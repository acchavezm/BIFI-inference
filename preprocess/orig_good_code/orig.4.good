<COMMENT> <NL> import sys <NEWLINE> <NL> ( N , K ) = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> have_been = set ( ) <NEWLINE> have_been_list = [ ] <NEWLINE> have_been . add ( 1 ) <NEWLINE> have_been_list . append ( 1 ) <NEWLINE> now_place = 1 <NEWLINE> while True : <NEWLINE> <INDENT> next_place = A [ now_place - 1 ] <NEWLINE> if next_place not in have_been : <NEWLINE> <INDENT> have_been . add ( next_place ) <NEWLINE> have_been_list . append ( next_place ) <NEWLINE> now_place = next_place <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> loop_start_index = have_been_list . index ( next_place ) <NEWLINE> <NL> loop_length = len ( have_been_list ) - loop_start_index <NEWLINE> <COMMENT> <NL> <NL> left_K = K - loop_start_index <NEWLINE> if left_K <= 0 : <NEWLINE> <INDENT> print ( have_been_list [ K ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> mod = left_K % loop_length <NEWLINE> print ( have_been_list [ mod + loop_start_index ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def fib_bad ( n ) : <NEWLINE> <INDENT> if not n or n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return fib_bad ( n - 2 ) + fib_bad ( n - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def fib_dp ( n ) : <NEWLINE> <INDENT> fib_list [ : 1 ] = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fib_list [ i ] = fib_list [ i - 2 ] + fib_list [ i - 1 ] <NEWLINE> <DEDENT> return fib_list . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> index = int ( _input [ 0 ] ) <NEWLINE> fib_list = [ None ] * index <NEWLINE> <COMMENT> <NL> print ( fib_dp ( index ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def isprime ( x ) : <NEWLINE> <INDENT> if x == 2 : return True <NEWLINE> if x % 2 == 0 : return False <NEWLINE> for i in range ( 3 , math . ceil ( math . sqrt ( x ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if isprime ( x ) : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> ad = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ad . get ( b , 0 ) * ( c - b ) <NEWLINE> print ( s ) <NEWLINE> ad [ c ] += ad . get ( b , 0 ) <NEWLINE> ad [ b ] = 0 <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> aa = input ( ) <NEWLINE> a = aa . split ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( int ( a [ i ] ) == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result *= int ( a [ i ] ) <NEWLINE> if ( result > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * ( n // i ) * ( n // i + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num_lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> s = sum ( num_lis ) <NEWLINE> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num += num_lis [ i ] <NEWLINE> ans += ( ( s - num ) * num_lis [ i ] ) % p <NEWLINE> <NL> <DEDENT> print ( ans % p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> k = 1 <NEWLINE> f = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> k = k * A [ i ] <NEWLINE> if k > 10 ** 18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> <NL> T = input ( ) <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if T [ 0 ] == <STRING> and T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T = <STRING> + T [ 1 : ] <NEWLINE> <COMMENT> <NL> <DEDENT> t = T [ 0 ] <NEWLINE> ans = [ ] <NEWLINE> if t == <STRING> and T [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif t == <STRING> and T [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( t ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( T ) ) : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( T [ i ] ) <NEWLINE> t = T [ i ] <NEWLINE> <DEDENT> <DEDENT> elif t == <STRING> and i < len ( T ) - 1 and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( T [ i ] ) <NEWLINE> t = T [ i ] <NEWLINE> <DEDENT> <DEDENT> elif t == <STRING> and i < len ( T ) - 1 and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( T [ i ] ) <NEWLINE> t = T [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( T [ i ] ) <NEWLINE> t = T [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from heapq import * <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> N , M = nm ( ) <NEWLINE> INF = 10 ** 18 <NEWLINE> def bfs ( start , edge ) : <NEWLINE> <INDENT> d = [ INF ] * ( N + 1 ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> d [ start ] = 0 <NEWLINE> q = [ ( 0 , start ) ] <NEWLINE> while ( len ( q ) != 0 ) : <NEWLINE> <INDENT> ci , i = heappop ( q ) <NEWLINE> for j in edge [ i ] : <NEWLINE> <INDENT> if ( d [ j ] > d [ i ] + 1 ) : <NEWLINE> <INDENT> d [ j ] = d [ i ] + 1 <NEWLINE> heappush ( q , ( d [ j ] , j ) ) <NEWLINE> ans [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> edge = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = nm ( ) <NEWLINE> edge [ A ] . append ( B ) <NEWLINE> edge [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> ans = bfs ( 1 , edge ) <NEWLINE> <NL> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if ( ans [ i ] == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if Y % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X * 2 > Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X * 4 >= Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( bisect . bisect_left ( A , b ) * ( N - bisect . bisect_right ( C , b ) ) for b in B ) ) <NEWLINE>
a , b , c = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> print ( a [ 0 ] . upper ( ) + b [ 0 ] . upper ( ) + c [ 0 ] . upper ( ) ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = set ( A ) <NEWLINE> Answer = 1 <NEWLINE> if 0 in B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> Answer *= A [ i ] <NEWLINE> if Answer > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( Answer ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import permutations , combinations , accumulate <NEWLINE> from functools import * <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> NIL = - 1 <NEWLINE> MOD = 2019 <NEWLINE> <NL> <STRING> <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> s_list = list ( map ( int , list ( S ) ) ) [ : : - 1 ] <NEWLINE> <NL> counts = [ 0 ] * MOD <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for s_element in s_list : <NEWLINE> <INDENT> num += s_element * d <NEWLINE> num %= MOD <NEWLINE> d *= 10 <NEWLINE> d %= MOD <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> primes = [ 0 , 0 ] + [ 1 ] * 49999 <NEWLINE> for i in range ( 2 , 225 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 50001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> values = [ i for i , k in enumerate ( primes ) if k ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> I = bisect . bisect ( values , n // 2 ) <NEWLINE> print ( sum ( primes [ n - v ] for v in values [ : I ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <NL> a . sort ( reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> cnt += a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( i // 2 ) <NEWLINE> cnt += a [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> t = dict ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t [ i ] = set ( ) <NEWLINE> <DEDENT> for a , b in ab : <NEWLINE> <INDENT> t [ a ] . add ( b ) <NEWLINE> t [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> s = set ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> s . add ( i ) <NEWLINE> tmp = [ i ] <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for ti in t [ v ] : <NEWLINE> <INDENT> if ti not in s : <NEWLINE> <INDENT> tmp . append ( ti ) <NEWLINE> q . append ( ti ) <NEWLINE> s . add ( ti ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , len ( tmp ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( x ) <NEWLINE> diff = [ ] <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> diff . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <NL> <DEDENT> diff = sorted ( diff , reverse = True ) <NEWLINE> <NL> dist = x [ - 1 ] - x [ 0 ] <NEWLINE> if dist < n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if m < n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dist -= diff [ i ] <NEWLINE> <NL> <DEDENT> print ( dist ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = i ( ) <NEWLINE> p = l ( ) <NEWLINE> count = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> ans , x = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * x <NEWLINE> x += a [ i ] <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def solve ( N : int , M : int ) : <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = [ ] <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> a , b = ( 0 , N // 2 - 1 ) <NEWLINE> <COMMENT> <NL> while a < b : <NEWLINE> <INDENT> ans . append ( ( a + 1 , b + 1 ) ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> a , b = ( N // 2 , N - 2 ) <NEWLINE> while a < b : <NEWLINE> <INDENT> ans . append ( ( a + 1 , b + 1 ) ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> if N % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> a , b = ( 0 , N // 2 ) <NEWLINE> while a < b : <NEWLINE> <INDENT> ans . append ( ( a + 1 , b + 1 ) ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> a , b = ( N // 2 + 1 , N - 1 ) <NEWLINE> while a < b : <NEWLINE> <INDENT> ans . append ( ( a + 1 , b + 1 ) ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( * ans [ i ] , sep = <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N , M ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( tmp , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import math <NEWLINE> ans = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( k , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
from collections import defaultdict <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> operations = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> temp = input ( ) . split ( <STRING> ) <NEWLINE> operations . append ( ( int ( temp [ 0 ] ) , int ( temp [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> for hoge in a : <NEWLINE> <INDENT> d [ hoge ] += 1 <NEWLINE> <NL> <DEDENT> initial_sum = 0 <NEWLINE> for key , value in d . items ( ) : <NEWLINE> <INDENT> initial_sum += key * value <NEWLINE> <NL> <DEDENT> for op in operations : <NEWLINE> <INDENT> target , goto = op <NEWLINE> <NL> before = goto * d [ goto ] + target * d [ target ] <NEWLINE> d [ goto ] += d [ target ] <NEWLINE> d [ target ] = 0 <NEWLINE> <NL> after = goto * d [ goto ] <NEWLINE> diff = after - before <NEWLINE> <NL> initial_sum += diff <NEWLINE> print ( initial_sum ) <NEWLINE> <NL> <DEDENT>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l = [ abs ( li [ i ] - li [ j ] ) + ans [ j ] for j in range ( max ( 0 , i - k ) , i ) ] <NEWLINE> <COMMENT> <NL> ans [ i ] = min ( l ) <NEWLINE> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> li [ b - 1 ] *= 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> li [ a - 1 ] *= 0 <NEWLINE> li [ b - 1 ] *= 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ a - 1 ] *= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = li . count ( 1 ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> s = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> <NL> while l < r : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ l ] == <STRING> and s [ r ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif s [ l ] != s [ r ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from itertools import chain <NEWLINE> <NL> <NL> def get_completed_board ( height , width ) : <NEWLINE> <INDENT> return [ str ( ( i + 1 ) % ( width * height ) ) for i in range ( width * height ) ] <NEWLINE> <NL> <NL> <DEDENT> def serialize_board ( board ) : <NEWLINE> <INDENT> return <STRING> . join ( board ) <NEWLINE> <NL> <NL> <DEDENT> def get_empty_pos ( board , width , height ) : <NEWLINE> <INDENT> for i , cell in enumerate ( board ) : <NEWLINE> <INDENT> if cell == <STRING> : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def get_all_possible_next_boards ( board , height , width , empty_pos = None ) : <NEWLINE> <INDENT> if empty_pos is None : <NEWLINE> <INDENT> empty_pos = get_empty_pos ( board , height , width ) <NEWLINE> <DEDENT> next_boards = [ ] <NEWLINE> x , y = empty_pos % width , empty_pos // height <NEWLINE> <COMMENT> <NL> if x > 0 : <NEWLINE> <INDENT> next_board = [ ] <NEWLINE> next_board . extend ( board ) <NEWLINE> dest_pos = empty_pos - 1 <NEWLINE> next_board [ empty_pos ] , next_board [ dest_pos ] = next_board [ dest_pos ] , next_board [ empty_pos ] <NEWLINE> next_boards . append ( ( next_board , dest_pos ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if x < width - 1 : <NEWLINE> <INDENT> next_board = [ ] <NEWLINE> next_board . extend ( board ) <NEWLINE> dest_pos = empty_pos + 1 <NEWLINE> next_board [ empty_pos ] , next_board [ dest_pos ] = next_board [ dest_pos ] , next_board [ empty_pos ] <NEWLINE> next_boards . append ( ( next_board , dest_pos ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if y > 0 : <NEWLINE> <INDENT> next_board = [ ] <NEWLINE> next_board . extend ( board ) <NEWLINE> dest_pos = empty_pos - height <NEWLINE> next_board [ empty_pos ] , next_board [ dest_pos ] = next_board [ dest_pos ] , next_board [ empty_pos ] <NEWLINE> next_boards . append ( ( next_board , dest_pos ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if y < height - 1 : <NEWLINE> <INDENT> next_board = [ ] <NEWLINE> next_board . extend ( board ) <NEWLINE> dest_pos = empty_pos + height <NEWLINE> next_board [ empty_pos ] , next_board [ dest_pos ] = next_board [ dest_pos ] , next_board [ empty_pos ] <NEWLINE> next_boards . append ( ( next_board , dest_pos ) ) <NEWLINE> <NL> <DEDENT> return next_boards <NEWLINE> <NL> <NL> <DEDENT> def resolve ( board , height , width ) : <NEWLINE> <COMMENT> <NL> <INDENT> known_serialized_boards = set ( [ serialize_board ( board ) ] ) <NEWLINE> <COMMENT> <NL> completed_board = get_completed_board ( width , height ) <NEWLINE> known_serialized_completed_boards = set ( [ serialize_board ( completed_board ) ] ) <NEWLINE> if known_serialized_boards & known_serialized_completed_boards : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> current_boards = [ ( board , None ) ] <NEWLINE> current_completed_boards = [ ( get_completed_board ( width , height ) , None ) ] <NEWLINE> step_count = 1 <NEWLINE> while step_count <= 45 : <NEWLINE> <COMMENT> <NL> <INDENT> next_boards = [ ] <NEWLINE> for board , empty_pos in current_boards : <NEWLINE> <COMMENT> <NL> <INDENT> tmp_next_boards = get_all_possible_next_boards ( board , height , width , empty_pos ) <NEWLINE> filtered_next_board = [ ] <NEWLINE> for board , empty_pos in tmp_next_boards : <NEWLINE> <INDENT> serialized_board = serialize_board ( board ) <NEWLINE> if serialized_board not in known_serialized_boards : <NEWLINE> <INDENT> known_serialized_boards . add ( serialized_board ) <NEWLINE> filtered_next_board . append ( ( board , empty_pos ) ) <NEWLINE> <DEDENT> <DEDENT> next_boards . extend ( filtered_next_board ) <NEWLINE> <NL> <DEDENT> if known_serialized_boards & known_serialized_completed_boards : <NEWLINE> <INDENT> return step_count <NEWLINE> <NL> <DEDENT> step_count = step_count + 1 <NEWLINE> current_boards = next_boards <NEWLINE> <NL> <COMMENT> <NL> next_completed_boards = [ ] <NEWLINE> for board , empty_pos in current_completed_boards : <NEWLINE> <COMMENT> <NL> <INDENT> tmp_next_boards = get_all_possible_next_boards ( board , height , width , empty_pos ) <NEWLINE> filtered_next_board = [ ] <NEWLINE> for board , empty_pos in tmp_next_boards : <NEWLINE> <INDENT> serialized_board = serialize_board ( board ) <NEWLINE> if serialized_board not in known_serialized_completed_boards : <NEWLINE> <INDENT> known_serialized_completed_boards . add ( serialized_board ) <NEWLINE> filtered_next_board . append ( ( board , empty_pos ) ) <NEWLINE> <DEDENT> <DEDENT> next_completed_boards . extend ( filtered_next_board ) <NEWLINE> <NL> <DEDENT> if known_serialized_boards & known_serialized_completed_boards : <NEWLINE> <INDENT> return step_count <NEWLINE> <DEDENT> step_count = step_count + 1 <NEWLINE> current_completed_boards = next_completed_boards <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> inputStr = sys . stdin . read ( ) <NEWLINE> lines = inputStr . split ( <STRING> ) <NEWLINE> lines = filter ( lambda line : line , lines ) <NEWLINE> board = list ( map ( lambda line : line . split ( <STRING> ) , lines ) ) <NEWLINE> height = len ( board ) <NEWLINE> width = len ( board [ 0 ] ) <NEWLINE> board = list ( chain . from_iterable ( board ) ) <NEWLINE> print ( resolve ( board , height , width ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( raw_input ( ) [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * H , = map ( int , input ( ) . split ( ) ) <NEWLINE> L = len ( H ) <NEWLINE> <NL> cnt = 0 <NEWLINE> prv = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if prv < H [ i ] : <NEWLINE> <INDENT> cnt += H [ i ] - prv <NEWLINE> <DEDENT> prv = H [ i ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> d = defaultdict ( list ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ int ( S [ i ] ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n1 in range ( 10 ) : <NEWLINE> <INDENT> if not d [ n1 ] : continue <NEWLINE> for n2 in range ( 10 ) : <NEWLINE> <INDENT> if not d [ n2 ] : continue <NEWLINE> if d [ n1 ] [ 0 ] > d [ n2 ] [ - 1 ] : continue <NEWLINE> for n3 in range ( 10 ) : <NEWLINE> <INDENT> if not d [ n3 ] : continue <NEWLINE> if d [ n1 ] [ 0 ] > d [ n3 ] [ - 1 ] or d [ n2 ] [ 0 ] > d [ n3 ] [ - 1 ] : continue <NEWLINE> for idx in d [ n2 ] : <NEWLINE> <INDENT> if idx > d [ n1 ] [ 0 ] and idx < d [ n3 ] [ - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> n , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> distT = [ - 1 ] * n <NEWLINE> distA = [ - 1 ] * n <NEWLINE> distT [ u ] = 0 <NEWLINE> distA [ v ] = 0 <NEWLINE> def dfs ( now , dist ) : <NEWLINE> <INDENT> for nxt in G [ now ] : <NEWLINE> <INDENT> if dist [ nxt ] != - 1 : continue <NEWLINE> dist [ nxt ] = dist [ now ] + 1 <NEWLINE> dfs ( nxt , dist ) <NEWLINE> <DEDENT> <DEDENT> dfs ( u , distT ) <NEWLINE> dfs ( v , distA ) <NEWLINE> <NL> mx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if distT [ i ] < distA [ i ] : <NEWLINE> <INDENT> mx = max ( mx , distA [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = mx - 1 <NEWLINE> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( i + j ) <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
l = [ ] <NEWLINE> m = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> k = 10 - ( i % 10 ) <NEWLINE> l . append ( i ) <NEWLINE> if k != 10 : <NEWLINE> <INDENT> m . append ( k ) <NEWLINE> <DEDENT> <DEDENT> m . sort ( ) <NEWLINE> if len ( m ) == 0 : <NEWLINE> <INDENT> print ( sum ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = sum ( m ) - m [ - 1 ] <NEWLINE> print ( sum ( l ) + s ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = 0 <NEWLINE> t = 1 <NEWLINE> a = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
N , M , * f = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> A = f [ : N ] <NEWLINE> B = f [ N : ] <NEWLINE> for i in range ( N - M + 1 ) : <NEWLINE> <INDENT> for j in range ( N - M + 1 ) : <NEWLINE> <INDENT> if A [ i ] [ j : j + M ] == B [ 0 ] : <NEWLINE> <INDENT> for k in range ( 1 , M ) : <NEWLINE> <INDENT> if A [ i + k ] [ j : j + M ] != B [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , ID , parent = - 1 , left = - 1 , right = - 1 , depth = 0 , children = [ ] ) : <NEWLINE> <INDENT> self . id = ID <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . depth = depth <NEWLINE> self . children = children <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> tree = [ Node ( i ) for i in range ( n ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> line = [ int ( l ) for l in input ( ) . split ( <STRING> ) ] <NEWLINE> ID = line [ 0 ] <NEWLINE> d = line [ 1 ] <NEWLINE> if d == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> children = line [ 2 : ] <NEWLINE> tree [ ID ] . children = children <NEWLINE> tree [ ID ] . left = children [ 0 ] <NEWLINE> for j in range ( 0 , d ) : <NEWLINE> <INDENT> tree [ children [ j ] ] . parent = ID <NEWLINE> if j < d - 1 : <NEWLINE> <INDENT> tree [ children [ j ] ] . right = children [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def setDepth ( u , p ) : <NEWLINE> <INDENT> tree [ u ] . depth = p <NEWLINE> if tree [ u ] . right != - 1 : <NEWLINE> <INDENT> setDepth ( tree [ u ] . right , p ) <NEWLINE> <DEDENT> if tree [ u ] . left != - 1 : <NEWLINE> <INDENT> setDepth ( tree [ u ] . left , p + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for node in tree : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> root = node . id <NEWLINE> <NL> <DEDENT> <DEDENT> setDepth ( root , 0 ) <NEWLINE> <NL> for node in tree : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> n_type = <STRING> <NEWLINE> <DEDENT> elif node . left != - 1 : <NEWLINE> <INDENT> n_type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_type = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( <NEWLINE> <INDENT> node . id , node . parent , node . depth , n_type , node . children ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import time <NEWLINE> start = time . time ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> m = m ^ a [ i ] <NEWLINE> <DEDENT> b . append ( m ) <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> m = m ^ a [ j - 1 ] <NEWLINE> m = m ^ a [ j ] <NEWLINE> b . append ( m ) <NEWLINE> <DEDENT> b = map ( str , b ) <NEWLINE> print ( <STRING> . join ( b ) ) <NEWLINE>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> m = [ ] <NEWLINE> <NL> <NL> for n in range ( M ) : <NEWLINE> <INDENT> m . append ( [ int ( s ) for s in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> minValue = min ( a ) + min ( b ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> discountPrice = a [ m [ i ] [ 0 ] - 1 ] + b [ m [ i ] [ 1 ] - 1 ] - m [ i ] [ 2 ] <NEWLINE> if discountPrice < minValue : <NEWLINE> <INDENT> minValue = discountPrice <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minValue ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > k - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
T = list ( input ( ) ) <NEWLINE> ex = None <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if ex == <STRING> or ex == None : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( T ) - 1 == i : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> or T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ex = T [ i ] <NEWLINE> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> t = [ ] <NEWLINE> o = 1 <NEWLINE> <NL> while o != 2 : <NEWLINE> <INDENT> if len ( t ) > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> t . append ( o ) <NEWLINE> o = a [ o - 1 ] <NEWLINE> <NL> <DEDENT> print ( len ( t ) ) <NEWLINE>
n , d , a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inp [ 1 ] = ( inp [ 1 ] - 1 ) // a + 1 <NEWLINE> e . append ( inp ) <NEWLINE> <DEDENT> e . sort ( ) <NEWLINE> sd = [ 0 for i in range ( n ) ] <NEWLINE> s = 0 <NEWLINE> mx = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> while e [ i ] [ 1 ] + s <= mx : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += sd [ i ] <NEWLINE> <DEDENT> while i < n and j < n and e [ j ] [ 0 ] <= e [ i ] [ 0 ] + 2 * d : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j < n : <NEWLINE> <INDENT> sd [ j ] += e [ i ] [ 1 ] + s - mx <NEWLINE> mx = e [ i ] [ 1 ] + s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mx = e [ i ] [ 1 ] + s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <COMMENT> <NL> mod = 2019 <NEWLINE> mod_list = [ 0 ] <NEWLINE> <COMMENT> <NL> ten = 1 <NEWLINE> <NL> for num in S [ : : - 1 ] : <NEWLINE> <INDENT> yo = ( num * ten + mod_list [ - 1 ] ) % mod <NEWLINE> <COMMENT> <NL> mod_list . append ( yo ) <NEWLINE> <COMMENT> <NL> ten = ( ten * 10 ) % mod <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * 2019 <NEWLINE> <NL> for yo in mod_list : <NEWLINE> <INDENT> cnt [ yo ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += cnt [ i ] * ( cnt [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> MOD = 998244353 <NEWLINE> <NL> <NL> class Combination : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , n_max , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . modinv = self . make_modinv_list ( n_max ) <NEWLINE> self . fac , self . facinv = self . make_factorial_list ( n_max ) <NEWLINE> <NL> <DEDENT> def __call__ ( self , n , r ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def make_factorial_list ( self , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> fac = [ 1 ] <NEWLINE> facinv = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fac . append ( fac [ i - 1 ] * i % self . mod ) <NEWLINE> facinv . append ( facinv [ i - 1 ] * self . modinv [ i ] % self . mod ) <NEWLINE> <DEDENT> return fac , facinv <NEWLINE> <NL> <DEDENT> def make_modinv_list ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> modinv = [ 0 ] * ( n + 1 ) <NEWLINE> modinv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> modinv [ i ] = self . mod - self . mod // i * modinv [ self . mod % i ] % self . mod <NEWLINE> <DEDENT> return modinv <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def power ( a , n ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> x = x * a % MOD <NEWLINE> <DEDENT> n >>= 1 <NEWLINE> a = a * a % MOD <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> combination = Combination ( 2 * 10 ** 5 + 1 , MOD ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> answer += M * power ( M - 1 , N - i - 1 ) * combination ( N - 1 , i ) % MOD <NEWLINE> <DEDENT> print ( answer % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 2 , n , 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ ( i + j ) >> 1 ] != s [ j ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D . sort ( ) <NEWLINE> A = list ( range ( D [ int ( N / 2 ) - 1 ] + 1 , D [ int ( N / 2 ) ] + 1 ) ) <NEWLINE> <NL> print ( len ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def update ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( N - 1 , i + x ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> K = min ( K , 100 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> A = update ( A ) <NEWLINE> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE>
<STRING> <NEWLINE> import math as f <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> result += f . gcd ( f . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> result += 3 * f . gcd ( f . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += 6 * f . gcd ( f . gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from math import floor <NEWLINE> <NL> while True : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = 10 ** 10 <NEWLINE> z = 0 <NEWLINE> while z ** 3 <= e : <NEWLINE> <INDENT> y = floor ( ( e - z ** 3 ) ** 0.5 ) <NEWLINE> x = e - y ** 2 - z ** 3 <NEWLINE> ans = min ( ans , x + y + z ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> max = a [ - 1 ] <NEWLINE> memo = [ <STRING> ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , a_i in enumerate ( a ) : <NEWLINE> <INDENT> if memo [ a_i ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a_i , max + 1 , a_i ) : <NEWLINE> <INDENT> memo [ j ] = <STRING> <NEWLINE> <DEDENT> if i != n - 1 and a_i == a [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> A = list ( range ( K // 2 , N + 1 , K ) ) <NEWLINE> B = list ( range ( K , N + 1 , K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = list ( range ( K , N + 1 , K ) ) <NEWLINE> B = [ ] <NEWLINE> <DEDENT> print ( len ( A ) ** 3 + len ( B ) ** 3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in An : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> mult = 1 <NEWLINE> for i in An : <NEWLINE> <INDENT> mult *= i <NEWLINE> if mult > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mult ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_A = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_A -= A [ i ] <NEWLINE> ans += A [ i ] * sum_A <NEWLINE> <DEDENT> ans %= 10 ** 9 + 7 <NEWLINE> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i ** 5 - ( - j ) ** 5 == x : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ 1 ] <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( 100 ) : <NEWLINE> <INDENT> A . append ( A [ - 1 ] * 26 ) <NEWLINE> <DEDENT> for n in range ( 1 , 100 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if N > A [ n ] : <NEWLINE> <INDENT> N -= A [ n ] <NEWLINE> continue <NEWLINE> <DEDENT> N -= 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> N , r = divmod ( N , 26 ) <NEWLINE> ret . append ( r ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> ret = [ chr ( ord ( <STRING> ) + x ) for x in ret ] <NEWLINE> return <STRING> . join ( reversed ( ret ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> un = UnionFind ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> un . union ( u , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if un . same ( u , v ) else 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> z = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> z . append ( c [ i ] [ 0 ] + c [ i ] [ 1 ] ) <NEWLINE> w . append ( c [ i ] [ 1 ] - c [ i ] [ 0 ] ) <NEWLINE> <DEDENT> ans = max ( max ( z ) - min ( z ) , max ( w ) - min ( w ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def mae_syori ( M ) : <NEWLINE> <INDENT> D = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> if D [ i ] != 0 : continue <NEWLINE> <COMMENT> <NL> for j in range ( i * 2 , M + 1 , i ) : <NEWLINE> <INDENT> if D [ j ] == 0 : <NEWLINE> <INDENT> D [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return D <NEWLINE> <NL> <DEDENT> def p_bunkai ( K ) : <NEWLINE> <INDENT> assert 2 <= K <= len ( D ) - 1 <NEWLINE> k = K <NEWLINE> ret = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if D [ k ] == 0 : <NEWLINE> <INDENT> ret . append ( ( k , 1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = D [ k ] <NEWLINE> count = 0 <NEWLINE> while k % p == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> k //= p <NEWLINE> <DEDENT> ret . append ( ( p , count ) ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def my_gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return my_gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> c_gcd = A [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> c_gcd = my_gcd ( c_gcd , a ) <NEWLINE> <NL> <DEDENT> if c_gcd == 1 : <NEWLINE> <INDENT> max_A = max ( A ) <NEWLINE> D = mae_syori ( max_A ) <NEWLINE> yakusu = set ( ) <NEWLINE> ok = True <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 1 : continue <NEWLINE> p_bunkai_result = p_bunkai ( a ) <NEWLINE> p_list = [ p [ 0 ] for p in p_bunkai_result ] <NEWLINE> for p in p_list : <NEWLINE> <INDENT> if p not in yakusu : <NEWLINE> <INDENT> yakusu . add ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> y = 1 <NEWLINE> <NL> while y <= n : <NEWLINE> <INDENT> if ( y % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> % y , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = y <NEWLINE> while ( p != 0 ) : <NEWLINE> <INDENT> if ( p % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> % y , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> p //= 10 <NEWLINE> <DEDENT> <DEDENT> y += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
import sys <NEWLINE> def func ( w , result ) : <NEWLINE> <INDENT> list = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] <NEWLINE> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> if w == list [ i ] : <NEWLINE> <INDENT> result . append ( list [ i ] ) <NEWLINE> w = w - list [ i ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if list [ i ] > w : <NEWLINE> <INDENT> result . append ( list [ i - 1 ] ) <NEWLINE> w = w - list [ i - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> elif w > 512 : <NEWLINE> <INDENT> result . append ( 512 ) <NEWLINE> w = w - 512 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return w <NEWLINE> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> w = int ( line ) <NEWLINE> while w > 0 : <NEWLINE> <INDENT> w = func ( w , result ) <NEWLINE> <DEDENT> i = len ( result ) - 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> print ( result [ i ] , end = <STRING> ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> print ( result [ 0 ] ) <NEWLINE> del ( result ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> slen = len ( s ) <NEWLINE> tlen = len ( t ) <NEWLINE> <NL> i = tlen <NEWLINE> n = 0 <NEWLINE> a = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> max_count = 0 <NEWLINE> while i <= slen : <NEWLINE> <INDENT> ps = s [ n : i + tlen - 1 ] <NEWLINE> count = 0 <NEWLINE> for j in range ( tlen ) : <NEWLINE> <INDENT> if ps [ j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if max_count < count : <NEWLINE> <INDENT> max_count = count <NEWLINE> <DEDENT> n += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( tlen - max_count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <NL> <DEDENT> for v in A : <NEWLINE> <INDENT> d [ v ] += 1 <NEWLINE> <NL> <DEDENT> for v in d . values ( ) : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
def main ( n , a_ ) : <NEWLINE> <INDENT> from collections import defaultdict <NEWLINE> lr = [ [ i + ai , i - ai ] for i , ai in enumerate ( a_ ) ] <NEWLINE> rs = defaultdict ( lambda : 0 ) <NEWLINE> ls = defaultdict ( lambda : 0 ) <NEWLINE> ans = 0 <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> rs [ r ] += 1 <NEWLINE> ls [ l ] += 1 <NEWLINE> <DEDENT> for k in rs . keys ( ) : <NEWLINE> <INDENT> ans += rs [ k ] * ls [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> main ( n , a_ ) <NEWLINE> <DEDENT>
import sys <NEWLINE> t = list ( input ( ) ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if len ( t ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if t [ 1 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == len ( t ) - 1 : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> t [ i + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> s = pin ( ) [ : - 1 ] <NEWLINE> K = int ( pin ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) - i + 1 ) : <NEWLINE> <INDENT> d . append ( s [ j : j + i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = sorted ( list ( set ( d ) ) ) <NEWLINE> print ( ans [ K - 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
import sys <NEWLINE> inf = 10 ** 9 <NEWLINE> sys . setrecursionlimit ( inf ) <NEWLINE> <NL> <NL> def connect ( signs , to_room , from_room ) : <NEWLINE> <INDENT> signs [ to_room ] [ 2 ] . add ( from_room ) <NEWLINE> signs [ from_room ] [ 2 ] . add ( to_room ) <NEWLINE> return signs <NEWLINE> <NL> <NL> <DEDENT> def update ( signs , to_room , from_room ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> signs [ from_room ] [ 0 ] = signs [ to_room ] [ 0 ] + 1 <NEWLINE> signs [ from_room ] [ 1 ] = to_room <NEWLINE> <COMMENT> <NL> for from_from_room in signs [ from_room ] [ 2 ] : <NEWLINE> <INDENT> if signs [ from_room ] [ 0 ] < signs [ from_from_room ] [ 0 ] - 1 : <NEWLINE> <INDENT> signs = update ( signs , from_room , from_from_room ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for from_to_room in signs [ from_room ] [ 2 ] : <NEWLINE> <INDENT> if from_to_room and signs [ from_room ] [ 0 ] < signs [ from_to_room ] [ 0 ] - 1 : <NEWLINE> <INDENT> signs = update ( signs , from_room , from_to_room ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return signs <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * ab = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ab = [ ab [ 2 * i : 2 * ( i + 1 ) ] for i in range ( m ) ] <NEWLINE> <NL> to = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ inf ] * n <NEWLINE> pre = [ None ] * n <NEWLINE> queue = [ 0 ] <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . pop ( 0 ) <NEWLINE> for u in to [ v ] : <NEWLINE> <INDENT> if dist [ u ] != inf : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ u ] = dist [ v ] + 1 <NEWLINE> pre [ u ] = v <NEWLINE> queue . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> pre = [ i + 1 for i in pre ] <NEWLINE> ans = <STRING> . join ( [ str ( i ) for i in [ <STRING> ] + pre [ 1 : ] ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE> return ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> lst = [ 0 ] * N <NEWLINE> ans = N <NEWLINE> <NL> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst [ 0 ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> lst [ i ] = lst [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ i ] = lst [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> left = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = i - lst [ i - 1 ] <NEWLINE> <DEDENT> right = lst [ N - 1 ] - lst [ i ] <NEWLINE> <NL> if left + right < ans : <NEWLINE> <INDENT> ans = left + right <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , Y , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> P = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) [ : X ] <NEWLINE> Q = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) [ : Y ] <NEWLINE> R = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) [ : X + Y ] <NEWLINE> i , j = X - 1 , Y - 1 <NEWLINE> for r in R : <NEWLINE> <INDENT> if i == - 1 and j == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif j == - 1 : <NEWLINE> <INDENT> if r > P [ i ] : <NEWLINE> <INDENT> P [ i ] = r <NEWLINE> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == - 1 : <NEWLINE> <INDENT> if r > Q [ j ] : <NEWLINE> <INDENT> Q [ j ] = r <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif P [ i ] > Q [ j ] : <NEWLINE> <INDENT> if r > Q [ j ] : <NEWLINE> <INDENT> Q [ j ] = r <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if r > P [ i ] : <NEWLINE> <INDENT> P [ i ] = r <NEWLINE> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( P ) + sum ( Q ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> w = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> w . append ( w [ - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> w1 = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( n - 1 - i ) % 2 == 0 : <NEWLINE> <INDENT> w1 [ i ] = A [ i ] <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> w1 [ i ] += w1 [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( x ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = n + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if A [ n - m ] <= x : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 2 * m - 1 > n : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ n - m ] - x >= x - A [ n - 2 * m + 1 ] : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = w [ - 1 ] - w [ n - l - 1 ] <NEWLINE> if n - 2 * l - 1 >= 0 : <NEWLINE> <INDENT> ans += w1 [ n - 2 * l - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> solve ( int ( input ( ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> for b in range ( k ) : <NEWLINE> <INDENT> x = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( k ) : <NEWLINE> <INDENT> s += math . gcd ( x , c + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 -= 1 <NEWLINE> y1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> y2 -= 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> c = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> c . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> fresh = [ True ] * ( H * W ) <NEWLINE> count = [ - 1 ] * ( H * W ) <NEWLINE> <NL> queue = [ x1 * W + y1 ] <COMMENT> <NEWLINE> count [ x1 * W + y1 ] = 0 <COMMENT> <NEWLINE> fresh [ x1 * W + y1 ] = False <NEWLINE> n = [ ] <COMMENT> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( c [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> fresh [ i * W + j ] = False <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> step = 1 <NEWLINE> status = True <NEWLINE> while status : <NEWLINE> <INDENT> if ( len ( queue ) > 0 ) : <NEWLINE> <INDENT> pivot = queue . pop ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for g in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( ( pivot + g ) % W != 0 and fresh [ pivot + g ] ) : <NEWLINE> <INDENT> n . append ( pivot + g ) <NEWLINE> count [ pivot + g ] = step <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for g in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( ( pivot - g ) % W != W - 1 and fresh [ pivot - g ] ) : <NEWLINE> <INDENT> n . append ( pivot - g ) <NEWLINE> count [ pivot - g ] = step <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for g in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( ( pivot + g * W ) // W < H and fresh [ pivot + g * W ] ) : <NEWLINE> <INDENT> n . append ( pivot + g * W ) <NEWLINE> count [ pivot + g * W ] = step <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for g in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( ( pivot - g * W ) >= 0 and fresh [ pivot - g * W ] ) : <NEWLINE> <INDENT> n . append ( pivot - g * W ) <NEWLINE> count [ pivot - g * W ] = step <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif ( len ( n ) > 0 ) : <NEWLINE> <INDENT> n = sorted ( n ) <NEWLINE> last = - 1 <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if last != n [ i ] : <NEWLINE> <INDENT> l . append ( n [ i ] ) <NEWLINE> last = n [ i ] <NEWLINE> <DEDENT> <DEDENT> for e in l : <NEWLINE> <INDENT> fresh [ e ] = False <NEWLINE> <DEDENT> queue = l <NEWLINE> n = [ ] <NEWLINE> <COMMENT> <NL> step += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> status = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count [ x2 * W + y2 ] ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a >= 10 ** 80 or b >= 10 ** 80 or a + b >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque , OrderedDict <NEWLINE> <NL> class Puzzle : <NEWLINE> <INDENT> def __init__ ( self , field = None , path = <STRING> ) : <NEWLINE> <INDENT> self . f = field <NEWLINE> self . space = None <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> if self . f [ i ] == 9 : <NEWLINE> <INDENT> self . space = i <NEWLINE> <DEDENT> <DEDENT> self . path = path <NEWLINE> <NL> <DEDENT> def __lt__ ( self , pzl ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if self . f [ i ] == pzl . f [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return self . f [ i ] > pzl . f [ i ] <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def __gt__ ( self , pzl ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if self . f [ i ] == pzl . f [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return self . f [ i ] < pzl . f [ i ] <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> dir = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def is_target ( pzl ) : <NEWLINE> <INDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if pzl . f [ i ] != i + 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def bfs ( pzl ) : <NEWLINE> <INDENT> queue = deque ( [ ] ) <NEWLINE> V = { } <NEWLINE> pzl . path = <STRING> <NEWLINE> queue . append ( pzl ) <NEWLINE> V [ str ( pzl . f ) ] = True <NEWLINE> if is_target ( pzl ) : return pzl . path <NEWLINE> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> sx , sy = u . space // 3 , u . space % 3 <NEWLINE> for r in range ( 4 ) : <NEWLINE> <INDENT> tx , ty = sx + dx [ r ] , sy + dy [ r ] <NEWLINE> if tx < 0 or ty < 0 or tx >= 3 or ty >= 3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = Puzzle ( field = [ u . f [ i ] for i in range ( 9 ) ] , path = u . path ) <NEWLINE> v . f [ u . space ] , v . f [ tx * 3 + ty ] = v . f [ tx * 3 + ty ] , v . f [ u . space ] <NEWLINE> v . space = tx * 3 + ty <NEWLINE> if str ( v . f ) not in V : <NEWLINE> <INDENT> V [ str ( v . f ) ] = True <NEWLINE> v . path += dir [ r ] <NEWLINE> if is_target ( v ) : return v . path <NEWLINE> queue . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> field = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> field . extend ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if field [ i ] == 0 : field [ i ] = 9 <NEWLINE> <NL> <DEDENT> pzl = Puzzle ( field = field ) <NEWLINE> ans = bfs ( pzl ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> <NL> <NL>
s = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> amari = [ 0 ] * 2019 <NEWLINE> amari [ 0 ] += 1 <NEWLINE> tmp = 0 <NEWLINE> digit = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += int ( s [ n - i - 1 ] ) * digit <NEWLINE> tmp %= 2019 <NEWLINE> amari [ tmp ] += 1 <NEWLINE> digit = ( digit * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in amari : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
M = 10 ** 6 + 1 <NEWLINE> _ , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * M <NEWLINE> for i in sorted ( l ) : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> if a [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , M , i ) : a [ j ] += 2 <NEWLINE> <DEDENT> <DEDENT> print ( a . count ( 1 ) ) <NEWLINE>
p = d = 2019 <NEWLINE> z = [ 0 ] * p <NEWLINE> for i , j in enumerate ( input ( ) [ : : - 1 ] ) : <NEWLINE> <INDENT> d = d + int ( j ) * pow ( 10 , i , p ) <NEWLINE> z [ d % p ] += 1 <NEWLINE> <DEDENT> r = z [ 0 ] <NEWLINE> for i in z : <NEWLINE> <INDENT> r += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> dp = [ 1 ] + [ 0 ] * 2019 <NEWLINE> now = 0 <NEWLINE> i = 1 <NEWLINE> <NL> for c in reversed ( s ) : <NEWLINE> <INDENT> now = ( now + i * int ( c ) ) % 2019 <NEWLINE> dp [ now ] += 1 <NEWLINE> i *= 10 <NEWLINE> i %= 2019 <NEWLINE> <NL> <DEDENT> ans = sum ( [ i * ( i - 1 ) / 2 for i in dp ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = s * a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> s = 0 <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
from functools import reduce <NEWLINE> t = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for k in A : <NEWLINE> <INDENT> ans *= k <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = sorted ( [ input ( ) for i in range ( N ) ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ i - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> loopnum = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( loopnum ) : <NEWLINE> <NL> <INDENT> chknum = int ( input ( ) ) <NEWLINE> rootnum = int ( math . sqrt ( chknum ) ) <NEWLINE> <NL> for j in range ( 2 , rootnum + 1 ) : <NEWLINE> <INDENT> if chknum % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . data = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def insert ( node , x ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return Node ( x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif x < node . data : <NEWLINE> <INDENT> node . left = Node . insert ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = Node . insert ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def find ( node , x ) : <NEWLINE> <INDENT> if node . data == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif node . left != None and node . data > x : <NEWLINE> <INDENT> return Node . find ( node . left , x ) <NEWLINE> <DEDENT> elif node . right != None and node . data < x : <NEWLINE> <INDENT> return Node . find ( node . right , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( node , x ) : <NEWLINE> <INDENT> if node . data == x : <NEWLINE> <INDENT> if ( node . left == None ) and ( node . right == None ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif node . left == None : <NEWLINE> <INDENT> return node . right <NEWLINE> <DEDENT> elif node . right == None : <NEWLINE> <INDENT> return node . left <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . data = Node . serch_min ( node . right ) <NEWLINE> node . right = Node . delete_min ( node . right ) <NEWLINE> return node <NEWLINE> <DEDENT> <DEDENT> elif node . data > x : <NEWLINE> <INDENT> node . left = Node . delete ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = Node . delete ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def serch_min ( node ) : <NEWLINE> <INDENT> if node . left != None : <NEWLINE> <INDENT> return Node . serch_min ( node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . data <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_min ( node ) : <NEWLINE> <INDENT> if node . left == None : <NEWLINE> <INDENT> return node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . left = Node . delete_min ( node . left ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder_print ( node ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = <STRING> <NEWLINE> if node . left != None : <NEWLINE> <INDENT> s += Node . inorder_print ( node . left ) <NEWLINE> <DEDENT> s += <STRING> + str ( node . data ) <NEWLINE> if node . right != None : <NEWLINE> <INDENT> s += Node . inorder_print ( node . right ) <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> def preorder_print ( node ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = <STRING> <NEWLINE> s += <STRING> + str ( node . data ) <NEWLINE> if node . left != None : <NEWLINE> <INDENT> s += Node . preorder_print ( node . left ) <NEWLINE> <DEDENT> if node . right != None : <NEWLINE> <INDENT> s += Node . preorder_print ( node . right ) <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> <DEDENT> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> self . root = Node . insert ( self . root , x ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if Node . find ( self . root , x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> self . root = Node . delete ( self . root , x ) <NEWLINE> <NL> <DEDENT> def print_tree ( self ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = Node . inorder_print ( self . root ) <NEWLINE> print ( s ) <NEWLINE> s = Node . preorder_print ( self . root ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> T = BinaryTree ( ) <NEWLINE> m = int ( sys . stdin . readline ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> T . print_tree ( ) <NEWLINE> <DEDENT> elif s . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . find ( int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif s . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . delete ( int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = int ( s . split ( ) [ 1 ] ) <NEWLINE> T . insert ( z ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += ( y * ( y + 1 ) * i ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> total = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ok = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( ok ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ok [ int ( s [ i ] ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ok [ int ( s [ i ] ) ] = 1 <NEWLINE> nd = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if sum ( nd ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if nd [ int ( s [ j ] ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nd [ int ( s [ j ] ) ] = 1 <NEWLINE> rd = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if sum ( rd ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if rd [ int ( s [ k ] ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rd [ int ( s [ k ] ) ] = 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def make_sumlist ( book_list ) : <NEWLINE> <INDENT> sumnum = 0 <NEWLINE> container = [ 0 ] <NEWLINE> for i in book_list : <NEWLINE> <INDENT> container . append ( sumnum + i ) <NEWLINE> sumnum += i <NEWLINE> <DEDENT> return container <NEWLINE> <NL> <DEDENT> total_a = make_sumlist ( a ) <NEWLINE> total_b = make_sumlist ( b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def readable ( r ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r > n + m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if r == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> max_book = 100000000000 <NEWLINE> for a_n in range ( max ( 0 , r - m ) , min ( n , r ) + 1 ) : <NEWLINE> <INDENT> b_n = r - a_n <NEWLINE> <COMMENT> <NL> book_sum = total_a [ a_n ] + total_b [ b_n ] <NEWLINE> <COMMENT> <NL> max_book = min ( max_book , book_sum ) <NEWLINE> <DEDENT> if max_book <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def nibuntansaku ( start , end ) : <NEWLINE> <INDENT> if start == end : <NEWLINE> <INDENT> return start <NEWLINE> <DEDENT> middle = ( start + end ) // 2 + 1 <NEWLINE> if readable ( middle ) : <NEWLINE> <INDENT> start = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = middle - 1 <NEWLINE> <DEDENT> return nibuntansaku ( start , end ) <NEWLINE> <NL> <DEDENT> print ( nibuntansaku ( 0 , k ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> fr , to = map ( lambda a : int ( a ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ fr ] . append ( to ) <NEWLINE> edges [ to ] . append ( fr ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> L = [ - 10 ** 18 ] <NEWLINE> <NL> def search ( now , pr ) : <NEWLINE> <INDENT> a = A [ now ] <NEWLINE> i = bisect_left ( L , a ) <NEWLINE> isAppended = False <NEWLINE> prevValue = - 1 <NEWLINE> <NL> if i == len ( L ) : <NEWLINE> <INDENT> L . append ( a ) <NEWLINE> isAppended = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prevValue = L [ i ] <NEWLINE> if L [ i ] > a : <NEWLINE> <INDENT> L [ i ] = a <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ now ] = len ( L ) - 1 <NEWLINE> <NL> for to in edges [ now ] : <NEWLINE> <INDENT> if to == pr : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> search ( to , now ) <NEWLINE> <NL> <DEDENT> if isAppended : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] = prevValue <NEWLINE> <NL> <DEDENT> <DEDENT> search ( 0 , - 1 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> if s [ 0 ] < s [ 1 ] : <NEWLINE> <INDENT> tmp = s [ 0 ] <NEWLINE> s [ 0 ] = s [ 1 ] <NEWLINE> s [ 1 ] = tmp <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> x = int ( s [ 0 ] ) % int ( s [ 1 ] ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s [ 0 ] = s [ 1 ] <NEWLINE> s [ 1 ] = x <NEWLINE> <NL> <DEDENT> print ( s [ 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = r * g * b <COMMENT> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ 2 * j - i ] and S [ j ] != S [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bad = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bad . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> dp = [ 0 for x in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> idx = 0 <NEWLINE> if m > 0 and bad [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> idx = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if idx < m and i == bad [ idx ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> idx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL> <NL> <NL>
while 1 : <NEWLINE> <INDENT> W , H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if W == 0 : break <NEWLINE> <NL> C = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> <NL> def work ( x , y ) : <NEWLINE> <INDENT> ax = [ - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 ] <NEWLINE> ay = [ - 1 , - 1 , - 1 , 0 , 0 , 1 , 1 , 1 ] <NEWLINE> <NL> if C [ y ] [ x ] != 1 : return False <NEWLINE> stack = [ ( x , y ) ] <NEWLINE> <NL> while len ( stack ) > 0 : <NEWLINE> <INDENT> s = stack . pop ( - 1 ) <NEWLINE> C [ s [ 1 ] ] [ s [ 0 ] ] = - 1 <COMMENT> <NEWLINE> <NL> for _x in [ s [ 0 ] + _x for _x in ax ] : <NEWLINE> <INDENT> for _y in [ s [ 1 ] + _y for _y in ay ] : <NEWLINE> <INDENT> if 0 <= _x < W and 0 <= _y < H and C [ _y ] [ _x ] == 1 : <NEWLINE> <INDENT> stack . append ( ( _x , _y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> for x in range ( W ) : <NEWLINE> <INDENT> for y in range ( H ) : <NEWLINE> <INDENT> cnt += work ( x , y ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> <NL> t = t . replace ( <STRING> , <STRING> ) <NEWLINE> print ( t ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import math <NEWLINE> <NL> h = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def parent ( node ) : <NEWLINE> <INDENT> return math . floor ( node / 2 ) <NEWLINE> <NL> <DEDENT> def left ( node ) : <NEWLINE> <INDENT> return 2 * node <NEWLINE> <NL> <DEDENT> def right ( node ) : <NEWLINE> <INDENT> return 2 * node + 1 <NEWLINE> <NL> <DEDENT> def max_heapify ( a , i ) : <NEWLINE> <INDENT> l = left ( i ) <NEWLINE> r = right ( i ) <NEWLINE> if l <= h and a [ l - 1 ] > a [ i - 1 ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= h and a [ r - 1 ] > a [ largest - 1 ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> a [ i - 1 ] , a [ largest - 1 ] = a [ largest - 1 ] , a [ i - 1 ] <NEWLINE> max_heapify ( a , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def build_max_heap ( a ) : <NEWLINE> <INDENT> for i in list ( range ( 1 , h // 2 + 1 ) ) [ : : - 1 ] : <NEWLINE> <INDENT> max_heapify ( a , i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> build_max_heap ( a ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
from bisect import * <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_ = [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> A_ . append ( A_ [ - 1 ] + a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> b_sum = 0 <NEWLINE> ans = 0 <NEWLINE> b_cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if b_sum > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = K - b_sum <NEWLINE> ans = max ( bisect_right ( A_ , k ) - 1 + b_cnt , ans ) <NEWLINE> <COMMENT> <NL> if b_cnt == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b_sum += B [ b_cnt ] <NEWLINE> b_cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
maxa = - ( 10 ** 10 ) <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> i = min ( n , b - 1 ) <NEWLINE> maxa = max ( ( ( a * i ) // b ) - a * ( i // b ) , maxa ) <NEWLINE> print ( maxa ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> imput = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = str ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> l = len ( n ) <NEWLINE> <NL> mod = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> mod += int ( n [ i ] ) <NEWLINE> mod %= 9 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if mod == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> E = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if i not in D : <NEWLINE> <INDENT> E . append ( i ) <NEWLINE> <DEDENT> <DEDENT> E = sorted ( E ) <NEWLINE> N = str ( N ) <NEWLINE> ind = len ( N ) <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if int ( N [ i ] ) not in E : <NEWLINE> <INDENT> ind = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ind == len ( N ) : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> x = <STRING> <NEWLINE> for i in range ( ind , - 1 , - 1 ) : <NEWLINE> <INDENT> n = int ( N [ i ] ) <NEWLINE> for e in E : <NEWLINE> <INDENT> if e > n : <NEWLINE> <INDENT> x = N [ : i ] + str ( e ) + str ( E [ 0 ] ) * ( len ( N ) - i - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : break <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> if E [ 0 ] > 0 : <NEWLINE> <INDENT> a = E [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = E [ 1 ] <NEWLINE> <DEDENT> x = str ( a ) + str ( E [ 0 ] ) * len ( N ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ [ ] for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> B . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> _A = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> _A . extend ( [ B [ i ] [ 1 ] ] * B [ i ] [ 0 ] ) <NEWLINE> cnt += B [ i ] [ 0 ] <NEWLINE> if cnt > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> A += _A <NEWLINE> A . sort ( reverse = True ) <NEWLINE> print ( sum ( A [ : n ] ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MIN = - 10 ** 9 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = [ 0 ] * N <NEWLINE> for x in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> * B , = map ( int , input ( ) . split ( ) ) <NEWLINE> cumsum_A , cumsum_B = [ 0 ] + list ( accumulate ( A ) ) , [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if cumsum_A [ i ] > K : break <NEWLINE> while cumsum_A [ i ] + cumsum_B [ j ] > K : j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] <NEWLINE> ans_ = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> ans_ += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ans_ ) <NEWLINE> ans_ = 0 <NEWLINE> <DEDENT> <DEDENT> ans . append ( ans_ ) <NEWLINE> print ( max ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> ans += mods [ current % 2019 ] <NEWLINE> mods [ current % 2019 ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> dic = dict ( ) <NEWLINE> dic2 = dict ( ) <NEWLINE> P = list ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if p not in dic . keys ( ) : <NEWLINE> <INDENT> dic [ p ] = [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ p ] . append ( y ) <NEWLINE> <DEDENT> P . append ( ( p , y ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for key in dic . keys ( ) : <NEWLINE> <INDENT> dic [ key ] . sort ( ) <NEWLINE> <NL> <DEDENT> for key in dic . keys ( ) : <NEWLINE> <INDENT> for i in range ( len ( dic [ key ] ) ) : <NEWLINE> <INDENT> dic2 [ dic [ key ] [ i ] ] = i + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> p , y = P [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> ans += <STRING> * ( 6 - len ( str ( p ) ) ) + str ( p ) <NEWLINE> <COMMENT> <NL> t = dic2 [ y ] <NEWLINE> ans += <STRING> * ( 6 - len ( str ( t ) ) ) + str ( t ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 2 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = factorization ( n ) <NEWLINE> B = Counter ( A ) <NEWLINE> count = 0 <NEWLINE> for key , value in B . items ( ) : <NEWLINE> <INDENT> for i in range ( 1 , value + 1 ) : <NEWLINE> <INDENT> if n % ( key ** i ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> n //= ( key ** i ) <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A += [ a ] <NEWLINE> B += [ b ] <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> index = int ( ( N - 1 ) / 2 ) <NEWLINE> minX = A [ index ] <NEWLINE> maxX = B [ index ] <NEWLINE> ans = maxX - minX + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = int ( N / 2 ) <NEWLINE> minX1 = A [ index - 1 ] <NEWLINE> minX2 = A [ index ] <NEWLINE> maxX1 = B [ index - 1 ] <NEWLINE> maxX2 = B [ index ] <NEWLINE> minX = minX1 + minX2 <NEWLINE> maxX = maxX1 + maxX2 <NEWLINE> ans = maxX - minX + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for s in N : <NEWLINE> <INDENT> cnt += int ( s ) <NEWLINE> cnt %= 9 <NEWLINE> <DEDENT> ans = <STRING> if cnt % 9 == 0 else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> memo = { } <NEWLINE> <NL> <NL> def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n in memo : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> memo [ n ] = 1 + f ( n % popcount ( n ) ) <NEWLINE> return memo [ n ] <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , X ) : <NEWLINE> <INDENT> Xint = int ( X , 2 ) <NEWLINE> p = popcount ( Xint ) <NEWLINE> if 1 < p : <NEWLINE> <INDENT> x1 = Xint % ( p - 1 ) <NEWLINE> <DEDENT> x2 = Xint % ( p + 1 ) <NEWLINE> ans = [ ] <NEWLINE> b = 1 <NEWLINE> if 1 < p : <NEWLINE> <INDENT> bmod1 = b % ( p - 1 ) <NEWLINE> <DEDENT> bmod2 = b % ( p + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if 1 < p : <NEWLINE> <INDENT> ans . append ( 1 + f ( ( x1 - bmod1 ) % ( p - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 1 + f ( ( x2 + bmod2 ) % ( p + 1 ) ) ) <NEWLINE> <DEDENT> b <<= 1 <NEWLINE> if 1 < p : <NEWLINE> <INDENT> bmod1 = bmod1 * 2 % ( p - 1 ) <NEWLINE> <DEDENT> bmod2 = bmod2 * 2 % ( p + 1 ) <NEWLINE> <NL> <DEDENT> return list ( reversed ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> for x in solve ( N , X ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if ( i ** 5 ) - ( j ** 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A [ 0 ] > K and B [ 0 ] > K : print ( 0 ) ; exit ( ) <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if Asum [ - 1 ] + A [ i ] <= K : <NEWLINE> <INDENT> Asum . append ( Asum [ - 1 ] + A [ i ] ) <NEWLINE> <DEDENT> else : break <NEWLINE> <NL> <DEDENT> Bsum = [ 0 ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if Bsum [ - 1 ] + B [ j ] <= K : <NEWLINE> <INDENT> Bsum . append ( Bsum [ - 1 ] + B [ j ] ) <NEWLINE> <DEDENT> else : break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> C = [ ] <NEWLINE> for i in range ( len ( Asum ) ) : <NEWLINE> <INDENT> C . append ( bisect . bisect ( Bsum , K - Asum [ i ] ) + i - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( max ( C ) ) <NEWLINE> <COMMENT> <NL>
N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ i ] = A [ i ] ** 2 <NEWLINE> <DEDENT> s1 , s2 = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s1 += A [ i ] <NEWLINE> s2 += B [ i ] <NEWLINE> <DEDENT> s1 = s1 ** 2 <NEWLINE> ans = ( s1 - s2 ) // 2 % mod <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , * i = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = i [ : n ] <NEWLINE> _ = i [ n ] <NEWLINE> s = sum ( a ) <NEWLINE> <NL> m = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for x in a : <NEWLINE> <INDENT> m [ x ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for b , c in zip ( * [ iter ( i [ n + 1 : ] ) ] * 2 ) : <NEWLINE> <INDENT> m [ c ] += m [ b ] <NEWLINE> s += ( c - b ) * m [ b ] <NEWLINE> m [ b ] = 0 <NEWLINE> ans . append ( s ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = [ ] <NEWLINE> st = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sa . append ( a [ i ] + i ) <NEWLINE> st . append ( i - a [ i ] ) <NEWLINE> <DEDENT> c = defaultdict ( int ) <NEWLINE> c = Counter ( st ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum = sum + c [ sa [ i ] ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ None ] * n <NEWLINE> cur = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if visited [ cur ] is None : <NEWLINE> <INDENT> visited [ cur ] = i <NEWLINE> cur = a [ cur ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( cur + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> k -= i <NEWLINE> k %= i - visited [ cur ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> cur = a [ cur ] - 1 <NEWLINE> <NL> <DEDENT> print ( cur + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = n - 1 <NEWLINE> <NL> p = int ( m ** ( 1 / 2 ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( 1 , p + 1 ) : <NEWLINE> <INDENT> c += ( m // i - ( i - 1 ) ) * 2 - 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s [ input ( ) ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result_list = [ 0 ] * N <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> result_list [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> result_list_str = [ str ( i ) for i in result_list ] <NEWLINE> print ( <STRING> . join ( result_list_str ) ) <NEWLINE>
z = input ( ) <NEWLINE> x , y = tuple ( z . split ( ) ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import networkx as nx <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> G = nx . Graph ( ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> G . add_edges_from ( edge ) <NEWLINE> pre = nx . predecessor ( G , 1 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( pre [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def dw_heap ( A , i ) : <NEWLINE> <INDENT> largest = i <NEWLINE> while True : <NEWLINE> <INDENT> l = i * 2 <NEWLINE> r = l + 1 <NEWLINE> if A [ l ] > A [ largest ] : largest = l <NEWLINE> if A [ r ] > A [ largest ] : largest = r <NEWLINE> if largest == i : return <NEWLINE> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> i = largest <NEWLINE> <NL> <DEDENT> <DEDENT> def up_heap ( A , i ) : <NEWLINE> <INDENT> p = i // 2 <NEWLINE> while A [ i ] > A [ p ] : <NEWLINE> <INDENT> A [ i ] , A [ p ] = A [ p ] , A [ i ] <NEWLINE> i = p <NEWLINE> p = i // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> hp = [ - 1 ] * ( 4000000 ) <NEWLINE> hp [ 0 ] = 2000000001 <NEWLINE> i = 1 <NEWLINE> j = - 1 <NEWLINE> for op in stdin : <NEWLINE> <INDENT> if op [ 0 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> hp [ i ] = int ( op [ 7 : ] ) <NEWLINE> up_heap ( hp , i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif op [ 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> hp [ j ] , hp [ 1 ] , hp [ i - 1 ] = hp [ 1 ] , hp [ i - 1 ] , - 1 <NEWLINE> dw_heap ( hp , 1 ) <NEWLINE> i -= 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * hp [ : j : - 1 ] , sep = <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = [ 1 ] <NEWLINE> t = 1 <NEWLINE> ord = [ - 1 ] * ( N + 1 ) <NEWLINE> ord [ 0 ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> t = A [ t - 1 ] <NEWLINE> if ord [ t ] != - 1 : <NEWLINE> <INDENT> f = n . index ( t ) <NEWLINE> break <NEWLINE> <DEDENT> n . append ( t ) <NEWLINE> ord [ t ] = 0 <NEWLINE> <NL> <DEDENT> k = len ( n ) - f <NEWLINE> <NL> if K >= f : <NEWLINE> <INDENT> print ( n [ f + ( K - f ) % k ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( n [ K ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> flag = False <NEWLINE> zeros = False <NEWLINE> over = pow ( 10 , 18 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> if ( ans > over ) : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> zeros = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> if ( zeros ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = [ 0 ] * ( n + 1 ) <NEWLINE> bsum = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> asum [ i + 1 ] = asum [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bsum [ i + 1 ] = bsum [ i ] + b [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> j = m <NEWLINE> res = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if asum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while asum [ i ] + bsum [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> res = max ( res , j + i ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> from math import * <NEWLINE> <NL> K = k ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( k , gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , V = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if W > V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> if abs ( A - B ) <= T * ( V - W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> x = sum ( a ) - a [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( a [ i ] * x ) % mod <NEWLINE> x -= a [ i + 1 ] <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> class Combination : <NEWLINE> <INDENT> def __init__ ( self , size , MOD ) : <NEWLINE> <INDENT> self . size = size + 2 <NEWLINE> <NL> f = 1 <NEWLINE> self . fact = fact = [ f ] <NEWLINE> for i in range ( 1 , size + 1 ) : <NEWLINE> <INDENT> f = f * i % MOD <NEWLINE> fact . append ( f ) <NEWLINE> <DEDENT> f = pow ( f , MOD - 2 , MOD ) <NEWLINE> self . factInv = factInv = [ f ] <NEWLINE> for i in range ( size , 0 , - 1 ) : <NEWLINE> <INDENT> f = f * i % MOD <NEWLINE> factInv . append ( f ) <NEWLINE> <DEDENT> factInv . reverse ( ) <NEWLINE> <NL> <DEDENT> def npr ( self , n , r ) : <NEWLINE> <INDENT> if n < r or n < 0 or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fact [ n ] * self . factInv [ n - r ] % MOD <NEWLINE> <NL> <DEDENT> def ncr ( self , n , r ) : <NEWLINE> <INDENT> if n < r or n < 0 or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fact [ n ] * ( self . factInv [ r ] * self . factInv [ n - r ] % MOD ) % MOD <NEWLINE> <NL> <DEDENT> def nhr ( self , n , r ) : <COMMENT> <NEWLINE> <INDENT> return self . ncr ( n + r - 1 , n - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sol ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> comb = Combination ( N + K + 100 , MOD ) <NEWLINE> <NL> ans = 0 <NEWLINE> L = 1 <NEWLINE> R = pow ( 26 , K , MOD ) <NEWLINE> inv26 = pow ( 26 , MOD - 2 , MOD ) <NEWLINE> for l in range ( K + 1 ) : <NEWLINE> <INDENT> ans += L * comb . nhr ( N , l ) * R <NEWLINE> ans %= MOD <NEWLINE> <NL> L = L * 25 % MOD <NEWLINE> R = R * inv26 % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> sol ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> souwa = N * ( N + 1 ) // 2 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> mi = ( i - 1 ) * i // 2 <NEWLINE> ma = souwa - ( N - i ) * ( N - i + 1 ) // 2 <NEWLINE> ans += ma - mi + 1 <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def find_num ( lst , value ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( lst ) if x == value ] <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> idx = find_num ( p , X ) <NEWLINE> if idx == [ ] : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if p [ idx [ 0 ] - i ] != X - i or idx [ 0 ] - i == - 1 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> if idx [ 0 ] + i == N : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif p [ idx [ 0 ] + i ] != X + i : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <DEDENT> for a in c : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if sum ( a ) >= h else <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( zip ( B , A ) ) <NEWLINE> B , A = zip ( * C ) <NEWLINE> D = sorted ( ( a , i ) for i , a in enumerate ( A ) ) <NEWLINE> E , indices = zip ( * D ) <NEWLINE> for e , b in zip ( E , B ) : <NEWLINE> <INDENT> if e > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> S = { 0 } <NEWLINE> now = 0 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> if indices [ now ] in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now = indices [ now ] <NEWLINE> S . add ( now ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if E [ i + 1 ] <= B [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xs = input ( ) <NEWLINE> xj = xs . count ( <STRING> ) <NEWLINE> <NL> x = int ( xs , 2 ) <NEWLINE> xip = x % ( xj + 1 ) <NEWLINE> if xj != 1 : <NEWLINE> <INDENT> xim = x % ( xj - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if xs [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> pxi = xj + 1 <NEWLINE> i2 = pow ( 2 , i , pxi ) <NEWLINE> xi = ( xip + i2 ) % pxi <NEWLINE> <DEDENT> elif xj == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pxi = xj - 1 <NEWLINE> i2 = pow ( 2 , i , pxi ) <NEWLINE> xi = ( xim - i2 ) % pxi <NEWLINE> <DEDENT> xi = xi % pxi <NEWLINE> if xi == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> icnt = 1 <NEWLINE> while xi > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> icnt += 1 <NEWLINE> xi = xi % ( bin ( xi ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> print ( icnt ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> count += ( a [ i ] - a [ i + 1 ] ) <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = ( int ) ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> sNumber = ( int ) ( input ( ) ) <NEWLINE> tNumber = ( int ) ( input ( ) ) <NEWLINE> uNumber = sNumber + tNumber <NEWLINE> print ( <STRING> if uNumber >= 10 ** 80 else uNumber ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> queue = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i <= k - 1 : <NEWLINE> <INDENT> queue . append ( a [ i ] ) <NEWLINE> <DEDENT> elif i >= k : <NEWLINE> <INDENT> x = queue . popleft ( ) <NEWLINE> if x < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> queue . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ret = ret * a <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
N = list ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> S += int ( i ) <NEWLINE> <NL> <DEDENT> if S % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = [ int ( t ) for t in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> mod = 998244353 <NEWLINE> mem = [ 0 ] * max ( k + 3 , n + 1 ) <NEWLINE> for i in range ( k + 2 ) : <NEWLINE> <INDENT> mem [ i ] = pow ( m , i , mod ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> for i in range ( k + 2 , n + 1 ) : <NEWLINE> <INDENT> mem [ i ] = ( m * mem [ i - 1 ] - m * c * pow ( m - 1 , i - k - 2 , mod ) ) % mod <NEWLINE> c = ( c * ( i - 1 ) * pow ( i - k - 1 , - 1 , mod ) ) % mod <NEWLINE> <DEDENT> print ( mem [ n ] ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> min_charge = 10 ** 7 <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> which = format ( i , <STRING> ) [ - n : ] <NEWLINE> <NL> <COMMENT> <NL> <NL> charge = 0 <NEWLINE> skill = [ 0 for _ in range ( m ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if which [ j ] == <STRING> : <NEWLINE> <INDENT> charge += A [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> skill [ k ] += A [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag_skill = 1 <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> if skill [ l ] < x : <NEWLINE> <INDENT> flag_skill = 0 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if flag_skill == 1 : <NEWLINE> <INDENT> min_charge = min ( min_charge , charge ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if min_charge == 10 ** 7 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_charge ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> for i in X : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in X : <NEWLINE> <INDENT> if i == 0 : result = 0 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> ans += gcd ( i , i , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , i , j ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> kai = math . factorial ( n ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> i = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> def isPrime ( x ) : <NEWLINE> <INDENT> global count <NEWLINE> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x > 2 and x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for j in range ( int ( i ) ) : <NEWLINE> <INDENT> j = int ( input ( ) ) <NEWLINE> if isPrime ( j ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def lcs ( X , Y ) : <NEWLINE> <INDENT> global c <NEWLINE> m , n = len ( X ) , len ( Y ) <NEWLINE> c = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if X [ i - 1 ] == Y [ j - 1 ] : <NEWLINE> <INDENT> c [ i ] [ j ] = c [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ i ] [ j ] = max ( c [ i - 1 ] [ j ] , c [ i ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c [ m ] [ n ] <NEWLINE> <NL> <DEDENT> def lcs_improved ( X , Y ) : <NEWLINE> <INDENT> hist = [ 0 ] <COMMENT> <NEWLINE> for c in Y : <NEWLINE> <INDENT> for i in range ( len ( hist ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> next_match_i = X . find ( c , hist [ i ] ) + 1 <NEWLINE> if next_match_i : <NEWLINE> <INDENT> if i + 1 < len ( hist ) : <NEWLINE> <INDENT> hist [ i + 1 ] = min ( hist [ i + 1 ] , next_match_i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hist . append ( next_match_i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( hist ) - 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( lcs_improved ( X , Y ) ) <NEWLINE> <DEDENT>
L = int ( input ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s += x * w <NEWLINE> <DEDENT> if ( s == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( s < 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> print ( 1 , - s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> print ( - 1 , s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> search = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> search . sort ( ) <NEWLINE> double = set ( [ ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if search [ i + 1 ] == search [ i ] : <NEWLINE> <INDENT> double . add ( search [ i ] ) <NEWLINE> <DEDENT> <DEDENT> dp = [ 1 ] * ( search [ - 1 ] + 1 ) <NEWLINE> for i in search : <NEWLINE> <INDENT> if not dp [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i in double : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> k = 2 * i <NEWLINE> while k <= search [ - 1 ] : <NEWLINE> <INDENT> dp [ k ] = 0 <NEWLINE> k += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ( dp [ i ] for i in search ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> i = sorted ( i , reverse = True ) <NEWLINE> for a in i : <NEWLINE> <INDENT> s = s * a <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = sorted ( D ) <NEWLINE> D_counter = Counter ( D ) <NEWLINE> <NL> <NL> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = sorted ( T ) <NEWLINE> T_counter = Counter ( T ) <NEWLINE> <NL> <NL> <NL> D_keylist = ( list ( D_counter . items ( ) ) ) <NEWLINE> <NL> T_keylist = ( list ( T_counter . keys ( ) ) ) <NEWLINE> T_Valuelist = ( list ( T_counter . values ( ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> T_index = 0 <NEWLINE> <NL> for i in D_keylist : <NEWLINE> <INDENT> D_key = i [ 0 ] <COMMENT> <NEWLINE> D_value = i [ 1 ] <COMMENT> <NEWLINE> <NL> T_key = T_keylist [ T_index ] <COMMENT> <NEWLINE> T_value = T_Valuelist [ T_index ] <COMMENT> <NEWLINE> <NL> <NL> if D_key == T_key and ( D_value >= T_value ) : <COMMENT> <NEWLINE> <INDENT> T_index = T_index + 1 <COMMENT> <NEWLINE> ans = ans + 1 <COMMENT> <NEWLINE> <NL> if T_index == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( T_keylist ) == ans : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> H0 = 1 <NEWLINE> H1 = 1 <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> H0 = A [ i ] <NEWLINE> H1 = A [ K + i ] <NEWLINE> <NL> if H1 > H0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . fromstring ( input ( ) , sep = <STRING> , dtype = np . int64 ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = np . zeros ( Q ) <NEWLINE> C = np . zeros ( Q ) <NEWLINE> D = np . fromstring ( <STRING> . join ( [ input ( ) for q in range ( Q ) ] ) , sep = <STRING> , dtype = np . int64 ) . reshape ( ( Q , 2 ) ) <NEWLINE> B = D [ : , 0 ] <NEWLINE> C = D [ : , 1 ] <NEWLINE> <NL> d = dict ( np . c_ [ np . unique ( A , return_counts = True ) ] ) <NEWLINE> s = np . sum ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> if ( B [ q ] in d ) : <NEWLINE> <INDENT> n = d . pop ( B [ q ] ) <NEWLINE> s += n * ( C [ q ] - B [ q ] ) <NEWLINE> if ( C [ q ] in d ) : <NEWLINE> <INDENT> d [ C [ q ] ] += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ C [ q ] ] = n <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i * i <= N : <NEWLINE> <INDENT> ans = max ( ans , i * i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> epsilon = 5 * 10 ** ( - 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xys = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> xs , ys = zip ( * xys ) <NEWLINE> <NL> lsd = 0 <COMMENT> <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> sd = ( xs [ i ] - xs [ j ] ) ** 2 + ( ys [ i ] - ys [ j ] ) ** 2 <NEWLINE> if lsd < sd : <NEWLINE> <INDENT> lsd = sd <NEWLINE> farthest_2_points = ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> p , q = farthest_2_points <NEWLINE> center_x = ( xs [ p ] + xs [ q ] ) / 2 <NEWLINE> center_y = ( ys [ p ] + ys [ q ] ) / 2 <NEWLINE> all_in_circle = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( xs [ i ] - center_x ) ** 2 + ( ys [ i ] - center_y ) ** 2 > lsd / 4 + epsilon : <NEWLINE> <INDENT> all_in_circle = False <NEWLINE> <NL> <DEDENT> <DEDENT> if all_in_circle : <NEWLINE> <COMMENT> <NL> <INDENT> print ( lsd ** 0.5 / 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> smallest_radius = 10 ** 9 <NEWLINE> for p in range ( 0 , N ) : <NEWLINE> <INDENT> for q in range ( p + 1 , N ) : <NEWLINE> <INDENT> for r in range ( q + 1 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> pq = ( ( xs [ q ] - xs [ p ] ) ** 2 + ( ys [ q ] - ys [ p ] ) ** 2 ) ** 0.5 <NEWLINE> v1x = xs [ p ] - xs [ r ] <NEWLINE> v1y = ys [ p ] - ys [ r ] <NEWLINE> v2x = xs [ q ] - xs [ r ] <NEWLINE> v2y = ys [ q ] - ys [ r ] <NEWLINE> vec1_len = ( v1x ** 2 + v1y ** 2 ) ** 0.5 <NEWLINE> vec2_len = ( v2x ** 2 + v2y ** 2 ) ** 0.5 <NEWLINE> vecs_dot = v1x * v2x + v1y * v2y <NEWLINE> theta = math . acos ( min ( 1.0 , max ( - 1.0 , vecs_dot / ( vec1_len * vec2_len ) ) ) ) <NEWLINE> if theta == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> radius = pq / ( 2 * math . sin ( theta ) ) <NEWLINE> <NL> <COMMENT> <NL> det = v1x * v2y - v1y * v2x <NEWLINE> if det == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> center_x = xs [ r ] + ( v2y * vec1_len ** 2 + ( - v1y ) * vec2_len ** 2 ) / ( 2 * ( det ) ) <NEWLINE> center_y = ys [ r ] + ( ( - v2x ) * vec1_len ** 2 + v1x * vec2_len ** 2 ) / ( 2 * ( det ) ) <NEWLINE> all_in_circle = True <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> if ( ( xs [ s ] - center_x ) ** 2 + ( ys [ s ] - center_y ) ** 2 ) ** 0.5 > radius + epsilon : <NEWLINE> <INDENT> all_in_circle = False <NEWLINE> <DEDENT> <DEDENT> if all_in_circle : <NEWLINE> <INDENT> smallest_radius = min ( smallest_radius , radius ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( smallest_radius ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> A . append ( x ) <NEWLINE> <NL> <DEDENT> B = [ int ( ) ] * n <NEWLINE> B [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if A [ i ] >= A [ i ] + B [ i - 1 ] : <NEWLINE> <INDENT> B [ i ] = A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ i ] = A [ i ] + B [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( B ) ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> key = <STRING> <NEWLINE> if <STRING> . join ( s ) == key : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> f = False <NEWLINE> for l in range ( ls ) : <NEWLINE> <INDENT> for r in range ( l + 1 , ls ) : <NEWLINE> <INDENT> f |= <STRING> . join ( [ <STRING> . join ( s [ : l ] ) , <STRING> . join ( s [ r : ] ) ] ) == key <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if f else <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 ] * k <NEWLINE> a = [ 0 ] * k <NEWLINE> s = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . extend ( a [ i ] ) <NEWLINE> <DEDENT> d = set ( s ) <NEWLINE> print ( n - len ( d ) ) <NEWLINE>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = rm ( ) <NEWLINE> a = [ ( i + 1 ) / 2 for i in rl ( ) ] <NEWLINE> a = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i + k ] - a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> , i , <STRING> , x , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> rg = R * i + G * j <NEWLINE> <NL> if rg <= N : <NEWLINE> <INDENT> if ( N - rg ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if ( 0 <= s - x - y ) and ( s - x - y <= k ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = a [ 0 ] <NEWLINE> over = False <NEWLINE> limit = pow ( 10 , 18 ) <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> m *= i <NEWLINE> if m > limit : <NEWLINE> <INDENT> over = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if over : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> paths = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> paths . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> paths [ - 1 ] [ 0 ] -= 1 <NEWLINE> paths [ - 1 ] [ 1 ] -= 1 <NEWLINE> <NL> <DEDENT> bad = set ( ) <NEWLINE> <NL> for path in paths : <NEWLINE> <INDENT> if H [ path [ 0 ] ] == H [ path [ 1 ] ] : <NEWLINE> <INDENT> bad . add ( path [ 0 ] ) <NEWLINE> bad . add ( path [ 1 ] ) <NEWLINE> <DEDENT> elif H [ path [ 0 ] ] > H [ path [ 1 ] ] : <NEWLINE> <INDENT> bad . add ( path [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad . add ( path [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( bad ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> opens = 0 <NEWLINE> closes = 0 <NEWLINE> ls = [ ] <NEWLINE> rs = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt1 == 0 : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt1 -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt2 == 0 : <NEWLINE> <INDENT> opens += cnt1 <NEWLINE> <DEDENT> elif cnt1 == 0 : <NEWLINE> <INDENT> closes += cnt2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls . append ( cnt2 ) <NEWLINE> rs . append ( cnt1 ) <NEWLINE> <DEDENT> <DEDENT> ls = sorted ( ls ) <NEWLINE> rs = sorted ( rs ) <NEWLINE> lefts = sum ( ls ) <NEWLINE> rights = sum ( rs ) <NEWLINE> if opens - closes != lefts - rights : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> if len ( ls ) == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> for a in ls : <NEWLINE> <INDENT> if opens < a or closes < a + ( rights - lefts ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pos = bisect . bisect_right ( rs , a + ( rights - lefts ) ) <NEWLINE> if pos != 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for d in rs : <NEWLINE> <INDENT> if opens < d + ( lefts - rights ) or closes < d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pos = bisect . bisect_right ( ls , d + ( lefts - rights ) ) <NEWLINE> if pos != 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> c = Counter ( a ) <NEWLINE> <NL> flags = [ True ] * ( a [ - 1 ] + 1 ) <NEWLINE> <NL> for e in a : <NEWLINE> <INDENT> for mul in range ( 2 , a [ - 1 ] // e + 1 ) : <NEWLINE> <INDENT> flags [ e * mul ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ flags [ a [ i ] ] and c [ a [ i ] ] == 1 for i in range ( n ) ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> s2 = list ( s ) <NEWLINE> s1 = <STRING> <NEWLINE> if s2 [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s2 [ - 1 ] = <STRING> <NEWLINE> <DEDENT> if s2 [ 0 ] == <STRING> and s2 [ 1 ] == <STRING> : <NEWLINE> <INDENT> s2 [ 0 ] = <STRING> <NEWLINE> <DEDENT> elif s2 [ 0 ] == <STRING> and ( s2 [ 1 ] == <STRING> or s2 [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> s2 [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , len ( s2 ) - 1 ) : <NEWLINE> <INDENT> if s2 [ i ] == <STRING> : <NEWLINE> <INDENT> if s2 [ i - 1 ] == <STRING> and ( s2 [ i + 1 ] == <STRING> or s2 [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> s2 [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in s2 : <NEWLINE> <INDENT> s1 += i <NEWLINE> <DEDENT> print ( s1 ) <NEWLINE>
from collections import deque <NEWLINE> a = int ( input ( ) ) <NEWLINE> list = deque ( [ ] ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> order = input ( ) . split ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> list . appendleft ( order [ 1 ] ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> if order [ 1 ] in list : <NEWLINE> <INDENT> list . remove ( order [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> list . popleft ( ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> list . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * list ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = math . floor ( i / 2 ) <NEWLINE> ans += A [ a ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> start , steps = 1 , 0 <NEWLINE> root = dict ( ) <NEWLINE> <NL> while start not in root and steps < k : <NEWLINE> <INDENT> root [ start ] = steps <NEWLINE> steps += 1 <NEWLINE> start = A [ start - 1 ] <NEWLINE> <NL> <DEDENT> if steps == k : <NEWLINE> <INDENT> print ( start ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pa = steps - root [ start ] <NEWLINE> ans = root [ start ] + ( k - steps ) % pa <NEWLINE> root = { v : k for k , v in root . items ( ) } <NEWLINE> print ( root [ ans ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> dlist = deque ( ) <NEWLINE> <NL> func = { <STRING> : dlist . appendleft , <STRING> : dlist . remove , <STRING> : dlist . popleft , <STRING> : dlist . pop } <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> command = line . split ( ) <NEWLINE> if len ( command ) == 2 : <NEWLINE> <INDENT> command [ 1 ] = int ( command [ 1 ] ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> func [ command [ 0 ] ] ( * command [ 1 : ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * dlist ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def CountingSort ( A , k , n ) : <NEWLINE> <INDENT> B = [ None ] * ( n + 1 ) <NEWLINE> C = [ 0 ] * k <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ j ] ] ] = A [ j ] <NEWLINE> C [ A [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> return B <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> k = 10000 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ None ] + [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> B = CountingSort ( A , k , n ) <NEWLINE> print ( <STRING> . join ( map ( str , B [ 1 : ] ) ) ) <NEWLINE> <NL> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> c = sorted ( [ R , G , B ] ) <NEWLINE> R = c [ 1 ] <NEWLINE> G = c [ 2 ] <NEWLINE> B = c [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> tmp = N - r * R <NEWLINE> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> ttmp = tmp - g * G <NEWLINE> ans += ( ttmp % B == 0 and ttmp >= 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BandC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> temp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> s = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> num = BandC [ i ] [ 0 ] <NEWLINE> num_temp = temp [ BandC [ i ] [ 0 ] ] <NEWLINE> temp [ BandC [ i ] [ 0 ] ] = 0 <NEWLINE> temp [ BandC [ i ] [ 1 ] ] += num_temp <NEWLINE> s = s - BandC [ i ] [ 0 ] * num_temp + BandC [ i ] [ 1 ] * num_temp <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> clist = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> clist . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> total_all = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> total = np . zeros ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> total = total + np . array ( clist [ j ] ) <NEWLINE> <DEDENT> <DEDENT> total_all . append ( list ( total ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = [ ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( len ( total_all ) ) : <NEWLINE> <INDENT> if min ( total_all [ i ] [ 1 : M + 1 ] ) >= X : <NEWLINE> <INDENT> ans . append ( total_all [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ans ) >= 1 : <NEWLINE> <INDENT> print ( int ( min ( ans ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import logging <NEWLINE> import collections <NEWLINE> <NL> logging . basicConfig ( level = logging . INFO , format = <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ai_plu_i = collections . Counter ( [ i + 1 + A_i [ i ] for i in range ( N ) ] ) <NEWLINE> ans = sum ( [ Ai_plu_i . get ( j + 1 - A_i [ j ] , 0 ) for j in range ( N ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> result = 0 <NEWLINE> cnt = collections . Counter ( a ) <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import bisect <NEWLINE> def main ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> return <NEWLINE> <DEDENT> P = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> NP = sorted ( list ( set ( range ( 102 ) ) - P ) ) <NEWLINE> right = bisect . bisect ( NP , X ) <NEWLINE> left = right - 1 <NEWLINE> if left == - 1 or abs ( X - NP [ left ] ) > abs ( X - NP [ right ] ) : <NEWLINE> <INDENT> print ( NP [ right ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NP [ left ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = [ 0 ] * 100010 <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <NL> <DEDENT> s = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s += ( c [ i ] - b [ i ] ) * num [ b [ i ] ] <NEWLINE> num [ c [ i ] ] += num [ b [ i ] ] <NEWLINE> num [ b [ i ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def readstr ( ) : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def readint ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readnums ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readstrs ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def popcount ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while n : <NEWLINE> <INDENT> ret += n & 1 <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = readint ( ) <NEWLINE> X = readstr ( ) <NEWLINE> s = sum ( tuple ( map ( int , X ) ) ) <NEWLINE> s1 = s + 1 <NEWLINE> s2 = s - 1 if s != 1 else 1 <NEWLINE> m1 = int ( X , 2 ) % s1 <NEWLINE> m2 = int ( X , 2 ) % s2 <NEWLINE> t1 = [ 1 ] <NEWLINE> t2 = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t1 . append ( t1 [ i ] * 2 % s1 ) <NEWLINE> t2 . append ( t2 [ i ] * 2 % s2 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> x = ( m1 + t1 [ ( N - i - 1 ) ] ) % s1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( m2 - t2 [ ( N - i - 1 ) ] ) % s2 <NEWLINE> <DEDENT> <DEDENT> d = popcount ( x ) <NEWLINE> ans += 1 <NEWLINE> while x : <NEWLINE> <INDENT> x %= d <NEWLINE> d = popcount ( x ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ input ( ) for _ in range ( N ) ] <NEWLINE> B = [ input ( ) for _ in range ( M ) ] <NEWLINE> <NL> def check ( x , y ) : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if y + i >= N or x + j >= N : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if A [ y + i ] [ x + j ] != B [ i ] [ j ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if check ( i , j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
from functools import reduce <NEWLINE> import math <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> gcdsum = K * K * K <NEWLINE> gcd_ab = [ ] <NEWLINE> ab_list = [ ] <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if gcd ( a , b ) != 1 : <NEWLINE> <INDENT> ab_list . append ( a ) <NEWLINE> ab_list . append ( b ) <NEWLINE> gcd_ab . append ( ab_list ) <NEWLINE> ab_list = [ ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ab in gcd_ab : <NEWLINE> <INDENT> ab = gcd ( ab [ 0 ] , ab [ 1 ] ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if gcd ( ab , c ) != 1 : <NEWLINE> <COMMENT> <NL> <INDENT> gcdsum += gcd ( ab , c ) - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( gcdsum ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while ( a != 0 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , a ) ) <NEWLINE> i += 1 <NEWLINE> a = int ( input ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sysread = sys . stdin . readline <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> A = [ ( idx , val ) for idx , val in enumerate ( A , 1 ) if val < N ] <NEWLINE> <NL> ret = 0 <NEWLINE> store = [ 0 ] * N <NEWLINE> for idx , val in A : <NEWLINE> <INDENT> if idx - val > 0 : <NEWLINE> <INDENT> ret += store [ idx - val ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> store [ idx + val ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> maxA = A [ - 1 ] <NEWLINE> dp = [ - 1 for i in range ( maxA + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] != 0 : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> dp [ a ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> dp [ a ] = 1 <NEWLINE> for i in range ( 2 * a , maxA + 1 , a ) : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> total = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> total = total * i <NEWLINE> if ( total > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> def debug ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> x_diff_of_5th_factor = int ( input ( ) ) <NEWLINE> <NL> <NL> for a in range ( - 118 , 119 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 118 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x_diff_of_5th_factor : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sys . exit ( 1 ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ma = min ( N , B - 1 ) <NEWLINE> result = int ( ( ( ma / B - int ( ma / B ) ) * A ) ) <NEWLINE> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> x ^= a [ i ] <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> ans . append ( str ( x ^ a [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> sum = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for e in a : <NEWLINE> <INDENT> sum += e <NEWLINE> <NL> <DEDENT> for e in a : <NEWLINE> <INDENT> sum -= e <NEWLINE> ans += e * sum <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> ij = i + j <NEWLINE> if ij > S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( S - ij <= K ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> res = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> s = ( s + a [ i - 1 ] ) % mod <NEWLINE> res = ( res + ( s * a [ i ] ) % mod ) % mod <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> V = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> S . append ( <STRING> ) <NEWLINE> op = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s0 , s1 = S [ i ] <NEWLINE> if V [ s0 ] + V [ s1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> x , y = s0 , s1 <NEWLINE> if V [ s1 ] == 0 or ( V [ s0 ] != 0 and s1 in S [ i + 1 ] ) : <NEWLINE> <INDENT> x , y = s1 , s0 <NEWLINE> <NL> <DEDENT> V [ x ] += 1 <NEWLINE> V [ y ] -= 1 <NEWLINE> op += x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if len ( op ) != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> [ print ( x ) for x in op ] <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ input ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N = z ( ) <NEWLINE> a = zz ( ) <NEWLINE> ans = [ ] <NEWLINE> all_xor = 0 <NEWLINE> for _a in a : <NEWLINE> <INDENT> all_xor ^= _a <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> tmp = - ( all_xor ^ ( ~ a [ i ] ) ) - 1 <NEWLINE> ans . append ( tmp ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <COMMENT> <NL>
from bisect import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = - int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def loopa ( ) : <NEWLINE> <NL> <INDENT> n = len ( a ) <NEWLINE> dp = [ 10 ** 10 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = - 10 ** 10 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> idx = bisect ( dp , a [ i ] ) <NEWLINE> dp [ idx ] = min ( a [ i ] , dp [ idx ] ) <NEWLINE> <NL> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> dp = loopa ( ) <NEWLINE> <NL> print ( bisect ( dp , 10 ** 10 - 1 ) - 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> i = n - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> l . append ( a [ i ] ) <NEWLINE> i -= 2 <NEWLINE> <NL> <DEDENT> j = 1 <NEWLINE> while j < n : <NEWLINE> <INDENT> l . append ( a [ j ] ) <NEWLINE> j += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = n - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> l . append ( a [ i ] ) <NEWLINE> i -= 2 <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> while j < n : <NEWLINE> <INDENT> l . append ( a [ j ] ) <NEWLINE> j += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , l ) ) ) <NEWLINE>
from heapq import heapify , heappush , heappop <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - x for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapify ( A ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = - heappop ( A ) <NEWLINE> <COMMENT> <NL> tmp = tmp // 2 <NEWLINE> <COMMENT> <NL> heappush ( A , - tmp ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <NL> <DEDENT> ans = abs ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> sh = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> <NL> id = [ int ( n ) for n in b . split ( <STRING> ) ] <NEWLINE> D = defaultdict ( int ) <NEWLINE> for i in id : <NEWLINE> <INDENT> if i not in D : <NEWLINE> <INDENT> D [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ i ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , sh + 1 ) : <NEWLINE> <INDENT> if i in D : <NEWLINE> <INDENT> print ( D [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> cnt , i = 0 , 1 <NEWLINE> l = len ( s ) <NEWLINE> <NL> while i < l : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i += 2 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( l - cnt ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good = [ True ] * N <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if H [ A ] >= H [ B ] : <NEWLINE> <INDENT> good [ B ] = False <NEWLINE> <DEDENT> if H [ A ] <= H [ B ] : <NEWLINE> <INDENT> good [ A ] = False <NEWLINE> <DEDENT> <DEDENT> print ( sum ( good ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if N == 1 and M == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif N == 1 and M > 1 : <NEWLINE> <INDENT> ans = M - 2 <NEWLINE> <DEDENT> elif N > 1 and M == 1 : <NEWLINE> <INDENT> ans = N - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( N - 2 ) * ( M - 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
T = input ( ) <NEWLINE> <NL> T = T . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( <STRING> . join ( T ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < n - 1 : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if p [ n - 1 ] == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> ans = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> dp = [ [ 1 ] * 220 for i in range ( 220 ) ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = math . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> a = dp [ i ] [ j ] <NEWLINE> gcd = dp [ a ] [ k ] <NEWLINE> if i == j == k : <NEWLINE> <INDENT> ans += gcd <NEWLINE> <DEDENT> elif i != j != k : <NEWLINE> <INDENT> ans += gcd * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a = 7 % K <NEWLINE> cnt = 1 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> if a % K == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a = ( a * 10 + 7 ) % K <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> before = 1 <NEWLINE> start = 0 <NEWLINE> end = 0 <NEWLINE> <NL> if K <= N : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> before = a [ before ] <NEWLINE> <DEDENT> print ( before ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> market_town = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> before = a [ before ] <NEWLINE> <DEDENT> marked_town = before <NEWLINE> K -= N <NEWLINE> counter = 1 <NEWLINE> while marked_town != a [ before ] : <NEWLINE> <INDENT> before = a [ before ] <NEWLINE> counter += 1 <NEWLINE> <DEDENT> K = K % counter <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> before = a [ before ] <NEWLINE> <DEDENT> print ( before ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if a < b * ( 2 ** i ) < c * ( 2 ** ( k - i ) ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = Counter ( a ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in A . values ( ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> cnt += ( i * ( i - 1 ) // 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> before = ( A [ i ] * ( A [ i ] - 1 ) ) // 2 <NEWLINE> after = ( ( A [ i ] - 1 ) * ( A [ i ] - 2 ) ) // 2 <NEWLINE> <NL> ans = cnt - before + after <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = <STRING> + s <NEWLINE> return n , s <NEWLINE> <NL> <DEDENT> def main ( n , s ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> all = set ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> l1 = s [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> l2 = s [ j ] <NEWLINE> if l1 == l2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l3 = ( all - set ( [ l1 , l2 ] ) ) . pop ( ) <NEWLINE> ij = j - i <NEWLINE> sub1 = s [ j + 1 : j + ij ] <NEWLINE> sub2 = s [ j + ij + 1 : ] <NEWLINE> count += sub1 . count ( l3 ) <NEWLINE> count += sub2 . count ( l3 ) <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main2 ( n , s ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> nr = s . count ( <STRING> ) <NEWLINE> ng = s . count ( <STRING> ) <NEWLINE> nb = s . count ( <STRING> ) <NEWLINE> all = set ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> l1 = s [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> l2 = s [ j ] <NEWLINE> if l1 == l2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ij = j - i <NEWLINE> jk = ij <NEWLINE> k = j + jk <NEWLINE> if ( k > n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l3 = s [ k ] <NEWLINE> if l3 == l1 or l3 == l2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return nr * ng * nb - count <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , s = readinput ( ) <NEWLINE> ans = main2 ( n , s ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) . strip ( ) <NEWLINE> t = input ( ) . strip ( ) <NEWLINE> <NL> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> v = <STRING> <NEWLINE> for i in range ( lt ) : <NEWLINE> <INDENT> v += s [ i ] + t [ i ] <NEWLINE> <DEDENT> if lt != ls : <NEWLINE> <INDENT> v += s [ - 1 ] <NEWLINE> <DEDENT> print ( v ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( 0 , Q ) ] <NEWLINE> ans = sum ( A ) <NEWLINE> num = collections . Counter ( A ) <NEWLINE> for i in range ( 0 , Q ) : <NEWLINE> <INDENT> before , after = B [ i ] [ 0 ] , B [ i ] [ 1 ] <NEWLINE> ans += num [ before ] * ( after - before ) <NEWLINE> num [ after ] += num [ before ] <NEWLINE> num [ before ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def g ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> p = 0 <NEWLINE> n2 = n <NEWLINE> while n2 > 0 : <NEWLINE> <INDENT> if n2 % 2 == 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <DEDENT> n2 //= 2 <NEWLINE> <NL> <DEDENT> n %= p <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> def modPow ( a , b , mod ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> <NL> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> x = ( x * a ) % mod <NEWLINE> <NL> <DEDENT> a = ( a ** 2 ) % mod <NEWLINE> b //= 2 <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def f ( N , X ) : <NEWLINE> <INDENT> b = sum ( 1 if x == <STRING> else 0 for x in X ) <NEWLINE> <NL> Xplus = 0 <NEWLINE> Xminus = 0 <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> Xplus = ( Xplus * 2 + ( 1 if x == <STRING> else 0 ) ) % ( b + 1 ) <NEWLINE> <NL> if b > 1 : <NEWLINE> <INDENT> Xminus = ( Xminus * 2 + ( 1 if x == <STRING> else 0 ) ) % ( b - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> X2 = ( Xplus + modPow ( 2 , N - i - 1 , b + 1 ) ) % ( b + 1 ) <NEWLINE> print ( g ( X2 ) + 1 ) <NEWLINE> <DEDENT> elif b > 1 : <NEWLINE> <COMMENT> <NL> <INDENT> X2 = ( Xminus - modPow ( 2 , N - i - 1 , b - 1 ) ) % ( b - 1 ) <NEWLINE> print ( g ( X2 ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> f ( N , X ) <NEWLINE> <NL>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( <STRING> ) <NEWLINE>
from collections import * <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> def root ( i ) : <NEWLINE> <INDENT> if par [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return root ( par [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( a ) : <NEWLINE> <INDENT> return - par [ root ( a ) ] <NEWLINE> <NL> <DEDENT> def union ( a , b ) : <NEWLINE> <INDENT> a = root ( a ) <NEWLINE> b = root ( b ) <NEWLINE> if a == b : <COMMENT> <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if size ( a ) < size ( b ) : <COMMENT> <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> par [ a ] += par [ b ] <NEWLINE> par [ b ] = a <NEWLINE> return True <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a = [ int ( j ) - 1 for j in input ( ) . split ( ) ] <COMMENT> <NEWLINE> if root ( a [ 0 ] ) != root ( a [ 1 ] ) : <NEWLINE> <INDENT> union ( a [ 0 ] , a [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( [ size ( i ) for i in par ] ) ) <NEWLINE>
lenght = int ( input ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( reverse = True ) <NEWLINE> check = False <NEWLINE> <NL> if x [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first_value = 1 <NEWLINE> for val in x : <NEWLINE> <INDENT> first_value *= val <NEWLINE> if first_value > 1e18 : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( first_value ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> x = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> x *= i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( pow ( r , 2 ) * math . pi ) , <STRING> % ( 2 * r * math . pi ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> num = int ( input ( ) ) + 1 <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( 1 , num ) : <NEWLINE> <INDENT> for b in range ( 1 , num ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> for c in range ( 1 , num ) : <NEWLINE> <INDENT> count += gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def ans_xyz ( x , y , z ) : <NEWLINE> <INDENT> return ( ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) + ( x * y ) + ( y * z ) + ( z * x ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> ans [ ans_xyz ( x , y , z ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : N + 1 ] , sep = <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> for j in range ( 19 ) : <NEWLINE> <INDENT> if a <= 10 ** j : <NEWLINE> <INDENT> m = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for k in range ( 19 ) : <NEWLINE> <INDENT> if ans <= 10 ** k : <NEWLINE> <INDENT> n = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( m + n > 19 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( ans * a == 10 ** 18 ) : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> <DEDENT> elif ( ans * a > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if N >= B : <NEWLINE> <INDENT> print ( f ( B - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a_list = s . split ( ) <NEWLINE> dic = Counter ( a_list ) <NEWLINE> k = 1 <NEWLINE> while k <= n : <NEWLINE> <INDENT> print ( dic [ str ( k ) ] ) <NEWLINE> k += 1 <NEWLINE> <DEDENT>
<NL> from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> dic = set ( ) <NEWLINE> L = sys . stdin . readlines ( ) <NEWLINE> <NL> for Ins in L [ 1 : ] : <NEWLINE> <INDENT> ins , op = Ins . split ( ) <NEWLINE> if ins == <STRING> : <NEWLINE> <INDENT> dic . add ( op ) <NEWLINE> <DEDENT> if ins == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if op in dic else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> a_goketi = sum ( a ) <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( a_goketi - a [ i ] ) <NEWLINE> a_goketi -= a [ i ] <NEWLINE> <NL> ans += a [ i ] * b [ i ] <NEWLINE> <NL> <DEDENT> ans %= 1000000007 <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 < numlist . count ( 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> total = 1 <NEWLINE> for i in numlist : <NEWLINE> <INDENT> total *= i <NEWLINE> if 10 ** 18 < total : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> num = 7 <NEWLINE> <NL> <COMMENT> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> num = num % K <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> num = 10 * num + 7 <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = dict ( [ ] ) <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> cmd , word = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> a [ word ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if word in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> colors = [ 0 ] * n <NEWLINE> def dfs ( v , color ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> colors [ v ] = color <NEWLINE> for to in g [ v ] : <NEWLINE> <INDENT> if colors [ to ] == color : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if colors [ to ] == 0 : <NEWLINE> <INDENT> if not dfs ( to , - color ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_bipartite ( ) : <NEWLINE> <INDENT> return dfs ( 0 , 1 ) <NEWLINE> <NL> <DEDENT> if is_bipartite ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( colors . count ( - 1 ) * colors . count ( 1 ) - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( ( n * ( n - 1 ) ) // 2 - m ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( i + a [ i ] ) <NEWLINE> r . append ( i - a [ i ] ) <NEWLINE> <DEDENT> c = collections . Counter ( r ) <NEWLINE> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += c . get ( i , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> m , n = input ( ) . split ( ) <NEWLINE> if m == <STRING> and n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( int ( m ) ) : <NEWLINE> <INDENT> print ( <STRING> * int ( n ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> adj = [ list ( map ( int , input ( ) . split ( ) ) ) [ 2 : ] for _ in range ( n ) ] <NEWLINE> <NL> d = [ - 1 ] * n <NEWLINE> <NL> s = 1 <NEWLINE> q = [ ] <NEWLINE> d [ s - 1 ] = 0 <NEWLINE> q . append ( s ) <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> u = q . pop ( ) <NEWLINE> v = adj [ u - 1 ] <NEWLINE> for vi in v : <NEWLINE> <INDENT> if d [ vi - 1 ] == - 1 : <NEWLINE> <INDENT> d [ vi - 1 ] = d [ u - 1 ] + 1 <NEWLINE> q . append ( vi ) <NEWLINE> <DEDENT> elif d [ vi - 1 ] > d [ u - 1 ] + 1 : <NEWLINE> <INDENT> d [ vi - 1 ] = d [ u - 1 ] + 1 <NEWLINE> q . append ( vi ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , di in enumerate ( d ) : <NEWLINE> <INDENT> print ( i + 1 , di ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> C = tuple ( map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) ) <NEWLINE> <NL> temp = map ( int , read ( ) . split ( ) ) <NEWLINE> temp = zip ( temp , temp ) <NEWLINE> <NL> adj = [ list ( ) for _ in range ( N ) ] <NEWLINE> for a , b in temp : <NEWLINE> <INDENT> adj [ a - 1 ] . append ( b - 1 ) <NEWLINE> adj [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> parent = [ None ] * N <NEWLINE> parent [ 0 ] = - 1 <NEWLINE> <NL> stack = [ 0 ] <NEWLINE> order = [ ] <NEWLINE> while stack : <NEWLINE> <INDENT> p = stack . pop ( ) <NEWLINE> order . append ( p ) <NEWLINE> for c in adj [ p ] : <NEWLINE> <INDENT> if parent [ c ] is None : <NEWLINE> <INDENT> parent [ c ] = p <NEWLINE> stack . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge ( a , b ) : <NEWLINE> <INDENT> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> for k , v in a . items ( ) : <NEWLINE> <INDENT> b [ k ] += v <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> dp = [ defaultdict ( int ) for _ in range ( N ) ] <COMMENT> <NEWLINE> subtreesize = [ 0 ] * N <NEWLINE> cnt = [ N * ( N + 1 ) // 2 ] * N <NEWLINE> <NL> for c in reversed ( order ) : <NEWLINE> <INDENT> p = parent [ c ] <NEWLINE> if p >= 0 : <NEWLINE> <INDENT> dp [ c ] [ C [ c ] ] = subtreesize [ c ] + 1 <NEWLINE> x = subtreesize [ c ] - dp [ c ] [ C [ p ] ] + 1 <NEWLINE> cnt [ C [ p ] ] -= x * ( x + 1 ) // 2 <NEWLINE> subtreesize [ p ] += subtreesize [ c ] + 1 <NEWLINE> <NL> dp [ p ] = merge ( dp [ c ] , dp [ p ] ) <NEWLINE> dp [ c ] = None <NEWLINE> <NL> <DEDENT> <DEDENT> dp [ 0 ] [ C [ 0 ] ] = subtreesize [ 0 ] + 1 <NEWLINE> for c in range ( N ) : <NEWLINE> <INDENT> x = subtreesize [ 0 ] - dp [ 0 ] [ c ] + 1 <NEWLINE> cnt [ c ] -= x * ( x + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( * cnt , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> Awithidx = [ [ a , i ] for i , a in enumerate ( A ) ] <NEWLINE> sortedA = sorted ( Awithidx , reverse = True ) <NEWLINE> <COMMENT> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = sortedA [ i ] [ 0 ] <NEWLINE> idx = sortedA [ i ] [ 1 ] <NEWLINE> for l in range ( i + 1 ) : <NEWLINE> <INDENT> r = i - l <NEWLINE> dp [ i + 1 ] [ l ] = max ( dp [ i + 1 ] [ l ] , dp [ i ] [ l ] + a * abs ( ( N - r - 1 ) - idx ) ) <NEWLINE> dp [ i + 1 ] [ l + 1 ] = max ( dp [ i + 1 ] [ l + 1 ] , dp [ i ] [ l ] + a * abs ( l - idx ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp [ N ] ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_dict = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Li = a_ls [ i ] + i + 1 <NEWLINE> L_dict [ Li ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> Rj = j + 1 - a_ls [ j ] <NEWLINE> ans += L_dict [ Rj ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> result = [ math . inf for i in range ( n ) ] <NEWLINE> <NL> result [ 0 ] = 0 <NEWLINE> result [ 1 ] = abs ( arr [ 1 ] - arr [ 0 ] ) <NEWLINE> <NL> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> a1 = abs ( arr [ i ] - arr [ i - 2 ] ) + result [ i - 2 ] <NEWLINE> a2 = abs ( arr [ i ] - arr [ i - 1 ] ) + result [ i - 1 ] <NEWLINE> <NL> result [ i ] = min ( a1 , a2 ) <NEWLINE> <NL> <NL> <DEDENT> print ( result [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> calculate ( N , ARR ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import defaultdict , deque <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 2 ) <NEWLINE> <NL> N , M = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> dic = defaultdict ( list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> dic [ A ] . append ( B ) <NEWLINE> dic [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> L = [ - 1 ] * ( N + 1 ) <NEWLINE> R = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> <NL> d = deque ( ) <NEWLINE> d . append ( ( 1 , 1 ) ) <NEWLINE> while len ( d ) : <NEWLINE> <INDENT> now , count = d . popleft ( ) <NEWLINE> for goto in dic [ now ] : <NEWLINE> <INDENT> if L [ goto ] == - 1 or count < L [ goto ] : <NEWLINE> <INDENT> L [ goto ] = count <NEWLINE> R [ goto ] = now <NEWLINE> d . append ( ( goto , count + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if any ( x + 1 for x in R [ 2 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for x in R [ 2 : ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <NL> def lcs ( X , Y ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( len ( Y ) + 1 ) <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> tmp = dp [ : ] <NEWLINE> for j , y in enumerate ( Y ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> dp [ j + 1 ] = tmp [ j ] + 1 <NEWLINE> <DEDENT> elif dp [ j + 1 ] < dp [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( lcs ( X , Y ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> nil = - 1 <NEWLINE> <NL> def set_depth ( v , depth ) : <NEWLINE> <INDENT> tree [ v ] [ 2 ] = depth <NEWLINE> <NL> for child in tree [ v ] [ 1 ] : <NEWLINE> <INDENT> set_depth ( child , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> tree = [ [ nil , [ ] , 0 , <STRING> ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> t_id = line [ 0 ] <NEWLINE> children = line [ 2 : ] <NEWLINE> <NL> tree [ t_id ] [ 1 ] = children <NEWLINE> <NL> if children : <NEWLINE> <INDENT> tree [ t_id ] [ 3 ] = <STRING> <NEWLINE> <NL> <DEDENT> for child in children : <NEWLINE> <INDENT> tree [ child ] [ 0 ] = t_id <NEWLINE> <NL> <DEDENT> <DEDENT> for t_id in range ( n ) : <NEWLINE> <INDENT> if tree [ t_id ] [ 0 ] == nil : <NEWLINE> <INDENT> tree [ t_id ] [ 3 ] = <STRING> <NEWLINE> r = t_id <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> set_depth ( r , 0 ) <NEWLINE> <NL> for t_id in range ( n ) : <NEWLINE> <INDENT> parent = tree [ t_id ] [ 0 ] <NEWLINE> depth = tree [ t_id ] [ 2 ] <NEWLINE> children = tree [ t_id ] [ 1 ] <NEWLINE> type_t = tree [ t_id ] [ 3 ] <NEWLINE> <NL> print ( <STRING> . format ( <NEWLINE> <INDENT> t_id , parent , depth , type_t , children ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def primes ( x ) : <NEWLINE> <INDENT> if x < 2 : return [ ] <NEWLINE> <NL> primes = [ i for i in range ( x ) ] <NEWLINE> primes [ 1 ] = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for prime in primes : <NEWLINE> <INDENT> if prime > math . sqrt ( x ) : break <NEWLINE> if prime == 0 : continue <NEWLINE> for non_prime in range ( 2 * prime , x , prime ) : primes [ non_prime ] = 0 <NEWLINE> <NL> <DEDENT> return [ prime for prime in primes if prime != 0 ] <NEWLINE> <NL> <DEDENT> prime_list = primes ( 1000000 ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> count = 0 <NEWLINE> for p in prime_list : <NEWLINE> <INDENT> if p > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> road . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> judge = [ 1 ] * N <NEWLINE> <NL> for r in road : <NEWLINE> <INDENT> h1 = H [ r [ 0 ] - 1 ] <NEWLINE> h2 = H [ r [ 1 ] - 1 ] <NEWLINE> if h1 < h2 : <NEWLINE> <INDENT> judge [ r [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> if h1 == h2 : <NEWLINE> <INDENT> judge [ r [ 0 ] - 1 ] = judge [ r [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> if h1 > h2 : <NEWLINE> <INDENT> judge [ r [ 1 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( judge ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from math import log <NEWLINE> <NL> <NL> def change_into_int ( lists ) : <NEWLINE> <INDENT> tmps = lists . split ( <STRING> ) <NEWLINE> num_list = [ ] <NEWLINE> for n in tmps : <NEWLINE> <INDENT> num_list . append ( int ( n ) ) <NEWLINE> <DEDENT> return num_list <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> result_list = [ ] <NEWLINE> <COMMENT> <NL> for l in sys . stdin : <NEWLINE> <INDENT> lines . append ( l . rstrip ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> num1 = change_into_int ( lines [ 0 ] ) <NEWLINE> data = change_into_int ( lines [ 1 ] ) <NEWLINE> i = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> ans = data [ i ] - data [ i + num1 [ 1 ] ] <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> if i + num1 [ 1 ] == len ( data ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> ans = sum ( A ) <NEWLINE> lst = np . zeros ( 10 ** 5 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> lst [ a ] += 1 <NEWLINE> <NL> <DEDENT> for q in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( C - B ) * lst [ B ] <NEWLINE> print ( int ( ans ) ) <NEWLINE> lst [ C ] += lst [ B ] <NEWLINE> lst [ B ] = 0 <NEWLINE> <DEDENT>
from itertools import groupby <NEWLINE> import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> S = [ [ i , len ( list ( j ) ) ] for i , j in groupby ( S ) ] <NEWLINE> <NL> if len ( S ) // 2 <= K : <NEWLINE> <INDENT> if len ( S ) % 2 == 1 and S [ - 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( sum ( [ j for i , j in S ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( [ j for i , j in S ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> lidx = - 1 <NEWLINE> for i , j in S : <NEWLINE> <INDENT> lidx += 1 <NEWLINE> if cnt == K and i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += j <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> sidx = 0 <NEWLINE> mans = ans <NEWLINE> for i in range ( lidx , len ( S ) ) : <NEWLINE> <INDENT> ans += S [ i ] [ 1 ] <NEWLINE> if i == len ( S ) - 1 or S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> ans -= S [ sidx ] [ 1 ] <NEWLINE> sidx += 1 <NEWLINE> if S [ sidx ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> mans = max ( mans , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mans ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = n // i <NEWLINE> ans += i * ( x * ( x + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A + 1 >= 2 * K : <COMMENT> <NEWLINE> <INDENT> res_list = [ i for i in range ( A , A + K ) ] + [ i for i in range ( B - K + 1 , B + 1 ) ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> res_list = [ i for i in range ( A , B + 1 ) ] <NEWLINE> <DEDENT> for i in res_list : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> k = N - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( k , i , - 1 ) : <NEWLINE> <INDENT> if c [ j ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> c [ i ] = <STRING> <NEWLINE> c [ j ] = <STRING> <NEWLINE> k = j - 1 <NEWLINE> break <NEWLINE> <DEDENT> if j == i + 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> A = dict ( zip ( A , B ) ) <NEWLINE> A = sorted ( A . items ( ) ) <NEWLINE> ans = [ str ( x [ 1 ] ) for x in A ] <NEWLINE> <NL> <NL> print ( <STRING> . join ( ans ) ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> <NL> limit = 10 ** 18 <NEWLINE> result = 1 <NEWLINE> for i in a [ : : - 1 ] : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def SieveOfEratosthenes ( n ) : <NEWLINE> <INDENT> prime = [ True for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while ( p * p <= n ) : <NEWLINE> <INDENT> if ( prime [ p ] == True ) : <NEWLINE> <INDENT> for i in range ( p * 2 , 10 ** 6 + 1 , p ) : <NEWLINE> <INDENT> if prime [ i ] : prime [ i ] = False <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <DEDENT> prime [ 0 ] , prime [ 1 ] = False , False <NEWLINE> count = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if prime [ p ] and p >= n : <NEWLINE> <INDENT> print ( p ) ; break <NEWLINE> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> SieveOfEratosthenes ( n ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ais = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> ais . append ( ai ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if len ( ais ) > 0 and ais [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> ais . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if len ( ais ) > 0 and ais [ 0 ] == i : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> ais . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] % 1000000007 ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a_ind = bisect . bisect_left ( A , b ) <NEWLINE> c_ind = bisect . bisect_right ( C , b ) <NEWLINE> ans += a_ind * ( n - c_ind ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = [ 0 ] * M <NEWLINE> s = [ 0 ] * M <NEWLINE> b = [ 0 ] * N <NEWLINE> pena = 0 <NEWLINE> corr = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p [ i ] , s [ i ] = input ( ) . split ( ) <NEWLINE> p [ i ] = int ( p [ i ] ) <NEWLINE> if b [ p [ i ] - 1 ] != - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> pena += b [ p [ i ] - 1 ] <NEWLINE> corr += 1 <NEWLINE> b [ p [ i ] - 1 ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ p [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( corr , pena ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> Is = [ input ( ) for i in range ( K ) ] <NEWLINE> Ns = [ input ( ) for i in range ( K ) ] <NEWLINE> atk_I = 0 <NEWLINE> atk_N = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i , n in zip ( Is , Ns ) : <NEWLINE> <INDENT> i_n = [ i , n ] <NEWLINE> if ( i_n . count ( <STRING> ) == 2 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif ( i_n . count ( <STRING> ) == 1 ) : <NEWLINE> <INDENT> if ( i_n . count ( <STRING> ) == 1 ) : <NEWLINE> <INDENT> exec ( <STRING> . format ( <STRING> if i [ 0 ] == <STRING> else <STRING> ) ) <NEWLINE> if ( atk_I > 5 ) : <NEWLINE> <INDENT> atk_I = 5 <NEWLINE> <DEDENT> elif ( atk_N > 5 ) : <NEWLINE> <INDENT> atk_N = 5 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( i [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> if ( atk_I == 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( atk_I == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> atk_I = 0 <NEWLINE> <DEDENT> <DEDENT> elif ( n [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> if ( atk_N == 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( atk_N == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> atk_N = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( i_n . count ( <STRING> ) == 2 ) : <NEWLINE> <INDENT> if ( atk_I > atk_N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( atk_I == atk_N ) : <NEWLINE> <INDENT> atk_I = 0 <NEWLINE> atk_N = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif ( i_n . count ( <STRING> ) == 1 ) : <NEWLINE> <INDENT> if ( i [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> if ( atk_I == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( atk_N == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> atk_I += 1 if atk_I != 5 else 0 <NEWLINE> atk_N += 1 if atk_N != 5 else 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> INF = 10 ** 20 <NEWLINE> def minimum_cost ( rest , h , init , dic ) : <NEWLINE> <INDENT> if h in dic : <NEWLINE> <INDENT> return dic [ h ] <NEWLINE> <NL> <DEDENT> if not h : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ret = INF <NEWLINE> for nex in rest : <NEWLINE> <INDENT> accnex = acc [ nex ] <NEWLINE> cumsnex = cums [ nex ] <NEWLINE> nex_init = init + accnex <NEWLINE> nex_rest = rest [ : ] <NEWLINE> nex_rest . remove ( nex ) <NEWLINE> nex_h = h - 2 ** nex <NEWLINE> tmp = minimum_cost ( nex_rest , nex_h , nex_init , dic ) + accnex - ( cumsnex [ nex_init ] - cumsnex [ init ] ) <NEWLINE> if ret > tmp : <NEWLINE> <INDENT> ret = tmp <NEWLINE> <DEDENT> <DEDENT> dic [ h ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> acc = [ 0 ] * m <NEWLINE> cums = [ [ 0 ] for _ in range ( m ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> acc [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cums [ i ] . append ( acc [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dic = { } <NEWLINE> h = sum ( [ 2 ** i for i in range ( m ) ] ) <NEWLINE> print ( minimum_cost ( [ i for i in range ( m ) ] , h , 0 , dic ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> score = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> b = sum ( a ) <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> b -= a [ i ] <NEWLINE> score += a [ i ] * b <NEWLINE> <NL> <DEDENT> print ( score % mod ) <NEWLINE>
import heapq <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> m = max ( l ) <NEWLINE> dp = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for n in l : <NEWLINE> <INDENT> for j in range ( n , m + 1 , n ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in l : <NEWLINE> <INDENT> if dp [ n ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> not_l , ans = [ ] , [ ] <NEWLINE> if not x in l : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> for i in range ( 0 , max ( l ) + 3 ) : <NEWLINE> <INDENT> if not i in l : <NEWLINE> <INDENT> not_l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( not_l ) ) : <NEWLINE> <INDENT> ans . append ( [ not_l [ j ] , abs ( not_l [ j ] - x ) ] ) <NEWLINE> <DEDENT> ans . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> print ( ans [ 0 ] [ 0 ] ) <NEWLINE>
import collections <NEWLINE> <NL> from scipy . special import comb <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> aa = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( s ) ] <NEWLINE> aa . append ( * s ) <NEWLINE> <NL> <DEDENT> cc = collections . Counter ( aa ) <NEWLINE> c = [ c [ 1 ] for c in cc . items ( ) if c [ 1 ] > 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> ans += comb ( c [ i ] , 2 , exact = True ) <NEWLINE> <NL> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<COMMENT> <NL> def counting_sort ( input_list : list , upper : int ) -> list : <NEWLINE> <INDENT> number = len ( input_list ) <NEWLINE> <NL> <COMMENT> <NL> b = [ 0 for i in range ( number + 1 ) ] <NEWLINE> <COMMENT> <NL> counter_list = [ 0 for i in range ( upper + 1 ) ] <NEWLINE> <NL> for j in input_list : <NEWLINE> <INDENT> counter_list [ j ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> counter_list [ i ] += counter_list [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( number ) : <NEWLINE> <INDENT> b [ counter_list [ input_list [ j ] ] ] = input_list [ j ] <NEWLINE> counter_list [ input_list [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 2000000 <NEWLINE> a = counting_sort ( a , k ) <NEWLINE> a . pop ( 0 ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ i + a [ i ] for i in range ( n ) ] <NEWLINE> r = [ i - a [ i ] for i in range ( n ) ] <NEWLINE> countl = Counter ( l ) <NEWLINE> countr = Counter ( r ) <NEWLINE> ans = sum ( [ countl [ i ] * countr [ i ] for i in countl . keys ( ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = A [ 0 ] <NEWLINE> i = 1 <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> t = t * A [ i ] <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if t <= 10 ** 18 : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( n , k , lst ) : <NEWLINE> <INDENT> for i in range ( n - k ) : <NEWLINE> <INDENT> if lst [ i + k ] > lst [ i ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( n , k , lst ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = len ( R ) * len ( G ) * len ( B ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> f = s [ i - 1 : : - 1 ] <NEWLINE> b = s [ i + 1 : ] <NEWLINE> for j in range ( min ( len ( f ) , len ( b ) ) ) : <NEWLINE> <INDENT> if f [ j ] != s [ i ] and f [ j ] != b [ j ] and s [ i ] != b [ j ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] <NEWLINE> c = [ 0 ] * n <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ca = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ i ] , a [ i ] = ca [ 0 ] , ca [ 1 : ] <NEWLINE> <NL> <DEDENT> for s in range ( 0 , 1 << n ) : <NEWLINE> <INDENT> smart = [ 0 ] * m <NEWLINE> cost = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s >> i ) % 2 == 0 : continue <NEWLINE> cost += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> smart [ j ] += a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ok = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if smart [ i ] < x : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10001 <NEWLINE> B = A [ : ] <NEWLINE> C = [ 0 ] * m <NEWLINE> for a in A : C [ a ] += 1 <NEWLINE> for i in range ( 1 , m ) : C [ i ] += C [ i - 1 ] <NEWLINE> for j in A [ : : - 1 ] : B [ C [ j ] - 1 ] = j ; C [ j ] -= 1 <NEWLINE> print ( * B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ikeru = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ikeru [ a - 1 ] . append ( ( b - 1 , i ) ) <NEWLINE> <NL> <DEDENT> settansaku = set ( [ ] ) <NEWLINE> setmada = { 0 } <NEWLINE> listmada = [ ( 0 , None ) ] <COMMENT> <NEWLINE> kouho = 1 <NEWLINE> num = [ 0 for _ in range ( n - 1 ) ] <NEWLINE> <NL> while kouho != 0 : <NEWLINE> <INDENT> for i , cnt in listmada [ : ] : <NEWLINE> <INDENT> colors = { cnt } <NEWLINE> settansaku . add ( i ) <NEWLINE> setmada . remove ( i ) <NEWLINE> listmada . remove ( ( i , cnt ) ) <NEWLINE> kouho -= 1 <NEWLINE> c = 0 <NEWLINE> for k , j in ikeru [ i ] : <NEWLINE> <INDENT> if not k in setmada : <NEWLINE> <INDENT> if not k in settansaku : <NEWLINE> <INDENT> setmada . add ( k ) <NEWLINE> while True : <NEWLINE> <INDENT> if c not in colors : <NEWLINE> <INDENT> listmada . append ( ( k , c ) ) <NEWLINE> colors . add ( c ) <NEWLINE> num [ j ] = c <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> kouho += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( num ) + 1 ) <NEWLINE> print ( <STRING> . join ( [ str ( i + 1 ) for i in num ] ) ) <NEWLINE>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> pos = { } <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> pos [ A [ h ] [ w ] ] = [ h , w ] <NEWLINE> <NL> <DEDENT> <DEDENT> S = [ 0 ] * ( H * W ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> now = d + 1 <NEWLINE> while now + D <= H * W : <NEWLINE> <INDENT> nowh , noww = pos [ now ] <NEWLINE> newh , neww = pos [ now + D ] <NEWLINE> tmp += abs ( nowh - newh ) + abs ( noww - neww ) <NEWLINE> S [ now + D - 1 ] = tmp <NEWLINE> now += D <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = S [ R - 1 ] - S [ L - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_dic = dict ( ) <NEWLINE> t_dic = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d1 = d [ i ] <NEWLINE> if d1 not in d_dic . keys ( ) : <NEWLINE> <INDENT> d_dic [ d1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d_dic [ d1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> t1 = t [ i ] <NEWLINE> if t1 in d_dic . keys ( ) : <NEWLINE> <INDENT> d_dic [ t1 ] -= 1 <NEWLINE> if d_dic [ t1 ] < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( p , q ) <NEWLINE> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if r == 1 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + math . gcd ( temp , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<NL> import sys <NEWLINE> from functools import reduce <NEWLINE> def rerooting ( N , adj , merge , finalize , identity ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> order = [ None ] * N <NEWLINE> parent = [ None ] * N <NEWLINE> parent [ 0 ] = - 1 <NEWLINE> stack = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> order [ i ] = v <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if parent [ u ] is None : <NEWLINE> <INDENT> parent [ u ] = v <NEWLINE> stack . append ( u ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> dp_down = [ None ] * N <NEWLINE> for v in reversed ( order [ 1 : ] ) : <NEWLINE> <INDENT> p = parent [ v ] <NEWLINE> dp_down [ v ] = finalize ( reduce ( merge , <NEWLINE> <INDENT> ( dp_down [ c ] for c in adj [ v ] if c != p ) , <NEWLINE> identity ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> dp_up = [ None ] * N <NEWLINE> dp_up [ 0 ] = identity <NEWLINE> for v in order : <NEWLINE> <INDENT> if len ( adj [ v ] ) == 1 and adj [ v ] [ 0 ] == parent [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p = parent [ v ] <NEWLINE> left = [ dp_up [ v ] ] <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if u != p : <NEWLINE> <INDENT> left . append ( merge ( left [ - 1 ] , dp_down [ u ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> right = [ identity ] <NEWLINE> for u in reversed ( adj [ v ] ) : <NEWLINE> <INDENT> if u != p : <NEWLINE> <INDENT> right . append ( merge ( dp_down [ u ] , right [ - 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> i = 0 <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if u != p : <NEWLINE> <INDENT> dp_up [ u ] = finalize ( merge ( left [ i ] , right [ - i - 2 ] ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for v , l in enumerate ( adj ) : <NEWLINE> <INDENT> order [ v ] = reduce ( merge , <NEWLINE> <INDENT> ( dp_down [ u ] for u in adj [ v ] if u != parent [ v ] ) , <NEWLINE> identity ) <NEWLINE> <DEDENT> order [ v ] = finalize ( merge ( order [ v ] , dp_up [ v ] ) ) <NEWLINE> <NL> <DEDENT> return order <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , edges ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> factorio = [ None ] * ( N + 1 ) <NEWLINE> factorio [ 0 ] = 1 <NEWLINE> t = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t *= i <NEWLINE> t %= MOD <NEWLINE> factorio [ i ] = t <NEWLINE> <NL> <DEDENT> factorio_inv = [ None ] * ( N + 1 ) <NEWLINE> factorio_inv [ 0 ] = 1 <NEWLINE> t = pow ( factorio [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> for i in reversed ( range ( 1 , N + 1 ) ) : <NEWLINE> <INDENT> factorio_inv [ i ] = t <NEWLINE> t *= i <NEWLINE> t %= MOD <NEWLINE> <NL> <NL> <DEDENT> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def func ( x , y ) : <NEWLINE> <INDENT> cx , nx = x <NEWLINE> cy , ny = y <NEWLINE> c = cx * cy * factorio [ nx + ny ] * factorio_inv [ nx ] * factorio_inv [ ny ] <NEWLINE> return c % MOD , nx + ny <NEWLINE> <NL> <DEDENT> def func2 ( x ) : <NEWLINE> <INDENT> c , n = x <NEWLINE> return c , n + 1 <NEWLINE> <NL> <DEDENT> identity = ( 1 , 0 ) <NEWLINE> <NL> res = rerooting ( N , adj , func , func2 , identity ) <NEWLINE> <NL> for k , n in res : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> edges = tuple ( ( a - 1 , b - 1 ) for a , b in zip ( m , m ) ) <NEWLINE> <NL> solve ( N , edges ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def isOK ( i , A , K ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return K >= sum ( ( a - 1 ) // i for a in A ) <NEWLINE> <NL> <DEDENT> def b_serach ( A , K ) : <NEWLINE> <INDENT> ng = - 1 <NEWLINE> ok = 10 ** 9 + 1 <NEWLINE> <NL> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isOK ( mid , A , K ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> print ( b_serach ( A , K ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> deq = deque ( ) <NEWLINE> sub_deq = { } <NEWLINE> for cmd in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if cmd == <STRING> : <NEWLINE> <INDENT> while deq : <NEWLINE> <INDENT> data = deq . pop ( ) <NEWLINE> if data [ 1 ] : <NEWLINE> <INDENT> data [ 1 ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> while deq : <NEWLINE> <INDENT> data = deq . popleft ( ) <NEWLINE> if data [ 1 ] : <NEWLINE> <INDENT> data [ 1 ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cmd , val = cmd . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> data = [ val , 1 ] <NEWLINE> deq . append ( data ) <NEWLINE> if val not in sub_deq : <NEWLINE> <INDENT> sub_deq [ val ] = [ data ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sub_deq [ val ] . append ( data ) <NEWLINE> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if val in sub_deq : <NEWLINE> <INDENT> deq_v = sub_deq [ val ] <NEWLINE> while deq_v : <NEWLINE> <INDENT> data = deq_v . pop ( ) <NEWLINE> if data [ 1 ] : <NEWLINE> <INDENT> data [ 1 ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> . join ( data [ 0 ] for data in reversed ( deq ) if data [ 1 ] ) ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] > q - k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> taste_lists = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> taste = l + i <NEWLINE> taste_lists . append ( taste ) <NEWLINE> <NL> <DEDENT> eat = 0 <NEWLINE> if taste_lists [ 0 ] > 0 and taste_lists [ - 1 ] > 0 : <NEWLINE> <INDENT> eat = taste_lists [ 0 ] <NEWLINE> <DEDENT> elif taste_lists [ 0 ] < 0 and taste_lists [ - 1 ] < 0 : <NEWLINE> <INDENT> eat = taste_lists [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> eat = 0 <NEWLINE> <NL> <DEDENT> taste_lists . remove ( eat ) <NEWLINE> ans = 0 <NEWLINE> for i in taste_lists : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections as c <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> z = set ( [ ] ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( s ) <NEWLINE> y . append ( t ) <NEWLINE> z . add ( tuple ( [ s , t ] ) ) <NEWLINE> <DEDENT> a = c . Counter ( x ) <NEWLINE> b = c . Counter ( y ) <NEWLINE> a = a . most_common ( ) <NEWLINE> b = b . most_common ( ) <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> e = a [ 0 ] [ 1 ] <NEWLINE> f = b [ 0 ] [ 1 ] <NEWLINE> <NL> for sa in a : <NEWLINE> <INDENT> if sa [ 1 ] == e : <NEWLINE> <INDENT> c . append ( sa [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for sb in b : <NEWLINE> <INDENT> if sb [ 1 ] == f : <NEWLINE> <INDENT> d . append ( sb [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> fl = 0 <NEWLINE> ans = e + f - 1 <NEWLINE> for s in c : <NEWLINE> <INDENT> for t in d : <NEWLINE> <INDENT> if tuple ( [ s , t ] ) not in z : <NEWLINE> <INDENT> fl = 1 <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if fl == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> num [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( c - b ) * num [ b ] <NEWLINE> print ( sum ) <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> dup = 0 <NEWLINE> RGB = set ( ( <STRING> , <STRING> , <STRING> ) ) <NEWLINE> <NL> for width in range ( N // 2 + 10 ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if set ( ( S [ i ] , S [ i + width ] , S [ i + width * 2 ] ) ) == RGB : <NEWLINE> <INDENT> dup += 1 <NEWLINE> <DEDENT> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = Counter ( S ) <NEWLINE> retval = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] - dup <NEWLINE> print ( retval ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> <NL> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> if j - i == k - j : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def hahaha ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> list = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> list . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> list . sort ( ) <NEWLINE> a = list [ 0 ] <NEWLINE> for j in range ( 0 , n ) : <NEWLINE> <INDENT> if a != list [ j ] : <NEWLINE> <INDENT> a = list [ j ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> hahaha ( ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> h = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> raw_input = input ( ) <NEWLINE> if raw_input == <STRING> : <NEWLINE> <INDENT> pri , item = heappop ( h ) <NEWLINE> print ( item ) <NEWLINE> <DEDENT> elif raw_input == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cmd , pri = raw_input . split ( ) <NEWLINE> heappush ( h , ( - 1 * int ( pri ) , pri ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> butnum = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> butnum [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> pushbut = 1 <NEWLINE> pushedbut = [ ] <NEWLINE> jud = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pushbut = butnum [ pushbut ] <NEWLINE> if pushbut == 2 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> jud = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if jud == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> tot = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tot += math . gcd ( gcd_ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> n = min ( x , y ) <NEWLINE> <NL> print ( gcd ( x , y ) ) <NEWLINE>
import collections <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = dict ( collections . Counter ( LI ( ) ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count = A . get ( i ) <NEWLINE> print ( count if count is not None else 0 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 99999999 ) <NEWLINE> <NL> <NL> [ n , m ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> friends = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> friends . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> tomodachi = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> tomodachi [ friends [ i ] [ 0 ] - 1 ] . append ( friends [ i ] [ 1 ] - 1 ) <NEWLINE> tomodachi [ friends [ i ] [ 1 ] - 1 ] . append ( friends [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tomodachi [ i ] = list ( set ( tomodachi [ i ] ) ) <NEWLINE> <NL> <DEDENT> namelist = [ 1 for i in range ( n ) ] <NEWLINE> teams = [ ] <NEWLINE> <NL> def haba ( x , kari , tomodachi , namelist ) : <NEWLINE> <INDENT> for i in range ( len ( tomodachi [ x ] ) ) : <NEWLINE> <INDENT> if namelist [ tomodachi [ x ] [ i ] ] == 1 : <COMMENT> <NEWLINE> <INDENT> kari . append ( tomodachi [ x ] [ i ] ) <NEWLINE> namelist [ tomodachi [ x ] [ i ] ] = 0 <COMMENT> <NEWLINE> haba ( tomodachi [ x ] [ i ] , kari , tomodachi , namelist ) <NEWLINE> <DEDENT> <DEDENT> return ( kari ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if namelist [ i ] == 1 : <NEWLINE> <INDENT> teams . append ( list ( set ( haba ( i , [ i ] , tomodachi , namelist ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> saidai = 0 <NEWLINE> <NL> for i in range ( len ( teams ) ) : <NEWLINE> <INDENT> if saidai < len ( teams [ i ] ) : <NEWLINE> <INDENT> saidai = len ( teams [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = saidai <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> lst = [ 0 ] * 3 <NEWLINE> <NL> for aa in a : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> j = - 1 <NEWLINE> for i , l in enumerate ( lst ) : <NEWLINE> <INDENT> if l == aa : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> j = i <NEWLINE> <DEDENT> <DEDENT> if j == - 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= cnt <NEWLINE> ans %= MOD <NEWLINE> lst [ j ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
memo = input ( ) . split ( ) <NEWLINE> a , b = [ int ( i ) for i in memo ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 and ( 0 not in a ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( int ( 2e6 ) ) <NEWLINE> <NL> def dfs ( u , p = 0 ) : <NEWLINE> <INDENT> vis [ u ] = True <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> if not vis [ v ] : <NEWLINE> <INDENT> dfs ( v , u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> assert 2 <= n <= int ( 1e5 ) <NEWLINE> assert 1 <= m <= int ( 1e5 ) <NEWLINE> g = [ list ( ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> assert 1 <= u <= int ( 1e5 ) <NEWLINE> assert 1 <= v <= int ( 1e5 ) <NEWLINE> assert u < v <NEWLINE> g [ u ] . append ( v ) <NEWLINE> g [ v ] . append ( u ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> vis = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not vis [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( c - 1 ) <NEWLINE>
def binary_search ( c1 , c2 ) : <NEWLINE> <INDENT> m = ( c1 + c2 + 1 ) // 2 <NEWLINE> if abs ( c1 - c2 ) <= 1 : <NEWLINE> <INDENT> return m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt += ( i - 1 ) // m <NEWLINE> <COMMENT> <NL> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> c2 = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c1 = m <NEWLINE> <DEDENT> return binary_search ( c1 , c2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = binary_search ( 0 , 10 ** 9 ) <NEWLINE> for i in range ( x + 5 , max ( x - 5 , 0 ) , - 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> cnt += ( j - 1 ) // i <NEWLINE> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans if not k == 0 else max ( a ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> lis = { } <NEWLINE> counter = 0 <NEWLINE> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> str = <STRING> . join ( sorted ( list ( input ( ) . rstrip ( ) ) ) ) <NEWLINE> if str in lis : <NEWLINE> <INDENT> lis [ str ] += 1 <NEWLINE> counter += lis [ str ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ str ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a < x + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> ans = 0 <NEWLINE> for a in As : <NEWLINE> <INDENT> ans += a <NEWLINE> nums [ a ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * nums [ b ] <NEWLINE> nums [ c ] += nums [ b ] <NEWLINE> nums [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> AN = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in AN : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for A in AN : <NEWLINE> <INDENT> ans *= A <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> if len ( b ) == 4 : <NEWLINE> <INDENT> b = int ( b [ 0 ] + b [ 2 : ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> b = int ( b [ 0 ] + b [ 2 ] + <STRING> ) <NEWLINE> <DEDENT> tmp = str ( a * b ) <NEWLINE> if len ( tmp ) <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = str ( a * b ) [ : - 2 ] <NEWLINE> print ( int ( tmp ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> op , st = input ( ) . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> h [ st ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h . get ( st , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> <NL> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( min ( b - 1 , n ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = i [ 0 ] <NEWLINE> M = i [ 1 ] <NEWLINE> <NL> l = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] ) <NEWLINE> <NL> limit1 = max ( l [ : , 0 ] ) <NEWLINE> limit2 = min ( l [ : , 1 ] ) <NEWLINE> <NL> print ( max ( limit2 - limit1 + 1 , 0 ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( _text : str ) : <NEWLINE> <INDENT> print ( _text . upper ( ) ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> text = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> main ( text ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = defaultdict ( lambda : 0 ) <NEWLINE> lis_h = [ 0 ] * H <NEWLINE> lis_w = [ 0 ] * W <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> bomb [ ( h , w ) ] = 1 <NEWLINE> lis_h [ h ] += 1 <NEWLINE> lis_w [ w ] += 1 <NEWLINE> <DEDENT> m_h = max ( lis_h ) <NEWLINE> m_w = max ( lis_w ) <NEWLINE> m_h_lis = [ ] <NEWLINE> m_w_lis = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if lis_h [ i ] == m_h : <NEWLINE> <INDENT> m_h_lis . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> if lis_w [ i ] == m_w : <NEWLINE> <INDENT> m_w_lis . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for h in m_h_lis : <NEWLINE> <INDENT> for w in m_w_lis : <NEWLINE> <INDENT> if bomb [ ( h , w ) ] == 0 : <NEWLINE> <INDENT> return m_h + m_w <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return m_h + m_w - 1 <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
from math import ceil <NEWLINE> <NL> N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> left = 1 <NEWLINE> right = max ( A ) <NEWLINE> while left != right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> temp = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> temp += ceil ( x / mid ) - 1 <NEWLINE> if temp > K : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> for i in range ( max ( 1 , left - 1 ) , left + 2 ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> temp += ceil ( x / i ) - 1 <NEWLINE> if temp > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> ls . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( ls ) ) ) <NEWLINE>
import heapq as pq <NEWLINE> inf = float ( <STRING> ) <NEWLINE> n , e = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> M [ s ] . append ( t ) <NEWLINE> <NL> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> if not visit [ s ] : <NEWLINE> <INDENT> visit [ s ] = True <NEWLINE> stack [ s ] = True <NEWLINE> for t in M [ s ] : <NEWLINE> <INDENT> if stack [ t ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : dfs ( t ) <NEWLINE> <DEDENT> <DEDENT> stack [ s ] = False <NEWLINE> <NL> <DEDENT> visit = [ False for _ in range ( n ) ] <NEWLINE> stack = [ False for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( [ n // ( 2 * pow ( 5 , i ) ) for i in range ( 1 , math . ceil ( math . log ( n + 1 , 5 ) ) ) ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> a = [ e for e in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> l = [ ] <NEWLINE> <NL> <NL> for x in a : <NEWLINE> <NL> <INDENT> if x not in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = l . pop ( ) <NEWLINE> b = l . pop ( ) <NEWLINE> <NL> if x == <STRING> : <NEWLINE> <INDENT> l . append ( b + a ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> l . append ( b - a ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> l . append ( b * a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
S = input ( ) <NEWLINE> leng = len ( S ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> <NL> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> <NL> num = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for char in S : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> count [ num ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <NL> <DEDENT> res = 0 <NEWLINE> for cnt in count : <NEWLINE> <INDENT> res += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
from collections import defaultdict <NEWLINE> di = defaultdict ( int ) <NEWLINE> dj = defaultdict ( int ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> di [ i + a ] += 1 <NEWLINE> dj [ i - a ] += 1 <NEWLINE> <DEDENT> X = set ( di . keys ( ) ) & set ( dj . keys ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> ans += di [ x ] * dj [ x ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def gfunc ( n ) : <NEWLINE> <INDENT> return int ( ( n * ( n + 1 ) ) / 2 ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * gfunc ( N // i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ListK = [ i + 1 + List [ i ] for i in range ( N ) ] <NEWLINE> ListL = [ i + 1 - List [ i ] for i in range ( N ) ] <NEWLINE> <NL> from collections import Counter <NEWLINE> ans = 0 <NEWLINE> <NL> NewlistK = Counter ( ListK ) <NEWLINE> NewlistL = Counter ( ListL ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += ( NewlistK [ i ] ) * ( NewlistL [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in N : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans *= N [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= ( 10 ** 18 ) and ans != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A1 = [ 0 , 0 ] <NEWLINE> A2 = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S = S + i <NEWLINE> <NL> <DEDENT> if K > 1 : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> A1 [ 0 ] = j <NEWLINE> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> A1 [ 1 ] = k <NEWLINE> S += 6 * gcd ( A1 [ 1 ] , A1 [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if K > 2 : <NEWLINE> <INDENT> for i1 in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> A2 [ 0 ] = i1 <NEWLINE> for k1 in range ( i1 + 1 , K ) : <NEWLINE> <INDENT> A2 [ 1 ] = k1 <NEWLINE> for j1 in range ( k1 + 1 , K + 1 ) : <NEWLINE> <INDENT> A2 [ 2 ] = j1 <NEWLINE> G3 = gcd ( A2 [ 2 ] , A2 [ 1 ] ) <NEWLINE> if G3 >= A2 [ 0 ] : <NEWLINE> <INDENT> S += 6 * gcd ( G3 , A2 [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += 6 * gcd ( A2 [ 0 ] , G3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Nums = input ( ) . split ( ) <NEWLINE> <NL> AA = set ( Nums ) <NEWLINE> <NL> if <STRING> in AA : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A *= int ( Nums [ i ] ) <NEWLINE> if A > 10 ** 18 : <NEWLINE> <INDENT> A = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> b = [ A [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> b . append ( b [ - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( b ) <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> <NL> for v in cnt . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> check = [ True ] * N <NEWLINE> item = <STRING> <NEWLINE> item_ = <STRING> <NEWLINE> dict_item = { } <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> item_ = S [ i ] <NEWLINE> if item_ != item : <NEWLINE> <INDENT> item = item_ <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * N <NEWLINE> for u in range ( N - 1 ) : <NEWLINE> <INDENT> s [ a [ u ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> if l != [ ] : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if l == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <DEDENT>
n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> n = n % k <NEWLINE> if abs ( n - k ) < n : <NEWLINE> <INDENT> print ( abs ( n - k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
def sumproductsofpairs ( lst ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> psum = 0 <NEWLINE> for x in lst : <NEWLINE> <INDENT> total += psum * x <NEWLINE> psum += x <NEWLINE> <DEDENT> return total % ( 1000000007 ) <NEWLINE> <DEDENT> b = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sumproductsofpairs ( A ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> if x - i not in a : <NEWLINE> <INDENT> ans = x - i <NEWLINE> break <NEWLINE> <DEDENT> elif x + i not in a : <NEWLINE> <INDENT> ans = x + i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> b = N // a <NEWLINE> if a * b == N : <NEWLINE> <INDENT> cnt = cnt + b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt + b <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> def d ( s , t ) : <NEWLINE> <INDENT> return sum ( [ 1 if i != j else 0 for i , j in zip ( s , t ) ] ) <NEWLINE> <NL> <DEDENT> print ( min ( [ d ( S [ i : ] , T ) for i in range ( len ( S ) - len ( T ) + 1 ) ] ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( 0 , B + A - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def mapint_inp ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def intinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> N = intinp ( ) <NEWLINE> A = list ( mapint_inp ( ) ) <NEWLINE> <NL> lim = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> f = True <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for A_i in A : <NEWLINE> <INDENT> ans = ans * A_i <NEWLINE> if ans > lim : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 0 <NEWLINE> r = 0 <NEWLINE> if N > 1000000 : <NEWLINE> <INDENT> M = N <NEWLINE> <NL> <NL> <DEDENT> for i in range ( min ( N , 1000000 ) ) : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> j = int ( N / ( m ) ) <NEWLINE> r = r + int ( m * j * ( 1 + j ) / 2 ) <NEWLINE> <NL> <DEDENT> if M != 0 : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> k = int ( M / ( i + 1 ) ) <NEWLINE> if k > 1000000 : <NEWLINE> <INDENT> r = r + ( i + 1 ) * int ( ( k - 1000000 ) * ( k + 1000001 ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def solve ( prev , r , dic ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> t = r <NEWLINE> stack = [ ] <NEWLINE> stack += [ [ prev , r , d ] ] <NEWLINE> while stack : <NEWLINE> <INDENT> prev , r , d1 = stack . pop ( - 1 ) <NEWLINE> if r in dic : <NEWLINE> <INDENT> for vtx , cost in dic [ r ] : <NEWLINE> <INDENT> if vtx == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack += [ [ r , vtx , d1 + cost ] ] <NEWLINE> if d < d1 + cost : <NEWLINE> <INDENT> d = d1 + cost <NEWLINE> t = vtx <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d , t <NEWLINE> <NL> <DEDENT> line = input ( ) <NEWLINE> n = int ( line ) <NEWLINE> edge = { } <NEWLINE> for _ in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s , t , d = list ( map ( int , line . split ( ) ) ) <NEWLINE> if s not in edge : <NEWLINE> <INDENT> edge [ s ] = [ [ t , d ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ s ] += [ [ t , d ] ] <NEWLINE> <DEDENT> if t not in edge : <NEWLINE> <INDENT> edge [ t ] = [ [ s , d ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ t ] += [ [ s , d ] ] <NEWLINE> <DEDENT> <DEDENT> r1 , t1 = solve ( - 1 , 0 , edge ) <NEWLINE> r2 , t2 = solve ( - 1 , t1 , edge ) <NEWLINE> print ( r2 ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c = collections . Counter ( S ) <NEWLINE> if <STRING> in c . keys ( ) and <STRING> in c . keys ( ) and <STRING> in c . keys ( ) : <NEWLINE> <INDENT> ans = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for x in range ( ( ( N - i ) - 1 ) // 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + x + 1 ] and S [ i ] != S [ i + 2 * ( x + 1 ) ] and S [ i + x + 1 ] != S [ i + 2 * ( x + 1 ) ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> sentence = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sentence += input ( ) . lower ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i ) , sentence . count ( chr ( i ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( map ( int , i . split ( ) ) ) for i in sys . stdin . readlines ( ) ] <NEWLINE> G = [ [ None for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <NL> for i in range ( W ) : <NEWLINE> <INDENT> if C [ 0 ] [ i ] == 0 : <NEWLINE> <INDENT> G [ 0 ] [ i ] = 1 <NEWLINE> <DEDENT> else : G [ 0 ] [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if C [ i ] [ 0 ] == 0 : <NEWLINE> <INDENT> G [ i ] [ 0 ] = 1 <NEWLINE> <DEDENT> else : G [ i ] [ 0 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> if C [ i ] [ j ] == 0 : <NEWLINE> <INDENT> G [ i ] [ j ] = min ( G [ i - 1 ] [ j ] , G [ i ] [ j - 1 ] , G [ i - 1 ] [ j - 1 ] ) + 1 <NEWLINE> <DEDENT> else : G [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( max ( i ) for i in G ) ** 2 <NEWLINE> print ( str ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ next ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> AA = sorted ( A , reverse = True ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i != AA [ 0 ] : <NEWLINE> <INDENT> print ( AA [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( AA [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.14159265358979323846264338 <NEWLINE> print ( <STRING> % ( pi * r * r , 2 * pi * r ) ) <NEWLINE>
int = int ( input ( ) ) <NEWLINE> y = 1000 <NEWLINE> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> z = y * i <NEWLINE> if int <= z : <NEWLINE> <INDENT> o = z - int <NEWLINE> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( o ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> edge = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <DEDENT> signpost = [ None ] * ( N + 1 ) <NEWLINE> signpost [ 0 ] = signpost [ 1 ] = 0 <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> dist = [ 0 for i in range ( N + 1 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> for e in edge [ node ] : <NEWLINE> <INDENT> if signpost [ e ] is None : <NEWLINE> <INDENT> dist [ e ] = dist [ node ] + 1 <NEWLINE> signpost [ e ] = node <NEWLINE> q . append ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if 0 in signpost [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in signpost [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
MAX = 1000000007 <NEWLINE> <NL> m , n = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> bi_n = bin ( n ) <NEWLINE> <NL> ans = 1 <NEWLINE> dig = m <NEWLINE> for i in range ( len ( bi_n ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> if bi_n [ i ] == <STRING> : ans *= dig <NEWLINE> if ans >= MAX : ans %= MAX <NEWLINE> dig *= dig <NEWLINE> if dig >= MAX : dig %= MAX <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> res = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> res += i * s % mod <NEWLINE> <DEDENT> print ( res % mod ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if B <= A : <NEWLINE> <INDENT> B *= 2 <NEWLINE> <DEDENT> elif C <= B : <NEWLINE> <INDENT> C *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if B > A and C > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> command = sys . stdin . readlines ( ) <NEWLINE> Q = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = command [ i ] . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> Q [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b in Q . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> L , R = [ ] , [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l1 , r1 = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l1 ) <NEWLINE> R . append ( r1 ) <NEWLINE> <NL> <DEDENT> dp = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dpsum = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> Li = i - R [ j ] <NEWLINE> Ri = i - L [ j ] <NEWLINE> if Ri < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Li = max ( 1 , Li ) <NEWLINE> dp [ i ] += dpsum [ Ri ] - dpsum [ Li - 1 ] <COMMENT> <NEWLINE> dp [ i ] %= 998244353 <NEWLINE> <NL> <DEDENT> dpsum [ i ] = ( dpsum [ i - 1 ] + dp [ i ] ) % 998244353 <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> dict_a = Counter ( a ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= b * dict_a [ b ] <NEWLINE> s += c * dict_a [ b ] <NEWLINE> dict_a [ c ] += dict_a [ b ] <NEWLINE> dict_a [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> dic = { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dic [ <STRING> ] . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> dic [ <STRING> ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> cnt = len ( dic [ <STRING> ] ) * len ( dic [ <STRING> ] ) * len ( dic [ <STRING> ] ) <NEWLINE> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( n - 2 * i ) : <NEWLINE> <INDENT> if s [ j ] != s [ j + i ] and s [ j + i ] != s [ j + i + i ] and s [ j ] != s [ j + i + i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , m = nm ( ) <NEWLINE> H = [ ] <NEWLINE> W = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hh , ww = nm ( ) <NEWLINE> H . append ( hh ) <NEWLINE> W . append ( ww ) <NEWLINE> <DEDENT> h_m = Counter ( H ) . most_common ( ) [ 0 ] <NEWLINE> w_m = Counter ( W ) . most_common ( ) [ 0 ] <NEWLINE> ans_1 = h_m [ 1 ] <NEWLINE> ans_2 = w_m [ 1 ] <NEWLINE> WW = [ ] <NEWLINE> HH = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if H [ i ] == h_m [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> WW . append ( W [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if W [ i ] == w_m [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> HH . append ( H [ i ] ) <NEWLINE> <DEDENT> if WW : <NEWLINE> <INDENT> ans_1 += Counter ( WW ) . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> if HH : <NEWLINE> <INDENT> ans_2 += Counter ( HH ) . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <NL> <DEDENT> print ( max ( ans_1 , ans_2 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s ^= a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ans [ j ] = s ^ a [ j ] <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> R = r * 2 * 3.14159265358979 <NEWLINE> S = r ** 2 * 3.14159265358979 <NEWLINE> print ( S , R ) <NEWLINE>
import sys <NEWLINE> <NL> A = list ( map ( int , sys . stdin . read ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> n = A [ 0 ] <NEWLINE> del A [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> <NL> G = [ i for i in [ 262913 , 65921 , 16577 , 4193 , 1073 , 281 , 77 , 23 , 8 , 1 ] if i <= n ] <NEWLINE> <NL> m = len ( G ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> g = G [ i ] <NEWLINE> <COMMENT> <NL> for j in range ( g , n ) : <NEWLINE> <INDENT> v = A [ j ] <NEWLINE> k = j - g <NEWLINE> while ( k >= 0 ) and ( A [ k ] > v ) : <NEWLINE> <INDENT> A [ k + g ] = A [ k ] <NEWLINE> k -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ k + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> x = i + 1 <NEWLINE> y = N - i - 1 <NEWLINE> if y - x > ( N - y + x ) : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( i + 1 , N - i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from math import sqrt , ceil <NEWLINE> <NL> def check_prime_number ( n ) : <NEWLINE> <INDENT> sqrt_num = ceil ( sqrt ( n ) ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif ( n % 2 ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> div = 3 <NEWLINE> while div <= sqrt_num : <NEWLINE> <INDENT> if ( n % div ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> div += 2 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def count_prime_numbers ( n_list ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for n in n_list : <NEWLINE> <INDENT> if check_prime_number ( n ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> target_list = [ int ( input ( ) ) for i in range ( num ) ] <NEWLINE> print ( count_prime_numbers ( target_list ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> i = 1 <NEWLINE> n = 1 <NEWLINE> cnt = 0 <NEWLINE> while 2 * i <= 2 * N : <NEWLINE> <INDENT> cnt += A [ n ] <NEWLINE> i += 1 <NEWLINE> n += 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ ] <NEWLINE> G = [ [ ] for i in range ( n ) ] <NEWLINE> RG = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> E . append ( ( a - 1 , b - 1 , c ) ) <NEWLINE> G [ a - 1 ] . append ( ( b - 1 , c , i ) ) <NEWLINE> RG [ b - 1 ] . append ( ( a - 1 , c , i ) ) <NEWLINE> <DEDENT> def dijkstra ( G , s ) : <NEWLINE> <INDENT> dist = [ 10 ** 18 ] * n <NEWLINE> dist [ s ] = 0 <NEWLINE> que = [ ( 0 , s ) ] <NEWLINE> while que : <NEWLINE> <INDENT> co , v = heappop ( que ) <NEWLINE> if dist [ v ] < co : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for w , c , i in G [ v ] : <NEWLINE> <INDENT> if co + c < dist [ w ] : <NEWLINE> <INDENT> dist [ w ] = co + c <NEWLINE> heappush ( que , ( co + c , w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <DEDENT> D = dijkstra ( G , 0 ) <NEWLINE> RD = dijkstra ( RG , 1 ) <NEWLINE> <NL> G0 = [ [ ] for i in range ( n ) ] <NEWLINE> used = set ( [ 1 ] ) <NEWLINE> deq = deque ( [ 1 ] ) <NEWLINE> P = set ( ) <NEWLINE> while deq : <NEWLINE> <INDENT> v = deq . popleft ( ) <NEWLINE> for w , c , i in RG [ v ] : <NEWLINE> <INDENT> if D [ w ] + c == D [ v ] : <NEWLINE> <INDENT> P . add ( i ) <NEWLINE> if w not in used : <NEWLINE> <INDENT> used . add ( w ) <NEWLINE> deq . append ( w ) <NEWLINE> <DEDENT> G0 [ v ] . append ( ( w , i ) ) <NEWLINE> G0 [ w ] . append ( ( v , i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> PB = set ( ) <NEWLINE> label = [ None ] * n <NEWLINE> gen = 1 <NEWLINE> cost = [ 0 ] * n <NEWLINE> def dfs ( u , p , i ) : <NEWLINE> <INDENT> global gen <NEWLINE> res = 0 <NEWLINE> p_cnt = 0 <NEWLINE> for v , j in G0 [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> p_cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if label [ v ] is not None : <NEWLINE> <INDENT> if label [ v ] < label [ u ] : <NEWLINE> <INDENT> cost [ v ] += 1 <NEWLINE> res += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> label [ v ] = gen ; gen += 1 <NEWLINE> res += dfs ( v , u , j ) <NEWLINE> <DEDENT> <DEDENT> res -= cost [ u ] <NEWLINE> if res == 0 and p != - 1 and p_cnt == 1 : <NEWLINE> <INDENT> PB . add ( i ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> label [ 0 ] = 0 <NEWLINE> dfs ( 0 , - 1 , None ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i in P : <NEWLINE> <INDENT> if i in PB : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , b , c = E [ i ] <NEWLINE> if D [ b ] + c + RD [ a ] < D [ 1 ] : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if h [ a [ i ] [ 0 ] - 1 ] > h [ a [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans . append ( a [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif h [ a [ i ] [ 0 ] - 1 ] < h [ a [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans . append ( a [ i ] [ 0 ] ) <NEWLINE> <DEDENT> if h [ a [ i ] [ 0 ] - 1 ] == h [ a [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans . append ( a [ i ] [ 0 ] ) <NEWLINE> ans . append ( a [ i ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = set ( ans ) <NEWLINE> <NL> print ( int ( len ( h ) ) - int ( len ( ans ) ) ) <NEWLINE> <COMMENT> <NL> <NL> 1 , 4 , 4 <NEWLINE>
s = input ( ) <NEWLINE> <NL> print ( <STRING> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] <NEWLINE> b *= 10 ** 5 + 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> <DEDENT> ans = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> d = b [ bi ] <NEWLINE> b [ ci ] += d <NEWLINE> b [ bi ] = 0 <NEWLINE> ans = ans + d * ( ci - bi ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> b = <STRING> <NEWLINE> if 0 < int ( s [ 0 : 2 ] ) < 13 : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> if 0 < int ( s [ 2 : 5 ] ) < 13 : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <NL> <DEDENT> if a == b == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class Stack : <NEWLINE> <INDENT> MAX = 101 <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . S = [ None ] * self . __class__ . MAX <NEWLINE> self . top = 0 <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . top == 0 <NEWLINE> <NL> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> return self . top >= self . __class__ . MAX - 1 <NEWLINE> <NL> <DEDENT> def push ( self , x ) : <NEWLINE> <INDENT> self . top += 1 <NEWLINE> self . S [ self . top ] = x <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> self . top -= 1 <NEWLINE> return self . S [ self . top + 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> arr = [ str ( s ) for s in input ( ) . split ( ) ] <NEWLINE> stack = Stack ( ) <NEWLINE> for s in arr : <NEWLINE> <INDENT> if s in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> stack . push ( <NEWLINE> <INDENT> eval ( <STRING> . join ( map ( str , [ stack . pop ( ) , s , stack . pop ( ) ] [ : : - 1 ] ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stack . push ( int ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack . pop ( ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a_inputs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> dic_l = { } <NEWLINE> dic_r = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a_inputs [ i ] + ( i + 1 ) <NEWLINE> b = ( i + 1 ) - a_inputs [ i ] <NEWLINE> dic_l [ a ] = dic_l . get ( a , 0 ) + 1 <NEWLINE> dic_r [ b ] = dic_r . get ( b , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key in dic_l . keys ( ) : <NEWLINE> <INDENT> ans += dic_l [ key ] * dic_r . get ( key , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Max_Bit : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . size = n <NEWLINE> self . tree = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def get_max ( self , i = None ) : <NEWLINE> <INDENT> if i is None : <NEWLINE> <INDENT> i = self . size <NEWLINE> <DEDENT> m = 0 <COMMENT> <NEWLINE> while i > 0 : <NEWLINE> <INDENT> m = max ( m , self . tree [ i ] ) <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] = max ( x , self . tree [ i ] ) <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = Max_Bit ( N ) <NEWLINE> sort_H_i = sorted ( ( h , i ) for i , h in enumerate ( H ) ) <NEWLINE> for h , i in sort_H_i : <NEWLINE> <INDENT> dp . update ( i + 1 , dp . get_max ( i ) + A [ i ] ) <NEWLINE> <DEDENT> print ( dp . get_max ( ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
Row = int ( input ( ) ) <NEWLINE> List = list ( input ( ) for i in range ( Row ) ) <NEWLINE> print ( len ( set ( List ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> <NL> class Dictionary ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . dict = { } <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> self . dict [ x ] = 0 <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if x in self . dict . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> d = Dictionary ( ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> command , key = list ( input ( ) . split ( ) ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> d . insert ( key ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> d . find ( key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( a , b , c , k ) : <NEWLINE> <INDENT> if a >= k : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a - ( k - a - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solve ( A , B , C , K ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> if res > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif res == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input1 = input ( ) <NEWLINE> input1 = input1 . split ( ) <NEWLINE> N = int ( input1 [ 0 ] ) <NEWLINE> M = int ( input1 [ 1 ] ) <NEWLINE> <NL> aisle = { } <NEWLINE> result = [ 0 ] * ( N - 1 ) <NEWLINE> record = [ 1 ] <NEWLINE> count = N - 1 <NEWLINE> in1 = 0 <NEWLINE> in2 = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> input2 = input ( ) <NEWLINE> input2 = input2 . split ( ) <NEWLINE> in1 = int ( input2 [ 0 ] ) <NEWLINE> in2 = int ( input2 [ 1 ] ) <NEWLINE> aisle . setdefault ( in1 , [ ] ) . append ( in2 ) <NEWLINE> aisle . setdefault ( in2 , [ ] ) . append ( in1 ) <NEWLINE> <NL> <DEDENT> while count != 0 and len ( record ) != 0 : <NEWLINE> <INDENT> pop1 = record . pop ( 0 ) <NEWLINE> if pop1 in aisle : <NEWLINE> <INDENT> for i in aisle [ pop1 ] : <NEWLINE> <INDENT> if result [ i - 2 ] == 0 and i >= 2 : <NEWLINE> <INDENT> result [ i - 2 ] = pop1 <NEWLINE> record . append ( i ) <NEWLINE> count = count - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( len ( result ) ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> t01 = <STRING> <NEWLINE> t10 = <STRING> <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> t01 += <STRING> <NEWLINE> t10 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t01 += <STRING> <NEWLINE> t10 += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> l1 = [ int ( a ) for a in t01 ] <NEWLINE> l2 = [ int ( a ) for a in t10 ] <NEWLINE> left = [ 0 ] + list ( accumulate ( l1 ) ) [ : - 1 ] <NEWLINE> right = list ( accumulate ( l2 [ : : - 1 ] ) ) [ - 2 : : - 1 ] + [ 0 ] <NEWLINE> print ( min ( w + e for ( w , e ) in zip ( left , right ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> re = 1 <NEWLINE> <NL> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if re > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> re = re * li [ i ] <NEWLINE> <DEDENT> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif re > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( re ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , value , left = None , right = None ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class BinTree ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . _tree = None <NEWLINE> <NL> <DEDENT> def insert ( self , value ) : <NEWLINE> <INDENT> parent = None <NEWLINE> current = self . _tree <NEWLINE> <NL> while current is not None : <NEWLINE> <INDENT> parent = current <NEWLINE> if value < current . value : <NEWLINE> <INDENT> current = current . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = current . right <NEWLINE> <NL> <DEDENT> <DEDENT> if parent is None : <NEWLINE> <INDENT> self . _tree = Node ( value ) <NEWLINE> <DEDENT> elif value < parent . value : <NEWLINE> <INDENT> parent . left = Node ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = Node ( value ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preoder_walk ( self ) : <NEWLINE> <INDENT> def preoder ( node ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if node is None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( node . value ) <NEWLINE> result . extend ( preoder ( node . left ) ) <NEWLINE> result . extend ( preoder ( node . right ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> return preoder ( self . _tree ) <NEWLINE> <NL> <DEDENT> def inorder_walk ( self ) : <NEWLINE> <INDENT> def inorder ( node ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if node is None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . extend ( inorder ( node . left ) ) <NEWLINE> result . append ( node . value ) <NEWLINE> result . extend ( inorder ( node . right ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> return inorder ( self . _tree ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_tree ( tree ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( val ) for val in tree . inorder_walk ( ) ] ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( [ str ( val ) for val in tree . preoder_walk ( ) ] ) ) <NEWLINE> <NL> <NL> <DEDENT> def insert_main ( commands ) : <NEWLINE> <INDENT> tree = BinTree ( ) <NEWLINE> for com in commands : <NEWLINE> <INDENT> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> print_tree ( tree ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> commands = [ com . split ( ) for com in sys . stdin . readlines ( ) ] <NEWLINE> insert_main ( commands ) <NEWLINE> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <DEDENT> <DEDENT> class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> self . inorder = [ ] <NEWLINE> self . preorder = [ ] <NEWLINE> <NL> <DEDENT> def insert ( self , node ) : <NEWLINE> <NL> <INDENT> p = None <NEWLINE> x = self . root <NEWLINE> while x is not None : <NEWLINE> <INDENT> p = x <NEWLINE> <COMMENT> <NL> if node . key <= x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> node . parent = p <NEWLINE> <NL> if p is None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if node . key <= p . key : <NEWLINE> <COMMENT> <NL> <INDENT> p . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> p . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , key ) : <NEWLINE> <COMMENT> <NL> <INDENT> node = self . root <NEWLINE> while node is not None : <NEWLINE> <INDENT> if node . key == key : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> elif key <= node . key : <NEWLINE> <INDENT> node = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . right <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def delete ( self , z ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> p = z . parent <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> if z . left is None and z . right is None : <NEWLINE> <COMMENT> <NL> <INDENT> if p . left == z : <NEWLINE> <INDENT> p . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = None <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif z . left is not None and z . right is not None : <NEWLINE> <COMMENT> <NL> <INDENT> next_node = tree . get_next_node ( z ) <NEWLINE> <COMMENT> <NL> z . key = next_node . key <NEWLINE> self . delete ( next_node ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if p . left == z : <NEWLINE> <INDENT> if z . left is not None : <NEWLINE> <INDENT> p . left = z . left <NEWLINE> z . left . parent = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . left = z . right <NEWLINE> z . right . parent = p <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if z . left is not None : <NEWLINE> <INDENT> p . right = z . left <NEWLINE> z . left . parent = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = z . right <NEWLINE> z . right . parent = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def get_next_node ( self , node ) : <NEWLINE> <INDENT> if node . right is not None : <NEWLINE> <COMMENT> <NL> <INDENT> return self . get_minimum ( node . right ) <NEWLINE> <DEDENT> p = x . parent <NEWLINE> while p is not None and p != p . parent . left : <NEWLINE> <INDENT> p = p . parent <NEWLINE> <DEDENT> return p . parent <NEWLINE> <NL> <DEDENT> def get_minimum ( self , node ) : <NEWLINE> <INDENT> x = node <NEWLINE> <COMMENT> <NL> while x . left is not None : <NEWLINE> <INDENT> x = x . left <NEWLINE> <COMMENT> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def print_inorder ( self ) : <NEWLINE> <INDENT> self . inorder = [ ] <NEWLINE> self . inorder_traverse ( self . root ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . inorder ) ) ) <NEWLINE> <NL> <DEDENT> def print_preorder ( self ) : <NEWLINE> <INDENT> self . preorder = [ ] <NEWLINE> self . preorder_traverse ( self . root ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . preorder ) ) ) <NEWLINE> <NL> <DEDENT> def inorder_traverse ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . inorder_traverse ( node . left ) <NEWLINE> self . inorder . append ( node . key ) <NEWLINE> self . inorder_traverse ( node . right ) <NEWLINE> <NL> <DEDENT> def preorder_traverse ( self , node ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . preorder . append ( node . key ) <NEWLINE> self . preorder_traverse ( node . left ) <NEWLINE> self . preorder_traverse ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> tree . print_inorder ( ) <NEWLINE> tree . print_preorder ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( line [ 1 ] ) <NEWLINE> tree . insert ( Node ( key ) ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( line [ 1 ] ) <NEWLINE> if tree . find ( key ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> key = int ( line [ 1 ] ) <NEWLINE> <COMMENT> <NL> node = tree . find ( key ) <NEWLINE> <COMMENT> <NL> tree . delete ( node ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
from collections import * <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> a = [ 0 ] * h <NEWLINE> b = [ 0 ] * w <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> a [ x ] += 1 <NEWLINE> b [ y ] += 1 <NEWLINE> d [ ( x , y ) ] += 1 <NEWLINE> <NL> <DEDENT> ma = max ( a ) <NEWLINE> mb = max ( b ) <NEWLINE> <NL> ind_x = [ i for i , j in enumerate ( a ) if j == ma ] <NEWLINE> ind_y = [ i for i , j in enumerate ( b ) if j == mb ] <NEWLINE> <NL> <NL> for x in ind_x : <NEWLINE> <INDENT> for y in ind_y : <NEWLINE> <INDENT> if d [ ( x , y ) ] == 0 : <NEWLINE> <INDENT> print ( ma + mb ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ma + mb - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> X1_dict = { } <NEWLINE> X2_dict = { } <NEWLINE> inp_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i , a_i in enumerate ( inp_list ) : <NEWLINE> <INDENT> X1 = i + 1 + a_i <NEWLINE> X2 = i + 1 - a_i <NEWLINE> if X1 in X1_dict . keys ( ) : <NEWLINE> <INDENT> X1_dict [ X1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X1_dict [ X1 ] = 1 <NEWLINE> <DEDENT> if X2 in X2_dict . keys ( ) : <NEWLINE> <INDENT> X2_dict [ X2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X2_dict [ X2 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for key , value in X1_dict . items ( ) : <NEWLINE> <INDENT> if key in X2_dict . keys ( ) : <NEWLINE> <INDENT> answer += value * X2_dict [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from functools import reduce <NEWLINE> from math import gcd <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> _ = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def inv ( a ) : <NEWLINE> <INDENT> return pow ( a , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def addmod ( a , b ) : <NEWLINE> <INDENT> return ( a + b ) % MOD <NEWLINE> <NL> <NL> <DEDENT> l = reduce ( lcm , la ) % MOD <NEWLINE> answer = reduce ( addmod , ( l * inv ( a ) for a in la ) , 0 ) <NEWLINE> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A , B = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> if ( N % 2 == 1 ) : <NEWLINE> <INDENT> l = A [ N // 2 ] <NEWLINE> r = B [ N // 2 ] <NEWLINE> cnt = r - l + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = A [ N // 2 - 1 ] + A [ N // 2 ] <NEWLINE> r = B [ N // 2 - 1 ] + B [ N // 2 ] <NEWLINE> cnt = r - l + 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K * 2 ) ] <NEWLINE> <NL> indexs = [ ] <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> indexs . append ( L [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> uniq_list = [ ] <NEWLINE> for li in indexs : <NEWLINE> <INDENT> for e in li : <NEWLINE> <INDENT> if e not in uniq_list : <NEWLINE> <INDENT> uniq_list . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - len ( uniq_list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> if L % 2 == 0 or L % 5 == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> tmp = 10 <NEWLINE> while True : <NEWLINE> <INDENT> tmp %= L <NEWLINE> if tmp == 1 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> tmp *= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> dd = { } <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> dd [ s [ i ] ] = 1 <NEWLINE> <DEDENT> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) ) : <NEWLINE> <INDENT> if j - i + 1 <= k : <NEWLINE> <INDENT> dd [ s [ i : j + 1 ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> li = [ ] <NEWLINE> for key in dd : <NEWLINE> <INDENT> li . append ( key ) <NEWLINE> <DEDENT> li . sort ( ) <NEWLINE> print ( li [ k - 1 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = math . pi * math . pow ( r , 2 ) <NEWLINE> c = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( a , c ) ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d = ( N - 1 ) // i <NEWLINE> c += d <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def c ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - a ) <NEWLINE> r = min ( N - 1 , i + a ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> <NL> K = min ( K , 50 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> A = c ( A ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
N , ma , mb = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> b = [ 0 ] * N <NEWLINE> c = [ 0 ] * N <NEWLINE> NMAX = 40 <NEWLINE> ABMAX = 10 <NEWLINE> INF = 1000000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> dp = [ [ [ INF ] * ( NMAX * ABMAX + 1 ) for _ in range ( NMAX * ABMAX + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for ca in range ( NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> for cb in range ( NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> if dp [ i ] [ ca ] [ cb ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i + 1 ] [ ca ] [ cb ] = min ( dp [ i + 1 ] [ ca ] [ cb ] , dp [ i ] [ ca ] [ cb ] ) <NEWLINE> dp [ i + 1 ] [ ca + a [ i ] ] [ cb + b [ i ] <NEWLINE> <INDENT> ] = min ( dp [ i + 1 ] [ ca + a [ i ] ] [ cb + b [ i ] ] , dp [ i ] [ ca ] [ cb ] + c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = INF <NEWLINE> for ca in range ( 1 , NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> for cb in range ( 1 , NMAX * ABMAX + 1 ) : <NEWLINE> <INDENT> if ca * mb == cb * ma : <NEWLINE> <INDENT> ans = min ( ans , dp [ N ] [ ca ] [ cb ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans if ans != INF else - 1 ) <NEWLINE>
from itertools import combinations_with_replacement as cr <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> nl = [ i for i in range ( 1 , m + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for v in cr ( nl , n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for a , b , c , d in l : <NEWLINE> <INDENT> if v [ b - 1 ] - v [ a - 1 ] == c : <NEWLINE> <INDENT> s += d <NEWLINE> <DEDENT> <DEDENT> if ans < s : <NEWLINE> <INDENT> ans = s <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> if len ( s ) >= 3 : <NEWLINE> <INDENT> n = [ s [ - 3 ] , s [ - 2 ] , s [ - 1 ] ] <NEWLINE> <DEDENT> if len ( s ) == 2 : <NEWLINE> <INDENT> n = [ s [ - 2 ] , s [ - 1 ] ] <NEWLINE> <DEDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> n = [ s [ 0 ] ] <NEWLINE> <DEDENT> n = <STRING> . join ( n ) <NEWLINE> n = int ( n ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> z = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> print ( z ) <NEWLINE> <NL>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> if B <= N : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> s = ( A * x ) // B - A * ( x // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> s = ( A * x ) // B - A * ( x // B ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> list . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n // 2 ) : <NEWLINE> <INDENT> ans += 2 * list [ i ] <NEWLINE> <DEDENT> ans -= list [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( n - 1 ) // 2 ) : <NEWLINE> <INDENT> ans += 2 * list [ i ] <NEWLINE> <DEDENT> ans += list [ ( n - 1 ) // 2 ] <NEWLINE> ans -= list [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
l = int ( input ( ) ) <NEWLINE> k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> o = sum ( k ) <NEWLINE> p = o ** 2 <NEWLINE> <NL> s = 0 <NEWLINE> for i in k : <NEWLINE> <INDENT> s = ( s + i ** 2 ) <NEWLINE> <NL> <DEDENT> print ( ( p - s ) // 2 % mod ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> a , v = map ( int , readline ( ) . split ( ) ) <NEWLINE> b , w = map ( int , readline ( ) . split ( ) ) <NEWLINE> t = int ( readline ( ) ) <NEWLINE> <NL> d = abs ( b - a ) <NEWLINE> <NL> d = d - ( v - w ) * t <NEWLINE> if d <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * n <NEWLINE> R = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ i ] = i + a [ i ] <NEWLINE> R [ i ] = i - a [ i ] <NEWLINE> <DEDENT> z1 = Counter ( L ) <NEWLINE> z2 = Counter ( R ) <NEWLINE> cnt = 0 <NEWLINE> for k1 , v1 in z1 . items ( ) : <NEWLINE> <INDENT> v2 = z2 [ k1 ] <NEWLINE> cnt += v1 * v2 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> area = math . pi * r ** 2 <NEWLINE> length = 2 * r * math . pi <NEWLINE> <NL> print ( <STRING> . format ( area , length ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> from collections import Counter <NEWLINE> import networkx as nx <NEWLINE> setrecursionlimit ( 1000000 ) <NEWLINE> def l_in ( type_ ) : return list ( map ( type_ , input ( ) . split ( ) ) ) <NEWLINE> def i_in ( ) : return int ( input ( ) ) <NEWLINE> def m_in ( type_ ) : return map ( type_ , input ( ) . split ( ) ) <NEWLINE> def r_in ( n , type_ ) : return [ type_ ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> def find_components ( n , connectors ) : <NEWLINE> <INDENT> g = nx . Graph ( ) <NEWLINE> for i in range ( n ) : g . add_node ( i + 1 ) <NEWLINE> g . add_edges_from ( connectors ) <NEWLINE> return len ( list ( nx . connected_components ( g ) ) ) <NEWLINE> <NL> <NL> <DEDENT> n , m = m_in ( int ) <NEWLINE> ab = [ list ( m_in ( int ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = find_components ( n , ab ) - 1 <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def extract_max ( A ) : <NEWLINE> <INDENT> x = A [ 0 ] <NEWLINE> A [ 0 ] = A [ - 1 ] <NEWLINE> A . pop ( ) <NEWLINE> H = len ( A ) <NEWLINE> i = 0 <NEWLINE> while i < H : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> rv = 0 <NEWLINE> lv = 0 <NEWLINE> r = ( i + 1 ) * 2 <NEWLINE> l = r - 1 <NEWLINE> if l < H : <NEWLINE> <INDENT> lv = A [ l ] <NEWLINE> if r < H : <NEWLINE> <INDENT> rv = A [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> if v < lv and lv > rv : <NEWLINE> <INDENT> A [ l ] = v <NEWLINE> A [ i ] = lv <NEWLINE> i = l <NEWLINE> <DEDENT> elif v < rv : <NEWLINE> <INDENT> A [ r ] = v <NEWLINE> A [ i ] = rv <NEWLINE> i = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def insert ( a , n ) : <NEWLINE> <INDENT> i = len ( a ) <NEWLINE> a . append ( n ) <NEWLINE> while i > 0 : <NEWLINE> <INDENT> p = int ( ( i + 1 ) / 2 ) - 1 <NEWLINE> v = a [ i ] <NEWLINE> pv = a [ p ] <NEWLINE> if pv < v : <NEWLINE> <INDENT> a [ p ] = v <NEWLINE> a [ i ] = pv <NEWLINE> i = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> istr = sys . stdin . read ( ) <NEWLINE> cmds = list ( istr . splitlines ( ) ) <NEWLINE> S = [ ] <NEWLINE> for cmd in cmds : <COMMENT> <NEWLINE> <INDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( S , int ( cmd [ 7 : ] ) ) <NEWLINE> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> a = extract_max ( S ) <NEWLINE> print ( a ) <NEWLINE> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> a = [ I ( ) - 1 for _ in range ( N ) ] <NEWLINE> <NL> c = 0 <NEWLINE> ans = 0 <NEWLINE> is_ok = True <NEWLINE> while True : <NEWLINE> <INDENT> c = a [ c ] <NEWLINE> ans += 1 <NEWLINE> if c == 0 or ans > N : <NEWLINE> <INDENT> is_ok = False <NEWLINE> break <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import heapq as hp <NEWLINE> import numpy as np <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = np . array ( [ list ( input ( ) ) for _ in range ( h ) ] ) <NEWLINE> s = np . pad ( s , 1 , <STRING> ) <NEWLINE> visited = np . zeros_like ( s , dtype = np . bool ) <NEWLINE> <NL> judge = np . inf <NEWLINE> <NL> q = [ ] <NEWLINE> hp . heappush ( q , ( 0 , 1 , 1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> cnt , y , x = hp . heappop ( q ) <NEWLINE> if y == h and x == w : <NEWLINE> <INDENT> judge = cnt <NEWLINE> break <NEWLINE> <DEDENT> for dy , dx in [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if s [ ny , nx ] == <STRING> and not visited [ ny , nx ] : <NEWLINE> <INDENT> visited [ ny , nx ] = True <NEWLINE> hp . heappush ( q , ( cnt + 1 , ny , nx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if judge == np . inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( s == <STRING> ) . sum ( ) - judge - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = ri ( ) <NEWLINE> a = rl ( ) <NEWLINE> t = sum ( a ) <NEWLINE> cnt_li = [ 0 ] * 10 ** 5 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt_li [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( ri ( ) ) : <NEWLINE> <INDENT> b , c = rm ( ) <NEWLINE> t += ( c - b ) * cnt_li [ b - 1 ] <NEWLINE> print ( t ) <NEWLINE> cnt_li [ c - 1 ] += cnt_li [ b - 1 ] <NEWLINE> cnt_li [ b - 1 ] = 0 <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> time = k <NEWLINE> aOnly = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> time -= a [ i ] <NEWLINE> if time < 0 : <NEWLINE> <INDENT> time += a [ i ] <NEWLINE> i -= 1 <NEWLINE> break <NEWLINE> <DEDENT> aOnly += 1 <NEWLINE> <DEDENT> a_idx = i <NEWLINE> b_idx = - 1 <NEWLINE> <NL> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> time -= b [ i ] <NEWLINE> if time < 0 : <NEWLINE> <INDENT> time += b [ i ] <NEWLINE> i -= 1 <NEWLINE> break <NEWLINE> <DEDENT> aOnly += 1 <NEWLINE> <DEDENT> b_idx = i <NEWLINE> ans = aOnly <NEWLINE> <NL> ans_kari = ans <NEWLINE> for i in range ( a_idx , - 1 , - 1 ) : <NEWLINE> <INDENT> time += a [ i ] <NEWLINE> ans_kari -= 1 <NEWLINE> for j in range ( b_idx + 1 , len ( b ) ) : <NEWLINE> <INDENT> time -= b [ j ] <NEWLINE> if time < 0 : <NEWLINE> <INDENT> time += b [ j ] <NEWLINE> b_idx = j - 1 <NEWLINE> break <NEWLINE> <DEDENT> ans_kari += 1 <NEWLINE> <DEDENT> ans = max ( ans , ans_kari ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = int ( input ( ) ) <NEWLINE> lists = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> for l in range ( k ) : <NEWLINE> <INDENT> sum = sum + math . gcd ( math . gcd ( i + 1 , j + 1 ) , l + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> res = 0 <NEWLINE> cnt = { 0 : 1 } <NEWLINE> now = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> now = ( now + ( 10 * p ) * int ( s [ i ] ) ) % 2019 <NEWLINE> cnt [ now ] = cnt . get ( now , 0 ) + 1 <NEWLINE> p = ( p * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> print ( sum ( cnt [ k ] * ( cnt [ k ] - 1 ) // 2 for k in cnt ) ) <NEWLINE>
import numpy as np <NEWLINE> import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = np . array ( [ i + 1 for i in range ( n ) ] ) <NEWLINE> C , D = A + B , B - A <NEWLINE> ans = 0 <NEWLINE> <NL> c = collections . Counter ( C ) <NEWLINE> d = collections . Counter ( D ) <NEWLINE> ans = 0 <NEWLINE> for i in c . keys ( ) : <NEWLINE> <INDENT> ans += c [ i ] * d [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( str , input ( ) ) ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , N // 2 + 2 ) : <NEWLINE> <INDENT> if i + 2 * j < N : <NEWLINE> <INDENT> if S [ i ] != S [ i + j ] and S [ i ] != S [ i + 2 * j ] and S [ i + j ] != S [ i + 2 * j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - ans ) <NEWLINE>
def calc ( s ) : <NEWLINE> <INDENT> t = s . split ( ) <NEWLINE> a = int ( t [ 0 ] ) <NEWLINE> b = int ( t [ 2 ] ) <NEWLINE> op = t [ 1 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> return ( <STRING> . format ( a + b ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> return ( <STRING> . format ( a - b ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> return ( <STRING> . format ( a * b ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> return ( <STRING> . format ( a // b ) ) <NEWLINE> <DEDENT> <DEDENT> w = <STRING> <NEWLINE> a = [ ] <NEWLINE> while ( w . split ( ) [ 1 ] != <STRING> ) : <NEWLINE> <INDENT> w = input ( ) <NEWLINE> a . append ( w ) <NEWLINE> <DEDENT> a . pop ( ) <NEWLINE> for st in a : <NEWLINE> <INDENT> print ( <STRING> . format ( calc ( st ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> record = { } <NEWLINE> <NL> possible = True <NEWLINE> <NL> <COMMENT> <NL> for e in a : <NEWLINE> <INDENT> if ( e in record . keys ( ) ) : <NEWLINE> <INDENT> record [ e ] += 1 <NEWLINE> if ( record [ e ] == 2 ) : <NEWLINE> <INDENT> if ( e == 0 ) : <NEWLINE> <INDENT> possible = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( record [ e ] == 3 ) : <NEWLINE> <INDENT> possible = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> record [ e ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( possible == False ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> multiCount = int ( n / 2 ) <NEWLINE> <NL> print ( 2 ** multiCount % ( 10 ** 9 + 7 ) ) <NEWLINE>
H , W , h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> p = ( 10 ** 9 - 1 ) // ( max ( h * w - 1 , 1 ) ) <NEWLINE> m = p * ( h * w - 1 ) + 1 <NEWLINE> vec = [ [ p for i in range ( W + 1 ) ] for j in range ( H + 1 ) ] <NEWLINE> sm = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if i % h == 0 and j % w == 0 : <NEWLINE> <INDENT> vec [ i ] [ j ] = - m <NEWLINE> <DEDENT> sm += vec [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if sm <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> print ( vec [ i ] [ j ] , end = <STRING> [ j == W ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> prod = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> R = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> R [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( R [ i ] ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from math import ceil as C , floor as F <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce as R <NEWLINE> <NL> ALP = <STRING> <NEWLINE> alp = <STRING> <NEWLINE> def _X ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> def _S ( ss ) : return tuple ( ss ) if len ( ss ) > 1 else ss [ 0 ] <NEWLINE> def S ( ) : return _S ( _X ( ) ) <NEWLINE> def _Ss ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Ss ( ) : return _Ss ( S ( ) ) <NEWLINE> def _I ( ss ) : return tuple ( [ int ( s ) for s in ss ] ) if isinstance ( ss , tuple ) else int ( ss ) <NEWLINE> def I ( ) : return _I ( S ( ) ) <NEWLINE> def _Is ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Is ( ) : return _Is ( I ( ) ) <NEWLINE> <NL> _ = I ( ) <NEWLINE> xs = Is ( ) <NEWLINE> <NL> sss = 0 <NEWLINE> count = D ( int ) <NEWLINE> for x in xs : <NEWLINE> <INDENT> sss += x <NEWLINE> count [ x ] += 1 <NEWLINE> <NL> <DEDENT> q = I ( ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = I ( ) <NEWLINE> sss += ( c - b ) * count [ b ] <NEWLINE> print ( sss ) <NEWLINE> count [ c ] += count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> group = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> group [ a ] . add ( b ) <NEWLINE> group [ b ] . add ( a ) <NEWLINE> <NL> <NL> <DEDENT> kisyutu = set ( ) <NEWLINE> deque = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i not in kisyutu : <NEWLINE> <INDENT> kisyutu . add ( i ) <NEWLINE> friend_set = group [ i ] <NEWLINE> <NL> deque . extend ( group [ i ] ) <NEWLINE> <NL> while deque : <NEWLINE> <INDENT> a1 = deque . pop ( ) <NEWLINE> if a1 not in kisyutu : <NEWLINE> <INDENT> kisyutu . add ( a1 ) <NEWLINE> friend_set . add ( a1 ) <NEWLINE> deque . extend ( group [ a1 ] ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , len ( friend_set ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if m != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import numpy <NEWLINE> <NL> tmp = input ( ) <NEWLINE> list = input ( ) . split ( <STRING> ) <NEWLINE> list = [ int ( x ) for x in list ] <NEWLINE> array = numpy . array ( list , dtype = <STRING> ) <NEWLINE> sum = numpy . sum ( array ) <NEWLINE> all = numpy . zeros ( 100001 , dtype = <STRING> ) <NEWLINE> for i in array : <NEWLINE> <INDENT> all [ i ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> b = input ( ) . split ( <STRING> ) <NEWLINE> b0 = int ( b [ 0 ] ) <NEWLINE> b1 = int ( b [ 1 ] ) <NEWLINE> diff = all [ b0 ] * ( b1 - b0 ) <NEWLINE> sum += diff <NEWLINE> all [ b1 ] += all [ b0 ] <NEWLINE> all [ b0 ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i * - 1 for i in a ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x = ( ( - 1 ) * heapq . heappop ( a ) ) // 2 <NEWLINE> heapq . heappush ( a , - x ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum1 = sum1 + Alist [ i ] <NEWLINE> sum2 = sum2 + ( Alist [ i ] ) ** 2 <NEWLINE> <DEDENT> ans = ( sum1 ** 2 - sum2 ) // 2 <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> ans = 0 <NEWLINE> <NL> def comb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> inv . append ( ( - inv [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> a = pow ( m - 1 , n - i - 1 , mod ) <NEWLINE> b = comb ( n - 1 , i , mod ) <NEWLINE> ans += ( a * b ) % mod <NEWLINE> <DEDENT> ans *= m <NEWLINE> print ( ans % mod ) <NEWLINE>
a = input ( ) <NEWLINE> N = int ( a ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> ind = A . index ( max ( A ) ) <NEWLINE> max = max ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == ind : <NEWLINE> <INDENT> B = sorted ( A ) <NEWLINE> print ( B [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> X = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Xs = list ( X ) <NEWLINE> Xs . sort ( ) <NEWLINE> for x in X : <NEWLINE> <INDENT> a = bisect . bisect_left ( Xs , x ) <NEWLINE> if a >= n / 2 : <NEWLINE> <INDENT> print ( Xs [ int ( n / 2 ) - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Xs [ int ( n / 2 ) ] ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import accumulate as acc <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , list ( input ( ) ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> acc_list = [ list ( acc ( [ 0 ] + s ) ) for s in S ] <NEWLINE> <NL> def solve ( l , x , limit ) : <NEWLINE> <INDENT> part_num = len ( l ) - 1 <NEWLINE> ok , ng = x , W + 1 <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> score = 0 <NEWLINE> for i in range ( part_num ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( l [ i ] , l [ i + 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> s += acc_list [ j ] [ mid ] - acc_list [ j ] [ x ] <NEWLINE> <DEDENT> score = max ( s , score ) <NEWLINE> <DEDENT> if score <= limit : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> min_num = 10 ** 18 <NEWLINE> for i in range ( 1 << ( H - 1 ) ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for j in range ( H - 1 ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> l . append ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> h_split_num = len ( l ) <NEWLINE> l = [ 0 ] + l + [ H ] <NEWLINE> x = solve ( l , 0 , K ) <NEWLINE> w_split_num = 0 <NEWLINE> flag = True <NEWLINE> while x < W : <NEWLINE> <INDENT> w_split_num += 1 <NEWLINE> r = solve ( l , x , K ) <NEWLINE> if x == r : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> x = r <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> split_num = w_split_num + h_split_num <NEWLINE> min_num = min ( split_num , min_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
import os <NEWLINE> from io import BytesIO , IOBase <NEWLINE> import sys <NEWLINE> from collections import defaultdict , deque <NEWLINE> import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += ( n // i - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> BUFSIZE = 8192 <NEWLINE> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> five = [ 0 ] * 200 <NEWLINE> five_inv = [ 0 ] * 200 <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> five [ i ] = i ** 5 <NEWLINE> five_inv [ i ] = - five [ i ] <NEWLINE> <NL> <DEDENT> def check ( x ) : <NEWLINE> <INDENT> A = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> if X + five [ i ] in five : <NEWLINE> <INDENT> B = i <NEWLINE> A = five . index ( five [ i ] + X ) <NEWLINE> break <NEWLINE> <DEDENT> elif X - five [ i ] in five : <NEWLINE> <INDENT> B = - i <NEWLINE> A = five . index ( - five [ i ] + X ) <NEWLINE> break <NEWLINE> <DEDENT> elif X - five [ i ] in five_inv : <NEWLINE> <INDENT> B = - i <NEWLINE> A = - five_inv . index ( - five [ i ] + X ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return <STRING> . format ( A , B ) <NEWLINE> <NL> <DEDENT> print ( check ( X ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> tmp = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> s += math . gcd ( tmp , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from random import randint <NEWLINE> <NL> <NL> class RollingHash : <NEWLINE> <INDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> self . base = [ 7073 , 7577 , 5445 , 2742 , 6972 , 7547 , 2267 , 286 , 6396 , 7147 , <NEWLINE> <INDENT> 3307 , 188 , 266 , 8253 , 2818 , 9527 , 5110 , 1207 , 4633 , 6196 , <NEWLINE> 309 , 2646 , 7533 , 85 , 9870 , 4730 , 6862 , 9213 , 7456 , 7098 , <NEWLINE> 6805 , 674 , 5821 , 4864 , 8061 , 1826 , 2219 , 459 , 5937 , 5667 , <NEWLINE> 9033 , 5552 , 7263 , 2402 , 9809 , 3701 , 7048 , 2874 , 8350 , 6006 , <NEWLINE> 973 , 3317 , 2522 , 5546 , 1669 , 1545 , 7972 , 4979 , 9905 , 173 , <NEWLINE> 6812 , 7715 , 5006 , 6068 , 6340 , 4989 , 5510 , 6380 , 1200 , 6739 , <NEWLINE> 5527 , 4000 , 6519 , 3448 , 2933 , 6048 , 3133 , 1667 , 9086 , 8368 , <NEWLINE> 4914 , 7142 , 2770 , 7752 , 391 , 7052 , 5476 , 3105 , 8322 , 3501 , <NEWLINE> 7454 , 3167 , 8730 , 9002 , 4564 , 138 , 2197 , 7238 , 3411 , 7433 ] [ randint ( 0 , 100 ) ] <NEWLINE> <DEDENT> self . mod = 4611686018427387903 <NEWLINE> self . size = len ( s ) <NEWLINE> self . string = s <NEWLINE> <NL> self . hash = self . make_hashtable ( s ) <NEWLINE> self . pow = self . make_powtable ( ) <NEWLINE> <NL> <DEDENT> def make_hashtable ( self , _s ) : <NEWLINE> <INDENT> hashtable = [ 0 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> hashtable [ i + 1 ] = ( hashtable [ i ] * self . base + ord ( _s [ i ] ) ) % self . mod <NEWLINE> <DEDENT> return hashtable <NEWLINE> <NL> <DEDENT> def make_powtable ( self ) : <NEWLINE> <INDENT> power = [ 1 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> power [ i + 1 ] = ( self . base * power [ i ] ) % self . mod <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def get_hash ( self , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . hash [ right ] - self . hash [ left ] * self . pow [ right - left ] ) % self . mod <NEWLINE> <NL> <DEDENT> def contain ( self , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m = len ( a ) <NEWLINE> if m > self . size : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> hashs = self . get_hash ( 0 , m ) <NEWLINE> hasha = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hasha = ( hasha * self . base + ord ( a [ i ] ) ) % self . mod <NEWLINE> <DEDENT> for i in range ( self . size - m + 1 ) : <NEWLINE> <INDENT> if hasha == hashs : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> hashs = self . get_hash ( i , m + i ) <NEWLINE> <DEDENT> return hasha == hashs <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from collections import defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> n , s = int ( input ( ) ) , input ( ) <NEWLINE> rh = RollingHash ( s ) <NEWLINE> <NL> <NL> def check ( m ) : <NEWLINE> <INDENT> d = defaultdict ( lambda : 10000000 ) <NEWLINE> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> h = rh . get_hash ( i , i + m ) <NEWLINE> d [ h ] = min ( d [ h ] , i ) <NEWLINE> <COMMENT> <NL> if i - d [ h ] >= m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> l , r = 0 , n // 2 + 1 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
<NL> K = int ( input ( ) ) <NEWLINE> a_i = 7 % K <NEWLINE> i = 1 <NEWLINE> if a_i == 0 : <NEWLINE> <INDENT> exit ( print ( 1 ) ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> a_i = ( 10 * a_i + 7 ) % K <NEWLINE> if a_i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i >= K : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = <STRING> . join ( input ( ) ) . split ( <STRING> ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> ri = - 1 <NEWLINE> <NL> if c . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if c . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> while c [ ri ] != <STRING> : <NEWLINE> <INDENT> ri -= 1 <NEWLINE> <NL> <DEDENT> if n < i - ri : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> c [ i ] , c [ ri ] = <STRING> , <STRING> <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = input ( ) . split ( ) <NEWLINE> A_int = [ int ( s ) for s in A ] <NEWLINE> <COMMENT> <NL> if 0 in A_int : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A_int [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> f = True <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> f = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for aa in a [ : : - 1 ] : <NEWLINE> <INDENT> ans *= aa <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = input ( ) . split ( ) <NEWLINE> a = 1 <NEWLINE> sikataganai = False <NEWLINE> try : <NEWLINE> <INDENT> h = li . index ( <STRING> ) <NEWLINE> print ( 0 ) <NEWLINE> sikataganai = True <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= int ( li [ i ] ) <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if not sikataganai : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> q = deque ( ) <NEWLINE> <NL> n = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> v = cmd [ 7 : ] <NEWLINE> q . appendleft ( v ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> v = cmd [ 7 : ] <NEWLINE> try : <NEWLINE> <INDENT> q . remove ( v ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
from sys import stdin <NEWLINE> N = list ( map ( int , ( stdin . readline ( ) . strip ( ) . split ( ) ) ) ) [ 0 ] <NEWLINE> S = list ( stdin . readline ( ) . strip ( ) ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def powmod ( x , y , mod ) : <NEWLINE> <INDENT> res = pow ( x , y ) % mod <NEWLINE> return res <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <COMMENT> <NL> ans = powmod ( 10 , N , mod ) - 2 * powmod ( 9 , N , mod ) + powmod ( 8 , N , mod ) <NEWLINE> ans = ans % mod <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = 0 <NEWLINE> c = 0 <NEWLINE> import sys <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if j == n - 1 : <NEWLINE> <NL> <INDENT> break <NEWLINE> <DEDENT> if i != a [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> c = 0 <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import copy <NEWLINE> <NL> class Puzzle ( list ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> list . __init__ ( self ) <NEWLINE> self . space = None <NEWLINE> self . path = <STRING> <NEWLINE> <NL> <DEDENT> def __hash__ ( self ) : <NEWLINE> <INDENT> return hash ( str ( self [ : ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> N = 3 <NEWLINE> N2 = 9 <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> d = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> p = Puzzle ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p += [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( N2 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> p [ i ] = N2 <NEWLINE> p . space = i <NEWLINE> <DEDENT> <DEDENT> target = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> def isTarget ( p ) : <NEWLINE> <INDENT> return p [ : ] == target [ : ] <NEWLINE> <NL> <DEDENT> def bfs ( s ) : <NEWLINE> <INDENT> Q = deque ( ) <NEWLINE> V = set ( ) <NEWLINE> Q . append ( s ) <NEWLINE> V . add ( s ) <NEWLINE> while Q : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> if isTarget ( u ) : <NEWLINE> <INDENT> return u . path <NEWLINE> <DEDENT> sx = u . space // N <NEWLINE> sy = u . space % N <NEWLINE> for r in range ( 4 ) : <NEWLINE> <INDENT> tx = sx + dx [ r ] <NEWLINE> ty = sy + dy [ r ] <NEWLINE> if not ( 0 <= tx < N and 0 <= ty < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = Puzzle ( ) <NEWLINE> v [ : ] = u [ : ] <NEWLINE> v . path = u . path <NEWLINE> change = tx * N + ty <NEWLINE> v [ u . space ] , v [ change ] = v [ change ] , v [ u . space ] <NEWLINE> v . space = change <NEWLINE> if not v in V : <NEWLINE> <INDENT> V . add ( v ) <NEWLINE> v . path += d [ r ] <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> ans = bfs ( p ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = [ 0 for _ in range ( 10001 ) ] <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v < 10001 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> ans = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += a [ B ] * ( C - B ) <NEWLINE> a [ C ] += a [ B ] <NEWLINE> a [ B ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> r = sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print ( r ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys ; from decimal import Decimal <NEWLINE> import math ; from itertools import combinations , product <NEWLINE> import bisect ; from collections import Counter , deque , defaultdict <NEWLINE> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def lcm ( a : int , b : int ) -> int : return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import i8 , njit <NEWLINE> <NL> <COMMENT> <NL> @ njit ( i8 ( i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def binary_search ( n , a ) : <NEWLINE> <INDENT> right = np . max ( a ) + 10 ** 9 <NEWLINE> left = np . min ( a ) - 10 ** 9 <NEWLINE> <NL> def calc ( b ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> score += abs ( a [ i ] - ( b + i + 1 ) ) <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> while right - left > 1 : <NEWLINE> <INDENT> middle = ( right + left ) // 2 <NEWLINE> if calc ( middle ) < calc ( middle + 1 ) : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = middle <NEWLINE> <NL> <DEDENT> <DEDENT> return calc ( right ) <NEWLINE> <NL> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> n = read_int ( ) <NEWLINE> a = np . array ( read_int_list ( ) , dtype = np . int64 ) <NEWLINE> <NL> print ( binary_search ( n , a ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> numbers = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( numbers [ : : - 1 ] ) ) <NEWLINE>
input ( ) ; Q = [ 0 ] * 101 <NEWLINE> for p in map ( int , input ( ) . split ( ) ) : Q [ p ] += 1 <NEWLINE> print ( max ( i for i in range ( 101 ) if sum ( Q [ i : ] ) >= i ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def num_divisor ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return table <NEWLINE> <DEDENT> print ( sum ( num_divisor ( n - 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> copy_a = sorted ( a , reverse = True ) <NEWLINE> <NL> A_Max = copy_a [ 0 ] <NEWLINE> A_Second = copy_a [ 1 ] <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> if a [ x ] == A_Max : <NEWLINE> <INDENT> print ( A_Second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A_Max ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> temp = int ( x ** 0.25 ) <NEWLINE> flag = True <NEWLINE> for i in range ( - temp , temp + 1 ) : <NEWLINE> <INDENT> for j in range ( - temp , temp + 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> ret = a <NEWLINE> a = b <NEWLINE> b = ret <NEWLINE> <NL> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> c = a % b <NEWLINE> if c == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( gcd ( a , b ) ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> k = 1 <NEWLINE> list . sort ( ) <NEWLINE> x = list [ 0 ] <NEWLINE> while k < n : <NEWLINE> <INDENT> y = x * list [ k ] <NEWLINE> x = y <NEWLINE> if y <= 1000000000000000000 : <NEWLINE> <INDENT> k = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = n + 1 <NEWLINE> y = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bad = dict ( ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if H [ A ] > H [ B ] : <NEWLINE> <INDENT> Bad [ B ] = 1 <NEWLINE> <DEDENT> elif H [ A ] < H [ B ] : <NEWLINE> <INDENT> Bad [ A ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bad [ A ] = 1 <NEWLINE> Bad [ B ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( Bad ) ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
import sys ; <NEWLINE> <NL> def init ( n_ ) : <NEWLINE> <INDENT> length = 1 ; <NEWLINE> while ( length < n_ ) : <NEWLINE> <INDENT> length *= 2 <NEWLINE> <DEDENT> element = [ 0 ] * ( 2 * length - 1 ) <NEWLINE> for i in range ( 2 * length - 1 ) : <NEWLINE> <INDENT> element [ i ] = 0 <NEWLINE> <DEDENT> return element , length <NEWLINE> <NL> <DEDENT> def update ( k , a , element ) : <NEWLINE> <INDENT> k += n - 1 <NEWLINE> element [ k ] += a <NEWLINE> while ( k > 0 ) : <NEWLINE> <INDENT> k = ( int ) ( ( k - 1 ) / 2 ) <NEWLINE> element [ k ] = element [ k * 2 + 1 ] + element [ k * 2 + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def findmin ( a , b ) : <NEWLINE> <INDENT> return findquery ( a , b + 1 , 0 , 0 , n ) <NEWLINE> <NL> <DEDENT> def findquery ( a , b , k , l , r ) : <NEWLINE> <INDENT> if ( r <= a or b <= l ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ( a <= l and r <= b ) : <NEWLINE> <INDENT> return element [ k ] <NEWLINE> <NL> <DEDENT> vl = findquery ( a , b , k * 2 + 1 , l , ( int ) ( ( l + r ) / 2 + 0.5 ) ) <NEWLINE> vr = findquery ( a , b , k * 2 + 2 , ( int ) ( ( l + r ) / 2 ) , r ) <NEWLINE> return vl + vr <NEWLINE> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> element , n = init ( n ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> query , key , value = map ( int , input ( ) . split ( ) ) ; <NEWLINE> if ( query == 0 ) : <NEWLINE> <INDENT> update ( key - 1 , value , element ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( findmin ( key - 1 , value - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<NL> s = input ( ) <NEWLINE> i , ans , total = 0 , 0 , 0 <NEWLINE> <NL> while i < len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += total <NEWLINE> i += 2 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> total += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> c = factorization ( n ) <NEWLINE> for arr in c : <NEWLINE> <INDENT> m = arr [ 1 ] <NEWLINE> i = 1 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> if i > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> m -= i <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import cos , radians , sqrt <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> rad = 0 if H == 0 and M == 0 else radians ( abs ( 360 / ( 720 / ( 60 * H + M ) ) - 6 * M ) ) <NEWLINE> ans = sqrt ( ( A ** 2 ) + ( B ** 2 ) - 2 * A * B * cos ( rad ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 3000 ) <NEWLINE> def dfs ( r , c , n ) : <NEWLINE> <INDENT> board [ r ] [ c ] = n <NEWLINE> drc = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> for dr , dc in drc : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if 0 <= nr < h and 0 <= nc < w and board [ nr ] [ nc ] != n : <NEWLINE> <INDENT> if board [ nr ] [ nc ] in <STRING> : <NEWLINE> <INDENT> pile . append ( board [ nr ] [ nc ] ) <NEWLINE> continue <NEWLINE> <DEDENT> dfs ( nr , nc , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : break <NEWLINE> board = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> place = 0 <NEWLINE> piles = [ ] <NEWLINE> black , white = [ ] , [ ] <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> for c in range ( w ) : <NEWLINE> <INDENT> if board [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> pile = [ ] <NEWLINE> place += 1 <NEWLINE> dfs ( r , c , place ) <NEWLINE> piles . append ( pile ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i , pile in enumerate ( piles ) : <NEWLINE> <INDENT> if not pile : continue <NEWLINE> for p in pile : <NEWLINE> <INDENT> if p != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> black . append ( i + 1 ) <NEWLINE> <DEDENT> for p in pile : <NEWLINE> <INDENT> if p != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> white . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> ans_b , ans_w = 0 , 0 <NEWLINE> for row in board : <NEWLINE> <INDENT> for c in row : <NEWLINE> <INDENT> if c in black : <NEWLINE> <INDENT> ans_b += 1 <NEWLINE> <DEDENT> elif c in white : <NEWLINE> <INDENT> ans_w += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans_b , ans_w ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ans = main ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> k = 10 ** 18 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if total != 0 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> total *= a [ i ] <NEWLINE> if total > k : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ ] ) ; MOD = pow ( 10 , 9 ) + 7 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . add ( a - 1 ) <NEWLINE> <DEDENT> dp = [ [ 0 ] * 2 for _ in range ( N ) ] <COMMENT> <NEWLINE> if 0 not in A : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( sum ( dp [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 1 not in A : <NEWLINE> <INDENT> dp [ 1 ] [ 0 ] = dp [ 0 ] [ 0 ] + dp [ 0 ] [ 1 ] <NEWLINE> dp [ 1 ] [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD <NEWLINE> dp [ i ] [ 1 ] = ( dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] ) % MOD <NEWLINE> <DEDENT> ans = sum ( dp [ N - 1 ] ) % MOD <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if w == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if h == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if w % 2 == 0 : <NEWLINE> <INDENT> ans = w // 2 * h <NEWLINE> <DEDENT> elif w % 2 == 1 : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> ans = h * w // 2 <NEWLINE> <DEDENT> elif h % 2 == 1 : <NEWLINE> <INDENT> ans = h * w // 2 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 0 ] * ( N + 1 ) <NEWLINE> seq = [ ] <NEWLINE> <NL> step = 0 <NEWLINE> current = 1 <NEWLINE> <NL> n1 = n2 = 0 <NEWLINE> while ( step < len ( A ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> seq . append ( current ) <NEWLINE> step += 1 <NEWLINE> visited [ current ] = step <NEWLINE> next_pos = A [ current - 1 ] <NEWLINE> if visited [ next_pos ] > 0 : <NEWLINE> <INDENT> n1 = visited [ next_pos ] <NEWLINE> n2 = step - n1 + 1 <NEWLINE> seq . append ( next_pos ) <NEWLINE> break <NEWLINE> <DEDENT> current = next_pos <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if n1 + n2 <= K : <NEWLINE> <INDENT> print ( seq [ n1 - 1 + ( ( K - ( n1 - 1 ) ) % n2 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( seq [ K ] ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
cnt = 0 <NEWLINE> <NL> def merge ( array , left , middle , right ) : <NEWLINE> <INDENT> n1 = middle - left <NEWLINE> n2 = right - middle <NEWLINE> L = array [ left : left + n1 ] + [ float ( <STRING> ) ] <NEWLINE> R = array [ middle : middle + n2 ] + [ float ( <STRING> ) ] <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> array [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( array , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> middle = int ( ( left + right ) / 2. ) <NEWLINE> mergeSort ( array , left , middle ) <NEWLINE> mergeSort ( array , middle , right ) <NEWLINE> merge ( array , left , middle , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mergeSort ( array , 0 , len ( array ) ) <NEWLINE> print ( * array ) <NEWLINE> print ( cnt ) <NEWLINE>
m , f , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if m + f < b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif m > b : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif m < b : <NEWLINE> <INDENT> ans = b - m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <DEDENT> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a + b + c == 2 : <NEWLINE> <INDENT> if a == b == 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a >= b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if c == b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a + b + c == 2 : <NEWLINE> <INDENT> if b == c == 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b >= c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a == c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a + b + c == 2 : <NEWLINE> <INDENT> if a == c == 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> a += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a >= c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> l [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if l [ - 2 ] != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> d . setdefault ( a , 0 ) <NEWLINE> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> A = sorted ( set ( A ) ) <NEWLINE> t = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if d [ a ] > 1 : <NEWLINE> <INDENT> t [ a ] = False <NEWLINE> <DEDENT> for i in range ( a + a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> t [ i ] = False <NEWLINE> <DEDENT> <DEDENT> print ( sum ( 1 for a in A if t [ a ] ) ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if abs ( a - b ) <= ( v - w ) * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> x = Counter ( a ) <NEWLINE> ans = sum ( a ) <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> ans += ( c - b ) * x [ b ] <NEWLINE> print ( ans ) <NEWLINE> x [ c ] += x [ b ] <NEWLINE> x [ b ] = 0 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , X , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if not D : <NEWLINE> <INDENT> if not X : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num_dict = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> left_num = int ( i * X / D ) + int ( i * ( i - 1 ) / 2 ) <NEWLINE> right_num = int ( i * X / D ) + int ( i * ( 2 * N - 1 - i ) / 2 ) <NEWLINE> judge_num = i * X % D <NEWLINE> if not judge_num in num_dict : <NEWLINE> <INDENT> num_dict [ judge_num ] = [ ( left_num , right_num ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dict [ judge_num ] . append ( ( left_num , right_num ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j , k in num_dict . items ( ) : <NEWLINE> <INDENT> new_k = sorted ( k ) <NEWLINE> L = new_k [ 0 ] [ 0 ] <NEWLINE> R = new_k [ 0 ] [ 1 ] <NEWLINE> for l in new_k : <NEWLINE> <INDENT> if l [ 0 ] <= R <= l [ 1 ] : <NEWLINE> <INDENT> R = l [ 1 ] <NEWLINE> <DEDENT> elif R < l [ 0 ] and R < l [ 1 ] : <NEWLINE> <INDENT> ans += R - L + 1 <NEWLINE> L , R = l [ 0 ] , l [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans += R - L + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> graph [ a - 1 ] . append ( b ) <NEWLINE> graph [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> queue = deque ( ) <NEWLINE> visited = [ 0 ] * N <NEWLINE> sign_list = [ 0 ] * N <NEWLINE> <NL> queue . append ( 1 ) <NEWLINE> visited [ 0 ] = 1 <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> room = queue . popleft ( ) <NEWLINE> next_rooms = graph [ room - 1 ] <NEWLINE> for r in next_rooms : <NEWLINE> <INDENT> if visited [ r - 1 ] == 0 : <NEWLINE> <INDENT> queue . append ( r ) <NEWLINE> sign_list [ r - 1 ] = room <NEWLINE> visited [ r - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> yes = True <NEWLINE> for s in sign_list [ 1 : ] : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> yes = False <NEWLINE> <NL> <DEDENT> <DEDENT> if yes : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for s in sign_list [ 1 : ] : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i . reverse ( ) <NEWLINE> for j in range ( len ( i ) ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( i [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B - 1 > N : <NEWLINE> <INDENT> answer = ( A * N / B ) // 1 - A * ( ( N / B ) // 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> answer = ( A * ( B - 1 ) / B ) // 1 - A * ( ( ( B - 1 ) / B ) // 1 ) <NEWLINE> <NL> <DEDENT> print ( int ( answer ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
N = list ( str ( input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> if len ( N ) == 1 : <NEWLINE> <INDENT> print ( int ( N [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] != <STRING> : <NEWLINE> <INDENT> ans += int ( N [ 0 ] ) - 1 <NEWLINE> ans += ( len ( N ) - 1 ) * 9 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans += int ( N [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nums = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : nums [ i ] += 1 <NEWLINE> <DEDENT> if i != n - 1 : nums [ i + 1 ] = nums [ i ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( nums [ r ] - nums [ l ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> ans = a * b * c <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from math import sqrt <NEWLINE> from collections import Counter <NEWLINE> <NL> def gen_primes ( X ) : <NEWLINE> <INDENT> D = [ 0 ] * ( X + 1 ) <NEWLINE> is_prime = [ True for _ in range ( 0 , X + 1 ) ] <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> primes = [ ] <NEWLINE> for n in range ( 2 , int ( sqrt ( X ) ) + 1 ) : <NEWLINE> <INDENT> if is_prime [ n ] : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> j = n * 2 <NEWLINE> D [ n ] = n <NEWLINE> while j <= X : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> if D [ j ] == 0 : <NEWLINE> <INDENT> D [ j ] = n <NEWLINE> <DEDENT> j += n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for n in range ( int ( sqrt ( X ) ) , X + 1 ) : <NEWLINE> <INDENT> if is_prime [ n ] : <NEWLINE> <INDENT> D [ n ] = n <NEWLINE> primes . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return primes , D <NEWLINE> <NL> <NL> <DEDENT> def solve ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> primes , D = gen_primes ( 10 ** 6 ) <NEWLINE> C = [ 0 ] * ( primes [ - 1 ] + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> a_ = a <NEWLINE> while a > 1 : <NEWLINE> <INDENT> d = D [ a ] <NEWLINE> while a % d == 0 : <NEWLINE> <INDENT> a //= d <NEWLINE> <DEDENT> C [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> M = max ( C ) <NEWLINE> if M <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> solve ( A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hasu = N - ( N // 1000 ) * 1000 <NEWLINE> print ( 1000 - hasu ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = <STRING> <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> s += line . lower ( ) <NEWLINE> <DEDENT> alphabet = list ( <STRING> ) <NEWLINE> for i in alphabet : <NEWLINE> <INDENT> print ( <STRING> . format ( i , s . count ( i ) ) ) <NEWLINE> <DEDENT>
from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = 10000 ) <NEWLINE> def canProd ( i , m ) : <NEWLINE> <NL> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> res = canProd ( i + 1 , m ) or canProd ( i + 1 , m - a [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in m : <NEWLINE> <INDENT> if canProd ( 0 , i ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> <NL> cnt = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for c in cnt : <NEWLINE> <INDENT> if k - ( q - c ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from copy import copy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> count = 0 <NEWLINE> a = [ ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a . append ( [ int ( i ) for i in input ( ) . split ( <STRING> ) ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> dim = int ( count / 2 ) + 1 <NEWLINE> b = [ [ 0 for i in range ( dim + 1 ) ] for j in range ( dim + 1 ) ] <NEWLINE> for i in range ( dim ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> b [ i - j ] [ j ] = a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( dim - 1 ) : <NEWLINE> <INDENT> for j in range ( dim - i - 1 ) : <NEWLINE> <INDENT> b [ dim - 1 - j ] [ i + 1 + j ] = a [ i + dim ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> dp_ = [ [ True if i < dim else 0 for i in range ( dim + 1 ) ] if j < dim else [ 0 for i in range ( dim + 1 ) ] for j in range ( dim + 1 ) ] <NEWLINE> <NL> def dp ( i , j ) : <NEWLINE> <INDENT> global dp_ <NEWLINE> if dp_ [ i ] [ j ] is True : <NEWLINE> <INDENT> dp_ [ i ] [ j ] = b [ i ] [ j ] + max ( dp ( i + 1 , j ) , dp ( i , j + 1 ) ) <NEWLINE> return dp_ [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dp_ [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp ( 0 , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> import hashlib <NEWLINE> base1 = 1007 <NEWLINE> mod1 = 10 ** 9 + 7 <NEWLINE> dic = { } <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> hs = hashlib . md5 ( s . encode ( ) ) . hexdigest ( ) <NEWLINE> dic . setdefault ( hs , s ) <NEWLINE> <NL> <DEDENT> print ( len ( dic ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> t = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> <NL> for i in range ( len ( e [ node ] ) ) : <NEWLINE> <INDENT> nex = e [ node ] [ i ] <NEWLINE> if t [ nex ] == - 1 : <NEWLINE> <INDENT> q . append ( nex ) <NEWLINE> t [ nex ] = node <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> INF = 1 << 30 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> dp = [ INF for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> idx = bisect . bisect_left ( dp , a [ i - 1 ] ) <NEWLINE> dp [ idx ] = a [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = bisect . bisect_left ( dp , INF ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> step = [ 0 ] <NEWLINE> for k , i in enumerate ( A [ 1 : ] ) : <NEWLINE> <INDENT> if A [ k ] >= i : <NEWLINE> <INDENT> step . append ( A [ k ] - i ) <NEWLINE> A [ k + 1 ] = A [ k + 1 ] + A [ k ] - i <NEWLINE> <DEDENT> <DEDENT> print ( sum ( step ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> room_dict = { i + 1 : [ ] for i in range ( N ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> _a , _b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> room_dict [ _a ] . append ( _b ) <NEWLINE> room_dict [ _b ] . append ( _a ) <NEWLINE> <NL> <DEDENT> rooms = set ( room_dict . keys ( ) ) <NEWLINE> s_dict = { i + 1 : None for i in range ( 1 , N ) } <NEWLINE> traversed_rooms = set ( [ 1 ] ) <NEWLINE> <NL> now_rooms = [ 1 ] <NEWLINE> from operator import add <NEWLINE> while now_rooms : <NEWLINE> <INDENT> next_rooms = set ( ) <NEWLINE> for _room in now_rooms : <NEWLINE> <INDENT> traversed_rooms . add ( _room ) <COMMENT> <NEWLINE> _n_rooms = [ i for i in room_dict [ _room ] <NEWLINE> <INDENT> if ( not i in traversed_rooms ) and ( s_dict [ i ] is None ) ] <NEWLINE> <DEDENT> for n_room in _n_rooms : <NEWLINE> <INDENT> next_rooms . add ( n_room ) <COMMENT> <NEWLINE> s_dict [ n_room ] = _room <COMMENT> <NEWLINE> <DEDENT> <DEDENT> now_rooms = [ i for i in next_rooms if not i in traversed_rooms ] <COMMENT> <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( s_dict [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> a . sort ( reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e6 ) ) <NEWLINE> <NL> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . data = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def get_sum ( self , i ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> ret += self . data [ i ] <NEWLINE> i -= ( i & - i ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def add ( self , i , w ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> while i <= self . n : <NEWLINE> <INDENT> self . data [ i ] += w <NEWLINE> i += ( i & - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs ( u , cnt ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l [ u ] = cnt <NEWLINE> for c in tree [ u ] : <NEWLINE> <INDENT> cnt = dfs ( c , cnt ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> r [ u ] = cnt <NEWLINE> return cnt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l , r = [ 0 ] * n , [ 0 ] * n <NEWLINE> tree = [ set ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) for _ in range ( n ) ] <NEWLINE> <NL> bit = BIT ( dfs ( 0 , 1 ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if line [ 0 ] : <NEWLINE> <INDENT> print ( bit . get_sum ( r [ line [ 1 ] ] - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bit . add ( l [ line [ 1 ] ] , line [ 2 ] ) <NEWLINE> bit . add ( r [ line [ 1 ] ] , - line [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = ( a * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> x = 1 <NEWLINE> P = 10 ** 18 <NEWLINE> if 0 in A : x = 0 <NEWLINE> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> x *= a <NEWLINE> if x > P : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans -= s [ k ] != s [ i ] != s [ j ] != s [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if i == j and j == l : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> elif i == j or j == l : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> b = math . gcd ( j , l ) <NEWLINE> g = math . gcd ( a , b ) <NEWLINE> sum += g * 3 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> b = math . gcd ( j , l ) <NEWLINE> g = math . gcd ( a , b ) <NEWLINE> sum += g * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> bc = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * bc ) ] <NEWLINE> a . sort <NEWLINE> count = [ 0 for _ in range ( 1000000 ) ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ a [ i ] ] = count [ a [ i ] ] + 1 <NEWLINE> sum = sum + a [ i ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> sum = sum + ( c [ i ] - b [ i ] ) * count [ b [ i ] ] <NEWLINE> print ( sum ) <NEWLINE> count [ c [ i ] ] = count [ c [ i ] ] + count [ b [ i ] ] <NEWLINE> count [ b [ i ] ] = 0 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> maxi = A [ - 1 ] <NEWLINE> real = set ( ) <NEWLINE> forbid = set ( ) <NEWLINE> <COMMENT> <NL> d = dict ( Counter ( A ) ) <NEWLINE> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] not in forbid : <NEWLINE> <INDENT> if d [ A [ i ] ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> p = maxi // A [ i ] <NEWLINE> for j in range ( 1 , p + 1 ) : <NEWLINE> <INDENT> forbid . add ( j * A [ i ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> n = str ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> count = 1 <NEWLINE> for i in reversed ( n ) : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> ans = ans % 9 <NEWLINE> count *= 10 <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> d = { i : 2 for i in range ( 1 , n , 2 ) } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = { i : 2 for i in range ( 0 , n , 2 ) } <NEWLINE> d [ 0 ] = 1 <NEWLINE> <DEDENT> for a in l : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> d [ a ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in d . values ( ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ( 2 ** ( n // 2 ) ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> a = c . count ( <STRING> ) <NEWLINE> b = c [ : a ] . count ( <STRING> ) <NEWLINE> print ( b ) <NEWLINE>
from math import inf <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = list ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ca . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> money = inf <NEWLINE> tmp = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += 2 ** i <NEWLINE> <DEDENT> for i in range ( tmp ) : <NEWLINE> <INDENT> B = str ( format ( i , str ( n ) . zfill ( n ) + <STRING> ) ) <NEWLINE> j = 0 <NEWLINE> cnt = 0 <NEWLINE> a = [ 0 ] * m <NEWLINE> for ch in B : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> cnt += ca [ j ] [ 0 ] <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> a [ k - 1 ] += ca [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> <DEDENT> for ch in a : <NEWLINE> <INDENT> if ch < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> money = min ( cnt , money ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 if money == inf else money ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ways = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ans = [ None ] * ( n + 1 ) <NEWLINE> <NL> hush = { } <NEWLINE> hush [ 1 ] = True <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> hush [ i ] = False <NEWLINE> <DEDENT> table = [ list ( ) for _ in range ( n + 1 ) ] <NEWLINE> for a , b in ways : <NEWLINE> <INDENT> table [ a ] . append ( b ) <NEWLINE> table [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = deque ( [ 1 ] ) <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> room = que . popleft ( ) <NEWLINE> for next in table [ room ] : <NEWLINE> <INDENT> if hush [ next ] == False : <NEWLINE> <INDENT> ans [ next ] = room <NEWLINE> que . append ( next ) <NEWLINE> hush [ next ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> B [ j ] += B [ j - 1 ] <NEWLINE> <NL> <NL> <DEDENT> b_cnt = m <NEWLINE> for a_cnt in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ a_cnt ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while A [ a_cnt ] + B [ b_cnt ] > k : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , a_cnt + b_cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> a1 = b <NEWLINE> b1 = a % b <NEWLINE> return gcd ( a1 , b1 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = [ ] <NEWLINE> for loop in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> a = y1 - y2 <NEWLINE> b = x2 - x1 <NEWLINE> c = - x1 * a - y1 * b <NEWLINE> line . append ( ( a , b , c ) ) <NEWLINE> <DEDENT> ans = n + 1 <NEWLINE> m = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> l1 = line [ i ] <NEWLINE> l2 = line [ j ] <NEWLINE> det = l1 [ 0 ] * l2 [ 1 ] - l1 [ 1 ] * l2 [ 0 ] <NEWLINE> deta = int ( abs ( det ) ) <NEWLINE> if det == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = l2 [ 1 ] * l1 [ 2 ] - l1 [ 1 ] * l2 [ 2 ] <NEWLINE> y = - l2 [ 0 ] * l1 [ 2 ] + l1 [ 0 ] * l2 [ 2 ] <NEWLINE> if x > - 100 * deta and x < 100 * deta and y > - 100 * deta and y < 100 * deta : <NEWLINE> <INDENT> ans += 1 <NEWLINE> G = gcd ( gcd ( int ( abs ( x ) ) , int ( abs ( y ) ) ) , int ( abs ( det ) ) ) <NEWLINE> x //= G <NEWLINE> y //= G <NEWLINE> det //= G <NEWLINE> if det < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> y *= - 1 <NEWLINE> det *= - 1 <NEWLINE> <DEDENT> if ( x , y , det ) in m : <NEWLINE> <INDENT> m [ ( x , y , det ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ ( x , y , det ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in m : <NEWLINE> <INDENT> S = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> S += cnt <NEWLINE> if m [ p ] == S : <NEWLINE> <INDENT> ans -= cnt * ( cnt - 1 ) // 2 <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n = k ( ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <= n : <NEWLINE> <INDENT> a [ i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = [ ] <NEWLINE> for i in range ( - 101 , 102 ) : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in p : <NEWLINE> <INDENT> tmp . remove ( i ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in tmp : <NEWLINE> <INDENT> a = abs ( x - i ) <NEWLINE> ans . append ( a ) <NEWLINE> <NL> <DEDENT> b = min ( ans ) <NEWLINE> <NL> c = x + b <NEWLINE> d = x - b <NEWLINE> <NL> if c and d in tmp : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> elif c in tmp : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> elif d in tmp : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> base_xor = 0 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> base_xor = base_xor ^ i <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = a_list [ i ] ^ base_xor <NEWLINE> <DEDENT> ans = <STRING> . join ( [ str ( i ) for i in ans ] ) <NEWLINE> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mm = 10 ** 5 + 5 <NEWLINE> c = [ [ 0 ] for i in range ( mm ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ a ] . append ( b ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> h = [ ] <NEWLINE> for i in reversed ( range ( m ) ) : <NEWLINE> <INDENT> d = m - i <NEWLINE> for j in c [ d ] : <NEWLINE> <INDENT> heapq . heappush ( h , - j ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans += - heapq . heappop ( h ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = [ ] <NEWLINE> h = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> s . append ( <STRING> + str ( i ) ) <NEWLINE> h . append ( <STRING> + str ( i ) ) <NEWLINE> c . append ( <STRING> + str ( i ) ) <NEWLINE> d . append ( <STRING> + str ( i ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> a = str ( input ( ) ) <NEWLINE> if ( a in s ) : <NEWLINE> <INDENT> s . remove ( a ) <NEWLINE> <DEDENT> elif ( a in h ) : <NEWLINE> <INDENT> h . remove ( a ) <NEWLINE> <DEDENT> elif ( a in c ) : <NEWLINE> <INDENT> c . remove ( a ) <NEWLINE> <DEDENT> elif ( a in d ) : <NEWLINE> <INDENT> d . remove ( a ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if ( len ( s ) > 0 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> if ( len ( h ) > 0 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( h ) ) <NEWLINE> <DEDENT> if ( len ( c ) > 0 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( c ) ) <NEWLINE> <DEDENT> if ( len ( d ) > 0 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( d ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> S2 = sum ( map ( lambda x : x ** 2 , A ) ) <NEWLINE> <NL> print ( ( S ** 2 - S2 ) // 2 % ( 1000000000 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : a [ i ] += a [ i - 1 ] <NEWLINE> ans , m = 0 , int ( 1e9 + 7 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ( ans + ( a [ i ] - a [ i - 1 ] ) * ( a [ n ] - a [ i ] ) ) % m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( W + 1 ) <NEWLINE> def knapsack ( n , w ) : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for wk in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> tv = dp [ wk - w ] + v <NEWLINE> if tv > dp [ wk ] : <NEWLINE> <INDENT> dp [ wk ] = tv <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <DEDENT> print ( knapsack ( N , W ) ) <NEWLINE>
t = input ( ) <NEWLINE> s = [ i for i in t ] <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , len ( t ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ - 1 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> A += map ( int , input ( ) . split ( ) ) <NEWLINE> B += map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while j > 0 and A [ i ] + B [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from scipy . special import comb <NEWLINE> from collections import Counter as C <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> l [ i + 1 ] = tmp + a [ i ] <NEWLINE> tmp = l [ i + 1 ] <NEWLINE> <NL> <DEDENT> c = C ( l ) <NEWLINE> ans = 0 <NEWLINE> <NL> for v in c . values ( ) : <NEWLINE> <INDENT> ans += comb ( v , 2 , exact = True ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * num <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> count [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( count ) ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x0 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x1 = [ i for i in x0 if i >= 0 ] <NEWLINE> x2 = list ( reversed ( [ i for i in x0 if i < 0 ] ) ) <NEWLINE> count0 = len ( x1 ) <NEWLINE> count1 = len ( x2 ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> if count1 == 0 : <NEWLINE> <INDENT> print ( x1 [ k - 1 ] ) <NEWLINE> <DEDENT> elif count0 == 0 : <NEWLINE> <INDENT> print ( - x2 [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 in x1 : <NEWLINE> <INDENT> x1 . remove ( 0 ) <NEWLINE> k -= 1 <NEWLINE> count0 -= 1 <NEWLINE> <DEDENT> for i in range ( min ( count0 , k ) ) : <NEWLINE> <INDENT> if count1 >= k - i - 1 : <NEWLINE> <INDENT> ans = min ( ans , x1 [ i ] * 2 - x2 [ k - i - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( min ( count1 , k ) ) : <NEWLINE> <INDENT> if count0 >= k - i - 1 : <NEWLINE> <INDENT> ans = min ( ans , - x2 [ i ] * 2 + x1 [ k - i - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import Counter <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> I = [ ] <NEWLINE> zz = 0 <NEWLINE> sz = 0 <NEWLINE> tz = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> zz += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if a == 0 : <NEWLINE> <INDENT> sz += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if b == 0 : <NEWLINE> <INDENT> tz += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> gcd = math . gcd ( a , b ) <NEWLINE> if b < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> I . append ( ( a // gcd , b // gcd ) ) <NEWLINE> <NL> <DEDENT> S = [ ] <NEWLINE> T = [ ] <NEWLINE> C = Counter ( I ) <NEWLINE> for a , b in C . keys ( ) : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> S . append ( C [ ( a , b ) ] ) <NEWLINE> T . append ( C [ ( - b , a ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if C [ ( b , - a ) ] == 0 : <NEWLINE> <INDENT> S . append ( 0 ) <NEWLINE> T . append ( C [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> ans *= 2 ** sz + 2 ** tz - 1 <NEWLINE> ans %= MOD <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> ans *= 2 ** S [ i ] + 2 ** T [ i ] - 1 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans += zz <COMMENT> <NEWLINE> ans -= 1 <NEWLINE> print ( ans % MOD ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , Q = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> Query = [ [ int ( v ) - 1 for v in input ( ) . split ( ) ] for _ in range ( Q ) ] <NEWLINE> <NL> rows = [ N - 1 ] * ( N - 1 ) <NEWLINE> cols = [ N - 1 ] * ( N - 1 ) <NEWLINE> <NL> black = ( N - 2 ) * ( N - 2 ) <NEWLINE> min_row = N - 1 <NEWLINE> min_col = N - 1 <NEWLINE> <NL> for ty , x in Query : <NEWLINE> <INDENT> if ty == 0 : <NEWLINE> <INDENT> if x < min_col : <NEWLINE> <INDENT> for j in range ( x , min_col ) : <NEWLINE> <INDENT> rows [ j ] = min_row <NEWLINE> <DEDENT> min_col = x <NEWLINE> <DEDENT> black -= rows [ x ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x < min_row : <NEWLINE> <INDENT> for j in range ( x , min_row ) : <NEWLINE> <INDENT> cols [ j ] = min_col <NEWLINE> <DEDENT> min_row = x <NEWLINE> <DEDENT> black -= cols [ x ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( black ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( H , N , AB ) : <NEWLINE> <INDENT> INF = 10 ** 18 <NEWLINE> dp = [ INF ] * ( H + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = AB [ i ] <NEWLINE> for d in range ( H + 1 ) : <NEWLINE> <INDENT> if d < A : <NEWLINE> <INDENT> dp [ d ] = min ( dp [ d ] , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ d ] = min ( dp [ d ] , dp [ d - A ] + B ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = np . zeros ( shape = ( N , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> AB [ i ] = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> ans = solve ( H , N , AB ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> try : a += input ( ) . lower ( ) <NEWLINE> except : break <NEWLINE> <DEDENT> [ print ( chr ( 97 + i ) , <STRING> , a . count ( chr ( 97 + i ) ) ) for i in range ( 26 ) ] <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List . sort ( ) <NEWLINE> cand = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cand . append ( ( b , c ) ) <NEWLINE> <DEDENT> bc = sorted ( cand , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> i = 0 <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> if i < n and List [ i ] < c : <NEWLINE> <INDENT> List [ i ] = c <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( List ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( X ) <NEWLINE> k = K <NEWLINE> <NL> xd = min ( x // D + 1 , K ) <NEWLINE> x -= D * xd <NEWLINE> k -= xd <NEWLINE> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> x += D <NEWLINE> <NL> <DEDENT> print ( abs ( x ) ) <NEWLINE>
def post_pd ( t ) : <NEWLINE> <INDENT> string_list = <STRING> <NEWLINE> for i in t : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> string_list = string_list + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> string_list = string_list + i <NEWLINE> <NL> <DEDENT> <DEDENT> return string_list <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> print ( post_pd ( t ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> T = Counter ( L ) . values ( ) <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in T ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = n - 1 <NEWLINE> x = int ( math . ceil ( math . sqrt ( n ) ) ) <NEWLINE> <NL> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans = int ( min ( ans , i + n / i - 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> print ( ( ( ( a * x ) // b ) ) ) <NEWLINE>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> len_arr = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> counter = Counter ( arr ) <NEWLINE> x_max = max ( counter . keys ( ) ) <NEWLINE> <NL> dp = np . empty ( x_max + 1 , dtype = np . bool_ ) <NEWLINE> dp [ : ] = True <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x , count in sorted ( counter . items ( ) ) : <NEWLINE> <INDENT> multi = [ x * y for y in range ( 1 , x_max // x + 1 ) ] <NEWLINE> if count == 1 and dp [ x ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> dp [ multi ] = False <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a1 , b1 , c1 , d1 = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] = a1 <NEWLINE> b [ i ] = b1 <NEWLINE> c [ i ] = c1 <NEWLINE> d [ i ] = d1 <NEWLINE> <NL> <DEDENT> x = itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) <NEWLINE> tmp = 0 <NEWLINE> ans = 0 <NEWLINE> for xi in x : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> if xi [ b [ i ] - 1 ] - xi [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> t = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> t *= i <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = [ x for x in a if x % 2 != 0 ] <NEWLINE> <NL> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = n // i <NEWLINE> ans += ( x * ( x + 1 ) // 2 ) * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> low = 0 <NEWLINE> high = 100001 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , m = map ( int , input ( ) . split ( ) ) <NEWLINE> low = max ( low , l ) <NEWLINE> high = min ( high , m ) <NEWLINE> <DEDENT> if high - low + 1 < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( high - low + 1 , n ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 1 ] * N <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> B [ A [ x ] - 1 ] += x <NEWLINE> <DEDENT> for y in B : <NEWLINE> <INDENT> print ( y , end = <STRING> ) <NEWLINE> if y != B [ N - 1 ] : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mp = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = i - A [ i ] <NEWLINE> ans += mp . get ( x , 0 ) <NEWLINE> y = A [ i ] + i <NEWLINE> mp [ y ] = mp . get ( y , 0 ) + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> s = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> ans = ( ans + ( i * s ) ) <NEWLINE> <DEDENT> ans = ans % mod <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if al [ i ] == 2 : <NEWLINE> <INDENT> print ( cnt + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num [ al [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ al [ i ] - 1 ] += 1 <NEWLINE> i = al [ i ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kai = [ 0 ] <NEWLINE> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> kai . append ( kai [ i - 1 ] + i ) <NEWLINE> <DEDENT> ka = [ 0 ] + [ kai [ i ] / i for i in range ( 1 , len ( kai ) ) ] <NEWLINE> lis = [ ka [ i ] for i in li ] <NEWLINE> <NL> ans = sum ( lis [ : k ] ) <NEWLINE> mx = ans <NEWLINE> for i in range ( len ( li ) - k ) : <NEWLINE> <INDENT> ans -= lis [ i ] <NEWLINE> ans += lis [ i + k ] <NEWLINE> mx = max ( ans , mx ) <NEWLINE> <DEDENT> print ( mx ) <NEWLINE>
import sys <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> square = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> a = list ( map ( str , input ( ) ) ) <NEWLINE> square += a <NEWLINE> <NL> <DEDENT> if H == W == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( H * W ) : <NEWLINE> <INDENT> if square [ i ] == <STRING> : <NEWLINE> <INDENT> if i % W != W - 1 : <NEWLINE> <INDENT> if square [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i % W != 0 : <NEWLINE> <INDENT> if square [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if i - W >= 0 : <NEWLINE> <INDENT> if square [ i - W ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i + W <= H * W : <NEWLINE> <INDENT> if square [ i + W ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> l = [ 0 ] * A [ - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if l [ A [ i ] - 1 ] > 1 : <NEWLINE> <INDENT> l [ A [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> elif l [ A [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> temp = A [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> temp += A [ i ] <NEWLINE> if temp > A [ - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l [ temp - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> F = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> B = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> F [ x ] . append ( y ) <NEWLINE> F [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> B [ x ] . append ( y ) <NEWLINE> B [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> belongs = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> group_ID = 0 <NEWLINE> <NL> def f_search ( root , group_ID ) : <NEWLINE> <INDENT> for j in F [ root ] : <NEWLINE> <INDENT> if belongs [ j ] == - 1 : <NEWLINE> <INDENT> belongs [ j ] = group_ID <NEWLINE> f_search ( j , group_ID ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if belongs [ i ] == - 1 : <NEWLINE> <INDENT> belongs [ i ] = group_ID <NEWLINE> f_search ( i , group_ID ) <NEWLINE> group_ID += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt_members = [ 0 for _ in range ( len ( set ( belongs ) ) ) ] <NEWLINE> for i in belongs [ 1 : ] : <NEWLINE> <INDENT> cnt_members [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in B [ i ] : <NEWLINE> <INDENT> if belongs [ j ] == belongs [ i ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = cnt_members [ belongs [ i ] ] - 1 - len ( F [ i ] ) - tmp <NEWLINE> <NL> <DEDENT> print ( * ans [ 1 : ] ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> amount = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> amount += math . gcd ( gcd_ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( amount ) <NEWLINE>
from bisect import bisect <NEWLINE> n , a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> W = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> X = [ int ( x ) for x , c in W ] <NEWLINE> C = [ c for x , c in W ] <NEWLINE> <NL> P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( b ) ] <NEWLINE> Y = [ y for y , h in P ] + [ n + 1 ] <NEWLINE> D = [ 0 ] * b <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> y0 , h = P [ i ] ; y1 = Y [ i + 1 ] <NEWLINE> l = y1 - y0 <NEWLINE> D [ i ] = min ( y0 - h , l ) <NEWLINE> <NL> <DEDENT> idx = 0 <NEWLINE> S = { } <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> x = X [ i ] ; c = C [ i ] <NEWLINE> S [ x ] = c <NEWLINE> if x < Y [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while Y [ idx + 1 ] <= x : idx += 1 <NEWLINE> i = idx ; j = i <NEWLINE> while Y [ 0 ] <= x : <NEWLINE> <INDENT> while x < Y [ i ] : i -= 1 <NEWLINE> y0 , h = P [ i ] ; y1 = Y [ i + 1 ] <NEWLINE> if h == 0 : break <NEWLINE> x = h + ( ( x - y0 ) % D [ i ] ) <NEWLINE> assert x < y0 <NEWLINE> S [ x ] = c <NEWLINE> <DEDENT> <DEDENT> def check ( z ) : <NEWLINE> <INDENT> if z in S : <NEWLINE> <INDENT> return S [ z ] <NEWLINE> <DEDENT> i = bisect ( Y , z ) - 1 <NEWLINE> while Y [ 0 ] <= z : <NEWLINE> <INDENT> while z < Y [ i ] : i -= 1 <NEWLINE> y0 , h = P [ i ] ; y1 = Y [ i + 1 ] <NEWLINE> if h == 0 : break <NEWLINE> z = h + ( ( z - y0 ) % D [ i ] ) <NEWLINE> assert z < y0 <NEWLINE> if z in S : <NEWLINE> <INDENT> return S [ z ] <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> Z = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> print ( * map ( check , Z ) , sep = <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( x , y ) , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> diff_x = abs ( A - B ) <NEWLINE> diff_a = max ( V - W , 0 ) <NEWLINE> <NL> if T * diff_a >= diff_x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ 0 ] * 40000 <NEWLINE> for i , j in enumerate ( s ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> if j == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> if j == <STRING> : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = len ( r ) * len ( g ) * sum ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> if b [ 2 * j - i ] == 1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> if b [ 2 * i - j ] == 1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> if ( i + j ) % 2 == 0 and b [ ( i + j ) // 2 ] == 1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
def get_divisor ( n : int ) -> list : <NEWLINE> <INDENT> divisor = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> divisor . append ( i ) <NEWLINE> if n // i != i : <NEWLINE> <INDENT> divisor . append ( n // i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisor <NEWLINE> <NL> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> cand = get_divisor ( x ) <NEWLINE> <COMMENT> <NL> for d in cand : <NEWLINE> <INDENT> if d ** 5 == x : <NEWLINE> <INDENT> print ( d , 0 ) <NEWLINE> <DEDENT> elif d ** 5 < x : <NEWLINE> <INDENT> a = d <NEWLINE> b = 0 <NEWLINE> while a ** 5 - b ** 5 < x : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> b = - d <NEWLINE> while a ** 5 - b ** 5 < x : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d % 2 == 0 and ( d // 2 ) ** 5 + ( d // 2 ) ** 5 > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d % 2 == 1 and ( ( d + 1 ) // 2 ) ** 5 + ( d // 2 ) ** 5 > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a = d <NEWLINE> b = 0 <NEWLINE> while a ** 5 - b ** 5 > x : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> b = - d <NEWLINE> while a ** 5 - b ** 5 > x : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = [ input ( ) for l in range ( 2 ) ] <NEWLINE> N , A_dct , A = int ( s [ 0 ] ) , { int ( x ) : int ( x ) for x in s [ 1 ] . split ( ) } , [ int ( x ) for x in s [ 1 ] . split ( ) ] <NEWLINE> if 0 in A_dct : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> for k in A : <NEWLINE> <INDENT> tmp *= k <NEWLINE> if tmp > 10 ** 18 : <NEWLINE> <INDENT> tmp = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , Q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ABCD = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> score = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> score = max ( score , tmp ) <NEWLINE> <DEDENT> print ( score ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import copy <NEWLINE> <NL> def YesNo ( Bool ) : <NEWLINE> <INDENT> if ( Bool ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <NL> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A [ i ] - 1 , B [ i ] - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> cnt = uf . group_count ( ) <NEWLINE> <NL> print ( cnt - 1 ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = { } <NEWLINE> s = 0 <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> i = int ( i ) <NEWLINE> x = m . get ( i , 0 ) <NEWLINE> m [ i ] = x + 1 <NEWLINE> s += i <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = m . get ( b , 0 ) <NEWLINE> y = m . get ( c , 0 ) <NEWLINE> m [ b ] = 0 <NEWLINE> m [ c ] = x + y <NEWLINE> s = s - ( b * x ) + ( c * x ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> snum = tuple ( s [ : ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if snum [ i - 1 ] != snum [ j - 1 ] and snum [ i - 1 ] != snum [ k - 1 ] and snum [ j - 1 ] != snum [ k - 1 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = [ i for i in range ( 120 ) ] + [ - i for i in range ( 1 , 119 ) ] <NEWLINE> b = [ i for i in range ( 119 ) ] + [ - i for i in range ( 1 , 120 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> rst , min_val = 0 , 10 ** 6 <NEWLINE> for i in P_ls : <NEWLINE> <INDENT> if min_val >= i : <NEWLINE> <INDENT> rst += 1 <NEWLINE> min_val = i <NEWLINE> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( f + 1 ) <NEWLINE> w = [ ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( f + 1 ) : <NEWLINE> <INDENT> if i % ( a * 100 ) == 0 : dp [ i ] = i <NEWLINE> if i % ( b * 100 ) == 0 : dp [ i ] = i <NEWLINE> if i > a * 100 and dp [ i - a * 100 ] : dp [ i ] = i <NEWLINE> if i > a * 100 and dp [ i - b * 100 ] : dp [ i ] = i <NEWLINE> <DEDENT> for i in dp : <NEWLINE> <INDENT> if i : w . append ( i ) <NEWLINE> <DEDENT> m = w [ - 1 ] * e // 100 + 1 <NEWLINE> dp = [ 0 ] * ( m ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i % c == 0 : dp [ i ] = i <NEWLINE> if i % d == 0 : dp [ i ] = i <NEWLINE> if i > c and dp [ i - c ] : dp [ i ] = i <NEWLINE> if i > d and dp [ i - d ] : dp [ i ] = i <NEWLINE> <DEDENT> for i in dp : <NEWLINE> <INDENT> if i : s . append ( i ) <NEWLINE> <DEDENT> g = 0 <NEWLINE> ans = ( w [ 0 ] , 0 ) <NEWLINE> for i in w : <NEWLINE> <INDENT> for j in s : <NEWLINE> <INDENT> if i + j <= f and g < j / ( i + j ) <= e / ( 100 + e ) : <NEWLINE> <INDENT> g = j / ( i + j ) <NEWLINE> ans = ( i + j , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , ( input ( ) . split ( ) ) ) <NEWLINE> <NL> D = ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 <NEWLINE> d = math . sqrt ( D ) <NEWLINE> print ( d ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ - 1 ] * ( n + 1 ) <COMMENT> <NEWLINE> tmp = [ ] <COMMENT> <NEWLINE> here = 1 <NEWLINE> count = 0 <COMMENT> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if b [ here ] != - 1 : <COMMENT> <NEWLINE> <INDENT> roop = count - b [ here ] <COMMENT> <NEWLINE> if k < count : <COMMENT> <NEWLINE> <INDENT> print ( tmp [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_tmp = tmp [ b [ here ] : ] <NEWLINE> s = k - b [ here ] <NEWLINE> print ( new_tmp [ s % roop ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> b [ here ] = count <NEWLINE> count += 1 <NEWLINE> tmp . append ( here ) <NEWLINE> here = a [ here - 1 ] <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> checklist = [ True ] * 100000 <NEWLINE> ind = 0 <NEWLINE> l = [ X ] <NEWLINE> while True : <NEWLINE> <INDENT> t = l [ - 1 ] ** 2 % M <NEWLINE> if checklist [ t ] : <NEWLINE> <INDENT> l . append ( t ) <NEWLINE> checklist [ t ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = l . index ( t ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> S = sum ( l [ ind : ] ) <NEWLINE> L = len ( l ) <NEWLINE> ans = 0 <NEWLINE> if N <= L : <NEWLINE> <INDENT> ans = sum ( l [ : N ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( l ) <NEWLINE> N -= L <NEWLINE> ans += S * ( N // ( L - ind ) ) <NEWLINE> ans += sum ( l [ ind : ind + ( N % ( L - ind ) ) ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect , copy , heapq , itertools , math , string <NEWLINE> from collections import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> a = LIST ( ) <NEWLINE> b = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <DEDENT> c = [ a [ b [ i ] ] for i in range ( n ) ] <NEWLINE> print ( * c ) <NEWLINE>
<NL> import math <NEWLINE> <NL> <NL> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> num = math . floor ( n / b ) <NEWLINE> <NL> if num == 0 : <NEWLINE> <INDENT> x = n <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if num >= 100000 : <NEWLINE> <INDENT> print ( b - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> x = b * i - 1 <NEWLINE> ans = max ( ans , math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> t = ( a * b ) // 100 <NEWLINE> t = int ( t ) <NEWLINE> print ( t ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> MOD = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dp_sum = [ 0 ] * ( N + 1 ) <NEWLINE> dp_sum [ 1 ] = 1 <NEWLINE> <NL> <NL> def get ( l , r , i ) : <NEWLINE> <INDENT> return dp_sum [ max ( ( i - l ) , 0 ) ] - dp_sum [ max ( ( i - r - 1 ) , 0 ) ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for l , r in LR : <NEWLINE> <INDENT> dp [ i ] += get ( l , r , i ) % MOD <NEWLINE> <DEDENT> dp_sum [ i ] = ( dp_sum [ i - 1 ] + dp [ i ] ) % MOD <NEWLINE> <DEDENT> print ( dp [ N ] % MOD ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <NL> <DEDENT> j , mx = m , 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( b [ j ] > k - a [ i ] ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if ( i + j > mx ) : <NEWLINE> <INDENT> mx = i + j <NEWLINE> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
import itertools <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> HW = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> A = np . zeros ( H , dtype = np . int64 ) <NEWLINE> B = np . zeros ( W , dtype = np . int64 ) <NEWLINE> <NL> for h , w in HW : <NEWLINE> <INDENT> A [ h - 1 ] += 1 <NEWLINE> B [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxA = np . max ( A ) <NEWLINE> maxB = np . max ( B ) <NEWLINE> <NL> <COMMENT> <NL> ind_A = np . arange ( H ) [ A == maxA ] <NEWLINE> ind_B = np . arange ( W ) [ B == maxB ] <NEWLINE> <NL> <COMMENT> <NL> nn = len ( ind_A ) * len ( ind_B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = maxA + maxB <NEWLINE> <NL> if nn <= M : <NEWLINE> <INDENT> for h , w in HW : <NEWLINE> <INDENT> if A [ h - 1 ] == maxA and B [ w - 1 ] == maxB : <NEWLINE> <INDENT> nn -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans if nn else ans - 1 ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> base = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = dic [ B ] <NEWLINE> dic [ B ] = 0 <NEWLINE> dic [ C ] += tmp <NEWLINE> base += ( C - B ) * tmp <NEWLINE> print ( base ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BCs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> ansArray = np . zeros ( 10 ** 5 + 1 , dtype = int ) <NEWLINE> indexArray = np . array ( range ( 10 ** 5 + 1 ) ) <NEWLINE> <NL> for A in As : <NEWLINE> <INDENT> ansArray [ A ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = np . dot ( ansArray , indexArray ) <NEWLINE> <NL> for BC in BCs : <NEWLINE> <NL> <INDENT> ans = ans + ( BC [ 1 ] - BC [ 0 ] ) * ansArray [ BC [ 0 ] ] <NEWLINE> print ( ans ) <NEWLINE> ansArray [ BC [ 1 ] ] += ansArray [ BC [ 0 ] ] <NEWLINE> ansArray [ BC [ 0 ] ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
T = str ( input ( ) ) <NEWLINE> <NL> T = T . replace ( <STRING> , <STRING> ) <NEWLINE> T = T . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( T ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N < B : <NEWLINE> <INDENT> for i in range ( N , N + 1 ) : <NEWLINE> <INDENT> if ( ( A * i ) // B ) - A * ( i // B ) > ans : <NEWLINE> <INDENT> ans = ( ( A * i ) // B ) - A * ( i // B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( ( A * ( B - 1 ) ) // B ) - A * ( ( B - 1 ) // B ) > ans : <NEWLINE> <INDENT> ans = ( ( A * ( B - 1 ) ) // B ) - A * ( ( B - 1 ) // B ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> <NL> def conn ( n , m , e ) : <NEWLINE> <INDENT> d = dict ( zip ( range ( 1 , n + 1 ) , range ( - 1 , ( - 1 ) * n - 1 , - 1 ) ) ) <NEWLINE> td = defaultdict ( lambda : deque ( [ ] ) ) <COMMENT> <NEWLINE> c = 1 <NEWLINE> for edge in e : <NEWLINE> <INDENT> a = edge [ 0 ] <NEWLINE> b = edge [ 1 ] <NEWLINE> da = d [ a ] <COMMENT> <NEWLINE> db = d [ b ] <NEWLINE> if da < 0 and db < 0 : <NEWLINE> <INDENT> d [ a ] = c <NEWLINE> d [ b ] = c <NEWLINE> td [ c ] . append ( a ) <NEWLINE> td [ c ] . append ( b ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif da > 0 and db < 0 : <NEWLINE> <INDENT> d [ b ] = da <NEWLINE> td [ d [ a ] ] . append ( b ) <NEWLINE> <DEDENT> elif da < 0 and db > 0 : <NEWLINE> <INDENT> d [ a ] = db <NEWLINE> td [ d [ b ] ] . append ( a ) <NEWLINE> <DEDENT> elif da > 0 and db > 0 and da != db : <NEWLINE> <INDENT> for x in td [ db ] : <NEWLINE> <INDENT> d [ x ] = da <NEWLINE> td [ da ] . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return list ( d . values ( ) ) <NEWLINE> <NL> <DEDENT> def main ( n , k , l , e1 , e2 ) : <NEWLINE> <INDENT> d1 = conn ( n , k , e1 ) <NEWLINE> d2 = conn ( n , l , e2 ) <NEWLINE> p = tuple ( zip ( iter ( d1 ) , iter ( d2 ) ) ) <NEWLINE> d = Counter ( p ) <NEWLINE> <COMMENT> <NL> d [ ( k , l ) ] = 1 <NEWLINE> print ( <STRING> . join ( [ str ( d [ x ] ) for x in p ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ssr = sys . stdin . readline <NEWLINE> n , k , l = map ( int , ssr ( ) . strip ( ) . split ( ) ) <NEWLINE> e1 = [ ] <NEWLINE> e2 = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> e1 . append ( tuple ( map ( int , ssr ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( l ) : <NEWLINE> <INDENT> e2 . append ( tuple ( map ( int , ssr ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> main ( n , k , l , e1 , e2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( abs ( l [ n // 2 - 1 ] - l [ n // 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = N_List [ i ] <NEWLINE> ans [ s - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> l = [ 0 ] * Q <NEWLINE> r = [ 0 ] * Q <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> ans = 1 <NEWLINE> z = False <NEWLINE> l = input ( ) . split ( <STRING> ) <NEWLINE> for x in l : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( l [ i ] ) <NEWLINE> ans *= x <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n * ( n - 1 ) // 2 <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> cc = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> cc [ min ( j - i , abs ( X - i ) + 1 + abs ( Y - j ) ) - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in cc : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> line = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> a_list = line . split ( <STRING> ) <NEWLINE> a_list = [ int ( a ) for a in a_list ] <NEWLINE> <NL> ans_list = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> ans_list [ a - 1 ] = ans_list [ a - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for ans in ans_list : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> stack = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> stack . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = - 10 ** 9 <NEWLINE> minv = stack [ 0 ] <NEWLINE> for i in range ( 1 , len ( stack ) ) : <NEWLINE> <INDENT> maxv = max ( maxv , stack [ i ] - minv ) <NEWLINE> minv = min ( minv , stack [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
import sys <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> if t [ - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> if len ( t ) == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if i == 0 and t [ i + 1 ] == <STRING> and t [ 0 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> elif i == 0 and t [ 0 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if t [ i - 1 ] == <STRING> and t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i - 1 ] == <STRING> and t [ i + 1 ] == <STRING> and t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> except IndexError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s ^= A [ i ] <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = s ^ A [ i ] <NEWLINE> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arr = { } <NEWLINE> P = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in arr : <NEWLINE> <INDENT> arr [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> for k , v in arr . items ( ) : <NEWLINE> <INDENT> P [ k ] = k * v <NEWLINE> <DEDENT> S = sum ( [ i for i in P . values ( ) ] ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if B in arr : <NEWLINE> <INDENT> if C in arr : <NEWLINE> <INDENT> arr [ C ] += arr [ B ] <NEWLINE> P [ C ] += arr [ B ] * C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ C ] = arr [ B ] <NEWLINE> P [ C ] = arr [ B ] * C <NEWLINE> <DEDENT> S -= P [ B ] <NEWLINE> S += arr [ B ] * C <NEWLINE> del arr [ B ] <NEWLINE> del P [ B ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_ij = gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd_ij , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<NL> import sys <NEWLINE> import itertools <NEWLINE> from math import gcd <NEWLINE> from math import sqrt <NEWLINE> from sys import stdin <NEWLINE> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def mips ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> A , VA = mips ( ) <NEWLINE> B , VB = mips ( ) <NEWLINE> T = ii ( ) <NEWLINE> if A <= B : <NEWLINE> <INDENT> d1 = A + VA * T <NEWLINE> d2 = B + VB * T <NEWLINE> if d1 >= d2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d2 = B - VB * T <NEWLINE> d1 = A - VA * T <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import * <NEWLINE> K = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
dp = [ 0 ] + [ 1 << 20 ] * 10000 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( i // 2 + 1 ) : <NEWLINE> <INDENT> if dp [ j ] > dp [ i - j ] + a : dp [ j ] = dp [ i - j ] + a <NEWLINE> if dp [ i - j ] > dp [ j ] + a : dp [ i - j ] = dp [ j ] + a <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n // 2 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( N + 2 ) <NEWLINE> pass_list = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a [ b ] = 1 <NEWLINE> <DEDENT> if ( a [ 1 ] != 1 ) : <NEWLINE> <INDENT> pass_list [ 1 ] = 1 <NEWLINE> <DEDENT> if ( a [ 2 ] != 1 ) : <NEWLINE> <INDENT> pass_list [ 2 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if ( a [ i ] != 1 ) : <NEWLINE> <INDENT> pass_list [ i ] += pass_list [ i - 1 ] + pass_list [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( pass_list [ N ] % 1000000007 ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for H in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> from bisect import bisect_left <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <DEDENT> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> return - self . table [ self . _root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> <NL> extra_durabilities = [ 0 ] * n <NEWLINE> self_loop_durabilities = [ [ ] for _ in range ( n ) ] <NEWLINE> outdegrees = [ 0 ] * n <NEWLINE> base_operation_count = 0 <NEWLINE> uft = UnionFind ( n ) <NEWLINE> <NL> mp = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> for a , b , c in zip ( mp , mp , mp ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> outdegrees [ a ] += 1 <NEWLINE> if a == b : <NEWLINE> <INDENT> if c >= 2 : <NEWLINE> <INDENT> self_loop_durabilities [ a ] . append ( c ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> uft . unite ( a , b ) <NEWLINE> extra_durabilities [ a ] += c - 1 <NEWLINE> base_operation_count += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> components = defaultdict ( lambda : [ 0 , 0 , 0 , [ ] ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r = uft . _root ( i ) <NEWLINE> item = components [ r ] <NEWLINE> item [ 0 ] += 1 <NEWLINE> item [ 1 ] = max ( item [ 1 ] , outdegrees [ i ] ) <NEWLINE> item [ 2 ] += extra_durabilities [ i ] <NEWLINE> item [ 3 ] . extend ( self_loop_durabilities [ i ] ) <NEWLINE> <NL> <DEDENT> exists_initial_catalyst_on_moving_path = False <NEWLINE> exists_initial_catalyst_at_self_loop = False <NEWLINE> supplied_catalyst = 0 <NEWLINE> demanded_catalyst = 0 <NEWLINE> self_loop_catalysts_cost1 = [ ] <NEWLINE> self_loop_catalysts_cost2 = [ ] <NEWLINE> <NL> for i , ( cnt , deg , dur , sel ) in components . items ( ) : <NEWLINE> <INDENT> if cnt == 1 : <NEWLINE> <INDENT> if deg == 1 : <NEWLINE> <INDENT> self_loop_catalysts_cost2 . extend ( c - 2 for c in sel ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( sel ) >= 1 : <NEWLINE> <INDENT> self_loop_catalysts_cost1 . extend ( c - 1 for c in sel ) <NEWLINE> exists_initial_catalyst_at_self_loop = True <NEWLINE> <DEDENT> <DEDENT> continue <NEWLINE> <DEDENT> if deg == 1 : <NEWLINE> <INDENT> supplied_catalyst += dur <NEWLINE> demanded_catalyst += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> supplied_catalyst += dur <NEWLINE> if dur >= 1 : <NEWLINE> <INDENT> exists_initial_catalyst_on_moving_path = True <NEWLINE> <DEDENT> elif len ( sel ) >= 1 : <NEWLINE> <INDENT> exists_initial_catalyst_at_self_loop = True <NEWLINE> <DEDENT> <DEDENT> self_loop_catalysts_cost1 . extend ( c - 1 for c in sel ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if demanded_catalyst == 0 : <NEWLINE> <INDENT> return base_operation_count <NEWLINE> <NL> <DEDENT> if not exists_initial_catalyst_on_moving_path and not exists_initial_catalyst_at_self_loop : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> if supplied_catalyst >= demanded_catalyst : <NEWLINE> <INDENT> if exists_initial_catalyst_on_moving_path : <NEWLINE> <INDENT> return base_operation_count + demanded_catalyst <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return base_operation_count + demanded_catalyst + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> self_loop_catalysts_cost1 . sort ( reverse = True ) <NEWLINE> self_loop_catalysts_cost2 . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> acc1 = [ 0 ] + list ( accumulate ( self_loop_catalysts_cost1 ) ) <NEWLINE> acc2 = [ 0 ] + list ( accumulate ( self_loop_catalysts_cost2 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> shortage = demanded_catalyst - supplied_catalyst <NEWLINE> if acc1 [ - 1 ] + acc2 [ - 1 ] < shortage : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> cost = 10 ** 18 <NEWLINE> for use1 in range ( 0 if exists_initial_catalyst_on_moving_path else 1 , len ( acc1 ) ) : <NEWLINE> <INDENT> cat = acc1 [ use1 ] <NEWLINE> remaining = shortage - cat <NEWLINE> if remaining <= 0 : <NEWLINE> <INDENT> cost = min ( cost , use1 ) <NEWLINE> break <NEWLINE> <DEDENT> if remaining > acc2 [ - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> use2 = bisect_left ( acc2 , remaining ) <NEWLINE> cost = min ( cost , use1 + 2 * use2 ) <NEWLINE> <NL> <DEDENT> return base_operation_count + demanded_catalyst + cost <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in v : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= v [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> p = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p = p * a [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> total += A [ N - 1 - math . floor ( i / 2 ) ] <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> answer = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if int ( A [ i ] ) == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> answer = answer * int ( A [ i ] ) <NEWLINE> if answer > 1 * 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = int ( x * y ) <NEWLINE> b = int ( 2 * x + 2 * y ) <NEWLINE> <NL> <COMMENT> <NL> print ( a , b ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> n = 1 <NEWLINE> P = 10 % L <NEWLINE> while True : <NEWLINE> <INDENT> if P == 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> P = ( 10 * P ) % L <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = n % k <NEWLINE> print ( min ( a , k - a ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> def accumulate ( l , X ) : <NEWLINE> <INDENT> acclist = [ 0 ] * ( l + 1 ) <NEWLINE> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> acclist [ i ] = acclist [ i - 1 ] + X [ i ] <NEWLINE> <DEDENT> return acclist <NEWLINE> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = accumulate ( N , A ) <NEWLINE> Y = accumulate ( M , B ) <NEWLINE> <NL> maxbook = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> x = X [ i ] <NEWLINE> y = Y [ j ] <NEWLINE> while x + y > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y = Y [ j ] <NEWLINE> <DEDENT> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> maxbook = max ( maxbook , i + j ) <NEWLINE> <NL> <DEDENT> print ( maxbook ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> c = list ( str ( input ( ) ) ) <NEWLINE> dw = deque ( ) <NEWLINE> dr = deque ( ) <NEWLINE> <NL> for i , c in enumerate ( c , 1 ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dw . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dr . appendleft ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> while dw and dr : <NEWLINE> <INDENT> w = dw . popleft ( ) <NEWLINE> r = dr . popleft ( ) <NEWLINE> if w < r : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> iim = lambda : map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> it = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> N = next ( it ) <NEWLINE> A = [ next ( it ) for i in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ax = max ( A ) + 1 <NEWLINE> dp = [ 0 ] * ax <NEWLINE> for ai in A : <NEWLINE> <INDENT> da = dp [ ai ] <NEWLINE> if da > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ ai ] += 1 <NEWLINE> if da == 0 : <NEWLINE> <INDENT> for aj in range ( 2 * ai , ax , ai ) : <NEWLINE> <INDENT> dp [ aj ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if dp [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = { } <NEWLINE> r = { } <NEWLINE> xc = 0 <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> xi = int ( x ) <NEWLINE> lx = xc + xi <NEWLINE> if lx in l : <NEWLINE> <INDENT> l [ lx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ lx ] = 1 <NEWLINE> <DEDENT> rx = xc - xi <NEWLINE> if rx in r : <NEWLINE> <INDENT> r [ rx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ rx ] = 1 <NEWLINE> <DEDENT> xc += 1 <NEWLINE> <DEDENT> c = 0 <NEWLINE> for x in l : <NEWLINE> <INDENT> if x in r : <NEWLINE> <INDENT> c += l [ x ] * r [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def insertionSort ( nums , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and nums [ j ] > v : <NEWLINE> <INDENT> nums [ j + g ] = nums [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> nums [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( nums , n ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> v = 1 <NEWLINE> while v <= n : <NEWLINE> <INDENT> g . append ( v ) <NEWLINE> v = 3 * v + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertionSort ( nums , n , g [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> nums . append ( 0 ) <NEWLINE> shellSort ( nums , n ) <NEWLINE> nums . pop ( ) <NEWLINE> for v in nums : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_neg = [ ] <NEWLINE> A_pos = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] <= 0 : <NEWLINE> <INDENT> A_neg . append ( - A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_pos . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> A_neg . sort ( reverse = True ) <NEWLINE> A_pos . sort ( reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if K == N : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= ( A [ i ] % 1000000007 ) <NEWLINE> ans %= 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> elif K % 2 == 1 and len ( A_pos ) == 0 : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans *= ( ( - A_neg [ - i ] ) % 1000000007 ) <NEWLINE> ans %= 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> ans *= A_pos . pop ( 0 ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> buf = [ ] <NEWLINE> for i in range ( len ( A_pos ) // 2 ) : <NEWLINE> <INDENT> buf . append ( A_pos [ 2 * i ] * A_pos [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( len ( A_neg ) // 2 ) : <NEWLINE> <INDENT> buf . append ( A_neg [ 2 * i ] * A_neg [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> buf . sort ( reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= ( buf [ i ] % 1000000007 ) <NEWLINE> ans %= 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
num = int ( input ( ) ) <NEWLINE> nabeatu = [ ] <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> nabeatu . append ( str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( nabeatu ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> baisu = [ 0 ] * ( a [ n - 1 ] + 1 ) <NEWLINE> an = a [ n - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a0 = a [ i ] <NEWLINE> a1 = a0 <NEWLINE> while a1 <= an : <NEWLINE> <INDENT> baisu [ a1 ] += 1 <NEWLINE> a1 += a0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if baisu [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> lst = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> lst . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> lst . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> lst . append ( n ) <NEWLINE> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> while lst : <NEWLINE> <INDENT> s = 0 <NEWLINE> i = 1 <NEWLINE> num = lst [ 0 ] <NEWLINE> for ele in lst : <NEWLINE> <INDENT> if ele == num : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( s ) : <NEWLINE> <INDENT> lst . remove ( num ) <NEWLINE> <DEDENT> while s > 0 : <NEWLINE> <INDENT> s -= i <NEWLINE> i += 1 <NEWLINE> if s >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> max_ = 0 <NEWLINE> min_ = 0 <NEWLINE> <NL> for i in range ( x , 102 , 1 ) : <NEWLINE> <NL> <INDENT> if i not in p_list : <NEWLINE> <INDENT> max_ = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in reversed ( range ( x + 1 ) ) : <NEWLINE> <NL> <NL> <INDENT> if j not in p_list : <NEWLINE> <INDENT> min_ = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( min_ - x ) <= abs ( max_ - x ) : <NEWLINE> <INDENT> ans = min_ <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max_ <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
cnt = 0 <NEWLINE> coefficients = [ 1 ] <NEWLINE> n = 1 <NEWLINE> <NL> _list = [ ] <NEWLINE> length = int ( input ( ) ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> _list . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , length ) : <NEWLINE> <INDENT> if i < n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> coefficients . append ( i ) <NEWLINE> n = i * 2.25 + 1 <NEWLINE> <NL> <DEDENT> for c in coefficients [ : : - 1 ] : <NEWLINE> <INDENT> for i in range ( length ) : <NEWLINE> <INDENT> val = _list [ i ] <NEWLINE> j = i - c <NEWLINE> while j >= 0 and _list [ j ] > val : <NEWLINE> <INDENT> _list [ j + c ] = _list [ j ] <NEWLINE> j -= c <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> _list [ j + c ] = val <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( coefficients ) ) <NEWLINE> print ( * coefficients [ : : - 1 ] ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * _list , sep = <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( <STRING> ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for v in c : <NEWLINE> <INDENT> ans += v * c [ v ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if C in c : <NEWLINE> <INDENT> ans = ans - B * c [ B ] + C * c [ B ] <NEWLINE> c [ C ] += c [ B ] <NEWLINE> del c [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans - B * c [ B ] + C * c [ B ] <NEWLINE> c [ C ] = c [ B ] <NEWLINE> del c [ B ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> count = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> num = input ( ) . split ( ) <NEWLINE> <NL> hantei = 0 <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> if int ( num [ i ] ) == 0 : <NEWLINE> <INDENT> hantei = 1 <NEWLINE> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if hantei == 0 : <NEWLINE> <INDENT> total = 1 <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> total = int ( num [ i ] ) * total <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> lr = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> lr . append ( ( l , r ) ) <NEWLINE> <DEDENT> lr . sort ( ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if l >= i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += dp [ i - l ] - dp [ max ( 0 , i - r - 1 ) ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + cnt ) % mod <NEWLINE> <NL> <DEDENT> print ( cnt % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( s , MAX ) : <NEWLINE> <INDENT> if s < 3 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif s < 6 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> num = 6 <NEWLINE> while num <= s : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = c <NEWLINE> c += tmp <NEWLINE> c %= MAX <NEWLINE> num += 1 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> MAX = 10 ** 9 + 7 <NEWLINE> s = int ( input ( ) ) <NEWLINE> res = solve ( s , MAX ) <NEWLINE> <NL> print ( res ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> combo = False <NEWLINE> cnt = 0 <NEWLINE> ans = [ 0 , ] <NEWLINE> for mozi in s : <NEWLINE> <INDENT> if ( mozi == <STRING> or mozi == <STRING> or mozi == <STRING> or mozi == <STRING> ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> if combo != True : <NEWLINE> <INDENT> combo = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if combo : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> combo = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans . append ( cnt ) <NEWLINE> print ( max ( ans ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> import decimal <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def prime_factor_count ( n ) : <NEWLINE> <INDENT> def count ( n , i ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> return n , cnt <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return d <NEWLINE> <NL> <DEDENT> n , cnt = count ( n , 2 ) <NEWLINE> d [ 2 ] = cnt <NEWLINE> <NL> lst = [ 2 ] <NEWLINE> for num in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for p_num in lst : <NEWLINE> <INDENT> if num % p_num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif p_num * p_num > num : <NEWLINE> <INDENT> lst . append ( num ) <NEWLINE> n , cnt = count ( n , num ) <NEWLINE> d [ num ] = cnt <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n != 1 : <NEWLINE> <INDENT> d [ n ] = 1 <NEWLINE> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> d = prime_factor_count ( n ) <NEWLINE> <NL> cnt = 0 <NEWLINE> tmp_n = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> exp_cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if exp_cnt > v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tmp_n % ( tmp_exp : = k ** exp_cnt ) == 0 : <NEWLINE> <INDENT> tmp_n //= tmp_exp <NEWLINE> cnt += 1 <NEWLINE> v -= exp_cnt <NEWLINE> exp_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == tmp_n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def seq ( ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> yield a <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( here , went , connect , discovery , low , answer , seq ) : <NEWLINE> <INDENT> went |= { here } <NEWLINE> discovery [ here ] = low [ here ] = next ( seq ) <NEWLINE> child = 0 <NEWLINE> for con in connect [ here ] : <NEWLINE> <INDENT> if con not in went : <NEWLINE> <INDENT> parent [ con ] = here <NEWLINE> child += 1 <NEWLINE> dfs ( con , went , connect , discovery , low , answer , seq ) <NEWLINE> low [ here ] = min ( low [ here ] , low [ con ] ) <NEWLINE> if parent [ here ] is None and child >= 2 : <NEWLINE> <INDENT> answer [ here ] = 1 <NEWLINE> <DEDENT> elif parent [ here ] is not None and discovery [ here ] <= low [ con ] : <NEWLINE> <INDENT> answer [ here ] = 1 <NEWLINE> <DEDENT> <DEDENT> elif parent [ here ] != con : <NEWLINE> <INDENT> low [ here ] = min ( low [ here ] , discovery [ con ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> vertices , edges = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> for _ in range ( edges ) : <NEWLINE> <INDENT> v1 , v2 = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect [ v1 ] . append ( v2 ) <NEWLINE> connect [ v2 ] . append ( v1 ) <NEWLINE> <DEDENT> answer = [ 0 for n in range ( vertices ) ] <NEWLINE> new_seq = seq ( ) <NEWLINE> went = set ( ) <NEWLINE> discovery = [ 0 for n in range ( vertices ) ] <NEWLINE> low = [ float ( <STRING> ) for n in range ( vertices ) ] <NEWLINE> parent = [ None for n in range ( vertices ) ] <NEWLINE> dfs ( 0 , went , connect , discovery , low , answer , new_seq ) <NEWLINE> for i , n in enumerate ( answer ) : <NEWLINE> <INDENT> if n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import string <NEWLINE> s = str ( input ( ) ) <NEWLINE> low = string . ascii_lowercase <NEWLINE> fin = <STRING> <NEWLINE> for i in range ( len ( low ) ) : <NEWLINE> <INDENT> if low [ i ] not in s : <NEWLINE> <INDENT> fin += low [ i ] <NEWLINE> <DEDENT> <DEDENT> if len ( fin ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fin [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> nums = sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> nums . reverse ( ) <NEWLINE> output = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> output . append ( nums [ i ] ) <NEWLINE> if i < ( n - 1 ) : <NEWLINE> <INDENT> output . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for S in B : <NEWLINE> <INDENT> result *= S <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % result ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> C = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in C . keys ( ) : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> B = list ( C . items ( ) ) <NEWLINE> B . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> count = B [ i ] [ 1 ] <NEWLINE> if i + 1 < len ( B ) and B [ i + 1 ] [ 0 ] == B [ i ] [ 0 ] + 1 : <NEWLINE> <INDENT> count += B [ i + 1 ] [ 1 ] <NEWLINE> if i + 2 < len ( B ) and B [ i + 2 ] [ 0 ] == B [ i ] [ 0 ] + 2 : <NEWLINE> <INDENT> count += B [ i + 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> num += data [ i ] <NEWLINE> <DEDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> num -= data [ i ] <NEWLINE> temp = ( num * data [ i ] ) <NEWLINE> ans += temp <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b = b * a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = list ( range ( N ) ) <NEWLINE> p . sort ( key = lambda i : A [ i ] , reverse = True ) <NEWLINE> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> pi = p [ i ] <NEWLINE> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] + A [ pi ] * ( N - i + j - 1 - pi ) ) <NEWLINE> dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + A [ pi ] * ( pi - j ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp [ N ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> money += A [ i ] * stock <NEWLINE> stock = 0 <NEWLINE> <DEDENT> elif A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> buy = money // A [ i ] <NEWLINE> money -= A [ i ] * buy <NEWLINE> stock += buy <NEWLINE> <DEDENT> <DEDENT> money += A [ N - 1 ] * stock <NEWLINE> stock = 0 <NEWLINE> <NL> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def cal ( i ) : <NEWLINE> <INDENT> s = ( i + i * ( n // i ) ) * ( n // i ) * 0.5 <NEWLINE> return s <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += cal ( i ) <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def solve ( s , p ) : <NEWLINE> <INDENT> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> return [ p // 1000 , p // 100 % 10 , p // 10 % 10 , p % 10 ] [ ord ( s [ 0 ] ) - ord ( <STRING> ) ] <NEWLINE> <DEDENT> i = 3 <NEWLINE> cs = [ 0 , 1 ] [ s [ 2 ] == <STRING> ] <NEWLINE> ce = 0 <NEWLINE> while cs != ce : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cs += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> ce += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> j = i + 1 <NEWLINE> cs = [ 0 , 1 ] [ s [ i ] == <STRING> ] <NEWLINE> ce = 0 <NEWLINE> while cs != ce : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> cs += 1 <NEWLINE> <DEDENT> elif s [ j ] == <STRING> : <NEWLINE> <INDENT> ce += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> l = solve ( s [ 2 : i ] , p ) <NEWLINE> r = solve ( s [ i : j ] , p ) <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> return l | r <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> return l & r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return l ^ r <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> p = int ( input ( ) ) <NEWLINE> a = solve ( s , p ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> if solve ( s , i ) == a : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a , c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = { } <NEWLINE> R = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = i + 1 + A [ i ] <NEWLINE> if t in L : <NEWLINE> <INDENT> L [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ t ] = 1 <NEWLINE> <DEDENT> t = i + 1 - A [ i ] <NEWLINE> if t > 0 : <NEWLINE> <INDENT> if t in R : <NEWLINE> <INDENT> R [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ t ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in R : <NEWLINE> <INDENT> if i in L : <NEWLINE> <INDENT> ans += R [ i ] * L [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A + B ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> range_total = sum ( P [ : K ] ) + K <NEWLINE> max_value = range_total <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> range_total += P [ K + i ] - P [ i ] <NEWLINE> max_value = max ( max_value , range_total ) <NEWLINE> <DEDENT> print ( max_value / 2 ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> A . append ( ( X [ i ] [ 0 ] - X [ j ] [ 0 ] , X [ i ] [ 1 ] - X [ j ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> C = Counter ( A ) <NEWLINE> print ( N - C . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import copy <NEWLINE> <NL> def next_permutation ( a ) : <NEWLINE> <INDENT> for i in reversed ( range ( len ( a ) - 1 ) ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> j = next ( j for j in reversed ( range ( i + 1 , len ( a ) ) ) if a [ i ] < a [ j ] ) <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> a [ i + 1 : ] = reversed ( a [ i + 1 : ] ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> if len ( S ) == 26 : <NEWLINE> <INDENT> sl = list ( S ) <NEWLINE> if next_permutation ( sl ) : <NEWLINE> <INDENT> np = <STRING> . join ( sl ) <NEWLINE> for b in range ( 0 , 26 ) : <NEWLINE> <INDENT> if np [ b ] != S [ b ] : <NEWLINE> <INDENT> print ( np [ : b + 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> hist = set ( S ) <NEWLINE> for c in range ( 0 , 27 ) : <NEWLINE> <INDENT> cand = chr ( c + ord ( <STRING> ) ) <NEWLINE> if cand not in hist : <NEWLINE> <INDENT> print ( S + cand ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> num = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( s , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 1 <NEWLINE> c = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if S == a [ j ] : <NEWLINE> <INDENT> S += 1 <NEWLINE> <DEDENT> elif S != a [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n , m = tmp [ 0 ] , tmp [ 1 ] <NEWLINE> ans = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> hs , ws = [ 0 ] , [ 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> hs . append ( hs [ - 1 ] + int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ws . append ( ws [ - 1 ] + int ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> h_dif , w_dif = [ 0 ] * ( hs [ - 1 ] + 1 ) , [ 0 ] * ( ws [ - 1 ] + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> h_dif [ hs [ j ] - hs [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( i + 1 , m + 1 ) : <NEWLINE> <INDENT> w_dif [ ws [ j ] - ws [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , min ( len ( h_dif ) , len ( w_dif ) ) ) : <NEWLINE> <INDENT> ans += h_dif [ i ] * w_dif [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for v in cnt . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for k in A : <NEWLINE> <COMMENT> <NL> <INDENT> print ( ans - ( cnt [ k ] - 1 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def binary_search ( data , targets , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for num in targets : <NEWLINE> <INDENT> small = 0 <NEWLINE> big = n - 1 <NEWLINE> while small < big : <NEWLINE> <INDENT> index = ( small + big ) >> 1 <NEWLINE> if small < big : <NEWLINE> <INDENT> if num < data [ index ] : <NEWLINE> <INDENT> big = index - 1 <NEWLINE> <DEDENT> if num > data [ index ] : <NEWLINE> <INDENT> small = index + 1 <NEWLINE> <DEDENT> if num == data [ index ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if small == big and num == data [ small ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input_data = [ val . split ( ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> n = int ( input_data [ 0 ] [ 0 ] ) <NEWLINE> data = [ int ( n ) for n in input_data [ 1 ] ] <NEWLINE> targets = [ int ( n ) for n in input_data [ 3 ] ] <NEWLINE> print ( binary_search ( data , targets , n ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> route = [ 0 ] <NEWLINE> visited = { 0 } <NEWLINE> while True : <NEWLINE> <INDENT> nex = A [ route [ - 1 ] ] - 1 <NEWLINE> <COMMENT> <NL> if nex in visited : <NEWLINE> <COMMENT> <NL> <INDENT> loopstart = route . index ( nex ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . add ( nex ) <NEWLINE> route += [ nex ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> before_loop , one_loop = route [ : loopstart ] , route [ loopstart : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if K <= len ( before_loop ) - 1 : <NEWLINE> <INDENT> print ( before_loop [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= len ( before_loop ) <NEWLINE> K %= len ( one_loop ) <NEWLINE> print ( one_loop [ K ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def digit_sum ( num ) : <NEWLINE> <INDENT> digit_sum = 0 <NEWLINE> while ( num > 0 ) : <NEWLINE> <INDENT> digit_sum += num % 10 <NEWLINE> num = int ( num / 10 ) <NEWLINE> <DEDENT> return digit_sum <NEWLINE> <NL> <DEDENT> min_num = 100000 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> B = N - A <NEWLINE> digit_num = digit_sum ( A ) <NEWLINE> digit_num += digit_sum ( B ) <NEWLINE> if digit_num < min_num : <NEWLINE> <INDENT> min_num = digit_num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
from collections import deque <NEWLINE> n , m , * inp = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> d = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> j = 2 * i <NEWLINE> a , b = inp [ j : j + 2 ] <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <DEDENT> l = [ - 1 for i in range ( n ) ] <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> <COMMENT> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for i in d [ x ] : <NEWLINE> <COMMENT> <NL> <INDENT> if l [ i ] == - 1 : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <COMMENT> <NL> l [ i ] = str ( x + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> l = l [ 1 : ] <NEWLINE> <COMMENT> <NL> print ( <STRING> if 0 in l else <STRING> + <STRING> . join ( l ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> left = 1 <NEWLINE> right = N <NEWLINE> <NL> for l , r in LR : <NEWLINE> <INDENT> left = max ( left , l ) <NEWLINE> right = min ( right , r ) <NEWLINE> <NL> <DEDENT> ans = right - left <NEWLINE> <NL> print ( ans + 1 if ans >= 0 else 0 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s1 = [ ] <NEWLINE> s2 = [ ] <NEWLINE> sum = 0 <NEWLINE> for i , s in enumerate ( line ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> s1 . append ( i ) <NEWLINE> <DEDENT> elif s == <STRING> and len ( s1 ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> j = s1 . pop ( ) <NEWLINE> sum += i - j <COMMENT> <NEWLINE> <COMMENT> <NL> a = i - j <NEWLINE> while len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> a += s2 . pop ( ) [ 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> s2 . append ( ( j , a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> if len ( s2 ) > 0 : <NEWLINE> <INDENT> print ( len ( s2 ) , end = <STRING> ) <NEWLINE> for x in s2 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( s2 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> T = <STRING> <NEWLINE> ans = 0 <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> if S [ i ] in T : <NEWLINE> <INDENT> temp = 1 <NEWLINE> for j in range ( i + 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ j ] in T : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def calc ( n ) : <NEWLINE> <INDENT> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = x ** 2 <NEWLINE> if a >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( 1 , 1 + n ) : <NEWLINE> <INDENT> b = y ** 2 <NEWLINE> if b >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , 1 + n ) : <NEWLINE> <INDENT> c = z ** 2 <NEWLINE> if c >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> f = a + b + c + x * y + y * z + z * x <NEWLINE> if f > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ f ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> res = calc ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( res [ i + 1 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ratio = [ ] <NEWLINE> cnt = 0 <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ratio . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( len ( s ) - len ( t ) ) : <NEWLINE> <INDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + k ] == t [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ratio . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> res = len ( t ) - max ( ratio ) <NEWLINE> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> def bsrch ( l , s , e , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = int ( ( e - s ) / 2 ) + s if e - s > 1 else s <NEWLINE> x = l [ c ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if x == a : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c > s : <NEWLINE> <INDENT> if x < a : <NEWLINE> <INDENT> return bsrch ( l , c , e , a ) <NEWLINE> <DEDENT> elif x > a : <NEWLINE> <INDENT> return bsrch ( l , s , c , a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = { } <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> x = bsrch ( S , 0 , n , T [ j ] ) <NEWLINE> if x == True : <NEWLINE> <INDENT> cnt [ T [ j ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( cnt ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> input = stdin . readline <NEWLINE> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arrive = [ 1 ] <NEWLINE> next = aa [ 1 ] <NEWLINE> visited = set ( [ 1 ] ) <NEWLINE> if next == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while not ( next in visited ) : <NEWLINE> <INDENT> arrive . append ( next ) <NEWLINE> visited . add ( next ) <NEWLINE> next = aa [ next ] <NEWLINE> <DEDENT> num_town = len ( arrive ) <NEWLINE> start_index = arrive . index ( next ) <NEWLINE> if k < num_town : <NEWLINE> <INDENT> print ( arrive [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( arrive [ start_index + ( k - start_index ) % ( num_town - start_index ) ] ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> import math <NEWLINE> <NL> def Next ( ) : return input ( ) <NEWLINE> def NextInt ( ) : return int ( Next ( ) ) <NEWLINE> def NextInts ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def Nexts ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def NextIntList ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def RowInts ( n ) : return [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> da = NextIntList ( ) <NEWLINE> da = sorted ( da ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= da [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , x = int ( input ( ) ) , input ( ) <NEWLINE> o = x . count ( <STRING> ) <NEWLINE> if o == 1 : <NEWLINE> <INDENT> for i , v in enumerate ( x ) : <NEWLINE> <INDENT> if v == <STRING> : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if x [ - 1 ] == <STRING> : print ( 1 ) <NEWLINE> else : print ( 2 ) <NEWLINE> <DEDENT> else : print ( 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = o - 1 <NEWLINE> M = o + 1 <NEWLINE> mp , mm = { 0 : 1 } , { 0 : 1 } <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> mp [ i ] = mp [ i - 1 ] * 2 % M <NEWLINE> mm [ i ] = mm [ i - 1 ] * 2 % m <NEWLINE> <DEDENT> A = int ( x , 2 ) <NEWLINE> a = A % m <NEWLINE> b = A % M <NEWLINE> rest = { 0 : 0 } <NEWLINE> for i in range ( 1 , o + 1 ) : <NEWLINE> <INDENT> rest [ i ] = 1 + rest [ i % bin ( i ) . count ( <STRING> ) ] <NEWLINE> <DEDENT> for i , v in enumerate ( x ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> print ( 1 + rest [ ( a - mm [ n - i - 1 ] ) % m ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 + rest [ ( b + mp [ n - i - 1 ] ) % M ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> def check ( x ) : <NEWLINE> <INDENT> return math . floor ( ( A * x ) / B ) <NEWLINE> <NL> <DEDENT> print ( check ( x ) ) <NEWLINE>
num = input ( ) <NEWLINE> num_list = [ ] <NEWLINE> num_list = num . split ( ) <NEWLINE> <NL> if int ( num_list [ 0 ] ) == int ( num_list [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> elif int ( num_list [ 0 ] ) > int ( num_list [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def dist ( ) : <NEWLINE> <INDENT> coordinates = [ float ( num ) for num in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> return math . hypot ( coordinates [ 2 ] - coordinates [ 0 ] , <NEWLINE> <INDENT> coordinates [ 3 ] - coordinates [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print ( dist ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> k = 0 <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> I = i ** 5 <NEWLINE> j = I - x <NEWLINE> J = abs ( j ) <NEWLINE> k = 0 <NEWLINE> while k <= J ** ( 0.2 ) : <NEWLINE> <INDENT> if k ** 5 == J : <NEWLINE> <INDENT> A = i <NEWLINE> B = k * ( np . sign ( j ) ) <NEWLINE> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE>
import math <NEWLINE> def fib ( q ) : <NEWLINE> <INDENT> fibonacci = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , q ) : <NEWLINE> <INDENT> fibonacci . append ( fibonacci [ i - 2 ] + fibonacci [ i - 1 ] ) <NEWLINE> <DEDENT> return fibonacci [ q - 1 ] <NEWLINE> <DEDENT> n , m = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( - 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a . append ( n + 1 ) <NEWLINE> out = 1 <NEWLINE> c = 10 ** 9 + 7 <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> out *= int ( fib ( a [ i + 1 ] - a [ i ] ) ) <NEWLINE> <DEDENT> out %= c <NEWLINE> print ( out ) <NEWLINE>
from sys import stdin <NEWLINE> def stdinput ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( stdinput ( ) ) <NEWLINE> inputs = list ( map ( int , [ stdinput ( ) for _ in range ( n ) ] ) ) <NEWLINE> <NL> primes = 0 <NEWLINE> for a in inputs : <NEWLINE> <INDENT> if is_prime ( a , None ) : <NEWLINE> <INDENT> primes += 1 <NEWLINE> <DEDENT> <DEDENT> print ( primes ) <NEWLINE> <NL> <DEDENT> def is_prime ( a , primes ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for p in range ( 2 , int ( a ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if a % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : print ( <STRING> if A [ K + i ] > A [ i ] else <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> judge = [ True ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> j = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> judge [ a - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( judge . count ( True ) ) <NEWLINE>
import collections <NEWLINE> import math <NEWLINE> <NL> def cmb_factorial ( s ) : <NEWLINE> <INDENT> return math . factorial ( s ) // ( math . factorial ( 2 ) * math . factorial ( s - 2 ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> f = { } <NEWLINE> <NL> cmb = 0 <NEWLINE> for x in c . values ( ) : <NEWLINE> <INDENT> f [ 1 ] = 0 <NEWLINE> f [ 2 ] = 1 <NEWLINE> if x >= 3 : <NEWLINE> <INDENT> f [ x ] = cmb_factorial ( x ) <NEWLINE> if x - 1 not in f : <NEWLINE> <INDENT> f [ x - 1 ] = cmb_factorial ( x - 1 ) <NEWLINE> <DEDENT> <DEDENT> cmb += f . get ( x ) <NEWLINE> <NL> <DEDENT> for z in a : <NEWLINE> <INDENT> y = c . get ( z ) <NEWLINE> ans = cmb <NEWLINE> if y >= 2 : <NEWLINE> <INDENT> ans = cmb - f . get ( y ) + f . get ( y - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> L = [ 0 ] * 10 <NEWLINE> R = [ 0 ] * 10 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> L [ i ] , R [ i ] = l , r <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> up = [ 0 ] * ( N + 1 ) <NEWLINE> up [ 0 ] = 1 <NEWLINE> up [ 1 ] = - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + up [ i - 1 ] <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> if i + ( L [ j ] - 1 ) < N + 1 : <NEWLINE> <INDENT> up [ i + ( L [ j ] - 1 ) ] += dp [ i ] <NEWLINE> <DEDENT> if i + R [ j ] < N + 1 : <NEWLINE> <INDENT> up [ i + R [ j ] ] -= dp [ i ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] %= 998244353 <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . data = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def insert ( node , x ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return Node ( x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif x < node . data : <NEWLINE> <INDENT> node . left = Node . insert ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = Node . insert ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def find ( node , x ) : <NEWLINE> <INDENT> if node . data == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif node . left != None and node . data > x : <NEWLINE> <INDENT> return Node . find ( node . left , x ) <NEWLINE> <DEDENT> elif node . right != None and node . data < x : <NEWLINE> <INDENT> return Node . find ( node . right , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( node , x ) : <NEWLINE> <INDENT> if node . data == x : <NEWLINE> <INDENT> if ( node . left == None ) and ( node . right == None ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif node . left == None : <NEWLINE> <INDENT> return node . right <NEWLINE> <DEDENT> elif node . right == None : <NEWLINE> <INDENT> return node . left <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . data = Node . serch_min ( node . right ) <NEWLINE> node . right = Node . delete_min ( node . right ) <NEWLINE> return node <NEWLINE> <DEDENT> <DEDENT> elif node . data > x : <NEWLINE> <INDENT> node . left = Node . delete ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = Node . delete ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def serch_min ( node ) : <NEWLINE> <INDENT> if node . left != None : <NEWLINE> <INDENT> return Node . serch_min ( node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . data <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_min ( node ) : <NEWLINE> <INDENT> if node . left == None : <NEWLINE> <INDENT> return node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . left = Node . delete_min ( node . left ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder_print ( node ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = <STRING> <NEWLINE> if node . left != None : <NEWLINE> <INDENT> s += Node . inorder_print ( node . left ) <NEWLINE> <DEDENT> s += <STRING> + str ( node . data ) <NEWLINE> if node . right != None : <NEWLINE> <INDENT> s += Node . inorder_print ( node . right ) <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> def preorder_print ( node ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = <STRING> <NEWLINE> s += <STRING> + str ( node . data ) <NEWLINE> if node . left != None : <NEWLINE> <INDENT> s += Node . preorder_print ( node . left ) <NEWLINE> <DEDENT> if node . right != None : <NEWLINE> <INDENT> s += Node . preorder_print ( node . right ) <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> <DEDENT> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> self . root = Node . insert ( self . root , x ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if Node . find ( self . root , x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> self . root = Node . delete ( self . root , x ) <NEWLINE> <NL> <DEDENT> def print_tree ( self ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = Node . inorder_print ( self . root ) <NEWLINE> print ( s ) <NEWLINE> s = Node . preorder_print ( self . root ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> T = BinaryTree ( ) <NEWLINE> m = int ( sys . stdin . readline ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> T . print_tree ( ) <NEWLINE> <DEDENT> elif s . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . find ( int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif s . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . delete ( int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = int ( s . split ( ) [ 1 ] ) <NEWLINE> T . insert ( z ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z <= k and z >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = [ ] <NEWLINE> x = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = n - 1 - i <NEWLINE> c = int ( s [ j ] ) <NEWLINE> p %= 2019 <NEWLINE> x += ( p * c ) % 2019 <NEWLINE> p *= 10 <NEWLINE> x %= 2019 <NEWLINE> a . append ( x ) <NEWLINE> <DEDENT> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans += v <NEWLINE> <DEDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) . strip ( ) ) <NEWLINE> l , r = 0 , N - 1 <NEWLINE> ans = 0 <NEWLINE> if <STRING> not in C or <STRING> not in C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return True <NEWLINE> <DEDENT> while l < r : <NEWLINE> <INDENT> while C [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while C [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if l < r : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> p = i + 2 <NEWLINE> <COMMENT> <NL> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> while p < N and L [ p ] < L [ i ] + L [ j ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans += max ( 0 , p - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def digitSum ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = str ( n ) <NEWLINE> <COMMENT> <NL> array = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> return sum ( array ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = digitSum ( n ) <NEWLINE> <COMMENT> <NL> <NL> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inf = 10 ** 9 <NEWLINE> dp = [ 0 ] + [ inf ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import copy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class csr : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( s , n , edges ) : <NEWLINE> <INDENT> s . start = [ 0 ] * ( n + 1 ) <NEWLINE> s . elist = [ [ ] for _ in range ( len ( edges ) ) ] <NEWLINE> for e in edges : <NEWLINE> <INDENT> s . start [ e [ 0 ] + 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s . start [ i ] += s . start [ i - 1 ] <NEWLINE> <DEDENT> counter = copy . deepcopy ( s . start ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> s . elist [ counter [ e [ 0 ] ] ] = e [ 1 ] <NEWLINE> counter [ e [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class scc_graph : <NEWLINE> <NL> <INDENT> edges = [ ] <NEWLINE> <NL> <COMMENT> <NL> def __init__ ( s , n ) : s . _n = n <NEWLINE> def num_vertices ( s ) : return s . _n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> def add_edge ( s , frm , to ) : s . edges . append ( [ frm , [ to ] ] ) <NEWLINE> <NL> <COMMENT> <NL> def scc_ids ( s ) : <NEWLINE> <INDENT> g = csr ( s . _n , s . edges ) <NEWLINE> now_ord = group_num = 0 <NEWLINE> visited = [ ] <NEWLINE> low = [ 0 ] * s . _n <NEWLINE> ord = [ - 1 ] * s . _n <NEWLINE> ids = [ 0 ] * s . _n <NEWLINE> <COMMENT> <NL> def dfs ( self , v , now_ord , group_num ) : <NEWLINE> <INDENT> low [ v ] = ord [ v ] = now_ord <NEWLINE> now_ord += 1 <NEWLINE> visited . append ( v ) <NEWLINE> for i in range ( g . start [ v ] , g . start [ v + 1 ] ) : <NEWLINE> <INDENT> to = g . elist [ i ] [ 0 ] <NEWLINE> if ord [ to ] == - 1 : <NEWLINE> <INDENT> now_ord , group_num = self ( self , to , now_ord , group_num ) <NEWLINE> low [ v ] = min ( low [ v ] , low [ to ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low [ v ] = min ( low [ v ] , ord [ to ] ) <NEWLINE> <DEDENT> <DEDENT> if low [ v ] == ord [ v ] : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> u = visited . pop ( ) <NEWLINE> ord [ u ] = s . _n <NEWLINE> ids [ u ] = group_num <NEWLINE> if u == v : break <NEWLINE> <DEDENT> group_num += 1 <NEWLINE> <DEDENT> return now_ord , group_num <NEWLINE> <NL> <DEDENT> for i in range ( s . _n ) : <NEWLINE> <INDENT> if ord [ i ] == - 1 : now_ord , group_num = dfs ( dfs , i , now_ord , group_num ) <NEWLINE> <DEDENT> for i in range ( s . _n ) : <NEWLINE> <INDENT> ids [ i ] = group_num - 1 - ids [ i ] <NEWLINE> <DEDENT> return [ group_num , ids ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def scc ( s ) : <NEWLINE> <INDENT> ids = s . scc_ids ( ) <NEWLINE> group_num = ids [ 0 ] <NEWLINE> counts = [ 0 ] * group_num <NEWLINE> for x in ids [ 1 ] : counts [ x ] += 1 <NEWLINE> groups = [ [ ] for _ in range ( group_num ) ] <NEWLINE> for i in range ( s . _n ) : <NEWLINE> <INDENT> groups [ ids [ 1 ] [ i ] ] . append ( i ) <NEWLINE> <DEDENT> return groups <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> g = scc_graph ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> u , v = ab [ i ] <NEWLINE> g . add_edge ( u , v ) <NEWLINE> <NL> <DEDENT> scc = g . scc ( ) <NEWLINE> <NL> print ( len ( scc ) ) <NEWLINE> <NL> for v in scc : <NEWLINE> <INDENT> print ( len ( v ) , end = <STRING> ) <NEWLINE> for x in v : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = 1 <NEWLINE> G = [ g ] <NEWLINE> while 3 * g + 1 < n : <NEWLINE> <INDENT> g = 3 * g + 1 <NEWLINE> G . append ( g ) <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> G . reverse ( ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( stdin . readline ( ) ) <NEWLINE> A = [ int ( stdin . readline ( ) ) for i in range ( n ) ] <NEWLINE> <NL> shellSort ( A , n ) <NEWLINE> print ( cnt ) <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> <NL> ans = ( A * x // B ) - A * ( x // B ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Flag = True <NEWLINE> ans = 1 <NEWLINE> <NL> if ( 0 in As ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * As [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> if ( Flag ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> Flag = False <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( Flag ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def dep ( u , p ) : <NEWLINE> <INDENT> D [ u ] = p <NEWLINE> for i in tree [ u ] [ 3 ] : <NEWLINE> <INDENT> dep ( i , p + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_ans ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <INDENT> . format ( i , tree [ i ] [ 0 ] , D [ i ] , <NEWLINE> <INDENT> <STRING> if tree [ i ] [ 0 ] == NIL else <STRING> if tree [ i ] [ 1 ] == NIL else <STRING> , <NEWLINE> tree [ i ] [ 3 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> NIL = - 1 <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> tree = [ [ NIL , NIL , NIL ] for i in range ( n ) ] <NEWLINE> D = [ 0 for i in range ( n ) ] <NEWLINE> root = set ( range ( n ) ) <NEWLINE> for a in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a = list ( map ( int , a . split ( ) ) ) <NEWLINE> tree [ a [ 0 ] ] . append ( a [ 2 : ] ) <NEWLINE> if a [ 1 ] > 0 : <NEWLINE> <INDENT> tree [ a [ 0 ] ] [ 1 ] = a [ 2 ] <COMMENT> <NEWLINE> for i in range ( a [ 1 ] ) : <NEWLINE> <INDENT> tree [ a [ i + 2 ] ] [ 0 ] = a [ 0 ] <COMMENT> <NEWLINE> if i != a [ 1 ] - 1 : <NEWLINE> <INDENT> tree [ a [ i + 2 ] ] [ 2 ] = a [ i + 3 ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> root -= set ( a [ 2 : ] ) <NEWLINE> <DEDENT> dep ( root . pop ( ) , 0 ) <NEWLINE> print_ans ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum_list = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * ( sum_list - A [ i ] ) <NEWLINE> ans %= 1000000007 <NEWLINE> sum_list -= A [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from copy import deepcopy <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> a = np . array ( [ list ( map ( int , l . split ( ) ) ) for l in read ( ) . splitlines ( ) ] ) <NEWLINE> cost = deepcopy ( a ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> arr = np . stack ( [ cost , [ cost [ k ] ] + np . transpose ( [ cost [ k ] ] ) ] ) <NEWLINE> cost = np . amin ( arr , axis = 0 ) <NEWLINE> <DEDENT> cost2 = deepcopy ( a ) <NEWLINE> f = np . sum ( cost < a ) <NEWLINE> if f : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> filt = np . sum ( [ ( [ cost [ k ] ] + np . transpose ( [ cost [ k ] ] ) ) == cost for k in range ( n ) ] , axis = 0 ) == 2 <NEWLINE> print ( np . sum ( a [ filt ] ) // 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = math . pi * r ** 2 <NEWLINE> l = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> LR = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> LR . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> p = 0 <NEWLINE> C = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif p == 1 and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> p = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> C . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l = LR [ i ] [ 0 ] <NEWLINE> r = LR [ i ] [ 1 ] <NEWLINE> ans = C [ r - 1 ] - C [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from time import time <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> t0 = time ( ) <NEWLINE> x , y , z = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> no = 0 <NEWLINE> for s in range ( N - 2 ) : <NEWLINE> <INDENT> d = 1 <NEWLINE> while ( s + 2 * d < N ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = S [ s ] <NEWLINE> b = S [ s + d ] <NEWLINE> c = S [ s + 2 * d ] <NEWLINE> if a != b and b != c and c != a : <NEWLINE> <INDENT> no += 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x * y * z - no ) <NEWLINE> <COMMENT> <NL>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = sorted ( p , reverse = True ) <NEWLINE> q = sorted ( q , reverse = True ) <NEWLINE> r = sorted ( r ) <NEWLINE> <NL> box = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <NL> for i in range ( x ) : <NEWLINE> <INDENT> box . append ( p [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( y ) : <NEWLINE> <INDENT> box . append ( q [ j ] ) <NEWLINE> <NL> <DEDENT> box = box + r <NEWLINE> <NL> box = sorted ( box , reverse = True ) <NEWLINE> <NL> for k in range ( x + y ) : <NEWLINE> <INDENT> ans += box [ k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n : <NEWLINE> <INDENT> aa , ba = 0 , 0 <NEWLINE> a , b = [ None ] * n , [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> aa += ( a [ i ] + b [ i ] ) <NEWLINE> <DEDENT> elif a [ i ] < b [ i ] : <NEWLINE> <INDENT> ba += ( a [ i ] + b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa += a [ i ] <NEWLINE> ba += b [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( aa , ba ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left as bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> g [ u ] . append ( v ) <NEWLINE> g [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> def dfs ( t , f , l ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> i = bisect ( l , a [ t ] ) <NEWLINE> if len ( l ) == i : <NEWLINE> <INDENT> l . append ( a [ t ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = [ i , l [ i ] ] <NEWLINE> l [ i ] = a [ t ] <NEWLINE> <DEDENT> ans [ t ] = len ( l ) <NEWLINE> for v in g [ t ] : <NEWLINE> <INDENT> if v != f : <NEWLINE> <INDENT> back = dfs ( v , t , l ) <NEWLINE> if back : <NEWLINE> <INDENT> l [ back [ 0 ] ] = back [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> dfs ( 0 , 0 , [ ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> P_n = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( X , 150 ) : <NEWLINE> <INDENT> if i not in set ( P_n ) : <NEWLINE> <INDENT> min_1 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( X , - 150 , - 1 ) : <NEWLINE> <INDENT> if i not in set ( P_n ) : <NEWLINE> <INDENT> min_2 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if abs ( min_1 - X ) == abs ( min_2 - X ) : <NEWLINE> <INDENT> print ( min ( min_1 , min_2 ) ) <NEWLINE> <DEDENT> elif abs ( min_1 - X ) < abs ( min_2 - X ) : <NEWLINE> <INDENT> print ( min_1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> goods = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> goods . append ( input ( ) ) <NEWLINE> <DEDENT> goods = list ( set ( goods ) ) <NEWLINE> print ( len ( goods ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> p_min = p [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p_min >= p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> p_min = min ( p_min , p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sorted ( A ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> if result == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result *= i <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = abs ( x ) // d <NEWLINE> <NL> if n >= k : <NEWLINE> <INDENT> print ( abs ( x ) - d * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - n ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - d * n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - d * ( n + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( a ) >= k : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> L , R = - 1 , n - 1 <NEWLINE> while L + 1 < R : <NEWLINE> <INDENT> P = ( L + R + 1 ) // 2 <NEWLINE> if k <= a [ P ] : <NEWLINE> <INDENT> R = P <NEWLINE> continue <NEWLINE> <DEDENT> dp = np . zeros ( ( k + 1 ) , dtype = np . bool ) <NEWLINE> dp [ 0 ] = True <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if k <= a [ j ] or j == P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ a [ j ] : ] |= dp [ : - a [ j ] ] <NEWLINE> <DEDENT> f = False <NEWLINE> for j in range ( k - a [ P ] , k ) : <NEWLINE> <INDENT> f |= dp [ j ] <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> R = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = P <NEWLINE> <DEDENT> <DEDENT> print ( R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = [ int ( x ) for x in reversed ( list ( input ( ) ) ) ] <NEWLINE> n = len ( s ) <NEWLINE> x = [ 0 ] * 2019 <NEWLINE> dp = 0 <NEWLINE> dim = 1 <NEWLINE> for si in s : <NEWLINE> <INDENT> dp = ( dp + si * dim ) % 2019 <NEWLINE> x [ dp ] += 1 <NEWLINE> dim = dim * 10 % 2019 <NEWLINE> <DEDENT> ans = x [ 0 ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += x [ i ] * ( x [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> <NL> s = a [ k - 1 ] <NEWLINE> <NL> print ( s ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = X + s * d <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import collections as c <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> <NL> cnt = c . Counter ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = 2 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if x * ans % 360 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> h , w , d = nii ( ) <NEWLINE> <NL> a_dict = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = lnii ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> a_dict [ a [ j ] ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> b_dict = { } <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> num = i <NEWLINE> cy , cx = a_dict [ num ] <NEWLINE> b_dict [ num ] = 0 <NEWLINE> while num + d <= h * w : <NEWLINE> <INDENT> num += d <NEWLINE> ny , nx = a_dict [ num ] <NEWLINE> b_dict [ num ] = b_dict [ num - d ] + abs ( cy - ny ) + abs ( cx - nx ) <NEWLINE> cy = ny <NEWLINE> cx = nx <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = nii ( ) <NEWLINE> ans = b_dict [ r ] - b_dict [ l ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import random , time <NEWLINE> def score ( D , c , s , t ) : <NEWLINE> <INDENT> v = list ( ) <NEWLINE> last = [ 0 ] * 26 <NEWLINE> legacy = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> minus = 0 <NEWLINE> v . append ( legacy ) <NEWLINE> v [ i ] += s [ i ] [ t [ i ] - 1 ] <NEWLINE> last [ t [ i ] - 1 ] = i + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> minus += c [ j ] * ( i + 1 - last [ j ] ) <NEWLINE> <DEDENT> v [ i ] -= minus <NEWLINE> legacy = v [ i ] <NEWLINE> <DEDENT> return v [ D - 1 ] <NEWLINE> <DEDENT> time_sta = time . perf_counter ( ) <NEWLINE> s = list ( ) <NEWLINE> t = list ( ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> t = [ random . randint ( 1 , 26 ) ] * D <NEWLINE> time_end = time . perf_counter ( ) <NEWLINE> tim = time_end - time_sta <NEWLINE> while tim < 1.9 : <NEWLINE> <INDENT> d = random . randint ( 1 , D ) <NEWLINE> q = random . randint ( 1 , 26 ) <NEWLINE> old = t [ d - 1 ] <NEWLINE> oldscore = score ( D , c , s , t ) <NEWLINE> t [ d - 1 ] = q <NEWLINE> if score ( D , c , s , t ) < oldscore : <NEWLINE> <INDENT> t [ d - 1 ] = old <NEWLINE> <DEDENT> time_end = time . perf_counter ( ) <NEWLINE> tim = time_end - time_sta <NEWLINE> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> import itertools <NEWLINE> <NL> <NL> def gcd ( a , b , c ) : <NEWLINE> <INDENT> ans = math . gcd ( a , b ) <NEWLINE> ans = math . gcd ( ans , c ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> elem = [ i + 1 for i in range ( k ) ] <NEWLINE> <NL> combs = itertools . combinations_with_replacement ( elem , 3 ) <NEWLINE> <NL> tmp = [ 1 , 2 , 3 ] <NEWLINE> <NL> s = 0 <NEWLINE> for comb in combs : <NEWLINE> <INDENT> s += sum ( tmp [ : len ( set ( comb ) ) ] ) * gcd ( comb [ 0 ] , comb [ 1 ] , comb [ 2 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> hw . sort ( ) <NEWLINE> <NL> hcnt = [ 0 ] * ( H + 1 ) <NEWLINE> wcnt = [ 0 ] * ( W + 1 ) <NEWLINE> <NL> target = [ ] <NEWLINE> for i , j in hw : <NEWLINE> <INDENT> hcnt [ i ] += 1 <NEWLINE> wcnt [ j ] += 1 <NEWLINE> target . append ( [ str ( i ) + <STRING> + str ( j ) , 1 ] ) <NEWLINE> <NL> <DEDENT> d = dict ( target ) <NEWLINE> <NL> hlist = [ ] <NEWLINE> hmax = - 1 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> if hmax < hcnt [ i ] : <NEWLINE> <INDENT> hlist = [ i ] <NEWLINE> hmax = hcnt [ i ] <NEWLINE> <DEDENT> elif hmax == hcnt [ i ] : <NEWLINE> <INDENT> hlist . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> wlist = [ ] <NEWLINE> wmax = - 1 <NEWLINE> for i in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if wmax < wcnt [ i ] : <NEWLINE> <INDENT> wlist = [ i ] <NEWLINE> wmax = wcnt [ i ] <NEWLINE> <DEDENT> elif wmax == wcnt [ i ] : <NEWLINE> <INDENT> wlist . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( hlist ) * len ( wlist ) > M : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> idx = 0 <NEWLINE> for h in hlist : <NEWLINE> <INDENT> for w in wlist : <NEWLINE> <INDENT> while h > hw [ idx ] [ 0 ] or w > hw [ idx ] [ 1 ] : <NEWLINE> <INDENT> idx += 1 <NEWLINE> if idx == M : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if h == hw [ idx ] [ 0 ] and w == hw [ idx ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if h < hw [ idx ] [ 0 ] or w < hw [ idx ] [ 1 ] : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( hmax + wmax - 1 ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> a = len ( S ) <NEWLINE> b = len ( T ) <NEWLINE> m = a - b <NEWLINE> ans = b <NEWLINE> if m != 0 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> cnt = b <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( cnt , ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = b <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( cnt , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def v ( ) : <NEWLINE> <INDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> r = int ( e . split ( ) [ 0 ] ) <NEWLINE> d = [ int ( <STRING> . join ( x ) , 2 ) for x in zip ( * [ input ( ) . split ( ) for _ in [ 0 ] * r ] ) ] <NEWLINE> a = 0 <NEWLINE> for m in range ( 1 << ~ - r ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for s in d : <NEWLINE> <INDENT> c = bin ( m ^ s ) . count ( <STRING> ) <NEWLINE> t += max ( c , r - c ) <NEWLINE> <DEDENT> if a < t : a = t <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : v ( ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> seen = set ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( S [ i ] ) <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] + S [ j ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( S [ i ] + S [ j ] ) <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] + S [ j ] + S [ k ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( S [ i ] + S [ j ] + S [ k ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> C [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * C ) <NEWLINE>
from math import sqrt <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cand = [ ] <NEWLINE> <NL> for i in range ( 1 , int ( sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> cand . append ( i ) <NEWLINE> u = M // i <NEWLINE> if u != i : <NEWLINE> <INDENT> cand . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cand . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for j in cand : <NEWLINE> <INDENT> if N * j <= M : <NEWLINE> <INDENT> ans = max ( ans , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = np . zeros ( ( K , N ) ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> D [ i ] [ A [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = D . sum ( axis = 0 ) <NEWLINE> print ( sum ( ans == 0 ) ) <NEWLINE>
s = input ( ) <NEWLINE> a = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ a ] += 1 <NEWLINE> r = 1 <NEWLINE> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> a = ( a + int ( i ) * r ) % 2019 <NEWLINE> r = r * 10 % 2019 <NEWLINE> mods [ a ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in mods : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h = [ ] <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if a [ 0 ] > a [ 1 ] : <NEWLINE> <INDENT> h . append ( a [ 0 ] - a [ 1 ] ) <NEWLINE> a [ 1 ] = a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if a [ i - 1 ] > a [ i ] : <NEWLINE> <INDENT> h . append ( a [ i - 1 ] - a [ i ] ) <NEWLINE> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( h ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> <NL> ans2 = A [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> j = 1 <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if cnt == 2 : <NEWLINE> <INDENT> j += 1 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> ans2 += A [ j ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( ans2 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = Counter ( input ( ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s &= Counter ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( sorted ( s . elements ( ) ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_list = sorted ( p_list ) <NEWLINE> <NL> print ( sum ( p_list [ : K ] ) ) <NEWLINE>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> indices = [ ] <NEWLINE> for cb in b : <NEWLINE> <INDENT> bgn_idx = 0 <NEWLINE> for i , cur_idx in enumerate ( indices ) : <NEWLINE> <INDENT> chr_idx = a . find ( cb , bgn_idx ) + 1 <NEWLINE> if not chr_idx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if chr_idx < cur_idx : <NEWLINE> <INDENT> indices [ i ] = chr_idx <NEWLINE> <DEDENT> bgn_idx = cur_idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> chr_idx = a . find ( cb , bgn_idx ) + 1 <NEWLINE> if chr_idx : <NEWLINE> <INDENT> indices . append ( chr_idx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( indices ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> rr = [ ] <NEWLINE> gg = [ ] <NEWLINE> bb = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rr . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> gg . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lr = len ( rr ) <NEWLINE> lg = len ( gg ) <NEWLINE> lb = len ( bb ) <NEWLINE> ans = lr * lg * lb <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> for xx in rr : <NEWLINE> <INDENT> for yy in gg : <NEWLINE> <INDENT> x , y = min ( xx , yy ) , max ( xx , yy ) <NEWLINE> d = y - x <NEWLINE> a = x - d <NEWLINE> b = y + d <NEWLINE> if 0 <= a < n and s [ a ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 0 <= b < n and s [ b ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( x + y ) % 2 == 0 : <NEWLINE> <INDENT> c = ( x + y ) // 2 <NEWLINE> if 0 <= c < n and s [ c ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> max_len = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> while j < n and s [ i : j ] in s [ j : ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> max_len = max ( max_len , j - i - 1 ) <NEWLINE> <NL> <DEDENT> print ( max_len ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> <NL> def solve ( n , a_list , uv_list ) : <NEWLINE> <INDENT> res = [ 0 ] * n <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for u , v in uv_list : <NEWLINE> <INDENT> tree [ u - 1 ] . append ( v - 1 ) <NEWLINE> tree [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> visited = [ 0 ] * n <NEWLINE> parent = [ - 1 ] * n <NEWLINE> tour = [ 0 ] <NEWLINE> p = 0 <NEWLINE> while True : <NEWLINE> <INDENT> visited [ p ] = 1 <NEWLINE> r = parent [ p ] <NEWLINE> while len ( tree [ p ] ) : <NEWLINE> <INDENT> q = tree [ p ] . pop ( ) <NEWLINE> if visited [ q ] == 0 : <NEWLINE> <INDENT> parent [ q ] = p <NEWLINE> r = q <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = r <NEWLINE> tour . append ( p ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> dp = [ 10 ** 9 + i for i in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> re_visited = [ 0 ] * n <NEWLINE> callbacks = [ ] <NEWLINE> for p in tour : <NEWLINE> <INDENT> if re_visited [ p ] == 0 : <NEWLINE> <INDENT> re_visited [ p ] = 1 <NEWLINE> ind = bisect_left ( dp , a_list [ p ] ) <NEWLINE> callbacks . append ( ( ind , dp [ ind ] ) ) <NEWLINE> dp [ ind ] = a_list [ p ] <NEWLINE> res [ p ] = bisect_left ( dp , 10 ** 9 ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind , v = callbacks . pop ( ) <NEWLINE> dp [ ind ] = v <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uv_list = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> res = solve ( n , a_list , uv_list ) <NEWLINE> for r in res : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 10 , [ 1 , 2 , 5 , 3 , 4 , 6 , 7 , 3 , 2 , 4 ] , <NEWLINE> <INDENT> [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 3 , 6 ] , [ 6 , 7 ] , [ 1 , 8 ] , [ 8 , 9 ] , [ 9 , 10 ] ] <NEWLINE> ) == [ 1 , 2 , 3 , 3 , 4 , 4 , 5 , 2 , 2 , 3 ] <NEWLINE> <DEDENT> assert solve ( 10 , [ 5 , 2 , 5 , 3 , 4 , 6 , 7 , 3 , 2 , 4 ] , <NEWLINE> <INDENT> [ [ 1 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 1 , 6 ] , [ 1 , 7 ] , [ 1 , 8 ] , [ 1 , 9 ] , [ 1 , 10 ] ] <NEWLINE> ) == [ 1 , 1 , 1 , 1 , 1 , 2 , 2 , 1 , 1 , 1 ] <NEWLINE> <DEDENT> assert solve ( 10 , [ 5 , 2 , 5 , 3 , 4 , 6 , 7 , 3 , 2 , 4 ] , <NEWLINE> <INDENT> [ [ 1 , 2 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 2 , 7 ] , [ 2 , 8 ] , [ 2 , 9 ] , [ 2 , 10 ] ] <NEWLINE> ) == [ 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 1 , 2 ] <NEWLINE> <DEDENT> assert solve ( 10 , [ 3 , 5 , 5 , 3 , 4 , 6 , 7 , 3 , 2 , 4 ] , <NEWLINE> <INDENT> [ [ 1 , 2 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 2 , 7 ] , [ 2 , 8 ] , [ 2 , 9 ] , [ 2 , 10 ] ] <NEWLINE> ) == [ 1 , 2 , 2 , 2 , 2 , 3 , 3 , 2 , 2 , 2 ] <NEWLINE> <DEDENT> assert solve ( 10 , [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] , <NEWLINE> <INDENT> [ [ 1 , 2 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 2 , 7 ] , [ 2 , 8 ] , [ 2 , 9 ] , [ 2 , 10 ] ] <NEWLINE> ) == [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] * ( h * w + 1 ) <NEWLINE> b = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> l = map ( int , input ( ) . split ( ) ) <NEWLINE> for j , k in enumerate ( l , 1 ) : <NEWLINE> <INDENT> a [ k ] = i <NEWLINE> b [ k ] = j <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( d + 1 , h * w + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i - d ] + abs ( a [ i ] - a [ i - d ] ) + abs ( b [ i ] - b [ i - d ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> res . append ( c [ r ] - c [ l ] ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( map ( str , res ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( s ) for s in A ] <NEWLINE> <NL> sum = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sum *= A [ i ] <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sum > 1000000000000000000 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = int ( n ** 0.5 ) <NEWLINE> li = [ 0 ] * ( 10 ** 4 ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( 1 , m ) : <NEWLINE> <INDENT> for k in range ( 1 , m ) : <NEWLINE> <INDENT> if i * i + j * j + k * k + i * j + k * j + k * i <= n : <NEWLINE> <INDENT> li [ i * i + j * j + k * k + i * j + k * j + k * i - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT>
a , b , c , k = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> ans = int ( 0 ) <NEWLINE> if k >= a : <NEWLINE> <INDENT> ans += a <NEWLINE> k -= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += k <NEWLINE> k = 0 <NEWLINE> <DEDENT> if k >= b : <NEWLINE> <INDENT> k -= b <NEWLINE> <DEDENT> if k >= c : <NEWLINE> <INDENT> ans -= c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] <NEWLINE> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> start , end = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = ans [ end - 1 ] - ans [ start - 1 ] <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> ( H , W ) = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if ( H , W ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , face_vals ) : <NEWLINE> <INDENT> self . faces = dict ( zip ( [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> ] , face_vals . split ( ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] = self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] = self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] = self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] = self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> def _revolve ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] = self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] = self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] , self . faces [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> def show_right_face ( self , top , front ) : <NEWLINE> <INDENT> if front == self . faces [ <STRING> ] : <NEWLINE> <INDENT> if top == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . _revolve ( <STRING> ) <NEWLINE> self . _revolve ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> self . roll ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif front == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif front == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . _revolve ( <STRING> ) <NEWLINE> <DEDENT> elif front == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . _revolve ( <STRING> ) <NEWLINE> <DEDENT> elif front == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> if top == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif top == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif top == self . faces [ <STRING> ] : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> print ( self . faces [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> face_vals = sys . stdin . readline ( ) <NEWLINE> <NL> dice = Dice ( face_vals ) <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> top , front = sys . stdin . readline ( ) . split ( ) <NEWLINE> dice . show_right_face ( top , front ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if arr [ i - k ] < arr [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = [ 0 ] * K <NEWLINE> n , k = N - 1 , 0 <NEWLINE> while k < K : <NEWLINE> <INDENT> if S [ n ] == <STRING> : <NEWLINE> <INDENT> R [ k ] = n + 1 <NEWLINE> k += 1 <NEWLINE> n -= C <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <DEDENT> R = R [ : : - 1 ] <NEWLINE> <NL> n , k = 0 , 0 <NEWLINE> while k < K : <NEWLINE> <INDENT> if S [ n ] == <STRING> : <NEWLINE> <INDENT> if n + 1 == R [ k ] : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> <DEDENT> k += 1 <NEWLINE> n += C <NEWLINE> <DEDENT> n += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> t = N % 26 <NEWLINE> ans = chr ( t + 97 ) + ans <NEWLINE> N //= 26 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> one_or_two = [ 0 ] + [ 1 ] + [ 2 ] + [ - 1 ] * n <NEWLINE> for i in range ( 3 , n + 3 ) : <NEWLINE> <INDENT> one_or_two [ i ] = ( one_or_two [ i - 1 ] + one_or_two [ i - 2 ] ) % mod <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> print ( one_or_two [ n ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> if a [ 0 ] > 1 : <NEWLINE> <INDENT> ans *= one_or_two [ a [ 0 ] - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> if a [ i ] - a [ i - 1 ] == 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ i ] - a [ i - 1 ] == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= one_or_two [ a [ i ] - a [ i - 1 ] - 2 ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if n - a [ - 1 ] > 1 : <NEWLINE> <INDENT> ans *= one_or_two [ n - a [ - 1 ] - 1 ] <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ line [ 1 ] ] = 1 <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> if line [ 1 ] in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> num = Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans += ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> cnt = collections . Counter ( s ) <NEWLINE> used = set ( cnt . keys ( ) ) <NEWLINE> c = - 1 <NEWLINE> if len ( used ) < 26 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if not chr ( i + ord ( <STRING> ) ) in used : <NEWLINE> <INDENT> c = chr ( i + ord ( <STRING> ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c != - 1 : <NEWLINE> <INDENT> print ( s + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = 25 <NEWLINE> while i > 1 and s [ i - 1 ] > s [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> lused = sorted ( s [ i - 1 : ] ) <NEWLINE> print ( s [ : i - 1 ] + lused [ lused . index ( s [ i - 1 ] ) + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import io <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> _DEB = 0 <COMMENT> <NEWLINE> <NL> _INPUT = <STRING> + ( <STRING> * 200000 ) <NEWLINE> _EXPECTED = <STRING> <NEWLINE> if _DEB : <NEWLINE> <INDENT> sys . stdin = io . StringIO ( _INPUT ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def logd ( str ) : <NEWLINE> <INDENT> if _DEB : print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> c = c . replace ( <STRING> , <STRING> ) <NEWLINE> c = c . replace ( <STRING> , <STRING> ) <NEWLINE> c = [ int ( x ) for x in c ] <NEWLINE> <NL> <COMMENT> <NL> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> id1 = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if id1 > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> id0 = - 1 <NEWLINE> if c [ i ] == 0 : <NEWLINE> <INDENT> id0 = i <NEWLINE> not_found = True <NEWLINE> for j in range ( id1 , id0 ) : <NEWLINE> <INDENT> if c [ j ] == 1 : <NEWLINE> <INDENT> id1 = j <NEWLINE> c [ i ] = 1 <NEWLINE> c [ j ] = 0 <NEWLINE> ans += 1 <NEWLINE> not_found = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not_found : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if [ i ] == 0 : <NEWLINE> <INDENT> c [ i ] = 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = str ( ans ) <NEWLINE> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <COMMENT> <NL> if _DEB : <NEWLINE> <INDENT> if _EXPECTED . strip ( ) == ans . strip ( ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> n_c = n - 1 <NEWLINE> w_dict = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> <NEWLINE> <INDENT> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> <NEWLINE> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> } <NEWLINE> <DEDENT> out = <STRING> <NEWLINE> while n_c > 25 : <NEWLINE> <INDENT> out = out + w_dict [ n_c % 26 ] <NEWLINE> n_c = n_c // 26 - 1 <NEWLINE> <NL> <DEDENT> out = out + w_dict [ n_c ] <NEWLINE> print ( out [ : : - 1 ] ) <NEWLINE>
char = list ( input ( ) ) <NEWLINE> for i in range ( len ( char ) ) : <NEWLINE> <INDENT> if char [ i ] . islower ( ) : <NEWLINE> <INDENT> char [ i ] = char [ i ] . upper ( ) <NEWLINE> <DEDENT> elif char [ i ] . isupper ( ) : <NEWLINE> <INDENT> char [ i ] = char [ i ] . lower ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( char ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count += ( N - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> from math import factorial <NEWLINE> <NL> def permutations_count ( n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return factorial ( n ) // factorial ( n - r ) <NEWLINE> <NL> <DEDENT> def combinations_count ( n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> <NL> lis = [ ] <NEWLINE> amari = 1 <NEWLINE> lis . append ( int ( S [ - 1 ] ) ) <NEWLINE> <NL> for i in range ( 2 , len ( S ) + 1 ) : <NEWLINE> <INDENT> amari = ( amari * 10 ) % 2019 <NEWLINE> lis . append ( ( int ( S [ - 1 * i ] ) * amari + lis [ i - 2 ] ) % 2019 ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( lis ) <NEWLINE> <NL> su = 0 <NEWLINE> <NL> for k in c : <NEWLINE> <INDENT> if c [ k ] > 1 : <NEWLINE> <INDENT> su += combinations_count ( c [ k ] , 2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> su += c [ 0 ] <NEWLINE> <NL> print ( su ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uni = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uni . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( uni . group_count ( ) - 1 ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = X <NEWLINE> hist = [ a ] <NEWLINE> indices = [ - 1 ] * M <NEWLINE> indices [ a ] = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( 1 , min ( 10 ** 6 , N ) ) : <NEWLINE> <INDENT> a = a ** 2 % M <NEWLINE> if indices [ a ] != - 1 : <NEWLINE> <INDENT> idx = indices [ a ] <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> hist . append ( a ) <NEWLINE> indices [ a ] = i <NEWLINE> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( sum ( hist ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cycle = hist [ idx : ] <NEWLINE> margin = hist [ : idx ] <NEWLINE> q , r = divmod ( ( N - len ( margin ) ) , len ( cycle ) ) <NEWLINE> ans = 0 <NEWLINE> ans += sum ( margin ) <NEWLINE> ans += sum ( cycle ) * q <NEWLINE> <COMMENT> <NL> ans += sum ( cycle [ : r ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE>
t = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i , s in enumerate ( t ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> for s in ans : <NEWLINE> <INDENT> print ( s , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> from collections import deque <NEWLINE> import bisect <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> from queue import deque <NEWLINE> from math import gcd <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> <NL> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def inp_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def lcm ( x , y ) : return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> N = inp ( ) <NEWLINE> r = - 1 <NEWLINE> if 0 < N < 10 : <NEWLINE> <INDENT> r = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = int ( str ( N ) [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if r in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> A . append ( tmp ) <NEWLINE> <NL> <DEDENT> B = copy . copy ( A ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> max_val = max ( B ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == max_val : <NEWLINE> <INDENT> print ( B [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ N - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
from bisect import bisect_right <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ps = [ 0 ] + sorted ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> <NL> p2 = set ( ) <NEWLINE> for i , pi in enumerate ( ps ) : <NEWLINE> <INDENT> for pj in ps [ i : ] : <NEWLINE> <INDENT> if pi + pj > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p2 . add ( pi + pj ) <NEWLINE> <NL> <DEDENT> <DEDENT> p2 = sorted ( p2 ) <NEWLINE> <NL> print ( max ( pi + p2 [ bisect_right ( p2 , m - pi ) - 1 ] for pi in p2 ) ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> target = X <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> target_num_min = X <NEWLINE> target_num_plus = X <NEWLINE> if X in p_list : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> target_num_min -= 1 <NEWLINE> if target_num_min not in p_list : <NEWLINE> <INDENT> target = target_num_min <NEWLINE> break <NEWLINE> <DEDENT> target_num_plus += 1 <NEWLINE> if target_num_plus not in p_list : <NEWLINE> <INDENT> target = target_num_plus <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( target ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ ] <NEWLINE> xor = 0 <NEWLINE> for i , x in enumerate ( arr ) : <NEWLINE> <INDENT> xor = xor ^ x <NEWLINE> <DEDENT> for i , x in enumerate ( arr ) : <NEWLINE> <INDENT> temp = xor ^ x <NEWLINE> <NL> ans . append ( temp ) <NEWLINE> <DEDENT> for x in ans : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> k = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( min ( [ S - i + 1 , K + 1 ] ) ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
ch = input ( ) <NEWLINE> for i in range ( len ( ch ) ) : <NEWLINE> <INDENT> num = ord ( ch [ i ] ) <NEWLINE> if num >= 68 : <NEWLINE> <INDENT> num -= 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += 23 <NEWLINE> <DEDENT> ans = chr ( num ) <NEWLINE> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rui = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> rui . append ( rui [ - 1 ] + i ) <NEWLINE> <DEDENT> hantei = 0 <NEWLINE> for i in range ( 0 , len ( rui ) - k ) : <NEWLINE> <INDENT> if hantei <= rui [ i + k ] - rui [ i ] : <NEWLINE> <INDENT> hantei = rui [ i + k ] - rui [ i ] <NEWLINE> l = i <NEWLINE> r = i + k <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> ans += ( a [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <NL> <INDENT> ans = ans * i <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> N = ini ( ) <NEWLINE> A = inl ( ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> big = A [ - 1 ] <NEWLINE> small = A [ 0 ] <NEWLINE> res = [ ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> res . append ( ( small , A [ i ] ) ) <NEWLINE> small -= A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( ( big , A [ i ] ) ) <NEWLINE> big -= A [ i ] <NEWLINE> <DEDENT> <DEDENT> res . append ( ( big , small ) ) <NEWLINE> print ( big - small ) <NEWLINE> for x , y in res : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in sorted ( A ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n , k = l [ 0 ] , l [ 1 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> if k > n : <NEWLINE> <INDENT> k = n <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> h [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( h ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> b = a ** 5 - x <NEWLINE> if b < 0 : <NEWLINE> <INDENT> b = - ( ( - b ) ** ( 1 / 5 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b ** ( 1 / 5 ) <NEWLINE> <DEDENT> c = int ( b ) <NEWLINE> if ( a ** 5 - c ** 5 ) == x : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( c ) ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if S [ n ] == <STRING> : <NEWLINE> <INDENT> R . append ( n ) <NEWLINE> <DEDENT> elif S [ n ] == <STRING> : <NEWLINE> <INDENT> G . append ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> ANS = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ANS -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ k ] != S [ i ] and S [ k ] != S [ j ] and S [ j ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> ans += mods [ current % 2019 ] <NEWLINE> mods [ current % 2019 ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = list ( range ( A , min ( B , A + K ) ) ) + list ( range ( max ( A , B - K + 1 ) , B + 1 ) ) <NEWLINE> L_no_duplication = set ( L ) <NEWLINE> print ( * sorted ( L_no_duplication ) , sep = <STRING> ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = <STRING> <NEWLINE> li = [ ] <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> li . append ( 4 ) <NEWLINE> <DEDENT> if sum ( li ) == Y : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( X ) : <NEWLINE> <INDENT> li [ i ] = 2 <NEWLINE> if sum ( li ) == Y : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
n , m , k = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nokori = k - A [ i ] <NEWLINE> <NL> while ( nokori < B [ j ] and 0 <= j ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> rest = x <NEWLINE> target = sorted ( a ) <NEWLINE> if sum ( target ) < x : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> elif sum ( target ) == x : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> rest -= target [ i ] <NEWLINE> if rest < 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> if rest == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def graph_bfs ( source , target , parent ) : <NEWLINE> <INDENT> visited = [ False ] * vertices <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( source ) <NEWLINE> visited [ source ] = True <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> current = queue . popleft ( ) <NEWLINE> for adj , cp in adj_table [ current ] . items ( ) : <NEWLINE> <INDENT> if not visited [ adj ] and cp > 0 : <NEWLINE> <INDENT> queue . append ( adj ) <NEWLINE> visited [ adj ] = True <NEWLINE> parent [ adj ] = current <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return True if visited [ target ] else False <NEWLINE> <NL> <NL> <DEDENT> def graphFordFulkerson ( source , sink ) : <NEWLINE> <INDENT> parent = [ - 1 ] * vertices <NEWLINE> max_flow = 0 <NEWLINE> <NL> while graph_bfs ( source , sink , parent ) : <NEWLINE> <INDENT> path_flow = float ( <STRING> ) <NEWLINE> <NL> bk_1 = sink <NEWLINE> while bk_1 != source : <NEWLINE> <INDENT> path_flow = min ( path_flow , adj_table [ parent [ bk_1 ] ] [ bk_1 ] ) <NEWLINE> bk_1 = parent [ bk_1 ] <NEWLINE> <NL> <DEDENT> max_flow += path_flow <NEWLINE> <NL> bk_2 = sink <NEWLINE> while bk_2 != source : <NEWLINE> <INDENT> parent_bk_2 = parent [ bk_2 ] <NEWLINE> adj_table [ parent_bk_2 ] . setdefault ( bk_2 , 0 ) <NEWLINE> adj_table [ bk_2 ] . setdefault ( parent_bk_2 , 0 ) <NEWLINE> <NL> <COMMENT> <NL> adj_table [ parent_bk_2 ] [ bk_2 ] -= path_flow <NEWLINE> adj_table [ bk_2 ] [ parent_bk_2 ] += path_flow <NEWLINE> bk_2 = parent [ bk_2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return max_flow <NEWLINE> <NL> <NL> <DEDENT> def generate_adj_table ( v_table ) : <NEWLINE> <INDENT> for each in v_table : <NEWLINE> <INDENT> source , target , cp = map ( int , each ) <NEWLINE> init_adj_table [ source ] [ target ] = cp <NEWLINE> <NL> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> init_adj_table = [ dict ( ) for _ in range ( vertices ) ] <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> ans = graphFordFulkerson ( source = 0 , sink = vertices - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> I = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> T = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> S . append ( i ) <NEWLINE> if i in I : <NEWLINE> <INDENT> S . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( S ) ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> T . append ( S [ 0 ] ) <NEWLINE> <DEDENT> elif abs ( x - S [ j - 1 ] ) > abs ( x - S [ j ] ) : <NEWLINE> <INDENT> T . clear ( ) <NEWLINE> T . append ( S [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( T ) ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for char in s : <NEWLINE> <INDENT> if char != <STRING> : <NEWLINE> <INDENT> ans += char <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> le = len ( ans ) <NEWLINE> ans = ans [ 0 : le - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = N <NEWLINE> t = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if t + a [ i ] < K : <NEWLINE> <INDENT> t += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> good = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> good [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ a - 1 ] = good [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( good . count ( 1 ) ) <NEWLINE>
import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> book = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> book . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> buy = list ( itertools . product ( [ 0 , 1 ] , repeat = n ) ) <NEWLINE> <NL> money = [ ] <NEWLINE> <NL> for i in range ( len ( buy ) ) : <NEWLINE> <INDENT> algo = [ 0 for _ in range ( m ) ] <NEWLINE> money_tmp = 0 <NEWLINE> <COMMENT> <NL> for j in range ( len ( buy [ i ] ) ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> algo [ k ] += book [ j ] [ k + 1 ] * buy [ i ] [ j ] <NEWLINE> <DEDENT> money_tmp += book [ j ] [ 0 ] * buy [ i ] [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> if min ( algo ) >= x : <NEWLINE> <INDENT> money . append ( money_tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( money ) > 0 : <NEWLINE> <INDENT> print ( min ( money ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> DP = [ 0 ] * ( N + 1 ) <NEWLINE> tmp = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if N < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> DP [ 3 ] = 1 <NEWLINE> for i in range ( 4 , N + 1 ) : <NEWLINE> <INDENT> DP [ i ] = ( DP [ i - 1 ] + DP [ i - 3 ] ) % mod <NEWLINE> <DEDENT> print ( DP [ N ] % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> check = 0 <NEWLINE> NEW_x = [ ] <NEWLINE> <NL> def roop ( N , x ) : <NEWLINE> <INDENT> global check <NEWLINE> global NEW_x <NEWLINE> for i in x : <NEWLINE> <INDENT> s = i // 2 <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> check += 1 <NEWLINE> <NL> NEW_x . append ( s ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> NEW_x . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> roop ( N , x ) <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> x = NEW_x <NEWLINE> NEW_x = [ ] <NEWLINE> if check == N : <NEWLINE> <INDENT> check = 0 <NEWLINE> count += 1 <NEWLINE> roop ( N , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> e = S [ 1 : ] . count ( <STRING> ) <NEWLINE> w = S [ : 0 ] . count ( <STRING> ) <NEWLINE> ans = e + w <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> e = e - 1 <NEWLINE> <DEDENT> if ( S [ i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> w = w + 1 <NEWLINE> <DEDENT> ans = min ( ans , e + w ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> L = lcm ( N , M ) <NEWLINE> G = math . gcd ( N , M ) <NEWLINE> for i in range ( G ) : <NEWLINE> <INDENT> if S [ N // G * i ] != T [ M // G * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( L ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> calc = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> calc = ( i * calc ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( calc ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 0 : : 2 ] [ : : - 1 ] + a [ 1 : : 2 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 1 : : 2 ] [ : : - 1 ] + a [ 0 : : 2 ] ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> ls = deque ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ls . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * reversed ( ls ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * ls ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = input ( ) <NEWLINE> ans = 0 <NEWLINE> for item in n : <NEWLINE> <INDENT> ans += int ( item ) <NEWLINE> <DEDENT> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
def getIntList ( strList ) : <NEWLINE> <INDENT> return list ( map ( lambda x : int ( x ) , strList ) ) <NEWLINE> <NL> <DEDENT> N , M , K = getIntList ( input ( ) . split ( <STRING> ) ) <NEWLINE> A = getIntList ( input ( ) . split ( <STRING> ) ) <NEWLINE> B = getIntList ( input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ta = 0 <NEWLINE> tb = 0 <NEWLINE> TA = [ 0 ] <NEWLINE> TB = [ 0 ] <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ta += A [ i ] <NEWLINE> if ta <= K : <NEWLINE> <INDENT> TA . append ( ta ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( B ) ) : <NEWLINE> <INDENT> tb += B [ j ] <NEWLINE> if tb <= K : <NEWLINE> <INDENT> TB . append ( tb ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> Cij = [ 0 ] <NEWLINE> <NL> j = len ( TB ) - 1 <NEWLINE> for i in range ( len ( TA ) ) : <NEWLINE> <INDENT> while TA [ i ] + TB [ j ] > K : <NEWLINE> <INDENT> j += - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j >= 0 : <NEWLINE> <INDENT> Cij . append ( i + j ) <NEWLINE> <DEDENT> <DEDENT> if j == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( Cij ) ) <NEWLINE>
import sys <NEWLINE> import cProfile <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = [ 1 ] <NEWLINE> i = 0 <NEWLINE> aa = 1 <NEWLINE> while True : <NEWLINE> <INDENT> aa = a [ aa - 1 ] <NEWLINE> if aa == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if i > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H_val = [ H [ i ] for i in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = A - 1 , B - 1 <NEWLINE> if H [ A ] > H [ B ] : <NEWLINE> <INDENT> H_val [ B ] = 0 <NEWLINE> <NL> <DEDENT> elif H [ B ] > H [ A ] : <NEWLINE> <INDENT> H_val [ A ] = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> H_val [ A ] , H_val [ B ] = 0 , 0 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H_val [ i ] != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> <NL> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> town_line = [ ] <NEWLINE> town_set = set ( ) <NEWLINE> last_town = None <NEWLINE> <NL> <NL> def search ( town = 0 ) : <NEWLINE> <INDENT> global last_town <NEWLINE> if town not in town_set : <NEWLINE> <INDENT> town_line . append ( town ) <NEWLINE> town_set . add ( town ) <NEWLINE> search ( town = A [ town ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last_town = town <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> search ( 0 ) <NEWLINE> town_loop = town_line [ town_line . index ( last_town ) : ] <NEWLINE> <NL> if K < len ( town_line ) : <NEWLINE> <INDENT> print ( town_line [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = K - len ( town_line ) + 1 <NEWLINE> k = k % len ( town_loop ) <NEWLINE> print ( town_loop [ k - 1 ] + 1 ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> qlist = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> qlist . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> nums = [ i for i in range ( 1 , m + 1 ) ] <NEWLINE> alist = tuple ( combinations_with_replacement ( nums , n ) ) <NEWLINE> <NL> r = 0 <NEWLINE> for al in alist : <NEWLINE> <INDENT> tr = 0 <NEWLINE> for eq in qlist : <NEWLINE> <INDENT> eq0 = eq [ 0 ] - 1 <NEWLINE> eq1 = eq [ 1 ] - 1 <NEWLINE> eq2 = eq [ 2 ] <NEWLINE> eq3 = eq [ 3 ] <NEWLINE> if al [ eq1 ] - al [ eq0 ] == eq2 : <NEWLINE> <INDENT> tr += eq3 <NEWLINE> <DEDENT> <DEDENT> r = max ( r , tr ) <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> def make_divisors ( n ) : <COMMENT> <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return n // lower_divisors [ - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> ans = make_divisors ( N ) <NEWLINE> print ( len ( str ( ans ) ) ) <NEWLINE>
import heapq <NEWLINE> push , pop = heapq . heappush , heapq . heappop <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def modify ( ) : <NEWLINE> <INDENT> heapq . heapify ( a ) <NEWLINE> <NL> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for b , c in bc : <NEWLINE> <INDENT> for _ in range ( b ) : <NEWLINE> <INDENT> p = pop ( a ) <NEWLINE> if p < c : <NEWLINE> <INDENT> push ( a , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> push ( a , p ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> modify ( ) <NEWLINE> print ( sum ( a ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = a // ( b + c ) <NEWLINE> m = a - ( b + c ) * n <NEWLINE> res = n * b <NEWLINE> if m < b : <NEWLINE> <INDENT> res += m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += b <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = min ( B - 1 , N ) <NEWLINE> ans = ( A * i // B ) - A * ( i // B ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c = c ^ a [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = c ^ a [ i ] <NEWLINE> <DEDENT> L = [ str ( a ) for a in ans ] <NEWLINE> L = <STRING> . join ( L ) <NEWLINE> print ( L ) <NEWLINE>
import sys <NEWLINE> from math import ceil , floor , sqrt , sin , cos , pi <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def lcm ( x , y ) : return ( ( x * y ) // gcd ( x , y ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = { } <NEWLINE> y = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = i - a [ i ] <NEWLINE> s = i + a [ i ] <NEWLINE> if t in x : <NEWLINE> <INDENT> x [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ t ] = 1 <NEWLINE> <DEDENT> if s in y : <NEWLINE> <INDENT> y [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in x . keys ( ) : <NEWLINE> <INDENT> if i in y : <NEWLINE> <INDENT> cnt += x [ i ] * y [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import collections <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] -= 1 <NEWLINE> <DEDENT> B = [ 0 ] <NEWLINE> visited = [ 0 ] * N <NEWLINE> visited [ 0 ] = 1 <NEWLINE> Flag = True <NEWLINE> for i in range ( 0 , N * 2 ) : <NEWLINE> <INDENT> next = A [ B [ i ] ] <NEWLINE> if visited [ next ] == 0 : <NEWLINE> <INDENT> B . append ( next ) <NEWLINE> visited [ next ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = B [ B . index ( next ) : ] <NEWLINE> num = B . index ( next ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if K > num : <NEWLINE> <INDENT> Ans = ( K - num ) % len ( C ) <NEWLINE> print ( C [ Ans ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ K ] + 1 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for _ in range ( M ) ] <NEWLINE> ac_count = [ 0 ] * ( N + 1 ) <NEWLINE> wa_count = defaultdict ( lambda : 0 ) <NEWLINE> ac , wa = 0 , 0 <NEWLINE> <NL> for q_no , ans in a : <NEWLINE> <INDENT> q_no = int ( q_no ) <NEWLINE> if ac_count [ q_no ] == 0 : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> ac_count [ q_no ] = 1 <NEWLINE> ac += 1 <NEWLINE> wa += wa_count . get ( q_no , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa_count [ q_no ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> ii = int ( X / D ) <NEWLINE> if K <= ii : <NEWLINE> <INDENT> X -= K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X -= ii * D <NEWLINE> if ( K - ii ) % 2 == 1 : <NEWLINE> <INDENT> X -= D <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( X ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> amari = [ 0 ] * 2019 <NEWLINE> amari [ 0 ] = 1 <NEWLINE> <NL> temp = 0 <NEWLINE> d = 1 <NEWLINE> for char in s : <NEWLINE> <INDENT> temp += int ( char ) * d <NEWLINE> temp %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> amari [ temp ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in amari : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
from sys import stdin , stdout <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> n = stdin . readline ( ) <NEWLINE> <NL> <COMMENT> <NL> arr = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> summation = 1 <NEWLINE> for x in arr : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> summation = 0 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for x in arr : <NEWLINE> <INDENT> summation *= x <NEWLINE> if summation > 1e18 : <NEWLINE> <INDENT> summation = - 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if summation > 1e18 : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( summation ) ; <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> ret = 0 <NEWLINE> <NL> <COMMENT> <NL> i = 0 <NEWLINE> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> ret += i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n_up = 0 <NEWLINE> n_down = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> n_up = 0 <NEWLINE> n_down = 0 <NEWLINE> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> n_up += 1 <NEWLINE> i += 1 <NEWLINE> if i >= len ( S ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> n_down += 1 <NEWLINE> i += 1 <NEWLINE> if i >= len ( S ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if n_up < n_down : <NEWLINE> <INDENT> n_up , n_down = n_down , n_up <NEWLINE> <NL> <DEDENT> ret += ( ( n_up + 1 ) * n_up ) // 2 <NEWLINE> ret += ( n_down * ( n_down - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE>
input ( ) <NEWLINE> A = [ int ( h ) for h in input ( ) . split ( ) ] <NEWLINE> iph_dic = { } <NEWLINE> pair_of_spies = 0 <NEWLINE> <NL> for i , h in enumerate ( A ) : <NEWLINE> <INDENT> if i - h in iph_dic : <NEWLINE> <INDENT> pair_of_spies += iph_dic [ i - h ] <NEWLINE> <DEDENT> if i + h in iph_dic : <NEWLINE> <INDENT> iph_dic [ i + h ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> iph_dic [ i + h ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( pair_of_spies ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> x = 0 <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i + a not in d : <NEWLINE> <INDENT> d [ i + a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + a ] += 1 <NEWLINE> <DEDENT> if i - a in d : <NEWLINE> <INDENT> x += d [ i - a ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> ans [ p ] += x <NEWLINE> <NL> <DEDENT> checked = [ False ] * n <NEWLINE> checked [ 0 ] = True <NEWLINE> <NL> <NL> def function ( now , count ) : <NEWLINE> <INDENT> ans [ now ] += count <NEWLINE> for i in tree [ now ] : <NEWLINE> <INDENT> if checked [ i ] == False : <NEWLINE> <INDENT> checked [ i ] = True <NEWLINE> function ( i , ans [ now ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> function ( 0 , 0 ) <NEWLINE> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import collections <NEWLINE> s = list ( map ( int , input ( ) ) ) <NEWLINE> modpow = [ 1 ] * len ( s ) <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> modpow [ i ] = ( modpow [ i - 1 ] * 10 ) % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> res = [ 0 ] * len ( s ) <NEWLINE> res [ 0 ] = s [ - 1 ] % 2019 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> res [ i ] = ( modpow [ i ] * s [ len ( s ) - 1 - i ] + res [ i - 1 ] ) % 2019 <NEWLINE> <DEDENT> res . append ( 0 ) <NEWLINE> c = collections . Counter ( res ) . most_common ( ) <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> ans += ( c [ i ] [ 1 ] * ( c [ i ] [ 1 ] - 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if i + j + K >= S and i + j <= S : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> poe = deque ( [ ] ) <NEWLINE> S = input ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> poe . append ( S [ i ] ) <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = list ( input ( ) . split ( ) ) <NEWLINE> P . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if len ( P [ i ] ) == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ i ] [ 1 ] = int ( P [ i ] [ 1 ] ) + cnt <NEWLINE> if P [ i ] [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> poe . appendleft ( P [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> poe . append ( P [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> poe = list ( poe ) <NEWLINE> if cnt % 2 == 1 : <NEWLINE> <INDENT> poe = poe [ : : - 1 ] <NEWLINE> <DEDENT> print ( <STRING> . join ( poe ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> S = [ str ( input ( ) ) for _ in range ( num ) ] <NEWLINE> <NL> print ( len ( collections . Counter ( S ) ) ) <NEWLINE>
class union_find : <NEWLINE> <INDENT> def __init__ ( self , node_num ) : <NEWLINE> <INDENT> self . root_array = [ - 1 ] * node_num <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . root_array [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root_array [ x ] = self . root ( self . root_array [ x ] ) <NEWLINE> return self . root_array [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . root_array [ x ] > self . root_array [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . root_array [ x ] += self . root_array [ y ] <NEWLINE> self . root_array [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . root_array [ self . root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( n , m , ab_array ) : <NEWLINE> <INDENT> uf = union_find ( n ) <NEWLINE> for ab in ab_array : <NEWLINE> <INDENT> a , b = ab <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab_array = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ans = solve ( n , m , ab_array ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def pop ( x ) : <COMMENT> <NEWLINE> <INDENT> ret = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> ret += x % 2 <NEWLINE> x //= 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def solve ( x ) : <COMMENT> <NEWLINE> <INDENT> ret = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> pop_c = pop ( x ) <NEWLINE> x %= pop_c <NEWLINE> ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> mod = X . count ( <STRING> ) <COMMENT> <NEWLINE> original_plus = 0 <NEWLINE> original_minus = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ N - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if mod > 1 : <NEWLINE> <INDENT> original_minus += pow ( 2 , i , mod - 1 ) <NEWLINE> <DEDENT> original_plus += pow ( 2 , i , mod + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> tmp = original_plus + pow ( 2 , N - 1 - i , mod + 1 ) <NEWLINE> tmp %= mod + 1 <NEWLINE> print ( solve ( tmp ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if mod == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> tmp = original_minus - pow ( 2 , N - 1 - i , mod - 1 ) <NEWLINE> tmp %= mod - 1 <NEWLINE> print ( solve ( tmp ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = a [ 0 ] <NEWLINE> k = a [ 1 ] <NEWLINE> <NL> c = [ ] <NEWLINE> bfr = 0 <NEWLINE> aft = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> if i != k - 1 : <NEWLINE> <INDENT> if b [ i - k ] < b [ i ] : <NEWLINE> <INDENT> c . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> s_n = <STRING> . join ( c ) <NEWLINE> print ( s_n ) <NEWLINE>
from math import ceil <NEWLINE> n = int ( input ( ) ) <NEWLINE> pf = [ ] <NEWLINE> t = n <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 2 , ceil ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while t % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> t //= i <NEWLINE> <DEDENT> if c > 0 : pf . append ( c ) <NEWLINE> <DEDENT> if t != 1 : pf . append ( 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in pf : <NEWLINE> <INDENT> tmp = i <NEWLINE> j = 1 <NEWLINE> while j <= tmp : <NEWLINE> <INDENT> tmp -= j <NEWLINE> ans += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a_c = Counter ( A ) <NEWLINE> res = [ int ( v * ( v - 1 ) / 2 ) for v in a_c . values ( ) ] <NEWLINE> cnt = sum ( res ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ( cnt - ( a_c [ a ] - 1 ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> from collections import Counter <NEWLINE> <NL> N , * xyf = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> xy = [ ( xyf [ i * 2 ] , xyf [ i * 2 + 1 ] ) for i in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = [ ] <NEWLINE> for a , b in permutations ( xy , 2 ) : <NEWLINE> <INDENT> count . append ( ( b [ 0 ] - a [ 0 ] , b [ 1 ] - a [ 1 ] ) ) <NEWLINE> <DEDENT> c = Counter ( count ) <NEWLINE> print ( N - max ( c . values ( ) ) ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 for i in range ( m ) ] for _ in range ( n ) ] <NEWLINE> c = [ 0 ] * n <NEWLINE> for sankousyo in range ( n ) : <NEWLINE> <INDENT> c_and_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ sankousyo ] = c_and_a [ 0 ] <NEWLINE> a [ sankousyo ] = c_and_a [ 1 : ] <NEWLINE> <NL> <DEDENT> cost = [ 0 ] * ( 2 ** n ) <NEWLINE> INF = 10 ** 12 <NEWLINE> res_cost = INF <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> understandings = [ 0 ] * m <NEWLINE> cost_sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <NL> <INDENT> cost_sum += c [ j ] <NEWLINE> <NL> for k in range ( m ) : <NEWLINE> <INDENT> understandings [ k ] = understandings [ k ] + a [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if understandings [ j ] < x : <NEWLINE> <INDENT> res = False <NEWLINE> <NL> <DEDENT> <DEDENT> if res : <NEWLINE> <INDENT> if res_cost > cost_sum : <NEWLINE> <INDENT> res_cost = cost_sum <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if res_cost == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res_cost ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> stdin = open ( 0 ) <NEWLINE> <NL> N , A , B , C = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> S = stdin . read ( ) . split ( ) <NEWLINE> <NL> ans = [ <STRING> ] * N <NEWLINE> def dfs ( i , a , b , c ) : <NEWLINE> <INDENT> if a < 0 or b < 0 or c < 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if i == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , a + 1 , b - 1 , c ) <NEWLINE> <NL> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , a - 1 , b + 1 , c ) <NEWLINE> <NL> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , a , b + 1 , c - 1 ) <NEWLINE> <NL> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , a , b - 1 , c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , a + 1 , b , c - 1 ) <NEWLINE> <NL> ans [ i ] = <STRING> <NEWLINE> dfs ( i + 1 , a - 1 , b , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , A , B , C ) <NEWLINE> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def RN ( N ) : return [ input ( ) . strip ( ) for i in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = MI ( ) <NEWLINE> p = LI ( ) <NEWLINE> ps = sorted ( p ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ans += ps [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> sum = 0 <NEWLINE> p = 1 <NEWLINE> d = { } <NEWLINE> d [ 0 ] = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum = ( sum + int ( s [ i ] ) * p ) % mod <NEWLINE> if sum in d : <NEWLINE> <INDENT> d [ sum ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ sum ] = 1 <NEWLINE> <DEDENT> p = ( p * 10 ) % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> ans += ( v * ( v - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( 1 , int ( math . sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if i != M // i : <NEWLINE> <INDENT> l . append ( M // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l . sort ( reverse = True ) <NEWLINE> for n in l : <NEWLINE> <INDENT> if n * N <= M : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = input ( ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> def binarySearch ( a , b ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( b ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if b [ mid ] == a : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif b [ mid ] < a : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> elif b [ mid ] > a : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> count += binarySearch ( i , S ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> D = [ a , b , c ] <NEWLINE> <COMMENT> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> Y = [ ] <NEWLINE> <NL> def f ( s , ns ) : <NEWLINE> <INDENT> s0 = ord ( s [ 0 ] ) - 65 <NEWLINE> s1 = ord ( s [ 1 ] ) - 65 <NEWLINE> k = 0 <NEWLINE> if D [ s0 ] == D [ s1 ] : <NEWLINE> <INDENT> ns0 = ord ( ns [ 0 ] ) - 65 <NEWLINE> ns1 = ord ( ns [ 1 ] ) - 65 <NEWLINE> <NL> if s0 == ns0 and s1 == ns1 : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> elif s0 == 3 - ns0 - ns1 : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif D [ s0 ] > D [ s1 ] : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 1 <NEWLINE> <NL> <DEDENT> if k == 0 : <NEWLINE> <INDENT> D [ s0 ] -= 1 <NEWLINE> D [ s1 ] += 1 <NEWLINE> <COMMENT> <NL> Y . append ( s [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ s0 ] += 1 <NEWLINE> D [ s1 ] -= 1 <NEWLINE> <COMMENT> <NL> Y . append ( s [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> g = True <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> ns = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ns = S [ i + 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> f ( s , ns ) <NEWLINE> <COMMENT> <NL> if D [ 0 ] < 0 or D [ 1 ] < 0 or D [ 2 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> g = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if g : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for y in Y : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> array = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> b_1 = [ ] <NEWLINE> b_2 = [ ] <NEWLINE> b_3 = [ ] <NEWLINE> b_4 = [ ] <NEWLINE> zero = <STRING> <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> b_1 . append ( zero . split ( ) ) <NEWLINE> b_2 . append ( zero . split ( ) ) <NEWLINE> b_3 . append ( zero . split ( ) ) <NEWLINE> b_4 . append ( zero . split ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = int ( array [ i ] [ 0 ] ) <NEWLINE> f = int ( array [ i ] [ 1 ] ) <NEWLINE> r = int ( array [ i ] [ 2 ] ) <NEWLINE> v = int ( array [ i ] [ 3 ] ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> b_1 [ f - 1 ] [ r - 1 ] = str ( int ( b_1 [ f - 1 ] [ r - 1 ] ) + v ) <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> b_2 [ f - 1 ] [ r - 1 ] = str ( int ( b_2 [ f - 1 ] [ r - 1 ] ) + v ) <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> b_3 [ f - 1 ] [ r - 1 ] = str ( int ( b_3 [ f - 1 ] [ r - 1 ] ) + v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_4 [ f - 1 ] [ r - 1 ] = str ( int ( b_4 [ f - 1 ] [ r - 1 ] ) + v ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for i2 in range ( 3 ) : <NEWLINE> <INDENT> for i3 in range ( 10 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if i3 == 9 : <NEWLINE> <INDENT> print ( b_1 [ i2 ] [ i3 ] ) <NEWLINE> <DEDENT> elif i3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + b_1 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_1 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> if i3 == 9 : <NEWLINE> <INDENT> print ( b_2 [ i2 ] [ i3 ] ) <NEWLINE> <DEDENT> elif i3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + b_2 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_2 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> if i3 == 9 : <NEWLINE> <INDENT> print ( b_3 [ i2 ] [ i3 ] ) <NEWLINE> <DEDENT> elif i3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + b_3 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_3 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i3 == 9 : <NEWLINE> <INDENT> print ( b_4 [ i2 ] [ i3 ] ) <NEWLINE> <DEDENT> elif i3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + b_4 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_4 [ i2 ] [ i3 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if i == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N = list ( range ( 1 , int ( input ( ) ) + 1 ) ) <NEWLINE> a = np . asarray ( N , dtype = <STRING> ) <NEWLINE> b = a % 3 <NEWLINE> c = a % 5 <NEWLINE> d = np . array ( [ a , b , c ] ) <NEWLINE> d = np . delete ( d , np . where ( d == 0 ) [ 1 ] , axis = 1 ) <NEWLINE> print ( np . sum ( d [ 0 ] ) ) <NEWLINE>
from scipy . sparse . csgraph import breadth_first_tree , breadth_first_order <NEWLINE> from scipy . sparse import csr_matrix , coo_matrix <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> D = [ 1 ] * M <NEWLINE> csr = coo_matrix ( ( D , ( A , B ) ) , ( N , N ) ) . tocsr ( ) <NEWLINE> Tcsr = breadth_first_order ( csr , 0 , False , True ) <NEWLINE> ans = [ ] <NEWLINE> for i in Tcsr [ 1 ] [ 1 : ] + 1 : <NEWLINE> <INDENT> if i == - 9998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ans . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> ans = 0 <NEWLINE> <NL> k = 0 <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> k += a [ i ] % MOD <NEWLINE> s [ i ] = k <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * s [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = ans % MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for k in range ( 60 ) : <NEWLINE> <INDENT> x , y = 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> x += 1 & a >> k <NEWLINE> <DEDENT> tmp = x * ( n - x ) % mod <NEWLINE> tmp *= pow ( 2 , k , mod ) <NEWLINE> ans += tmp <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> if arr [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr = arr [ : : - 1 ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> data . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = set ( data ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> data = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> H = data [ 0 ] <NEWLINE> W = data [ 1 ] <NEWLINE> assert 0 <= H <= 300 and 0 <= W <= 300 , <STRING> <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> result = [ 0 ] * n <NEWLINE> <COMMENT> <NL> <NL> for i in numlist : <NEWLINE> <INDENT> result [ i - 1 ] = result [ i - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for j in range ( len ( result ) ) : <NEWLINE> <INDENT> print ( result [ j ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> add = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> B = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> add += math . gcd ( B , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( add ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ a - 1 for a in A ] <COMMENT> <NEWLINE> <NL> cnt = 0 <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> appeared = [ False ] * N <NEWLINE> appeared [ 0 ] = True <NEWLINE> arrive = [ None ] * ( N + 1 ) <NEWLINE> arrive [ 0 ] = 0 <NEWLINE> roop_s = None <NEWLINE> n_roop = None <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> i = A [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> if cnt == K : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <NL> <DEDENT> if appeared [ i ] : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> if arrive [ j ] == i : <NEWLINE> <INDENT> roop_s = j <NEWLINE> n_roop = ( k + 1 ) - roop_s <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> appeared [ i ] = True <NEWLINE> arrive [ k + 1 ] = i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> rest = ( K - roop_s ) % n_roop <NEWLINE> <COMMENT> <NL> i = arrive [ roop_s ] <NEWLINE> for _ in range ( rest ) : <NEWLINE> <INDENT> i = A [ i ] <NEWLINE> <NL> <DEDENT> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> color = [ i == <STRING> for i in c ] <NEWLINE> ans = 0 <NEWLINE> checked = 0 <NEWLINE> for right in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if color [ right ] : <NEWLINE> <INDENT> for left in range ( checked , right ) : <NEWLINE> <INDENT> if not color [ left ] : <NEWLINE> <INDENT> color [ right ] , color [ left ] = color [ left ] , color [ right ] <NEWLINE> ans += 1 <NEWLINE> checked = left <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> checked = left <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> l [ a - 1 ] = 0 <NEWLINE> <DEDENT> if h [ b - 1 ] <= h [ a - 1 ] : <NEWLINE> <INDENT> l [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> W = [ 0 ] * N <NEWLINE> W [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> W [ i ] += W [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( W [ N - 1 ] - W [ i ] ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if N == K : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = ans * a % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> minus = [ ] <NEWLINE> plus = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> minus . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( minus ) == N : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * A [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> minus . sort ( reverse = True ) <NEWLINE> plus . sort ( ) <NEWLINE> <NL> if K % 2 : <NEWLINE> <INDENT> ans *= plus . pop ( ) <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> <NL> while len ( minus ) > 1 : <NEWLINE> <INDENT> a = minus . pop ( ) <NEWLINE> b = minus . pop ( ) <NEWLINE> B . append ( a * b ) <NEWLINE> <NL> <DEDENT> while len ( plus ) > 1 : <NEWLINE> <INDENT> a = plus . pop ( ) <NEWLINE> b = plus . pop ( ) <NEWLINE> B . append ( a * b ) <NEWLINE> <NL> <DEDENT> B . sort ( ) <NEWLINE> <NL> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans = ans * B . pop ( ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> pos . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <COMMENT> <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( pos ) > 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> if not flag : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> h = [ abs ( x ) for x in A ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ans *= heapq . heappop ( h ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hpos = [ - x for x in pos ] <NEWLINE> heapq . heapify ( hpos ) <NEWLINE> hneg = neg [ : ] <NEWLINE> heapq . heapify ( hneg ) <NEWLINE> if K % 2 == 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans *= - heapq . heappop ( hpos ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> pairs = [ ] <NEWLINE> while len ( hpos ) >= 2 : <NEWLINE> <INDENT> x = - heapq . heappop ( hpos ) <NEWLINE> x *= - heapq . heappop ( hpos ) <NEWLINE> heapq . heappush ( pairs , - x ) <NEWLINE> <DEDENT> while len ( hneg ) >= 2 : <NEWLINE> <INDENT> x = heapq . heappop ( hneg ) <NEWLINE> x *= heapq . heappop ( hneg ) <NEWLINE> heapq . heappush ( pairs , - x ) <NEWLINE> <DEDENT> if len ( pairs ) : <NEWLINE> <INDENT> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= - heapq . heappop ( pairs ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pa , pb = [ 0 ] * ( n + 1 ) , [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pa [ i + 1 ] = pa [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> pb [ i + 1 ] = pb [ i ] + b [ i ] <NEWLINE> <DEDENT> mx = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if pa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> v = k - pa [ i ] <NEWLINE> while pb [ j ] > v : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> mx = max ( mx , i + j ) <NEWLINE> <DEDENT> print ( mx ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = [ - a for a in A ] <NEWLINE> import heapq <NEWLINE> heapq . heapify ( A ) <NEWLINE> import bisect <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <NEWLINE> new = a / 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> heapq . heappush ( A , new ) <NEWLINE> <DEDENT> import numpy as np <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> print ( - A . sum ( ) ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> p = 2019 <NEWLINE> ans = 0 <NEWLINE> <NL> num_rem = [ 0 ] * p <NEWLINE> t = 1 <NEWLINE> mod = 0 <NEWLINE> num_rem [ mod ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mod = ( mod + int ( s [ - i - 1 ] ) * t ) % p <NEWLINE> num_rem [ mod ] += 1 <NEWLINE> t = ( 10 * t ) % p <NEWLINE> <DEDENT> for m in num_rem : <NEWLINE> <INDENT> ans += ( m * ( m - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memory = [ [ - 1 for i in range ( max ( m ) + 1 ) ] for j in range ( n ) ] <NEWLINE> <NL> def f ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif memory [ i ] [ m ] != - 1 : <NEWLINE> <INDENT> return memory [ i ] [ m ] <NEWLINE> <DEDENT> elif m - a [ i ] >= 0 : <NEWLINE> <INDENT> res0 = f ( i + 1 , m ) <NEWLINE> res1 = f ( i + 1 , m - a [ i ] ) <NEWLINE> if res0 or res1 : <NEWLINE> <INDENT> memory [ i ] [ m ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memory [ i ] [ m ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = f ( i + 1 , m ) <NEWLINE> memory [ i ] [ m ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> <DEDENT> for k in m : <NEWLINE> <INDENT> print ( <STRING> if f ( 0 , k ) else <STRING> ) <NEWLINE> <DEDENT>
int ( input ( ) ) <NEWLINE> A = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= int ( i ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> N = k ( ) <NEWLINE> D = l ( ) <NEWLINE> M = k ( ) <NEWLINE> T = l ( ) <NEWLINE> <NL> d = Counter ( D ) <NEWLINE> t = Counter ( T ) <NEWLINE> <NL> for i in t : <NEWLINE> <INDENT> if t [ i ] > d [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> nyuryoku = [ int ( i ) - 1 for i in sys . stdin ] <NEWLINE> <NL> N = nyuryoku [ 0 ] + 1 <NEWLINE> a_list = nyuryoku [ 1 : ] <NEWLINE> <NL> <NL> cnt_push = 0 <NEWLINE> button_list = [ False ] * N <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> if button_list [ i ] == False : <NEWLINE> <INDENT> button_list [ i ] = True <NEWLINE> cnt_push += 1 <NEWLINE> if a_list [ i ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = a_list [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_push = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt_push ) <NEWLINE> <NL> <STRING> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> class TreeNode : <NEWLINE> <INDENT> def __init__ ( self , val ) : <NEWLINE> <INDENT> self . val = val <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def reconstruction ( _pre_order , _in_order ) : <NEWLINE> <COMMENT> <NL> <INDENT> if not _pre_order : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> root = TreeNode ( _pre_order [ 0 ] ) <NEWLINE> root_position = _in_order . index ( _pre_order [ 0 ] ) <NEWLINE> root . left = reconstruction ( _pre_order = _pre_order [ 1 : 1 + root_position ] , _in_order = _in_order [ : root_position ] ) <NEWLINE> root . right = reconstruction ( _pre_order = _pre_order [ root_position + 1 : ] , _in_order = _in_order [ root_position + 1 : ] ) <NEWLINE> post_order . append ( root . val ) <NEWLINE> return root . val <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> pre_order = list ( map ( int , _input [ 1 ] . split ( ) ) ) <NEWLINE> in_order = list ( map ( int , _input [ 2 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> post_order = [ ] <NEWLINE> reconstruction ( _pre_order = pre_order , _in_order = in_order ) <NEWLINE> print ( * post_order ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> name_count = { <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 , } <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> name = input ( ) <NEWLINE> <NL> if name [ 0 ] in name_count : <NEWLINE> <INDENT> name_count [ name [ 0 ] ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> up = 1 <NEWLINE> down = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> up *= n - i <NEWLINE> down *= i + 1 <NEWLINE> <DEDENT> return up // down <NEWLINE> <NL> <NL> <DEDENT> all_sum = sum ( name_count . values ( ) ) <NEWLINE> total = comb ( all_sum , 3 ) <NEWLINE> <NL> for i in name_count . values ( ) : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> total -= comb ( i , 2 ) * ( all_sum - i ) <NEWLINE> <NL> <DEDENT> if i >= 3 : <NEWLINE> <INDENT> total -= comb ( i , 3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def Main ( ) : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> times = 10 ** 100 <NEWLINE> ans = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> save = [ i ] <NEWLINE> while s [ i + 1 ] != <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> save . append ( i ) <NEWLINE> <DEDENT> flg = save . pop ( ) <NEWLINE> ans [ flg ] += 1 <NEWLINE> for j in range ( len ( save ) ) : <NEWLINE> <INDENT> tmp = save . pop ( ) <NEWLINE> ans [ flg + abs ( flg - tmp ) % 2 ] += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> i = n - 1 <NEWLINE> while 0 <= i : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> i -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> save = [ i ] <NEWLINE> while s [ i - 1 ] != <STRING> : <NEWLINE> <INDENT> i -= 1 <NEWLINE> save . append ( i ) <NEWLINE> <DEDENT> flg = save . pop ( ) <NEWLINE> ans [ flg ] += 1 <NEWLINE> for j in range ( len ( save ) ) : <NEWLINE> <INDENT> tmp = save . pop ( ) <NEWLINE> ans [ flg - abs ( flg - tmp ) % 2 ] += 1 <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> lst [ a - 1 ] += 1 <NEWLINE> <DEDENT> for l in lst : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 10 ** 4 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i + 1 , 101 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , min ( j + 1 , 101 ) ) : <NEWLINE> <INDENT> if ( i + j + k ) ** 2 - i * j - j * k - k * i <= 10 ** 4 : <NEWLINE> <INDENT> p = ( i + j + k ) ** 2 - i * j - j * k - k * i <NEWLINE> if i == j == k : <NEWLINE> <INDENT> a [ p - 1 ] += 1 <NEWLINE> <DEDENT> elif i != j and j != k : <NEWLINE> <INDENT> a [ p - 1 ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ p - 1 ] += 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for q in a [ : n ] : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( h ) : m . append ( list ( input ( ) ) ) <NEWLINE> black = 0 <NEWLINE> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if m [ i ] [ j ] == <STRING> : black += 1 <NEWLINE> <DEDENT> <DEDENT> white = h * w - black <NEWLINE> node = [ [ 0 , 0 , 1 ] ] <NEWLINE> dx , dy = [ - 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , - 1 ] <NEWLINE> while node : <NEWLINE> <INDENT> temp = node . pop ( 0 ) <NEWLINE> if temp [ 0 ] == h - 1 and temp [ 1 ] == w - 1 : <NEWLINE> <INDENT> print ( h * w - black - temp [ 2 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m [ temp [ 0 ] ] [ temp [ 1 ] ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if 0 <= temp [ 0 ] + dx [ i ] < h and 0 <= temp [ 1 ] + dy [ i ] < w : <NEWLINE> <INDENT> if m [ temp [ 0 ] + dx [ i ] ] [ temp [ 1 ] + dy [ i ] ] == <STRING> : <NEWLINE> <INDENT> node . append ( [ temp [ 0 ] + dx [ i ] , temp [ 1 ] + dy [ i ] , temp [ 2 ] + 1 ] ) <NEWLINE> m [ temp [ 0 ] + dx [ i ] ] [ temp [ 1 ] + dy [ i ] ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> MOD = sum ( map ( lambda x : x == <STRING> , X ) ) <NEWLINE> lowNumber = [ ] <NEWLINE> for i in range ( MOD + 1 ) : <NEWLINE> <INDENT> anscur = i <NEWLINE> cnt = 1 <NEWLINE> while anscur != 0 : <NEWLINE> <INDENT> oneCount = bin ( anscur ) . count ( <STRING> ) <NEWLINE> anscur %= oneCount <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> lowNumber . append ( cnt ) <NEWLINE> <DEDENT> if MOD == 0 : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( N - 1 ) ) <NEWLINE> return 0 <NEWLINE> <DEDENT> if MOD == 1 and X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> * ( N - 1 ) + <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> if MOD == 1 and X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif i != N - 1 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> if i != N - 1 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <DEDENT> MODP1 = MOD + 1 <NEWLINE> MODM1 = MOD - 1 <NEWLINE> POWEROFTWOP1 = [ 0 ] * 200001 <NEWLINE> POWEROFTWOM1 = [ 0 ] * 200001 <NEWLINE> POWEROFTWOP1 [ 0 ] = 1 <NEWLINE> POWEROFTWOM1 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> POWEROFTWOP1 [ i ] = ( POWEROFTWOP1 [ i - 1 ] * 2 ) % MODP1 <NEWLINE> POWEROFTWOM1 [ i ] = ( POWEROFTWOM1 [ i - 1 ] * 2 ) % MODM1 <NEWLINE> <DEDENT> xMODP1 = 0 <NEWLINE> xMODM1 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> xMODP1 += POWEROFTWOP1 [ N - i - 1 ] <NEWLINE> xMODP1 %= MODP1 <NEWLINE> xMODM1 += POWEROFTWOM1 [ N - i - 1 ] <NEWLINE> xMODM1 %= MODM1 <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> anscur = xMODP1 <NEWLINE> anscur += POWEROFTWOP1 [ N - i - 1 ] <NEWLINE> anscur %= MODP1 <NEWLINE> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> anscur = xMODM1 <NEWLINE> anscur -= POWEROFTWOM1 [ N - i - 1 ] <NEWLINE> anscur %= MODM1 <NEWLINE> <DEDENT> ans += str ( lowNumber [ anscur ] ) <NEWLINE> if i != N - 1 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> az = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> <NL> N = N - 1 <NEWLINE> <NL> tmp1 = 0 <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> tmp1 += 26 ** i <NEWLINE> if tmp1 > N : <NEWLINE> <INDENT> num = i <NEWLINE> tmp1 -= 26 ** i <NEWLINE> N -= tmp1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = [ 0 for _ in range ( num ) ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> tmp [ i ] = N % 26 <NEWLINE> N = N // 26 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> ans = az [ tmp [ i ] ] + ans <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 1 <NEWLINE> flag = 1 <NEWLINE> limit = 1000000000000000000 <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for num in nums : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> sum = 0 <NEWLINE> break ; <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> sum *= num <NEWLINE> <DEDENT> if sum > limit or sum == - 1 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> sum = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def threeDivCheck ( x ) : <NEWLINE> <INDENT> if x % 3 == 0 : return x <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> def threeIncludeCheck ( x ) : <NEWLINE> <INDENT> y = x <NEWLINE> while y != 0 : <NEWLINE> <INDENT> if y % 10 == 3 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> y = int ( y / 10 ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> p = threeDivCheck ( i ) <NEWLINE> if p : <NEWLINE> <INDENT> print ( <STRING> . format ( p ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = threeIncludeCheck ( i ) <NEWLINE> if p : <NEWLINE> <INDENT> print ( <STRING> . format ( p ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
H = int ( input ( ) ) + 1 <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def h ( i ) : <NEWLINE> <INDENT> l = 2 * i ; r = l + 1 <NEWLINE> g = l if l < H and A [ i ] < A [ l ] else i <NEWLINE> if r < H and A [ g ] < A [ r ] : g = r <NEWLINE> if g > i : A [ i ] , A [ g ] = A [ g ] , A [ i ] ; h ( g ) <NEWLINE> <DEDENT> for i in range ( H // 2 , 0 , - 1 ) : h ( i ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , A [ 1 : ] ) ) ) <NEWLINE>
class Node ( ) : <NEWLINE> <INDENT> right = None <NEWLINE> left = None <NEWLINE> def __init__ ( self , key , parent ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , v ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if v < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z = Node ( v , y ) <NEWLINE> <NL> if y == None : <COMMENT> <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif v < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def printPreorder ( self , parent ) : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> + str ( parent . key ) , end = <STRING> ) <NEWLINE> if parent . left != None : <NEWLINE> <INDENT> self . printPreorder ( parent . left ) <NEWLINE> <DEDENT> if parent . right != None : <NEWLINE> <INDENT> self . printPreorder ( parent . right ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def printInorder ( self , parent ) : <COMMENT> <NEWLINE> <INDENT> if parent . left != None : <NEWLINE> <INDENT> self . printInorder ( parent . left ) <NEWLINE> <DEDENT> print ( <STRING> + str ( parent . key ) , end = <STRING> ) <NEWLINE> if parent . right != None : <NEWLINE> <INDENT> self . printInorder ( parent . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> T = Tree ( ) <NEWLINE> Orders = [ ] <NEWLINE> tmp = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = [ input ( ) . split ( ) ] <NEWLINE> Orders . extend ( tmp ) <NEWLINE> <NL> <DEDENT> for order in Orders : <NEWLINE> <INDENT> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . insert ( int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . printInorder ( T . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> T . printPreorder ( T . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> lst [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * lst ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = False <NEWLINE> count = 0 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> m = min ( m , P [ i ] ) <NEWLINE> if m >= P [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
def main ( ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> E = max ( C , D ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( A - 1 , E ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> if cnt >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if C < D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( B - 2 , D + 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> if cnt >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( 0 , H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> * ( W - 2 ) , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> g = defaultdict ( set ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . add ( b ) <NEWLINE> g [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( u , visited : set ) : <NEWLINE> <INDENT> stack = [ u ] <NEWLINE> visited . add ( u ) <NEWLINE> while stack : <NEWLINE> <INDENT> u = stack . pop ( ) <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> if v not in visited : <NEWLINE> <INDENT> stack . append ( v ) <NEWLINE> visited . add ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count = dict ( ) <NEWLINE> for u in range ( N ) : <NEWLINE> <INDENT> if u in count : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited = set ( ) <NEWLINE> dfs ( u , visited ) <NEWLINE> <COMMENT> <NL> count [ u ] = len ( visited ) <NEWLINE> for v in visited : <NEWLINE> <INDENT> count [ v ] = len ( visited ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( count . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T [ i + 1 ] = T [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( T [ R - 1 ] - T [ L - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = ns ( ) <NEWLINE> e = [ [ ] for _ in range ( n ) ] <NEWLINE> root = [ True for _ in range ( n ) ] <NEWLINE> prnt_cnt = [ 0 for _ in range ( n ) ] <NEWLINE> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 + m ) : <NEWLINE> <INDENT> a , b = ns ( ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> e [ a ] . append ( b ) <NEWLINE> root [ b ] = False <NEWLINE> prnt_cnt [ b ] += 1 <NEWLINE> <NL> <DEDENT> root_idx = root . index ( True ) <NEWLINE> <NL> que = collections . deque ( [ root_idx ] ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> q = que . popleft ( ) <NEWLINE> <NL> for ei in e [ q ] : <NEWLINE> <INDENT> ans [ ei ] = q <NEWLINE> prnt_cnt [ ei ] -= 1 <NEWLINE> if prnt_cnt [ ei ] == 0 : <NEWLINE> <INDENT> que . append ( ei ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ansi in ans : <NEWLINE> <INDENT> print ( ansi + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
MAXN = 2 ** 15 <NEWLINE> MAXRT = int ( MAXN ** 0.5 ) <NEWLINE> MAXTERM = 4 <NEWLINE> <NL> dp = [ [ 0 for n in range ( MAXN + 1 ) ] for t in range ( MAXTERM + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for r in range ( MAXRT , 0 , - 1 ) : <NEWLINE> <INDENT> for t in range ( MAXTERM ) : <NEWLINE> <INDENT> for n in range ( MAXN + 1 - r * r ) : <NEWLINE> <INDENT> if dp [ t ] [ n ] == 0 : continue <NEWLINE> dp [ t + 1 ] [ n + r * r ] += dp [ t ] [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> print ( sum ( map ( lambda x : x [ N ] , dp ) ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> tel = set ( ) <NEWLINE> route = [ ] <NEWLINE> <COMMENT> <NL> town = 1 <NEWLINE> route . append ( town ) <NEWLINE> tel . add ( town ) <NEWLINE> time_loop = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> town = a [ town - 1 ] <NEWLINE> if town in tel : <NEWLINE> <INDENT> time_loop += 1 <NEWLINE> break <NEWLINE> <DEDENT> tel . add ( town ) <NEWLINE> route . append ( town ) <NEWLINE> <COMMENT> <NL> time_loop += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> start = route . index ( town ) <NEWLINE> if time_loop != start : <NEWLINE> <INDENT> k = ( k - start ) % ( time_loop - start ) <NEWLINE> print ( route [ k + start ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( town ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> data = [ 0 ] * 10 ** 5 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) and is_prime ( ( i + 1 ) // 2 ) : <NEWLINE> <INDENT> data [ i - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cumulative_sum = [ 0 ] * 10 ** 5 <NEWLINE> cumulative_sum [ 0 ] = data [ 0 ] <NEWLINE> for i in range ( 10 ** 5 - 1 ) : <NEWLINE> <INDENT> cumulative_sum [ i + 1 ] += cumulative_sum [ i ] + data [ i + 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> cumulative_sum = [ 0 ] + cumulative_sum <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cumulative_sum [ r ] - cumulative_sum [ l - 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT>
from collections import Counter <NEWLINE> from sys import exit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> l = list ( Counter ( s ) . values ( ) ) <NEWLINE> if len ( l ) < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = l [ 0 ] * l [ 1 ] * l [ 2 ] <NEWLINE> <NL> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j + i * 2 > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = j <NEWLINE> b = j + i <NEWLINE> c = b + i <NEWLINE> if s [ a ] != s [ b ] and s [ b ] != s [ c ] and s [ c ] != s [ a ] : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<NL> from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> for ai in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for bi in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ab = gcd ( ai , bi ) <NEWLINE> for ci in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a += gcd ( gcd_ab , ci ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = collections . Counter ( a ) <NEWLINE> l = list ( l . values ( ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> print ( sum ( l [ k : ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> left = set ( ) <NEWLINE> right = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left . add ( l ) <NEWLINE> right . add ( r ) <NEWLINE> <DEDENT> mini = max ( left ) <NEWLINE> maxi = min ( right ) <NEWLINE> print ( len ( range ( mini , maxi + 1 ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> asum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = ( p [ i ] + 1 ) / 2 + asum <NEWLINE> asum = a [ i ] <NEWLINE> <DEDENT> ans = a [ k - 1 ] <NEWLINE> for f in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( [ ans , a [ f + k - 1 ] - a [ f - 1 ] ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> depth_list = [ 0 ] * len ( s ) <NEWLINE> max_depth = [ 0 ] * len ( s ) <NEWLINE> d = 0 <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> depth_list [ i ] = d <NEWLINE> <NL> <DEDENT> m_d = d <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> max_depth [ i ] = m_d <NEWLINE> m_d = max ( m_d , d ) <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> m_d = 0 <NEWLINE> water = 0 <NEWLINE> puddles = [ 0 ] <NEWLINE> for i , n in enumerate ( depth_list ) : <NEWLINE> <INDENT> up = min ( m_d , max_depth [ i ] ) <NEWLINE> if d < up and d != n or d == up and d > n : <NEWLINE> <INDENT> water += 0.5 <NEWLINE> <DEDENT> if d < n : <NEWLINE> <INDENT> d = n <NEWLINE> <DEDENT> water += max ( 0 , up - d ) <NEWLINE> d = n <NEWLINE> m_d = max ( m_d , d ) <NEWLINE> <NL> if d == up and sum ( puddles ) < int ( water ) : <NEWLINE> <INDENT> m_d = d <NEWLINE> puddles . append ( int ( water - sum ( puddles ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( water ) ) <NEWLINE> print ( str ( len ( puddles ) - 1 ) + ( <STRING> if len ( puddles ) > 1 else <STRING> ) + <STRING> . join ( [ str ( n ) for n in puddles [ 1 : ] ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = n % k <NEWLINE> print ( min ( c , k - c ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> P = 2019 <NEWLINE> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> now = ( now + int ( s ) * _10 ) % P <NEWLINE> _10 *= 10 <NEWLINE> _10 %= P <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a [ i ] . append ( 0 ) <NEWLINE> aic = 0 <NEWLINE> for k in range ( c ) : <NEWLINE> <INDENT> aic = aic + a [ i ] [ k ] <NEWLINE> <DEDENT> a [ i ] [ c ] = aic <NEWLINE> <DEDENT> a . append ( [ 0 for i in range ( c + 1 ) ] ) <NEWLINE> for k in range ( c ) : <NEWLINE> <INDENT> ark = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> ark = ark + a [ i ] [ k ] <NEWLINE> <DEDENT> a [ r ] [ k ] = ark <NEWLINE> <DEDENT> arc = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> arc = arc + a [ i ] [ c ] <NEWLINE> <DEDENT> a [ r ] [ c ] = arc <NEWLINE> <NL> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if k == c : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X_2 = input ( ) <NEWLINE> X_10 = int ( X_2 , 2 ) <NEWLINE> <NL> y = X_2 . count ( <STRING> ) <NEWLINE> <NL> a = X_10 % ( y + 1 ) <NEWLINE> if y == 1 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = X_10 % ( y - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X_2 [ i ] == <STRING> and y == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> elif X_2 [ i ] == <STRING> : <NEWLINE> <INDENT> x = ( b - pow ( 2 , N - 1 - i , y - 1 ) ) % ( y - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( a + pow ( 2 , N - 1 - i , y + 1 ) ) % ( y + 1 ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x %= bin ( x ) [ 2 : ] . count ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from bisect import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = int ) <NEWLINE> B = np . array ( input ( ) . split ( ) , dtype = int ) <NEWLINE> <NL> AA = np . insert ( A , 0 , 0 ) <NEWLINE> BB = np . insert ( B , 0 , 0 ) <NEWLINE> AAA = np . cumsum ( AA ) <NEWLINE> BBB = np . cumsum ( BB ) <NEWLINE> max_books = 0 <NEWLINE> for a in enumerate ( AAA ) : <NEWLINE> <INDENT> if a [ 1 ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> books = a [ 0 ] <NEWLINE> ind = bisect ( BBB , K - a [ 1 ] ) <NEWLINE> books += ( ind - 1 ) <NEWLINE> max_books = max ( books , max_books ) <NEWLINE> <DEDENT> print ( max_books ) <NEWLINE> <NL> <NL>
import math <NEWLINE> isPrime = [ 1 for _ in range ( 10002 ) ] <NEWLINE> isPrime [ : 2 ] = [ 0 , 0 ] <NEWLINE> for i in range ( 2 , 101 ) : <NEWLINE> <INDENT> for j in range ( i * i , 10001 , i ) : <NEWLINE> <INDENT> isPrime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> for i in range ( 10001 ) : <NEWLINE> <INDENT> if isPrime [ i ] == 1 : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( len ( prime ) + 1 ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( i , len ( prime ) ) : <NEWLINE> <INDENT> sum += prime [ j ] <NEWLINE> if sum == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> if sum > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> a = V * T + A <NEWLINE> b = W * T + B <NEWLINE> <NL> if V > W : <NEWLINE> <INDENT> if abs ( A - B ) / ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> d = [ <STRING> * 5010 ] * 5 <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i , i + k ) : <NEWLINE> <INDENT> x = s [ i : j + 1 ] <NEWLINE> if x in d or x == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l = 0 <NEWLINE> while l < 5 and x > d [ l ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if l < 5 : <NEWLINE> <INDENT> d = d [ 0 : l ] + [ x ] + d [ l : ] <NEWLINE> d = d [ 0 : 5 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( d [ k - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> re = 1 <NEWLINE> if int ( 0 in A ) == 1 : <NEWLINE> <INDENT> re = 0 <NEWLINE> N = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> re *= A [ i ] <NEWLINE> if re > 10 ** 18 : <NEWLINE> <INDENT> re = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( re ) <NEWLINE>
x = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> print ( <STRING> % ( x * x * x ) ) <NEWLINE>
T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> coler = input ( ) . split ( ) <NEWLINE> groups = [ [ ] , [ ] , [ ] ] <NEWLINE> for i , c in enumerate ( coler ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> groups [ 0 ] . append ( num [ i ] ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> groups [ 1 ] . append ( num [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> groups [ 2 ] . append ( num [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for group in groups : <NEWLINE> <INDENT> while len ( group ) != 0 and len ( group ) % 3 == 0 : <NEWLINE> <INDENT> tmp = group [ : ] <NEWLINE> group . sort ( ) <NEWLINE> i = group [ 0 ] <NEWLINE> if group . count ( i ) >= 3 : <NEWLINE> <INDENT> for _ in range ( 3 ) : <NEWLINE> <INDENT> group . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> if i + 1 in group and i + 2 in group : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> group . remove ( i + j ) <NEWLINE> <DEDENT> <DEDENT> if tmp == group : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( groups [ 0 ] ) == len ( groups [ 1 ] ) == len ( groups [ 2 ] ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
X , N = input ( ) . split ( ) <NEWLINE> X = int ( X ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P = input ( ) . split ( ) <NEWLINE> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> P [ i ] = int ( P [ i ] ) <NEWLINE> <NL> <DEDENT> if X not in P : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> abs_num_p = X + 1 <NEWLINE> abs_num_n = X - 1 <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if abs_num_p in P : <NEWLINE> <INDENT> flag_p = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag_p = False <NEWLINE> <NL> <DEDENT> if abs_num_n in P : <NEWLINE> <INDENT> flag_n = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag_n = False <NEWLINE> <DEDENT> if ( flag_p == True and flag_n == True ) : <NEWLINE> <INDENT> abs_num_p += 1 <NEWLINE> abs_num_n -= 1 <NEWLINE> continue ; <NEWLINE> <DEDENT> elif ( flag_p == True and flag_n == False ) : <NEWLINE> <INDENT> print ( abs_num_n ) <NEWLINE> break ; <NEWLINE> <DEDENT> elif ( flag_p == False and flag_n == True ) : <NEWLINE> <INDENT> print ( abs_num_p ) <NEWLINE> break ; <NEWLINE> <DEDENT> elif ( flag_p == False and flag_n == False ) : <NEWLINE> <INDENT> print ( abs_num_n ) <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 2 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 2 : ] <NEWLINE> i = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> elif s [ : 1 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 1 : ] <NEWLINE> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif i == 3 : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> elif s [ : 3 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 3 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> i = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = len ( T ) <NEWLINE> for start in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> dif = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] != S [ start + i ] : <NEWLINE> <INDENT> dif += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , dif ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ar = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> p = 1 <NEWLINE> <NL> go = 0 <NEWLINE> <NL> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <NL> <NL> <NL> <NL> <NL> <INDENT> ar [ p ] = i - 1 <NEWLINE> p = a [ p - 1 ] <NEWLINE> <NL> if ar [ p ] > 0 : <NEWLINE> <INDENT> j = ar [ p ] <NEWLINE> amari = ( k - i ) % ( i - j ) <NEWLINE> <NL> go = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if go == 1 : <NEWLINE> <INDENT> p = ar . index ( j + amari ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( p ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> p = math . gcd ( p , i - x ) <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> [ H , W ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ 0 ] + sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) <NEWLINE> s = list ( ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in p [ i : ] : <NEWLINE> <INDENT> if p [ i ] + j > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += [ p [ i ] + j ] <NEWLINE> <DEDENT> <DEDENT> s . sort ( ) <NEWLINE> print ( max ( i + s [ bisect . bisect_right ( s , m - i ) - 1 ] for i in s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( [ a , k ] ) - max ( [ 0 , k - a - b ] ) ) <NEWLINE>
<NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> class UnionFindTree : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . table = [ - 1 for _ in range ( size ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if self . table [ x ] < 0 : <NEWLINE> <COMMENT> <NL> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . table [ x ] = self . find ( self . table [ x ] ) <NEWLINE> return self . table [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s1 = self . find ( x ) <NEWLINE> s2 = self . find ( y ) <NEWLINE> if s1 != s2 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if self . table [ s2 ] <= self . table [ s1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> self . table [ s1 ] += self . table [ s2 ] <NEWLINE> self . table [ s2 ] = s1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . table [ s2 ] += self . table [ s1 ] <NEWLINE> self . table [ s1 ] = s2 <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def groupCount ( self ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( len ( self . table ) ) : <NEWLINE> <INDENT> if self . table [ i ] < 0 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> UF = UnionFindTree ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . union ( A - 1 , B - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( UF . groupCount ( ) - 1 ) <NEWLINE> <NL>
def lcs ( s1 , s2 ) : <NEWLINE> <INDENT> dp = [ ] <NEWLINE> for s2_k in s2 : <NEWLINE> <INDENT> bgn_idx = 0 <NEWLINE> for i , cur_idx in enumerate ( dp ) : <NEWLINE> <INDENT> chr_idx = s1 . find ( s2_k , bgn_idx ) + 1 <NEWLINE> if not chr_idx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i ] = min ( cur_idx , chr_idx ) <NEWLINE> bgn_idx = cur_idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> chr_idx = s1 . find ( s2_k , bgn_idx ) + 1 <NEWLINE> if chr_idx : <NEWLINE> <INDENT> dp . append ( chr_idx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return len ( dp ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> print ( lcs ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> r , g , b = S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def compute_prefix_function ( p ) : <NEWLINE> <INDENT> m = len ( p ) <NEWLINE> pi = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> pi [ 1 ] = 0 <NEWLINE> k = 0 <NEWLINE> for q in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> while k > 0 and p [ k ] != p [ q - 1 ] : <NEWLINE> <INDENT> k = pi [ k ] <NEWLINE> <DEDENT> if p [ k ] == p [ q - 1 ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> pi [ q ] = k <NEWLINE> <DEDENT> return pi <NEWLINE> <NL> <NL> <DEDENT> def kmp_matcher ( t , p ) : <NEWLINE> <INDENT> n = len ( t ) <NEWLINE> m = len ( p ) <NEWLINE> pi = compute_prefix_function ( p ) <NEWLINE> q = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> while q > 0 and p [ q ] != t [ i - 1 ] : <NEWLINE> <INDENT> q = pi [ q ] <NEWLINE> <DEDENT> if p [ q ] == t [ i - 1 ] : <NEWLINE> <INDENT> q += 1 <NEWLINE> <DEDENT> if q == m : <NEWLINE> <INDENT> print ( i - m ) <NEWLINE> q = pi [ q ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> t = input ( ) <NEWLINE> p = input ( ) <NEWLINE> kmp_matcher ( t , p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if min ( X1 ) == max ( X1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for p in range ( min ( X1 ) , max ( X1 ) ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num += ( X1 [ i ] - p ) * ( X1 [ i ] - p ) <NEWLINE> <NL> <DEDENT> ans . append ( int ( num ) ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( w , v ) in enumerate ( wv , start = 1 ) : <NEWLINE> <INDENT> dp_i = dp [ i ] <NEWLINE> dp_im = dp [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp_i [ j ] = dp_im [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = dp_im [ j - w ] + v <NEWLINE> b = dp_im [ j ] <NEWLINE> if a > b : <NEWLINE> <INDENT> dp_i [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_i [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> print ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> indexes = np . arange ( 0 , N ) <NEWLINE> <NL> dp = np . zeros ( shape = N + 1 , dtype = np . int64 ) <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> np . add . at ( dp , np . maximum ( 0 , indexes - A ) , 1 ) <NEWLINE> np . add . at ( dp , np . minimum ( N , indexes + A + 1 ) , - 1 ) <NEWLINE> A = dp . cumsum ( ) [ : - 1 ] <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp *= 0 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic . add ( cmd [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cmd [ 1 ] in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M , S = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> convert = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj [ u - 1 ] . append ( ( v - 1 , a , b ) ) <NEWLINE> adj [ v - 1 ] . append ( ( u - 1 , a , b ) ) <NEWLINE> <NL> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> convert . append ( ( c , d ) ) <NEWLINE> <NL> <DEDENT> import heapq <NEWLINE> <NL> limit = 2500 <NEWLINE> S = min ( S , limit ) <NEWLINE> h = [ ( 0 , 0 , S ) ] <NEWLINE> ans = [ [ float ( <STRING> ) ] * ( limit + 1 ) for _ in range ( N ) ] <NEWLINE> <NL> while h != [ ] : <NEWLINE> <INDENT> time_consumed , city , coin = heapq . heappop ( h ) <NEWLINE> if ans [ city ] [ coin ] < time_consumed : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ city ] [ coin ] = time_consumed <NEWLINE> <NL> if coin + convert [ city ] [ 0 ] < limit and ans [ city ] [ coin + convert [ city ] [ 0 ] ] > time_consumed + convert [ city ] [ 1 ] : <NEWLINE> <INDENT> ans [ city ] [ coin + convert [ city ] [ 0 ] ] = time_consumed + convert [ city ] [ 1 ] <NEWLINE> heapq . heappush ( h , ( time_consumed + convert [ city ] [ 1 ] , city , coin + convert [ city ] [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> for v , a , b in adj [ city ] : <NEWLINE> <INDENT> if coin - a < 0 or ans [ v ] [ coin - a ] <= time_consumed + b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ v ] [ coin - a ] = time_consumed + b <NEWLINE> heapq . heappush ( h , ( time_consumed + b , v , coin - a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( ans [ i ] ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def mpow ( n , p , mod ) : <NEWLINE> <INDENT> if mod == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = 1 <NEWLINE> while p > 0 : <NEWLINE> <INDENT> if p & 1 == 1 : <NEWLINE> <INDENT> r = r * n % mod <NEWLINE> <DEDENT> n = n * n % mod <NEWLINE> p >>= 1 <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> def popcount ( u ) : <NEWLINE> <INDENT> if u == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> a = u % bin ( u ) . count ( <STRING> ) <NEWLINE> return 1 + popcount ( a ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = <STRING> + input ( ) <NEWLINE> xs = int ( x , 0 ) <NEWLINE> xc = x . count ( <STRING> ) <NEWLINE> xsp = mpow ( xs , 1 , xc + 1 ) <NEWLINE> xsm = mpow ( xs , 1 , xc - 1 ) <NEWLINE> for i in range ( 2 , n + 2 ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> y = xsp + mpow ( 2 , n - i + 1 , xc + 1 ) <NEWLINE> y = mpow ( y , 1 , xc + 1 ) <NEWLINE> print ( popcount ( y ) + 1 ) <NEWLINE> <DEDENT> elif xc == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = xsm - mpow ( 2 , n - i + 1 , xc - 1 ) <NEWLINE> y = mpow ( y , 1 , xc - 1 ) <NEWLINE> print ( popcount ( y ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> MAX_N = 3 * 10 ** 6 <NEWLINE> <NL> fact = [ 1 ] <NEWLINE> fact_inv = [ 0 ] * ( MAX_N + 4 ) <NEWLINE> for i in range ( MAX_N + 3 ) : <NEWLINE> <INDENT> fact . append ( fact [ - 1 ] * ( i + 1 ) % mod ) <NEWLINE> <NL> <DEDENT> fact_inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( MAX_N + 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> fact_inv [ i ] = fact_inv [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> def comb ( n , k , mod ) : <NEWLINE> <INDENT> if n < k : return 0 <NEWLINE> return fact [ n ] * fact_inv [ k ] % mod * fact_inv [ n - k ] % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> ans += comb ( c1 + r1 , r1 , mod ) <NEWLINE> ans %= mod <NEWLINE> ans -= comb ( c1 + r2 + 1 , r2 + 1 , mod ) <NEWLINE> ans %= mod <NEWLINE> ans -= comb ( c2 + r1 + 1 , r1 , mod ) <NEWLINE> ans %= mod <NEWLINE> ans += comb ( c2 + r2 + 2 , r2 + 1 , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in b ] <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if X == 1 : <NEWLINE> <INDENT> ans = N * T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N <= X : <NEWLINE> <INDENT> ans = T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i < N : <NEWLINE> <INDENT> i = i + X <NEWLINE> ans = ans + T <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , Y , Z , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> <NL> hq = [ ( - ( A [ 0 ] + B [ 0 ] + C [ 0 ] ) , 0 , 0 , 0 ) ] <NEWLINE> seen = set ( ) <NEWLINE> ans = [ ] <NEWLINE> while len ( ans ) < K : <NEWLINE> <INDENT> s , i , j , k = heappop ( hq ) <NEWLINE> ans . append ( - s ) <NEWLINE> if i < X - 1 and ( i + 1 , j , k ) not in seen : <NEWLINE> <INDENT> heappush ( hq , ( - ( A [ i + 1 ] + B [ j ] + C [ k ] ) , i + 1 , j , k ) ) <NEWLINE> seen . add ( ( i + 1 , j , k ) ) <NEWLINE> <DEDENT> if j < Y - 1 and ( i , j + 1 , k ) not in seen : <NEWLINE> <INDENT> heappush ( hq , ( - ( A [ i ] + B [ j + 1 ] + C [ k ] ) , i , j + 1 , k ) ) <NEWLINE> seen . add ( ( i , j + 1 , k ) ) <NEWLINE> <DEDENT> if k < Z - 1 and ( i , j , k + 1 ) not in seen : <NEWLINE> <INDENT> heappush ( hq , ( - ( A [ i ] + B [ j ] + C [ k + 1 ] ) , i , j , k + 1 ) ) <NEWLINE> seen . add ( ( i , j , k + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m = 2019 <NEWLINE> s = 0 <NEWLINE> i = 1 <NEWLINE> l = [ 0 ] * m <NEWLINE> <NL> for c in reversed ( input ( ) ) : <NEWLINE> <INDENT> s = ( s + int ( c ) * i ) % m <NEWLINE> l [ s ] += 1 <NEWLINE> i = ( i * 10 ) % m <NEWLINE> <NL> <DEDENT> print ( l [ 0 ] + sum ( v * ( v - 1 ) // 2 for v in l ) ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> num = [ 0 for _ in range ( len ( n ) ) ] <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> num [ i ] = int ( n [ i ] ) <NEWLINE> <DEDENT> for i in ( reversed ( range ( len ( n ) ) ) ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if num [ j ] > num [ j + 1 ] : <NEWLINE> <INDENT> tmp = num [ j + 1 ] <NEWLINE> num [ j + 1 ] = num [ j ] <NEWLINE> num [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( num [ 0 ] ) + <STRING> + str ( num [ 1 ] ) + <STRING> + str ( num [ 2 ] ) ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> bad = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ori = L [ i ] [ 0 ] - 1 <NEWLINE> dest = L [ i ] [ 1 ] - 1 <NEWLINE> <COMMENT> <NL> if H [ ori ] <= H [ dest ] : <NEWLINE> <INDENT> bad . append ( ori ) <NEWLINE> <DEDENT> if H [ ori ] >= H [ dest ] : <NEWLINE> <INDENT> bad . append ( dest ) <NEWLINE> <NL> <DEDENT> <DEDENT> deletes = set ( bad ) <NEWLINE> print ( N - len ( deletes ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 0 ) : <NEWLINE> <INDENT> self . d = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . d [ x ] < 0 : return x <NEWLINE> self . d [ x ] = self . find ( self . d [ x ] ) <NEWLINE> return self . d [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return False <NEWLINE> if self . d [ x ] > self . d [ y ] : x , y = y , x <NEWLINE> self . d [ x ] += self . d [ y ] <NEWLINE> self . d [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : return self . find ( x ) == self . find ( y ) <NEWLINE> def size ( self , x ) : return - self . d [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> n_friends = defaultdict ( int ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a , b ) <NEWLINE> n_friends [ a ] += 1 <NEWLINE> n_friends [ b ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ uf . size ( i ) - n_friends [ i ] - 1 for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( c , d ) : <NEWLINE> <INDENT> ans [ c ] -= 1 <NEWLINE> ans [ d ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans [ 1 : ] ) <NEWLINE>
import sys <NEWLINE> import bisect <COMMENT> <NEWLINE> <NL> <NL> MAX_N = 200005 <NEWLINE> INF = 10 ** 9 + 5 <NEWLINE> <NL> sys . setrecursionlimit ( MAX_N ) <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> A = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> E = [ [ ] for _ in range ( N ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> E [ u - 1 ] . append ( v - 1 ) <NEWLINE> E [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> lis = [ INF ] * N <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> def dfs ( u , r = - 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> i = bisect . bisect_left ( lis , A [ u ] ) <COMMENT> <NEWLINE> old = lis [ i ] <COMMENT> <NEWLINE> lis [ i ] = A [ u ] <NEWLINE> <NL> for v in E [ u ] : <NEWLINE> <INDENT> if v == r : continue <COMMENT> <NEWLINE> <NL> dfs ( v , u ) <NEWLINE> <NL> <DEDENT> ans [ u ] = bisect . bisect_left ( lis , INF - 1 ) <NEWLINE> lis [ i ] = old <COMMENT> <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if abs ( n - m ) == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = 2 * ( ans ** 2 ) <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> elif abs ( n - m ) == 1 : <NEWLINE> <INDENT> for i in range ( 1 , min ( n + 1 , m + 1 ) ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = max ( n , m ) * ( ans ** 2 ) <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> h = int ( S ) // 3600 <NEWLINE> HA = int ( S ) - h * 3600 <NEWLINE> m = HA // 60 <NEWLINE> MA = HA - m * 60 <NEWLINE> s = MA % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for ai in a : <NEWLINE> <INDENT> p = p * ai % mod <NEWLINE> <DEDENT> print ( p ) <NEWLINE> return <NEWLINE> <DEDENT> if a [ 0 ] < 0 and k % 2 : <NEWLINE> <INDENT> for ai in a [ : k ] : <NEWLINE> <INDENT> p = p * ai % mod <NEWLINE> <DEDENT> print ( p ) <NEWLINE> return <NEWLINE> <DEDENT> b = sorted ( [ ( abs ( ai ) , ai ) for ai in a ] , reverse = True ) <NEWLINE> s = 0 <NEWLINE> for ba , bb in b [ : k ] : <NEWLINE> <INDENT> p = p * ba % mod <NEWLINE> if bb < 0 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> if s % 2 == 0 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> return <NEWLINE> <DEDENT> pa , na , pb , nb = [ - 1 ] * 4 <NEWLINE> for ba , bb in b [ : k ] : <NEWLINE> <INDENT> if bb < 0 : <NEWLINE> <INDENT> na = ba <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pa = ba <NEWLINE> <DEDENT> <DEDENT> for ba , bb in b [ k : ] [ : : - 1 ] : <NEWLINE> <INDENT> if bb < 0 : <NEWLINE> <INDENT> nb = ba <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pb = ba <NEWLINE> <DEDENT> <DEDENT> if pa == - 1 or nb == - 1 : <NEWLINE> <INDENT> print ( p * pb * pow ( na , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT> elif pb == - 1 or na == - 1 : <NEWLINE> <INDENT> print ( p * nb * pow ( pa , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT> elif pa * pb > na * nb : <NEWLINE> <INDENT> print ( p * pb * pow ( na , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p * nb * pow ( pa , mod - 2 , mod ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> intList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> intList . sort ( ) <NEWLINE> <NL> cntList = [ 1 ] * ( intList [ - 1 ] + 1 ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> while i < ( N - 1 ) : <NEWLINE> <INDENT> base = intList [ i ] <NEWLINE> j = 1 <NEWLINE> num = base <NEWLINE> if cntList [ num ] == 1 : <NEWLINE> <INDENT> while num <= intList [ - 1 ] : <NEWLINE> <INDENT> if cntList [ num ] == 1 : <NEWLINE> <INDENT> cntList [ num ] = 0 <NEWLINE> <DEDENT> j += 1 <NEWLINE> num = base * j <NEWLINE> <DEDENT> if intList [ i ] != intList [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if cntList [ intList [ - 1 ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> values = list ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> values . append ( int ( lines [ i ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> su = 0 <NEWLINE> amaris = list ( ) <NEWLINE> <NL> for value in values : <NEWLINE> <INDENT> amari = value % 10 <NEWLINE> if amari > 0 : <NEWLINE> <INDENT> amaris . append ( 10 - amari ) <NEWLINE> <NL> <DEDENT> <DEDENT> if amaris == [ ] : <NEWLINE> <INDENT> result = sum ( values ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = sum ( values ) + sum ( amaris ) - max ( amaris ) <NEWLINE> <NL> <DEDENT> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 215 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 481 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 643 ] <NEWLINE> <DEDENT> if pattern == - 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 50 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <DEDENT> if FLAG_LOG : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> if lines_result == lines_export : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> finished = time . time ( ) <NEWLINE> duration = finished - started <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> result = <STRING> <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> result += <STRING> + str ( i ) <NEWLINE> <DEDENT> elif str ( i ) . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> result += <STRING> + str ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : break <NEWLINE> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> nset = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , nset ) : <NEWLINE> <NL> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = list ( map ( float , input ( ) . strip ( <STRING> ) . split ( <STRING> ) ) ) <NEWLINE> vABx = x2 - x1 <NEWLINE> vABy = y2 - y1 <NEWLINE> vCDx = x4 - x3 <NEWLINE> vCDy = y4 - y3 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if abs ( vABx * vCDy - vCDx * vABy ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ True ] * N <NEWLINE> ctr = 0 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if H [ a ] >= H [ b ] : ans [ b ] = False <NEWLINE> if H [ a ] <= H [ b ] : ans [ a ] = False <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ans [ i ] : <NEWLINE> <INDENT> ctr += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ctr ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . readline <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N , K = inpl ( ) <NEWLINE> A = inpl ( ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for t in list ( itertools . combinations ( [ i + 1 for i in range ( n ) ] , 3 ) ) : <NEWLINE> <INDENT> if sum ( t ) == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> list_R = [ ] <NEWLINE> list_G = [ ] <NEWLINE> list_B = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> list_R . append ( i ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> list_G . append ( i ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> list_B . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i + 2 * j > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + j * 2 ] and S [ i + 2 * j ] != S [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( list_B ) * len ( list_G ) * len ( list_R ) - count ) <NEWLINE> <NL>
import math <NEWLINE> def fun ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( int ( fun ( A , B , x ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> m = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> s = [ ] <NEWLINE> total = sum ( a ) <NEWLINE> s . append ( total - a [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s . append ( s [ i - 1 ] - a [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = s [ i ] % m <NEWLINE> ans += tmp * a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans % m ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += y * ( y + 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> f = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if s <= 10 ** 18 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> R , G , B = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> exc = 0 <NEWLINE> for j in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> while 0 <= j - num and j + num < N : <NEWLINE> <INDENT> if S [ j - num ] != S [ j + num ] and S [ j - num ] != S [ j ] and S [ j ] != S [ j + num ] : <NEWLINE> <INDENT> exc += 1 <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( R * B * G - exc ) ) <NEWLINE>
def gcd ( a , b , c ) : <NEWLINE> <COMMENT> <NL> <INDENT> seq = [ a , b , c ] <NEWLINE> seq . sort ( ) <NEWLINE> while b > 0 : <NEWLINE> <INDENT> r = c % b <NEWLINE> c = b <NEWLINE> b = r <NEWLINE> <COMMENT> <NL> <DEDENT> seq_2 = [ a , c ] <NEWLINE> seq_2 . sort ( ) <NEWLINE> while a > 0 : <NEWLINE> <INDENT> r = c % a <NEWLINE> c = a <NEWLINE> a = r <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> from functools import reduce <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for k in range ( j , k + 1 ) : <NEWLINE> <INDENT> t = len ( set ( [ i , j , k ] ) ) <NEWLINE> <NL> if t == 1 : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 3 <NEWLINE> <NL> <DEDENT> elif t == 3 : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> sum_A = ( sum ( A ) ** 2 ) % mod <NEWLINE> B = list ( map ( lambda x : ( x ** 2 ) % mod , A ) ) <NEWLINE> sum_B = sum ( B ) % mod <NEWLINE> print ( ( ( sum_A - sum_B ) * 500000004 ) % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> LIST = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> LIST [ a ] += 1 <NEWLINE> <DEDENT> ANS = 0 <NEWLINE> <NL> for i in range ( 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if LIST [ i ] == 1 : <NEWLINE> <INDENT> ANS += 1 <NEWLINE> <DEDENT> if LIST [ i ] != 0 : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> if LIST [ j ] != 0 : <NEWLINE> <INDENT> LIST [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> class Facts : <NEWLINE> <INDENT> def __init__ ( self , mod = 10 ** 9 + 7 , n_max = 1 ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . n_max = n_max <NEWLINE> self . fact = [ 1 , 1 ] <NEWLINE> self . inv = [ 0 , 1 ] <NEWLINE> self . factinv = [ 1 , 1 ] <NEWLINE> if 1 < n_max : <NEWLINE> <INDENT> setup_table ( n_max ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cmb ( self , n , r ) : <NEWLINE> <INDENT> if r < 0 or n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if self . n_max < n : <NEWLINE> <INDENT> self . setup_table ( n ) <NEWLINE> <DEDENT> return self . fact [ n ] * ( self . factinv [ r ] * self . factinv [ n - r ] % self . mod ) % self . mod <NEWLINE> <NL> <DEDENT> def setup_table ( self , t ) : <NEWLINE> <INDENT> for i in range ( self . n_max + 1 , t + 1 ) : <NEWLINE> <INDENT> self . fact . append ( self . fact [ - 1 ] * i % self . mod ) <NEWLINE> self . inv . append ( - self . inv [ self . mod % i ] * ( self . mod // i ) % self . mod ) <NEWLINE> self . factinv . append ( self . factinv [ - 1 ] * self . inv [ - 1 ] % self . mod ) <NEWLINE> <DEDENT> self . n_max = t <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> f = Facts ( mod ) <NEWLINE> ans = 0 <NEWLINE> t = m * pow ( m - 1 , n - 1 - k , mod ) <NEWLINE> for kx in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += f . cmb ( n - 1 , kx ) * t % mod <NEWLINE> t = t * ( m - 1 ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import defaultdict <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LIR ( row , col ) : <NEWLINE> <INDENT> if row <= 0 : <NEWLINE> <INDENT> return [ [ ] for _ in range ( col ) ] <NEWLINE> <DEDENT> elif col == 1 : <NEWLINE> <INDENT> return [ I ( ) for _ in range ( row ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> read_all = [ LI ( ) for _ in range ( row ) ] <NEWLINE> return map ( list , zip ( * read_all ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> d = defaultdict ( lambda : defaultdict ( lambda : - float ( <STRING> ) ) ) <NEWLINE> d [ 0 ] [ 1 ] = A [ 0 ] <NEWLINE> d [ 1 ] [ 1 ] = max ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in [ i // 2 , i // 2 + 1 ] : <NEWLINE> <INDENT> d [ i ] [ j ] = max ( d [ i - 2 ] [ j - 1 ] + A [ i ] , d [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> d [ i ] [ j ] = max ( d [ i - 2 ] [ j - 1 ] + A [ i ] , d [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d [ N - 1 ] [ N // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = defaultdict ( lambda : defaultdict ( lambda : - float ( <STRING> ) ) ) <NEWLINE> d [ 0 ] [ 1 ] = A [ 0 ] <NEWLINE> d [ 1 ] [ 1 ] = max ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in [ i // 2 , i // 2 + 1 ] : <NEWLINE> <INDENT> d [ i ] [ j ] = max ( d [ i - 2 ] [ j - 1 ] + A [ i ] , d [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in [ i // 2 , i // 2 + 1 ] : <NEWLINE> <INDENT> d [ i ] [ j ] = max ( d [ i - 2 ] [ j - 1 ] + A [ i ] , d [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a1 = d [ N - 1 ] [ N // 2 ] <NEWLINE> n = 0 <NEWLINE> for i in range ( 2 , N , 2 ) : <NEWLINE> <INDENT> n += A [ i ] <NEWLINE> <DEDENT> print ( max ( n , a1 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> import time <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> path = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> alr = [ 0 ] * ( n + 1 ) <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> idx = que . popleft ( ) <NEWLINE> for i in path [ idx ] : <NEWLINE> <INDENT> if alr [ i ] == 0 : <NEWLINE> <INDENT> que . append ( i ) <NEWLINE> ans [ i ] = idx <NEWLINE> alr [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( i + 1 + A [ i ] ) <NEWLINE> R . append ( i + 1 - A [ i ] ) <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> R . sort ( ) <NEWLINE> for i in L : <NEWLINE> <INDENT> l = bisect . bisect_left ( R , i ) <NEWLINE> r = bisect . bisect_right ( R , i ) <NEWLINE> ans = ans + r - l <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> tmp_sum = sum ( a [ 1 : m ] ) % mod <NEWLINE> <NL> for x in range ( m - 1 ) : <NEWLINE> <INDENT> if a [ x ] % mod != 0 : <NEWLINE> <INDENT> ans += ( a [ x ] * tmp_sum ) % mod <NEWLINE> <NL> <DEDENT> tmp_sum -= a [ x + 1 ] % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
<COMMENT> <NL> <NL> S = input ( ) . strip ( ) <NEWLINE> <COMMENT> <NL> num = 0 <NEWLINE> cnt_mod = { 0 : 1 } <COMMENT> <NEWLINE> mod = 2019 <NEWLINE> base_pow = 1 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> digit = int ( S [ len ( S ) - 1 - i ] ) <NEWLINE> <NL> num += ( digit * base_pow ) % mod <NEWLINE> num %= mod <NEWLINE> <NL> base_pow = ( base_pow * 10 ) % mod <NEWLINE> <NL> cnt_mod . setdefault ( num , 0 ) <NEWLINE> cnt_mod [ num ] += 1 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for r , c in cnt_mod . items ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if c >= 2 : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> divisors = [ [ ] , [ ] ] <NEWLINE> for i in range ( 1 , int ( sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divisors [ 0 ] . append ( i ) <NEWLINE> if i * i != x : <NEWLINE> <INDENT> divisors [ 1 ] . append ( x // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors [ 0 ] + divisors [ 1 ] [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in f ( m ) : <NEWLINE> <INDENT> if n <= i : <NEWLINE> <INDENT> print ( m // i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while c < 10 ** 18 and len ( b ) != 0 : <NEWLINE> <INDENT> c = c * b [ 0 ] <NEWLINE> del b [ 0 ] <NEWLINE> <DEDENT> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
s = int ( input ( ) ) <NEWLINE> a = s <NEWLINE> alp = list ( <STRING> ) <NEWLINE> ans = <STRING> <NEWLINE> i = 1 <NEWLINE> <COMMENT> <NL> while s != 0 : <NEWLINE> <INDENT> jo = ( 26 ** i ) <NEWLINE> x = s % jo <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = jo <NEWLINE> <DEDENT> s -= x <NEWLINE> x //= 26 ** ( i - 1 ) <NEWLINE> <COMMENT> <NL> ans = alp [ x - 1 ] + ans <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> limit = 1000000000000000000 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> num = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> num *= i <NEWLINE> if num > limit : <NEWLINE> <INDENT> num = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = num <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> position = 1 <NEWLINE> exp1 = [ 0 ] * n <NEWLINE> exp1 [ 0 ] = 1 <NEWLINE> exp = [ 1 ] <NEWLINE> count = 0 <NEWLINE> <NL> if n >= k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> position = a [ position - 1 ] <NEWLINE> <DEDENT> print ( position ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> position = a [ position - 1 ] <NEWLINE> count += 1 <NEWLINE> if exp1 [ position - 1 ] == 0 : <NEWLINE> <INDENT> exp . append ( position ) <NEWLINE> exp1 [ position - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> init = exp . index ( position ) <NEWLINE> res = ( k - init ) % ( count - init ) <NEWLINE> print ( exp [ init + res ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> rlist = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> rlist . append ( ( rlist [ - 1 ] + int ( S [ - i - 1 ] ) * pow ( 10 , i , 2019 ) ) % 2019 ) <NEWLINE> <NL> <DEDENT> c = Counter ( rlist ) <NEWLINE> c [ 0 ] -= 1 <NEWLINE> <NL> def nC2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans = c [ 0 ] <NEWLINE> for k in c . keys ( ) : <NEWLINE> <INDENT> if c [ k ] >= 2 : <NEWLINE> <INDENT> ans += nC2 ( c [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if j == W - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( w , v ) in enumerate ( wv , start = 1 ) : <NEWLINE> <INDENT> dp_i = dp [ i ] <NEWLINE> dp_im = dp [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp_i [ j ] = dp_im [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = dp_im [ j - w ] + v <NEWLINE> b = dp_im [ j ] <NEWLINE> if a > b : <NEWLINE> <INDENT> dp_i [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_i [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k > a : <NEWLINE> <INDENT> af = k - a <NEWLINE> ab = abs ( af - b ) <NEWLINE> print ( a - ab ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dict_A = Counter ( A ) <NEWLINE> sum_list = sum ( A ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in dict_A : <NEWLINE> <INDENT> print ( sum_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_num = dict_A [ b ] <NEWLINE> dict_A [ c ] += dict_A [ b ] <NEWLINE> dict_A [ b ] = 0 <NEWLINE> sum_list = sum_list + ( c - b ) * b_num <NEWLINE> print ( sum_list ) <NEWLINE> <DEDENT> <DEDENT>
b = input ( ) <NEWLINE> base = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> versus = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> print ( versus [ base . index ( b ) ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = x * A [ i ] <NEWLINE> <NL> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> ans_set = set ( s ) <NEWLINE> print ( len ( ans_set ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> ans = [ i , j ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
def bubble_sort ( l ) : <NEWLINE> <INDENT> N = len ( l ) <NEWLINE> isChange = True <NEWLINE> while isChange : <NEWLINE> <INDENT> isChange = False <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( l [ i ] > l [ i + 1 ] ) : <NEWLINE> <INDENT> l [ i ] , l [ i + 1 ] = l [ i + 1 ] , l [ i ] <NEWLINE> isChange = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> l = input ( ) . split ( ) <NEWLINE> out = bubble_sort ( l ) <NEWLINE> print ( <STRING> . format ( out [ 0 ] , out [ 1 ] , out [ 2 ] ) ) <NEWLINE>
sequence = ( ( 1 , 3 , 5 , 7 , 8 , 10 , 12 ) , ( 4 , 6 , 9 , 11 ) , ( 2 , ) ) <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for s in sequence : <NEWLINE> <INDENT> if x in s and y in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = [ 0 ] * m <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> survey = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = survey [ 0 ] <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> favorite = survey [ j ] <NEWLINE> cnt [ favorite - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt . count ( n ) ) <NEWLINE>
import sys <NEWLINE> <NL> line = sys . stdin . readline ( ) <NEWLINE> line = line . split ( <STRING> ) <NEWLINE> inp = [ ] <NEWLINE> for i in line : <NEWLINE> <INDENT> inp . append ( int ( i ) ) <NEWLINE> <DEDENT> inp . sort ( ) <NEWLINE> inp . reverse ( ) <NEWLINE> for i in range ( len ( inp ) ) : <NEWLINE> <INDENT> if i < len ( inp ) - 1 : <NEWLINE> <INDENT> print ( inp [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( inp [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lists = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lists [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> for i in lists : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> M = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b <= n : <NEWLINE> <INDENT> print ( math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) - a * math . floor ( n / b ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> list . append ( math . gcd ( t , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( list ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def dfs ( G , v , p ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> sc . append ( c [ v ] ) <NEWLINE> <NL> for nv in G [ v ] : <NEWLINE> <INDENT> if nv == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen [ nv ] : <NEWLINE> <INDENT> pos [ 0 ] = nv <NEWLINE> return <NEWLINE> <NL> <DEDENT> dfs ( G , nv , v ) <NEWLINE> if pos [ 0 ] != - 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> G [ i ] . append ( p [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> ans = - float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if seen [ i ] == False : <NEWLINE> <INDENT> pos = [ - 1 ] <NEWLINE> sc = [ ] <NEWLINE> dfs ( G , i , - 1 ) <NEWLINE> <NL> if sc : <NEWLINE> <INDENT> sumsc = sum ( sc ) <NEWLINE> lenc = len ( sc ) <NEWLINE> for j in range ( lenc ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> sc = sc [ 1 : ] + [ sc [ 0 ] ] <NEWLINE> <DEDENT> ac = list ( accumulate ( sc ) ) <NEWLINE> <NL> if sumsc <= 0 : <NEWLINE> <INDENT> ans = max ( ans , max ( ac [ : min ( k , lenc ) ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % lenc == 0 : <NEWLINE> <INDENT> ans = max ( ans , ac [ - 1 ] * ( k // lenc - 1 ) + max ( ac ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , ac [ - 1 ] * ( k // lenc ) + max ( ac [ : k % lenc ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = [ ] <NEWLINE> cur = arr [ 0 ] if arr [ 0 ] < arr [ 1 ] else 10 ** 10 <NEWLINE> f = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if cur < arr [ i ] : <NEWLINE> <INDENT> arr2 . append ( cur ) <NEWLINE> f *= - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if cur > arr [ i ] : <NEWLINE> <INDENT> arr2 . append ( cur ) <NEWLINE> f *= - 1 <NEWLINE> <DEDENT> <DEDENT> cur = arr [ i ] <NEWLINE> <DEDENT> if f == - 1 : <NEWLINE> <INDENT> arr2 . append ( cur ) <NEWLINE> <DEDENT> ans = 1000 <NEWLINE> stock = 0 <NEWLINE> for i , a in enumerate ( arr2 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> stock = ans // a <NEWLINE> ans %= a <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans += stock * a <NEWLINE> stock = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * ( a [ : : - 2 ] + a [ n % 2 : : 2 ] ) ) <NEWLINE>
import math <NEWLINE> import queue <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = qb <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> def dq ( ) : <NEWLINE> <INDENT> return queue . deque ( ) <NEWLINE> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def bitArr ( n ) : <COMMENT> <NEWLINE> <INDENT> x = 1 <NEWLINE> zero = <STRING> * n <NEWLINE> ans = [ ] <NEWLINE> ans . append ( [ 0 ] * n ) <NEWLINE> for i in range ( 2 ** n - 1 ) : <NEWLINE> <INDENT> ans . append ( list ( map ( lambda x : int ( x ) , list ( ( zero + bin ( x ) [ 2 : ] ) [ - 1 * n : ] ) ) ) ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> return ans ; <NEWLINE> <DEDENT> def arrsSum ( a1 , a2 ) : <NEWLINE> <INDENT> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> a1 [ i ] += a2 [ i ] <NEWLINE> <DEDENT> return a1 <NEWLINE> <DEDENT> def maxValue ( a , b , v ) : <NEWLINE> <INDENT> v2 = v <NEWLINE> for i in range ( v2 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( v2 // a + 1 ) : <COMMENT> <NEWLINE> <INDENT> k = i - a * j <NEWLINE> if k % b == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> arr = readInts ( ) <NEWLINE> gu_num = arr [ 0 ] % 2 + arr [ 1 ] % 2 + arr [ 2 ] % 2 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if gu_num not in [ 0 , 3 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if gu_num == 1 : <NEWLINE> <INDENT> if arr [ 0 ] % 2 == 1 : <NEWLINE> <INDENT> arr [ 1 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> elif arr [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if arr [ 0 ] % 2 == 0 : <NEWLINE> <INDENT> arr [ 1 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> elif arr [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> while not ( arr [ 0 ] == arr [ 1 ] and arr [ 1 ] == arr [ 2 ] ) : <NEWLINE> <INDENT> arr [ arr . index ( min ( arr ) ) ] += 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> low = 0 <NEWLINE> high = max ( A ) <NEWLINE> def ok ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += ( a // x ) <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <= K <NEWLINE> <NL> <DEDENT> while high - low > 1 : <NEWLINE> <INDENT> mid = ( high + low ) // 2 <NEWLINE> if ok ( mid ) : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> <DEDENT> print ( high ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li = lst [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and lst [ j ] > li : <NEWLINE> <INDENT> lst [ j : j + 2 ] = lst [ j + 1 ] , lst [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> print ( * lst ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class UnionFindTree : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . parent = self <NEWLINE> self . id = x <NEWLINE> self . rank = 0 <NEWLINE> <NL> <DEDENT> def find ( self ) : <NEWLINE> <INDENT> if self . id == self . parent . id : <NEWLINE> <INDENT> return self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . parent . find ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes = [ UnionFindTree ( i ) for i in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x_root = nodes [ x ] . find ( ) <NEWLINE> y_root = nodes [ y ] . find ( ) <NEWLINE> if com == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if x_root . rank > y_root . rank : <NEWLINE> <INDENT> y_root . parent = x_root <NEWLINE> <DEDENT> elif y_root . rank > x_root . rank : <NEWLINE> <INDENT> x_root . parent = y_root <NEWLINE> <DEDENT> elif x_root . id != y_root . id : <NEWLINE> <INDENT> y_root . parent = x_root <NEWLINE> x_root . rank += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> same = 1 if x_root . id == y_root . id else 0 <NEWLINE> print ( same ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> town = [ ] <NEWLINE> dic = { } <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i not in dic and j < K : <NEWLINE> <INDENT> dic [ i ] = j <NEWLINE> town . append ( i ) <NEWLINE> i = X [ i ] - 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> if j == K : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> num = dic [ i ] <NEWLINE> loop = j - num <NEWLINE> print ( town [ ( ( K - num ) % loop ) + num ] + 1 ) <NEWLINE> <DEDENT>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( w ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> tmp_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> g [ i ] . append ( tmp_list [ i ] ) <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> qs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> loc = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> loc [ g [ j ] [ i ] ] = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> roots = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> while j < h * w + 1 : <NEWLINE> <INDENT> cost = abs ( loc [ j ] [ 0 ] - loc [ j - d ] [ 0 ] ) + abs ( loc [ j ] [ 1 ] - loc [ j - d ] [ 1 ] ) <NEWLINE> roots [ j ] = cost + roots [ j - d ] <NEWLINE> j += d <NEWLINE> <DEDENT> <DEDENT> for i in qs : <NEWLINE> <INDENT> l , r = i [ 0 ] , i [ 1 ] <NEWLINE> print ( roots [ r ] - roots [ l ] ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> Ans = 0 <NEWLINE> W_put_place = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> Ans += i - W_put_place <NEWLINE> W_put_place += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( li ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> if ( i == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( a , i ) ) <NEWLINE> a += 1 <NEWLINE> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> r = { } <NEWLINE> b = { } <NEWLINE> g = { } <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r [ i + 1 ] = s [ i ] <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i + 1 ] = s [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g [ i + 1 ] = s [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( b ) * len ( g ) <NEWLINE> for i in r . keys ( ) : <NEWLINE> <INDENT> for j in b . keys ( ) : <NEWLINE> <INDENT> diff = abs ( j - i ) <NEWLINE> minb = min ( i , j ) - diff <NEWLINE> maxb = max ( i , j ) + diff <NEWLINE> if maxb in g . keys ( ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if minb in g . keys ( ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( ( i + j ) % 2 == 0 ) : <NEWLINE> <INDENT> if ( ( i + j ) // 2 in g . keys ( ) ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> c = [ 0 ] <NEWLINE> visit = [ False ] * n <NEWLINE> visit [ 0 ] = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nt = a [ c [ - 1 ] ] - 1 <NEWLINE> if visit [ nt ] : <NEWLINE> <INDENT> ws = c . index ( nt ) <NEWLINE> wst = c [ : ws ] <NEWLINE> wrt = c [ ws : ] <NEWLINE> wr = len ( wrt ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( nt ) <NEWLINE> visit [ nt ] = True <NEWLINE> <DEDENT> <DEDENT> if ws > k : <NEWLINE> <INDENT> ans = wst [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = wrt [ ( k - ws ) % wr ] <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n , s , q , t = input ( ) , list ( set ( map ( int , input ( ) . split ( ) ) ) ) , input ( ) , set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> s . sort ( ) <NEWLINE> <NL> <NL> def binary_search ( i ) : <NEWLINE> <INDENT> global s <NEWLINE> l , r = 0 , len ( s ) <NEWLINE> while l < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> sm = s [ m ] <NEWLINE> if sm == i : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif i < sm : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m + 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> print ( sum ( binary_search ( i ) for i in t ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> base = int ( 1e9 + 7 ) <NEWLINE> tot = 0 <NEWLINE> <NL> s = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> tot += s * a <NEWLINE> s += a <NEWLINE> tot %= base <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> sumA = sumB = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if c [ 0 ] == c [ 1 ] : <NEWLINE> <INDENT> sumA = sumA + c [ 0 ] <NEWLINE> sumB = sumB + c [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumA = sumA + ( c [ 0 ] + c [ 1 ] if c [ 0 ] > c [ 1 ] else 0 ) <NEWLINE> sumB = sumB + ( c [ 0 ] + c [ 1 ] if c [ 1 ] > c [ 0 ] else 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( sumA , sumB ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> while n > 25 : <NEWLINE> <INDENT> p = n // 26 <NEWLINE> k = n - 26 * p <NEWLINE> if k == 0 : <NEWLINE> <INDENT> ans . append ( 26 ) <NEWLINE> n = p - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( k ) <NEWLINE> n = p <NEWLINE> <DEDENT> <DEDENT> if n != 0 : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> b . append ( chr ( 96 + ans [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> collection = Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( collection [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> i = 2 * j - k <NEWLINE> if i >= 0 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) - tmp <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( i ) for i in b ] <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> if A [ - 1 ] < 0 and k % 2 == 1 : <NEWLINE> <INDENT> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now *= A [ - i - 1 ] % mod <NEWLINE> now %= mod <NEWLINE> <DEDENT> print ( now ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = n - 1 <NEWLINE> ans = 1 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans = A [ - 1 ] <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( k // 2 ) : <NEWLINE> <INDENT> mi = A [ l ] * A [ l + 1 ] <NEWLINE> pl = A [ r ] * A [ r - 1 ] <NEWLINE> if mi > pl : <NEWLINE> <INDENT> ans *= mi % mod <NEWLINE> ans %= mod <NEWLINE> l += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pl % mod <NEWLINE> ans %= mod <NEWLINE> r -= 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
_ = input ( ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> B *= a <NEWLINE> if B > 10 ** 18 : <NEWLINE> <INDENT> B = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
n , m = ( int ( each ) for each in input ( ) . split ( ) ) <NEWLINE> h = [ int ( each ) for each in input ( ) . split ( ) ] <NEWLINE> pathlist = list ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> pathlist . append ( [ int ( each ) for each in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> score = 0 <NEWLINE> <NL> decklist = set ( range ( 1 , n + 1 ) ) <NEWLINE> for path in pathlist : <NEWLINE> <COMMENT> <NL> <INDENT> if h [ path [ 0 ] - 1 ] >= h [ path [ 1 ] - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> decklist . discard ( path [ 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> if h [ path [ 0 ] - 1 ] <= h [ path [ 1 ] - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> decklist . discard ( path [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( decklist ) ) <NEWLINE>
input ( ) <NEWLINE> A = [ 0 ] + input ( ) . split ( ) <NEWLINE> H = len ( A ) <NEWLINE> for i in range ( 1 , H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * 26 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> cnt [ ord ( a [ j ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> if h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> f = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt [ i ] -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> four = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] >= 4 : <NEWLINE> <INDENT> four += cnt [ i ] // 4 * 4 <NEWLINE> <DEDENT> elif cnt [ i ] % 2 == 1 : <NEWLINE> <INDENT> f = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if four >= h * w - ( h // 2 + w // 2 ) * 2 - 1 and f == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> elif h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] % 4 != 0 : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> h , w = w , h <NEWLINE> <DEDENT> two = 0 ; f = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] % 4 == 2 : <NEWLINE> <INDENT> two += 2 <NEWLINE> <DEDENT> elif cnt [ i ] % 2 == 1 : <NEWLINE> <INDENT> f = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if two <= w and f == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if f else <STRING> ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> res = 0 <NEWLINE> cur = 0 <NEWLINE> count = [ 0 ] * 2020 <NEWLINE> count [ 0 ] = 1 <NEWLINE> for i , c in enumerate ( map ( int , S ) ) : <NEWLINE> <INDENT> cur = ( cur * 10 + c ) % 2019 <NEWLINE> temp = ( cur * pow ( 10 , ( n - i ) , 2019 ) ) % 2019 <NEWLINE> count [ temp ] += 1 <NEWLINE> <DEDENT> print ( sum ( c * ( c - 1 ) // 2 for c in count ) ) <NEWLINE>
<COMMENT> <NL> def jyu_waru ( a ) : <NEWLINE> <INDENT> x = a <NEWLINE> b = 0 <NEWLINE> while x > 10 : <NEWLINE> <INDENT> x = x // 10 <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> b = a <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return b <NEWLINE> <NL> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> kazu = [ ] <NEWLINE> x = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> kazu . append ( i ) <NEWLINE> <NL> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> kazu . append ( i ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = jyu_waru ( i ) <NEWLINE> if x != 0 : <NEWLINE> <INDENT> kazu . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , kazu ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> c = x . count ( <STRING> ) <NEWLINE> cp = c + 1 <NEWLINE> cn = c - 1 <NEWLINE> <NL> rp = [ 0 ] * n <NEWLINE> if cp > 1 : <NEWLINE> <INDENT> rp [ 0 ] = 1 <NEWLINE> <DEDENT> rn = [ 0 ] * n <NEWLINE> if cn > 1 : <NEWLINE> <INDENT> rn [ 0 ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> rp [ i ] = ( rp [ i - 1 ] * 2 ) % cp <NEWLINE> if cn > 0 : <NEWLINE> <INDENT> rn [ i ] = ( rn [ i - 1 ] * 2 ) % cn <NEWLINE> <NL> <DEDENT> <DEDENT> xp = 0 <NEWLINE> xn = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xx = x [ i ] <NEWLINE> if xx == <STRING> : <NEWLINE> <INDENT> xp = ( xp + rp [ n - i - 1 ] ) % cp <NEWLINE> if cn > 0 : <NEWLINE> <INDENT> xn = ( xn + rn [ n - i - 1 ] ) % cn <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> o = 1 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if cn == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> xx = ( xn - rn [ n - i - 1 ] ) % cn <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xx = ( xp + rp [ n - i - 1 ] ) % cp <NEWLINE> <DEDENT> while xx > 0 : <NEWLINE> <INDENT> cc = bin ( xx ) [ 2 : ] . count ( <STRING> ) <NEWLINE> xx = xx % cc <NEWLINE> o += 1 <NEWLINE> <DEDENT> print ( o ) <NEWLINE> <DEDENT>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> r = o = s = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a = input ( ) [ 1 ] <NEWLINE> if <STRING> == a : <NEWLINE> <INDENT> if r < 3 : r += 1 <NEWLINE> else : s += 1 <NEWLINE> <DEDENT> elif <STRING> == a : s += r + 1 ; r = 0 <NEWLINE> else : <NEWLINE> <INDENT> if o < 2 : o += 1 <NEWLINE> else : print ( s ) ; break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ - k ] ) <NEWLINE>
<COMMENT> <NL> S = list ( str ( input ( ) ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> U = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> U . append ( int ( S [ N - i - 1 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> DP = [ - 1 ] * ( N + 1 ) <NEWLINE> DP [ 0 ] = 0 <NEWLINE> now = 0 <NEWLINE> pnow = 1 <NEWLINE> for i , u in enumerate ( U ) : <NEWLINE> <INDENT> pnow *= 10 <NEWLINE> pnow %= 2019 <NEWLINE> now += int ( u ) * pnow <NEWLINE> now %= 2019 <NEWLINE> DP [ i + 1 ] = now <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> tyo = [ 0 ] * 2019 <NEWLINE> for dp in DP : <NEWLINE> <INDENT> tyo [ dp ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for t in tyo : <NEWLINE> <INDENT> ans += ( t * ( t - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
from itertools import accumulate <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> t = K - a [ i ] <NEWLINE> if t < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect_left ( b , t ) <NEWLINE> if j == M + 1 : <NEWLINE> <INDENT> result = max ( result , i + M ) <NEWLINE> <DEDENT> elif b [ j ] == t : <NEWLINE> <INDENT> result = max ( result , i + j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = max ( result , i + j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
x1 = input ( ) <NEWLINE> x2 = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> result = 0 <NEWLINE> if 0 in x2 : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for xv in x2 : <NEWLINE> <INDENT> result = xv * result <NEWLINE> <NL> if 10 ** 18 < result : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 < n : <NEWLINE> <INDENT> n = b - 1 <NEWLINE> <DEDENT> print ( a * ( n ) // b - a * ( ( n ) // b ) ) <NEWLINE> <NL>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> sum *= i <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a . append ( math . gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> a = collections . Counter ( a ) <NEWLINE> for key , value in a . items ( ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , key ) * value <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> friendlist = list ( range ( N ) ) <NEWLINE> <COMMENT> <NL> gplist = [ [ i ] for i in range ( N ) ] <NEWLINE> <NL> def getgroup ( a ) : <NEWLINE> <INDENT> A = friendlist [ a ] <NEWLINE> if A == a : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return getgroup ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> def match ( ab ) : <NEWLINE> <INDENT> A = getgroup ( ab [ 0 ] ) <NEWLINE> B = getgroup ( ab [ 1 ] ) <NEWLINE> if A == B : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif len ( gplist [ A ] ) < len ( gplist [ B ] ) : <NEWLINE> <INDENT> gplist [ B ] . extend ( gplist [ A ] ) <NEWLINE> friendlist [ A ] = B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gplist [ A ] . extend ( gplist [ B ] ) <NEWLINE> friendlist [ B ] = A <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> match ( tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( max ( [ len ( item ) for item in gplist ] ) ) <NEWLINE>
import math <NEWLINE> <NL> def floor ( num , a , b ) : <NEWLINE> <INDENT> return math . floor ( a * num / b ) - ( a * math . floor ( num / b ) ) <NEWLINE> <NL> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( floor ( min ( b - 1 , n ) , a , b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> search_max = int ( N ** 0.5 ) <NEWLINE> <NL> min_number = 10 ** 12 <NEWLINE> for x in range ( 1 , search_max + 1 ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> y = N // x <NEWLINE> if x + y < min_number : <NEWLINE> <NL> <INDENT> min_number = x + y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min_number - 2 ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> def popcnt ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def mod ( n , cnt ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <DEDENT> n = n % popcnt ( n ) <NEWLINE> cnt += 1 <NEWLINE> return mod ( n , cnt ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( readline ( ) ) <NEWLINE> x2 = list ( readline ( ) . decode ( ) . rstrip ( ) ) <NEWLINE> x10 = int ( <STRING> . join ( x2 ) , 2 ) <NEWLINE> <NL> c = x2 . count ( <STRING> ) <NEWLINE> mod1 = x10 % ( c + 1 ) <NEWLINE> mod2 = x10 % ( c - 1 ) if c - 1 != 0 else 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x2 [ i ] == <STRING> : <NEWLINE> <INDENT> t = ( mod1 + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c - 1 != 0 : <NEWLINE> <INDENT> t = ( mod2 - pow ( 2 , n - i - 1 , c - 1 ) ) % ( c - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( mod ( t , 1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x = A [ i ] - 1 <NEWLINE> B [ x ] = B [ x ] + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> <NL> def circle ( r ) : <NEWLINE> <INDENT> print ( r * r * pi , 2 * pi * r ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> r = input ( ) <NEWLINE> ret = circle ( float ( r ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> FootPrintA = A [ : ] <NEWLINE> <NL> loop = [ ] <NEWLINE> <NL> slack_que = deque ( [ ] ) <NEWLINE> flag = 0 <NEWLINE> t = 0 <NEWLINE> start = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> slack_que . append ( t ) <NEWLINE> t_ = FootPrintA [ t ] <NEWLINE> FootPrintA [ t ] = - 1 <NEWLINE> if t_ == - 1 : <NEWLINE> <INDENT> start = slack_que . index ( t ) <NEWLINE> flag = 1 <NEWLINE> slack_que . pop ( ) <NEWLINE> <DEDENT> t = A [ t ] <NEWLINE> <NL> <DEDENT> slack = list ( slack_que ) <NEWLINE> slack_num = start <NEWLINE> loop_num = len ( slack ) - slack_num <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> loop = slack [ start : ] <NEWLINE> <COMMENT> <NL> if ( K - slack_num ) < 0 : <NEWLINE> <INDENT> res = slack [ K ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tele_num = ( ( K - slack_num ) % loop_num ) <NEWLINE> town = loop [ tele_num ] <NEWLINE> res = town + 1 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> <NL> s = <STRING> <NEWLINE> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> s += O [ i ] <NEWLINE> if i < len ( E ) : <NEWLINE> <INDENT> s += E [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
bfr = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> bfr [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , bfr [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s_a = input ( ) <NEWLINE> s_b = input ( ) <NEWLINE> s_c = input ( ) <NEWLINE> s_a = [ s for s in s_a if s != <STRING> ] <NEWLINE> s_b = [ s for s in s_b if s != <STRING> ] <NEWLINE> s_c = [ s for s in s_c if s != <STRING> ] <NEWLINE> s_a = deque ( s_a ) <NEWLINE> s_b = deque ( s_b ) <NEWLINE> s_c = deque ( s_c ) <NEWLINE> if not s_a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> turn = s_a . popleft ( ) <NEWLINE> ans = - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if turn == <STRING> and s_a : <NEWLINE> <INDENT> turn = s_a . popleft ( ) <NEWLINE> <DEDENT> elif turn == <STRING> and s_b : <NEWLINE> <INDENT> turn = s_b . popleft ( ) <NEWLINE> <DEDENT> elif turn == <STRING> and s_c : <NEWLINE> <INDENT> turn = s_c . popleft ( ) <NEWLINE> <DEDENT> elif turn == <STRING> and not s_a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif turn == <STRING> and not s_b : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif turn == <STRING> and not s_c : <NEWLINE> <INDENT> ans = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> minus = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - minus ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 50000 ) <NEWLINE> <NL> def findset ( x , element , weight ) : <NEWLINE> <INDENT> if ( x != element [ x ] ) : <NEWLINE> <INDENT> element [ x ] , s = findset ( element [ x ] , element , weight ) <NEWLINE> weight [ x ] += s <NEWLINE> <DEDENT> return element [ x ] , weight [ x ] <NEWLINE> <NL> <DEDENT> def union ( x , y , element , weight , w ) : <NEWLINE> <INDENT> x , wx = findset ( x , element , weight ) <NEWLINE> y , wy = findset ( y , element , weight ) <NEWLINE> link ( x , wx , y , wy , w , element ) <NEWLINE> <DEDENT> def link ( x , wx , y , wy , z , element ) : <NEWLINE> <INDENT> z = z + wy - wx <NEWLINE> <NL> element [ x ] = y <NEWLINE> weight [ x ] = z <NEWLINE> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> element = [ i for i in range ( n ) ] <NEWLINE> weight = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> inp = map ( int , input ( ) . split ( ) ) ; <NEWLINE> inp = list ( inp ) <NEWLINE> if ( inp [ 0 ] == 0 ) : <NEWLINE> <INDENT> x , y , w = inp [ 1 ] , inp [ 2 ] , inp [ 3 ] <NEWLINE> union ( x , y , element , weight , w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = inp [ 1 ] , inp [ 2 ] <NEWLINE> x , wx = findset ( x , element , weight ) <NEWLINE> y , wy = findset ( y , element , weight ) <NEWLINE> if ( x == y ) : <NEWLINE> <INDENT> print ( wx - wy ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b > a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> import re <NEWLINE> <NL> regxp = <STRING> + S + <STRING> <NEWLINE> <NL> repattern = re . compile ( regxp ) <NEWLINE> result = repattern . search ( T ) <NEWLINE> <NL> <COMMENT> <NL> <NL> try : <NEWLINE> <INDENT> if result . group ( ) == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> if S < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( 2001 ) ] <NEWLINE> <NL> ans [ 3 ] = 1 <NEWLINE> ans [ 4 ] = 1 <NEWLINE> ans [ 5 ] = 1 <NEWLINE> <NL> for i in range ( 6 , S + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 3 ] + ans [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans [ S ] % 1000000007 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Town = [ ] <NEWLINE> <COMMENT> <NL> rec = [ - 1 ] * ( n + 1 ) <NEWLINE> idx = 1 <NEWLINE> <COMMENT> <NL> while ( rec [ idx ] == - 1 ) : <NEWLINE> <INDENT> rec [ idx ] = len ( Town ) <NEWLINE> Town . append ( idx ) <NEWLINE> idx = A [ idx - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Exce = rec [ idx ] <NEWLINE> <COMMENT> <NL> Cycl = len ( Town ) - Exce <NEWLINE> <NL> if Exce > k : <NEWLINE> <INDENT> print ( Town [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Warp = ( k - Exce ) % Cycl <NEWLINE> print ( Town [ Exce + Warp ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> c = n // 2 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = n // 2 <NEWLINE> <NL> <DEDENT> b [ c ] = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> b [ c + i ] = a [ i ] <NEWLINE> c += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ c - i ] = a [ i ] <NEWLINE> c -= i <NEWLINE> <NL> <DEDENT> <DEDENT> if c != 0 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> print ( * b , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * b , sep = <STRING> ) <NEWLINE> <DEDENT>
def partition ( hoge , p , r ) : <NEWLINE> <INDENT> x = int ( hoge [ r ] [ 1 ] ) <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if int ( hoge [ j ] [ 1 ] ) <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> tmp = hoge [ i ] <NEWLINE> hoge [ i ] = hoge [ j ] <NEWLINE> hoge [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> tmp = hoge [ i + 1 ] <NEWLINE> hoge [ i + 1 ] = hoge [ r ] <NEWLINE> hoge [ r ] = tmp <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def qSort ( hoge , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( hoge , p , r ) <NEWLINE> qSort ( hoge , p , q - 1 ) <NEWLINE> qSort ( hoge , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def isStable ( input_array , output_array ) : <NEWLINE> <INDENT> same_nums = list ( ) <NEWLINE> now_num = 0 <NEWLINE> for elem in output_array : <NEWLINE> <INDENT> if now_num != int ( elem [ 1 ] ) : <NEWLINE> <INDENT> now_num = int ( elem [ 1 ] ) <NEWLINE> same_nums = list ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in same_nums : <NEWLINE> <INDENT> if input_array . index ( c ) > input_array . index ( elem ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> same_nums . append ( elem ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> hoge = list ( ) <NEWLINE> for _ in range ( num ) : <NEWLINE> <INDENT> c , s = input ( ) . split ( ) <NEWLINE> hoge . append ( ( c , s ) ) <NEWLINE> <DEDENT> origin = hoge [ : ] <NEWLINE> qSort ( hoge , 0 , len ( hoge ) - 1 ) <NEWLINE> print ( isStable ( origin , hoge ) ) <NEWLINE> print ( <STRING> . join ( [ <STRING> . format ( x ) for x in hoge ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> S = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> ans += A [ i ] * S <NEWLINE> <NL> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> from itertools import combinations <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> s = int ( input ( ) ) <NEWLINE> qwe = np . arange ( s + 1 ) <NEWLINE> <NL> sum = ( 1 + s ) * s / 2 <NEWLINE> <NL> for i in range ( 1 , s + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , s + 1 ) : <NEWLINE> <INDENT> sum += gcd ( i , j , j ) * 3 <NEWLINE> sum += gcd ( i , i , j ) * 3 <NEWLINE> <COMMENT> <NL> for k in range ( j + 1 , s + 1 ) : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 6 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( sum ) ) <NEWLINE> <NL>
def check ( a , b , c , d ) : <NEWLINE> <INDENT> while ( a > 0 and c > 0 ) : <NEWLINE> <INDENT> c -= b <NEWLINE> if ( c <= 0 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> a -= d <NEWLINE> if ( a <= 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> inp1 = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : 4 ] <NEWLINE> a , b , c , d = inp1 [ 0 ] , inp1 [ 1 ] , inp1 [ 2 ] , inp1 [ 3 ] <NEWLINE> if ( check ( a , b , c , d ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kari = set ( ) <NEWLINE> hako = set ( ) <NEWLINE> count = 1 <NEWLINE> cnt = 1 <NEWLINE> zahyo = 0 <NEWLINE> ans = 0 <NEWLINE> kari . add ( zahyo ) <NEWLINE> if K <= 10 ** 6 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = A [ ans ] - 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> zahyo = A [ zahyo ] - 1 <NEWLINE> if zahyo not in kari : <NEWLINE> <INDENT> kari . add ( zahyo ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> hako . add ( zahyo ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> zahyo = A [ zahyo ] - 1 <NEWLINE> if zahyo not in hako : <NEWLINE> <INDENT> hako . add ( zahyo ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> count = len ( kari ) <NEWLINE> cnt = len ( hako ) <NEWLINE> kaisu = K - count <NEWLINE> <COMMENT> <NL> if kaisu > N : <NEWLINE> <INDENT> kaisu = kaisu % cnt <NEWLINE> <DEDENT> for i in range ( kaisu ) : <NEWLINE> <INDENT> zahyo = A [ zahyo ] - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( zahyo + 1 ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> y = x - i <NEWLINE> if y not in a : <NEWLINE> <INDENT> ans = y <NEWLINE> break <NEWLINE> <DEDENT> z = x + i <NEWLINE> if z not in a : <NEWLINE> <INDENT> ans = z <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> def _tsundoku ( n , m , k , a , b ) : <NEWLINE> <INDENT> a_temp = tuple ( accumulate ( a , initial = 0 ) ) <NEWLINE> b_temp = tuple ( accumulate ( b , initial = 0 ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> b_index = m <NEWLINE> for a_index in range ( n + 1 ) : <NEWLINE> <INDENT> if a_temp [ a_index ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a_temp [ a_index ] + b_temp [ b_index ] > k : <NEWLINE> <INDENT> b_index -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , a_index + b_index ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def tsundoku ( f ) : <NEWLINE> <INDENT> readline = f . readline <NEWLINE> n , m , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> return _tsundoku ( n , m , k , a , b ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = tsundoku ( sys . stdin . buffer ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def parse ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pc = { i : ( pi - 1 , ci ) for i , ( pi , ci ) in enumerate ( zip ( p , c ) ) } <NEWLINE> return k , pc <NEWLINE> <NL> <NL> <DEDENT> def split_simple ( ) : <NEWLINE> <INDENT> k , pc = parse ( ) <NEWLINE> lst = [ [ ] ] <NEWLINE> lst [ 0 ] . append ( pc . pop ( 0 ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if not pc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p , _ = lst [ - 1 ] [ - 1 ] <NEWLINE> if p in pc : <NEWLINE> <INDENT> pcj = pc . pop ( p ) <NEWLINE> lst [ - 1 ] . append ( pcj ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = next ( iter ( pc . keys ( ) ) ) <NEWLINE> pcj = pc . pop ( j ) <NEWLINE> lst . append ( [ pcj ] ) <NEWLINE> <DEDENT> <DEDENT> return k , [ np . array ( [ ls [ 1 ] for ls in lst_ ] , dtype = np . long ) for lst_ in lst ] <NEWLINE> <NL> <NL> <DEDENT> def inner ( n , k , s , sim ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if sim . shape [ 1 ] == 1 : <NEWLINE> <INDENT> return sim . max ( ) <NEWLINE> <DEDENT> if k < n or s <= 0 : <NEWLINE> <INDENT> return sim . max ( ) <NEWLINE> <DEDENT> div = k // n <NEWLINE> mod = k % n <NEWLINE> <COMMENT> <NL> if mod == 0 : <NEWLINE> <INDENT> return max ( s * div , s * ( div - 1 ) + sim . max ( ) ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> return max ( s * div + sim [ : , : mod ] . max ( ) , s * ( div - 1 ) + sim [ : , : mod ] . max ( ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( mod ) <NEWLINE> print ( sim ) <NEWLINE> print ( sim . shape ) <NEWLINE> raise <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k , data_set = split_simple ( ) <NEWLINE> result = min ( [ d . min ( ) for d in data_set ] ) <NEWLINE> for data in data_set : <NEWLINE> <INDENT> n = data . size <NEWLINE> rep = np . repeat ( data [ None ] , 2 , axis = 0 ) . flatten ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sim = np . array ( [ np . cumsum ( rep [ i : i + min ( k , n ) ] ) for i in range ( n ) ] ) <NEWLINE> <COMMENT> <NL> cand = inner ( n , k , data . sum ( ) , sim ) <NEWLINE> result = max ( result , cand ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> t = int ( x , 2 ) <NEWLINE> c = x . count ( <STRING> ) <NEWLINE> a = t % - ~ c <NEWLINE> b = 0 if c < 2 else t % ~ - c <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if int ( x [ i ] ) : <NEWLINE> <INDENT> if c < 2 : print ( 0 ) ; continue <NEWLINE> else : t = ( b - pow ( 2 , n - i - 1 , c - 1 ) ) % ~ - c <NEWLINE> <DEDENT> else : t = ( a + pow ( 2 , n - i - 1 , c + 1 ) ) % - ~ c <NEWLINE> z = 1 <NEWLINE> while t : <NEWLINE> <INDENT> d = bin ( t ) . count ( <STRING> ) <NEWLINE> t %= d <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( z ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> t = list ( map ( lambda x : list ( x ) , itertools . product ( [ i + 1 for i in range ( k ) ] , repeat = 2 ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> cu = math . gcd ( t [ i ] [ 0 ] , t [ i ] [ 1 ] ) <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( j , cu ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 2 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 4 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <NL> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] + s [ j ] + s [ k ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> import math <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> com = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( c [ i ] <= 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> com += combinations_count ( c [ i ] , 2 ) <NEWLINE> <DEDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = com <NEWLINE> ans -= c [ a [ k - 1 ] ] - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = tuple ( map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 0 ] * n <NEWLINE> next_town = 0 <NEWLINE> order = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if visited [ next_town ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> order . append ( next_town ) <NEWLINE> visited [ next_town ] = 1 <NEWLINE> next_town = a [ next_town ] <NEWLINE> <NL> <DEDENT> first_loop = len ( order ) <NEWLINE> offset = order . index ( next_town ) <NEWLINE> second_loop = first_loop - offset <NEWLINE> <NL> if k < first_loop : <NEWLINE> <INDENT> print ( order [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( order [ offset + ( k - first_loop ) % second_loop ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> from collections import defaultdict , deque , Counter , OrderedDict <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from functools import reduce , lru_cache <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> <NL> import itertools <NEWLINE> import math , fractions <NEWLINE> import sys , copy <NEWLINE> <NL> def L ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def SL ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI1 ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def R ( n ) : return [ sys . stdin . readline ( ) . strip ( ) for _ in range ( n ) ] <NEWLINE> def LR ( n ) : return [ L ( ) for _ in range ( n ) ] <NEWLINE> def IR ( n ) : return [ I ( ) for _ in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def LIR1 ( n ) : return [ LI1 ( ) for _ in range ( n ) ] <NEWLINE> def SLR ( n ) : return [ SL ( ) for _ in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> <NL> def perm ( n , r ) : return math . factorial ( n ) // math . factorial ( r ) <NEWLINE> def comb ( n , r ) : return math . factorial ( n ) // ( math . factorial ( r ) * math . factorial ( n - r ) ) <NEWLINE> <NL> def make_list ( n , * args , default = 0 ) : return [ make_list ( * args , default = default ) for _ in range ( n ) ] if args else [ default for _ in range ( n ) ] <NEWLINE> <NL> dire = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> dire8 = [ [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] ] <NEWLINE> alphabets = <STRING> <NEWLINE> ALPHABETS = <STRING> <NEWLINE> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class MaxFlowGraph : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . graph = [ [ ] for _ in range ( N ) ] <NEWLINE> self . capacities = [ defaultdict ( int ) for _ in range ( N ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , v , w , cap = 1 ) : <NEWLINE> <INDENT> self . graph [ v ] . append ( w ) <NEWLINE> self . graph [ w ] . append ( v ) <NEWLINE> self . capacities [ v ] [ w ] = cap <NEWLINE> <NL> <DEDENT> def bfs ( self , s , t ) : <NEWLINE> <INDENT> self . level = [ - 1 ] * self . N <NEWLINE> q = [ s ] <NEWLINE> self . level [ s ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> nq = [ ] <NEWLINE> for v in q : <NEWLINE> <INDENT> for w , cap in self . capacities [ v ] . items ( ) : <NEWLINE> <INDENT> if cap and self . level [ w ] == - 1 : <NEWLINE> <INDENT> self . level [ w ] = self . level [ v ] + 1 <NEWLINE> if w == t : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> nq . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = nq <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def dfs ( self , s , t , up ) : <NEWLINE> <INDENT> st = [ t ] <NEWLINE> while st : <NEWLINE> <INDENT> v = st [ - 1 ] <NEWLINE> if v == s : <NEWLINE> <INDENT> flow = min ( up , min ( self . capacities [ st [ i + 1 ] ] [ st [ i ] ] for i in range ( len ( st ) - 2 ) ) ) <NEWLINE> for i in range ( len ( st ) - 1 ) : <NEWLINE> <INDENT> self . capacities [ st [ i ] ] [ st [ i + 1 ] ] += flow <NEWLINE> self . capacities [ st [ i + 1 ] ] [ st [ i ] ] -= flow <NEWLINE> <DEDENT> return flow <NEWLINE> <COMMENT> <NL> <DEDENT> while self . it [ v ] < len ( self . graph [ v ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> w = self . graph [ v ] [ self . it [ v ] ] <NEWLINE> cap = self . capacities [ w ] [ v ] <NEWLINE> if cap and self . level [ w ] != - 1 : <NEWLINE> <INDENT> if self . level [ v ] > self . level [ w ] : <NEWLINE> <INDENT> st . append ( w ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> self . it [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . pop ( ) <NEWLINE> self . level [ v ] = self . N <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def flow ( self , s , t , flow_limit = 18446744073709551615 ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while flow < flow_limit and self . bfs ( s , t ) : <NEWLINE> <INDENT> self . it = [ 0 ] * self . N <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> f = self . dfs ( s , t , flow_limit - flow ) <NEWLINE> if not f : break <NEWLINE> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> def min_cut ( self , s ) : <NEWLINE> <INDENT> visited = [ False ] * self . N <NEWLINE> q = [ s ] <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> visited [ v ] = True <NEWLINE> for w , cap in self . capacities [ v ] . items ( ) : <NEWLINE> <INDENT> if cap and not visited [ w ] : <NEWLINE> <INDENT> q . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> S = SLR ( N ) <NEWLINE> g = MaxFlowGraph ( N * M + 2 ) <NEWLINE> <NL> s = N * M <NEWLINE> t = N * M + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( y + x ) % 2 == 0 : <NEWLINE> <INDENT> g . add_edge ( s , M * y + x ) <NEWLINE> for dy , dx in [ [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < N and 0 <= nx < M and S [ y ] [ x ] == <STRING> and S [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( M * y + x , M * ny + nx ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> g . add_edge ( M * y + x , t ) <NEWLINE> for dy , dx in [ [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < N and 0 <= nx < M and S [ y ] [ x ] == <STRING> and S [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( M * ny + nx , M * y + x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( g . flow ( s , t ) ) <NEWLINE> <NL> <COMMENT> <NL> for u in range ( N * M + 2 ) : <NEWLINE> <INDENT> uy , ux = divmod ( u , M ) <NEWLINE> if ( uy + ux ) % 2 == 1 : continue <NEWLINE> <NL> for v , cap in g . capacities [ u ] . items ( ) : <NEWLINE> <INDENT> if cap != 0 : continue <NEWLINE> vy , vx = divmod ( v , M ) <NEWLINE> if u != s and u != t and v != s and v != t : <NEWLINE> <INDENT> if uy - 1 == vy : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif uy + 1 == vy : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif ux + 1 == vx : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif ux - 1 == vx : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in S : <NEWLINE> <INDENT> print ( <STRING> . join ( p ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> idx = 1 <NEWLINE> S = [ idx ] <NEWLINE> ed = set ( [ idx ] ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> idx = A [ idx - 1 ] <NEWLINE> if idx in ed : <NEWLINE> <INDENT> start = S . index ( idx ) <NEWLINE> end = len ( S ) <NEWLINE> n = start + ( K - start ) % ( end - start ) <NEWLINE> print ( S [ n ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( idx ) <NEWLINE> ed . add ( idx ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( idx ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> sum1 = 1 <NEWLINE> <NL> if <STRING> in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> sum1 = sum1 * int ( b [ i ] ) <NEWLINE> if sum1 > 10 ** 18 : <NEWLINE> <INDENT> sum1 = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> if S [ : N // 2 ] == S [ N // 2 + 1 : ] [ : : - 1 ] : <NEWLINE> <INDENT> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( N // 2 ) % 2 == 1 : <NEWLINE> <INDENT> if S [ : ( N // 2 ) // 2 ] == S [ ( N // 2 ) // 2 + 1 : N // 2 ] [ : : - 1 ] and S [ N // 2 + 1 : - ( N // 2 ) // 2 ] == S [ - ( N // 2 ) // 2 + 1 : ] [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ : ( N // 2 ) // 2 ] == S [ ( N // 2 ) // 2 : N // 2 ] [ : : - 1 ] and S [ N // 2 + 1 : - ( N // 2 ) // 2 ] == S [ - ( N // 2 ) // 2 : ] [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> temp = 0 <NEWLINE> res = 0 <NEWLINE> <NL> if ( b - 1 ) > n : <NEWLINE> <INDENT> x = n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = ( b - 1 ) <NEWLINE> <NL> <DEDENT> res = math . floor ( ( a * x ) / b ) - a * math . floor ( x / b ) <NEWLINE> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> num_eas = s . count ( <STRING> ) <NEWLINE> <NL> <NL> res = [ ] <NEWLINE> res += [ num_eas - s [ 0 ] . count ( <STRING> ) ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> res += [ res [ i - 1 ] + s [ i - 1 ] . count ( <STRING> ) - s [ i ] . count ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> print ( min ( res ) ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> for i in itertools . combinations_with_replacement ( range ( m ) , n ) : <NEWLINE> <INDENT> anss = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if i [ b - 1 ] - i [ a - 1 ] == c : anss += d <NEWLINE> <DEDENT> ans = max ( ans , anss ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , <NEWLINE> <INDENT> 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , <NEWLINE> 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( a [ n - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from itertools import accumulate <NEWLINE> a = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( b ) ) <NEWLINE> from bisect import bisect_right <NEWLINE> c = bisect_right ( a , k ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> ans = max ( ans , i + bisect_right ( b , k - a [ i ] ) - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> max_A = A [ - 1 ] <NEWLINE> arr = [ 0 ] * ( max_A + 1 ) <NEWLINE> <NL> for val in A : <NEWLINE> <INDENT> arr [ val ] += 1 <NEWLINE> if arr [ val ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * val , max_A + 1 , val ) : <NEWLINE> <INDENT> arr [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( arr . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> namelist = [ ] <NEWLINE> name = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> namelist . append ( chr ( ord ( <STRING> ) + n % 26 ) ) <NEWLINE> n = int ( n / 26 ) <NEWLINE> <DEDENT> for i in namelist [ : : - 1 ] : <NEWLINE> <INDENT> name += i <NEWLINE> <DEDENT> print ( name ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> count = [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> i = a [ i ] - 1 <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( sum ( count ) ) <NEWLINE> break <NEWLINE> <DEDENT> if count [ i ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = set ( [ ] ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> if ( item in A ) == False : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> A . add ( item ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> if len ( s ) <= 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> chk = [ 0 ] * 2019 <NEWLINE> for i , si in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> c += int ( si ) * pow ( 10 , i , 2019 ) <NEWLINE> chk [ c % 2019 ] += 1 <NEWLINE> <DEDENT> ans = chk [ 0 ] <NEWLINE> for i in chk : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def e_bomber ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> H , W , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> bomb_row = [ 0 ] * H <NEWLINE> bomb_col = [ 0 ] * W <NEWLINE> bomb_pos = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> r , c = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> bomb_row [ r ] += 1 <NEWLINE> bomb_col [ c ] += 1 <NEWLINE> bomb_pos . add ( ( r , c ) ) <NEWLINE> <NL> <DEDENT> bomb_row_max = max ( bomb_row ) <NEWLINE> bomb_col_max = max ( bomb_col ) <NEWLINE> row_index_list = [ r for r , v in enumerate ( bomb_row ) if v == bomb_row_max ] <NEWLINE> col_index_list = [ c for c , v in enumerate ( bomb_col ) if v == bomb_col_max ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for row in row_index_list : <NEWLINE> <INDENT> for col in col_index_list : <NEWLINE> <INDENT> if ( row , col ) not in bomb_pos : <NEWLINE> <INDENT> return bomb_row_max + bomb_col_max <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return bomb_row_max + bomb_col_max - 1 <NEWLINE> <NL> <DEDENT> print ( e_bomber ( ) ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations <NEWLINE> from itertools import permutations <NEWLINE> from math import factorial <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> xy = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in xy : <NEWLINE> <INDENT> for j in xy : <NEWLINE> <INDENT> cnt += np . linalg . norm ( i - j ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt / N ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n_line = int ( input ( ) ) <NEWLINE> input_list = [ tuple ( input ( ) . split ( ) ) for i in range ( n_line ) ] <NEWLINE> l = set ( [ ] ) <NEWLINE> for c , s in input_list : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> l . add ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P . sort ( ) <NEWLINE> print ( sum ( P [ : K ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> towns = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( <STRING> ) ) ) <NEWLINE> assert len ( towns ) == N <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> L = None <NEWLINE> visited = set ( [ ] ) <NEWLINE> current = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> current = towns [ current ] <NEWLINE> K -= 1 <NEWLINE> if current in visited : <NEWLINE> <INDENT> L = 0 <NEWLINE> tcurrent = current <NEWLINE> while 1 : <NEWLINE> <INDENT> tcurrent = towns [ tcurrent ] <NEWLINE> L += 1 <NEWLINE> if tcurrent == current : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> visited . add ( current ) <NEWLINE> <NL> <DEDENT> if L is not None : <NEWLINE> <INDENT> K = K % L <NEWLINE> <COMMENT> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> current = towns [ current ] <NEWLINE> <DEDENT> <DEDENT> print ( current + 1 ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> def merge ( A , B ) : <NEWLINE> <INDENT> ans = [ 0 ] * ( len ( A ) + len ( B ) ) <NEWLINE> count = i = j = 0 <NEWLINE> A += [ 10 ** 9 + 1 ] <NEWLINE> B += [ 10 ** 9 + 1 ] <NEWLINE> for k in range ( len ( ans ) ) : <NEWLINE> <INDENT> if A [ i ] < B [ j ] : <NEWLINE> <INDENT> ans [ k ] = A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ k ] = B [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> return ( ans , count ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> div = deque ( [ S ] ) <NEWLINE> mer = deque ( ) <NEWLINE> count = 0 <NEWLINE> while ( len ( div ) > 0 ) : <NEWLINE> <INDENT> d = div . pop ( ) <NEWLINE> if ( len ( d ) > 2 ) : <NEWLINE> <INDENT> mid = len ( d ) // 2 <NEWLINE> div . appendleft ( d [ : mid ] ) <NEWLINE> div . appendleft ( d [ mid : ] ) <NEWLINE> <DEDENT> elif ( len ( d ) == 2 ) : <NEWLINE> <INDENT> if d [ 0 ] > d [ 1 ] : <NEWLINE> <INDENT> mer . appendleft ( d [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mer . appendleft ( d ) <NEWLINE> <DEDENT> count += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mer . appendleft ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> while ( len ( mer ) > 1 ) : <NEWLINE> <INDENT> A = mer . popleft ( ) <NEWLINE> B = mer . popleft ( ) <NEWLINE> ret = merge ( A , B ) <NEWLINE> mer . append ( ret [ 0 ] ) <NEWLINE> count += ret [ 1 ] <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in ret [ 0 ] : <NEWLINE> <INDENT> ans += str ( i ) + <STRING> <NEWLINE> <DEDENT> print ( ans [ : - 1 ] ) <NEWLINE> print ( count ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) + 1 <NEWLINE> goke = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i , K ) : <NEWLINE> <INDENT> for k in range ( j , K ) : <NEWLINE> <INDENT> if i == j and i == k : <NEWLINE> <INDENT> goke = goke + i <NEWLINE> <DEDENT> elif ( i == j and i < k ) or ( i < j and j == k ) : <NEWLINE> <INDENT> goke = goke + 3 * math . gcd ( i , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> goke = goke + 6 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( goke ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n , m , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> aa = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> bb = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> asum = [ 0 ] * n <NEWLINE> bsum = [ 0 ] * m <NEWLINE> asum [ 0 ] = aa [ 0 ] <NEWLINE> bsum [ 0 ] = bb [ 0 ] <NEWLINE> mp = n - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> asum [ i ] = ( aa [ i ] + asum [ i - 1 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> bsum [ i ] = ( bb [ i ] + bsum [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = bsum [ i - 1 ] <NEWLINE> <DEDENT> while mp >= 0 : <NEWLINE> <INDENT> if asum [ mp ] + x <= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mp -= 1 <NEWLINE> <DEDENT> <DEDENT> if mp >= 0 : <NEWLINE> <INDENT> if asum [ mp ] + x <= k : <NEWLINE> <INDENT> ans = max ( i + mp + 1 , ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x <= k : <NEWLINE> <INDENT> ans = max ( i , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> k = int ( math . log10 ( n ) ) <NEWLINE> <NL> a = n // ( 10 ** k ) <NEWLINE> b = n % ( 10 ** k ) <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> ans = n <NEWLINE> <DEDENT> elif n % 10 == 9 : <NEWLINE> <INDENT> ans = k * 9 + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k * 9 + a - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> if nums [ 0 ] < nums [ 3 ] : <NEWLINE> <INDENT> max = nums [ 0 ] <NEWLINE> if nums [ 0 ] + nums [ 1 ] < nums [ 3 ] : <NEWLINE> <INDENT> max -= ( nums [ 3 ] - ( nums [ 0 ] + nums [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max = nums [ 3 ] <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> S = [ int ( s ) for s in S ] <NEWLINE> S = S [ : : - 1 ] <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> index = 0 <NEWLINE> tmp = 0 <NEWLINE> z = 1 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> tmp += s * pow ( 10 , i , 2019 ) <NEWLINE> l [ tmp % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> ans = l [ 0 ] <NEWLINE> <NL> for v in l : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> def IS ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def II ( ) : return int ( IS ( ) ) <NEWLINE> def MII ( ) : return list ( map ( int , IS ( ) . split ( ) ) ) <NEWLINE> def MIIZ ( ) : return list ( map ( lambda x : x - 1 , MII ( ) ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : return x <NEWLINE> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <DEDENT> def count_member_nums ( self ) : <NEWLINE> <INDENT> return [ len ( self . members ( r ) ) for r in self . roots ( ) ] <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = MII ( ) <NEWLINE> group = [ MIIZ ( ) for _ in range ( m ) ] <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for a , b in group : <NEWLINE> <INDENT> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( abs ( sorted ( uf . parents ) [ 0 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> C = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , C [ i ] ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for x in lst : <NEWLINE> <INDENT> s = s * x <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> Y = 2 * int ( X ** ( 1 / 5 ) ) + 1 <NEWLINE> for A in range ( - Y , Y ) : <NEWLINE> <INDENT> for B in range ( - Y , Y ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> return A , B <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A , B = main ( ) <NEWLINE> print ( <STRING> . format ( A , B ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> def CHK ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( i + A [ i ] ) <NEWLINE> <DEDENT> L_Cnt = Counter ( L ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> chk = i - A [ i ] <NEWLINE> cnt += L_Cnt [ chk ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> CHK ( ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = np . array ( readline ( ) . split ( ) , np . uint64 ) <NEWLINE> T = np . array ( readline ( ) . split ( ) , np . uint64 ) <NEWLINE> U = np . array ( readline ( ) . split ( ) , np . uint64 ) <NEWLINE> V = np . array ( readline ( ) . split ( ) , np . uint64 ) <NEWLINE> <NL> <NL> def solve ( S , T , U , V ) : <NEWLINE> <INDENT> A = np . zeros ( ( N , N ) , np . uint64 ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return np . array ( [ [ U [ 0 ] ] ] , np . uint64 ) <NEWLINE> <DEDENT> all_one_row = ( S == 0 ) & ( U == 1 ) <NEWLINE> all_zero_row = ( S == 1 ) & ( U == 0 ) <NEWLINE> r = np . any ( all_zero_row ) , np . any ( all_one_row ) <NEWLINE> all_one_col = ( T == 0 ) & ( V == 1 ) <NEWLINE> all_zero_col = ( T == 1 ) & ( V == 0 ) <NEWLINE> c = np . any ( all_zero_col ) , np . any ( all_one_col ) <NEWLINE> if ( c [ 0 ] or c [ 1 ] ) and not ( r [ 0 ] or r [ 1 ] ) : <NEWLINE> <INDENT> return solve ( T , S , V , U ) . T <NEWLINE> <COMMENT> <NL> <DEDENT> if not ( r [ 0 ] or r [ 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> A [ 1 : : 2 , : : 2 ] = 1 <NEWLINE> A [ : : 2 , 1 : : 2 ] = 1 <NEWLINE> return A <NEWLINE> <COMMENT> <NL> <DEDENT> if r [ 0 ] and r [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> A += U [ : , None ] <NEWLINE> return A <NEWLINE> <DEDENT> if r [ 0 ] : <NEWLINE> <INDENT> if c [ 1 ] : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> if c [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> A += 1 <NEWLINE> A [ all_zero_row , : ] = 0 <NEWLINE> A [ : , all_zero_col ] = 0 <NEWLINE> return A <NEWLINE> <COMMENT> <NL> <DEDENT> if np . any ( U == 1 ) : <NEWLINE> <INDENT> A += U [ : , None ] <NEWLINE> return A <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if np . any ( V == 0 ) : <NEWLINE> <INDENT> A += V [ None , : ] <NEWLINE> A [ all_zero_row ] = 0 <NEWLINE> return A <NEWLINE> <DEDENT> if N - 1 <= np . count_nonzero ( all_zero_row ) : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> ind = np . where ( ~ all_zero_row ) [ 0 ] <NEWLINE> A [ ind [ 0 ] , 0 ] = 1 <NEWLINE> A [ ind [ - 1 ] , 1 : ] = 1 <NEWLINE> return A <NEWLINE> <DEDENT> if r [ 1 ] : <NEWLINE> <INDENT> if c [ 0 ] : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> if c [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> A [ all_one_row , : ] = 1 <NEWLINE> A [ : , all_one_col ] = 1 <NEWLINE> return A <NEWLINE> <COMMENT> <NL> <DEDENT> if np . any ( U == 0 ) : <NEWLINE> <INDENT> A += U [ : , None ] <NEWLINE> return A <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if np . any ( V == 1 ) : <NEWLINE> <INDENT> A += V [ None , : ] <NEWLINE> A [ all_one_row ] = 1 <NEWLINE> return A <NEWLINE> <DEDENT> if N - 1 <= np . count_nonzero ( all_one_row ) : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> A += 1 <NEWLINE> ind = np . where ( ~ all_one_row ) [ 0 ] <NEWLINE> A [ ind [ 0 ] , 0 ] = 0 <NEWLINE> A [ ind [ - 1 ] , 1 : ] = 0 <NEWLINE> return A <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def test ( S , T , U , V , A ) : <NEWLINE> <INDENT> row_or = np . bitwise_or . reduce ( A , axis = 1 ) <NEWLINE> row_and = np . bitwise_and . reduce ( A , axis = 1 ) <NEWLINE> cond_row = np . all ( U [ S == 0 ] == row_and [ S == 0 ] ) and np . all ( U [ S == 1 ] == row_or [ S == 1 ] ) <NEWLINE> col_or = np . bitwise_or . reduce ( A , axis = 0 ) <NEWLINE> col_and = np . bitwise_and . reduce ( A , axis = 0 ) <NEWLINE> cond_col = np . all ( V [ T == 0 ] == col_and [ T == 0 ] ) and np . all ( V [ T == 1 ] == col_or [ T == 1 ] ) <NEWLINE> return cond_row and cond_col <NEWLINE> <NL> <NL> <DEDENT> A = np . zeros ( ( N , N ) , np . uint64 ) <NEWLINE> for k in range ( 64 ) : <NEWLINE> <INDENT> A ^= solve ( S , T , ( U >> k ) & 1 , ( V >> k ) & 1 ) << k <NEWLINE> <NL> <DEDENT> if not test ( S , T , U , V , A ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( <STRING> . join ( row ) for row in A . astype ( str ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = input ( ) <NEWLINE> <NL> if N != 0 : <NEWLINE> <NL> <INDENT> p_list = [ int ( n ) for n in p . split ( ) ] <NEWLINE> <NL> X_near = np . array ( list ( range ( int ( np . ceil ( X - N / 2 - 1 ) ) , int ( np . floor ( X + N / 2 ) ) + 2 ) ) ) <NEWLINE> <NL> remain_list = [ ] <NEWLINE> <NL> for i in X_near : <NEWLINE> <INDENT> if i not in p_list : <NEWLINE> <INDENT> remain_list . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> remain_array = np . array ( remain_list ) <NEWLINE> min_bool = np . abs ( X - remain_array ) . min ( ) == np . abs ( X - remain_array ) <NEWLINE> print ( remain_array [ min_bool ] . min ( ) ) <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> A_mod = [ a % MOD for a in A ] <NEWLINE> <NL> R = sum ( A_mod ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in A_mod : <NEWLINE> <INDENT> R -= a <NEWLINE> ans = ( ans + a % MOD * R % MOD ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = <STRING> <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( line ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = max ( a ) <NEWLINE> <COMMENT> <NL> lis = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> lis [ j ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if lis [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : break <NEWLINE> print ( statistics . pstdev ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT>
N , M , X = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> CA = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> mcost = 10 ** 10 <NEWLINE> <NL> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> learn = [ 0 ] * M <NEWLINE> cost = 0 <NEWLINE> bn = str ( bin ( i ) ) [ 2 : ] . zfill ( N ) <NEWLINE> <COMMENT> <NL> for j , b in enumerate ( bn ) : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> cost += CA [ j ] [ 0 ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> learn [ m ] += CA [ j ] [ m + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> learn . sort ( ) <NEWLINE> <COMMENT> <NL> if learn [ 0 ] >= X : <NEWLINE> <INDENT> mcost = min ( mcost , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if mcost == 10 ** 10 : <NEWLINE> <INDENT> mcost = - 1 <NEWLINE> <NL> <DEDENT> print ( mcost ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> x = y = 10 <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for i , j in [ input ( ) . split ( ) for _ in range ( int ( input ( ) ) ) ] : <NEWLINE> <INDENT> for _ in range ( int ( j ) ) : <NEWLINE> <INDENT> if <STRING> <= i <= <STRING> : y += 1 if i == <STRING> else - 1 <NEWLINE> else : x += 1 if i == <STRING> else - 1 <NEWLINE> if [ x , y ] in b : del b [ b . index ( [ x , y ] ) ] <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ bool ( b ) ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> L = 10 ** 6 + 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ 0 ] * L <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> memo [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , L ) : <NEWLINE> <INDENT> if sum ( memo [ i : : i ] ) > 1 : <NEWLINE> <INDENT> if reduce ( math . gcd , a_list ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def main ( self ) : <NEWLINE> <INDENT> return max ( [ len ( self . members ( r ) ) for r in self . roots ( ) ] ) <NEWLINE> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> print ( - min ( uf . parents ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> mod = 7 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if mod % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> mod = ( mod * 10 + 7 ) % k <NEWLINE> <NL> <DEDENT> if mod % k == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) [ : : - 1 ] <NEWLINE> <NL> sum_of_digits = 0 <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> <NL> cnts [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> sum_of_digits += int ( s [ i ] ) * d <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> sum_of_digits %= 2019 <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis = [ i for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if lis [ i ] == i : <NEWLINE> <INDENT> lis [ i ] = i <NEWLINE> for j in range ( i ** 2 , n + 1 , i ) : <NEWLINE> <INDENT> if lis [ j ] == j : <NEWLINE> <INDENT> lis [ j ] = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def bunkai ( m ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> now = lis [ m ] <NEWLINE> cnt = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> m = m // lis [ m ] <NEWLINE> if now == lis [ m ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> now = lis [ m ] <NEWLINE> <NL> <DEDENT> if m == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> yaku = bunkai ( i ) <NEWLINE> for i in yaku : <NEWLINE> <INDENT> tmp *= ( i + 1 ) <NEWLINE> <DEDENT> ans += tmp <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for l in range ( Q ) ] <NEWLINE> <NL> l = [ 0 ] * 10 ** 6 <NEWLINE> tot = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ A [ i ] ] += 1 <NEWLINE> tot += A [ i ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> s0 = S [ i ] [ 0 ] <NEWLINE> s1 = S [ i ] [ 1 ] <NEWLINE> tot += s1 * ( l [ s0 ] + l [ s1 ] ) - ( s0 * l [ s0 ] + s1 * l [ s1 ] ) <NEWLINE> l [ s1 ] += l [ s0 ] <NEWLINE> l [ s0 ] = 0 <NEWLINE> print ( tot ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> def run ( ) : <NEWLINE> <INDENT> N , M = map ( int , sysread ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> AB = list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> A = AB [ : : 2 ] <NEWLINE> B = AB [ 1 : : 2 ] <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> seen = [ False ] * ( N + 1 ) <NEWLINE> queue = deque ( [ ] ) <NEWLINE> seen [ 1 ] = True <NEWLINE> queue . append ( ( 1 , 0 ) ) <COMMENT> <NEWLINE> mark = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> current , prev = queue . popleft ( ) <NEWLINE> for next in to [ current ] : <NEWLINE> <INDENT> if not seen [ next ] : <NEWLINE> <INDENT> queue . append ( ( next , current ) ) <NEWLINE> mark [ next ] = current <NEWLINE> seen [ next ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> mark = [ str ( val ) for val in mark ] <NEWLINE> print ( <STRING> . join ( mark [ 2 : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def check_sekisairyo ( p_min ) : <NEWLINE> <INDENT> p_now = 0 <NEWLINE> k_now = 0 <NEWLINE> for w in w_i : <NEWLINE> <INDENT> p_now += w <NEWLINE> if p_now > p_min : <NEWLINE> <INDENT> p_now = w <NEWLINE> k_now += 1 <NEWLINE> <DEDENT> elif p_now == p_min : <NEWLINE> <INDENT> p_now = 0 <NEWLINE> k_now += 1 <NEWLINE> <DEDENT> if k_now == k and p_now != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w_i = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> left , right , p_min = max ( w_i ) , sum ( w_i ) , 0 <NEWLINE> while left < right : <NEWLINE> <INDENT> p_min = ( left + right ) // 2 <NEWLINE> if check_sekisairyo ( p_min ) : <NEWLINE> <INDENT> right = p_min <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = p_min = p_min + 1 <NEWLINE> <DEDENT> <DEDENT> print ( p_min ) <NEWLINE>
import math <NEWLINE> <NL> def prime ( a ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> n = 2 <NEWLINE> while n <= math . sqrt ( a ) : <NEWLINE> <INDENT> if a % n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> count += prime ( a ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ - 1 for _ in range ( n ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> pos = 0 <NEWLINE> que = deque ( [ ] ) <NEWLINE> if g [ 0 ] : <NEWLINE> <INDENT> visited [ 0 ] = 0 <NEWLINE> for nx in g [ 0 ] : <NEWLINE> <INDENT> que . append ( ( nx , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> while que : <NEWLINE> <INDENT> to , now = que . popleft ( ) <NEWLINE> if visited [ to ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ to ] = now <NEWLINE> for nx in g [ to ] : <NEWLINE> <INDENT> que . append ( ( nx , to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> visited = visited [ 1 : ] <NEWLINE> if - 1 in visited : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for k in visited : <NEWLINE> <INDENT> print ( k + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> apartment = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> apartment [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> if ( b != 0 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , apartment [ b ] [ f ] ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( enumerate ( a ) ) <NEWLINE> c = sorted ( b , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <NL> print ( * [ c [ i ] [ 0 ] + 1 for i in range ( n ) ] ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = r * g * b <NEWLINE> <NL> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j - i + j <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> r = [ 0 ] * N <NEWLINE> r [ 0 ] = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> r [ i ] = r [ i - 1 ] + a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s += a [ i ] * ( r [ N - 1 ] - r [ i ] ) <NEWLINE> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_list = sorted ( p_list ) <NEWLINE> all_range = list ( range ( 102 ) ) <NEWLINE> A = [ i for i in all_range if i not in p_list ] <NEWLINE> B = [ abs ( i - X ) for i in A ] <NEWLINE> <NL> low = X - min ( B ) <NEWLINE> high = X + min ( B ) <NEWLINE> <NL> output = 0 <NEWLINE> if high > 101 : <NEWLINE> <INDENT> output = low <NEWLINE> <DEDENT> if low < 0 : <NEWLINE> <INDENT> output = high <NEWLINE> <NL> <DEDENT> if output != 0 : <NEWLINE> <INDENT> print ( output ) <NEWLINE> <DEDENT> elif high in p_list : <NEWLINE> <INDENT> print ( low ) <NEWLINE> <DEDENT> elif low in p_list : <NEWLINE> <INDENT> print ( high ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( low ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> value = 0 <NEWLINE> index = 0 <NEWLINE> hashmap = dict ( ) <NEWLINE> while value < int ( 1e18 ) + 1 : <NEWLINE> <INDENT> value = pow ( index , 5 ) <NEWLINE> hashmap [ value ] = index <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> b1 = x + int ( pow ( i , 5 ) ) <NEWLINE> b2 = x + int ( pow ( - i , 5 ) ) <NEWLINE> <COMMENT> <NL> if hashmap . get ( b1 ) != None : <NEWLINE> <INDENT> print ( hashmap [ b1 ] , i ) <NEWLINE> break <NEWLINE> <DEDENT> if hashmap . get ( b2 ) != None : <NEWLINE> <INDENT> print ( hashmap [ b2 ] , - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
dic = dict ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> t = a . split ( ) <NEWLINE> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic [ t [ 1 ] ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ 1 ] in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> cnt = collections . defaultdict ( int ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> key = math . gcd ( i , j ) <NEWLINE> <COMMENT> <NL> cnt [ key ] = cnt [ key ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = 0 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for key in cnt . keys ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> total = total + math . gcd ( k , key ) * cnt [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> def f ( x , y ) : <NEWLINE> <INDENT> x , y = min ( x , y ) , max ( x , y ) <NEWLINE> while y % x != 0 : <NEWLINE> <INDENT> z = y % x <NEWLINE> y = x <NEWLINE> x = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> <DEDENT> def ff ( a , b , c ) : <NEWLINE> <INDENT> return f ( c , f ( a , b ) ) <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for k in range ( j , k + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += ff ( i , j , k ) <NEWLINE> <DEDENT> elif ( i == j ) or ( j == k ) : <NEWLINE> <INDENT> ans += 3 * ff ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * ff ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ _ for _ in range ( n + 1 ) ] <NEWLINE> <NL> tmp_min = sum ( l [ 0 : k ] ) <NEWLINE> tmp_max = sum ( l [ - 1 : - k - 1 : - 1 ] ) <NEWLINE> x = tmp_max - tmp_min + 1 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> tmp_min += l [ k + i ] <NEWLINE> tmp_max += l [ - k - i - 1 ] <NEWLINE> x += tmp_max - tmp_min + 1 <NEWLINE> <NL> <DEDENT> print ( x % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 0 ] * 10 ** 5 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> l [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = l [ b - 1 ] <NEWLINE> l [ b - 1 ] = 0 <NEWLINE> l [ c - 1 ] += tmp <NEWLINE> <NL> ans += tmp * ( c - b ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> <NL> <NL> def counting_sort ( A , max_occurance ) : <NEWLINE> <INDENT> result = [ 0 ] * array_length <NEWLINE> count_list = [ 0 ] * max_occurance <NEWLINE> <NL> for j in range ( array_length ) : <NEWLINE> <INDENT> count_list [ A [ j ] ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 1 , max_occurance ) : <NEWLINE> <INDENT> count_list [ i ] += count_list [ i - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for m in array [ : : - 1 ] : <NEWLINE> <INDENT> result [ count_list [ m ] - 1 ] = m <NEWLINE> count_list [ m ] -= 1 <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> array = list ( map ( int , _input [ 1 ] . split ( ) ) ) <NEWLINE> assert len ( array ) == array_length <NEWLINE> max_elem = int ( 1e4 ) <NEWLINE> result = counting_sort ( A = array , max_occurance = max_elem ) <NEWLINE> print ( * result ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> def Eratosthenes ( x ) : <NEWLINE> <INDENT> lis = [ int ( i ) for i in range ( 2 , x ) ] <NEWLINE> <COMMENT> <NL> res = list ( ) <NEWLINE> while lis : <NEWLINE> <INDENT> a = lis . pop ( 0 ) <NEWLINE> res . append ( a ) <NEWLINE> lis = [ i for i in lis if i % a != 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> lis = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 , 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 , 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 , 13513 , 13523 , 13537 , 13553 , 13567 , 13577 , 13591 , 13597 , 13613 , 13619 , 13627 , 13633 , 13649 , 13669 , 13679 , 13681 , 13687 , 13691 , 13693 , 13697 , 13709 , 13711 , 13721 , 13723 , 13729 , 13751 , 13757 , 13759 , 13763 , 13781 , 13789 , 13799 , 13807 , 13829 , 13831 , 13841 , 13859 , 13873 , 13877 , 13879 , 13883 , 13901 , 13903 , 13907 , 13913 , 13921 , 13931 , 13933 , 13963 , 13967 , 13997 , 13999 , 14009 , 14011 , 14029 , 14033 , 14051 , 14057 , 14071 , 14081 , 14083 , 14087 , 14107 , 14143 , 14149 , 14153 , 14159 , 14173 , 14177 , 14197 , 14207 , 14221 , 14243 , 14249 , 14251 , 14281 , 14293 , 14303 , 14321 , 14323 , 14327 , 14341 , 14347 , 14369 , 14387 , 14389 , 14401 , 14407 , 14411 , 14419 , 14423 , 14431 , 14437 , 14447 , 14449 , 14461 , 14479 , 14489 , 14503 , 14519 , 14533 , 14537 , 14543 , 14549 , 14551 , 14557 , 14561 , 14563 , 14591 , 14593 , 14621 , 14627 , 14629 , 14633 , 14639 , 14653 , 14657 , 14669 , 14683 , 14699 , 14713 , 14717 , 14723 , 14731 , 14737 , 14741 , 14747 , 14753 , 14759 , 14767 , 14771 , 14779 , 14783 , 14797 , 14813 , 14821 , 14827 , 14831 , 14843 , 14851 , 14867 , 14869 , 14879 , 14887 , 14891 , 14897 , 14923 , 14929 , 14939 , 14947 , 14951 , 14957 , 14969 , 14983 , 15013 , 15017 , 15031 , 15053 , 15061 , 15073 , 15077 , 15083 , 15091 , 15101 , 15107 , 15121 , 15131 , 15137 , 15139 , 15149 , 15161 , 15173 , 15187 , 15193 , 15199 , 15217 , 15227 , 15233 , 15241 , 15259 , 15263 , 15269 , 15271 , 15277 , 15287 , 15289 , 15299 , 15307 , 15313 , 15319 , 15329 , 15331 , 15349 , 15359 , 15361 , 15373 , 15377 , 15383 , 15391 , 15401 , 15413 , 15427 , 15439 , 15443 , 15451 , 15461 , 15467 , 15473 , 15493 , 15497 , 15511 , 15527 , 15541 , 15551 , 15559 , 15569 , 15581 , 15583 , 15601 , 15607 , 15619 , 15629 , 15641 , 15643 , 15647 , 15649 , 15661 , 15667 , 15671 , 15679 , 15683 , 15727 , 15731 , 15733 , 15737 , 15739 , 15749 , 15761 , 15767 , 15773 , 15787 , 15791 , 15797 , 15803 , 15809 , 15817 , 15823 , 15859 , 15877 , 15881 , 15887 , 15889 , 15901 , 15907 , 15913 , 15919 , 15923 , 15937 , 15959 , 15971 , 15973 , 15991 , 16001 , 16007 , 16033 , 16057 , 16061 , 16063 , 16067 , 16069 , 16073 , 16087 , 16091 , 16097 , 16103 , 16111 , 16127 , 16139 , 16141 , 16183 , 16187 , 16189 , 16193 , 16217 , 16223 , 16229 , 16231 , 16249 , 16253 , 16267 , 16273 , 16301 , 16319 , 16333 , 16339 , 16349 , 16361 , 16363 , 16369 , 16381 , 16411 , 16417 , 16421 , 16427 , 16433 , 16447 , 16451 , 16453 , 16477 , 16481 , 16487 , 16493 , 16519 , 16529 , 16547 , 16553 , 16561 , 16567 , 16573 , 16603 , 16607 , 16619 , 16631 , 16633 , 16649 , 16651 , 16657 , 16661 , 16673 , 16691 , 16693 , 16699 , 16703 , 16729 , 16741 , 16747 , 16759 , 16763 , 16787 , 16811 , 16823 , 16829 , 16831 , 16843 , 16871 , 16879 , 16883 , 16889 , 16901 , 16903 , 16921 , 16927 , 16931 , 16937 , 16943 , 16963 , 16979 , 16981 , 16987 , 16993 , 17011 , 17021 , 17027 , 17029 , 17033 , 17041 , 17047 , 17053 , 17077 , 17093 , 17099 , 17107 , 17117 , 17123 , 17137 , 17159 , 17167 , 17183 , 17189 , 17191 , 17203 , 17207 , 17209 , 17231 , 17239 , 17257 , 17291 , 17293 , 17299 , 17317 , 17321 , 17327 , 17333 , 17341 , 17351 , 17359 , 17377 , 17383 , 17387 , 17389 , 17393 , 17401 , 17417 , 17419 , 17431 , 17443 , 17449 , 17467 , 17471 , 17477 , 17483 , 17489 , 17491 , 17497 , 17509 , 17519 , 17539 , 17551 , 17569 , 17573 , 17579 , 17581 , 17597 , 17599 , 17609 , 17623 , 17627 , 17657 , 17659 , 17669 , 17681 , 17683 , 17707 , 17713 , 17729 , 17737 , 17747 , 17749 , 17761 , 17783 , 17789 , 17791 , 17807 , 17827 , 17837 , 17839 , 17851 , 17863 , 17881 , 17891 , 17903 , 17909 , 17911 , 17921 , 17923 , 17929 , 17939 , 17957 , 17959 , 17971 , 17977 , 17981 , 17987 , 17989 , 18013 , 18041 , 18043 , 18047 , 18049 , 18059 , 18061 , 18077 , 18089 , 18097 , 18119 , 18121 , 18127 , 18131 , 18133 , 18143 , 18149 , 18169 , 18181 , 18191 , 18199 , 18211 , 18217 , 18223 , 18229 , 18233 , 18251 , 18253 , 18257 , 18269 , 18287 , 18289 , 18301 , 18307 , 18311 , 18313 , 18329 , 18341 , 18353 , 18367 , 18371 , 18379 , 18397 , 18401 , 18413 , 18427 , 18433 , 18439 , 18443 , 18451 , 18457 , 18461 , 18481 , 18493 , 18503 , 18517 , 18521 , 18523 , 18539 , 18541 , 18553 , 18583 , 18587 , 18593 , 18617 , 18637 , 18661 , 18671 , 18679 , 18691 , 18701 , 18713 , 18719 , 18731 , 18743 , 18749 , 18757 , 18773 , 18787 , 18793 , 18797 , 18803 , 18839 , 18859 , 18869 , 18899 , 18911 , 18913 , 18917 , 18919 , 18947 , 18959 , 18973 , 18979 , 19001 , 19009 , 19013 , 19031 , 19037 , 19051 , 19069 , 19073 , 19079 , 19081 , 19087 , 19121 , 19139 , 19141 , 19157 , 19163 , 19181 , 19183 , 19207 , 19211 , 19213 , 19219 , 19231 , 19237 , 19249 , 19259 , 19267 , 19273 , 19289 , 19301 , 19309 , 19319 , 19333 , 19373 , 19379 , 19381 , 19387 , 19391 , 19403 , 19417 , 19421 , 19423 , 19427 , 19429 , 19433 , 19441 , 19447 , 19457 , 19463 , 19469 , 19471 , 19477 , 19483 , 19489 , 19501 , 19507 , 19531 , 19541 , 19543 , 19553 , 19559 , 19571 , 19577 , 19583 , 19597 , 19603 , 19609 , 19661 , 19681 , 19687 , 19697 , 19699 , 19709 , 19717 , 19727 , 19739 , 19751 , 19753 , 19759 , 19763 , 19777 , 19793 , 19801 , 19813 , 19819 , 19841 , 19843 , 19853 , 19861 , 19867 , 19889 , 19891 , 19913 , 19919 , 19927 , 19937 , 19949 , 19961 , 19963 , 19973 , 19979 , 19991 , 19993 , 19997 , 20011 , 20021 , 20023 , 20029 , 20047 , 20051 , 20063 , 20071 , 20089 , 20101 , 20107 , 20113 , 20117 , 20123 , 20129 , 20143 , 20147 , 20149 , 20161 , 20173 , 20177 , 20183 , 20201 , 20219 , 20231 , 20233 , 20249 , 20261 , 20269 , 20287 , 20297 , 20323 , 20327 , 20333 , 20341 , 20347 , 20353 , 20357 , 20359 , 20369 , 20389 , 20393 , 20399 , 20407 , 20411 , 20431 , 20441 , 20443 , 20477 , 20479 , 20483 , 20507 , 20509 , 20521 , 20533 , 20543 , 20549 , 20551 , 20563 , 20593 , 20599 , 20611 , 20627 , 20639 , 20641 , 20663 , 20681 , 20693 , 20707 , 20717 , 20719 , 20731 , 20743 , 20747 , 20749 , 20753 , 20759 , 20771 , 20773 , 20789 , 20807 , 20809 , 20849 , 20857 , 20873 , 20879 , 20887 , 20897 , 20899 , 20903 , 20921 , 20929 , 20939 , 20947 , 20959 , 20963 , 20981 , 20983 , 21001 , 21011 , 21013 , 21017 , 21019 , 21023 , 21031 , 21059 , 21061 , 21067 , 21089 , 21101 , 21107 , 21121 , 21139 , 21143 , 21149 , 21157 , 21163 , 21169 , 21179 , 21187 , 21191 , 21193 , 21211 , 21221 , 21227 , 21247 , 21269 , 21277 , 21283 , 21313 , 21317 , 21319 , 21323 , 21341 , 21347 , 21377 , 21379 , 21383 , 21391 , 21397 , 21401 , 21407 , 21419 , 21433 , 21467 , 21481 , 21487 , 21491 , 21493 , 21499 , 21503 , 21517 , 21521 , 21523 , 21529 , 21557 , 21559 , 21563 , 21569 , 21577 , 21587 , 21589 , 21599 , 21601 , 21611 , 21613 , 21617 , 21647 , 21649 , 21661 , 21673 , 21683 , 21701 , 21713 , 21727 , 21737 , 21739 , 21751 , 21757 , 21767 , 21773 , 21787 , 21799 , 21803 , 21817 , 21821 , 21839 , 21841 , 21851 , 21859 , 21863 , 21871 , 21881 , 21893 , 21911 , 21929 , 21937 , 21943 , 21961 , 21977 , 21991 , 21997 , 22003 , 22013 , 22027 , 22031 , 22037 , 22039 , 22051 , 22063 , 22067 , 22073 , 22079 , 22091 , 22093 , 22109 , 22111 , 22123 , 22129 , 22133 , 22147 , 22153 , 22157 , 22159 , 22171 , 22189 , 22193 , 22229 , 22247 , 22259 , 22271 , 22273 , 22277 , 22279 , 22283 , 22291 , 22303 , 22307 , 22343 , 22349 , 22367 , 22369 , 22381 , 22391 , 22397 , 22409 , 22433 , 22441 , 22447 , 22453 , 22469 , 22481 , 22483 , 22501 , 22511 , 22531 , 22541 , 22543 , 22549 , 22567 , 22571 , 22573 , 22613 , 22619 , 22621 , 22637 , 22639 , 22643 , 22651 , 22669 , 22679 , 22691 , 22697 , 22699 , 22709 , 22717 , 22721 , 22727 , 22739 , 22741 , 22751 , 22769 , 22777 , 22783 , 22787 , 22807 , 22811 , 22817 , 22853 , 22859 , 22861 , 22871 , 22877 , 22901 , 22907 , 22921 , 22937 , 22943 , 22961 , 22963 , 22973 , 22993 , 23003 , 23011 , 23017 , 23021 , 23027 , 23029 , 23039 , 23041 , 23053 , 23057 , 23059 , 23063 , 23071 , 23081 , 23087 , 23099 , 23117 , 23131 , 23143 , 23159 , 23167 , 23173 , 23189 , 23197 , 23201 , 23203 , 23209 , 23227 , 23251 , 23269 , 23279 , 23291 , 23293 , 23297 , 23311 , 23321 , 23327 , 23333 , 23339 , 23357 , 23369 , 23371 , 23399 , 23417 , 23431 , 23447 , 23459 , 23473 , 23497 , 23509 , 23531 , 23537 , 23539 , 23549 , 23557 , 23561 , 23563 , 23567 , 23581 , 23593 , 23599 , 23603 , 23609 , 23623 , 23627 , 23629 , 23633 , 23663 , 23669 , 23671 , 23677 , 23687 , 23689 , 23719 , 23741 , 23743 , 23747 , 23753 , 23761 , 23767 , 23773 , 23789 , 23801 , 23813 , 23819 , 23827 , 23831 , 23833 , 23857 , 23869 , 23873 , 23879 , 23887 , 23893 , 23899 , 23909 , 23911 , 23917 , 23929 , 23957 , 23971 , 23977 , 23981 , 23993 , 24001 , 24007 , 24019 , 24023 , 24029 , 24043 , 24049 , 24061 , 24071 , 24077 , 24083 , 24091 , 24097 , 24103 , 24107 , 24109 , 24113 , 24121 , 24133 , 24137 , 24151 , 24169 , 24179 , 24181 , 24197 , 24203 , 24223 , 24229 , 24239 , 24247 , 24251 , 24281 , 24317 , 24329 , 24337 , 24359 , 24371 , 24373 , 24379 , 24391 , 24407 , 24413 , 24419 , 24421 , 24439 , 24443 , 24469 , 24473 , 24481 , 24499 , 24509 , 24517 , 24527 , 24533 , 24547 , 24551 , 24571 , 24593 , 24611 , 24623 , 24631 , 24659 , 24671 , 24677 , 24683 , 24691 , 24697 , 24709 , 24733 , 24749 , 24763 , 24767 , 24781 , 24793 , 24799 , 24809 , 24821 , 24841 , 24847 , 24851 , 24859 , 24877 , 24889 , 24907 , 24917 , 24919 , 24923 , 24943 , 24953 , 24967 , 24971 , 24977 , 24979 , 24989 , 25013 , 25031 , 25033 , 25037 , 25057 , 25073 , 25087 , 25097 , 25111 , 25117 , 25121 , 25127 , 25147 , 25153 , 25163 , 25169 , 25171 , 25183 , 25189 , 25219 , 25229 , 25237 , 25243 , 25247 , 25253 , 25261 , 25301 , 25303 , 25307 , 25309 , 25321 , 25339 , 25343 , 25349 , 25357 , 25367 , 25373 , 25391 , 25409 , 25411 , 25423 , 25439 , 25447 , 25453 , 25457 , 25463 , 25469 , 25471 , 25523 , 25537 , 25541 , 25561 , 25577 , 25579 , 25583 , 25589 , 25601 , 25603 , 25609 , 25621 , 25633 , 25639 , 25643 , 25657 , 25667 , 25673 , 25679 , 25693 , 25703 , 25717 , 25733 , 25741 , 25747 , 25759 , 25763 , 25771 , 25793 , 25799 , 25801 , 25819 , 25841 , 25847 , 25849 , 25867 , 25873 , 25889 , 25903 , 25913 , 25919 , 25931 , 25933 , 25939 , 25943 , 25951 , 25969 , 25981 , 25997 , 25999 , 26003 , 26017 , 26021 , 26029 , 26041 , 26053 , 26083 , 26099 , 26107 , 26111 , 26113 , 26119 , 26141 , 26153 , 26161 , 26171 , 26177 , 26183 , 26189 , 26203 , 26209 , 26227 , 26237 , 26249 , 26251 , 26261 , 26263 , 26267 , 26293 , 26297 , 26309 , 26317 , 26321 , 26339 , 26347 , 26357 , 26371 , 26387 , 26393 , 26399 , 26407 , 26417 , 26423 , 26431 , 26437 , 26449 , 26459 , 26479 , 26489 , 26497 , 26501 , 26513 , 26539 , 26557 , 26561 , 26573 , 26591 , 26597 , 26627 , 26633 , 26641 , 26647 , 26669 , 26681 , 26683 , 26687 , 26693 , 26699 , 26701 , 26711 , 26713 , 26717 , 26723 , 26729 , 26731 , 26737 , 26759 , 26777 , 26783 , 26801 , 26813 , 26821 , 26833 , 26839 , 26849 , 26861 , 26863 , 26879 , 26881 , 26891 , 26893 , 26903 , 26921 , 26927 , 26947 , 26951 , 26953 , 26959 , 26981 , 26987 , 26993 , 27011 , 27017 , 27031 , 27043 , 27059 , 27061 , 27067 , 27073 , 27077 , 27091 , 27103 , 27107 , 27109 , 27127 , 27143 , 27179 , 27191 , 27197 , 27211 , 27239 , 27241 , 27253 , 27259 , 27271 , 27277 , 27281 , 27283 , 27299 , 27329 , 27337 , 27361 , 27367 , 27397 , 27407 , 27409 , 27427 , 27431 , 27437 , 27449 , 27457 , 27479 , 27481 , 27487 , 27509 , 27527 , 27529 , 27539 , 27541 , 27551 , 27581 , 27583 , 27611 , 27617 , 27631 , 27647 , 27653 , 27673 , 27689 , 27691 , 27697 , 27701 , 27733 , 27737 , 27739 , 27743 , 27749 , 27751 , 27763 , 27767 , 27773 , 27779 , 27791 , 27793 , 27799 , 27803 , 27809 , 27817 , 27823 , 27827 , 27847 , 27851 , 27883 , 27893 , 27901 , 27917 , 27919 , 27941 , 27943 , 27947 , 27953 , 27961 , 27967 , 27983 , 27997 , 28001 , 28019 , 28027 , 28031 , 28051 , 28057 , 28069 , 28081 , 28087 , 28097 , 28099 , 28109 , 28111 , 28123 , 28151 , 28163 , 28181 , 28183 , 28201 , 28211 , 28219 , 28229 , 28277 , 28279 , 28283 , 28289 , 28297 , 28307 , 28309 , 28319 , 28349 , 28351 , 28387 , 28393 , 28403 , 28409 , 28411 , 28429 , 28433 , 28439 , 28447 , 28463 , 28477 , 28493 , 28499 , 28513 , 28517 , 28537 , 28541 , 28547 , 28549 , 28559 , 28571 , 28573 , 28579 , 28591 , 28597 , 28603 , 28607 , 28619 , 28621 , 28627 , 28631 , 28643 , 28649 , 28657 , 28661 , 28663 , 28669 , 28687 , 28697 , 28703 , 28711 , 28723 , 28729 , 28751 , 28753 , 28759 , 28771 , 28789 , 28793 , 28807 , 28813 , 28817 , 28837 , 28843 , 28859 , 28867 , 28871 , 28879 , 28901 , 28909 , 28921 , 28927 , 28933 , 28949 , 28961 , 28979 , 29009 , 29017 , 29021 , 29023 , 29027 , 29033 , 29059 , 29063 , 29077 , 29101 , 29123 , 29129 , 29131 , 29137 , 29147 , 29153 , 29167 , 29173 , 29179 , 29191 , 29201 , 29207 , 29209 , 29221 , 29231 , 29243 , 29251 , 29269 , 29287 , 29297 , 29303 , 29311 , 29327 , 29333 , 29339 , 29347 , 29363 , 29383 , 29387 , 29389 , 29399 , 29401 , 29411 , 29423 , 29429 , 29437 , 29443 , 29453 , 29473 , 29483 , 29501 , 29527 , 29531 , 29537 , 29567 , 29569 , 29573 , 29581 , 29587 , 29599 , 29611 , 29629 , 29633 , 29641 , 29663 , 29669 , 29671 , 29683 , 29717 , 29723 , 29741 , 29753 , 29759 , 29761 , 29789 , 29803 , 29819 , 29833 , 29837 , 29851 , 29863 , 29867 , 29873 , 29879 , 29881 , 29917 , 29921 , 29927 , 29947 , 29959 , 29983 , 29989 , 30011 , 30013 , 30029 , 30047 , 30059 , 30071 , 30089 , 30091 , 30097 , 30103 , 30109 , 30113 , 30119 , 30133 , 30137 , 30139 , 30161 , 30169 , 30181 , 30187 , 30197 , 30203 , 30211 , 30223 , 30241 , 30253 , 30259 , 30269 , 30271 , 30293 , 30307 , 30313 , 30319 , 30323 , 30341 , 30347 , 30367 , 30389 , 30391 , 30403 , 30427 , 30431 , 30449 , 30467 , 30469 , 30491 , 30493 , 30497 , 30509 , 30517 , 30529 , 30539 , 30553 , 30557 , 30559 , 30577 , 30593 , 30631 , 30637 , 30643 , 30649 , 30661 , 30671 , 30677 , 30689 , 30697 , 30703 , 30707 , 30713 , 30727 , 30757 , 30763 , 30773 , 30781 , 30803 , 30809 , 30817 , 30829 , 30839 , 30841 , 30851 , 30853 , 30859 , 30869 , 30871 , 30881 , 30893 , 30911 , 30931 , 30937 , 30941 , 30949 , 30971 , 30977 , 30983 , 31013 , 31019 , 31033 , 31039 , 31051 , 31063 , 31069 , 31079 , 31081 , 31091 , 31121 , 31123 , 31139 , 31147 , 31151 , 31153 , 31159 , 31177 , 31181 , 31183 , 31189 , 31193 , 31219 , 31223 , 31231 , 31237 , 31247 , 31249 , 31253 , 31259 , 31267 , 31271 , 31277 , 31307 , 31319 , 31321 , 31327 , 31333 , 31337 , 31357 , 31379 , 31387 , 31391 , 31393 , 31397 , 31469 , 31477 , 31481 , 31489 , 31511 , 31513 , 31517 , 31531 , 31541 , 31543 , 31547 , 31567 , 31573 , 31583 , 31601 , 31607 , 31627 , 31643 , 31649 , 31657 , 31663 , 31667 , 31687 , 31699 , 31721 , 31723 , 31727 , 31729 , 31741 , 31751 , 31769 , 31771 , 31793 , 31799 , 31817 , 31847 , 31849 , 31859 , 31873 , 31883 , 31891 , 31907 , 31957 , 31963 , 31973 , 31981 , 31991 , 32003 , 32009 , 32027 , 32029 , 32051 , 32057 , 32059 , 32063 , 32069 , 32077 , 32083 , 32089 , 32099 , 32117 , 32119 , 32141 , 32143 , 32159 , 32173 , 32183 , 32189 , 32191 , 32203 , 32213 , 32233 , 32237 , 32251 , 32257 , 32261 , 32297 , 32299 , 32303 , 32309 , 32321 , 32323 , 32327 , 32341 , 32353 , 32359 , 32363 , 32369 , 32371 , 32377 , 32381 , 32401 , 32411 , 32413 , 32423 , 32429 , 32441 , 32443 , 32467 , 32479 , 32491 , 32497 , 32503 , 32507 , 32531 , 32533 , 32537 , 32561 , 32563 , 32569 , 32573 , 32579 , 32587 , 32603 , 32609 , 32611 , 32621 , 32633 , 32647 , 32653 , 32687 , 32693 , 32707 , 32713 , 32717 , 32719 , 32749 , 32771 , 32779 , 32783 , 32789 , 32797 , 32801 , 32803 , 32831 , 32833 , 32839 , 32843 , 32869 , 32887 , 32909 , 32911 , 32917 , 32933 , 32939 , 32941 , 32957 , 32969 , 32971 , 32983 , 32987 , 32993 , 32999 , 33013 , 33023 , 33029 , 33037 , 33049 , 33053 , 33071 , 33073 , 33083 , 33091 , 33107 , 33113 , 33119 , 33149 , 33151 , 33161 , 33179 , 33181 , 33191 , 33199 , 33203 , 33211 , 33223 , 33247 , 33287 , 33289 , 33301 , 33311 , 33317 , 33329 , 33331 , 33343 , 33347 , 33349 , 33353 , 33359 , 33377 , 33391 , 33403 , 33409 , 33413 , 33427 , 33457 , 33461 , 33469 , 33479 , 33487 , 33493 , 33503 , 33521 , 33529 , 33533 , 33547 , 33563 , 33569 , 33577 , 33581 , 33587 , 33589 , 33599 , 33601 , 33613 , 33617 , 33619 , 33623 , 33629 , 33637 , 33641 , 33647 , 33679 , 33703 , 33713 , 33721 , 33739 , 33749 , 33751 , 33757 , 33767 , 33769 , 33773 , 33791 , 33797 , 33809 , 33811 , 33827 , 33829 , 33851 , 33857 , 33863 , 33871 , 33889 , 33893 , 33911 , 33923 , 33931 , 33937 , 33941 , 33961 , 33967 , 33997 , 34019 , 34031 , 34033 , 34039 , 34057 , 34061 , 34123 , 34127 , 34129 , 34141 , 34147 , 34157 , 34159 , 34171 , 34183 , 34211 , 34213 , 34217 , 34231 , 34253 , 34259 , 34261 , 34267 , 34273 , 34283 , 34297 , 34301 , 34303 , 34313 , 34319 , 34327 , 34337 , 34351 , 34361 , 34367 , 34369 , 34381 , 34403 , 34421 , 34429 , 34439 , 34457 , 34469 , 34471 , 34483 , 34487 , 34499 , 34501 , 34511 , 34513 , 34519 , 34537 , 34543 , 34549 , 34583 , 34589 , 34591 , 34603 , 34607 , 34613 , 34631 , 34649 , 34651 , 34667 , 34673 , 34679 , 34687 , 34693 , 34703 , 34721 , 34729 , 34739 , 34747 , 34757 , 34759 , 34763 , 34781 , 34807 , 34819 , 34841 , 34843 , 34847 , 34849 , 34871 , 34877 , 34883 , 34897 , 34913 , 34919 , 34939 , 34949 , 34961 , 34963 , 34981 , 35023 , 35027 , 35051 , 35053 , 35059 , 35069 , 35081 , 35083 , 35089 , 35099 , 35107 , 35111 , 35117 , 35129 , 35141 , 35149 , 35153 , 35159 , 35171 , 35201 , 35221 , 35227 , 35251 , 35257 , 35267 , 35279 , 35281 , 35291 , 35311 , 35317 , 35323 , 35327 , 35339 , 35353 , 35363 , 35381 , 35393 , 35401 , 35407 , 35419 , 35423 , 35437 , 35447 , 35449 , 35461 , 35491 , 35507 , 35509 , 35521 , 35527 , 35531 , 35533 , 35537 , 35543 , 35569 , 35573 , 35591 , 35593 , 35597 , 35603 , 35617 , 35671 , 35677 , 35729 , 35731 , 35747 , 35753 , 35759 , 35771 , 35797 , 35801 , 35803 , 35809 , 35831 , 35837 , 35839 , 35851 , 35863 , 35869 , 35879 , 35897 , 35899 , 35911 , 35923 , 35933 , 35951 , 35963 , 35969 , 35977 , 35983 , 35993 , 35999 , 36007 , 36011 , 36013 , 36017 , 36037 , 36061 , 36067 , 36073 , 36083 , 36097 , 36107 , 36109 , 36131 , 36137 , 36151 , 36161 , 36187 , 36191 , 36209 , 36217 , 36229 , 36241 , 36251 , 36263 , 36269 , 36277 , 36293 , 36299 , 36307 , 36313 , 36319 , 36341 , 36343 , 36353 , 36373 , 36383 , 36389 , 36433 , 36451 , 36457 , 36467 , 36469 , 36473 , 36479 , 36493 , 36497 , 36523 , 36527 , 36529 , 36541 , 36551 , 36559 , 36563 , 36571 , 36583 , 36587 , 36599 , 36607 , 36629 , 36637 , 36643 , 36653 , 36671 , 36677 , 36683 , 36691 , 36697 , 36709 , 36713 , 36721 , 36739 , 36749 , 36761 , 36767 , 36779 , 36781 , 36787 , 36791 , 36793 , 36809 , 36821 , 36833 , 36847 , 36857 , 36871 , 36877 , 36887 , 36899 , 36901 , 36913 , 36919 , 36923 , 36929 , 36931 , 36943 , 36947 , 36973 , 36979 , 36997 , 37003 , 37013 , 37019 , 37021 , 37039 , 37049 , 37057 , 37061 , 37087 , 37097 , 37117 , 37123 , 37139 , 37159 , 37171 , 37181 , 37189 , 37199 , 37201 , 37217 , 37223 , 37243 , 37253 , 37273 , 37277 , 37307 , 37309 , 37313 , 37321 , 37337 , 37339 , 37357 , 37361 , 37363 , 37369 , 37379 , 37397 , 37409 , 37423 , 37441 , 37447 , 37463 , 37483 , 37489 , 37493 , 37501 , 37507 , 37511 , 37517 , 37529 , 37537 , 37547 , 37549 , 37561 , 37567 , 37571 , 37573 , 37579 , 37589 , 37591 , 37607 , 37619 , 37633 , 37643 , 37649 , 37657 , 37663 , 37691 , 37693 , 37699 , 37717 , 37747 , 37781 , 37783 , 37799 , 37811 , 37813 , 37831 , 37847 , 37853 , 37861 , 37871 , 37879 , 37889 , 37897 , 37907 , 37951 , 37957 , 37963 , 37967 , 37987 , 37991 , 37993 , 37997 , 38011 , 38039 , 38047 , 38053 , 38069 , 38083 , 38113 , 38119 , 38149 , 38153 , 38167 , 38177 , 38183 , 38189 , 38197 , 38201 , 38219 , 38231 , 38237 , 38239 , 38261 , 38273 , 38281 , 38287 , 38299 , 38303 , 38317 , 38321 , 38327 , 38329 , 38333 , 38351 , 38371 , 38377 , 38393 , 38431 , 38447 , 38449 , 38453 , 38459 , 38461 , 38501 , 38543 , 38557 , 38561 , 38567 , 38569 , 38593 , 38603 , 38609 , 38611 , 38629 , 38639 , 38651 , 38653 , 38669 , 38671 , 38677 , 38693 , 38699 , 38707 , 38711 , 38713 , 38723 , 38729 , 38737 , 38747 , 38749 , 38767 , 38783 , 38791 , 38803 , 38821 , 38833 , 38839 , 38851 , 38861 , 38867 , 38873 , 38891 , 38903 , 38917 , 38921 , 38923 , 38933 , 38953 , 38959 , 38971 , 38977 , 38993 , 39019 , 39023 , 39041 , 39043 , 39047 , 39079 , 39089 , 39097 , 39103 , 39107 , 39113 , 39119 , 39133 , 39139 , 39157 , 39161 , 39163 , 39181 , 39191 , 39199 , 39209 , 39217 , 39227 , 39229 , 39233 , 39239 , 39241 , 39251 , 39293 , 39301 , 39313 , 39317 , 39323 , 39341 , 39343 , 39359 , 39367 , 39371 , 39373 , 39383 , 39397 , 39409 , 39419 , 39439 , 39443 , 39451 , 39461 , 39499 , 39503 , 39509 , 39511 , 39521 , 39541 , 39551 , 39563 , 39569 , 39581 , 39607 , 39619 , 39623 , 39631 , 39659 , 39667 , 39671 , 39679 , 39703 , 39709 , 39719 , 39727 , 39733 , 39749 , 39761 , 39769 , 39779 , 39791 , 39799 , 39821 , 39827 , 39829 , 39839 , 39841 , 39847 , 39857 , 39863 , 39869 , 39877 , 39883 , 39887 , 39901 , 39929 , 39937 , 39953 , 39971 , 39979 , 39983 , 39989 , 40009 , 40013 , 40031 , 40037 , 40039 , 40063 , 40087 , 40093 , 40099 , 40111 , 40123 , 40127 , 40129 , 40151 , 40153 , 40163 , 40169 , 40177 , 40189 , 40193 , 40213 , 40231 , 40237 , 40241 , 40253 , 40277 , 40283 , 40289 , 40343 , 40351 , 40357 , 40361 , 40387 , 40423 , 40427 , 40429 , 40433 , 40459 , 40471 , 40483 , 40487 , 40493 , 40499 , 40507 , 40519 , 40529 , 40531 , 40543 , 40559 , 40577 , 40583 , 40591 , 40597 , 40609 , 40627 , 40637 , 40639 , 40693 , 40697 , 40699 , 40709 , 40739 , 40751 , 40759 , 40763 , 40771 , 40787 , 40801 , 40813 , 40819 , 40823 , 40829 , 40841 , 40847 , 40849 , 40853 , 40867 , 40879 , 40883 , 40897 , 40903 , 40927 , 40933 , 40939 , 40949 , 40961 , 40973 , 40993 , 41011 , 41017 , 41023 , 41039 , 41047 , 41051 , 41057 , 41077 , 41081 , 41113 , 41117 , 41131 , 41141 , 41143 , 41149 , 41161 , 41177 , 41179 , 41183 , 41189 , 41201 , 41203 , 41213 , 41221 , 41227 , 41231 , 41233 , 41243 , 41257 , 41263 , 41269 , 41281 , 41299 , 41333 , 41341 , 41351 , 41357 , 41381 , 41387 , 41389 , 41399 , 41411 , 41413 , 41443 , 41453 , 41467 , 41479 , 41491 , 41507 , 41513 , 41519 , 41521 , 41539 , 41543 , 41549 , 41579 , 41593 , 41597 , 41603 , 41609 , 41611 , 41617 , 41621 , 41627 , 41641 , 41647 , 41651 , 41659 , 41669 , 41681 , 41687 , 41719 , 41729 , 41737 , 41759 , 41761 , 41771 , 41777 , 41801 , 41809 , 41813 , 41843 , 41849 , 41851 , 41863 , 41879 , 41887 , 41893 , 41897 , 41903 , 41911 , 41927 , 41941 , 41947 , 41953 , 41957 , 41959 , 41969 , 41981 , 41983 , 41999 , 42013 , 42017 , 42019 , 42023 , 42043 , 42061 , 42071 , 42073 , 42083 , 42089 , 42101 , 42131 , 42139 , 42157 , 42169 , 42179 , 42181 , 42187 , 42193 , 42197 , 42209 , 42221 , 42223 , 42227 , 42239 , 42257 , 42281 , 42283 , 42293 , 42299 , 42307 , 42323 , 42331 , 42337 , 42349 , 42359 , 42373 , 42379 , 42391 , 42397 , 42403 , 42407 , 42409 , 42433 , 42437 , 42443 , 42451 , 42457 , 42461 , 42463 , 42467 , 42473 , 42487 , 42491 , 42499 , 42509 , 42533 , 42557 , 42569 , 42571 , 42577 , 42589 , 42611 , 42641 , 42643 , 42649 , 42667 , 42677 , 42683 , 42689 , 42697 , 42701 , 42703 , 42709 , 42719 , 42727 , 42737 , 42743 , 42751 , 42767 , 42773 , 42787 , 42793 , 42797 , 42821 , 42829 , 42839 , 42841 , 42853 , 42859 , 42863 , 42899 , 42901 , 42923 , 42929 , 42937 , 42943 , 42953 , 42961 , 42967 , 42979 , 42989 , 43003 , 43013 , 43019 , 43037 , 43049 , 43051 , 43063 , 43067 , 43093 , 43103 , 43117 , 43133 , 43151 , 43159 , 43177 , 43189 , 43201 , 43207 , 43223 , 43237 , 43261 , 43271 , 43283 , 43291 , 43313 , 43319 , 43321 , 43331 , 43391 , 43397 , 43399 , 43403 , 43411 , 43427 , 43441 , 43451 , 43457 , 43481 , 43487 , 43499 , 43517 , 43541 , 43543 , 43573 , 43577 , 43579 , 43591 , 43597 , 43607 , 43609 , 43613 , 43627 , 43633 , 43649 , 43651 , 43661 , 43669 , 43691 , 43711 , 43717 , 43721 , 43753 , 43759 , 43777 , 43781 , 43783 , 43787 , 43789 , 43793 , 43801 , 43853 , 43867 , 43889 , 43891 , 43913 , 43933 , 43943 , 43951 , 43961 , 43963 , 43969 , 43973 , 43987 , 43991 , 43997 , 44017 , 44021 , 44027 , 44029 , 44041 , 44053 , 44059 , 44071 , 44087 , 44089 , 44101 , 44111 , 44119 , 44123 , 44129 , 44131 , 44159 , 44171 , 44179 , 44189 , 44201 , 44203 , 44207 , 44221 , 44249 , 44257 , 44263 , 44267 , 44269 , 44273 , 44279 , 44281 , 44293 , 44351 , 44357 , 44371 , 44381 , 44383 , 44389 , 44417 , 44449 , 44453 , 44483 , 44491 , 44497 , 44501 , 44507 , 44519 , 44531 , 44533 , 44537 , 44543 , 44549 , 44563 , 44579 , 44587 , 44617 , 44621 , 44623 , 44633 , 44641 , 44647 , 44651 , 44657 , 44683 , 44687 , 44699 , 44701 , 44711 , 44729 , 44741 , 44753 , 44771 , 44773 , 44777 , 44789 , 44797 , 44809 , 44819 , 44839 , 44843 , 44851 , 44867 , 44879 , 44887 , 44893 , 44909 , 44917 , 44927 , 44939 , 44953 , 44959 , 44963 , 44971 , 44983 , 44987 , 45007 , 45013 , 45053 , 45061 , 45077 , 45083 , 45119 , 45121 , 45127 , 45131 , 45137 , 45139 , 45161 , 45179 , 45181 , 45191 , 45197 , 45233 , 45247 , 45259 , 45263 , 45281 , 45289 , 45293 , 45307 , 45317 , 45319 , 45329 , 45337 , 45341 , 45343 , 45361 , 45377 , 45389 , 45403 , 45413 , 45427 , 45433 , 45439 , 45481 , 45491 , 45497 , 45503 , 45523 , 45533 , 45541 , 45553 , 45557 , 45569 , 45587 , 45589 , 45599 , 45613 , 45631 , 45641 , 45659 , 45667 , 45673 , 45677 , 45691 , 45697 , 45707 , 45737 , 45751 , 45757 , 45763 , 45767 , 45779 , 45817 , 45821 , 45823 , 45827 , 45833 , 45841 , 45853 , 45863 , 45869 , 45887 , 45893 , 45943 , 45949 , 45953 , 45959 , 45971 , 45979 , 45989 , 46021 , 46027 , 46049 , 46051 , 46061 , 46073 , 46091 , 46093 , 46099 , 46103 , 46133 , 46141 , 46147 , 46153 , 46171 , 46181 , 46183 , 46187 , 46199 , 46219 , 46229 , 46237 , 46261 , 46271 , 46273 , 46279 , 46301 , 46307 , 46309 , 46327 , 46337 , 46349 , 46351 , 46381 , 46399 , 46411 , 46439 , 46441 , 46447 , 46451 , 46457 , 46471 , 46477 , 46489 , 46499 , 46507 , 46511 , 46523 , 46549 , 46559 , 46567 , 46573 , 46589 , 46591 , 46601 , 46619 , 46633 , 46639 , 46643 , 46649 , 46663 , 46679 , 46681 , 46687 , 46691 , 46703 , 46723 , 46727 , 46747 , 46751 , 46757 , 46769 , 46771 , 46807 , 46811 , 46817 , 46819 , 46829 , 46831 , 46853 , 46861 , 46867 , 46877 , 46889 , 46901 , 46919 , 46933 , 46957 , 46993 , 46997 , 47017 , 47041 , 47051 , 47057 , 47059 , 47087 , 47093 , 47111 , 47119 , 47123 , 47129 , 47137 , 47143 , 47147 , 47149 , 47161 , 47189 , 47207 , 47221 , 47237 , 47251 , 47269 , 47279 , 47287 , 47293 , 47297 , 47303 , 47309 , 47317 , 47339 , 47351 , 47353 , 47363 , 47381 , 47387 , 47389 , 47407 , 47417 , 47419 , 47431 , 47441 , 47459 , 47491 , 47497 , 47501 , 47507 , 47513 , 47521 , 47527 , 47533 , 47543 , 47563 , 47569 , 47581 , 47591 , 47599 , 47609 , 47623 , 47629 , 47639 , 47653 , 47657 , 47659 , 47681 , 47699 , 47701 , 47711 , 47713 , 47717 , 47737 , 47741 , 47743 , 47777 , 47779 , 47791 , 47797 , 47807 , 47809 , 47819 , 47837 , 47843 , 47857 , 47869 , 47881 , 47903 , 47911 , 47917 , 47933 , 47939 , 47947 , 47951 , 47963 , 47969 , 47977 , 47981 , 48017 , 48023 , 48029 , 48049 , 48073 , 48079 , 48091 , 48109 , 48119 , 48121 , 48131 , 48157 , 48163 , 48179 , 48187 , 48193 , 48197 , 48221 , 48239 , 48247 , 48259 , 48271 , 48281 , 48299 , 48311 , 48313 , 48337 , 48341 , 48353 , 48371 , 48383 , 48397 , 48407 , 48409 , 48413 , 48437 , 48449 , 48463 , 48473 , 48479 , 48481 , 48487 , 48491 , 48497 , 48523 , 48527 , 48533 , 48539 , 48541 , 48563 , 48571 , 48589 , 48593 , 48611 , 48619 , 48623 , 48647 , 48649 , 48661 , 48673 , 48677 , 48679 , 48731 , 48733 , 48751 , 48757 , 48761 , 48767 , 48779 , 48781 , 48787 , 48799 , 48809 , 48817 , 48821 , 48823 , 48847 , 48857 , 48859 , 48869 , 48871 , 48883 , 48889 , 48907 , 48947 , 48953 , 48973 , 48989 , 48991 , 49003 , 49009 , 49019 , 49031 , 49033 , 49037 , 49043 , 49057 , 49069 , 49081 , 49103 , 49109 , 49117 , 49121 , 49123 , 49139 , 49157 , 49169 , 49171 , 49177 , 49193 , 49199 , 49201 , 49207 , 49211 , 49223 , 49253 , 49261 , 49277 , 49279 , 49297 , 49307 , 49331 , 49333 , 49339 , 49363 , 49367 , 49369 , 49391 , 49393 , 49409 , 49411 , 49417 , 49429 , 49433 , 49451 , 49459 , 49463 , 49477 , 49481 , 49499 , 49523 , 49529 , 49531 , 49537 , 49547 , 49549 , 49559 , 49597 , 49603 , 49613 , 49627 , 49633 , 49639 , 49663 , 49667 , 49669 , 49681 , 49697 , 49711 , 49727 , 49739 , 49741 , 49747 , 49757 , 49783 , 49787 , 49789 , 49801 , 49807 , 49811 , 49823 , 49831 , 49843 , 49853 , 49871 , 49877 , 49891 , 49919 , 49921 , 49927 , 49937 , 49939 , 49943 , 49957 , 49991 , 49993 , 49999 , 50021 , 50023 , 50033 , 50047 , 50051 , 50053 , 50069 , 50077 , 50087 , 50093 , 50101 , 50111 , 50119 , 50123 , 50129 , 50131 , 50147 , 50153 , 50159 , 50177 , 50207 , 50221 , 50227 , 50231 , 50261 , 50263 , 50273 , 50287 , 50291 , 50311 , 50321 , 50329 , 50333 , 50341 , 50359 , 50363 , 50377 , 50383 , 50387 , 50411 , 50417 , 50423 , 50441 , 50459 , 50461 , 50497 , 50503 , 50513 , 50527 , 50539 , 50543 , 50549 , 50551 , 50581 , 50587 , 50591 , 50593 , 50599 , 50627 , 50647 , 50651 , 50671 , 50683 , 50707 , 50723 , 50741 , 50753 , 50767 , 50773 , 50777 , 50789 , 50821 , 50833 , 50839 , 50849 , 50857 , 50867 , 50873 , 50891 , 50893 , 50909 , 50923 , 50929 , 50951 , 50957 , 50969 , 50971 , 50989 , 50993 , 51001 , 51031 , 51043 , 51047 , 51059 , 51061 , 51071 , 51109 , 51131 , 51133 , 51137 , 51151 , 51157 , 51169 , 51193 , 51197 , 51199 , 51203 , 51217 , 51229 , 51239 , 51241 , 51257 , 51263 , 51283 , 51287 , 51307 , 51329 , 51341 , 51343 , 51347 , 51349 , 51361 , 51383 , 51407 , 51413 , 51419 , 51421 , 51427 , 51431 , 51437 , 51439 , 51449 , 51461 , 51473 , 51479 , 51481 , 51487 , 51503 , 51511 , 51517 , 51521 , 51539 , 51551 , 51563 , 51577 , 51581 , 51593 , 51599 , 51607 , 51613 , 51631 , 51637 , 51647 , 51659 , 51673 , 51679 , 51683 , 51691 , 51713 , 51719 , 51721 , 51749 , 51767 , 51769 , 51787 , 51797 , 51803 , 51817 , 51827 , 51829 , 51839 , 51853 , 51859 , 51869 , 51871 , 51893 , 51899 , 51907 , 51913 , 51929 , 51941 , 51949 , 51971 , 51973 , 51977 , 51991 , 52009 , 52021 , 52027 , 52051 , 52057 , 52067 , 52069 , 52081 , 52103 , 52121 , 52127 , 52147 , 52153 , 52163 , 52177 , 52181 , 52183 , 52189 , 52201 , 52223 , 52237 , 52249 , 52253 , 52259 , 52267 , 52289 , 52291 , 52301 , 52313 , 52321 , 52361 , 52363 , 52369 , 52379 , 52387 , 52391 , 52433 , 52453 , 52457 , 52489 , 52501 , 52511 , 52517 , 52529 , 52541 , 52543 , 52553 , 52561 , 52567 , 52571 , 52579 , 52583 , 52609 , 52627 , 52631 , 52639 , 52667 , 52673 , 52691 , 52697 , 52709 , 52711 , 52721 , 52727 , 52733 , 52747 , 52757 , 52769 , 52783 , 52807 , 52813 , 52817 , 52837 , 52859 , 52861 , 52879 , 52883 , 52889 , 52901 , 52903 , 52919 , 52937 , 52951 , 52957 , 52963 , 52967 , 52973 , 52981 , 52999 , 53003 , 53017 , 53047 , 53051 , 53069 , 53077 , 53087 , 53089 , 53093 , 53101 , 53113 , 53117 , 53129 , 53147 , 53149 , 53161 , 53171 , 53173 , 53189 , 53197 , 53201 , 53231 , 53233 , 53239 , 53267 , 53269 , 53279 , 53281 , 53299 , 53309 , 53323 , 53327 , 53353 , 53359 , 53377 , 53381 , 53401 , 53407 , 53411 , 53419 , 53437 , 53441 , 53453 , 53479 , 53503 , 53507 , 53527 , 53549 , 53551 , 53569 , 53591 , 53593 , 53597 , 53609 , 53611 , 53617 , 53623 , 53629 , 53633 , 53639 , 53653 , 53657 , 53681 , 53693 , 53699 , 53717 , 53719 , 53731 , 53759 , 53773 , 53777 , 53783 , 53791 , 53813 , 53819 , 53831 , 53849 , 53857 , 53861 , 53881 , 53887 , 53891 , 53897 , 53899 , 53917 , 53923 , 53927 , 53939 , 53951 , 53959 , 53987 , 53993 , 54001 , 54011 , 54013 , 54037 , 54049 , 54059 , 54083 , 54091 , 54101 , 54121 , 54133 , 54139 , 54151 , 54163 , 54167 , 54181 , 54193 , 54217 , 54251 , 54269 , 54277 , 54287 , 54293 , 54311 , 54319 , 54323 , 54331 , 54347 , 54361 , 54367 , 54371 , 54377 , 54401 , 54403 , 54409 , 54413 , 54419 , 54421 , 54437 , 54443 , 54449 , 54469 , 54493 , 54497 , 54499 , 54503 , 54517 , 54521 , 54539 , 54541 , 54547 , 54559 , 54563 , 54577 , 54581 , 54583 , 54601 , 54617 , 54623 , 54629 , 54631 , 54647 , 54667 , 54673 , 54679 , 54709 , 54713 , 54721 , 54727 , 54751 , 54767 , 54773 , 54779 , 54787 , 54799 , 54829 , 54833 , 54851 , 54869 , 54877 , 54881 , 54907 , 54917 , 54919 , 54941 , 54949 , 54959 , 54973 , 54979 , 54983 , 55001 , 55009 , 55021 , 55049 , 55051 , 55057 , 55061 , 55073 , 55079 , 55103 , 55109 , 55117 , 55127 , 55147 , 55163 , 55171 , 55201 , 55207 , 55213 , 55217 , 55219 , 55229 , 55243 , 55249 , 55259 , 55291 , 55313 , 55331 , 55333 , 55337 , 55339 , 55343 , 55351 , 55373 , 55381 , 55399 , 55411 , 55439 , 55441 , 55457 , 55469 , 55487 , 55501 , 55511 , 55529 , 55541 , 55547 , 55579 , 55589 , 55603 , 55609 , 55619 , 55621 , 55631 , 55633 , 55639 , 55661 , 55663 , 55667 , 55673 , 55681 , 55691 , 55697 , 55711 , 55717 , 55721 , 55733 , 55763 , 55787 , 55793 , 55799 , 55807 , 55813 , 55817 , 55819 , 55823 , 55829 , 55837 , 55843 , 55849 , 55871 , 55889 , 55897 , 55901 , 55903 , 55921 , 55927 , 55931 , 55933 , 55949 , 55967 , 55987 , 55997 , 56003 , 56009 , 56039 , 56041 , 56053 , 56081 , 56087 , 56093 , 56099 , 56101 , 56113 , 56123 , 56131 , 56149 , 56167 , 56171 , 56179 , 56197 , 56207 , 56209 , 56237 , 56239 , 56249 , 56263 , 56267 , 56269 , 56299 , 56311 , 56333 , 56359 , 56369 , 56377 , 56383 , 56393 , 56401 , 56417 , 56431 , 56437 , 56443 , 56453 , 56467 , 56473 , 56477 , 56479 , 56489 , 56501 , 56503 , 56509 , 56519 , 56527 , 56531 , 56533 , 56543 , 56569 , 56591 , 56597 , 56599 , 56611 , 56629 , 56633 , 56659 , 56663 , 56671 , 56681 , 56687 , 56701 , 56711 , 56713 , 56731 , 56737 , 56747 , 56767 , 56773 , 56779 , 56783 , 56807 , 56809 , 56813 , 56821 , 56827 , 56843 , 56857 , 56873 , 56891 , 56893 , 56897 , 56909 , 56911 , 56921 , 56923 , 56929 , 56941 , 56951 , 56957 , 56963 , 56983 , 56989 , 56993 , 56999 , 57037 , 57041 , 57047 , 57059 , 57073 , 57077 , 57089 , 57097 , 57107 , 57119 , 57131 , 57139 , 57143 , 57149 , 57163 , 57173 , 57179 , 57191 , 57193 , 57203 , 57221 , 57223 , 57241 , 57251 , 57259 , 57269 , 57271 , 57283 , 57287 , 57301 , 57329 , 57331 , 57347 , 57349 , 57367 , 57373 , 57383 , 57389 , 57397 , 57413 , 57427 , 57457 , 57467 , 57487 , 57493 , 57503 , 57527 , 57529 , 57557 , 57559 , 57571 , 57587 , 57593 , 57601 , 57637 , 57641 , 57649 , 57653 , 57667 , 57679 , 57689 , 57697 , 57709 , 57713 , 57719 , 57727 , 57731 , 57737 , 57751 , 57773 , 57781 , 57787 , 57791 , 57793 , 57803 , 57809 , 57829 , 57839 , 57847 , 57853 , 57859 , 57881 , 57899 , 57901 , 57917 , 57923 , 57943 , 57947 , 57973 , 57977 , 57991 , 58013 , 58027 , 58031 , 58043 , 58049 , 58057 , 58061 , 58067 , 58073 , 58099 , 58109 , 58111 , 58129 , 58147 , 58151 , 58153 , 58169 , 58171 , 58189 , 58193 , 58199 , 58207 , 58211 , 58217 , 58229 , 58231 , 58237 , 58243 , 58271 , 58309 , 58313 , 58321 , 58337 , 58363 , 58367 , 58369 , 58379 , 58391 , 58393 , 58403 , 58411 , 58417 , 58427 , 58439 , 58441 , 58451 , 58453 , 58477 , 58481 , 58511 , 58537 , 58543 , 58549 , 58567 , 58573 , 58579 , 58601 , 58603 , 58613 , 58631 , 58657 , 58661 , 58679 , 58687 , 58693 , 58699 , 58711 , 58727 , 58733 , 58741 , 58757 , 58763 , 58771 , 58787 , 58789 , 58831 , 58889 , 58897 , 58901 , 58907 , 58909 , 58913 , 58921 , 58937 , 58943 , 58963 , 58967 , 58979 , 58991 , 58997 , 59009 , 59011 , 59021 , 59023 , 59029 , 59051 , 59053 , 59063 , 59069 , 59077 , 59083 , 59093 , 59107 , 59113 , 59119 , 59123 , 59141 , 59149 , 59159 , 59167 , 59183 , 59197 , 59207 , 59209 , 59219 , 59221 , 59233 , 59239 , 59243 , 59263 , 59273 , 59281 , 59333 , 59341 , 59351 , 59357 , 59359 , 59369 , 59377 , 59387 , 59393 , 59399 , 59407 , 59417 , 59419 , 59441 , 59443 , 59447 , 59453 , 59467 , 59471 , 59473 , 59497 , 59509 , 59513 , 59539 , 59557 , 59561 , 59567 , 59581 , 59611 , 59617 , 59621 , 59627 , 59629 , 59651 , 59659 , 59663 , 59669 , 59671 , 59693 , 59699 , 59707 , 59723 , 59729 , 59743 , 59747 , 59753 , 59771 , 59779 , 59791 , 59797 , 59809 , 59833 , 59863 , 59879 , 59887 , 59921 , 59929 , 59951 , 59957 , 59971 , 59981 , 59999 , 60013 , 60017 , 60029 , 60037 , 60041 , 60077 , 60083 , 60089 , 60091 , 60101 , 60103 , 60107 , 60127 , 60133 , 60139 , 60149 , 60161 , 60167 , 60169 , 60209 , 60217 , 60223 , 60251 , 60257 , 60259 , 60271 , 60289 , 60293 , 60317 , 60331 , 60337 , 60343 , 60353 , 60373 , 60383 , 60397 , 60413 , 60427 , 60443 , 60449 , 60457 , 60493 , 60497 , 60509 , 60521 , 60527 , 60539 , 60589 , 60601 , 60607 , 60611 , 60617 , 60623 , 60631 , 60637 , 60647 , 60649 , 60659 , 60661 , 60679 , 60689 , 60703 , 60719 , 60727 , 60733 , 60737 , 60757 , 60761 , 60763 , 60773 , 60779 , 60793 , 60811 , 60821 , 60859 , 60869 , 60887 , 60889 , 60899 , 60901 , 60913 , 60917 , 60919 , 60923 , 60937 , 60943 , 60953 , 60961 , 61001 , 61007 , 61027 , 61031 , 61043 , 61051 , 61057 , 61091 , 61099 , 61121 , 61129 , 61141 , 61151 , 61153 , 61169 , 61211 , 61223 , 61231 , 61253 , 61261 , 61283 , 61291 , 61297 , 61331 , 61333 , 61339 , 61343 , 61357 , 61363 , 61379 , 61381 , 61403 , 61409 , 61417 , 61441 , 61463 , 61469 , 61471 , 61483 , 61487 , 61493 , 61507 , 61511 , 61519 , 61543 , 61547 , 61553 , 61559 , 61561 , 61583 , 61603 , 61609 , 61613 , 61627 , 61631 , 61637 , 61643 , 61651 , 61657 , 61667 , 61673 , 61681 , 61687 , 61703 , 61717 , 61723 , 61729 , 61751 , 61757 , 61781 , 61813 , 61819 , 61837 , 61843 , 61861 , 61871 , 61879 , 61909 , 61927 , 61933 , 61949 , 61961 , 61967 , 61979 , 61981 , 61987 , 61991 , 62003 , 62011 , 62017 , 62039 , 62047 , 62053 , 62057 , 62071 , 62081 , 62099 , 62119 , 62129 , 62131 , 62137 , 62141 , 62143 , 62171 , 62189 , 62191 , 62201 , 62207 , 62213 , 62219 , 62233 , 62273 , 62297 , 62299 , 62303 , 62311 , 62323 , 62327 , 62347 , 62351 , 62383 , 62401 , 62417 , 62423 , 62459 , 62467 , 62473 , 62477 , 62483 , 62497 , 62501 , 62507 , 62533 , 62539 , 62549 , 62563 , 62581 , 62591 , 62597 , 62603 , 62617 , 62627 , 62633 , 62639 , 62653 , 62659 , 62683 , 62687 , 62701 , 62723 , 62731 , 62743 , 62753 , 62761 , 62773 , 62791 , 62801 , 62819 , 62827 , 62851 , 62861 , 62869 , 62873 , 62897 , 62903 , 62921 , 62927 , 62929 , 62939 , 62969 , 62971 , 62981 , 62983 , 62987 , 62989 , 63029 , 63031 , 63059 , 63067 , 63073 , 63079 , 63097 , 63103 , 63113 , 63127 , 63131 , 63149 , 63179 , 63197 , 63199 , 63211 , 63241 , 63247 , 63277 , 63281 , 63299 , 63311 , 63313 , 63317 , 63331 , 63337 , 63347 , 63353 , 63361 , 63367 , 63377 , 63389 , 63391 , 63397 , 63409 , 63419 , 63421 , 63439 , 63443 , 63463 , 63467 , 63473 , 63487 , 63493 , 63499 , 63521 , 63527 , 63533 , 63541 , 63559 , 63577 , 63587 , 63589 , 63599 , 63601 , 63607 , 63611 , 63617 , 63629 , 63647 , 63649 , 63659 , 63667 , 63671 , 63689 , 63691 , 63697 , 63703 , 63709 , 63719 , 63727 , 63737 , 63743 , 63761 , 63773 , 63781 , 63793 , 63799 , 63803 , 63809 , 63823 , 63839 , 63841 , 63853 , 63857 , 63863 , 63901 , 63907 , 63913 , 63929 , 63949 , 63977 , 63997 , 64007 , 64013 , 64019 , 64033 , 64037 , 64063 , 64067 , 64081 , 64091 , 64109 , 64123 , 64151 , 64153 , 64157 , 64171 , 64187 , 64189 , 64217 , 64223 , 64231 , 64237 , 64271 , 64279 , 64283 , 64301 , 64303 , 64319 , 64327 , 64333 , 64373 , 64381 , 64399 , 64403 , 64433 , 64439 , 64451 , 64453 , 64483 , 64489 , 64499 , 64513 , 64553 , 64567 , 64577 , 64579 , 64591 , 64601 , 64609 , 64613 , 64621 , 64627 , 64633 , 64661 , 64663 , 64667 , 64679 , 64693 , 64709 , 64717 , 64747 , 64763 , 64781 , 64783 , 64793 , 64811 , 64817 , 64849 , 64853 , 64871 , 64877 , 64879 , 64891 , 64901 , 64919 , 64921 , 64927 , 64937 , 64951 , 64969 , 64997 , 65003 , 65011 , 65027 , 65029 , 65033 , 65053 , 65063 , 65071 , 65089 , 65099 , 65101 , 65111 , 65119 , 65123 , 65129 , 65141 , 65147 , 65167 , 65171 , 65173 , 65179 , 65183 , 65203 , 65213 , 65239 , 65257 , 65267 , 65269 , 65287 , 65293 , 65309 , 65323 , 65327 , 65353 , 65357 , 65371 , 65381 , 65393 , 65407 , 65413 , 65419 , 65423 , 65437 , 65447 , 65449 , 65479 , 65497 , 65519 , 65521 , 65537 , 65539 , 65543 , 65551 , 65557 , 65563 , 65579 , 65581 , 65587 , 65599 , 65609 , 65617 , 65629 , 65633 , 65647 , 65651 , 65657 , 65677 , 65687 , 65699 , 65701 , 65707 , 65713 , 65717 , 65719 , 65729 , 65731 , 65761 , 65777 , 65789 , 65809 , 65827 , 65831 , 65837 , 65839 , 65843 , 65851 , 65867 , 65881 , 65899 , 65921 , 65927 , 65929 , 65951 , 65957 , 65963 , 65981 , 65983 , 65993 , 66029 , 66037 , 66041 , 66047 , 66067 , 66071 , 66083 , 66089 , 66103 , 66107 , 66109 , 66137 , 66161 , 66169 , 66173 , 66179 , 66191 , 66221 , 66239 , 66271 , 66293 , 66301 , 66337 , 66343 , 66347 , 66359 , 66361 , 66373 , 66377 , 66383 , 66403 , 66413 , 66431 , 66449 , 66457 , 66463 , 66467 , 66491 , 66499 , 66509 , 66523 , 66529 , 66533 , 66541 , 66553 , 66569 , 66571 , 66587 , 66593 , 66601 , 66617 , 66629 , 66643 , 66653 , 66683 , 66697 , 66701 , 66713 , 66721 , 66733 , 66739 , 66749 , 66751 , 66763 , 66791 , 66797 , 66809 , 66821 , 66841 , 66851 , 66853 , 66863 , 66877 , 66883 , 66889 , 66919 , 66923 , 66931 , 66943 , 66947 , 66949 , 66959 , 66973 , 66977 , 67003 , 67021 , 67033 , 67043 , 67049 , 67057 , 67061 , 67073 , 67079 , 67103 , 67121 , 67129 , 67139 , 67141 , 67153 , 67157 , 67169 , 67181 , 67187 , 67189 , 67211 , 67213 , 67217 , 67219 , 67231 , 67247 , 67261 , 67271 , 67273 , 67289 , 67307 , 67339 , 67343 , 67349 , 67369 , 67391 , 67399 , 67409 , 67411 , 67421 , 67427 , 67429 , 67433 , 67447 , 67453 , 67477 , 67481 , 67489 , 67493 , 67499 , 67511 , 67523 , 67531 , 67537 , 67547 , 67559 , 67567 , 67577 , 67579 , 67589 , 67601 , 67607 , 67619 , 67631 , 67651 , 67679 , 67699 , 67709 , 67723 , 67733 , 67741 , 67751 , 67757 , 67759 , 67763 , 67777 , 67783 , 67789 , 67801 , 67807 , 67819 , 67829 , 67843 , 67853 , 67867 , 67883 , 67891 , 67901 , 67927 , 67931 , 67933 , 67939 , 67943 , 67957 , 67961 , 67967 , 67979 , 67987 , 67993 , 68023 , 68041 , 68053 , 68059 , 68071 , 68087 , 68099 , 68111 , 68113 , 68141 , 68147 , 68161 , 68171 , 68207 , 68209 , 68213 , 68219 , 68227 , 68239 , 68261 , 68279 , 68281 , 68311 , 68329 , 68351 , 68371 , 68389 , 68399 , 68437 , 68443 , 68447 , 68449 , 68473 , 68477 , 68483 , 68489 , 68491 , 68501 , 68507 , 68521 , 68531 , 68539 , 68543 , 68567 , 68581 , 68597 , 68611 , 68633 , 68639 , 68659 , 68669 , 68683 , 68687 , 68699 , 68711 , 68713 , 68729 , 68737 , 68743 , 68749 , 68767 , 68771 , 68777 , 68791 , 68813 , 68819 , 68821 , 68863 , 68879 , 68881 , 68891 , 68897 , 68899 , 68903 , 68909 , 68917 , 68927 , 68947 , 68963 , 68993 , 69001 , 69011 , 69019 , 69029 , 69031 , 69061 , 69067 , 69073 , 69109 , 69119 , 69127 , 69143 , 69149 , 69151 , 69163 , 69191 , 69193 , 69197 , 69203 , 69221 , 69233 , 69239 , 69247 , 69257 , 69259 , 69263 , 69313 , 69317 , 69337 , 69341 , 69371 , 69379 , 69383 , 69389 , 69401 , 69403 , 69427 , 69431 , 69439 , 69457 , 69463 , 69467 , 69473 , 69481 , 69491 , 69493 , 69497 , 69499 , 69539 , 69557 , 69593 , 69623 , 69653 , 69661 , 69677 , 69691 , 69697 , 69709 , 69737 , 69739 , 69761 , 69763 , 69767 , 69779 , 69809 , 69821 , 69827 , 69829 , 69833 , 69847 , 69857 , 69859 , 69877 , 69899 , 69911 , 69929 , 69931 , 69941 , 69959 , 69991 , 69997 , 70001 , 70003 , 70009 , 70019 , 70039 , 70051 , 70061 , 70067 , 70079 , 70099 , 70111 , 70117 , 70121 , 70123 , 70139 , 70141 , 70157 , 70163 , 70177 , 70181 , 70183 , 70199 , 70201 , 70207 , 70223 , 70229 , 70237 , 70241 , 70249 , 70271 , 70289 , 70297 , 70309 , 70313 , 70321 , 70327 , 70351 , 70373 , 70379 , 70381 , 70393 , 70423 , 70429 , 70439 , 70451 , 70457 , 70459 , 70481 , 70487 , 70489 , 70501 , 70507 , 70529 , 70537 , 70549 , 70571 , 70573 , 70583 , 70589 , 70607 , 70619 , 70621 , 70627 , 70639 , 70657 , 70663 , 70667 , 70687 , 70709 , 70717 , 70729 , 70753 , 70769 , 70783 , 70793 , 70823 , 70841 , 70843 , 70849 , 70853 , 70867 , 70877 , 70879 , 70891 , 70901 , 70913 , 70919 , 70921 , 70937 , 70949 , 70951 , 70957 , 70969 , 70979 , 70981 , 70991 , 70997 , 70999 , 71011 , 71023 , 71039 , 71059 , 71069 , 71081 , 71089 , 71119 , 71129 , 71143 , 71147 , 71153 , 71161 , 71167 , 71171 , 71191 , 71209 , 71233 , 71237 , 71249 , 71257 , 71261 , 71263 , 71287 , 71293 , 71317 , 71327 , 71329 , 71333 , 71339 , 71341 , 71347 , 71353 , 71359 , 71363 , 71387 , 71389 , 71399 , 71411 , 71413 , 71419 , 71429 , 71437 , 71443 , 71453 , 71471 , 71473 , 71479 , 71483 , 71503 , 71527 , 71537 , 71549 , 71551 , 71563 , 71569 , 71593 , 71597 , 71633 , 71647 , 71663 , 71671 , 71693 , 71699 , 71707 , 71711 , 71713 , 71719 , 71741 , 71761 , 71777 , 71789 , 71807 , 71809 , 71821 , 71837 , 71843 , 71849 , 71861 , 71867 , 71879 , 71881 , 71887 , 71899 , 71909 , 71917 , 71933 , 71941 , 71947 , 71963 , 71971 , 71983 , 71987 , 71993 , 71999 , 72019 , 72031 , 72043 , 72047 , 72053 , 72073 , 72077 , 72089 , 72091 , 72101 , 72103 , 72109 , 72139 , 72161 , 72167 , 72169 , 72173 , 72211 , 72221 , 72223 , 72227 , 72229 , 72251 , 72253 , 72269 , 72271 , 72277 , 72287 , 72307 , 72313 , 72337 , 72341 , 72353 , 72367 , 72379 , 72383 , 72421 , 72431 , 72461 , 72467 , 72469 , 72481 , 72493 , 72497 , 72503 , 72533 , 72547 , 72551 , 72559 , 72577 , 72613 , 72617 , 72623 , 72643 , 72647 , 72649 , 72661 , 72671 , 72673 , 72679 , 72689 , 72701 , 72707 , 72719 , 72727 , 72733 , 72739 , 72763 , 72767 , 72797 , 72817 , 72823 , 72859 , 72869 , 72871 , 72883 , 72889 , 72893 , 72901 , 72907 , 72911 , 72923 , 72931 , 72937 , 72949 , 72953 , 72959 , 72973 , 72977 , 72997 , 73009 , 73013 , 73019 , 73037 , 73039 , 73043 , 73061 , 73063 , 73079 , 73091 , 73121 , 73127 , 73133 , 73141 , 73181 , 73189 , 73237 , 73243 , 73259 , 73277 , 73291 , 73303 , 73309 , 73327 , 73331 , 73351 , 73361 , 73363 , 73369 , 73379 , 73387 , 73417 , 73421 , 73433 , 73453 , 73459 , 73471 , 73477 , 73483 , 73517 , 73523 , 73529 , 73547 , 73553 , 73561 , 73571 , 73583 , 73589 , 73597 , 73607 , 73609 , 73613 , 73637 , 73643 , 73651 , 73673 , 73679 , 73681 , 73693 , 73699 , 73709 , 73721 , 73727 , 73751 , 73757 , 73771 , 73783 , 73819 , 73823 , 73847 , 73849 , 73859 , 73867 , 73877 , 73883 , 73897 , 73907 , 73939 , 73943 , 73951 , 73961 , 73973 , 73999 , 74017 , 74021 , 74027 , 74047 , 74051 , 74071 , 74077 , 74093 , 74099 , 74101 , 74131 , 74143 , 74149 , 74159 , 74161 , 74167 , 74177 , 74189 , 74197 , 74201 , 74203 , 74209 , 74219 , 74231 , 74257 , 74279 , 74287 , 74293 , 74297 , 74311 , 74317 , 74323 , 74353 , 74357 , 74363 , 74377 , 74381 , 74383 , 74411 , 74413 , 74419 , 74441 , 74449 , 74453 , 74471 , 74489 , 74507 , 74509 , 74521 , 74527 , 74531 , 74551 , 74561 , 74567 , 74573 , 74587 , 74597 , 74609 , 74611 , 74623 , 74653 , 74687 , 74699 , 74707 , 74713 , 74717 , 74719 , 74729 , 74731 , 74747 , 74759 , 74761 , 74771 , 74779 , 74797 , 74821 , 74827 , 74831 , 74843 , 74857 , 74861 , 74869 , 74873 , 74887 , 74891 , 74897 , 74903 , 74923 , 74929 , 74933 , 74941 , 74959 , 75011 , 75013 , 75017 , 75029 , 75037 , 75041 , 75079 , 75083 , 75109 , 75133 , 75149 , 75161 , 75167 , 75169 , 75181 , 75193 , 75209 , 75211 , 75217 , 75223 , 75227 , 75239 , 75253 , 75269 , 75277 , 75289 , 75307 , 75323 , 75329 , 75337 , 75347 , 75353 , 75367 , 75377 , 75389 , 75391 , 75401 , 75403 , 75407 , 75431 , 75437 , 75479 , 75503 , 75511 , 75521 , 75527 , 75533 , 75539 , 75541 , 75553 , 75557 , 75571 , 75577 , 75583 , 75611 , 75617 , 75619 , 75629 , 75641 , 75653 , 75659 , 75679 , 75683 , 75689 , 75703 , 75707 , 75709 , 75721 , 75731 , 75743 , 75767 , 75773 , 75781 , 75787 , 75793 , 75797 , 75821 , 75833 , 75853 , 75869 , 75883 , 75913 , 75931 , 75937 , 75941 , 75967 , 75979 , 75983 , 75989 , 75991 , 75997 , 76001 , 76003 , 76031 , 76039 , 76079 , 76081 , 76091 , 76099 , 76103 , 76123 , 76129 , 76147 , 76157 , 76159 , 76163 , 76207 , 76213 , 76231 , 76243 , 76249 , 76253 , 76259 , 76261 , 76283 , 76289 , 76303 , 76333 , 76343 , 76367 , 76369 , 76379 , 76387 , 76403 , 76421 , 76423 , 76441 , 76463 , 76471 , 76481 , 76487 , 76493 , 76507 , 76511 , 76519 , 76537 , 76541 , 76543 , 76561 , 76579 , 76597 , 76603 , 76607 , 76631 , 76649 , 76651 , 76667 , 76673 , 76679 , 76697 , 76717 , 76733 , 76753 , 76757 , 76771 , 76777 , 76781 , 76801 , 76819 , 76829 , 76831 , 76837 , 76847 , 76871 , 76873 , 76883 , 76907 , 76913 , 76919 , 76943 , 76949 , 76961 , 76963 , 76991 , 77003 , 77017 , 77023 , 77029 , 77041 , 77047 , 77069 , 77081 , 77093 , 77101 , 77137 , 77141 , 77153 , 77167 , 77171 , 77191 , 77201 , 77213 , 77237 , 77239 , 77243 , 77249 , 77261 , 77263 , 77267 , 77269 , 77279 , 77291 , 77317 , 77323 , 77339 , 77347 , 77351 , 77359 , 77369 , 77377 , 77383 , 77417 , 77419 , 77431 , 77447 , 77471 , 77477 , 77479 , 77489 , 77491 , 77509 , 77513 , 77521 , 77527 , 77543 , 77549 , 77551 , 77557 , 77563 , 77569 , 77573 , 77587 , 77591 , 77611 , 77617 , 77621 , 77641 , 77647 , 77659 , 77681 , 77687 , 77689 , 77699 , 77711 , 77713 , 77719 , 77723 , 77731 , 77743 , 77747 , 77761 , 77773 , 77783 , 77797 , 77801 , 77813 , 77839 , 77849 , 77863 , 77867 , 77893 , 77899 , 77929 , 77933 , 77951 , 77969 , 77977 , 77983 , 77999 , 78007 , 78017 , 78031 , 78041 , 78049 , 78059 , 78079 , 78101 , 78121 , 78137 , 78139 , 78157 , 78163 , 78167 , 78173 , 78179 , 78191 , 78193 , 78203 , 78229 , 78233 , 78241 , 78259 , 78277 , 78283 , 78301 , 78307 , 78311 , 78317 , 78341 , 78347 , 78367 , 78401 , 78427 , 78437 , 78439 , 78467 , 78479 , 78487 , 78497 , 78509 , 78511 , 78517 , 78539 , 78541 , 78553 , 78569 , 78571 , 78577 , 78583 , 78593 , 78607 , 78623 , 78643 , 78649 , 78653 , 78691 , 78697 , 78707 , 78713 , 78721 , 78737 , 78779 , 78781 , 78787 , 78791 , 78797 , 78803 , 78809 , 78823 , 78839 , 78853 , 78857 , 78877 , 78887 , 78889 , 78893 , 78901 , 78919 , 78929 , 78941 , 78977 , 78979 , 78989 , 79031 , 79039 , 79043 , 79063 , 79087 , 79103 , 79111 , 79133 , 79139 , 79147 , 79151 , 79153 , 79159 , 79181 , 79187 , 79193 , 79201 , 79229 , 79231 , 79241 , 79259 , 79273 , 79279 , 79283 , 79301 , 79309 , 79319 , 79333 , 79337 , 79349 , 79357 , 79367 , 79379 , 79393 , 79397 , 79399 , 79411 , 79423 , 79427 , 79433 , 79451 , 79481 , 79493 , 79531 , 79537 , 79549 , 79559 , 79561 , 79579 , 79589 , 79601 , 79609 , 79613 , 79621 , 79627 , 79631 , 79633 , 79657 , 79669 , 79687 , 79691 , 79693 , 79697 , 79699 , 79757 , 79769 , 79777 , 79801 , 79811 , 79813 , 79817 , 79823 , 79829 , 79841 , 79843 , 79847 , 79861 , 79867 , 79873 , 79889 , 79901 , 79903 , 79907 , 79939 , 79943 , 79967 , 79973 , 79979 , 79987 , 79997 , 79999 , 80021 , 80039 , 80051 , 80071 , 80077 , 80107 , 80111 , 80141 , 80147 , 80149 , 80153 , 80167 , 80173 , 80177 , 80191 , 80207 , 80209 , 80221 , 80231 , 80233 , 80239 , 80251 , 80263 , 80273 , 80279 , 80287 , 80309 , 80317 , 80329 , 80341 , 80347 , 80363 , 80369 , 80387 , 80407 , 80429 , 80447 , 80449 , 80471 , 80473 , 80489 , 80491 , 80513 , 80527 , 80537 , 80557 , 80567 , 80599 , 80603 , 80611 , 80621 , 80627 , 80629 , 80651 , 80657 , 80669 , 80671 , 80677 , 80681 , 80683 , 80687 , 80701 , 80713 , 80737 , 80747 , 80749 , 80761 , 80777 , 80779 , 80783 , 80789 , 80803 , 80809 , 80819 , 80831 , 80833 , 80849 , 80863 , 80897 , 80909 , 80911 , 80917 , 80923 , 80929 , 80933 , 80953 , 80963 , 80989 , 81001 , 81013 , 81017 , 81019 , 81023 , 81031 , 81041 , 81043 , 81047 , 81049 , 81071 , 81077 , 81083 , 81097 , 81101 , 81119 , 81131 , 81157 , 81163 , 81173 , 81181 , 81197 , 81199 , 81203 , 81223 , 81233 , 81239 , 81281 , 81283 , 81293 , 81299 , 81307 , 81331 , 81343 , 81349 , 81353 , 81359 , 81371 , 81373 , 81401 , 81409 , 81421 , 81439 , 81457 , 81463 , 81509 , 81517 , 81527 , 81533 , 81547 , 81551 , 81553 , 81559 , 81563 , 81569 , 81611 , 81619 , 81629 , 81637 , 81647 , 81649 , 81667 , 81671 , 81677 , 81689 , 81701 , 81703 , 81707 , 81727 , 81737 , 81749 , 81761 , 81769 , 81773 , 81799 , 81817 , 81839 , 81847 , 81853 , 81869 , 81883 , 81899 , 81901 , 81919 , 81929 , 81931 , 81937 , 81943 , 81953 , 81967 , 81971 , 81973 , 82003 , 82007 , 82009 , 82013 , 82021 , 82031 , 82037 , 82039 , 82051 , 82067 , 82073 , 82129 , 82139 , 82141 , 82153 , 82163 , 82171 , 82183 , 82189 , 82193 , 82207 , 82217 , 82219 , 82223 , 82231 , 82237 , 82241 , 82261 , 82267 , 82279 , 82301 , 82307 , 82339 , 82349 , 82351 , 82361 , 82373 , 82387 , 82393 , 82421 , 82457 , 82463 , 82469 , 82471 , 82483 , 82487 , 82493 , 82499 , 82507 , 82529 , 82531 , 82549 , 82559 , 82561 , 82567 , 82571 , 82591 , 82601 , 82609 , 82613 , 82619 , 82633 , 82651 , 82657 , 82699 , 82721 , 82723 , 82727 , 82729 , 82757 , 82759 , 82763 , 82781 , 82787 , 82793 , 82799 , 82811 , 82813 , 82837 , 82847 , 82883 , 82889 , 82891 , 82903 , 82913 , 82939 , 82963 , 82981 , 82997 , 83003 , 83009 , 83023 , 83047 , 83059 , 83063 , 83071 , 83077 , 83089 , 83093 , 83101 , 83117 , 83137 , 83177 , 83203 , 83207 , 83219 , 83221 , 83227 , 83231 , 83233 , 83243 , 83257 , 83267 , 83269 , 83273 , 83299 , 83311 , 83339 , 83341 , 83357 , 83383 , 83389 , 83399 , 83401 , 83407 , 83417 , 83423 , 83431 , 83437 , 83443 , 83449 , 83459 , 83471 , 83477 , 83497 , 83537 , 83557 , 83561 , 83563 , 83579 , 83591 , 83597 , 83609 , 83617 , 83621 , 83639 , 83641 , 83653 , 83663 , 83689 , 83701 , 83717 , 83719 , 83737 , 83761 , 83773 , 83777 , 83791 , 83813 , 83833 , 83843 , 83857 , 83869 , 83873 , 83891 , 83903 , 83911 , 83921 , 83933 , 83939 , 83969 , 83983 , 83987 , 84011 , 84017 , 84047 , 84053 , 84059 , 84061 , 84067 , 84089 , 84121 , 84127 , 84131 , 84137 , 84143 , 84163 , 84179 , 84181 , 84191 , 84199 , 84211 , 84221 , 84223 , 84229 , 84239 , 84247 , 84263 , 84299 , 84307 , 84313 , 84317 , 84319 , 84347 , 84349 , 84377 , 84389 , 84391 , 84401 , 84407 , 84421 , 84431 , 84437 , 84443 , 84449 , 84457 , 84463 , 84467 , 84481 , 84499 , 84503 , 84509 , 84521 , 84523 , 84533 , 84551 , 84559 , 84589 , 84629 , 84631 , 84649 , 84653 , 84659 , 84673 , 84691 , 84697 , 84701 , 84713 , 84719 , 84731 , 84737 , 84751 , 84761 , 84787 , 84793 , 84809 , 84811 , 84827 , 84857 , 84859 , 84869 , 84871 , 84913 , 84919 , 84947 , 84961 , 84967 , 84977 , 84979 , 84991 , 85009 , 85021 , 85027 , 85037 , 85049 , 85061 , 85081 , 85087 , 85091 , 85093 , 85103 , 85109 , 85121 , 85133 , 85147 , 85159 , 85193 , 85199 , 85201 , 85213 , 85223 , 85229 , 85237 , 85243 , 85247 , 85259 , 85297 , 85303 , 85313 , 85331 , 85333 , 85361 , 85363 , 85369 , 85381 , 85411 , 85427 , 85429 , 85439 , 85447 , 85451 , 85453 , 85469 , 85487 , 85513 , 85517 , 85523 , 85531 , 85549 , 85571 , 85577 , 85597 , 85601 , 85607 , 85619 , 85621 , 85627 , 85639 , 85643 , 85661 , 85667 , 85669 , 85691 , 85703 , 85711 , 85717 , 85733 , 85751 , 85781 , 85793 , 85817 , 85819 , 85829 , 85831 , 85837 , 85843 , 85847 , 85853 , 85889 , 85903 , 85909 , 85931 , 85933 , 85991 , 85999 , 86011 , 86017 , 86027 , 86029 , 86069 , 86077 , 86083 , 86111 , 86113 , 86117 , 86131 , 86137 , 86143 , 86161 , 86171 , 86179 , 86183 , 86197 , 86201 , 86209 , 86239 , 86243 , 86249 , 86257 , 86263 , 86269 , 86287 , 86291 , 86293 , 86297 , 86311 , 86323 , 86341 , 86351 , 86353 , 86357 , 86369 , 86371 , 86381 , 86389 , 86399 , 86413 , 86423 , 86441 , 86453 , 86461 , 86467 , 86477 , 86491 , 86501 , 86509 , 86531 , 86533 , 86539 , 86561 , 86573 , 86579 , 86587 , 86599 , 86627 , 86629 , 86677 , 86689 , 86693 , 86711 , 86719 , 86729 , 86743 , 86753 , 86767 , 86771 , 86783 , 86813 , 86837 , 86843 , 86851 , 86857 , 86861 , 86869 , 86923 , 86927 , 86929 , 86939 , 86951 , 86959 , 86969 , 86981 , 86993 , 87011 , 87013 , 87037 , 87041 , 87049 , 87071 , 87083 , 87103 , 87107 , 87119 , 87121 , 87133 , 87149 , 87151 , 87179 , 87181 , 87187 , 87211 , 87221 , 87223 , 87251 , 87253 , 87257 , 87277 , 87281 , 87293 , 87299 , 87313 , 87317 , 87323 , 87337 , 87359 , 87383 , 87403 , 87407 , 87421 , 87427 , 87433 , 87443 , 87473 , 87481 , 87491 , 87509 , 87511 , 87517 , 87523 , 87539 , 87541 , 87547 , 87553 , 87557 , 87559 , 87583 , 87587 , 87589 , 87613 , 87623 , 87629 , 87631 , 87641 , 87643 , 87649 , 87671 , 87679 , 87683 , 87691 , 87697 , 87701 , 87719 , 87721 , 87739 , 87743 , 87751 , 87767 , 87793 , 87797 , 87803 , 87811 , 87833 , 87853 , 87869 , 87877 , 87881 , 87887 , 87911 , 87917 , 87931 , 87943 , 87959 , 87961 , 87973 , 87977 , 87991 , 88001 , 88003 , 88007 , 88019 , 88037 , 88069 , 88079 , 88093 , 88117 , 88129 , 88169 , 88177 , 88211 , 88223 , 88237 , 88241 , 88259 , 88261 , 88289 , 88301 , 88321 , 88327 , 88337 , 88339 , 88379 , 88397 , 88411 , 88423 , 88427 , 88463 , 88469 , 88471 , 88493 , 88499 , 88513 , 88523 , 88547 , 88589 , 88591 , 88607 , 88609 , 88643 , 88651 , 88657 , 88661 , 88663 , 88667 , 88681 , 88721 , 88729 , 88741 , 88747 , 88771 , 88789 , 88793 , 88799 , 88801 , 88807 , 88811 , 88813 , 88817 , 88819 , 88843 , 88853 , 88861 , 88867 , 88873 , 88883 , 88897 , 88903 , 88919 , 88937 , 88951 , 88969 , 88993 , 88997 , 89003 , 89009 , 89017 , 89021 , 89041 , 89051 , 89057 , 89069 , 89071 , 89083 , 89087 , 89101 , 89107 , 89113 , 89119 , 89123 , 89137 , 89153 , 89189 , 89203 , 89209 , 89213 , 89227 , 89231 , 89237 , 89261 , 89269 , 89273 , 89293 , 89303 , 89317 , 89329 , 89363 , 89371 , 89381 , 89387 , 89393 , 89399 , 89413 , 89417 , 89431 , 89443 , 89449 , 89459 , 89477 , 89491 , 89501 , 89513 , 89519 , 89521 , 89527 , 89533 , 89561 , 89563 , 89567 , 89591 , 89597 , 89599 , 89603 , 89611 , 89627 , 89633 , 89653 , 89657 , 89659 , 89669 , 89671 , 89681 , 89689 , 89753 , 89759 , 89767 , 89779 , 89783 , 89797 , 89809 , 89819 , 89821 , 89833 , 89839 , 89849 , 89867 , 89891 , 89897 , 89899 , 89909 , 89917 , 89923 , 89939 , 89959 , 89963 , 89977 , 89983 , 89989 , 90001 , 90007 , 90011 , 90017 , 90019 , 90023 , 90031 , 90053 , 90059 , 90067 , 90071 , 90073 , 90089 , 90107 , 90121 , 90127 , 90149 , 90163 , 90173 , 90187 , 90191 , 90197 , 90199 , 90203 , 90217 , 90227 , 90239 , 90247 , 90263 , 90271 , 90281 , 90289 , 90313 , 90353 , 90359 , 90371 , 90373 , 90379 , 90397 , 90401 , 90403 , 90407 , 90437 , 90439 , 90469 , 90473 , 90481 , 90499 , 90511 , 90523 , 90527 , 90529 , 90533 , 90547 , 90583 , 90599 , 90617 , 90619 , 90631 , 90641 , 90647 , 90659 , 90677 , 90679 , 90697 , 90703 , 90709 , 90731 , 90749 , 90787 , 90793 , 90803 , 90821 , 90823 , 90833 , 90841 , 90847 , 90863 , 90887 , 90901 , 90907 , 90911 , 90917 , 90931 , 90947 , 90971 , 90977 , 90989 , 90997 , 91009 , 91019 , 91033 , 91079 , 91081 , 91097 , 91099 , 91121 , 91127 , 91129 , 91139 , 91141 , 91151 , 91153 , 91159 , 91163 , 91183 , 91193 , 91199 , 91229 , 91237 , 91243 , 91249 , 91253 , 91283 , 91291 , 91297 , 91303 , 91309 , 91331 , 91367 , 91369 , 91373 , 91381 , 91387 , 91393 , 91397 , 91411 , 91423 , 91433 , 91453 , 91457 , 91459 , 91463 , 91493 , 91499 , 91513 , 91529 , 91541 , 91571 , 91573 , 91577 , 91583 , 91591 , 91621 , 91631 , 91639 , 91673 , 91691 , 91703 , 91711 , 91733 , 91753 , 91757 , 91771 , 91781 , 91801 , 91807 , 91811 , 91813 , 91823 , 91837 , 91841 , 91867 , 91873 , 91909 , 91921 , 91939 , 91943 , 91951 , 91957 , 91961 , 91967 , 91969 , 91997 , 92003 , 92009 , 92033 , 92041 , 92051 , 92077 , 92083 , 92107 , 92111 , 92119 , 92143 , 92153 , 92173 , 92177 , 92179 , 92189 , 92203 , 92219 , 92221 , 92227 , 92233 , 92237 , 92243 , 92251 , 92269 , 92297 , 92311 , 92317 , 92333 , 92347 , 92353 , 92357 , 92363 , 92369 , 92377 , 92381 , 92383 , 92387 , 92399 , 92401 , 92413 , 92419 , 92431 , 92459 , 92461 , 92467 , 92479 , 92489 , 92503 , 92507 , 92551 , 92557 , 92567 , 92569 , 92581 , 92593 , 92623 , 92627 , 92639 , 92641 , 92647 , 92657 , 92669 , 92671 , 92681 , 92683 , 92693 , 92699 , 92707 , 92717 , 92723 , 92737 , 92753 , 92761 , 92767 , 92779 , 92789 , 92791 , 92801 , 92809 , 92821 , 92831 , 92849 , 92857 , 92861 , 92863 , 92867 , 92893 , 92899 , 92921 , 92927 , 92941 , 92951 , 92957 , 92959 , 92987 , 92993 , 93001 , 93047 , 93053 , 93059 , 93077 , 93083 , 93089 , 93097 , 93103 , 93113 , 93131 , 93133 , 93139 , 93151 , 93169 , 93179 , 93187 , 93199 , 93229 , 93239 , 93241 , 93251 , 93253 , 93257 , 93263 , 93281 , 93283 , 93287 , 93307 , 93319 , 93323 , 93329 , 93337 , 93371 , 93377 , 93383 , 93407 , 93419 , 93427 , 93463 , 93479 , 93481 , 93487 , 93491 , 93493 , 93497 , 93503 , 93523 , 93529 , 93553 , 93557 , 93559 , 93563 , 93581 , 93601 , 93607 , 93629 , 93637 , 93683 , 93701 , 93703 , 93719 , 93739 , 93761 , 93763 , 93787 , 93809 , 93811 , 93827 , 93851 , 93871 , 93887 , 93889 , 93893 , 93901 , 93911 , 93913 , 93923 , 93937 , 93941 , 93949 , 93967 , 93971 , 93979 , 93983 , 93997 , 94007 , 94009 , 94033 , 94049 , 94057 , 94063 , 94079 , 94099 , 94109 , 94111 , 94117 , 94121 , 94151 , 94153 , 94169 , 94201 , 94207 , 94219 , 94229 , 94253 , 94261 , 94273 , 94291 , 94307 , 94309 , 94321 , 94327 , 94331 , 94343 , 94349 , 94351 , 94379 , 94397 , 94399 , 94421 , 94427 , 94433 , 94439 , 94441 , 94447 , 94463 , 94477 , 94483 , 94513 , 94529 , 94531 , 94541 , 94543 , 94547 , 94559 , 94561 , 94573 , 94583 , 94597 , 94603 , 94613 , 94621 , 94649 , 94651 , 94687 , 94693 , 94709 , 94723 , 94727 , 94747 , 94771 , 94777 , 94781 , 94789 , 94793 , 94811 , 94819 , 94823 , 94837 , 94841 , 94847 , 94849 , 94873 , 94889 , 94903 , 94907 , 94933 , 94949 , 94951 , 94961 , 94993 , 94999 , 95003 , 95009 , 95021 , 95027 , 95063 , 95071 , 95083 , 95087 , 95089 , 95093 , 95101 , 95107 , 95111 , 95131 , 95143 , 95153 , 95177 , 95189 , 95191 , 95203 , 95213 , 95219 , 95231 , 95233 , 95239 , 95257 , 95261 , 95267 , 95273 , 95279 , 95287 , 95311 , 95317 , 95327 , 95339 , 95369 , 95383 , 95393 , 95401 , 95413 , 95419 , 95429 , 95441 , 95443 , 95461 , 95467 , 95471 , 95479 , 95483 , 95507 , 95527 , 95531 , 95539 , 95549 , 95561 , 95569 , 95581 , 95597 , 95603 , 95617 , 95621 , 95629 , 95633 , 95651 , 95701 , 95707 , 95713 , 95717 , 95723 , 95731 , 95737 , 95747 , 95773 , 95783 , 95789 , 95791 , 95801 , 95803 , 95813 , 95819 , 95857 , 95869 , 95873 , 95881 , 95891 , 95911 , 95917 , 95923 , 95929 , 95947 , 95957 , 95959 , 95971 , 95987 , 95989 , 96001 , 96013 , 96017 , 96043 , 96053 , 96059 , 96079 , 96097 , 96137 , 96149 , 96157 , 96167 , 96179 , 96181 , 96199 , 96211 , 96221 , 96223 , 96233 , 96259 , 96263 , 96269 , 96281 , 96289 , 96293 , 96323 , 96329 , 96331 , 96337 , 96353 , 96377 , 96401 , 96419 , 96431 , 96443 , 96451 , 96457 , 96461 , 96469 , 96479 , 96487 , 96493 , 96497 , 96517 , 96527 , 96553 , 96557 , 96581 , 96587 , 96589 , 96601 , 96643 , 96661 , 96667 , 96671 , 96697 , 96703 , 96731 , 96737 , 96739 , 96749 , 96757 , 96763 , 96769 , 96779 , 96787 , 96797 , 96799 , 96821 , 96823 , 96827 , 96847 , 96851 , 96857 , 96893 , 96907 , 96911 , 96931 , 96953 , 96959 , 96973 , 96979 , 96989 , 96997 , 97001 , 97003 , 97007 , 97021 , 97039 , 97073 , 97081 , 97103 , 97117 , 97127 , 97151 , 97157 , 97159 , 97169 , 97171 , 97177 , 97187 , 97213 , 97231 , 97241 , 97259 , 97283 , 97301 , 97303 , 97327 , 97367 , 97369 , 97373 , 97379 , 97381 , 97387 , 97397 , 97423 , 97429 , 97441 , 97453 , 97459 , 97463 , 97499 , 97501 , 97511 , 97523 , 97547 , 97549 , 97553 , 97561 , 97571 , 97577 , 97579 , 97583 , 97607 , 97609 , 97613 , 97649 , 97651 , 97673 , 97687 , 97711 , 97729 , 97771 , 97777 , 97787 , 97789 , 97813 , 97829 , 97841 , 97843 , 97847 , 97849 , 97859 , 97861 , 97871 , 97879 , 97883 , 97919 , 97927 , 97931 , 97943 , 97961 , 97967 , 97973 , 97987 , 98009 , 98011 , 98017 , 98041 , 98047 , 98057 , 98081 , 98101 , 98123 , 98129 , 98143 , 98179 , 98207 , 98213 , 98221 , 98227 , 98251 , 98257 , 98269 , 98297 , 98299 , 98317 , 98321 , 98323 , 98327 , 98347 , 98369 , 98377 , 98387 , 98389 , 98407 , 98411 , 98419 , 98429 , 98443 , 98453 , 98459 , 98467 , 98473 , 98479 , 98491 , 98507 , 98519 , 98533 , 98543 , 98561 , 98563 , 98573 , 98597 , 98621 , 98627 , 98639 , 98641 , 98663 , 98669 , 98689 , 98711 , 98713 , 98717 , 98729 , 98731 , 98737 , 98773 , 98779 , 98801 , 98807 , 98809 , 98837 , 98849 , 98867 , 98869 , 98873 , 98887 , 98893 , 98897 , 98899 , 98909 , 98911 , 98927 , 98929 , 98939 , 98947 , 98953 , 98963 , 98981 , 98993 , 98999 , 99013 , 99017 , 99023 , 99041 , 99053 , 99079 , 99083 , 99089 , 99103 , 99109 , 99119 , 99131 , 99133 , 99137 , 99139 , 99149 , 99173 , 99181 , 99191 , 99223 , 99233 , 99241 , 99251 , 99257 , 99259 , 99277 , 99289 , 99317 , 99347 , 99349 , 99367 , 99371 , 99377 , 99391 , 99397 , 99401 , 99409 , 99431 , 99439 , 99469 , 99487 , 99497 , 99523 , 99527 , 99529 , 99551 , 99559 , 99563 , 99571 , 99577 , 99581 , 99607 , 99611 , 99623 , 99643 , 99661 , 99667 , 99679 , 99689 , 99707 , 99709 , 99713 , 99719 , 99721 , 99733 , 99761 , 99767 , 99787 , 99793 , 99809 , 99817 , 99823 , 99829 , 99833 , 99839 , 99859 , 99871 , 99877 , 99881 , 99901 , 99907 , 99923 , 99929 , 99961 , 99971 , 99989 , 99991 , 100003 ] <NEWLINE> for i in lis : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> fac = [ ] <NEWLINE> sqrt_n = math . sqrt ( n ) <NEWLINE> for i in range ( 2 , int ( sqrt_n ) ) : <NEWLINE> <INDENT> if not n % i : <NEWLINE> <INDENT> fac . append ( 0 ) <NEWLINE> <DEDENT> while not n % i : <NEWLINE> <INDENT> n /= i <NEWLINE> fac [ - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> if n > sqrt_n : <NEWLINE> <INDENT> fac . append ( 1 ) <NEWLINE> <DEDENT> num = 0 <NEWLINE> for f in fac : <NEWLINE> <INDENT> num += np . count_nonzero ( f >= np . cumsum ( range ( 1 , f + 1 ) ) ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> m = math . floor ( math . sqrt ( n ) ) <NEWLINE> <NL> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( 1 , m ) : <NEWLINE> <INDENT> for k in range ( 1 , m ) : <NEWLINE> <INDENT> p = i * i + j * j + k * k + i * j + j * k + i * k <NEWLINE> if p <= n : <NEWLINE> <INDENT> t [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> A . append ( a ) <NEWLINE> <DEDENT> B = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> b = [ int ( k ) for k in input ( ) . split ( ) ] <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = [ ] <NEWLINE> for k in range ( l ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x += A [ i ] [ j ] * B [ j ] [ k ] <NEWLINE> <DEDENT> c . append ( str ( x ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( c ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> num = list ( input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if <STRING> in num : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in num : <NEWLINE> <INDENT> ans *= int ( i ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> sevens = 7 % K <NEWLINE> count = 1 <NEWLINE> <NL> while ( sevens % K != 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> sevens = sevens * ( 10 % K ) + ( 7 % K ) <NEWLINE> sevens = sevens % K <NEWLINE> <NL> count += 1 <NEWLINE> if count > K : <NEWLINE> <INDENT> count = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def calculate_n ( x , y , z ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> return n <NEWLINE> <DEDENT> l = [ ] <NEWLINE> for x in range ( 1 , N ) : <NEWLINE> <INDENT> for y in range ( 1 , N ) : <NEWLINE> <INDENT> for z in range ( 1 , N ) : <NEWLINE> <INDENT> n = calculate_n ( x , y , z ) <NEWLINE> if n > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( n ) <NEWLINE> <DEDENT> <DEDENT> if calculate_n ( x , y + 1 , 1 ) > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if calculate_n ( x + 1 , 1 , 1 ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> import collections <NEWLINE> c = collections . Counter ( l ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in c : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( maxsplit = N ) ] <NEWLINE> presum = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> presum [ i + 1 ] = presum [ i ] + A [ i ] <NEWLINE> <DEDENT> sumA = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sumA += ( A [ i ] * ( presum [ i ] ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( sumA % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> Y = X <NEWLINE> Z = X <NEWLINE> s = 0 <NEWLINE> t = 0 <NEWLINE> while s == 0 : <NEWLINE> <INDENT> Y += 1 <NEWLINE> if Y not in p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while t == 0 : <NEWLINE> <INDENT> Z -= 1 <NEWLINE> if Z not in p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if abs ( X - Y ) < abs ( X - Z ) : <NEWLINE> <INDENT> print ( Y ) <NEWLINE> <DEDENT> elif abs ( X - Y ) > abs ( X - Z ) : <NEWLINE> <INDENT> print ( Z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Z ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> file_input = sys . stdin <NEWLINE> N , R , L = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> <NL> hq = [ ] <NEWLINE> m = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> team = [ 0 , i , 0 ] <NEWLINE> heappush ( hq , team ) <NEWLINE> m [ i ] = team <NEWLINE> <NL> <DEDENT> time = 0 <NEWLINE> for line in file_input : <NEWLINE> <INDENT> d , t , x = map ( int , line . split ( ) ) <NEWLINE> hq [ 0 ] [ 2 ] += t - time <NEWLINE> time = t <NEWLINE> <NL> scored_team = m [ d ] [ : ] <NEWLINE> scored_team [ 0 ] -= x <NEWLINE> heappush ( hq , scored_team ) <NEWLINE> m [ d ] [ 2 ] = - 1 <NEWLINE> m [ d ] = scored_team <NEWLINE> <NL> while hq [ 0 ] [ 2 ] == - 1 : <NEWLINE> <INDENT> heappop ( hq ) <NEWLINE> <DEDENT> <DEDENT> hq [ 0 ] [ 2 ] += L - time <NEWLINE> ans_team = max ( hq , key = lambda x : ( x [ 2 ] , - x [ 1 ] ) ) <NEWLINE> print ( ans_team [ 1 ] ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
from heapq import * <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> inf = 10 ** 16 <NEWLINE> n , m , s = MI ( ) <NEWLINE> to = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = MI ( ) <NEWLINE> to [ u - 1 ] . append ( ( v - 1 , a , b ) ) <NEWLINE> to [ v - 1 ] . append ( ( u - 1 , a , b ) ) <NEWLINE> <DEDENT> cd = LLI ( n ) <NEWLINE> <NL> dp = [ [ inf ] * 3005 for _ in range ( n ) ] <NEWLINE> hp = [ ] <NEWLINE> heappush ( hp , ( 0 , min ( s , 3000 ) , 0 ) ) <NEWLINE> dp [ 0 ] [ min ( s , 3000 ) ] = 0 <NEWLINE> <NL> while hp : <NEWLINE> <INDENT> t , g , u = heappop ( hp ) <NEWLINE> if dp [ u ] [ g ] < t : continue <NEWLINE> c , d = cd [ u ] <NEWLINE> if g + c < 3000 : <NEWLINE> <INDENT> if dp [ u ] [ g + c ] > t + d : <NEWLINE> <INDENT> dp [ u ] [ g + c ] = t + d <NEWLINE> heappush ( hp , ( t + d , g + c , u ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dp [ u ] [ 3000 ] > t + d : <NEWLINE> <INDENT> dp [ u ] [ 3000 ] = t + d <NEWLINE> heappush ( hp , ( t + d , 3000 , u ) ) <NEWLINE> <DEDENT> <DEDENT> for v , a , b in to [ u ] : <NEWLINE> <INDENT> if g - a < 0 : continue <NEWLINE> if dp [ v ] [ g - a ] <= t + b : continue <NEWLINE> dp [ v ] [ g - a ] = t + b <NEWLINE> heappush ( hp , ( t + b , g - a , v ) ) <NEWLINE> <DEDENT> <DEDENT> for u in range ( 1 , n ) : <NEWLINE> <INDENT> print ( min ( dp [ u ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] * h <NEWLINE> W = [ 0 ] * w <NEWLINE> L = [ ( 0 , 0 ) ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ i ] = ( a , b ) <NEWLINE> H [ a - 1 ] += 1 <NEWLINE> W [ b - 1 ] += 1 <NEWLINE> <DEDENT> h_max = max ( H ) <NEWLINE> w_max = max ( W ) <NEWLINE> ans = h_max + w_max <NEWLINE> cnt = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> if H [ l [ 0 ] - 1 ] == h_max and W [ l [ 1 ] - 1 ] == w_max : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if H . count ( h_max ) * W . count ( w_max ) == cnt : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> B = [ [ ] for i in range ( h ) ] <NEWLINE> H = [ 0 ] * h <NEWLINE> W = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> B [ p - 1 ] . append ( q - 1 ) <NEWLINE> H [ p - 1 ] += 1 <NEWLINE> W [ q - 1 ] += 1 <NEWLINE> <DEDENT> mH = max ( H ) <NEWLINE> mW = max ( W ) <NEWLINE> CH = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if H [ i ] == mH : <NEWLINE> <INDENT> CH . append ( i ) <NEWLINE> <DEDENT> <DEDENT> CW = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> if W [ i ] == mW : <NEWLINE> <INDENT> CW . append ( i ) <NEWLINE> <DEDENT> <DEDENT> CW = set ( CW ) <NEWLINE> flag = 0 <NEWLINE> if len ( CH ) * len ( CW ) > m : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for ch in CH : <NEWLINE> <INDENT> b = set ( B [ ch ] ) <NEWLINE> if CW <= b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( mH + mW ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mH + mW - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for idx , a in enumerate ( A ) : <NEWLINE> <INDENT> tree [ idx ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> start = [ ] <NEWLINE> depth = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> def dfs ( v , p , d , cnt ) : <NEWLINE> <INDENT> depth [ v ] = d <NEWLINE> for u in tree [ v ] : <NEWLINE> <INDENT> if visited [ u ] : <NEWLINE> <INDENT> start . append ( [ u + 1 , depth [ u ] , cnt + 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> dfs ( u , v , d + 1 , cnt + 1 ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> visited = [ False for _ in range ( n ) ] <NEWLINE> visited [ 0 ] = True <NEWLINE> dfs ( 0 , - 1 , 0 , 0 ) <NEWLINE> <NL> if k <= start [ 0 ] [ 1 ] : <NEWLINE> <INDENT> print ( depth . index ( k ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = ( k - start [ 0 ] [ 1 ] ) % ( start [ 0 ] [ 2 ] - start [ 0 ] [ 1 ] ) <NEWLINE> res = start [ 0 ] [ 1 ] + cnt <NEWLINE> print ( depth . index ( res ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for li in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ li ] ] ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> S = input ( ) <NEWLINE> S = deque ( S ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> Reverse_Flag = 0 <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> string = ( input ( ) ) <NEWLINE> Query = string . replace ( <STRING> , <STRING> ) <NEWLINE> Query = list ( Query ) <NEWLINE> <NL> if Query [ 0 ] == <STRING> : <NEWLINE> <INDENT> if Reverse_Flag == 0 : <NEWLINE> <INDENT> Reverse_Flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Reverse_Flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> elif Query [ 1 ] == <STRING> : <NEWLINE> <INDENT> if Reverse_Flag == 0 : <NEWLINE> <INDENT> S . appendleft ( Query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( Query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Reverse_Flag == 0 : <NEWLINE> <INDENT> S . append ( Query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( Query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if Reverse_Flag == 1 : <NEWLINE> <INDENT> S = list ( S ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = list ( S ) <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = min ( p ) <NEWLINE> m . append ( a ) <NEWLINE> p . remove ( a ) <NEWLINE> <NL> <DEDENT> print ( sum ( m ) ) <NEWLINE>
<NL> def InsertionSort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> <NL> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def ShellSort ( A , n ) : <NEWLINE> <INDENT> total_cnt = 0 <NEWLINE> <NL> G = [ 1 ] <NEWLINE> span = 4 <NEWLINE> <NL> while span < len ( A ) : <NEWLINE> <INDENT> G . append ( span ) <NEWLINE> span = span * 3 + 1 <NEWLINE> <NL> <DEDENT> G . reverse ( ) <NEWLINE> <NL> m = len ( G ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> total_cnt += InsertionSort ( A , n , G [ i ] ) <NEWLINE> <NL> <DEDENT> return m , G , total_cnt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> m , G , cnt = ShellSort ( A , n ) <NEWLINE> <NL> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if b - 1 <= n : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> neighbor = [ [ ] for _ in range ( n ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> neighbor [ edge [ 0 ] - 1 ] . append ( edge [ 1 ] - 1 ) <COMMENT> <NEWLINE> neighbor [ edge [ 1 ] - 1 ] . append ( edge [ 0 ] - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> visited = [ - 1 ] * n <NEWLINE> ans = 1 <NEWLINE> for idx in range ( n ) : <NEWLINE> <INDENT> if visited [ idx ] == - 1 : <NEWLINE> <INDENT> queue = deque ( ) <NEWLINE> queue . append ( idx ) <NEWLINE> group_population = 1 <NEWLINE> visited [ idx ] = 0 <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> vertex = queue . popleft ( ) <NEWLINE> for nei in neighbor [ vertex ] : <NEWLINE> <INDENT> if visited [ nei ] == - 1 : <NEWLINE> <INDENT> visited [ nei ] = 0 <NEWLINE> queue . append ( nei ) <NEWLINE> group_population += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , group_population ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> m = n - 1 <NEWLINE> g = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> g . append ( l [ i ] + l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> g = sorted ( g , reverse = True ) <NEWLINE> for i in g : <NEWLINE> <INDENT> while l [ m ] >= i : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> cnt += n - m - 1 <NEWLINE> <DEDENT> print ( n * ( n - 1 ) * ( n - 2 ) // 6 - cnt ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> items = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] , dtype = np . int32 ) <NEWLINE> <NL> out = 10 ** 18 <NEWLINE> for c in itertools . product ( [ False , True ] , repeat = N ) : <NEWLINE> <INDENT> tmp = np . sum ( items [ np . where ( c ) ] , axis = 0 ) <NEWLINE> if np . any ( tmp ) : <NEWLINE> <INDENT> if M == np . count_nonzero ( tmp [ 1 : ] >= X ) : <NEWLINE> <INDENT> out = min ( out , tmp [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if out == 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> for b in range ( a , N + 1 , 1 ) : <NEWLINE> <INDENT> for c in range ( b , N + 1 , 1 ) : <NEWLINE> <INDENT> if len ( set ( [ a , b , c ] ) ) == 3 : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 6 <NEWLINE> <DEDENT> elif len ( set ( [ a , b , c ] ) ) == 2 : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import nlargest <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = nlargest ( 2 , a ) <NEWLINE> ma = max ( a ) <NEWLINE> for j in a : <NEWLINE> <INDENT> if j == ma : <NEWLINE> <INDENT> print ( b [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ma ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> k = ri ( ) <NEWLINE> a = k % 10 <NEWLINE> if a in [ 1 , 3 , 7 , 9 ] : <NEWLINE> <INDENT> s = 7 <NEWLINE> cnt = 1 <NEWLINE> while s % k : <NEWLINE> <INDENT> s = s * 10 + 7 <NEWLINE> s %= k <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT>
n , q = [ int ( el ) for el in input ( ) . split ( <STRING> ) ] <NEWLINE> data = [ 0 ] * n <NEWLINE> result , index = 0 , 1 <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , v = [ int ( el ) for el in input ( ) . split ( <STRING> ) ] <NEWLINE> data [ a - 1 ] += v <NEWLINE> if v > 0 : <NEWLINE> <INDENT> if result < data [ a - 1 ] : <NEWLINE> <INDENT> result , index = data [ a - 1 ] , a <NEWLINE> <DEDENT> elif result == data [ a - 1 ] : <NEWLINE> <INDENT> index = min ( index , a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if index == a : <NEWLINE> <INDENT> result = max ( data ) <NEWLINE> index = data . index ( result ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( index , result ) <NEWLINE> <DEDENT>
MAX = 100003 <NEWLINE> ws = [ 0 for i in range ( MAX ) ] <NEWLINE> par = [ - 1 for i in range ( MAX * 2 ) ] <NEWLINE> <NL> <NL> def weight ( x ) : <NEWLINE> <INDENT> root ( x ) <NEWLINE> return ws [ x ] <NEWLINE> <NL> <DEDENT> def root ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : return x <NEWLINE> p = root ( par [ x ] ) <NEWLINE> ws [ x ] = ws [ x ] + ws [ par [ x ] ] <NEWLINE> par [ x ] = p <NEWLINE> return par [ x ] <NEWLINE> <NL> <NL> <DEDENT> def unite ( y , x , z ) : <NEWLINE> <INDENT> z = z + weight ( x ) <NEWLINE> z = z - weight ( y ) <NEWLINE> x = root ( x ) <NEWLINE> y = root ( y ) <NEWLINE> if x == y : return 0 <NEWLINE> if par [ y ] < par [ x ] : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> z = - z <NEWLINE> <NL> <DEDENT> par [ x ] = par [ x ] + par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> ws [ y ] = z <NEWLINE> return 1 <NEWLINE> <NL> <DEDENT> def diff ( x , y ) : <NEWLINE> <INDENT> if root ( x ) != root ( y ) : return 0 <NEWLINE> ans = ws [ x ] - ws [ y ] <NEWLINE> return 1 , ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> global ans <NEWLINE> N , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> t , * cmd = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if t : <NEWLINE> <INDENT> x , y = cmd <NEWLINE> z = diff ( x , y ) <NEWLINE> if z == False : print ( <STRING> ) <NEWLINE> else : print ( z [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y , z = cmd <NEWLINE> unite ( x , y , z ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> for i in range ( 1 , int ( X ** ( 0.5 ) + 1 ) ) : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = - i <NEWLINE> while a ** 5 < X ** 2 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> W = [ 0 ] * N <NEWLINE> E = [ 0 ] * N <NEWLINE> L = 0 <NEWLINE> R = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> L += 1 <NEWLINE> <DEDENT> if S [ N - 1 - i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> W [ i ] = L <NEWLINE> E [ N - 1 - i ] = R <NEWLINE> <NL> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , E [ i ] + W [ i ] - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <COMMENT> <NL> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , k = ns ( ) <NEWLINE> a = na ( ) <NEWLINE> b = na ( ) <NEWLINE> <NL> perm_a = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> perm_b = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> <NL> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> perm_a [ i + 1 ] = perm_a [ i ] + ai <NEWLINE> <NL> <DEDENT> for i , bi in enumerate ( b ) : <NEWLINE> <INDENT> perm_b [ i + 1 ] = perm_b [ i ] + bi <NEWLINE> <NL> <DEDENT> perm_a . append ( INF ) <NEWLINE> perm_b . append ( INF ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , pa in enumerate ( perm_a ) : <NEWLINE> <INDENT> bserch = k - pa <NEWLINE> if bserch < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if bserch == 0 : <NEWLINE> <INDENT> ans = max ( ans , i ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> idx = bisect . bisect_left ( perm_b , bserch ) <NEWLINE> tmp_ans = i + idx - 1 <NEWLINE> if perm_b [ idx ] == bserch : <NEWLINE> <INDENT> tmp_ans += 1 <NEWLINE> <DEDENT> ans = max ( ans , tmp_ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while K - a [ i ] < b [ j ] : <NEWLINE> <INDENT> j = j - 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from math import gcd <NEWLINE> <NL> N , * AB = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> dict_F = { } <NEWLINE> count_0 = 0 <NEWLINE> <NL> def insert ( A , B , s ) : <COMMENT> <NEWLINE> <INDENT> if ( A , B ) not in dict_F . keys ( ) : <NEWLINE> <INDENT> dict_F [ ( A , B ) ] = [ 0 , 0 ] <NEWLINE> <DEDENT> dict_F [ ( A , B ) ] [ s ] += 1 <NEWLINE> <NL> <DEDENT> def make_power2 ( N ) : <NEWLINE> <INDENT> result = 1 <NEWLINE> list_result = [ 1 ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> result = ( 2 * result ) % mod <NEWLINE> list_result . append ( result ) <NEWLINE> <DEDENT> return list_result <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> A , B = AB [ 2 * i ] , AB [ 2 * i + 1 ] <NEWLINE> if A == 0 and B == 0 : <NEWLINE> <INDENT> count_0 += 1 <NEWLINE> continue <NEWLINE> <DEDENT> g = gcd ( A , B ) <NEWLINE> A //= g <NEWLINE> B //= g <NEWLINE> if A >= 0 and B > 0 : <NEWLINE> <INDENT> insert ( A , B , 0 ) <NEWLINE> <DEDENT> elif A > 0 and B <= 0 : <NEWLINE> <INDENT> insert ( - B , A , 1 ) <NEWLINE> <DEDENT> elif A <= 0 and B < 0 : <NEWLINE> <INDENT> insert ( - A , - B , 0 ) <NEWLINE> <DEDENT> elif A < 0 and B >= 0 : <NEWLINE> <INDENT> insert ( B , - A , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> mod = 1000000007 <NEWLINE> power2 = make_power2 ( N ) <NEWLINE> answer = 1 <NEWLINE> <NL> for A , B in dict_F . values ( ) : <NEWLINE> <INDENT> answer = ( answer * ( power2 [ A ] + power2 [ B ] - 1 ) ) % mod <NEWLINE> <DEDENT> answer = ( answer + count_0 - 1 ) % mod <NEWLINE> <NL> print ( answer ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> l = len ( n ) <NEWLINE> if int ( n ) > 9 : <NEWLINE> <INDENT> ans = [ 9 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = n [ l - 1 ] <NEWLINE> for i in range ( 2 , l + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if int ( tmp ) != 9 : <NEWLINE> <INDENT> tmp = int ( n [ l - i ] ) - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp = int ( n [ l - i ] ) <NEWLINE> <DEDENT> if i == l : <NEWLINE> <INDENT> ans . append ( int ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 9 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> c0 , c1 = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ c0 - c1 , c0 + c1 ] ) <NEWLINE> <DEDENT> a . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> ans , b = 1 , a [ 0 ] [ 1 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> if b <= i [ 0 ] : <NEWLINE> <INDENT> b = i [ 1 ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> ERROR_INPUT = <STRING> <NEWLINE> OPECODE = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> BUF = [ ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> stack = get_input ( ) <NEWLINE> ans = calc_stack ( stack = stack ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def calc_stack ( stack ) : <NEWLINE> <INDENT> if stack [ - 1 ] in OPECODE : <NEWLINE> <INDENT> BUF . append ( stack [ - 1 ] ) <NEWLINE> stack . pop ( ) <NEWLINE> return calc_stack ( stack = stack ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right_num = int ( stack [ - 1 ] ) <NEWLINE> stack . pop ( ) <NEWLINE> if stack [ - 1 ] in OPECODE : <NEWLINE> <INDENT> BUF . append ( right_num ) <NEWLINE> BUF . append ( stack [ - 1 ] ) <NEWLINE> stack . pop ( ) <NEWLINE> return calc_stack ( stack = stack ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_num = int ( stack [ - 1 ] ) <NEWLINE> stack . pop ( ) <NEWLINE> stack . append ( calc ( left_num , right_num , BUF [ - 1 ] ) ) <NEWLINE> BUF . pop ( ) <NEWLINE> stack . extend ( reversed ( BUF ) ) <NEWLINE> BUF . clear ( ) <NEWLINE> <NL> <DEDENT> if len ( stack ) == 1 : <NEWLINE> <INDENT> return stack [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return calc_stack ( stack = stack ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def calc ( left , right , ope ) : <NEWLINE> <INDENT> if ope == <STRING> : <NEWLINE> <INDENT> return left + right <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> return left - right <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> return left * right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_input ( ) : <NEWLINE> <INDENT> inp = input ( ) . split ( <STRING> ) <NEWLINE> opecode_count = 0 <NEWLINE> OPECODE_count = 0 <NEWLINE> <NL> for i in inp : <NEWLINE> <INDENT> if i in OPECODE : <NEWLINE> <INDENT> opecode_count += 1 <NEWLINE> <DEDENT> elif int ( i ) < 0 or int ( i ) > 10 ** 6 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> OPECODE_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if opecode_count < 1 or opecode_count > 100 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> if OPECODE_count < 2 or OPECODE_count > 100 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> return inp <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> de = deque ( ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> de . appendleft ( com [ 1 ] ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> de . remove ( com [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> de . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> de . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * de ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> card = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> B_x = B * ( 2 ** i ) <NEWLINE> C_x = C * ( 2 ** ( K - i ) ) <NEWLINE> card . append ( [ A , B_x , C_x ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( len ( card ) ) : <NEWLINE> <INDENT> if card [ i ] [ 2 ] > card [ i ] [ 1 ] > card [ i ] [ 0 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Tree : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , n , left , right ) : <NEWLINE> <INDENT> self . left = left <NEWLINE> self . right = right <NEWLINE> self . n = n <NEWLINE> if left is not None : <NEWLINE> <INDENT> lt = { t + n for t in left . totals } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lt = set ( ) <NEWLINE> <DEDENT> if right is not None : <NEWLINE> <INDENT> rt = right . totals <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rt = set ( ) <NEWLINE> <NL> <DEDENT> self . totals = lt | rt | { n } <NEWLINE> <NL> <DEDENT> def find ( self , total ) : <NEWLINE> <INDENT> return total in self . totals <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> cs = [ ] <NEWLINE> if self . left is not None : <NEWLINE> <INDENT> cs . append ( str ( self . left ) ) <NEWLINE> <DEDENT> if self . right is not None : <NEWLINE> <INDENT> cs . append ( str ( self . right ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . format ( self . n , <STRING> . join ( cs ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def __init__ ( self , ns ) : <NEWLINE> <INDENT> self . top = self . build_nodes ( sorted ( ns ) ) <NEWLINE> <NL> <DEDENT> def has_subset ( self , total ) : <NEWLINE> <INDENT> return self . top . find ( total ) <NEWLINE> <NL> <DEDENT> def build_nodes ( self , ns ) : <NEWLINE> <INDENT> if len ( ns ) == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> left = self . build_nodes ( ns [ : - 1 ] ) <NEWLINE> right = self . build_nodes ( ns [ : - 1 ] ) <NEWLINE> node = self . Node ( ns [ - 1 ] , left , right ) <NEWLINE> <NL> return node <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run_tree ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <COMMENT> <NEWLINE> ns = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> tree = Tree ( ns ) <NEWLINE> _ = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> for q in ( int ( j ) for j in input ( ) . split ( ) ) : <NEWLINE> <INDENT> if tree . has_subset ( q ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run_tree ( ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lrd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for l , r , d in lrd : <NEWLINE> <INDENT> g [ l - 1 ] . append ( [ d , r - 1 ] ) <NEWLINE> g [ r - 1 ] . append ( [ - d , l - 1 ] ) <NEWLINE> <NL> <DEDENT> no_seen = set ( range ( n ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dst = [ inf ] * n <NEWLINE> while no_seen : <NEWLINE> <INDENT> todo = [ [ 0 , no_seen . pop ( ) ] ] <NEWLINE> <COMMENT> <NL> while todo : <NEWLINE> <INDENT> d , t = todo . pop ( ) <NEWLINE> no_seen . discard ( t ) <NEWLINE> l = g [ t ] <NEWLINE> for di , ti in l : <NEWLINE> <INDENT> if dst [ ti ] != inf and dst [ ti ] != d + di : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif dst [ ti ] != inf and dst [ ti ] == d + di : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> todo . append ( [ d + di , ti ] ) <NEWLINE> dst [ ti ] = d + di <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sa = sorted ( a ) <NEWLINE> if Sa [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ k ] <NEWLINE> k += 1 <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from itertools import product <NEWLINE> while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if not H : break <NEWLINE> ma = [ list ( map ( int , input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) ) + [ 0 ] for _ in range ( H ) ] <NEWLINE> for i , j in product ( range ( 1 , H ) , range ( W ) ) : <NEWLINE> <INDENT> if ma [ i ] [ j ] : ma [ i ] [ j ] += ma [ i - 1 ] [ j ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> stk = [ ] <NEWLINE> for j in range ( W + 1 ) : <NEWLINE> <INDENT> cur = ma [ i ] [ j ] <NEWLINE> if ( not stk ) or stk [ - 1 ] [ 1 ] < cur : <NEWLINE> <INDENT> stk . append ( [ j , cur ] ) <NEWLINE> <DEDENT> elif stk [ - 1 ] [ 1 ] > cur : <NEWLINE> <INDENT> idx = j <NEWLINE> while stk and stk [ - 1 ] [ 1 ] >= cur : <NEWLINE> <INDENT> idx = stk [ - 1 ] [ 0 ] <NEWLINE> ans = max ( ans , stk [ - 1 ] [ 1 ] * ( j - stk [ - 1 ] [ 0 ] ) ) <NEWLINE> stk . pop ( ) <NEWLINE> <DEDENT> stk . append ( [ idx , cur ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> YEAH = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> FUCK = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> GOMI = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> GOMI += FUCK [ k ] [ j ] * YEAH [ i ] [ k ] <NEWLINE> <DEDENT> if j != l - 1 : <NEWLINE> <INDENT> print ( GOMI , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( GOMI , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT>
t = str ( input ( ) ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> lst = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> switch = 0 <COMMENT> <NEWLINE> <NL> str_lst = [ s ] <NEWLINE> front_lst = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <NL> <INDENT> if lst [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> switch = 1 - switch <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> f = lst [ i ] [ 1 ] <NEWLINE> c = lst [ i ] [ 2 ] <NEWLINE> <NL> if f == <STRING> : <COMMENT> <NEWLINE> <NL> <INDENT> if switch == 0 : <NEWLINE> <INDENT> front_lst . append ( c ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> str_lst . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> if switch == 0 : <NEWLINE> <INDENT> str_lst . append ( c ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> front_lst . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> front = <STRING> . join ( front_lst ) <NEWLINE> front = front [ : : - 1 ] <NEWLINE> after = <STRING> . join ( str_lst ) <NEWLINE> answer = front + after <NEWLINE> <NL> if switch == 1 : <NEWLINE> <INDENT> answer = answer [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> all_str = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> str_temp = input ( ) <NEWLINE> all_str . append ( str_temp ) <NEWLINE> <DEDENT> all_str . sort ( ) <NEWLINE> coll_str = ( collections . Counter ( all_str ) ) <NEWLINE> count_max = 0 <NEWLINE> j = 0 <NEWLINE> max_str = coll_str . most_common ( ) <NEWLINE> for i in max_str : <NEWLINE> <NL> <INDENT> num_of_str = i [ 1 ] <NEWLINE> if num_of_str == count_max or j == 0 : <NEWLINE> <INDENT> print ( i [ 0 ] ) <NEWLINE> j = 1 <NEWLINE> count_max = num_of_str <NEWLINE> <NL> <DEDENT> if num_of_str < count_max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ x , y ] ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> s = set ( ) <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> s . add ( ( l [ k ] [ 0 ] - l [ j ] [ 0 ] , l [ k ] [ 1 ] - l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> s_l = sorted ( list ( s ) ) <NEWLINE> cnt = [ 0 ] * len ( s_l ) <NEWLINE> dic = { } <NEWLINE> for i in range ( len ( s_l ) ) : <NEWLINE> <INDENT> dic [ s_l [ i ] ] = i <NEWLINE> <DEDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> cnt [ dic [ ( l [ k ] [ 0 ] - l [ j ] [ 0 ] , l [ k ] [ 1 ] - l [ j ] [ 1 ] ) ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( n - max ( cnt ) ) <NEWLINE>
import numpy as np <NEWLINE> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A + B > N + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A == 1 : <NEWLINE> <INDENT> if B == N : <NEWLINE> <INDENT> ans = [ i + 1 for i in reversed ( range ( N ) ) ] <NEWLINE> print ( * ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if B == 1 : <NEWLINE> <INDENT> if A == N : <NEWLINE> <INDENT> ans = [ i + 1 for i in range ( N ) ] <NEWLINE> print ( * ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if A >= B : <NEWLINE> <INDENT> Flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> A , B = B , A <NEWLINE> <COMMENT> <NL> <DEDENT> if A * B < N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = [ 1 for _ in range ( B ) ] <NEWLINE> nokori = N - B <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> if A - L [ i ] > 0 : <NEWLINE> <INDENT> temp = min ( A - L [ i ] , nokori ) <NEWLINE> L [ i ] += temp <NEWLINE> nokori -= temp <NEWLINE> <DEDENT> if nokori == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> now = 0 <NEWLINE> P = [ [ ] for _ in range ( B ) ] <NEWLINE> for i , num in enumerate ( L ) : <NEWLINE> <INDENT> for j in range ( num ) : <NEWLINE> <INDENT> now += 1 <NEWLINE> P [ - i - 1 ] . append ( now ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = P <NEWLINE> output = [ ] <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> for j in ans [ i ] : <NEWLINE> <INDENT> output . append ( j ) <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( * output ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = output [ : : - 1 ] <NEWLINE> print ( * output ) <NEWLINE> <DEDENT> <DEDENT>
from math import pi <NEWLINE> k = float ( input ( ) ) <NEWLINE> print ( pi * k ** 2 , pi * k * 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> ruiseki = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ruiseki += a [ j - 1 ] <NEWLINE> res = res + a [ j ] * ruiseki <NEWLINE> <DEDENT> print ( res % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> import math <NEWLINE> if abs ( B - A ) / ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = n <NEWLINE> lol = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> lol . sort ( ) <NEWLINE> lol . reverse ( ) <NEWLINE> z = lol . copy ( ) <NEWLINE> ans += lol [ 0 ] <NEWLINE> lol . remove ( max ( lol ) ) <NEWLINE> n = n - 2 <NEWLINE> <NL> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> for i in range ( int ( n / 2 ) ) : <NEWLINE> <INDENT> ans += ( 2 * lol [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( ( n - 1 ) / 2 ) ) : <NEWLINE> <INDENT> ans += ( 2 * lol [ i ] ) <NEWLINE> <DEDENT> ans += ( z [ int ( x / 2 ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> arr = sorted ( arr ) <NEWLINE> def solve ( arr , ans ) : <NEWLINE> <INDENT> for i in arr : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> return ( - 1 ) <NEWLINE> <DEDENT> if ( ans == 0 ) : <NEWLINE> <INDENT> return ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> return ( - 1 ) <NEWLINE> <DEDENT> return ( ans ) <NEWLINE> <DEDENT> print ( solve ( arr , ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_input = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_li = [ True ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> <NL> if h_input [ a ] > h_input [ b ] : <NEWLINE> <INDENT> ans_li [ b ] = False <NEWLINE> <DEDENT> if h_input [ a ] < h_input [ b ] : <NEWLINE> <INDENT> ans_li [ a ] = False <NEWLINE> <DEDENT> if h_input [ a ] == h_input [ b ] : <NEWLINE> <INDENT> ans_li [ a ] = False <NEWLINE> ans_li [ b ] = False <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans_li ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> d = deque ( [ A [ 0 ] ] ) <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N , 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += d . popleft ( ) <NEWLINE> d . extend ( [ A [ i ] , A [ i ] ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> dll = deque ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> operation = input ( ) . split ( <STRING> ) <NEWLINE> if operation [ 0 ] in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> key = operation [ 1 ] <NEWLINE> if operation [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( key ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if operation [ 0 ] [ 6 ] == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dll ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> anss = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> anss [ - i - 1 ] = anss [ - i ] + a [ - i ] <NEWLINE> if anss [ - i - 1 ] > 10 ** 9 + 7 : <NEWLINE> <INDENT> anss [ - i - 1 ] %= 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * anss [ i + 1 ] <NEWLINE> if ans > 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( i ) : <NEWLINE> <INDENT> a = int ( A * i / B ) <NEWLINE> b = A * int ( i / B ) <NEWLINE> return a - b <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( min ( N , B - 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if n >= a >= 1 : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if B < N : <NEWLINE> <INDENT> Max = int ( A * ( B - 1 ) / B ) <NEWLINE> X = int ( N / B ) <NEWLINE> fx = int ( A * ( B * X - 1 ) / B ) - A * int ( ( B * X - 1 ) / B ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif B == N : <NEWLINE> <INDENT> Max = int ( A * ( B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Max = int ( A * N / B ) <NEWLINE> <DEDENT> print ( Max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> c = 0 <NEWLINE> s = sum ( A ) <NEWLINE> table = [ 0 ] * 100001 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> c = table [ B ] <NEWLINE> s += ( C - B ) * c <NEWLINE> table [ C ] += table [ B ] <NEWLINE> table [ B ] = 0 <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> for s in S : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in l : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def keisan ( numlist ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if <STRING> in numlist : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> for i in numlist : <NEWLINE> <INDENT> ans *= int ( i ) <NEWLINE> if ans > max : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> num = input ( ) <NEWLINE> numlist = input ( ) . split ( ) <NEWLINE> <NL> max = 10 ** 18 <NEWLINE> print ( keisan ( numlist ) ) <NEWLINE>
def kai ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> kai ( ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( 0 , N ) ] <NEWLINE> for x , y , z in itertools . product ( range ( 1 , int ( N ** ( 1 / 2 ) + 1 ) ) , range ( 1 , int ( N ** ( 1 / 2 ) + 1 ) ) , range ( 1 , int ( N ** ( 1 / 2 ) + 1 ) ) ) : <NEWLINE> <INDENT> kai = x ** 2 + y ** 2 + z ** 2 + x * y + x * z + y * z <NEWLINE> if 0 < kai <= N : <NEWLINE> <INDENT> ans [ kai - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
p = 998244353 <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> cmb = 1 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += M * pow ( M - 1 , N - k - 1 , p ) * cmb <NEWLINE> ans %= p <NEWLINE> cmb *= ( N - 1 - k ) * pow ( k + 1 , p - 2 , p ) <NEWLINE> cmb %= p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def slove ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a_max = A [ - 1 ] + 1 <NEWLINE> B = [ 0 ] * a_max <NEWLINE> for value in A : <NEWLINE> <INDENT> B [ value ] += 1 <NEWLINE> for i in range ( value * 2 , a_max , value ) : <NEWLINE> <INDENT> B [ i ] += 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( B . count ( 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> slove ( ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ i - 1 for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . n = num <COMMENT> <NEWLINE> self . parents = [ - 1 for i in range ( self . n ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> xx = self . find ( x ) <COMMENT> <NEWLINE> yy = self . find ( y ) <COMMENT> <NEWLINE> if xx == yy : <NEWLINE> <INDENT> return <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> size_xx = abs ( self . parents [ xx ] ) <COMMENT> <NEWLINE> size_yy = abs ( self . parents [ yy ] ) <COMMENT> <NEWLINE> if size_xx > size_yy : <NEWLINE> <INDENT> xx , yy = yy , xx <COMMENT> <NEWLINE> <NL> <DEDENT> self . parents [ yy ] += self . parents [ xx ] <COMMENT> <NEWLINE> self . parents [ xx ] = yy <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> xx = self . find ( x ) <NEWLINE> return abs ( self . parents [ xx ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return 1 if self . find ( x ) == self . find ( y ) else 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> xx = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == xx ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def state_grouping ( self ) : <NEWLINE> <INDENT> return list ( self . all_group_members ( ) . values ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += uf . same ( i , P [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> def dfs ( i , now , done ) : <NEWLINE> <INDENT> global count <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> return <NEWLINE> <NL> <DEDENT> for j in ab [ now ] : <NEWLINE> <INDENT> if j not in done : <NEWLINE> <INDENT> dfs ( i + 1 , j , done + [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 , [ 0 ] ) <NEWLINE> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ i for i in range ( 1 , int ( N ** .5 ) + 1 ) ] [ : : - 1 ] <NEWLINE> for i in P : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> print ( len ( str ( N // i ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
num = ( int ) ( input ( ) ) <NEWLINE> n = num // 100 <NEWLINE> amari = num % 100 <NEWLINE> if num <= 99 or amari / n > 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lamps = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) [ 1 : ] for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 << n ) : <NEWLINE> <INDENT> for r in range ( m ) : <NEWLINE> <INDENT> on_sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 and j in lamps [ r ] : <NEWLINE> <INDENT> on_sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if on_sum % 2 != p [ r ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( S ) <NEWLINE> if len ( c ) == 3 : <NEWLINE> <NL> <INDENT> u = 1 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> u = u * i <NEWLINE> <DEDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , int ( ( N - 1 + i ) / 2 ) + 1 ) : <NEWLINE> <NL> <INDENT> if set ( [ S [ i ] , S [ j ] , S [ 2 * j - i ] ] ) == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> u = u - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> m -= a [ i ] <NEWLINE> ans += a [ i ] * m <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = ( input ( ) ) . split ( ) <NEWLINE> task = input ( ) . split ( ) <NEWLINE> list1 = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in task : <NEWLINE> <INDENT> list1 . append ( i ) <NEWLINE> <DEDENT> for j in list1 : <NEWLINE> <INDENT> sum = sum + int ( j ) <NEWLINE> <DEDENT> result = int ( N ) - sum <NEWLINE> if result < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> input = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> temp = sum ( input ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> temp = temp - input [ i ] <NEWLINE> ans = ( ans + ( input [ i ] * ( ( temp ) % ( 10 ** 9 + 7 ) ) ) % ( 10 ** 9 + 7 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans = ans * n [ i ] <NEWLINE> <DEDENT> if n [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import math <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> X = input ( ) . strip ( ) <NEWLINE> return N , X <NEWLINE> <NL> <NL> <DEDENT> def bitdiv ( N : int , X : str , d : int ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> q <<= 1 <NEWLINE> q |= int ( X [ i ] ) <NEWLINE> p , q = divmod ( q , d ) <NEWLINE> <DEDENT> return q <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , X ) : <NEWLINE> <INDENT> BP = [ 0 for i in range ( N ) ] <NEWLINE> BM = [ 0 for i in range ( N ) ] <NEWLINE> <NL> c = X . count ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> qp = bitdiv ( N , X , c + 1 ) <NEWLINE> BP [ N - 1 ] = 1 % ( c + 1 ) <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> BP [ i ] = ( BP [ i + 1 ] * 2 ) % ( c + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if c > 1 : <NEWLINE> <INDENT> qm = bitdiv ( N , X , c - 1 ) <NEWLINE> BM [ N - 1 ] = 1 % ( c - 1 ) <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> BM [ i ] = ( BM [ i + 1 ] * 2 ) % ( c - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> ans = 0 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> q = ( qp + BP [ i ] ) % ( c + 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif X [ i ] == <STRING> and c > 1 : <NEWLINE> <COMMENT> <NL> <INDENT> q = ( qm - BM [ i ] ) % ( c - 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = 0 <NEWLINE> ans = 0 <NEWLINE> <DEDENT> while q > 0 : <NEWLINE> <INDENT> q %= ( bin ( q ) . count ( <STRING> ) ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
buffer = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> buffer . append ( [ x , y ] ) <NEWLINE> <DEDENT> for n in range ( len ( buffer ) ) : <NEWLINE> <INDENT> for r in range ( buffer [ n ] [ 0 ] ) : <NEWLINE> <INDENT> for c in range ( buffer [ n ] [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> HEIGHT = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MA = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> MA . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> hasi1 , hasi2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> MA [ hasi1 - 1 ] = max ( MA [ hasi1 - 1 ] , HEIGHT [ hasi2 - 1 ] ) <NEWLINE> MA [ hasi2 - 1 ] = max ( MA [ hasi2 - 1 ] , HEIGHT [ hasi1 - 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if HEIGHT [ i ] > MA [ i ] : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dll = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> input_line = input ( ) . split ( ) <NEWLINE> if input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( input_line [ 1 ] ) <NEWLINE> <DEDENT> elif len ( dll ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( input_line [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * dll ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> max_val = max ( a ) <NEWLINE> dp = [ True for i in range ( max_val ) ] <NEWLINE> done = [ 0 for i in range ( max_val ) ] <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <NL> <INDENT> if 1 <= done [ i - 1 ] : <NEWLINE> <INDENT> done [ i - 1 ] += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> done [ i - 1 ] += 1 <NEWLINE> cnt = 1 <NEWLINE> while ( i * cnt <= max_val ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt * i <= max_val : <NEWLINE> <INDENT> done [ cnt * i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if done [ i - 1 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import * <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> <NL> ab = Decimal ( a ) * Decimal ( b ) <NEWLINE> result = Decimal ( str ( ab ) ) . quantize ( Decimal ( str ( 1 ) ) , rounding = ROUND_DOWN ) <NEWLINE> <NL> print ( int ( result ) ) <NEWLINE>
from math import sqrt <NEWLINE> from collections import deque <NEWLINE> <NL> def sub ( a , b ) : <NEWLINE> <INDENT> return [ a [ 0 ] - b [ 0 ] , a [ 1 ] - b [ 1 ] ] <NEWLINE> <NL> <DEDENT> def cross ( a , b ) : <NEWLINE> <INDENT> return a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] <NEWLINE> <NL> <DEDENT> def ccw ( a , b , c ) : <NEWLINE> <INDENT> x = sub ( b , a ) <NEWLINE> y = sub ( c , a ) <NEWLINE> return cross ( x , y ) > 0 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> c . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> U = deque ( c [ : 2 ] ) <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> j = len ( U ) <NEWLINE> while j >= 2 and ccw ( U [ - 1 ] , U [ - 2 ] , c [ i ] ) : <NEWLINE> <INDENT> U . pop ( ) <NEWLINE> j -= 1 <NEWLINE> <DEDENT> U . append ( c [ i ] ) <NEWLINE> <NL> <DEDENT> c = c [ : : - 1 ] <NEWLINE> L = deque ( c [ : 2 ] ) <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> j = len ( L ) <NEWLINE> while j >= 2 and ccw ( L [ - 1 ] , L [ - 2 ] , c [ i ] ) : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> j -= 1 <NEWLINE> <DEDENT> L . append ( c [ i ] ) <NEWLINE> <NL> <DEDENT> ans = U <NEWLINE> for i in range ( 1 , len ( L ) - 1 ) : <NEWLINE> <INDENT> x , y = L [ i ] <NEWLINE> ans . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE> i = ans . index ( sorted ( ans , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) [ 0 ] ) <NEWLINE> ans = list ( ans ) <NEWLINE> for x , y in ans [ i : ] + ans [ : i ] : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> area = math . pi * r * r <NEWLINE> circle = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( area , circle ) ) <NEWLINE> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_ , b_ = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_ . append ( a_ [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_ . append ( b_ [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_ [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_ [ j ] > k - a_ [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = p ^ a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( p ^ a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> que = deque ( ) <NEWLINE> dist = [ float ( <STRING> ) ] * n <NEWLINE> prev = [ - 1 ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> que . append ( 0 ) <NEWLINE> while que : <NEWLINE> <INDENT> now = que . popleft ( ) <NEWLINE> for edge in edges [ now ] : <NEWLINE> <INDENT> if dist [ edge ] > dist [ now ] + 1 : <NEWLINE> <INDENT> dist [ edge ] = dist [ now ] + 1 <NEWLINE> prev [ edge ] = now + 1 <NEWLINE> que . append ( edge ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( prev [ i ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> l . append ( a ) <NEWLINE> <DEDENT> b = set ( l ) <NEWLINE> print ( len ( b ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> if ( i == j and j == k and i == k ) : ans += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> elif ( i != j and j != k and i != k ) : ans += math . gcd ( math . gcd ( i , j ) , k ) * 6 <NEWLINE> else : ans += math . gcd ( math . gcd ( i , j ) , k ) * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( itertools . accumulate ( A ) ) <NEWLINE> B = list ( itertools . accumulate ( B ) ) <NEWLINE> <NL> count = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while A [ i ] + B [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> count = max ( count , i + j ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> t = dict ( ) <NEWLINE> ans = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if tmp in t : <NEWLINE> <INDENT> t [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ tmp ] = 1 <NEWLINE> <DEDENT> <DEDENT> max_v = max ( t . values ( ) ) <NEWLINE> ans = [ kv [ 0 ] for kv in t . items ( ) if kv [ 1 ] == max_v ] <NEWLINE> ans . sort ( ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> count = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> count [ i [ 0 ] ] += 1 <NEWLINE> <DEDENT> l = [ 0 ] * n <NEWLINE> ans = max ( count ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> M = max ( count ) <NEWLINE> ind = count . index ( M ) <NEWLINE> s . add ( ind ) <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if a [ j ] [ l [ j ] ] == ind : <NEWLINE> <NL> <INDENT> count [ ind ] -= 1 <NEWLINE> while a [ j ] [ l [ j ] ] in s : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> count [ a [ j ] [ l [ j ] ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , max ( count ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import heapq <COMMENT> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> heapq . heapify ( A ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <COMMENT> <NEWLINE> a = - a // 2 <COMMENT> <NEWLINE> heapq . heappush ( A , - a ) <COMMENT> <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> print ( N * T // X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( N // X ) + 1 ) * T ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in a_list : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > ( 10 ** 18 ) : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> dp = np . zeros ( w + 1 , dtype = int ) <NEWLINE> <NL> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> w , v = map ( int , x . split ( ) ) <NEWLINE> np . maximum ( dp [ w : ] , dp [ : - w ] + v , out = dp [ w : ] ) <NEWLINE> <DEDENT> print ( dp . max ( ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def ff ( x , y , z ) : <NEWLINE> <INDENT> return ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> an = [ 0 ] * n <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> wk = ff ( i , j , k ) <NEWLINE> if wk <= n : <NEWLINE> <INDENT> an [ wk - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in an : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def delete_head_zeros ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> l = len ( n ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> l = n . find ( <STRING> ) <NEWLINE> <DEDENT> head_zeros = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> head_zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return n [ head_zeros : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_compare ( a , b ) : <NEWLINE> <INDENT> a = delete_head_zeros ( a ) <NEWLINE> b = delete_head_zeros ( b ) <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( a ) < len ( b ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def bigint_plus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> d = max ( [ len ( a ) , len ( b ) ] ) <NEWLINE> a = <STRING> * ( d - len ( a ) ) + a <NEWLINE> b = <STRING> * ( d - len ( b ) ) + b <NEWLINE> <NL> ans = <STRING> <NEWLINE> carry = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = int ( a [ - i - 1 ] ) + int ( b [ - i - 1 ] ) + carry <NEWLINE> carry = s // 10 <NEWLINE> ans = str ( s % 10 ) + ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> ans = str ( carry ) + ans <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_minus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> M = [ ] <NEWLINE> m = [ ] <NEWLINE> sign = <STRING> <NEWLINE> <NL> if len ( a ) > len ( b ) or ( len ( a ) == len ( b ) and a >= b ) : <NEWLINE> <INDENT> [ M , m ] = [ a , b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ M , m ] = [ b , a ] <NEWLINE> sign = <STRING> <NEWLINE> <DEDENT> m = <STRING> * ( len ( M ) - len ( m ) ) + m <NEWLINE> <NL> ans = <STRING> <NEWLINE> borrow = 0 <NEWLINE> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> s = int ( M [ - i - 1 ] ) - int ( m [ - i - 1 ] ) - borrow <NEWLINE> if s < 0 : <NEWLINE> <INDENT> borrow = 1 <NEWLINE> s += 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> borrow = 0 <NEWLINE> <DEDENT> ans = str ( s ) + ans <NEWLINE> <NL> <DEDENT> return sign + delete_head_zeros ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_multiply ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> md = [ ] <NEWLINE> carry = 0 <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> mj = <STRING> <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m = int ( a [ - i - 1 ] ) * int ( b [ - j - 1 ] ) + carry <NEWLINE> carry = m // 10 <NEWLINE> mj = str ( m % 10 ) + mj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> mj = str ( carry ) + mj <NEWLINE> <DEDENT> <DEDENT> md . append ( mj ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( len ( md ) ) : <NEWLINE> <INDENT> ans = bigint_plus ( md [ k ] + <STRING> * k , ans ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_divide ( a , b , d = 0 ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> d = int ( d ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> r = <STRING> <NEWLINE> for i in range ( len ( a ) + d ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> if i < len ( a ) : <NEWLINE> <INDENT> r += a [ i ] <NEWLINE> <DEDENT> elif i == len ( a ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> r += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += <STRING> <NEWLINE> <NL> <DEDENT> if bigint_compare ( r , b ) == - 1 : <NEWLINE> <INDENT> ans += str ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while bigint_compare ( r , b ) >= 0 : <NEWLINE> <INDENT> r = bigint_minus ( r , b ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> ans += str ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delete_head_zeros ( ans ) <NEWLINE> <NL> <NL> <DEDENT> a , b , x = [ n for n in input ( ) . split ( <STRING> ) ] <NEWLINE> c1 = bigint_divide ( b , x ) <NEWLINE> <NL> if int ( a ) == 0 : <NEWLINE> <INDENT> c2 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c2 = bigint_divide ( bigint_minus ( a , 1 ) , x ) <NEWLINE> <NL> <DEDENT> if int ( a ) == 0 : <NEWLINE> <INDENT> print ( bigint_plus ( bigint_minus ( c1 , c2 ) , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bigint_minus ( c1 , c2 ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = [ 0 ] * k <NEWLINE> a = [ ] <NEWLINE> snuk = [ False ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> snuk [ j - 1 ] = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if snuk [ i ] == False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> R , G , B = 0 , 0 , 0 <NEWLINE> <NL> for char in S : <NEWLINE> <INDENT> if char == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif char == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> i2j = j - i <NEWLINE> try : <NEWLINE> <INDENT> if not S [ j + i2j ] in [ S [ i ] , S [ j ] ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> n = int ( pin ( ) ) <NEWLINE> a = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> b = deque ( [ ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> b . appendleft ( a [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> pout ( str ( b [ k ] ) ) <NEWLINE> if k != n - 1 : <NEWLINE> <INDENT> pout ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> pout ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> imput = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> M = max ( A ) + 1 <NEWLINE> B = [ True ] * ( M + 1 ) <NEWLINE> A = sorted ( A ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> answer = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] : <NEWLINE> <INDENT> for j in range ( a , M , a ) : <NEWLINE> <INDENT> B [ j ] = False <NEWLINE> <DEDENT> if C [ a ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x <= 0 or x % 1 != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , int ( math . sqrt ( x ) // 1 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> S = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) and is_prime ( ( i + 1 ) / 2 ) : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <DEDENT> S [ i ] += S [ i - 1 ] <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( S [ r ] - S [ l - 1 ] ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> pattern = list ( product ( [ <STRING> , <STRING> ] , repeat = n - 1 ) ) <NEWLINE> <NL> for i in range ( 2 ** ( n - 1 ) ) : <NEWLINE> <INDENT> formula = s [ 0 ] <NEWLINE> for j , k in zip ( pattern [ i ] , s [ 1 : ] ) : <NEWLINE> <INDENT> formula += ( j + k ) <NEWLINE> <DEDENT> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( <STRING> . format ( formula ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> L = [ i for i in range ( 0 , 102 ) if i not in P ] <NEWLINE> <NL> if X in L : <NEWLINE> <INDENT> ANS = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( X ) <NEWLINE> L = sorted ( L ) <NEWLINE> n = L . index ( X ) <NEWLINE> l = len ( L ) - 1 <NEWLINE> <NL> <NL> if ( 0 < n < l ) : <NEWLINE> <INDENT> if ( L [ n + 1 ] - L [ n ] < L [ n ] - L [ n - 1 ] ) : <NEWLINE> <INDENT> ANS = L [ n + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ANS = L [ n - 1 ] <NEWLINE> <DEDENT> <DEDENT> elif ( n == l ) : <NEWLINE> <INDENT> ANS = L [ l - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ex = [ 0 ] * 1000001 <NEWLINE> for a in A : ex [ a ] += 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> if ex [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( i + i , 1000001 , i ) : ex [ j ] = 0 <NEWLINE> if ex [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> EP = [ 0 ] * ( N + 1 ) <NEWLINE> WP = [ 0 ] * ( N + 1 ) <NEWLINE> CP = [ 0 ] * N <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> EP [ N - T - 1 ] = EP [ N - T ] + ( S [ N - 1 - T ] == <STRING> ) <NEWLINE> WP [ T + 1 ] = WP [ T ] + ( S [ T ] == <STRING> ) <NEWLINE> <DEDENT> for T in range ( 0 , N ) : <NEWLINE> <INDENT> CP [ T ] = EP [ T + 1 ] + WP [ T ] <NEWLINE> <DEDENT> print ( min ( CP ) ) <NEWLINE>
A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A < B < C : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if B <= A : <NEWLINE> <INDENT> B *= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if ans == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A < B < C : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if B >= C : <NEWLINE> <INDENT> C *= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if ans == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A < B < C : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if A < B < C : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
NIL = - 1 <NEWLINE> <NL> <NL> class Node : <NEWLINE> <INDENT> right = NIL <NEWLINE> left = NIL <NEWLINE> parent = NIL <NEWLINE> <NL> <NL> <DEDENT> def setHeight ( u ) : <NEWLINE> <INDENT> global T , H <NEWLINE> hr = 0 <NEWLINE> hl = 0 <NEWLINE> if T [ u ] . right != NIL : <NEWLINE> <INDENT> hr = setHeight ( T [ u ] . right ) + 1 <NEWLINE> <DEDENT> if T [ u ] . left != NIL : <NEWLINE> <INDENT> hl = setHeight ( T [ u ] . left ) + 1 <NEWLINE> <DEDENT> h = max ( hr , hl ) <NEWLINE> H [ u ] = h <NEWLINE> return h <NEWLINE> <NL> <NL> <DEDENT> def setDepth ( u , d ) : <NEWLINE> <INDENT> global T , D <NEWLINE> D [ u ] = d <NEWLINE> if T [ u ] . right != NIL : <NEWLINE> <INDENT> setDepth ( T [ u ] . right , d + 1 ) <NEWLINE> <DEDENT> if T [ u ] . left != NIL : <NEWLINE> <INDENT> setDepth ( T [ u ] . left , d + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getSibling ( u ) : <NEWLINE> <INDENT> global T <NEWLINE> if T [ u ] . parent == NIL : <NEWLINE> <INDENT> return NIL <NEWLINE> <DEDENT> if T [ T [ u ] . parent ] . left != u and T [ T [ u ] . parent ] . left != NIL : <NEWLINE> <INDENT> return T [ T [ u ] . parent ] . left <NEWLINE> <DEDENT> if T [ T [ u ] . parent ] . right != u and T [ T [ u ] . parent ] . right != NIL : <NEWLINE> <INDENT> return T [ T [ u ] . parent ] . right <NEWLINE> <DEDENT> return NIL <NEWLINE> <NL> <NL> <DEDENT> def getDegree ( u ) : <NEWLINE> <INDENT> global T <NEWLINE> deg = 0 <NEWLINE> if T [ u ] . left != NIL : deg += 1 <NEWLINE> if T [ u ] . right != NIL : deg += 1 <NEWLINE> return deg <NEWLINE> <NL> <NL> <DEDENT> def show_info ( u ) : <NEWLINE> <INDENT> global T , D , H <NEWLINE> label = <STRING> <NEWLINE> if T [ u ] . parent == NIL : <NEWLINE> <INDENT> label = <STRING> <NEWLINE> <DEDENT> elif T [ u ] . left == NIL and T [ u ] . right == NIL : <NEWLINE> <INDENT> label = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> label = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( u , T [ u ] . parent , <NEWLINE> <INDENT> getSibling ( u ) , <NEWLINE> getDegree ( u ) , <NEWLINE> D [ u ] , <NEWLINE> H [ u ] , label ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> T , D , H = [ ] , [ ] , [ ] <NEWLINE> root_num = NIL <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> T . append ( Node ( ) ) <NEWLINE> D . append ( NIL ) <NEWLINE> H . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> id , r , l = map ( int , input ( ) . split ( ) ) <NEWLINE> T [ id ] . right = r <NEWLINE> T [ id ] . left = l <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if T [ i ] . right != NIL : <NEWLINE> <INDENT> T [ T [ i ] . right ] . parent = i <NEWLINE> <DEDENT> if T [ i ] . left != NIL : <NEWLINE> <INDENT> T [ T [ i ] . left ] . parent = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if T [ i ] . parent == NIL : <NEWLINE> <INDENT> root_num = i <NEWLINE> <NL> <DEDENT> <DEDENT> setHeight ( root_num ) <NEWLINE> setDepth ( root_num , 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> show_info ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> items = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> items [ s ] = 0 <NEWLINE> <DEDENT> print ( len ( items ) ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> table = [ A , B , C ] <NEWLINE> ans = [ ] <NEWLINE> <NL> def ci ( s ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> return 0 , 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> return 1 , 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 , 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if A + B + C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif A + B + C == 1 : <NEWLINE> <INDENT> for s in S : <NEWLINE> <INDENT> i , j = ci ( s ) <NEWLINE> if table [ i ] == 0 and table [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if table [ i ] == 0 : <NEWLINE> <INDENT> table [ i ] = 1 <NEWLINE> table [ j ] = 0 <NEWLINE> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ j ] = 1 <NEWLINE> table [ i ] = 0 <NEWLINE> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> i , j = ci ( S [ k ] ) <NEWLINE> if table [ i ] > table [ j ] : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <COMMENT> <NL> <DEDENT> if k + 1 < N : <NEWLINE> <INDENT> i2 , j2 = ci ( S [ k + 1 ] ) <NEWLINE> <DEDENT> if table [ i ] == 0 and table [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif table [ i ] == 0 and table [ j ] > 0 : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> table [ j ] -= 1 <NEWLINE> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> table [ j ] -= 1 <NEWLINE> if k + 1 < N : <NEWLINE> <INDENT> if table [ i2 ] == 0 and table [ j2 ] == 0 : <NEWLINE> <INDENT> table [ i ] -= 2 <NEWLINE> table [ j ] += 2 <NEWLINE> ans . append ( j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> L = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( L [ a ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> inf = 10 ** 18 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> <NL> if ans > inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sysread = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def run ( ) : <NEWLINE> <INDENT> pri = [ ] <NEWLINE> N , A , B , C = map ( int , sysread ( ) . split ( ) ) <NEWLINE> vals = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> S = [ sysread ( ) for _ in range ( N ) ] <NEWLINE> <NL> pri = [ ] <NEWLINE> for idx , s in enumerate ( S ) : <NEWLINE> <INDENT> if vals [ s [ 0 ] ] == vals [ s [ 1 ] ] and vals [ s [ 0 ] ] == 1 and idx != len ( S ) - 1 : <NEWLINE> <INDENT> if s [ 0 ] in S [ idx + 1 ] : <NEWLINE> <INDENT> vals [ s [ 0 ] ] += 1 <NEWLINE> vals [ s [ 1 ] ] -= 1 <NEWLINE> pri . append ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vals [ s [ 0 ] ] -= 1 <NEWLINE> vals [ s [ 1 ] ] += 1 <NEWLINE> pri . append ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if vals [ s [ 0 ] ] <= vals [ s [ 1 ] ] : <NEWLINE> <INDENT> vals [ s [ 0 ] ] += 1 <NEWLINE> vals [ s [ 1 ] ] -= 1 <NEWLINE> pri . append ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vals [ s [ 0 ] ] -= 1 <NEWLINE> vals [ s [ 1 ] ] += 1 <NEWLINE> pri . append ( s [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if not check_vals ( vals ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for st in pri : <NEWLINE> <INDENT> print ( st ) <NEWLINE> <NL> <DEDENT> <DEDENT> def check_vals ( vals ) : <NEWLINE> <INDENT> for v in vals . values ( ) : <NEWLINE> <INDENT> if v < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> ans = [ 10 ] * N <NEWLINE> for l in lst : <NEWLINE> <INDENT> if ans [ l [ 0 ] - 1 ] < 10 and ans [ l [ 0 ] - 1 ] != l [ 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans [ l [ 0 ] - 1 ] = l [ 1 ] <NEWLINE> <NL> <DEDENT> if ans [ 0 ] == 10 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> ans [ 0 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans [ i ] == 10 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if N != 1 and ans [ 0 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = list ( map ( str , ans ) ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] <NEWLINE> now = 0 <NEWLINE> memo = 0 <NEWLINE> town = [ 0 ] * n <NEWLINE> town [ 0 ] = 1 <NEWLINE> b = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now ] <NEWLINE> if town [ now ] == 1 : <NEWLINE> <INDENT> memo = now <NEWLINE> b = 1 <NEWLINE> break <NEWLINE> <DEDENT> lst . append ( now ) <NEWLINE> town [ now ] = 1 <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> i = lst . index ( memo ) <NEWLINE> l = len ( lst ) <NEWLINE> if memo != 0 : <NEWLINE> <INDENT> lst = lst [ i : ] <NEWLINE> l -= len ( lst ) <NEWLINE> print ( lst [ ( k - l ) % len ( lst ) ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( lst [ k % l ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> b = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> ca = Counter ( a ) <NEWLINE> cb = Counter ( b ) <NEWLINE> for k in cb . keys ( ) : <NEWLINE> <INDENT> if cb [ k ] > n - ca [ k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> shift = max ( ca [ k ] for k in cb . keys ( ) ) <NEWLINE> while any ( a == b ) : <NEWLINE> <INDENT> b = np . roll ( b , shift ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
MOD = 998244353 <NEWLINE> <NL> fact = [ 0 ] * 220000 <NEWLINE> invfact = [ 0 ] * 220000 <NEWLINE> <NL> fact [ 0 ] = 1 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % MOD <NEWLINE> <NL> <DEDENT> invfact [ 220000 - 1 ] = pow ( fact [ 220000 - 1 ] , MOD - 2 , MOD ) <NEWLINE> <NL> for i in range ( 220000 - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> invfact [ i ] = invfact [ i + 1 ] * ( i + 1 ) % MOD <NEWLINE> <NL> <DEDENT> def nCk ( n , k ) : <NEWLINE> <INDENT> if k < 0 or n < k : return 0 <NEWLINE> return fact [ n ] * invfact [ k ] * invfact [ n - k ] % MOD <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> ans += m * ( pow ( m - 1 , n - i - 1 , MOD ) % MOD ) * ( nCk ( n - 1 , i ) % MOD ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c_list = [ ] <NEWLINE> <NL> for i in range ( - 101 , 102 , 1 ) : <NEWLINE> <INDENT> c_list . append ( i ) <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> c_list [ c_list . index ( p [ i ] ) ] = 250 <NEWLINE> <COMMENT> <NL> <DEDENT> diff = 500 <NEWLINE> for i in range ( len ( c_list ) ) : <NEWLINE> <INDENT> if abs ( x - c_list [ i ] ) < diff : <NEWLINE> <INDENT> diff = x - c_list [ i ] <NEWLINE> ans = c_list [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for i in range ( len ( AL [ v ] [ CHILDREN ] ) ) : <NEWLINE> <INDENT> u = AL [ v ] [ CHILDREN ] [ i ] <NEWLINE> if visited [ u ] : <NEWLINE> <INDENT> AL [ v ] [ CHILDREN ] [ i ] = None <NEWLINE> continue <NEWLINE> <DEDENT> AL [ v ] [ SIZE ] += dfs ( u ) <NEWLINE> <DEDENT> return AL [ v ] [ SIZE ] <NEWLINE> <NL> <NL> <DEDENT> def anaaki ( v ) : <NEWLINE> <INDENT> ret = powp - 1 <NEWLINE> for ch in AL [ v ] [ CHILDREN ] : <NEWLINE> <INDENT> if ch is None : continue <NEWLINE> ret -= pow ( 2 , AL [ ch ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> <DEDENT> ret -= pow ( 2 , n - AL [ v ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> SIZE = 0 <NEWLINE> CHILDREN = 1 <NEWLINE> AL = [ [ 1 , [ ] ] for _ in range ( n ) ] <NEWLINE> visited = [ False ] * n <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> powp = pow ( 2 , n - 1 , p ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> AL [ a ] [ CHILDREN ] . append ( b ) <NEWLINE> AL [ b ] [ CHILDREN ] . append ( a ) <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> numer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numer += anaaki ( i ) <NEWLINE> numer %= p <NEWLINE> <NL> <DEDENT> denom = pow ( 2 , n , p ) <NEWLINE> print ( numer * pow ( denom , p - 2 , p ) % p ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( math . pi * r ** 2 ) , <STRING> . format ( 2 * math . pi * r ) ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( A ) >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = list ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> d = deque ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t = list ( input ( ) . split ( ) ) <NEWLINE> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> c *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ 1 ] == <STRING> : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> d . appendleft ( t [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( t [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> d . append ( t [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . appendleft ( t [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( d ) [ : : c ] ) ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> import decimal <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> p = find ( x ) <NEWLINE> q = find ( y ) <NEWLINE> if p == q : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if p > q : <NEWLINE> <INDENT> p , q = q , p <NEWLINE> <DEDENT> par [ p ] += par [ q ] <NEWLINE> par [ q ] = p <NEWLINE> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <DEDENT> n = 0 <NEWLINE> par = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> def prime_numbers ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime_numbers = [ i for i in range ( x ) ] <NEWLINE> prime_numbers [ 1 ] = 0 <NEWLINE> for prime_number in prime_numbers : <NEWLINE> <INDENT> if prime_number > math . sqrt ( x ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if prime_number == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for composite_number in range ( 2 * prime_number , x , prime_number ) : <NEWLINE> <INDENT> prime_numbers [ composite_number ] = 0 <NEWLINE> <DEDENT> <DEDENT> return [ prime_number for prime_number in prime_numbers if prime_number != 0 ] <NEWLINE> <DEDENT> def is_prime ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if x == 2 or x == 3 or x == 5 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x % 2 == 0 or x % 3 == 0 or x % 5 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> prime_number = 7 <NEWLINE> difference = 4 <NEWLINE> while prime_number <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % prime_number == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> prime_number += difference <NEWLINE> difference = 6 - difference <NEWLINE> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return fa [ n ] * fi [ r ] % mod * fi [ n - r ] % mod <NEWLINE> <DEDENT> fa = [ 1 ] * ( n + 1 ) <NEWLINE> fi = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fa [ i ] = fa [ i - 1 ] * i % mod <NEWLINE> fi [ i ] = pow ( fa [ i ] , mod - 2 , mod ) <NEWLINE> <COMMENT> <NL> <DEDENT> BIT = [ 0 ] * ( n + 1 ) <NEWLINE> def add ( i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> BIT [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> def query ( i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += BIT [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> <DEDENT> from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> li = [ 1 for i in range ( n - k + 1 ) ] <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> if p [ i - 1 ] > p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> li [ 0 ] = 0 <NEWLINE> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if p [ i - 1 ] > p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if p [ i - k ] > p [ i - k + 1 ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> li [ i - k + 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> Q1 = deque ( [ ] ) <NEWLINE> Q2 = deque ( [ ] ) <NEWLINE> L1 = [ 0 for i in range ( n - k + 2 ) ] <NEWLINE> L2 = [ 0 for i in range ( n - k + 2 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while Q1 and p [ Q1 [ - 1 ] ] > p [ i ] : <NEWLINE> <INDENT> Q1 . pop ( ) <NEWLINE> <DEDENT> while Q2 and p [ Q2 [ - 1 ] ] < p [ i ] : <NEWLINE> <INDENT> Q2 . pop ( ) <NEWLINE> <DEDENT> Q1 . append ( i ) <NEWLINE> Q2 . append ( i ) <NEWLINE> if Q1 [ 0 ] == i - k + 1 : <NEWLINE> <INDENT> Q1 . popleft ( ) <NEWLINE> <DEDENT> if Q2 [ 0 ] == i - k + 1 : <NEWLINE> <INDENT> Q2 . popleft ( ) <NEWLINE> <DEDENT> if i >= k - 2 : <NEWLINE> <INDENT> L1 [ i - k + 2 ] = p [ Q1 [ 0 ] ] <NEWLINE> L2 [ i - k + 2 ] = p [ Q2 [ 0 ] ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] > L1 [ i ] or p [ i + k - 1 ] < L2 [ i ] : <NEWLINE> <INDENT> if li [ i ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - min ( li ) + li [ 0 ] + 1 ) <NEWLINE>
N , D = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> D = int ( D ) <NEWLINE> X = list ( ) <NEWLINE> Y = list ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> if x ** 2 + y ** 2 <= D ** 2 : <NEWLINE> <INDENT> s = s + 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> gcd = math . gcd ( A , B ) <NEWLINE> ans = [ 1 ] <NEWLINE> while gcd % 2 == 0 : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> gcd = gcd // 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= gcd : <NEWLINE> <INDENT> if gcd % f == 0 : <NEWLINE> <INDENT> ans . append ( f ) <NEWLINE> gcd = gcd // f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if gcd != 1 : <NEWLINE> <INDENT> ans . append ( gcd ) <NEWLINE> <DEDENT> print ( len ( set ( ans ) ) ) <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> from math import ceil <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> log_count , cut_count = ( int ( i ) for i in sys . stdin . readline ( ) . split ( ) ) <NEWLINE> logs = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> high = max ( logs ) <NEWLINE> low = 1 <NEWLINE> soln = high <NEWLINE> <COMMENT> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> cuts_needed = sum ( [ int ( ceil ( log / mid ) ) - 1 for log in logs ] ) <NEWLINE> if cuts_needed <= cut_count : <NEWLINE> <INDENT> soln = min ( soln , mid ) <NEWLINE> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> print ( soln ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> lis = make_divisors ( x ) <NEWLINE> flg = False <NEWLINE> <NL> for i in range ( 0 , len ( lis ) ) : <NEWLINE> <NL> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( j + lis [ i ] ) ** 5 - j ** 5 == x : <NEWLINE> <INDENT> ans = str ( j + lis [ i ] ) + <STRING> + str ( j ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> for i in range ( 0 , len ( lis ) ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( j + lis [ i ] ) ** 5 - j ** 5 == x : <NEWLINE> <INDENT> ans = str ( j + lis [ i ] ) + <STRING> + str ( j ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> in_list = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> in_list . append ( input ( ) ) <NEWLINE> <DEDENT> N , S = in_list <NEWLINE> N = int ( N ) <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> j = i + n <NEWLINE> k = j + n <NEWLINE> if k > N - 1 : break <NEWLINE> res += ( S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] ) <NEWLINE> n += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> rgb = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> print ( rgb - res ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ - 1 ] <NEWLINE> H . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> lose = set ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A ] < H [ B ] : <NEWLINE> <INDENT> lose . add ( A ) <NEWLINE> <DEDENT> elif H [ A ] > H [ B ] : <NEWLINE> <INDENT> lose . add ( B ) <NEWLINE> <DEDENT> elif H [ A ] == H [ B ] : <NEWLINE> <INDENT> lose . add ( A ) <NEWLINE> lose . add ( B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( lose ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( m , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> m = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if not m : break <NEWLINE> a = list ( range ( 1 , m + 1 ) ) <NEWLINE> b = [ input ( ) for _ in range ( n ) ] <NEWLINE> t = [ str ( i + 1 ) for i in range ( n ) ] <NEWLINE> t [ 2 : : 3 ] = [ <STRING> ] * len ( t [ 2 : : 3 ] ) <NEWLINE> t [ 4 : : 5 ] = [ <STRING> ] * len ( t [ 4 : : 5 ] ) <NEWLINE> t [ 14 : : 15 ] = [ <STRING> ] * len ( t [ 14 : : 15 ] ) <NEWLINE> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if len ( a ) < 2 : break <NEWLINE> if b [ j ] != t [ j ] : del a [ i ] ; i = i % len ( a ) ; continue <NEWLINE> i += 1 <NEWLINE> i = i % len ( a ) <NEWLINE> <DEDENT> print ( <STRING> . join ( str ( e ) for e in a ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = 10 ** 18 <NEWLINE> r = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> r *= i <NEWLINE> if t < r : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = N <NEWLINE> cnt = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i - 1 ] : <NEWLINE> <INDENT> t = A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> A [ i - 1 ] = t <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> n -= 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( str ( A [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( A [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> B = 0 <NEWLINE> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if X == i ** 5 - j ** 5 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> lsa = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> lsb = collections . deque ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> lsb . append ( lsa [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lsb . appendleft ( lsa [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> lsb . append ( lsa [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lsb . appendleft ( lsa [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( lsb ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> N = int ( next ( in_ ) ) <NEWLINE> A = tuple ( map ( int , next ( in_ ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> v = sum ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> v -= a <NEWLINE> ans += a * v <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
* o , = open ( 0 ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> ( n , m , x ) , * ca = map ( lambda x : np . array ( list ( map ( int , x . split ( ) ) ) ) , o ) <NEWLINE> <NL> INF = 1 << 31 <NEWLINE> <NL> ans = INF <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> tmp = np . zeros ( m + 1 , int ) <NEWLINE> sel = [ ] <NEWLINE> for j , dig in enumerate ( bin ( i ) [ 2 : ] [ : : - 1 ] ) : <NEWLINE> <INDENT> if int ( dig ) : <NEWLINE> <INDENT> tmp += ca [ j ] <NEWLINE> sel . append ( j ) <NEWLINE> <DEDENT> <DEDENT> if min ( tmp [ 1 : ] ) >= x : <NEWLINE> <INDENT> ans = min ( ans , tmp [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> for i , s in enumerate ( sys . stdin ) : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i != 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lst = input ( ) . split ( ) <NEWLINE> name = lst [ 0 ] <NEWLINE> w = int ( lst [ 1 ] ) <NEWLINE> l = int ( lst [ 2 ] ) <NEWLINE> d = int ( lst [ 3 ] ) <NEWLINE> score = 3 * w + d <NEWLINE> A . append ( ( score , - i , name ) ) <NEWLINE> <DEDENT> A . sort ( reverse = True ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> score = a [ 0 ] <NEWLINE> name = a [ 2 ] <NEWLINE> print ( <STRING> . format ( name , score ) ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> print ( <STRING> ) if a [ i ] < a [ k + i ] else print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> error = str ( ans ) <NEWLINE> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import namedtuple <NEWLINE> <NL> class TreeWalk : <NEWLINE> <INDENT> def __init__ ( self , t ) : <NEWLINE> <INDENT> self . t = t <NEWLINE> <NL> <DEDENT> def preParse ( self , u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> , str ( u ) , end = <STRING> ) <NEWLINE> self . preParse ( self . t [ u ] . l ) <NEWLINE> self . preParse ( self . t [ u ] . r ) <NEWLINE> <NL> <DEDENT> def inParse ( self , u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . inParse ( self . t [ u ] . l ) <NEWLINE> print ( <STRING> , str ( u ) , end = <STRING> ) <NEWLINE> self . inParse ( self . t [ u ] . r ) <NEWLINE> <NL> <DEDENT> def postParse ( self , u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . postParse ( self . t [ u ] . l ) <NEWLINE> self . postParse ( self . t [ u ] . r ) <NEWLINE> print ( <STRING> , str ( u ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> Node = namedtuple ( <STRING> , [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> t = [ Node ( - 1 , - 1 , - 1 ) ] * n <NEWLINE> root = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v , l , r = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> t [ v ] = t [ v ] . _replace ( l = l , r = r ) <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> t [ l ] = t [ l ] . _replace ( p = v ) <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> t [ r ] = t [ r ] . _replace ( p = v ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( t [ i ] . p == - 1 ) : <NEWLINE> <INDENT> root = i <NEWLINE> <NL> <DEDENT> <DEDENT> x = TreeWalk ( t ) <NEWLINE> print ( <STRING> ) <NEWLINE> x . preParse ( root ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> x . inParse ( root ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> x . postParse ( root ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> manhattan = ( <NEWLINE> <INDENT> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) , <NEWLINE> ( 6 , 5 , 4 , 3 , 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 ) ) <NEWLINE> <DEDENT> movables = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 , 8 ) , ( 1 , 4 , 6 , 9 ) , ( 2 , 5 , 7 , 10 ) , ( 3 , 6 , 11 ) , <NEWLINE> <INDENT> ( 4 , 9 , 12 ) , ( 5 , 8 , 10 , 13 ) , ( 6 , 9 , 11 , 14 ) , ( 7 , 10 , 15 ) , ( 8 , 13 ) , ( 9 , 12 , 14 ) , ( 10 , 13 , 15 ) , ( 11 , 14 ) ) <NEWLINE> <DEDENT> swap_mul = [ [ ( 1 << mf ) - ( 1 << mt ) for mt in range ( 0 , 64 , 4 ) ] for mf in range ( 0 , 64 , 4 ) ] <NEWLINE> destination = 0xfedcba9876543210 <NEWLINE> i = 0 <NEWLINE> board_init = 0 <NEWLINE> blank_init = 0 <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> for n in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 15 <NEWLINE> blank_init = i <NEWLINE> <DEDENT> board_init += n * 16 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> estimation_init = sum ( manhattan [ i ] [ ( ( board_init >> ( 4 * i ) ) & 15 ) ] for i in range ( 16 ) if i != blank_init ) <NEWLINE> queue = [ ( estimation_init , board_init , blank_init ) ] <NEWLINE> visited = set ( ) <NEWLINE> while True : <NEWLINE> <INDENT> estimation , board , blank = heappop ( queue ) <NEWLINE> if board in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif board == destination : <NEWLINE> <INDENT> print ( estimation ) <NEWLINE> break <NEWLINE> <DEDENT> visited . add ( board ) <NEWLINE> for new_blank in movables [ blank ] : <NEWLINE> <INDENT> num = ( board >> ( 4 * new_blank ) ) & 15 <NEWLINE> new_board = board + swap_mul [ new_blank ] [ blank ] * ( 15 - num ) <NEWLINE> if new_board in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> new_estimation = estimation + 1 - manhattan [ new_blank ] [ num ] + manhattan [ blank ] [ num ] <NEWLINE> if new_estimation > 45 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> heappush ( queue , ( new_estimation , new_board , new_blank ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> town = 1 <NEWLINE> town_list = [ 1 ] <NEWLINE> towntown = [ 0 ] * ( N + 1 ) <NEWLINE> towntown [ 1 ] = 1 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> count += 1 <NEWLINE> if count == K : <NEWLINE> <INDENT> print ( town ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if towntown [ town ] == 0 : <NEWLINE> <INDENT> town_list . append ( town ) <NEWLINE> towntown [ town ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop_town_num = town <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> l_ini_index = town_list . index ( roop_town_num ) <NEWLINE> len_roop = len ( town_list ) - l_ini_index <NEWLINE> <NL> if K <= l_ini_index : <NEWLINE> <INDENT> print ( town_list [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( town_list [ ( ( K - l_ini_index ) % len_roop + l_ini_index ) ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 10 ** 9 * N <NEWLINE> front = 0 <NEWLINE> back = sum ( a ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> front += a [ i ] <NEWLINE> back -= a [ i ] <NEWLINE> ans = min ( ans , abs ( front - back ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def lcm ( l ) : <NEWLINE> <INDENT> r = l . pop ( 0 ) <NEWLINE> for i in l : <NEWLINE> <INDENT> r = r * i // math . gcd ( r , i ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( lcm ( T ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( A * x ) // B - A * int ( x // B ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> ans = 0 <NEWLINE> c = 1 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ( ( ( m * pow ( m - 1 , n - i - 1 , MOD ) ) % MOD ) * c ) % MOD <NEWLINE> ans %= MOD <NEWLINE> c = ( c * ( n - 1 - i ) * pow ( i + 1 , MOD - 2 , MOD ) ) % MOD <NEWLINE> <NL> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> factorial = 1 <NEWLINE> divisor = [ ] <NEWLINE> ans = 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> def get_prime ( num ) : <NEWLINE> <INDENT> if num <= 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for i in range ( 2 , num + 1 ) : <NEWLINE> <INDENT> while num % i == 0 : <NEWLINE> <INDENT> divisor . append ( i ) <NEWLINE> num //= i <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> get_prime ( j ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> count = collections . Counter ( divisor ) <NEWLINE> <NL> for k in count . most_common ( ) : <NEWLINE> <INDENT> temp = list ( k ) [ 1 ] <NEWLINE> ans = ans * ( temp + 1 ) <NEWLINE> <NL> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ans > 10 ** 18 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> if n > b - 1 : <NEWLINE> <INDENT> n = b - 1 <NEWLINE> <NL> <DEDENT> ans = math . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 1 <NEWLINE> li . sort ( ) <NEWLINE> for a in li : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> break <NEWLINE> <DEDENT> total *= a <NEWLINE> if 10 ** 18 < total : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> rev = 0 <NEWLINE> sh = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q = input ( ) . split ( ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> rev = ( rev + 1 ) % 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> head = int ( q [ 1 ] ) % 2 <NEWLINE> if head ^ rev : <NEWLINE> <INDENT> sh += q [ 2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> s += q [ 2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = sh [ : : - 1 ] + s <NEWLINE> print ( ans [ : : - 1 ] ) if rev else print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> sum_j = [ 0 ] * n <NEWLINE> sum_tmp = 0 <NEWLINE> <NL> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> sum_tmp += a [ i ] <NEWLINE> sum_j [ i ] = sum_tmp <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * sum_j [ i + 1 ] % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> <NL> sumA = sum ( alist ) <NEWLINE> adict = Counter ( alist ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b not in adict : <NEWLINE> <INDENT> print ( sumA ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> bnum = adict . pop ( b ) <NEWLINE> if c in adict : <NEWLINE> <INDENT> adict [ c ] += bnum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adict [ c ] = bnum <NEWLINE> <NL> <DEDENT> sumA -= bnum * ( b - c ) <NEWLINE> print ( sumA ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> positions = { 0 : [ 0 , 0 ] , 1 : [ 1 , 1 ] } <NEWLINE> direction = 135 * math . pi / 180 <NEWLINE> x , y = 1 , 1 <NEWLINE> for step in range ( 2 , 1001 ) : <NEWLINE> <INDENT> x += math . cos ( direction ) <NEWLINE> y += math . sin ( direction ) <NEWLINE> positions [ step ] = [ x , y ] <NEWLINE> direction = math . atan2 ( x , - y ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % positions [ n - 1 ] [ 0 ] ) <NEWLINE> print ( <STRING> % positions [ n - 1 ] [ 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 0 ] * N <COMMENT> <NEWLINE> ima_pos = 0 <COMMENT> <NEWLINE> mirai_pos = 0 <COMMENT> <NEWLINE> <NL> count_first = 0 <COMMENT> <NEWLINE> first_DP = [ ] <NEWLINE> while ( visited [ ima_pos ] == 0 ) : <NEWLINE> <INDENT> visited [ ima_pos ] = 1 <COMMENT> <NEWLINE> mirai_pos = A [ ima_pos ] - 1 <NEWLINE> ima_pos = mirai_pos <NEWLINE> first_DP . append ( ima_pos ) <COMMENT> <NEWLINE> count_first += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> second_start = ima_pos <COMMENT> <NEWLINE> count_second = 0 <COMMENT> <NEWLINE> second_DP = [ ] <NEWLINE> <NL> while ( True ) : <COMMENT> <NEWLINE> <INDENT> visited [ ima_pos ] = 2 <COMMENT> <NEWLINE> mirai_pos = A [ ima_pos ] - 1 <NEWLINE> ima_pos = mirai_pos <NEWLINE> second_DP . append ( ima_pos ) <NEWLINE> count_second += 1 <COMMENT> <NEWLINE> if ima_pos == second_start : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if K <= count_first : <NEWLINE> <INDENT> print ( first_DP [ K - 1 ] + 1 ) <NEWLINE> <DEDENT> elif K > count_first : <NEWLINE> <INDENT> cc = K - count_first <COMMENT> <NEWLINE> if cc % count_second == 0 : <NEWLINE> <INDENT> print ( second_DP [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( second_DP [ cc % count_second - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> class Prime ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . M = m = int ( math . sqrt ( n ) ) + 10 <NEWLINE> self . A = a = [ True ] * m <NEWLINE> a [ 0 ] = a [ 1 ] = False <NEWLINE> self . T = t = [ ] <NEWLINE> for i in range ( 2 , m ) : <NEWLINE> <INDENT> if not a [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t . append ( i ) <NEWLINE> for j in range ( i * i , m , i ) : <NEWLINE> <INDENT> a [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def is_prime ( self , n ) : <NEWLINE> <INDENT> return self . A [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> pr = Prime ( 100000 ** 2 ) <NEWLINE> tl = len ( pr . T ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , a , b = LI ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = fractions . Fraction ( a , b ) <NEWLINE> sn = n ** 0.5 <NEWLINE> r = 0 <NEWLINE> rs = <STRING> <NEWLINE> for ni in range ( tl ) : <NEWLINE> <INDENT> i = pr . T [ ni ] <NEWLINE> if i > sn : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = min ( n // i , int ( i / m ) + 1 ) <NEWLINE> if j < i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while not pr . is_prime ( j ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ji = pr . T . index ( j ) <NEWLINE> while fractions . Fraction ( i , pr . T [ ji ] ) < m : <NEWLINE> <INDENT> ji -= 1 <NEWLINE> <DEDENT> j = pr . T [ ji ] <NEWLINE> if i * j <= r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> r = i * j <NEWLINE> rs = <STRING> . format ( i , j ) <NEWLINE> <NL> <DEDENT> rr . append ( rs ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> c = a % b <NEWLINE> return gcd ( b , c ) <NEWLINE> <NL> <DEDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( l , k + 1 ) : <NEWLINE> <INDENT> for n in range ( m , k + 1 ) : <NEWLINE> <INDENT> tmp1 = gcd ( l , n ) <NEWLINE> tmp2 = gcd ( tmp1 , m ) <NEWLINE> if ( l == m == n ) : <NEWLINE> <INDENT> ans += tmp2 <NEWLINE> <DEDENT> elif ( l == m or m == n ) : <NEWLINE> <INDENT> ans += 3 * tmp2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * tmp2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <DEDENT> elif A < K and K < B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <COMMENT> <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
yes = <STRING> <NEWLINE> no = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if max ( a ) - min ( a ) > 1 : exit ( print ( no ) ) <NEWLINE> if a == [ a [ 0 ] ] * n : <NEWLINE> <INDENT> if a [ 0 ] == n - 1 : print ( yes ) <NEWLINE> elif 2 * a [ 0 ] <= n : print ( yes ) <NEWLINE> else : print ( no ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mi = a . count ( min ( a ) ) <NEWLINE> ma = n - mi <NEWLINE> if mi < max ( a ) and 2 * ( max ( a ) - mi ) <= ma : print ( yes ) <NEWLINE> else : print ( no ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import random <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> D = int ( readline ( ) ) <NEWLINE> C = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> score = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> max_ind = s . index ( max ( s ) ) + 1 <NEWLINE> t . append ( max_ind ) <NEWLINE> score . append ( s ) <NEWLINE> <NL> <DEDENT> M = 100 <NEWLINE> <NL> d = [ random . randint ( 1 , D ) for i in range ( M ) ] <NEWLINE> q = [ random . randint ( 1 , 26 ) for i in range ( M ) ] <NEWLINE> max_S = - float ( <STRING> ) <NEWLINE> for i in range ( 0 , M , 2 ) : <NEWLINE> <INDENT> t [ d [ i ] - 1 ] = q [ i ] <NEWLINE> t [ d [ i + 1 ] - 1 ] = q [ i + 1 ] <NEWLINE> S = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for day in range ( D ) : <NEWLINE> <INDENT> select = t [ day ] - 1 <NEWLINE> S += score [ day ] [ select ] <NEWLINE> last [ select ] = day + 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> S -= C [ i ] * ( day + 1 - last [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if S > max_S : <NEWLINE> <INDENT> ans = t <NEWLINE> max_S = S <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( str ( n ) for n in ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , parent = - 1 , left = - 1 , right = - 1 ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . parent , self . left , self . right ) <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return self . __str__ ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preorder_traverse ( node_list , current ) : <NEWLINE> <INDENT> print ( <STRING> % current , end = <STRING> ) <NEWLINE> node = node_list [ current ] <NEWLINE> if node . left != - 1 : <NEWLINE> <INDENT> preorder_traverse ( node_list , node . left ) <NEWLINE> <DEDENT> if node . right != - 1 : <NEWLINE> <INDENT> preorder_traverse ( node_list , node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def inorder_traverse ( node_list , current ) : <NEWLINE> <INDENT> node = node_list [ current ] <NEWLINE> if node . left != - 1 : <NEWLINE> <INDENT> inorder_traverse ( node_list , node . left ) <NEWLINE> <DEDENT> print ( <STRING> % current , end = <STRING> ) <NEWLINE> if node . right != - 1 : <NEWLINE> <INDENT> inorder_traverse ( node_list , node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def postorder_traverse ( node_list , current ) : <NEWLINE> <INDENT> node = node_list [ current ] <NEWLINE> if node . left != - 1 : <NEWLINE> <INDENT> postorder_traverse ( node_list , node . left ) <NEWLINE> <DEDENT> if node . right != - 1 : <NEWLINE> <INDENT> postorder_traverse ( node_list , node . right ) <NEWLINE> <DEDENT> print ( <STRING> % current , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> num_of_nodes = int ( lines [ 0 ] ) <NEWLINE> node_list = [ Node ( ) for _ in range ( num_of_nodes ) ] <NEWLINE> <NL> <COMMENT> <NL> for line in lines [ 1 : ] : <NEWLINE> <INDENT> node_id , left , right = [ int ( x ) for x in line . strip ( ) . split ( <STRING> ) ] <NEWLINE> node_list [ node_id ] . left = left <NEWLINE> node_list [ node_id ] . right = right <NEWLINE> <NL> if left != - 1 : <NEWLINE> <INDENT> node_list [ left ] . parent = node_id <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> node_list [ right ] . parent = node_id <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for node_id , node in enumerate ( node_list ) : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> root = node_id <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> preorder_traverse ( node_list , root ) <NEWLINE> print ( <STRING> ) <NEWLINE> inorder_traverse ( node_list , root ) <NEWLINE> print ( <STRING> ) <NEWLINE> postorder_traverse ( node_list , root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> l = [ 0 ] * ( 1000005 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ a [ i ] ] == 1 : <NEWLINE> <INDENT> l [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> if l [ a [ i ] ] == 0 : <NEWLINE> <INDENT> for j in range ( 1000000 // a [ i ] + 1 ) : <NEWLINE> <INDENT> l [ a [ i ] * j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ a [ i ] ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = set ( [ v for v , i in enumerate ( S ) if i == <STRING> ] ) <NEWLINE> G = set ( [ v for v , i in enumerate ( S ) if i == <STRING> ] ) <NEWLINE> B = set ( [ v for v , i in enumerate ( S ) if i == <STRING> ] ) <NEWLINE> t = len ( B ) <NEWLINE> c = 0 <NEWLINE> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> d = [ 2 * i - j , 2 * j - i , ( i + j ) / 2 ] <NEWLINE> for a , s in enumerate ( d ) : <NEWLINE> <INDENT> if s in B : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> <DEDENT> c += t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> if a >= b : <NEWLINE> <INDENT> p = int ( math . log ( a / b , 2 ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> <NL> <DEDENT> if b * ( 2 ** p ) >= c : <NEWLINE> <INDENT> q = int ( math . log ( b * ( 2 ** p ) / c , 2 ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if ( p + q ) <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> x = [ a , b , c ] <NEWLINE> ans = x [ 0 ] <NEWLINE> for i in range ( 1 , 3 ) : <NEWLINE> <INDENT> ans = math . gcd ( ans , x [ i ] ) <NEWLINE> <DEDENT> if a == b and b == c : <NEWLINE> <INDENT> S = S + ans <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> S = S + 3 * ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S + 6 * ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alphas = map ( int , input ( ) . split ( ) ) <NEWLINE> alphas = list ( alphas ) <NEWLINE> <NL> res = [ ] <NEWLINE> <NL> r = None <NEWLINE> <NL> for i in range ( len ( alphas ) ) : <NEWLINE> <INDENT> if r is None : <NEWLINE> <INDENT> r = alphas [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r ^= alphas [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( alphas ) ) : <NEWLINE> <INDENT> res . append ( r ^ alphas [ i ] ) <NEWLINE> <DEDENT> print ( * res ) <NEWLINE>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = False <NEWLINE> S = deque ( s ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> d = list ( input ( ) . split ( ) ) <NEWLINE> if len ( d ) == 1 : <NEWLINE> <INDENT> r = ~ r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( d [ 1 ] == <STRING> and ~ r ) or ( d [ 1 ] == <STRING> and r ) : <NEWLINE> <INDENT> S . appendleft ( d [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( d [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = <STRING> . join ( S ) <NEWLINE> if r : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n , m = [ int ( x ) for x in input ( ) . split ( ) ] <COMMENT> <NEWLINE> g = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> g [ a - 1 ] . append ( b ) <NEWLINE> g [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> def bfs ( u ) : <NEWLINE> <INDENT> queue = deque ( [ u ] ) <NEWLINE> d = [ None ] * n <COMMENT> <NEWLINE> d [ u - 1 ] = 0 <COMMENT> <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v - 1 ] : <NEWLINE> <INDENT> if d [ i - 1 ] is None : <NEWLINE> <INDENT> d [ i - 1 ] = d [ v - 1 ] + 1 <NEWLINE> queue . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> d = bfs ( 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in g [ i ] : <NEWLINE> <INDENT> if d [ i ] - 1 == d [ j - 1 ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> squares = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> odd = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if squares [ i ] % 2 : <NEWLINE> <INDENT> odd += 1 <NEWLINE> <DEDENT> <DEDENT> print ( odd ) <NEWLINE>
<COMMENT> <NL> <NL> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> t = min ( A , K ) <NEWLINE> result += t <NEWLINE> K -= t <NEWLINE> t = min ( B , K ) <NEWLINE> K -= t <NEWLINE> t = min ( C , K ) <NEWLINE> result -= t <NEWLINE> print ( result ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if Asum [ - 1 ] + i > K : break <NEWLINE> Asum . append ( Asum [ - 1 ] + i ) <NEWLINE> <DEDENT> import numpy as np <NEWLINE> Asum = np . array ( Asum ) <NEWLINE> Bsum = [ 0 ] <NEWLINE> for i in B : <NEWLINE> <INDENT> if Bsum [ - 1 ] + i > K : break <NEWLINE> Bsum . append ( Bsum [ - 1 ] + i ) <NEWLINE> <DEDENT> Bsum = np . array ( Bsum ) <NEWLINE> <NL> maxval = len ( Asum ) - 1 <NEWLINE> <NL> tmp = 0 <NEWLINE> lenB = len ( Bsum ) <NEWLINE> lenA = len ( Asum ) <NEWLINE> for i in range ( lenA ) : <NEWLINE> <INDENT> if lenA - 1 - i + lenB < maxval : break <NEWLINE> for j in range ( lenB ) : <NEWLINE> <INDENT> j = tmp + j <NEWLINE> if Asum [ - i - 1 ] + Bsum [ j ] > K : <NEWLINE> <INDENT> maxval = max ( maxval , len ( Asum ) - 1 - i + j - 1 ) <NEWLINE> tmp = j <NEWLINE> break <NEWLINE> <DEDENT> elif j == lenB - 1 : <NEWLINE> <INDENT> maxval = max ( maxval , lenA - 1 - i + j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( maxval ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ms = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> m , l = LI ( ) <NEWLINE> a = [ LI ( ) for _ in range ( m ) ] <NEWLINE> b = 0 <NEWLINE> for s , e in a : <NEWLINE> <INDENT> for i in range ( s , e ) : <NEWLINE> <INDENT> b |= 2 ** ( i - 6 ) <NEWLINE> <DEDENT> <DEDENT> ms . append ( ( l , b ) ) <NEWLINE> <NL> <DEDENT> d = collections . defaultdict ( int ) <NEWLINE> d [ 0 ] = 0 <NEWLINE> for l , b in ms : <NEWLINE> <INDENT> for k , v in list ( d . items ( ) ) : <NEWLINE> <INDENT> if b & k > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ b | k ] < v + l : <NEWLINE> <INDENT> d [ b | k ] = v + l <NEWLINE> <DEDENT> <DEDENT> <DEDENT> rr . append ( max ( d . values ( ) ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s1 = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> c = 1 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> l = list ( a . split ( ) ) <NEWLINE> c2 = 3 - 2 * int ( l [ 1 ] ) <NEWLINE> if c * c2 == 1 : <NEWLINE> <INDENT> s1 = s1 + l [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = s2 + l [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = - c <NEWLINE> <DEDENT> <DEDENT> s = s1 [ : : - 1 ] + s + s2 <NEWLINE> if c == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : : - 1 ] ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = 2019 <NEWLINE> flag = False <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> m = min ( m , i * j % 2019 ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : break <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from scipy . special import comb <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N , K = zz ( ) <NEWLINE> A = zz ( ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( A [ i ] > A [ i - K ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for l in range ( j , k + 1 ) : <NEWLINE> <INDENT> temp = reduce ( math . gcd , [ i , j , l ] ) <NEWLINE> if len ( set ( [ i , j , l ] ) ) == 1 : <NEWLINE> <INDENT> ans += temp <NEWLINE> <DEDENT> elif len ( set ( [ i , j , l ] ) ) == 2 : <NEWLINE> <INDENT> ans += temp * 3 <NEWLINE> <DEDENT> elif len ( set ( [ i , j , l ] ) ) == 3 : <NEWLINE> <INDENT> ans += temp * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> L . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <COMMENT> <NEWLINE> <INDENT> ab = L [ i ] + L [ j ] <NEWLINE> idx = bisect . bisect_left ( L , ab , lo = j ) <NEWLINE> ans += max ( idx - ( j + 1 ) , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( c ) for c in str ( n ) ] <NEWLINE> nums . reverse ( ) <NEWLINE> a = [ 0 ] * 2019 <NEWLINE> a [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> pow10 = [ 1 ] * len ( nums ) <NEWLINE> for i , num in enumerate ( nums ) : <NEWLINE> <INDENT> if i < len ( nums ) - 1 : <NEWLINE> <INDENT> pow10 [ i + 1 ] = pow10 [ i ] * 10 % 2019 <NEWLINE> <DEDENT> <DEDENT> for i , num in enumerate ( nums ) : <NEWLINE> <INDENT> now = ( now + num * pow10 [ i ] ) % 2019 <NEWLINE> a [ now ] += 1 <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> sum += a [ i ] * ( a [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> def Strider ( ) : <NEWLINE> <NL> <INDENT> NumA = int ( input ( ) ) <NEWLINE> <NL> count = 360 / NumA <NEWLINE> <NL> NumB = 1 <NEWLINE> <NL> while ( ( 360 * NumB % NumA ) != 0 ) : <NEWLINE> <INDENT> NumB = NumB + 1 <NEWLINE> count = 360 * NumB / NumA <NEWLINE> <NL> <DEDENT> print ( int ( count ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Strider ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def maximum_profit ( price_list ) : <NEWLINE> <INDENT> max = price_list [ 1 ] - price_list [ 0 ] <NEWLINE> min = price_list [ 0 ] <NEWLINE> for i in range ( 1 , len ( price_list ) ) : <NEWLINE> <INDENT> if max < price_list [ i ] - min : <NEWLINE> <INDENT> max = price_list [ i ] - min <NEWLINE> <DEDENT> if min > price_list [ i ] : <NEWLINE> <INDENT> min = price_list [ i ] <NEWLINE> <DEDENT> <DEDENT> return max <NEWLINE> <NL> <DEDENT> input_num = int ( input ( ) ) <NEWLINE> price_list = list ( ) <NEWLINE> for i in range ( input_num ) : <NEWLINE> <INDENT> input_price = int ( input ( ) ) <NEWLINE> price_list . append ( input_price ) <NEWLINE> <DEDENT> print ( maximum_profit ( price_list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> c_dic = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in c_dic : <NEWLINE> <INDENT> c_dic [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dic [ i ] += 1 <NEWLINE> <NL> <DEDENT> if i + 1 not in c_dic : <NEWLINE> <INDENT> c_dic [ i + 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dic [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> if i - 1 not in c_dic : <NEWLINE> <INDENT> c_dic [ i - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dic [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( c_dic . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> ans = 0 <NEWLINE> if a >= n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> a += i <NEWLINE> if a >= n : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , ans + 1 ) : <NEWLINE> <INDENT> if a - n != k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while ( n > i ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a . append ( b ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> score = - 1000000000 <NEWLINE> mini = a [ 0 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> if ( i - mini > score ) : <NEWLINE> <INDENT> score = i - mini <NEWLINE> <DEDENT> if ( mini > i ) : <NEWLINE> <INDENT> mini = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if a % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 10 * ( a % K ) + 7 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
P = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> s = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> s [ 1 ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> s [ i + 1 ] += ( s [ max ( 0 , i - l + 1 ) ] - s [ max ( 0 , i - r ) ] ) % P <NEWLINE> s [ i + 1 ] %= P <NEWLINE> <DEDENT> <DEDENT> print ( ( s [ N ] - s [ N - 1 ] ) % P ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> len_s = len ( s ) <NEWLINE> len_t = len ( t ) <NEWLINE> <NL> ans = 1000 <NEWLINE> max_cnt = 0 <NEWLINE> for i in range ( len_s - len_t + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> l = [ ] <NEWLINE> for j in range ( len_t ) : <NEWLINE> <INDENT> if s [ i : i + len_t ] [ j ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if s [ i : i + len_t ] [ j ] != t [ j ] : <NEWLINE> <INDENT> cnt += 0 <NEWLINE> <DEDENT> <DEDENT> max_cnt = max ( max_cnt , cnt ) <NEWLINE> <NL> <DEDENT> ans = min ( ans , len_t - max_cnt ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> d = abs ( A - B ) <NEWLINE> v = V - W <NEWLINE> if d / v <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import numpy as np <NEWLINE> <NL> K = INT ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for n in range ( K ) : <NEWLINE> <INDENT> for m in range ( K ) : <NEWLINE> <INDENT> sum1 = gcd ( n + 1 , m + 1 ) <NEWLINE> for l in range ( K ) : <NEWLINE> <INDENT> sum += gcd ( l + 1 , sum1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort = sorted ( a ) <NEWLINE> ans = sort [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ans <= 1000000000000000000 : <NEWLINE> <INDENT> ans = ans * sort [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= 1000000000000000000 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> y = min ( b - 1 , n ) <NEWLINE> <NL> print ( ( a * y ) // b ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> a = [ ] <NEWLINE> def f ( a , bin , n ) : <NEWLINE> <INDENT> if bin > n : return <NEWLINE> if bin : a += [ bin ] <NEWLINE> f ( a , bin * 10 + 2 , n ) <NEWLINE> f ( a , bin * 10 + 8 , n ) <NEWLINE> <NL> <DEDENT> def g ( n , p ) : <NEWLINE> <INDENT> m = - 1 << 20 <NEWLINE> x = bisect . bisect_left ( a , n ) <NEWLINE> if x != len ( a ) and a [ x ] == n : m = 1 <NEWLINE> if a [ p ] ** 2 > n : return m <NEWLINE> if n % a [ p ] == 0 : m = g ( n // a [ p ] , p ) + 1 <NEWLINE> return max ( m , g ( n , p + 1 ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n & 1 : print ( - 1 ) ; exit ( ) <NEWLINE> f ( a , 0 , n ) <NEWLINE> a = sorted ( a ) + [ 10 ** 20 ] <NEWLINE> b = g ( n , 0 ) <NEWLINE> if b < 0 : b = - 1 <NEWLINE> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) + [ 1000001 ] <NEWLINE> A . sort ( ) <NEWLINE> m , ans = max ( A ) + 1 , 0 <NEWLINE> li = [ 0 for _ in range ( m ) ] <NEWLINE> li [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if not li [ a ] : <NEWLINE> <INDENT> if A [ i + 1 ] != a : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( a , m , a ) : <NEWLINE> <INDENT> li [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sort = sorted ( set ( A ) ) <NEWLINE> <NL> bool_list = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> duplicate_dic = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> duplicate_dic [ a ] += 1 <NEWLINE> if duplicate_dic [ a ] > 1 : <NEWLINE> <INDENT> bool_list [ a ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A_sort : <NEWLINE> <INDENT> for i in range ( 2 * a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> bool_list [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ 1 for a in A_sort if bool_list [ a ] ] ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def search ( a ) : <NEWLINE> <INDENT> B = np . zeros_like ( a ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - a [ i ] ) <NEWLINE> r = min ( N - 1 , i + a [ i ] ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> A = search ( A ) <NEWLINE> if min ( A ) == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> A = map ( str , A ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
import copy <NEWLINE> s = input ( ) <NEWLINE> check = <STRING> <NEWLINE> tmp = 6 <NEWLINE> sNow = 0 <NEWLINE> cNow = 0 <NEWLINE> <COMMENT> <NL> for i in s : <NEWLINE> <INDENT> sNow += 1 <NEWLINE> if i == check [ cNow ] : <NEWLINE> <INDENT> cNow += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if cNow == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> if check [ cNow : ] == s [ - 1 * ( 7 - cNow ) : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ x - 1 ] . append ( y - 1 ) <NEWLINE> a [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> c = [ 0 ] * n <NEWLINE> que = deque ( [ ] ) <NEWLINE> que . append ( 0 ) <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> e = que . popleft ( ) <NEWLINE> for i in a [ e ] : <NEWLINE> <INDENT> if c [ i ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c [ i ] = e + 1 <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_lst . reverse ( ) <NEWLINE> tmp = a_lst [ 0 ] <NEWLINE> lst = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> lst . append ( tmp ) <NEWLINE> tmp += a_lst [ i ] <NEWLINE> tmp %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> lst . reverse ( ) <NEWLINE> a_lst . reverse ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( a_lst [ i ] * lst [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> k = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> k = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for num in input ( ) . split ( ) : <NEWLINE> <INDENT> ans = ( ans * int ( num ) ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for num in input ( ) . split ( ) : <NEWLINE> <INDENT> num = int ( num ) <NEWLINE> if num >= 0 : <NEWLINE> <INDENT> plus . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> pn = len ( plus ) <NEWLINE> mn = len ( minus ) <NEWLINE> <NL> if pn == 0 and k % 2 == 1 : <NEWLINE> <INDENT> minus . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( - ans * minus [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( ( - ans ) % mod ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> <NL> pi = 0 <NEWLINE> mi = 0 <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> if pi + 1 == pn : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> mi += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pi += 1 <NEWLINE> mi += k - 1 <NEWLINE> <NL> <DEDENT> break <NEWLINE> <NL> <DEDENT> if pi == pn : <NEWLINE> <INDENT> mi += k <NEWLINE> break <NEWLINE> <NL> <DEDENT> if mi + 1 >= mn : <NEWLINE> <INDENT> pi += k <NEWLINE> break <NEWLINE> <NL> <DEDENT> if k == 1 or plus [ pi ] * plus [ pi + 1 ] >= minus [ mi ] * minus [ mi + 1 ] : <NEWLINE> <INDENT> pi += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mi += 2 <NEWLINE> k -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( pi ) : <NEWLINE> <INDENT> ans = ( ans * plus [ i ] ) % mod <NEWLINE> <NL> <DEDENT> for i in range ( mi ) : <NEWLINE> <INDENT> ans = ( - ans * minus [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> Ak = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> Ak = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K - Ak > 0 : <NEWLINE> <INDENT> for j in range ( K - Ak ) : <NEWLINE> <INDENT> if B >= C : <NEWLINE> <INDENT> C = C * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if A < B and B < C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> count2 = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if count == 8 and i % 2 != 0 : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> <DEDENT> ans = count2 <NEWLINE> count = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> check = [ i for i in A if i == 0 ] <NEWLINE> if 0 in check : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> work = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> work *= a <NEWLINE> if work > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( work ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> x = min ( n , b - 1 ) <NEWLINE> print ( a * x // b ) <NEWLINE>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> x = [ p [ 0 ] for p in xy ] <NEWLINE> y = [ p [ 1 ] for p in xy ] <NEWLINE> x . sort ( ) <NEWLINE> y . sort ( ) <NEWLINE> <NL> s1 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> s2 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> s3 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> s4 = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for p in xy : <NEWLINE> <INDENT> if p [ 0 ] <= x [ i ] and p [ 1 ] <= y [ j ] : <NEWLINE> <INDENT> s1 [ i ] [ j ] += 1 <NEWLINE> s2 [ i ] [ j ] += ( p [ 0 ] < x [ i ] ) <NEWLINE> s3 [ i ] [ j ] += ( p [ 1 ] < y [ j ] ) <NEWLINE> s4 [ i ] [ j ] += ( p [ 0 ] < x [ i ] ) * ( p [ 1 ] < y [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> for t in range ( s + 1 , n ) : <NEWLINE> <INDENT> for u in range ( n ) : <NEWLINE> <INDENT> for v in range ( u + 1 , n ) : <NEWLINE> <INDENT> if s1 [ t ] [ v ] - s3 [ t ] [ u ] - s2 [ s ] [ v ] + s4 [ s ] [ u ] >= k : <NEWLINE> <INDENT> ans = min ( ans , ( x [ t ] - x [ s ] ) * ( y [ v ] - y [ u ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> multi = 1 <NEWLINE> <NL> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> multi = multi * A [ n ] <NEWLINE> if multi > 10 ** 18 : <NEWLINE> <INDENT> multi = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( multi ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import itertools <NEWLINE> <NL> <NL> def rev ( x ) : <NEWLINE> <INDENT> return sumA - x <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = sum ( A ) <NEWLINE> all_sum = set ( ) <NEWLINE> for i in range ( ( n + 1 ) // 2 ) : <NEWLINE> <INDENT> com = set ( itertools . combinations ( A , i + 1 ) ) <NEWLINE> com_sum = set ( map ( sum , com ) ) <NEWLINE> com_sum_rev = set ( map ( rev , com_sum ) ) <NEWLINE> all_sum = all_sum . union ( com_sum ) <NEWLINE> all_sum = all_sum . union ( com_sum_rev ) <NEWLINE> <DEDENT> for m in M : <NEWLINE> <INDENT> if m in all_sum : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> c = a + t * v <NEWLINE> d = b + t * w <NEWLINE> <NL> <NL> if ( a > b ) : <NEWLINE> <INDENT> c = a - t * v <NEWLINE> d = b - t * w <NEWLINE> if ( c <= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = a + t * v <NEWLINE> d = b + t * w <NEWLINE> if ( c >= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ ( 1 + p ) / 2 for p in P ] <NEWLINE> temp = sum ( Q [ : K ] ) <NEWLINE> ans = temp <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> temp = temp - Q [ i ] + Q [ i + K ] <NEWLINE> ans = max ( ans , temp ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> hlis = [ 0 for i in range ( h ) ] <NEWLINE> wlis = [ 0 for i in range ( w ) ] <NEWLINE> hw = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> hlis [ hi - 1 ] += 1 <NEWLINE> wlis [ wi - 1 ] += 1 <NEWLINE> hw . append ( [ hi - 1 , wi - 1 ] ) <NEWLINE> <NL> <DEDENT> hmax = max ( hlis ) <NEWLINE> wmax = max ( wlis ) <NEWLINE> <NL> ph = [ ] <NEWLINE> pw = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if hlis [ i ] == hmax : <NEWLINE> <INDENT> ph . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if wlis [ i ] == wmax : <NEWLINE> <INDENT> pw . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ph ) * len ( pw ) > 3 * ( 10 ** 5 ) : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> plis = [ ] <NEWLINE> for phi in ph : <NEWLINE> <INDENT> for pwj in pw : <NEWLINE> <INDENT> plis . append ( phi * ( 10 ** 6 ) + pwj ) <NEWLINE> <NL> <DEDENT> <DEDENT> plis . sort ( ) <NEWLINE> <NL> hwlis = [ ] <NEWLINE> for hi , wi in hw : <NEWLINE> <INDENT> hwlis . append ( hi * ( 10 ** 6 ) + wi ) <NEWLINE> <NL> <DEDENT> hwlis . sort ( ) <NEWLINE> <NL> c = 0 <NEWLINE> check = 0 <NEWLINE> <NL> for pi in plis : <NEWLINE> <INDENT> while pi != hwlis [ c ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c >= len ( hwlis ) : <NEWLINE> <INDENT> check = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if check == 1 : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hmax + wmax - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> from collections import deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> <NL> class BreadthFirstSearch : <NEWLINE> <INDENT> def __init__ ( self , num_nodes ) : <NEWLINE> <INDENT> self . n = num_nodes <NEWLINE> self . adj_list = [ [ ] for _ in range ( self . n ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def add_edge ( self , start , end , undirected = True ) : <NEWLINE> <INDENT> self . adj_list [ start ] . append ( end ) <NEWLINE> if undirected : <NEWLINE> <INDENT> self . adj_list [ end ] . append ( start ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def search ( self , start_node ) : <NEWLINE> <INDENT> order = [ - 1 ] * self . n <COMMENT> <NEWLINE> parent = [ - 1 ] * self . n <COMMENT> <NEWLINE> depth = [ - 1 ] * self . n <COMMENT> <NEWLINE> q = deque ( [ ( start_node , - 1 , 0 ) ] ) <COMMENT> <NEWLINE> num = 0 <COMMENT> <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> v , p , d = q . popleft ( ) <NEWLINE> if order [ v ] < 0 : <COMMENT> <NEWLINE> <INDENT> order [ v ] = num <NEWLINE> parent [ v ] = p <NEWLINE> depth [ v ] = d <NEWLINE> num += 1 <NEWLINE> for u in self . adj_list [ v ] : <NEWLINE> <INDENT> if order [ u ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( u , v , d + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return order , parent , depth <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Dijkstra : <NEWLINE> <INDENT> def __init__ ( self , num_nodes ) : <NEWLINE> <INDENT> self . n = num_nodes <NEWLINE> self . adj_list = [ [ ] for _ in range ( self . n ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def add_edge ( self , start , end , weight = 1 , undirected = False ) : <NEWLINE> <INDENT> self . adj_list [ start ] . append ( ( end , weight ) ) <NEWLINE> if undirected : <NEWLINE> <INDENT> self . adj_list [ end ] . append ( ( start , weight ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def distance ( self , start ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . dist = [ float ( <STRING> ) for _ in range ( self . n ) ] <NEWLINE> <COMMENT> <NL> self . prev = [ - 1 for _ in range ( self . n ) ] <NEWLINE> self . dist [ start ] = 0 <NEWLINE> <COMMENT> <NL> q = [ ] <NEWLINE> heappush ( q , ( 0 , start ) ) <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> prov_cost , src = heappop ( q ) <NEWLINE> <COMMENT> <NL> if self . dist [ src ] < prov_cost : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> for val in self . adj_list [ src ] : <NEWLINE> <INDENT> dest , cost = val <NEWLINE> if self . dist [ dest ] > self . dist [ src ] + cost : <NEWLINE> <INDENT> self . dist [ dest ] = self . dist [ src ] + cost <COMMENT> <NEWLINE> heappush ( q , ( self . dist [ dest ] , dest ) ) <COMMENT> <NEWLINE> self . prev [ dest ] = src <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return self . dist , self . prev <NEWLINE> <NL> <DEDENT> def shortest_path ( self , goal ) : <NEWLINE> <INDENT> path = [ goal ] <NEWLINE> dest = goal <NEWLINE> <COMMENT> <NL> while self . prev [ dest ] != float ( <STRING> ) : <NEWLINE> <INDENT> if self . prev [ dest ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> path . append ( self . prev [ dest ] ) <NEWLINE> dest = self . prev [ dest ] <NEWLINE> <DEDENT> return path [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_result ( data ) : <NEWLINE> <INDENT> N , M = data [ 0 ] <NEWLINE> A = data [ 1 : ] <NEWLINE> solver = Dijkstra ( N ) <NEWLINE> for val in A : <NEWLINE> <INDENT> solver . add_edge ( val [ 0 ] - 1 , val [ 1 ] - 1 , undirected = True ) <NEWLINE> <DEDENT> _ , prev = solver . distance ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for p in prev [ 1 : ] : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> raw_data = [ val . rstrip ( ) for val in stdin . readlines ( ) ] <NEWLINE> data = [ list ( map ( int , val . split ( <STRING> ) ) ) for val in raw_data ] <NEWLINE> get_result ( data ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r ** 2 * math . pi <NEWLINE> l = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( s ) , <STRING> . format ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> al . sort ( ) <NEWLINE> ma = al [ - 1 ] <NEWLINE> from collections import Counter <NEWLINE> c = Counter ( al ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sn = set ( ) <NEWLINE> total = 0 <NEWLINE> l = len ( al ) <NEWLINE> for num in al : <NEWLINE> <INDENT> if num in sn : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c [ num ] == 1 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> tmp = num <NEWLINE> while tmp <= ma : <NEWLINE> <INDENT> sn . add ( tmp ) <NEWLINE> tmp += num <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <DEDENT>
x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> a = [ input ( ) for i in range ( x ) ] <NEWLINE> c = <STRING> <NEWLINE> for i in range ( y + 2 ) : <NEWLINE> <INDENT> c = c + <STRING> <NEWLINE> <DEDENT> print ( c ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> print ( <STRING> + a [ i ] + <STRING> ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<STRING> <NEWLINE> <NL> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = A , B , C <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( A % 2 == 0 and B % 2 == 0 and C % 2 == 0 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> a , b , c = A , B , C <NEWLINE> A = ( b + c ) / 2 <NEWLINE> B = ( c + a ) / 2 <NEWLINE> C = ( a + b ) / 2 <NEWLINE> <COMMENT> <NL> if ( A == a and B == b and C == c ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> if ( A == a and B == b and C == c ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> N = len ( T ) <NEWLINE> count = 0 <NEWLINE> count_list = [ ] <NEWLINE> index_list = [ ] <NEWLINE> <NL> if len ( S ) - len ( T ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( S ) - N + 1 ) : <NEWLINE> <INDENT> index_list . append ( S [ 0 + i : N + i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( index_list ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if index_list [ i ] [ j ] == T [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> count_list . append ( count ) <NEWLINE> <NL> <DEDENT> print ( N - max ( count_list ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - count ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp_sum = [ 0 ] * N <NEWLINE> dp_sum [ 0 ] = 1 <NEWLINE> L = [ 0 ] * K <NEWLINE> R = [ 0 ] * K <NEWLINE> mod = 998244353 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ i ] = l <NEWLINE> R [ i ] = r <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> start = max ( 0 , i - R [ j ] ) <NEWLINE> end = i - L [ j ] <NEWLINE> cnt += ( dp_sum [ end ] - dp_sum [ start - 1 ] ) % mod <NEWLINE> cnt %= mod <NEWLINE> <DEDENT> dp [ i ] = cnt <NEWLINE> dp_sum [ i ] = dp_sum [ i - 1 ] + cnt <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> colors = [ 0 for i in range ( 8 ) ] <NEWLINE> tyty = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> c = a // 400 <NEWLINE> if c >= 8 : <NEWLINE> <INDENT> tyty += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> colors [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cNum = 8 - colors . count ( 0 ) <NEWLINE> <NL> minC = max ( cNum , 1 ) <NEWLINE> maxC = cNum + tyty <NEWLINE> <NL> print ( minC , maxC ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if 0 <= z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
import sys <NEWLINE> time_check = False <NEWLINE> if time_check : <NEWLINE> <INDENT> import time <NEWLINE> <NL> <DEDENT> num_of_inversions = 0 <NEWLINE> array = [ 0 for x in range ( 200000 ) ] <NEWLINE> <NL> def merge ( left , mid , right ) : <NEWLINE> <INDENT> n_fore = mid - left <NEWLINE> n_rear = right - mid <NEWLINE> l_fore = array [ left : left + n_fore ] <NEWLINE> l_fore . append ( sys . maxsize ) <NEWLINE> l_rear = array [ mid : mid + n_rear ] <NEWLINE> l_rear . append ( sys . maxsize ) <NEWLINE> <NL> i = j = 0 <NEWLINE> global num_of_inversions <NEWLINE> <NL> offset = len ( l_fore ) - 1 + left <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if l_fore [ i ] < l_rear [ j ] : <NEWLINE> <INDENT> array [ k ] = l_fore [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ k ] = l_rear [ j ] <NEWLINE> num_of_inversions += j - k + offset <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( left , mid ) <NEWLINE> merge_sort ( mid , right ) <NEWLINE> merge ( left , mid , right ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> for idx , value in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> array [ idx ] = int ( value ) <NEWLINE> <NL> <DEDENT> if time_check : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> <NL> <DEDENT> merge_sort ( 0 , n ) <NEWLINE> <NL> if time_check : <NEWLINE> <INDENT> print ( <STRING> , time . time ( ) - start ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( num_of_inversions ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def grinp ( h ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> ret . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = grinp ( h ) <NEWLINE> fa = False <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fl = 0 <NEWLINE> if i != 0 and grid [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if i != h - 1 and grid [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if j != 0 and grid [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if j != w - 1 and grid [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if fl == 0 : <NEWLINE> <INDENT> fa = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if fa : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if fa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> maxa = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> if min ( a ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > maxa : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> alphabet = <STRING> <NEWLINE> l = [ ] <NEWLINE> a = 1 <NEWLINE> sm = 0 <NEWLINE> for i in range ( 15 ) : <NEWLINE> <INDENT> a *= 26 <NEWLINE> sm += a <NEWLINE> l . append ( sm ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if n <= l [ i ] : <NEWLINE> <INDENT> cl = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cl == 0 : <NEWLINE> <INDENT> print ( alphabet [ n - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> n -= l [ cl - 1 ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( cl ) : <NEWLINE> <INDENT> num = ( n - 1 ) // ( 26 ** ( cl - i ) ) <NEWLINE> ans = ans + alphabet [ num ] <NEWLINE> n -= ( 26 ** ( cl - i ) ) * num <NEWLINE> <NL> <DEDENT> if n != 0 : <NEWLINE> <INDENT> ans = ans + alphabet [ n - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> g = K <NEWLINE> <NL> def d ( h ) : <NEWLINE> <INDENT> return X + ( h - ( K - h ) ) * D <NEWLINE> <NL> <DEDENT> if d ( s ) >= 0 : <NEWLINE> <INDENT> ans = d ( s ) <NEWLINE> <DEDENT> elif d ( g ) <= 0 : <NEWLINE> <INDENT> ans = abs ( d ( g ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> half = ( s + g ) // 2 <NEWLINE> while s < half : <NEWLINE> <INDENT> if d ( half ) < 0 : <NEWLINE> <INDENT> s = half <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = half <NEWLINE> <DEDENT> half = ( s + g ) // 2 <NEWLINE> <NL> <DEDENT> ans = min ( abs ( d ( s ) ) , abs ( d ( g ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> n = 0 <NEWLINE> for i in reversed ( S ) : <NEWLINE> <INDENT> n += int ( i ) * d <NEWLINE> n %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> mod [ n % 2019 ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( 2019 ) : <NEWLINE> <INDENT> ans += mod [ j ] * ( mod [ j ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( <STRING> ) <NEWLINE> ans = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if int ( i ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> ans = ans * int ( i ) <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> G . update ( { i : a [ i - 1 ] } ) <NEWLINE> <NL> <DEDENT> seen = [ False ] * ( n + 1 ) <NEWLINE> path = [ 1 ] <NEWLINE> <NL> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> seen [ i ] = True <NEWLINE> i = G [ i ] <NEWLINE> <NL> if seen [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> m = path . index ( i ) <NEWLINE> <NL> if m > k : <NEWLINE> <INDENT> print ( path [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= m <NEWLINE> path = path [ m : ] <NEWLINE> k %= len ( path ) <NEWLINE> print ( path [ k ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> <NL> num = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> num *= a [ i ] <NEWLINE> if ( num == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( num > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> print ( t [ lr [ j ] [ 1 ] - 1 ] - t [ lr [ j ] [ 0 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> instr = input ( ) <NEWLINE> x = int ( instr ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> b_count = N // a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_count = N // a <NEWLINE> <DEDENT> result += b_count <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> if N == K : <NEWLINE> <INDENT> ans0 = 1 <NEWLINE> for a in A [ 0 : N ] : <NEWLINE> <INDENT> ans0 *= a <NEWLINE> ans0 %= MOD <NEWLINE> <DEDENT> print ( ans0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> if ( K % 2 == 1 and A [ - 1 ] < 0 ) : <NEWLINE> <INDENT> ans1 = 1 <NEWLINE> for a in A [ N - K : N ] : <NEWLINE> <INDENT> ans1 *= a <NEWLINE> ans1 %= MOD <NEWLINE> <DEDENT> print ( ans1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> AA = [ np . sign ( i ) for i in A ] <NEWLINE> <NL> ansA = 1 <NEWLINE> for a in A [ 0 : K ] : <NEWLINE> <INDENT> ansA *= a <NEWLINE> ansA %= MOD <NEWLINE> <DEDENT> ansAA = AA [ 0 : K ] . count ( - 1 ) % 2 <NEWLINE> if ansA == 0 or ansAA == 0 : <NEWLINE> <INDENT> print ( ansA ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> B1 = A [ 0 : K ] <NEWLINE> C1 = A [ 0 : K ] <NEWLINE> B2 = sorted ( A [ K : N ] ) <NEWLINE> Bp = [ i for i in A [ 0 : K ] if i > 0 ] <NEWLINE> Bm = [ i for i in A [ 0 : K ] if i < 0 ] <NEWLINE> <NL> if B2 [ 0 ] > 0 : B2 . insert ( 0 , 0 ) <NEWLINE> if B2 [ - 1 ] < 0 : B2 . insert ( - 1 , 0 ) <NEWLINE> if not Bp : Bp . insert ( 0 , B1 [ - 1 ] ) <NEWLINE> if not Bm : Bm . insert ( 0 , B1 [ 0 ] ) <NEWLINE> <NL> B1 . remove ( Bp [ - 1 ] ) <NEWLINE> B1 . append ( min ( B2 [ 0 ] , 0 ) ) <NEWLINE> <NL> ansB = 1 <NEWLINE> for a in B1 [ 0 : K ] : <NEWLINE> <INDENT> ansB *= a <NEWLINE> ansB %= MOD <NEWLINE> <NL> <DEDENT> C1 . remove ( Bm [ - 1 ] ) <NEWLINE> C1 . append ( max ( B2 [ - 1 ] , 0 ) ) <NEWLINE> <NL> ansC = 1 <NEWLINE> for a in C1 [ 0 : K ] : <NEWLINE> <INDENT> ansC *= a <NEWLINE> ansC %= MOD <NEWLINE> <NL> <DEDENT> BB1 = [ np . sign ( i ) for i in B1 ] <NEWLINE> ansBB1 = BB1 [ 0 : K ] . count ( - 1 ) % 2 <NEWLINE> BB2 = [ np . sign ( i ) for i in C1 ] <NEWLINE> ansBB2 = BB2 [ 0 : K ] . count ( - 1 ) % 2 <NEWLINE> if ansBB1 == 1 : <NEWLINE> <INDENT> print ( ansC ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ansBB2 == 1 : <NEWLINE> <INDENT> print ( ansB ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if abs ( Bp [ - 1 ] * B2 [ - 1 ] ) - abs ( Bm [ - 1 ] * B2 [ 0 ] ) >= 0 : <NEWLINE> <INDENT> print ( ansC ) <NEWLINE> <DEDENT> else : print ( ansB ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 for i in range ( N ) ] <NEWLINE> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> P [ A - 1 ] += 1 <NEWLINE> P [ B - 1 ] += 1 <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> L [ A - 1 ] += 1 <NEWLINE> <DEDENT> if H [ B - 1 ] > H [ A - 1 ] : <NEWLINE> <INDENT> L [ B - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == L [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> W_count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - W_count <NEWLINE> W_count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
MAX = 1000000001 <NEWLINE> <NL> def merge ( A , left , mid , right , cnt ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> ls = len ( L ) <NEWLINE> L . append ( MAX ) <NEWLINE> R . append ( MAX ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> cnt += ls - i <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right , cnt ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> cnt = mergeSort ( A , left , mid , cnt ) <NEWLINE> cnt = mergeSort ( A , mid , right , cnt ) <NEWLINE> cnt = merge ( A , left , mid , right , cnt ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> cnt = mergeSort ( A , 0 , num , 0 ) <NEWLINE> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> n = inint ( ) <NEWLINE> P = inintl ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = P [ i ] <NEWLINE> b = P [ i + 1 ] <NEWLINE> if a == i + 1 : <NEWLINE> <INDENT> P [ i ] = b <NEWLINE> P [ i + 1 ] = a <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if P [ - 1 ] == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> s = S % 60 <NEWLINE> m = S // 60 % 60 <NEWLINE> h = S // 60 // 60 <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> nmax = 100000 <NEWLINE> n = int ( input ( ) ) <NEWLINE> values = [ 0 ] * nmax <NEWLINE> a = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> for v in a : <NEWLINE> <INDENT> values [ v - 1 ] += 1 <NEWLINE> <DEDENT> asum = sum ( a ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> asum += values [ b - 1 ] * ( c - b ) <NEWLINE> values [ c - 1 ] += values [ b - 1 ] <NEWLINE> values [ b - 1 ] = 0 <NEWLINE> print ( asum ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import copy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> RL = [ 0 ] * ( N + 1 ) <NEWLINE> GL = copy . deepcopy ( RL ) <NEWLINE> BL = copy . deepcopy ( RL ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> RL [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i + 1 ) <NEWLINE> GL [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B . append ( i + 1 ) <NEWLINE> BL [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> len_r = len ( R ) <NEWLINE> len_g = len ( G ) <NEWLINE> len_b = len ( B ) <NEWLINE> ans = 0 <NEWLINE> if max ( len_r , len_g , len_b ) == len_b : <NEWLINE> <INDENT> for i in range ( len_r ) : <NEWLINE> <INDENT> for j in range ( len_g ) : <NEWLINE> <INDENT> ans += len_b <NEWLINE> tmp_abs = abs ( R [ i ] - G [ j ] ) <NEWLINE> <NL> index = ( min ( R [ i ] , G [ j ] ) - tmp_abs ) <NEWLINE> if index > 0 and BL [ index ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> index = ( max ( R [ i ] , G [ j ] ) + tmp_abs ) <NEWLINE> if index <= N and BL [ index ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> if tmp_abs % 2 == 0 and BL [ max ( R [ i ] , G [ j ] ) - ( tmp_abs // 2 ) ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif max ( len_r , len_g , len_b ) == len_g : <NEWLINE> <INDENT> for i in range ( len_r ) : <NEWLINE> <INDENT> for j in range ( len_b ) : <NEWLINE> <INDENT> ans += len_g <NEWLINE> tmp_abs = abs ( R [ i ] - B [ j ] ) <NEWLINE> <NL> index = ( min ( R [ i ] , B [ j ] ) - tmp_abs ) <NEWLINE> if index > 0 and GL [ index ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> index = ( max ( R [ i ] , B [ j ] ) + tmp_abs ) <NEWLINE> if index <= N and GL [ index ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> if tmp_abs % 2 == 0 and GL [ max ( R [ i ] , B [ j ] ) - ( tmp_abs // 2 ) ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len_g ) : <NEWLINE> <INDENT> for j in range ( len_b ) : <NEWLINE> <INDENT> ans += len_r <NEWLINE> tmp_abs = abs ( G [ i ] - B [ j ] ) <NEWLINE> <NL> index = ( min ( G [ i ] , B [ j ] ) - tmp_abs ) <NEWLINE> if index > 0 and RL [ index ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> index = ( max ( G [ i ] , B [ j ] ) + tmp_abs ) <NEWLINE> if index <= N and RL [ index ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> if tmp_abs % 2 == 0 and RL [ max ( G [ i ] , B [ j ] ) - ( tmp_abs // 2 ) ] == 1 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = int ( b // x ) - int ( a // x ) <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> apartment = [ [ [ 0 for z in range ( 10 ) ] for y in range ( 3 ) ] for x in range ( 4 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> data = [ [ int ( x ) - 1 for x in input ( ) . split ( ) ] for y in range ( N ) ] <NEWLINE> for x in data : <NEWLINE> <INDENT> apartment [ x [ 0 ] ] [ x [ 1 ] ] [ x [ 2 ] ] += x [ 3 ] + 1 <NEWLINE> if apartment [ x [ 0 ] ] [ x [ 1 ] ] [ x [ 2 ] ] > 9 : <NEWLINE> <INDENT> apartment [ x [ 0 ] ] [ x [ 1 ] ] [ x [ 2 ] ] = 9 <NEWLINE> <DEDENT> elif apartment [ x [ 0 ] ] [ x [ 1 ] ] [ x [ 2 ] ] < 0 : <NEWLINE> <INDENT> apartment [ x [ 0 ] ] [ x [ 1 ] ] [ x [ 2 ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> for x in range ( 4 ) : <NEWLINE> <INDENT> for y in range ( 3 ) : <NEWLINE> <INDENT> for z in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( apartment [ x ] [ y ] [ z ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if x != 3 : <NEWLINE> <INDENT> print ( ( <STRING> * 20 ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : print ( <STRING> ) <NEWLINE> elif a > b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import string <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> n_digits = len ( str ( 1000000000000001 ) ) <NEWLINE> letters = string . ascii_lowercase <NEWLINE> <NL> x = N - 1 <NEWLINE> ans = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> mod = x % 26 <NEWLINE> div = x // 26 <NEWLINE> <NL> ans . append ( mod ) <NEWLINE> if div == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = div - 1 <NEWLINE> <NL> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> <COMMENT> <NL> print ( <STRING> . join ( [ letters [ v ] for v in ans ] ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Con = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> if A . __contains__ ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> if ans <= Con : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans <= Con else <STRING> ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> suma = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sumall = sum ( a ) % mod <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sumall -= a [ i ] <NEWLINE> suma += ( a [ i ] * sumall ) % mod <NEWLINE> <DEDENT> print ( suma % mod ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> <NL> def pd ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ms = [ <NEWLINE> <INDENT> [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for m in range ( M ) <NEWLINE> <DEDENT> ] <NEWLINE> pd ( <STRING> ) <NEWLINE> pd ( <STRING> ) <NEWLINE> <NL> rows = [ 0 ] * ( H + 1 ) <NEWLINE> cols = [ 0 ] * ( W + 1 ) <NEWLINE> targets = { } <NEWLINE> for h , w in ms : <NEWLINE> <INDENT> rows [ h ] += 1 <NEWLINE> cols [ w ] += 1 <NEWLINE> targets [ <STRING> ] = True <NEWLINE> <NL> <DEDENT> rmax = max ( rows ) <NEWLINE> cmax = max ( cols ) <NEWLINE> rmax_hs = [ i for i , v in enumerate ( rows ) if v == rmax ] <NEWLINE> cmax_wh = [ i for i , v in enumerate ( cols ) if v == cmax ] <NEWLINE> <NL> for h , w in itertools . product ( rmax_hs , cmax_wh ) : <NEWLINE> <INDENT> if <STRING> not in targets : <NEWLINE> <INDENT> print ( rmax + cmax ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( rmax + cmax - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> D = dict ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a not in D . keys ( ) : <NEWLINE> <INDENT> D [ a ] = 0 <NEWLINE> <DEDENT> D [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in D . items ( ) : <NEWLINE> <INDENT> ans += k * v <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> if B in D . keys ( ) : <NEWLINE> <INDENT> count = D [ B ] <NEWLINE> <NL> if C not in D . keys ( ) : <NEWLINE> <INDENT> D [ C ] = 0 <NEWLINE> <DEDENT> D [ C ] += count <NEWLINE> del D [ B ] <NEWLINE> <NL> ans += ( C - B ) * count <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> sum = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> sum += x <NEWLINE> sum %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> sum2 = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> sum2 += x * x <NEWLINE> sum2 %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> ans = ( sum ** 2 - sum2 ) % ( 10 ** 9 + 7 ) <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans *= int ( ( 10 ** 9 + 7 + 1 ) / 2 ) <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b == c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pair = 0 <NEWLINE> As = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> x1 = i + 1 - a <NEWLINE> x2 = i + 1 + a <NEWLINE> if x1 in As : <NEWLINE> <INDENT> pair += As [ x1 ] <NEWLINE> <DEDENT> if x2 in As : <NEWLINE> <INDENT> As [ x2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> As [ x2 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( pair ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= 2 * C : <NEWLINE> <INDENT> if B >= 2 * C : <NEWLINE> <INDENT> print ( 2 * C * max ( X , Y ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * C * X + B * max ( 0 , ( Y - X ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif B >= 2 * C : <NEWLINE> <INDENT> print ( 2 * C * Y + A * max ( 0 , ( X - Y ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A * X + B * Y <NEWLINE> for i in range ( 1 , min ( X , Y ) + 1 ) : <NEWLINE> <INDENT> p = A * ( X - i ) + B * ( Y - i ) + 2 * C * i <NEWLINE> ans = min ( ans , p ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = s [ i ] <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> <NL> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if { s [ k ] , s [ k + i ] , s [ k + 2 * i ] } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> * W ) <NEWLINE> for a in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = deque ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> D . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( D ) ) ) <NEWLINE>
import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ac_ques = np . array ( [ 0 ] * n ) <NEWLINE> count = np . array ( [ 0 ] * n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> if ac_ques [ int ( p ) - 1 ] == 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> count [ int ( p ) - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ac_ques [ int ( p ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( ac_ques ) , sum ( ac_ques * count ) ) <NEWLINE>
words = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> S = readline ( ) . rstrip ( ) <NEWLINE> <NL> stack = [ 0 ] <NEWLINE> while stack : <NEWLINE> <INDENT> ind = stack . pop ( ) <NEWLINE> if ind == len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> for w in words : <NEWLINE> <INDENT> if S [ ind : ind + len ( w ) ] == w : <NEWLINE> <INDENT> stack . append ( ind + len ( w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> data = input ( ) <NEWLINE> if data == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( sum ( [ int ( i ) for i in data ] ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pro = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> pro *= i <NEWLINE> if pro > 10 ** 18 : <NEWLINE> <INDENT> pro = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( pro ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a = [ eval ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( - 1 , - len ( a ) - 1 , - 1 ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> if i == - len ( a ) else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> B = [ 0 ] + list ( accumulate ( b ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sup_i = bisect_left ( A , k + 1 ) <NEWLINE> for i in range ( sup_i ) : <NEWLINE> <INDENT> ans = max ( ans , i + bisect_left ( B , k - A [ i ] + 1 ) - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
def sumOfNaturalNumber ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) / 2 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += sumOfNaturalNumber ( n ) * i <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = MAP ( ) <NEWLINE> <NL> tree = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = MAP ( ) <NEWLINE> tree . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , tree . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mx = max ( a ) + 1 <NEWLINE> dp = [ 0 ] * mx <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , mx , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> w_last_index = N - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> for j in range ( w_last_index , i , - 1 ) : <NEWLINE> <INDENT> if c [ j ] == <STRING> : <NEWLINE> <INDENT> c [ j ] = <STRING> <NEWLINE> w_last_index = j <NEWLINE> cnt += 1 <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_ind = a . index ( min ( a ) ) <NEWLINE> <NL> start = [ min_ind - x for x in range ( k ) if min_ind - x >= 0 ] <NEWLINE> end = [ s + k - 1 for s in start ] <NEWLINE> <NL> ans = 10 ** 6 <NEWLINE> for s , e in zip ( start , end ) : <NEWLINE> <INDENT> ans = min ( ans , math . ceil ( s / ( k - 1 ) ) + math . ceil ( ( n - ( e + 1 ) ) / ( k - 1 ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans + 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> N = X // D <NEWLINE> if N > K : <NEWLINE> <INDENT> N = K <NEWLINE> <DEDENT> X = X - N * D <NEWLINE> K -= N <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X -= D <NEWLINE> print ( abs ( X ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = collections . Counter ( [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] ) <NEWLINE> print ( sum ( map ( lambda x : x * ( x - 1 ) // 2 , S . values ( ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> res = 0 <NEWLINE> a_sum = sum ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> main = a [ i ] <NEWLINE> a_sum = a_sum - main <NEWLINE> res = ( res + main * a_sum % mod ) % mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
from collections import deque , namedtuple <NEWLINE> <NL> class RootedTree : <NEWLINE> <INDENT> def __init__ ( self , t , n ) : <NEWLINE> <INDENT> self . t = t <NEWLINE> self . n = n <NEWLINE> self . d = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def setDepth ( self , u , p ) : <NEWLINE> <INDENT> self . t [ u ] = self . t [ u ] . _replace ( d = p ) <NEWLINE> for i in self . getChildren ( u ) : <NEWLINE> <INDENT> self . setDepth ( i , p + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getChildren ( self , u ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> c = self . t [ u ] . l <NEWLINE> while c != - 1 : <NEWLINE> <INDENT> ret . append ( c ) <NEWLINE> c = self . t [ c ] . r <NEWLINE> <DEDENT> return ( ret ) <NEWLINE> <NL> <DEDENT> def printNode ( self , i ) : <NEWLINE> <INDENT> p_ = self . t [ i ] . p <NEWLINE> d_ = self . t [ i ] . d <NEWLINE> c_ = self . getChildren ( i ) <NEWLINE> if p_ == - 1 : <NEWLINE> <INDENT> t_ = <STRING> <NEWLINE> <DEDENT> elif len ( c_ ) == 0 : <NEWLINE> <INDENT> t_ = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_ = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( i , p_ , d_ , t_ , c_ ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> Node = namedtuple ( <STRING> , [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> t = [ Node ( - 1 , - 1 , - 1 , - 1 ) ] * n <NEWLINE> r = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = deque ( [ int ( i ) for i in input ( ) . rstrip ( ) . split ( <STRING> ) ] ) <NEWLINE> v = tmp . popleft ( ) <NEWLINE> d = tmp . popleft ( ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> c = tmp . popleft ( ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> t [ v ] = t [ v ] . _replace ( l = c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ l ] = t [ l ] . _replace ( r = c ) <NEWLINE> <DEDENT> l = c <NEWLINE> t [ c ] = t [ c ] . _replace ( p = v ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( t [ i ] . p == - 1 ) : <NEWLINE> <INDENT> r = i <NEWLINE> <DEDENT> <DEDENT> x = RootedTree ( t , n ) <NEWLINE> x . setDepth ( r , 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x . printNode ( i ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> for b in range ( a , math . ceil ( N / a ) ) : <NEWLINE> <INDENT> c = N - a * b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def mpow ( x , n , mod ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n % 4 == 0 : <NEWLINE> <INDENT> return mpow ( ( x ** 4 ) % mod , int ( n / 4 ) , mod ) <NEWLINE> <DEDENT> elif n % 4 == 1 : <NEWLINE> <INDENT> return ( mpow ( x , int ( n - 1 ) , mod ) * x ) % mod <NEWLINE> <DEDENT> elif n % 4 == 2 : <NEWLINE> <INDENT> return ( mpow ( x , int ( n - 2 ) , mod ) * ( x ** 2 ) ) % mod <NEWLINE> <DEDENT> elif n % 4 == 3 : <NEWLINE> <INDENT> return ( mpow ( x , int ( n - 3 ) , mod ) * ( x ** 3 ) ) % mod <NEWLINE> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> print ( mpow ( n , m , mod ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> R = [ ] <NEWLINE> B = [ ] <NEWLINE> G = [ ] <NEWLINE> p = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if ( i == <STRING> ) : <NEWLINE> <INDENT> R . append ( p ) <NEWLINE> <DEDENT> elif ( i == <STRING> ) : <NEWLINE> <INDENT> B . append ( p ) <NEWLINE> <DEDENT> elif ( i == <STRING> ) : <NEWLINE> <INDENT> G . append ( p ) <NEWLINE> <DEDENT> p += 1 <NEWLINE> <DEDENT> R = set ( R ) <NEWLINE> B = set ( B ) <NEWLINE> G = set ( G ) <NEWLINE> sum = len ( R ) * len ( B ) * len ( G ) <NEWLINE> for r in R : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> up = max ( r , b ) <NEWLINE> dw = min ( r , b ) <NEWLINE> d = up - dw <NEWLINE> if up + d in G : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> if dw - d in G : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> if ( r + b ) / 2 in G : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> NodeStatus = [ False ] * N <NEWLINE> NodeFirstSteps = [ 0 ] * N <NEWLINE> L = 0 <NEWLINE> STARTLINDEX = 0 <NEWLINE> OrderARR = [ ] <NEWLINE> <NL> <NL> def dfs ( pos , arr , step ) : <NEWLINE> <INDENT> if NodeStatus [ pos ] == True : <NEWLINE> <INDENT> L = ( step - NodeFirstSteps [ pos ] ) <NEWLINE> STARTLINDEX = NodeFirstSteps [ pos ] <NEWLINE> print ( OrderARR [ ( K - STARTLINDEX ) % L + STARTLINDEX ] + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if step == K : <NEWLINE> <INDENT> print ( pos + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> OrderARR . append ( pos ) <NEWLINE> NodeStatus [ pos ] = True <NEWLINE> NodeFirstSteps [ pos ] = step <NEWLINE> dfs ( arr [ pos ] - 1 , arr , step + 1 ) <NEWLINE> <NL> <NL> <DEDENT> dfs ( 0 , ARR , 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> sa = sum ( a ) <NEWLINE> bc = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> bc . append ( [ b , c ] ) <NEWLINE> <DEDENT> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in d : <NEWLINE> <INDENT> d [ a [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b = bc [ i ] [ 0 ] <NEWLINE> c = bc [ i ] [ 1 ] <NEWLINE> cb = c - b <NEWLINE> if b in d : <NEWLINE> <INDENT> sa += cb * d [ b ] <NEWLINE> if c in d : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sa ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> start = 7 % k <NEWLINE> ans = start <NEWLINE> con = 1 <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> print ( con ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> con += 1 <NEWLINE> ans = ans * 10 + 7 <NEWLINE> ans = ans % k <NEWLINE> if ans == start : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 0 <NEWLINE> rem = 7 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> rem = rem % K <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if r > K : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <DEDENT> rem = ( rem * 10 ) + 7 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> flag = True <NEWLINE> flag_zero = False <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> flag_zero = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> if not flag_zero : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from math import gcd <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> from collections import Counter <NEWLINE> ctr = Counter ( ) <NEWLINE> az = bz = zz = 0 <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> zz += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> az += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> bz += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a , b = a // g , b // g <NEWLINE> if b < 0 : <NEWLINE> <INDENT> b *= - 1 <NEWLINE> a *= - 1 <NEWLINE> <DEDENT> ctr [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = pow ( 2 , az , MOD ) + pow ( 2 , bz , MOD ) - 1 <NEWLINE> <NL> used = set ( ) <NEWLINE> for ( a1 , b1 ) , v in ctr . items ( ) : <NEWLINE> <INDENT> if ( a1 , b1 ) in used : continue <NEWLINE> a2 , b2 = - b1 , a1 <NEWLINE> if b2 < 0 : <NEWLINE> <INDENT> b2 *= - 1 <NEWLINE> a2 *= - 1 <NEWLINE> <DEDENT> if ( a2 , b2 ) in ctr : <NEWLINE> <INDENT> used . add ( ( a2 , b2 ) ) <NEWLINE> <DEDENT> r = pow ( 2 , v , MOD ) + pow ( 2 , ctr [ ( a2 , b2 ) ] , MOD ) - 1 <NEWLINE> ans *= r <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans += zz - 1 <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> sortli = sorted ( li ) <NEWLINE> print ( <STRING> . join ( sortli ) ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> M = [ ] <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p = input ( <STRING> ) <NEWLINE> M . append ( p ) <NEWLINE> <NL> <DEDENT> Mm = list ( set ( M ) ) <NEWLINE> <NL> print ( len ( Mm ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> dish = [ a , b , c , d , e ] <NEWLINE> last = 0 <NEWLINE> for index , d in enumerate ( dish ) : <NEWLINE> <INDENT> if d % 10 != 0 : <NEWLINE> <INDENT> d10 = ( ( d // 10 ) + 1 ) * 10 <NEWLINE> if last <= d10 - d : <NEWLINE> <INDENT> last = d10 - d <NEWLINE> <DEDENT> dish [ index ] = d10 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( dish ) - last ) <NEWLINE> <NL> <NL> <NL>
def check ( P ) : <NEWLINE> <INDENT> lis = [ [ ] for i in range ( k ) ] <NEWLINE> su = [ 0 for i in range ( k ) ] <NEWLINE> <NL> su . append ( - 10000 ) <NEWLINE> cur = 0 <NEWLINE> for i , bag in enumerate ( baggage ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> while su [ cur ] + bag > P : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> if cur == k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ cur ] . append ( bag ) <NEWLINE> su [ cur ] += bag <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> min_P = 1000000000 <NEWLINE> left = 1 <NEWLINE> right = 1000000000 <NEWLINE> mid = ( left + right ) // 2 <NEWLINE> while left < right : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if check ( mid ) : <NEWLINE> <INDENT> right = mid <NEWLINE> if min_P > mid : <NEWLINE> <INDENT> min_P = mid <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> mid = ( left + right ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( min_P ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> baggage = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for B in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if ( A + B >= K ) : <NEWLINE> <INDENT> if ( A > K ) : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = K - ( A + B ) <NEWLINE> ans = A - count <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ma = max ( A ) <NEWLINE> <NL> prime = [ 0 for i in range ( ma ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for j in range ( a , ma + 1 , a ) : <NEWLINE> <INDENT> prime [ j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if ( prime [ i - 1 ] == 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def check ( d ) : <NEWLINE> <INDENT> cut_num = 0 <NEWLINE> for i in leng : <NEWLINE> <INDENT> cut_num += math . ceil ( i / d ) - 1 <NEWLINE> <DEDENT> if cut_num <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> leng = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_min = 0 <NEWLINE> d_max = max ( leng ) <NEWLINE> d = math . ceil ( d_max / 2 ) <NEWLINE> <NL> while d_max - d_min > 1 : <NEWLINE> <INDENT> if check ( d ) : <NEWLINE> <INDENT> d_max = d <NEWLINE> d = math . ceil ( ( d_max + d_min ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d_min = d <NEWLINE> d = int ( ( d_max + d_min ) / 2 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( d_max ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> for i in range ( min ( len ( O ) , len ( E ) ) ) : <NEWLINE> <INDENT> print ( O [ i ] , E [ i ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if len ( O ) > len ( E ) : <NEWLINE> <INDENT> print ( O [ - 1 ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if h [ a ] > h [ b ] : <NEWLINE> <INDENT> result [ b ] = 0 <NEWLINE> <DEDENT> elif h [ a ] < h [ b ] : <NEWLINE> <INDENT> result [ a ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ a ] = 0 <NEWLINE> result [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( result ) ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> L = list ( input ( ) for i in range ( N ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> X = L [ 0 ] <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> e = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if L [ i ] == X : <NEWLINE> <INDENT> c += 1 <NEWLINE> if i == N - 1 and c > d : <NEWLINE> <INDENT> e = [ X ] <NEWLINE> <DEDENT> elif i == N - 1 and c == d : <NEWLINE> <INDENT> e . append ( X ) <NEWLINE> <DEDENT> <DEDENT> elif L [ i ] != X and d < c : <NEWLINE> <INDENT> d = c <NEWLINE> c = 0 <NEWLINE> e = [ ] <NEWLINE> e . append ( X ) <NEWLINE> X = L [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif L [ i ] != X and d == c : <NEWLINE> <INDENT> c = 1 <NEWLINE> e . append ( X ) <NEWLINE> X = L [ i ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> e . append ( X ) <NEWLINE> <DEDENT> <DEDENT> elif L [ i ] != X and d > c : <NEWLINE> <INDENT> c = 0 <NEWLINE> X = L [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> for i in e : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_max = max ( a ) <NEWLINE> lst = [ 0 ] * ( a_max + 1 ) <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> if lst [ i ] > 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a_max // i + 1 ) : <COMMENT> <NEWLINE> <INDENT> lst [ i * j ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if lst [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = Counter ( a ) . values ( ) <NEWLINE> c = [ x for x in b if x % 2 != 0 ] <NEWLINE> print ( len ( c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> x = ( n - 1 ) // a <NEWLINE> ans += x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> i_j = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( i_j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> MOD = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> N , K , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> if K == N : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A_pos = [ a for a in A if a >= 0 ] <NEWLINE> A_neg = [ a for a in A if a < 0 ] <NEWLINE> <NL> if len ( A_pos ) == 0 : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> A_neg . sort ( reverse = True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_neg . sort ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A_neg [ : K ] : <NEWLINE> <INDENT> ans = ans * a % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A_pos . sort ( ) <NEWLINE> A_neg . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> r = K <NEWLINE> if r % 2 == 1 : <NEWLINE> <INDENT> ans = ans * A_pos . pop ( ) % MOD <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> while r > 0 : <NEWLINE> <INDENT> if len ( A_pos ) <= 1 : <NEWLINE> <INDENT> ans = ans * A_neg . pop ( ) * A_neg . pop ( ) % MOD <NEWLINE> <DEDENT> elif len ( A_neg ) <= 1 : <NEWLINE> <INDENT> ans = ans * A_pos . pop ( ) * A_pos . pop ( ) % MOD <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> acc_pos = A_pos [ - 1 ] * A_pos [ - 2 ] <NEWLINE> acc_neg = A_neg [ - 1 ] * A_neg [ - 2 ] <NEWLINE> <NL> if acc_pos > acc_neg : <NEWLINE> <INDENT> ans = ans * A_pos . pop ( ) * A_pos . pop ( ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A_neg . pop ( ) * A_neg . pop ( ) % MOD <NEWLINE> <DEDENT> <DEDENT> r -= 2 <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k == 1 or len ( s ) == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT>
from __future__ import print_function <NEWLINE> from sys import stdin , stdout <NEWLINE> <NL> try : <NEWLINE> <INDENT> xrange <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> range = xrange <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> table = [ ] <NEWLINE> for _ in range ( 9 ) : <NEWLINE> <INDENT> table . append ( stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> check_table = [ ] <NEWLINE> for _ in range ( 9 ) : <NEWLINE> <INDENT> check_table . append ( [ False ] * 9 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for j in range ( 9 ) : <NEWLINE> <INDENT> a . append ( table [ i ] [ j ] ) <NEWLINE> <DEDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> n = table [ i ] [ j ] <NEWLINE> if a . count ( n ) > 1 : <NEWLINE> <INDENT> check_table [ i ] [ j ] = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> a . append ( table [ i ] [ j ] ) <NEWLINE> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> n = table [ i ] [ j ] <NEWLINE> if a . count ( n ) > 1 : <NEWLINE> <INDENT> check_table [ i ] [ j ] = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , 9 , 3 ) : <NEWLINE> <INDENT> for j in range ( 0 , 9 , 3 ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for di in range ( 3 ) : <NEWLINE> <INDENT> for dj in range ( 3 ) : <NEWLINE> <INDENT> a . append ( table [ i + di ] [ j + dj ] ) <NEWLINE> <DEDENT> <DEDENT> for di in range ( 3 ) : <NEWLINE> <INDENT> for dj in range ( 3 ) : <NEWLINE> <INDENT> n = table [ i + di ] [ j + dj ] <NEWLINE> if a . count ( n ) > 1 : <NEWLINE> <INDENT> check_table [ i + di ] [ j + dj ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> if check_table [ i ] [ j ] : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> stdout . write ( table [ i ] [ j ] ) <NEWLINE> <DEDENT> stdout . write ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = sorted ( [ [ abs ( X - i ) , i ] for i in range ( - 200 , 200 ) if i not in P ] , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> inf = 10 ** 3 <NEWLINE> inf2 = 10 ** 3 * - 1 <NEWLINE> <NL> for i in range ( X , inf ) : <NEWLINE> <INDENT> if i in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> plus = abs ( X - i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for j in range ( X , inf * - 1 , - 1 ) : <NEWLINE> <INDENT> if j in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> minus = abs ( X - j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if plus < minus : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> N , X = in_nn ( ) <NEWLINE> <NL> blen = [ 0 ] * ( N + 1 ) <NEWLINE> blen [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> blen [ i + 1 ] = blen [ i ] * 2 + 3 <NEWLINE> <NL> <DEDENT> pcount = [ 0 ] * ( N + 1 ) <NEWLINE> pcount [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pcount [ i + 1 ] = pcount [ i ] * 2 + 1 <NEWLINE> <NL> <NL> <DEDENT> def count ( L , X ) : <NEWLINE> <NL> <INDENT> if L == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if X == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> if X <= blen [ L ] // 2 : <NEWLINE> <INDENT> ret += count ( L - 1 , X - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += pcount [ L - 1 ] + 1 <NEWLINE> if X > blen [ L ] // 2 + 1 : <NEWLINE> <INDENT> X -= blen [ L ] // 2 + 1 <NEWLINE> X = min ( X , blen [ L - 1 ] ) <NEWLINE> ret += count ( L - 1 , X ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> ans = count ( N , X ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def is_ok ( x ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for ss in s : <NEWLINE> <INDENT> y = ss // x <NEWLINE> if ss % x == 0 : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> res += y <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> ng = 0 <NEWLINE> ok = 10 ** 10 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) <= k : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> l = [ 0 ] * 26 <NEWLINE> <NL> max = 0 <NEWLINE> target = 0 <NEWLINE> deg = 0 <NEWLINE> <COMMENT> <NL> for d in range ( D ) : <NEWLINE> <INDENT> degsum = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> degsum += c [ i ] * ( d - l [ i ] ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> w = degsum - c [ i ] * ( d - l [ i ] ) - s [ d ] [ i ] <NEWLINE> if max < - w : <NEWLINE> <INDENT> max = - w <NEWLINE> target = i <NEWLINE> <DEDENT> <DEDENT> t . append ( target + 1 ) <NEWLINE> l [ target ] = d <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] -= 1 <NEWLINE> b [ i ] -= 1 <NEWLINE> <DEDENT> A = [ 0 ] * n <NEWLINE> ans = 0 <NEWLINE> def dfs ( h ) : <NEWLINE> <INDENT> global ans <NEWLINE> if h == n - 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] ] - A [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A [ h ] , m + 1 ) : <NEWLINE> <INDENT> A [ h + 1 ] = i <NEWLINE> dfs ( h + 1 ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> A [ 0 ] = i <NEWLINE> dfs ( 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> <NL> member = int ( input ( ) ) <NEWLINE> mem_number = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> ans = [ 0 ] * member <NEWLINE> <NL> mycounter = Counter ( mem_number ) <NEWLINE> <NL> for i in range ( member ) : <NEWLINE> <INDENT> ans [ i ] = mycounter [ i + 1 ] <NEWLINE> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def is_good ( mid , key ) : <NEWLINE> <INDENT> x = A - mid // F <NEWLINE> return x [ x > 0 ] . sum ( ) <= key <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( key ) : <NEWLINE> <INDENT> bad , good = - 1 , 10 ** 18 <NEWLINE> while good - bad > 1 : <NEWLINE> <INDENT> mid = ( bad + good ) // 2 <NEWLINE> if is_good ( mid , key ) : <NEWLINE> <INDENT> good = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad = mid <NEWLINE> <DEDENT> <DEDENT> return good <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A . sort ( ) <NEWLINE> F [ : : - 1 ] . sort ( ) <NEWLINE> print ( binary_search ( K ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> li . sort ( ) <NEWLINE> last = li [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if last == li [ i ] : <NEWLINE> <INDENT> li [ i ] = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> last = li [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - li . count ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> print ( <STRING> . join ( a [ : : - 1 ] ) ) <NEWLINE>
<COMMENT> <NL> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> z = ( A * x ) // B - A * ( x // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> z = ( A * x ) // B - A * ( x // B ) <NEWLINE> <NL> <DEDENT> print ( int ( z ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> counter = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( now , prev ) : <NEWLINE> <INDENT> for next in edges [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ next ] += counter [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * counter ) <NEWLINE> <NL>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p1 = [ i for i in range ( 0 , 102 ) ] <NEWLINE> for i in p : <NEWLINE> <INDENT> if i in p1 : <NEWLINE> <INDENT> p1 . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 1000 <NEWLINE> al = [ ] <NEWLINE> for i in p1 : <NEWLINE> <INDENT> if ans >= abs ( i - x ) : <NEWLINE> <INDENT> ans = min ( abs ( i - x ) , ans ) <NEWLINE> al . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( al ) == 0 : <NEWLINE> <INDENT> if x < 50 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> <DEDENT> elif len ( al ) > 1 : <NEWLINE> <INDENT> if abs ( al [ - 1 ] - x ) == abs ( al [ - 2 ] - x ) : <NEWLINE> <INDENT> print ( al [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( al [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( al [ - 1 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> H , W , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> t . append ( [ int ( i ) for i in input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> d = np . array ( t ) <NEWLINE> i_2 = [ int ( k ) for k in bin ( i ) [ 2 : ] . rjust ( H , <STRING> ) ] <NEWLINE> j_2 = [ int ( k ) for k in bin ( j ) [ 2 : ] . rjust ( W , <STRING> ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> d = ( ( d . T ) * i_2 ) . T <NEWLINE> d = d * j_2 <NEWLINE> <NL> num = d . sum ( ) <NEWLINE> if num == K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def execute ( N , A ) : <NEWLINE> <INDENT> dst = 0 <NEWLINE> s = sum ( A ) <NEWLINE> for v in A : <NEWLINE> <INDENT> s -= v <NEWLINE> dst += v * s <NEWLINE> <NL> <DEDENT> return dst % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( execute ( N , A ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> if N < B : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - A * math . floor ( N / B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = math . floor ( A * ( B - 1 ) / B ) - A * math . floor ( ( B - 1 ) / B ) <NEWLINE> print ( tmp ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Aset = set ( A ) <NEWLINE> lst = { } <NEWLINE> for i in Aset : <NEWLINE> <INDENT> lst [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> lst [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> c = dict ( lst ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c_all = 0 <NEWLINE> for j in lst : <NEWLINE> <INDENT> c_all += lst [ j ] * ( lst [ j ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in lst : <NEWLINE> <INDENT> c [ i ] = c_all <NEWLINE> c [ i ] = c [ i ] - lst [ i ] * ( lst [ i ] - 1 ) // 2 + ( lst [ i ] - 1 ) * ( lst [ i ] - 2 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ A [ i ] ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> finput = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . ranks = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . ranks [ x ] < self . ranks [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> if self . ranks [ x ] == self . ranks [ y ] : <NEWLINE> <INDENT> self . ranks [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def issametree ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( finput ( ) ) <NEWLINE> coor = [ list ( map ( int , finput ( ) . split ( ) ) ) + [ i ] for i in range ( n ) ] <NEWLINE> coor . sort ( key = lambda e : e [ 0 ] ) <NEWLINE> cost = lambda e , f : min ( abs ( e [ 0 ] - f [ 0 ] ) , abs ( e [ 1 ] - f [ 1 ] ) ) <NEWLINE> ew = dict ( ( ( coor [ i ] [ 2 ] , coor [ i + 1 ] [ 2 ] ) , cost ( coor [ i ] [ : 2 ] , coor [ i + 1 ] [ : 2 ] ) ) for i in range ( n - 1 ) ) <NEWLINE> coor . sort ( key = lambda e : e [ 1 ] ) <NEWLINE> ew . update ( dict ( ( ( coor [ i ] [ 2 ] , coor [ i + 1 ] [ 2 ] ) , cost ( coor [ i ] [ : 2 ] , coor [ i + 1 ] [ : 2 ] ) ) for i in range ( n - 1 ) ) ) <NEWLINE> edges = sorted ( list ( iter ( ew ) ) , key = lambda e : ew [ e ] ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> totcost = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for edge in edges : <NEWLINE> <INDENT> if not v . issametree ( edge [ 0 ] , edge [ 1 ] ) : <NEWLINE> <INDENT> v . union ( edge [ 0 ] , edge [ 1 ] ) <NEWLINE> totcost += ew [ edge ] <NEWLINE> <DEDENT> <DEDENT> print ( totcost ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min ( B - 1 , N ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( ( A * x ) // B - A * ( x // B ) ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> <NL> I = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : <NEWLINE> <INDENT> return int ( I ( ) . strip ( ) ) <NEWLINE> <DEDENT> def li ( ) : <NEWLINE> <INDENT> return list ( map ( int , I ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , I ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> n , k = mi ( ) <NEWLINE> arr = li ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> tmp = arr [ k + i ] <NEWLINE> if tmp > arr [ a ] : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import random <NEWLINE> from decimal import Decimal <NEWLINE> <NL> <NL> N , M , K = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A1 = [ 0 ] <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> x = A1 [ i ] + v <NEWLINE> A1 . append ( x ) <NEWLINE> <DEDENT> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B1 = [ 0 ] <NEWLINE> for i , v in enumerate ( B ) : <NEWLINE> <INDENT> x = B1 [ i ] + v <NEWLINE> B1 . append ( x ) <NEWLINE> <DEDENT> c1 = 0 <NEWLINE> c2 = 0 <NEWLINE> ans = 0 <NEWLINE> temp = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A1 [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B1 [ temp ] > K - A1 [ i ] : <NEWLINE> <INDENT> temp -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + temp ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> i = 0 <NEWLINE> x = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> x = x * a [ i ] <NEWLINE> i += 1 <NEWLINE> if x > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> dp = np . zeros ( [ N + 1 , W + 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ : wv [ i - 1 ] [ 0 ] ] = dp [ i - 1 ] [ : wv [ i - 1 ] [ 0 ] ] <NEWLINE> dp [ i ] [ wv [ i - 1 ] [ 0 ] : ] = np . maximum ( dp [ i - 1 ] [ wv [ i - 1 ] [ 0 ] : ] , dp [ i - 1 ] [ : W + 1 - wv [ i - 1 ] [ 0 ] ] + wv [ i - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> print ( int ( dp [ - 1 , - 1 ] ) ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> k = abs ( A - B ) <NEWLINE> d = V - W <NEWLINE> if d <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k / d ) > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = list ( range ( n ) ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> size = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if uf . parents [ i ] == i : <NEWLINE> <INDENT> size += 1 <NEWLINE> <DEDENT> <DEDENT> print ( size - 1 ) <NEWLINE>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( A ) <NEWLINE> <DEDENT> a = sorted ( a , key = lambda x : x [ 0 ] ) <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] [ 1 ] <NEWLINE> if b >= k : <NEWLINE> <INDENT> print ( a [ i ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def calc ( p1 , p2 , v ) : <NEWLINE> <INDENT> dists_v = dists [ v ] <NEWLINE> if v == n - 1 : <NEWLINE> <INDENT> return dists_v [ p1 ] + dists_v [ p2 ] <NEWLINE> <DEDENT> if visited [ p1 ] [ p2 ] : <NEWLINE> <INDENT> return dp [ p1 ] [ p2 ] <NEWLINE> <DEDENT> dp [ p1 ] [ p2 ] = min ( dists_v [ p1 ] + calc ( p2 , v , v + 1 ) , dists_v [ p2 ] + calc ( p1 , v , v + 1 ) ) <NEWLINE> visited [ p1 ] [ p2 ] = True <NEWLINE> return dp [ p1 ] [ p2 ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> points = [ complex ( * map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> dists = [ [ abs ( p1 - p2 ) for p2 in points ] for p1 in points ] <NEWLINE> visited = [ [ False ] * n for _ in range ( n ) ] <NEWLINE> dp = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> <NL> print ( calc ( 0 , 0 , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> r = c . count ( <STRING> ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_np = np . zeros ( N ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for Ai in A : <NEWLINE> <INDENT> A_np [ Ai - 1 ] = A_np [ Ai - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( A_np [ i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( P [ i ] == 0 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a != 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= P [ i ] <NEWLINE> if ( a > 1000000000000000000 ) : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> return math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> ary = [ ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> ary . append ( gcd ( b , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ary . append ( gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> h = { } <NEWLINE> for a in ary : <NEWLINE> <INDENT> if a not in h : <NEWLINE> <INDENT> h [ a ] = 0 <NEWLINE> <DEDENT> h [ a ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for x in h . keys ( ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> answer += gcd ( x , c ) * h [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> N , M , s = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ui , vi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj [ ui ] . append ( ( vi , ci ) ) <NEWLINE> <NL> <DEDENT> d = [ float ( <STRING> ) ] * N <NEWLINE> d [ s ] = 0 <NEWLINE> pq = [ ( 0 , s ) ] <NEWLINE> fixed = 0 <NEWLINE> <NL> while pq : <NEWLINE> <INDENT> di , v = heappop ( pq ) <NEWLINE> <NL> if di > d [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for u , c in Adj [ v ] : <NEWLINE> <INDENT> if d [ v ] + c < d [ u ] : <NEWLINE> <INDENT> d [ u ] = d [ v ] + c <NEWLINE> heappush ( pq , ( d [ u ] , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> fixed += 1 <NEWLINE> <NL> if fixed == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for di in d : <NEWLINE> <INDENT> print ( di if di != float ( <STRING> ) else <STRING> ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in [ 0 ] * V ] <NEWLINE> for _ in [ 0 ] * E : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . append ( ( t , d ) ) <NEWLINE> <NL> <DEDENT> result = float ( <STRING> ) <NEWLINE> beam_width = 80 <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> q = [ ( 0 , i , { i } ) ] <NEWLINE> for j in range ( V - 1 ) : <NEWLINE> <INDENT> _q = [ ] <NEWLINE> append = _q . append <NEWLINE> for cost , v , visited in q [ : beam_width + 1 ] : <NEWLINE> <INDENT> for dest , d_cost in edges [ v ] : <NEWLINE> <INDENT> if dest not in visited : <NEWLINE> <INDENT> append ( ( cost + d_cost , dest , visited | { dest } ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = sorted ( _q ) <NEWLINE> <DEDENT> for cost , v , visited in q [ : beam_width + 1 ] : <NEWLINE> <INDENT> for dest , d_cost in edges [ v ] : <NEWLINE> <INDENT> if dest == i : <NEWLINE> <INDENT> if result > cost + d_cost : <NEWLINE> <INDENT> result = cost + d_cost <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result if result < float ( <STRING> ) else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> n , a , q , ms = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , input ( ) , map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cache = { } <NEWLINE> <NL> <NL> def sum_a ( tmp , t ) : <NEWLINE> <INDENT> global a , cache <NEWLINE> if t in cache : <NEWLINE> <INDENT> return tmp + cache [ t ] <NEWLINE> <DEDENT> elif len ( t ) == 1 : <NEWLINE> <INDENT> return tmp + a [ t [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cache [ t ] = result = sum_a ( tmp + a [ t [ 0 ] ] , t [ 1 : ] ) <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> l = list ( sum_a ( 0 , t ) for i in range ( n ) for t in combinations ( range ( n ) , i + 1 ) ) <NEWLINE> <NL> for m in ms : <NEWLINE> <INDENT> print ( <STRING> if m in l else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def isleft ( ox , oy , ax , ay , px , py ) : <NEWLINE> <INDENT> oax , oay = ax - ox , ay - oy <NEWLINE> opx , opy = px - ox , py - oy <NEWLINE> if oax * opy > oay * opx : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , line . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if isleft ( x1 , y1 , x2 , y2 , xp , yp ) == isleft ( x2 , y2 , x3 , y3 , xp , yp ) == isleft ( x3 , y3 , x1 , y1 , xp , yp ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> largenum = 10 ** 18 <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> r = 1 <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> r *= a [ i1 ] <NEWLINE> if r > largenum : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l , r = 1 , 10 ** 9 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> t = ( l + r ) // 2 <NEWLINE> k = sum ( [ ( a + t - 2 ) // ( t - 1 ) - 1 for a in A ] ) <NEWLINE> if K < k : <NEWLINE> <INDENT> l = t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = t <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = sum ( arr ) <NEWLINE> mt = [ 0 ] * N <NEWLINE> <NL> for j in range ( N - 1 ) : <NEWLINE> <INDENT> mt [ j + 1 ] = arr [ j ] * 2 - mt [ j ] <NEWLINE> <DEDENT> a = total - sum ( mt ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> mt [ i ] += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mt [ i ] -= a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * mt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i ] > 10 ** 18 : <NEWLINE> <INDENT> a = 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> b = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> s_set = set ( s ) <NEWLINE> <NL> print ( len ( s_set ) ) <NEWLINE>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ngs = np . zeros ( ( 10 ** 6 ) + 1 , dtype = int ) <NEWLINE> <NL> for a in set ( aa ) : <NEWLINE> <INDENT> ngs [ 2 * a : : a ] = 1 <NEWLINE> <NL> <DEDENT> dic = Counter ( aa ) <NEWLINE> times = np . array ( list ( dic . keys ( ) ) ) [ np . array ( list ( dic . values ( ) ) ) > 1 ] <NEWLINE> <NL> for i in times : <NEWLINE> <INDENT> ngs [ i ] = 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for a in aa : <NEWLINE> <INDENT> cnt += 1 - ngs [ a ] <NEWLINE> <DEDENT> print ( ( cnt ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_ = h * 30 + ( m / 60 ) * 30 <NEWLINE> m_ = m * 6 <NEWLINE> alpha = h_ - m_ <NEWLINE> if 0 < alpha < 180 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif alpha == 180 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif alpha == 0 or alpha == 360 : <NEWLINE> <INDENT> print ( abs ( a - b ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alpha = 360 - alpha <NEWLINE> <DEDENT> ans_2 = a ** 2 + b ** 2 - 2 * b * a * math . cos ( math . radians ( alpha ) ) <NEWLINE> print ( ans_2 ** 0.5 ) <NEWLINE>
from copy import deepcopy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> visited = set ( ) <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited . add ( i ) <NEWLINE> cnt += 1 <NEWLINE> i = a [ i ] <NEWLINE> if cnt == k : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> k -= cnt <NEWLINE> period = list ( ) <NEWLINE> period . append ( i ) <NEWLINE> i = a [ i ] <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> if i == period [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> period . append ( i ) <NEWLINE> i = a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> mod = k % len ( period ) <NEWLINE> ans = period [ mod ] <NEWLINE> print ( ans + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> bp = 1 <NEWLINE> for b in range ( 1 , X ) : <NEWLINE> <INDENT> for p in range ( 2 , X ) : <NEWLINE> <INDENT> if b ** p <= X : <NEWLINE> <INDENT> bp = max ( bp , b ** p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( bp ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x = x + a [ i ] <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> y = y + ( a [ i ] ** 2 ) <NEWLINE> <DEDENT> print ( ( ( x ** 2 - y ) // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for x in arr : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> d [ x - 1 ] += 1 <NEWLINE> d [ x + 1 ] += 1 <NEWLINE> <NL> <DEDENT> result = [ y for x , y in d . items ( ) ] <NEWLINE> <NL> print ( max ( result ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> person = [ [ 0 for _ in range ( 10 ) ] for _ in range ( 12 ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( m ) for m in input ( ) . split ( ) ] <NEWLINE> person [ 3 * ( b - 1 ) + f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for index , p in enumerate ( person ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( m ) for m in p ] ) ) <NEWLINE> if ( index + 1 ) % 3 == 0 and index < len ( person ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( i + a [ i ] ) <NEWLINE> r . append ( i - a [ i ] ) <NEWLINE> <NL> <DEDENT> count = collections . Counter ( r ) <NEWLINE> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += count . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acc = list ( accumulate ( A ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( acc [ - 1 ] - acc [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def quick_sort ( list ) : <NEWLINE> <INDENT> stand = list [ 0 ] <NEWLINE> over = [ ] <NEWLINE> same = [ ] <NEWLINE> under = [ ] <NEWLINE> for i in list : <NEWLINE> <INDENT> if ( i > stand ) : <NEWLINE> <INDENT> over . append ( i ) <NEWLINE> <DEDENT> elif ( i < stand ) : <NEWLINE> <INDENT> under . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if ( len ( over ) > 1 ) : <NEWLINE> <INDENT> over = quick_sort ( over ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if ( len ( under ) > 1 ) : <NEWLINE> <INDENT> under = quick_sort ( under ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> return under + same + over <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = quick_sort ( A ) <NEWLINE> ans = 1 <NEWLINE> way = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> way = str ( ans - 1 ) <NEWLINE> if ( len ( way ) >= 19 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> j = N // i <NEWLINE> ans += i * j * ( j + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1000 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> stock = 0 <NEWLINE> if a [ i - 1 ] < a [ i ] : <NEWLINE> <INDENT> stock = ans // a [ i - 1 ] <NEWLINE> <DEDENT> ans += ( a [ i ] - a [ i - 1 ] ) * stock <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B_C = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( Q ) ] <NEWLINE> first_sum = sum ( A ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> change_value = ( B_C [ i ] [ 1 ] - B_C [ i ] [ 0 ] ) * c [ B_C [ i ] [ 0 ] ] <NEWLINE> c [ B_C [ i ] [ 1 ] ] += c [ B_C [ i ] [ 0 ] ] <NEWLINE> c [ B_C [ i ] [ 0 ] ] = 0 <NEWLINE> first_sum += change_value <NEWLINE> print ( first_sum ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> tmp = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a == b and a == c : <NEWLINE> <INDENT> tmp += gcd_list ( [ a , b , c ] ) <NEWLINE> <DEDENT> elif a == b and a != c : <NEWLINE> <INDENT> tmp += gcd_list ( [ a , b , c ] ) * 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif b == c and a != c : <NEWLINE> <INDENT> tmp += gcd_list ( [ a , b , c ] ) * 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif a == c and b != c : <NEWLINE> <INDENT> tmp += gcd_list ( [ a , b , c ] ) * 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp += gcd_list ( [ a , b , c ] ) * 6 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> sum = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if not i in d : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> d [ i ] += 1 <NEWLINE> sum += i <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if not c in d : <NEWLINE> <INDENT> d [ c ] = 0 <NEWLINE> <DEDENT> if not b in d : <NEWLINE> <INDENT> d [ b ] = 0 <NEWLINE> <NL> <DEDENT> sum = sum - ( d [ b ] * b ) <NEWLINE> sum = sum - ( d [ c ] * c ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> sum = sum + ( d [ c ] * c ) <NEWLINE> <COMMENT> <NL> print ( sum ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> d = a . min ( ) <NEWLINE> while True : <NEWLINE> <INDENT> a1 = a % d <NEWLINE> if all ( a1 == 0 ) : <NEWLINE> <INDENT> ans = d <NEWLINE> break <NEWLINE> <DEDENT> d = min ( a1 [ a1 != 0 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , int ( ( n + 1 ) ** 0.5 ) ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if v > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import math <NEWLINE> <NL> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = min ( R [ 0 ] , R [ 1 ] ) <NEWLINE> for j in range ( 2 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , R [ j ] - minv ) <NEWLINE> minv = min ( minv , R [ j ] ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> PI = 3.141592653589793 <NEWLINE> <NL> r = float ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> area = r * r * PI <NEWLINE> periphery = r * 2 * PI <NEWLINE> <NL> print ( <STRING> % ( area , periphery ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] >= A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> <NL> s = sum ( list ( map ( int , str ( N ) ) ) ) <NEWLINE> <NL> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
p = lambda x : print ( x , end = <STRING> ) <NEWLINE> n = input ( ) <NEWLINE> p ( n + <STRING> ) <NEWLINE> n = int ( n ) ; s = n ** .5 <NEWLINE> while n % 2 == 0 and n > 3 : <NEWLINE> <INDENT> p ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> d = 3 <NEWLINE> while s > d and n > d : <NEWLINE> <INDENT> if n % d == 0 : <NEWLINE> <INDENT> p ( d ) <NEWLINE> n //= d <NEWLINE> <DEDENT> else : d += 2 <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
def convert ( S ) : <NEWLINE> <INDENT> cur = 0 <NEWLINE> def parse ( ) : <NEWLINE> <INDENT> nonlocal cur <NEWLINE> if S [ cur ] == <STRING> : <NEWLINE> <INDENT> return ( ) <NEWLINE> <DEDENT> cur += 1 <COMMENT> <NEWLINE> left = parse ( ) <NEWLINE> cur += 2 <COMMENT> <NEWLINE> num = 0 <NEWLINE> while S [ cur ] != <STRING> : <NEWLINE> <INDENT> num = 10 * num + int ( S [ cur ] ) <NEWLINE> cur += 1 <NEWLINE> <DEDENT> cur += 2 <COMMENT> <NEWLINE> right = parse ( ) <NEWLINE> cur += 1 <COMMENT> <NEWLINE> return left , num , right <NEWLINE> <DEDENT> return parse ( ) <NEWLINE> <DEDENT> def dfs ( A , B ) : <NEWLINE> <INDENT> if not A or not B : <NEWLINE> <INDENT> return ( ) <NEWLINE> <DEDENT> return ( dfs ( A [ 0 ] , B [ 0 ] ) , [ A [ 1 ] + B [ 1 ] ] , dfs ( A [ 2 ] , B [ 2 ] ) ) <NEWLINE> <DEDENT> print ( str ( dfs ( convert ( input ( ) ) , convert ( input ( ) ) ) ) . replace ( <STRING> , <STRING> ) [ 1 : - 1 ] ) <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> K = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for i2 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> K [ math . gcd ( i , i2 ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for i2 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += K [ i ] * math . gcd ( i , i2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def isSetwise ( A ) : <NEWLINE> <INDENT> ret = A [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> ret = gcd ( ret , a ) <NEWLINE> <DEDENT> return ret == 1 <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> <NL> def createPrimeList ( N ) : <NEWLINE> <INDENT> isPrime = [ True ] * ( N + 1 ) <NEWLINE> isPrime [ 0 ] = False <NEWLINE> isPrime [ 1 ] = False <NEWLINE> smallestPrime = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if not isPrime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for p in range ( i * 2 , N , i ) : <NEWLINE> <INDENT> if isPrime [ p ] : <NEWLINE> <INDENT> smallestPrime [ p ] = i <NEWLINE> <DEDENT> isPrime [ p ] = False <NEWLINE> <DEDENT> <DEDENT> return smallestPrime <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> smallestPrime = createPrimeList ( max ( A ) + 10 ) <NEWLINE> def primeFactorization ( N ) : <NEWLINE> <INDENT> ret = Counter ( ) <NEWLINE> while N > 1 : <NEWLINE> <INDENT> p = smallestPrime [ N ] <NEWLINE> if p == 1 : <NEWLINE> <INDENT> ret [ N ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> ret [ p ] += 1 <NEWLINE> N //= p <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def isPairwise ( A ) : <NEWLINE> <INDENT> P = Counter ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> for p in primeFactorization ( a ) : <NEWLINE> <INDENT> if P [ p ] >= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> P [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if not isSetwise ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if isPairwise ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> N , K = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> A_list = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> order_dict = dict ( zip ( range ( 1 , N + 1 ) , A_list ) ) <NEWLINE> <NL> foot_print = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> loop_que = collections . deque ( [ 1 ] ) <NEWLINE> <NL> goto = 1 <NEWLINE> <NL> while foot_print [ goto ] == - 1 : <NEWLINE> <INDENT> foot_print [ goto ] = 1 <NEWLINE> goto = order_dict [ goto ] <NEWLINE> loop_que . append ( goto ) <NEWLINE> <NL> <DEDENT> loop_start = loop_que . index ( goto ) + 1 <NEWLINE> loop_len = len ( loop_que ) - loop_start <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> data_list = list ( loop_que ) <NEWLINE> if K >= len ( loop_que ) : <NEWLINE> <INDENT> temp_K = K - loop_start + 1 <NEWLINE> temp_K %= loop_len <NEWLINE> temp_loop = data_list [ loop_start - 1 : - 1 ] <NEWLINE> print ( temp_loop [ temp_K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( data_list [ K ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> preans = [ 0 for _ in range ( N ) ] <NEWLINE> for a in As : <NEWLINE> <INDENT> preans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for n in preans : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ i for i in range ( - 150 , 150 ) ] <NEWLINE> P = list ( set ( Q ) - set ( P ) ) <NEWLINE> P . sort ( ) <NEWLINE> dif = 100 <NEWLINE> for p in P : <NEWLINE> <INDENT> if abs ( X - p ) < dif : <NEWLINE> <INDENT> dif = abs ( X - p ) <NEWLINE> ans = p <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> x = X . count ( <STRING> ) <NEWLINE> x_plus = int ( X , 2 ) % ( x + 1 ) <NEWLINE> keta = n - 1 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> ans = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += x_plus <NEWLINE> tmp += pow ( 2 , keta , ( x + 1 ) ) <NEWLINE> tmp %= ( x + 1 ) <NEWLINE> while tmp : <NEWLINE> <INDENT> tmp = tmp % ( bin ( tmp ) . count ( <STRING> ) ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> keta -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x_minus = int ( X , 2 ) % ( x - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> ans = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += x_plus <NEWLINE> tmp += pow ( 2 , keta , ( x + 1 ) ) <NEWLINE> tmp %= ( x + 1 ) <NEWLINE> while tmp : <NEWLINE> <INDENT> tmp = tmp % ( bin ( tmp ) . count ( <STRING> ) ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += x_minus <NEWLINE> tmp -= pow ( 2 , keta , ( x - 1 ) ) <NEWLINE> tmp %= ( x - 1 ) <NEWLINE> while tmp : <NEWLINE> <INDENT> tmp = tmp % ( bin ( tmp ) . count ( <STRING> ) ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> keta -= 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import bisect <COMMENT> <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( l , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , W = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> weight_array = np . zeros ( W + 1 ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> weight_array [ w : ] = np . maximum ( weight_array [ : - w ] + v , weight_array [ w : ] ) <NEWLINE> <DEDENT> print ( int ( weight_array [ - 1 ] ) ) <NEWLINE>
from sys import stdin <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <NL> N = int ( stdin . readline ( ) . rstrip ( ) . split ( ) [ 0 ] ) <NEWLINE> Sum = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> for k in range ( j , N + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> Sum += i <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> temp_gcd = math . gcd ( i , j ) <NEWLINE> Sum += ( math . gcd ( temp_gcd , k ) * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sum += ( math . gcd ( temp_gcd , k ) * 6 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , a , a ) <NEWLINE> <NL> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> ans += 3 * gcd ( a , a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 6 * gcd ( a , b , c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( f // a // 100 + 1 ) : <NEWLINE> <INDENT> for j in range ( ( f - 100 * a * i ) // b // 100 + 1 ) : <NEWLINE> <INDENT> if a * i * 100 + b * j * 100 < f : <NEWLINE> <INDENT> ans . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ans [ 1 : ] <NEWLINE> D = 0 <NEWLINE> A = [ 0 , 0 ] <NEWLINE> for an in ans : <NEWLINE> <INDENT> m = a * 100 * an [ 0 ] + b * 100 * an [ 1 ] <NEWLINE> slv = e * m // 100 <NEWLINE> M = 0 <NEWLINE> for i in range ( min ( f - m , slv ) // c + 1 ) : <NEWLINE> <INDENT> for j in range ( ( min ( f - m , slv ) - c * i ) // d + 1 ) : <NEWLINE> <INDENT> if i * c + d * j <= min ( slv , f - m ) : <NEWLINE> <INDENT> if M < i * c + d * j : <NEWLINE> <INDENT> M = i * c + d * j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> den = M / ( m + M ) <NEWLINE> if den >= D : <NEWLINE> <INDENT> D = den <NEWLINE> A = [ m + M , M ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( a ) for a in A ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> import math <NEWLINE> <NL> A , B , N = MII_split ( ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( f ( min ( B - 1 , N ) ) ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W = MAP ( ) <NEWLINE> a = [ LIST ( ) for _ in range ( H ) ] <NEWLINE> <NL> op = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 : <NEWLINE> <INDENT> a [ i ] [ j ] -= 1 <NEWLINE> a [ i ] [ j + 1 ] += 1 <NEWLINE> op . append ( ( i + 1 , j + 1 , i + 1 , j + 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ - 1 ] % 2 : <NEWLINE> <INDENT> a [ i ] [ - 1 ] -= 1 <NEWLINE> a [ i + 1 ] [ - 1 ] += 1 <NEWLINE> op . append ( ( i + 1 , W , i + 2 , W ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( op ) ) <NEWLINE> print ( * [ <STRING> . join ( map ( str , x ) ) for x in op ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = n % 60 <NEWLINE> n = n // 60 <NEWLINE> m = n % 60 <NEWLINE> h = n // 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> A = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> CB = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> CB . append ( [ c , b ] ) <NEWLINE> <NL> <DEDENT> CB . sort ( reverse = True ) <NEWLINE> <NL> idx = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] < CB [ idx ] [ 0 ] : <NEWLINE> <INDENT> A [ i ] = CB [ idx ] [ 0 ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> if CB [ idx ] [ 1 ] <= c : <NEWLINE> <INDENT> idx += 1 <NEWLINE> c = 0 <NEWLINE> <DEDENT> if idx >= m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> li2 = [ 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> cnt = 0 <NEWLINE> if k < 170 : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> li . append ( gcd ( gcd ( i , j ) , gcd ( j , l ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( li ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( li2 [ k - 170 ] ) <NEWLINE> <DEDENT>
def check ( x , A , K ) : <NEWLINE> <INDENT> import math <NEWLINE> sumA = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > x : <NEWLINE> <INDENT> sumA += math . ceil ( a / x ) - 1 <NEWLINE> <DEDENT> <DEDENT> if sumA <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> _ , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ok = max ( A ) <COMMENT> <NEWLINE> ng = - 1 <COMMENT> <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if mid > 0 and check ( mid , A , K ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for diff in range ( n ) : <NEWLINE> <INDENT> j = i + diff <NEWLINE> k = i + 2 * diff <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , int ( m ** .5 ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> if m // i >= n : a += [ i ] <NEWLINE> if i >= n : a += [ m // i ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( Ai ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> N = n - 1 <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> if C [ l ] == <STRING> : <NEWLINE> <INDENT> for r in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if r <= l : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if C [ r ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> C [ l ] = <STRING> <NEWLINE> C [ r ] = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans += 1 <NEWLINE> N = r - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lenS = len ( S ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> T . append ( abs ( i - ( N + 1 - i ) ) ) <NEWLINE> <NL> <DEDENT> T . sort ( ) <NEWLINE> S . sort ( ) <NEWLINE> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] != S [ i ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> nagasa = lenS // 2 <NEWLINE> for i in range ( nagasa ) : <NEWLINE> <NL> <INDENT> ans = ( ans * 2 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> import random <NEWLINE> from decimal import Decimal <NEWLINE> import itertools <NEWLINE> import re <NEWLINE> import bisect <NEWLINE> from collections import deque , Counter <NEWLINE> from functools import lru_cache <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 13 <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> def SERIES ( n ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> def GRID ( h , w ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> def GRIDfromString ( h , w ) : return np . frombuffer ( sys . stdin . buffer . read ( ) , <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> A = np . array ( LI ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> count = 0 <NEWLINE> a_max = A [ - 1 ] <NEWLINE> dp = [ 1 ] * a_max <NEWLINE> for a in A : <NEWLINE> <INDENT> point = dp [ a - 1 ] <NEWLINE> if point == 1 : <NEWLINE> <INDENT> dp [ a - 1 ] = 2 <NEWLINE> count += 1 <NEWLINE> for ai in range ( a * 2 , a_max + 1 , a ) : <NEWLINE> <INDENT> dp [ ai - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif point == 2 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> dp [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = 1000 <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> a = np . array ( range ( n ) ) <NEWLINE> ex = np . full ( n , 5 ) <NEWLINE> <NL> m = a * n + a . reshape ( n , 1 ) <NEWLINE> <NL> b = np . power ( a , ex ) <NEWLINE> <NL> plus = b + b . reshape ( n , 1 ) <NEWLINE> minus = b - b . reshape ( n , 1 ) <NEWLINE> <NL> plus = plus == X <NEWLINE> minus = minus == X <NEWLINE> <NL> if np . count_nonzero ( plus ) : <NEWLINE> <INDENT> c = m [ plus ] [ 0 ] <NEWLINE> ans = int ( c / n ) , - int ( c % n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = m [ minus ] [ 0 ] <NEWLINE> ans = int ( c / n ) , int ( c % n ) <NEWLINE> <NL> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = input ( ) [ : : - 1 ] <NEWLINE> dp = [ [ 0 , 0 ] for i in range ( len ( n ) + 1 ) ] <NEWLINE> dp [ 0 ] [ 1 ] = 1 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = min ( dp [ i ] [ 0 ] + int ( n [ i ] ) , dp [ i ] [ 1 ] - int ( n [ i ] ) + 10 ) <NEWLINE> dp [ i + 1 ] [ 1 ] = min ( dp [ i ] [ 0 ] + int ( n [ i ] ) + 1 , dp [ i ] [ 1 ] - int ( n [ i ] ) + 9 ) <NEWLINE> <DEDENT> print ( dp [ len ( n ) ] [ 0 ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c = int ( a ) ; d = int ( b ) <NEWLINE> <NL> if c >= - 1000 and d <= 1000 : <NEWLINE> <INDENT> if c > d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif c < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = 1001 <NEWLINE> x = [ 1 for i in range ( n ) ] <NEWLINE> y = [ 0 for i in range ( n ) ] <NEWLINE> ang = 0 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> ang += math . asin ( 1 / math . sqrt ( i - 1 ) ) <NEWLINE> x [ i ] = x [ i - 1 ] + math . cos ( ang ) <NEWLINE> y [ i ] = y [ i - 1 ] + math . sin ( ang ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( x [ n ] ) <NEWLINE> print ( y [ n ] ) <NEWLINE> <NL> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> man = 1 <NEWLINE> cnt = 0 <NEWLINE> man_list = [ 0 ] * N <NEWLINE> A . sort ( ) <NEWLINE> A += [ 0 ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a != man : <NEWLINE> <INDENT> man_list [ man - 1 ] = cnt <NEWLINE> man = a <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> for l in man_list : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> str_i = str ( i ) <NEWLINE> i_index = S . find ( str_i ) <NEWLINE> if i_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> str_j = str ( j ) <NEWLINE> j_index = S . find ( str_j , i_index + 1 ) <NEWLINE> if j_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> str_k = str ( k ) <NEWLINE> k_index = S . find ( str_k , j_index + 1 ) <NEWLINE> if k_index != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> point = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n - k ) : <NEWLINE> <INDENT> if point [ j ] < point [ j + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , M , A , B , C , T = LI ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = tuple ( LI ( ) ) <NEWLINE> if T == 0 : <NEWLINE> <INDENT> rr . append ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> continue <NEWLINE> <DEDENT> m = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] [ i ] = B <NEWLINE> if i > 0 : <NEWLINE> <INDENT> m [ i ] [ i - 1 ] = A <NEWLINE> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> m [ i ] [ i + 1 ] = C <NEWLINE> <DEDENT> <DEDENT> mod = M <NEWLINE> <NL> class Matrix ( ) : <NEWLINE> <INDENT> def __init__ ( self , A ) : <NEWLINE> <INDENT> self . A = A <NEWLINE> self . row = len ( A ) <NEWLINE> self . col = len ( A [ 0 ] ) <NEWLINE> <NL> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> return self . A . __iter__ ( ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , i ) : <NEWLINE> <INDENT> return self . A . __getitem__ ( i ) <NEWLINE> <NL> <DEDENT> def __add__ ( self , B ) : <NEWLINE> <INDENT> aa = self . A <NEWLINE> bb = B . A <NEWLINE> return Matrix ( [ [ ( aa [ i ] [ j ] + bb [ i ] [ j ] ) for j in range ( self . col ) ] for i in range ( self . row ) ] ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , B ) : <NEWLINE> <INDENT> aa = self . A <NEWLINE> bb = B . A <NEWLINE> return Matrix ( [ [ aa [ i ] [ j ] - bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , B ) : <NEWLINE> <INDENT> bb = [ [ B . A [ j ] [ i ] for j in range ( B . row ) ] for i in range ( B . col ) ] <NEWLINE> return Matrix ( [ [ sum ( [ ak * bk for ak , bk in zip ( ai , bj ) ] ) % mod for bj in bb ] for ai in self . A ] ) <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , x ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def pow ( self , n ) : <NEWLINE> <INDENT> A = self <NEWLINE> r = Matrix ( [ [ 0 if j != i else 1 for j in range ( self . row ) ] for i in range ( self . row ) ] ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> r *= A <NEWLINE> <DEDENT> A *= A <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . A . __str__ ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> m = Matrix ( m ) <NEWLINE> mp = m . pow ( T ) <NEWLINE> r = mp * Matrix ( [ [ a [ i ] ] for i in range ( n ) ] ) <NEWLINE> rr . append ( <STRING> . join ( map ( lambda x : str ( x [ 0 ] ) , r ) ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
import math <NEWLINE> <NL> a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> m = 0 <NEWLINE> if ( n < b ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = math . floor ( a * n / b ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> strs = input ( ) . split ( ) <NEWLINE> <NL> buka_nums = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> buka_nums . append ( 0 ) <NEWLINE> <NL> <DEDENT> zyousi = [ ] <NEWLINE> for s in strs : <NEWLINE> <INDENT> zyousi_n = int ( s ) <NEWLINE> buka_nums [ zyousi_n - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in buka_nums : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> hash = { } <NEWLINE> count = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in hash : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hash [ s ] = 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = list ( ) <NEWLINE> <NL> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> arry = y [ i ] <NEWLINE> x . append ( arry ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i == n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ i ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> ch_point = 1 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == ch_point : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> ans += 1 <NEWLINE> ch_point += 1 <NEWLINE> <DEDENT> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) ; <NEWLINE> <NL> <NL> <DEDENT> print ( factorization ( N ) ) <NEWLINE>
from bisect import bisect_left as bl <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ u - 1 ] . append ( v - 1 ) <NEWLINE> t [ v - 1 ] . append ( u - 1 ) <NEWLINE> <DEDENT> b = [ 0 ] * n <NEWLINE> dp = [ float ( <STRING> ) ] * n <NEWLINE> def f ( c , d ) : <NEWLINE> <INDENT> h = bl ( dp , a [ c ] ) <NEWLINE> g = dp [ h ] <NEWLINE> dp [ h ] = min ( dp [ h ] , a [ c ] ) <NEWLINE> b [ c ] = bl ( dp , float ( <STRING> ) ) <NEWLINE> for i in t [ c ] : <NEWLINE> <INDENT> if i != d : f ( i , c ) <NEWLINE> <DEDENT> dp [ h ] = g <NEWLINE> <DEDENT> f ( 0 , - 1 ) <NEWLINE> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> f = sys . stdin <NEWLINE> <NL> n , m , x = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> h = [ None ] + [ int ( f . readline ( ) ) for _ in range ( n ) ] <NEWLINE> tuple_abt = [ tuple ( map ( int , line . split ( ) ) ) for line in f ] <NEWLINE> <NL> dict_abt = { } <NEWLINE> for ai , bi , ti in tuple_abt : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if ti <= h [ ai ] : <NEWLINE> <INDENT> dict_abt [ ai ] [ bi ] = ti <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> dict_abt [ ai ] = { bi : ti } <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if ti <= h [ bi ] : <NEWLINE> <INDENT> dict_abt [ bi ] [ ai ] = ti <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> dict_abt [ bi ] = { ai : ti } <NEWLINE> <NL> <DEDENT> <DEDENT> class Tree : <NEWLINE> <INDENT> def __init__ ( self , t , h , jump_t = 0 , next_h = 0 ) : <NEWLINE> <INDENT> if jump_t : <NEWLINE> <INDENT> t += jump_t <NEWLINE> h -= jump_t <NEWLINE> if h < 0 : <COMMENT> <NEWLINE> <INDENT> t += - h <NEWLINE> h = 0 <NEWLINE> <DEDENT> if next_h < h : <COMMENT> <NEWLINE> <INDENT> t += h - next_h <NEWLINE> h = next_h <NEWLINE> <DEDENT> <DEDENT> self . t = t <NEWLINE> self . h = h <NEWLINE> self . d = t - h <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ None ] * ( n + 1 ) <NEWLINE> d [ 1 ] = Tree ( 0 , x ) <NEWLINE> q = [ ( d [ 1 ] . d , 1 ) ] <COMMENT> <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> _ , u = heapq . heappop ( q ) <COMMENT> <NEWLINE> if u not in dict_abt : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v , t in dict_abt [ u ] . items ( ) : <NEWLINE> <INDENT> dv = Tree ( d [ u ] . t , d [ u ] . h , t , h [ v ] ) <NEWLINE> if d [ v ] == None or d [ v ] . d > dv . d : <NEWLINE> <INDENT> d [ v ] = dv <NEWLINE> heapq . heappush ( q , ( d [ v ] . d , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if d [ - 1 ] : <NEWLINE> <INDENT> print ( d [ - 1 ] . t + h [ - 1 ] - d [ - 1 ] . h ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = np . zeros ( shape = ( n ) , dtype = np . int ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> ini = lambda : int ( input ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gcd = lambda x , y : gcd ( y , x % y ) if x % y else y <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <NL> n = ini ( ) <NEWLINE> a = inl ( ) <NEWLINE> b = a [ : : ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> a [ i ] += a [ i + 1 ] % mod <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i + 1 ] * b [ i ] <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
building = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = input ( ) . split ( <STRING> ) <NEWLINE> building [ int ( b ) - 1 ] [ int ( f ) - 1 ] [ int ( r ) - 1 ] += int ( v ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i , b in enumerate ( building ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> % ( r ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> X_int = int ( X , 2 ) <NEWLINE> cnt1 = bin ( X_int ) . count ( <STRING> ) <NEWLINE> pcXi01 = cnt1 + 1 <NEWLINE> pcXi10 = cnt1 - 1 <NEWLINE> zero_idx = N + 5 <NEWLINE> if cnt1 == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> zero_idx = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if pcXi10 < 1 : <NEWLINE> <INDENT> pcXi10 = 1 <NEWLINE> <DEDENT> Xmod01 = X_int % pcXi01 <NEWLINE> Xmod10 = X_int % pcXi10 <NEWLINE> <NL> tmp01 = [ 1 ] <NEWLINE> tmp10 = [ - 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp01 . append ( tmp01 [ i ] * 2 % pcXi01 ) <NEWLINE> tmp10 . append ( tmp10 [ i ] * 2 % pcXi10 ) <NEWLINE> <NL> <DEDENT> init_n = [ 0 ] * N <NEWLINE> next_n = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> next_n [ i ] = ( Xmod01 + tmp01 [ N - 1 - i ] ) % pcXi01 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_n [ i ] = ( Xmod10 + tmp10 [ N - 1 - i ] ) % pcXi10 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> fn = 0 <NEWLINE> if i == zero_idx : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> n = next_n [ i ] <NEWLINE> fn += 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = n % bin ( n ) . count ( <STRING> ) <NEWLINE> fn += 1 <NEWLINE> <NL> <DEDENT> print ( fn ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += N // a <NEWLINE> if N % a == 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , r * 2 * math . pi ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> <NL> s = input ( ) . strip ( ) <NEWLINE> for c in s : <NEWLINE> <INDENT> if c . islower ( ) : <NEWLINE> <INDENT> print ( c . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> elif c . isupper ( ) : <NEWLINE> <INDENT> print ( c . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 2 == 0 or n % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> p = 7 % n <NEWLINE> while ( p != 0 ) : <NEWLINE> <INDENT> p = ( p * 10 + 7 ) % n <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> br = [ 0 for i in range ( a ) ] <NEWLINE> for r in ar : <NEWLINE> <INDENT> br [ r - 1 ] += 1 <NEWLINE> <DEDENT> for r in br : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
def iput ( ) : return int ( input ( ) ) <NEWLINE> def mput ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = iput ( ) <NEWLINE> a = lput ( ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def mark ( s , x ) : <NEWLINE> <INDENT> for i in range ( x + x , len ( s ) , x ) : <NEWLINE> <INDENT> s [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> def sieve ( n ) : <NEWLINE> <INDENT> s = [ True ] * n <NEWLINE> for x in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if s [ x ] : mark ( s , x ) <NEWLINE> <DEDENT> return [ i for i in range ( 0 , n ) if s [ i ] and i > 1 ] <NEWLINE> <NL> <DEDENT> n = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n . append ( tmp ) <NEWLINE> <DEDENT> m = max ( n ) <NEWLINE> p = sieve ( 500000 ) <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> if n [ i ] == 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( n [ i ] ) : <NEWLINE> <INDENT> sum += p [ j ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = sorted ( ( int ( x ) for x in input ( ) . split ( ) ) , key = abs ) <NEWLINE> sgn = [ 0 if x == 0 else x // abs ( x ) for x in a ] <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> def modmul ( x , y ) : <NEWLINE> <INDENT> return x * y % M <NEWLINE> <DEDENT> if reduce ( mul , sgn [ - k : ] ) >= 0 : <NEWLINE> <INDENT> print ( reduce ( modmul , a [ - k : ] , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest_unselected_neg = next ( i for i , x in enumerate ( reversed ( a [ : - k ] ) ) if x < 0 ) if any ( x < 0 for x in a [ : - k ] ) else None <NEWLINE> largest_unselected_pos = next ( i for i , x in enumerate ( reversed ( a [ : - k ] ) ) if x > 0 ) if any ( x > 0 for x in a [ : - k ] ) else None <NEWLINE> smallest_selected_neg = next ( i for i , x in enumerate ( a [ - k : ] ) if x < 0 ) if any ( x < 0 for x in a [ - k : ] ) else None <NEWLINE> smallest_selected_pos = next ( i for i , x in enumerate ( a [ - k : ] ) if x > 0 ) if any ( x > 0 for x in a [ - k : ] ) else None <NEWLINE> can1 = largest_unselected_neg is not None and smallest_selected_pos is not None <NEWLINE> can2 = largest_unselected_pos is not None and smallest_selected_neg is not None <NEWLINE> def ans1 ( ) : <NEWLINE> <INDENT> return list ( reversed ( a [ : - k ] ) ) [ largest_unselected_neg ] * reduce ( modmul , ( x for i , x in enumerate ( a [ - k : ] ) if i != smallest_selected_pos ) , 1 ) % M <NEWLINE> <DEDENT> def ans2 ( ) : <NEWLINE> <INDENT> return list ( reversed ( a [ : - k ] ) ) [ largest_unselected_pos ] * reduce ( modmul , ( x for i , x in enumerate ( a [ - k : ] ) if i != smallest_selected_neg ) , 1 ) % M <NEWLINE> <DEDENT> if can1 and not can2 : <NEWLINE> <INDENT> print ( ans1 ( ) ) <NEWLINE> <DEDENT> elif can2 and not can1 : <NEWLINE> <INDENT> print ( ans2 ( ) ) <NEWLINE> <DEDENT> elif can1 and can2 : <NEWLINE> <INDENT> if list ( reversed ( a [ : - k ] ) ) [ largest_unselected_neg ] * a [ - k : ] [ smallest_selected_neg ] > list ( reversed ( a [ : - k ] ) ) [ largest_unselected_pos ] * a [ - k : ] [ smallest_selected_pos ] : <NEWLINE> <INDENT> print ( ans1 ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans2 ( ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( reduce ( modmul , a [ : k ] , 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> s = 0 <NEWLINE> for num in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( s , N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == num : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s += count <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> total = 0 <NEWLINE> for i in AList : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> total += i <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> bNum = dp [ B ] <NEWLINE> dp [ B ] = 0 <NEWLINE> dp [ C ] += bNum <NEWLINE> cNum = dp [ C ] <NEWLINE> total = total - B * bNum + C * bNum <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> key = int ( math . sqrt ( N ) ) <NEWLINE> <NL> ans = 10 ** 12 <NEWLINE> for i in reversed ( range ( 1 , key + 1 ) ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = i - 1 + N // i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> left = 0 <NEWLINE> right = max ( a ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> <NL> if mid == 0 : <NEWLINE> <INDENT> cnt = 10 ** 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for _a in a : <NEWLINE> <INDENT> cnt += math . ceil ( _a / mid - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt > k : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> if right - left <= 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
def factorint ( n ) : <NEWLINE> <INDENT> d = dict ( ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> n /= i <NEWLINE> <DEDENT> d [ i ] = c <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> d [ n ] = 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i , j in factorint ( n ) . items ( ) : <NEWLINE> <INDENT> for k in range ( j ) : <NEWLINE> <INDENT> if n % i ** ( k + 1 ) == 0 : <NEWLINE> <INDENT> n = n / i ** ( k + 1 ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
mod = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> ans += ( sum ( a ) * sum ( a ) ) % mod <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans -= ( a [ i ] * a [ i ] ) % mod <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> <DEDENT> ans *= ( mod + 1 ) // 2 <NEWLINE> ans %= mod <NEWLINE> print ( int ( ans ) ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> K = math . floor ( N / i ) <NEWLINE> ans += ( K * ( K + 1 ) * i ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> total = 1 <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> total *= i <NEWLINE> if total > 1000000000000000000 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in l : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> mods = [ 0 ] * ( len ( s ) ) <NEWLINE> countRemainder = [ 0 ] * 2019 <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> m = 1 <NEWLINE> mod = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> mod += int ( s [ len ( s ) - i - 1 ] ) * m <NEWLINE> <NL> mod %= 2019 <NEWLINE> m *= 10 <NEWLINE> m %= 2019 <NEWLINE> <NL> countRemainder [ mod ] += 1 <NEWLINE> <NL> <DEDENT> countRemainder [ 0 ] += 1 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> cnt += int ( countRemainder [ i ] * ( countRemainder [ i ] - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K <= N : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s = A [ s - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> S = { 1 } <NEWLINE> iloop = 1 <NEWLINE> while A [ s - 1 ] not in S : <NEWLINE> <INDENT> S . add ( A [ s - 1 ] ) <NEWLINE> s = A [ s - 1 ] <NEWLINE> iloop = iloop + 1 <NEWLINE> <DEDENT> p = s <NEWLINE> loop = 1 <NEWLINE> while A [ s - 1 ] != p : <NEWLINE> <INDENT> loop = loop + 1 <NEWLINE> s = A [ s - 1 ] <NEWLINE> <DEDENT> g = ( K - iloop ) % loop + iloop <NEWLINE> s = 1 <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> s = A [ s - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> inf = 1000000001 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( A , 0 , len ( A ) ) <NEWLINE> print ( * A ) <NEWLINE> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> s = input ( ) <NEWLINE> a = [ 0 ] <NEWLINE> mod = 2019 <NEWLINE> <NL> for i , j in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> a . append ( a [ - 1 ] + int ( j ) * pow ( 10 , i , mod ) ) <NEWLINE> a [ - 1 ] %= mod <NEWLINE> <DEDENT> b = Counter ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in b . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> M = i * ( 2 * N - i + 1 ) // 2 <NEWLINE> m = i * ( i - 1 ) // 2 <NEWLINE> ans += ( M - m + 1 ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N = input ( ) <NEWLINE> s = [ char for char in N ] <NEWLINE> sum_ = 0 <NEWLINE> for char in s : <NEWLINE> <INDENT> sum_ += int ( char ) <NEWLINE> <DEDENT> if sum_ % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> mod = 9 * K <NEWLINE> n = 1 <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> mod = mod // 7 <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> n = n * 10 % mod <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( x , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( a ) <NEWLINE> sum_res = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_res += ( c - b ) * counter [ b ] <NEWLINE> <NL> counter [ c ] += counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> print ( sum_res ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . zeros ( n ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> temp = input ( ) <NEWLINE> <NL> for j in range ( int ( d ) ) : <NEWLINE> <INDENT> a [ int ( temp . split ( <STRING> ) [ j ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c_al = Counter ( al ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for k , v in c_al . items ( ) : <NEWLINE> <INDENT> if v != 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow ( 2 , n // 2 , 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> elif n % 2 != 0 : <NEWLINE> <INDENT> for k , v in c_al . items ( ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> if v != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif v != 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow ( 2 , n // 2 , 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
def search ( x , y ) : <NEWLINE> <INDENT> x_length = len ( x ) <NEWLINE> y_length = len ( y ) <NEWLINE> memo = [ [ 0 ] * ( y_length + 1 ) for i in range ( x_length + 1 ) ] <NEWLINE> for i , ch_x in enumerate ( x , 1 ) : <NEWLINE> <INDENT> row = memo [ i ] <NEWLINE> pre_row = memo [ i - 1 ] <NEWLINE> for j , ch_y in enumerate ( y , 1 ) : <NEWLINE> <INDENT> if ch_x == ch_y : <NEWLINE> <INDENT> row [ j ] = pre_row [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif pre_row [ j ] < row [ j - 1 ] : <NEWLINE> <INDENT> row [ j ] = row [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ j ] = pre_row [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return memo [ - 1 ] [ - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( search ( X , Y ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( n - m ) > 1 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> def fact ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= ( i + 1 ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = ( fact ( n ) * fact ( m ) ) % mod <NEWLINE> if n == m : print ( ( 2 * ans ) % mod ) <NEWLINE> else : print ( ans ) <NEWLINE> <DEDENT>
def selection_sort ( A ) : <NEWLINE> <INDENT> steps = 0 <NEWLINE> N = len ( A ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if A [ minj ] [ 0 ] > A [ j ] [ 0 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if i != minj : <NEWLINE> <INDENT> steps += 1 <NEWLINE> <DEDENT> A [ minj ] , A [ i ] = A [ i ] , A [ minj ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def bubbleSort ( A ) : <NEWLINE> <INDENT> steps = 0 <NEWLINE> flag = 1 <NEWLINE> completed_idx = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( len ( A ) - 1 , completed_idx , - 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] [ 0 ] > A [ i ] [ 0 ] : <NEWLINE> <INDENT> A [ i - 1 ] , A [ i ] = A [ i ] , A [ i - 1 ] <NEWLINE> steps += 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> completed_idx += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return A <NEWLINE> <NL> <DEDENT> d = dict ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ( int ( elem [ 1 : ] ) , elem [ 0 ] ) for elem in input ( ) . split ( ) ] <NEWLINE> <NL> for elem in A : <NEWLINE> <INDENT> if elem [ 0 ] not in d : <NEWLINE> <INDENT> d [ elem [ 0 ] ] = elem [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ elem [ 0 ] ] += elem [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> is_stable = True <NEWLINE> A_bubble = bubbleSort ( A [ : ] ) <NEWLINE> st = A_bubble [ 0 ] [ 1 ] <NEWLINE> cur_val = A_bubble [ 1 ] [ 0 ] <NEWLINE> prev_val = A_bubble [ 0 ] [ 0 ] <NEWLINE> for e in A_bubble [ 1 : ] : <NEWLINE> <INDENT> cur_val = e [ 0 ] <NEWLINE> if cur_val != prev_val : <NEWLINE> <INDENT> if st != d [ prev_val ] : <NEWLINE> <INDENT> is_stable = False <NEWLINE> break <NEWLINE> <DEDENT> st = <STRING> <NEWLINE> <DEDENT> st += e [ 1 ] <NEWLINE> prev_val = cur_val <NEWLINE> <DEDENT> [ print ( A_bubble [ idx ] [ 1 ] + str ( A_bubble [ idx ] [ 0 ] ) , end = <STRING> ) if idx != len ( A_bubble ) - 1 else print ( A_bubble [ idx ] [ 1 ] + str ( A_bubble [ idx ] [ 0 ] ) ) for idx in range ( len ( A_bubble ) ) ] <NEWLINE> print ( <STRING> if is_stable else <STRING> ) <NEWLINE> <NL> is_stable = True <NEWLINE> A_slt = selection_sort ( A [ : ] ) <NEWLINE> st = A_slt [ 0 ] [ 1 ] <NEWLINE> cur_val = A_slt [ 1 ] [ 0 ] <NEWLINE> prev_val = A_slt [ 0 ] [ 0 ] <NEWLINE> for e in A_slt [ 1 : ] : <NEWLINE> <INDENT> cur_val = e [ 0 ] <NEWLINE> if cur_val != prev_val : <NEWLINE> <INDENT> if st != d [ prev_val ] : <NEWLINE> <INDENT> is_stable = False <NEWLINE> break <NEWLINE> <DEDENT> st = <STRING> <NEWLINE> <DEDENT> st += e [ 1 ] <NEWLINE> prev_val = cur_val <NEWLINE> <NL> <DEDENT> [ print ( A_slt [ idx ] [ 1 ] + str ( A_slt [ idx ] [ 0 ] ) , end = <STRING> ) if idx != len ( A_slt ) - 1 else print ( A_slt [ idx ] [ 1 ] + str ( A_slt [ idx ] [ 0 ] ) ) for idx in range ( len ( A_slt ) ) ] <NEWLINE> print ( <STRING> if is_stable else <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
from statistics import median <NEWLINE> n = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a * 2 ) <NEWLINE> B . append ( b * 2 ) <NEWLINE> <DEDENT> ma , mb = int ( median ( A ) ) , int ( median ( B ) ) <NEWLINE> <COMMENT> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( mb - ma + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( mb - ma ) // 2 + 1 ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <NL> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( 0 , b - k + a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( line ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <INDENT> print ( c [ k ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
i = 0 <NEWLINE> a = list ( ) <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> print ( <STRING> % ( i , a ) ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> B = deque ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = str ( A [ i ] ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> B . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = str ( A [ i ] ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> B . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( B ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) . strip ( ) <NEWLINE> x = remain = 0 <NEWLINE> remains = [ 0 ] * 2019 <NEWLINE> k = 1 <NEWLINE> for d in map ( int , list ( s [ : : - 1 ] ) ) : <NEWLINE> <INDENT> x = d * k + remain <NEWLINE> remain = x % 2019 <NEWLINE> k = ( 10 * k ) % 2019 <NEWLINE> remains [ remain ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ ( remain * ( remain - 1 ) ) // 2 for remain in remains ] ) + remains [ 0 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ input ( ) for _ in [ 0 ] * N ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> b = a . split ( <STRING> ) <NEWLINE> if len ( b ) == 1 : <NEWLINE> <INDENT> A [ i ] = int ( a ) * 10 ** 9 <NEWLINE> continue <NEWLINE> <DEDENT> c = b [ 1 ] <NEWLINE> n = len ( c ) <NEWLINE> c += <STRING> * ( 9 - n ) <NEWLINE> A [ i ] = int ( b [ 0 ] + c ) <NEWLINE> <NL> <DEDENT> cnt = [ [ 0 ] * 40 for _ in [ 0 ] * 40 ] <NEWLINE> B = [ ( 0 , 0 ) ] * N <NEWLINE> for k , a in enumerate ( A ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> a //= 2 <NEWLINE> i += 1 <NEWLINE> <DEDENT> while a % 5 == 0 : <NEWLINE> <INDENT> a //= 5 <NEWLINE> j += 1 <NEWLINE> <DEDENT> B [ k ] = ( i , j ) <NEWLINE> cnt [ i ] [ j ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 40 ) : <NEWLINE> <INDENT> i = 39 - i <NEWLINE> for j in range ( 40 ) : <NEWLINE> <INDENT> j = 39 - j <NEWLINE> cnt [ i ] [ j ] += cnt [ i + 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> i = 39 - i <NEWLINE> for j in range ( 1 , 40 ) : <NEWLINE> <INDENT> j = 39 - j <NEWLINE> cnt [ i ] [ j ] += cnt [ i ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j in B : <NEWLINE> <INDENT> me = int ( i >= 9 and j >= 9 ) <NEWLINE> ans += cnt [ max ( 0 , 18 - i ) ] [ max ( 0 , 18 - j ) ] - me <NEWLINE> <NL> <DEDENT> print ( ans // 2 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % k == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d1 , d2 = a [ : n - k ] , a [ k : n ] <NEWLINE> dd = list ( map ( lambda x , y : <STRING> if y > x else <STRING> , d1 , d2 ) ) <NEWLINE> for i in range ( len ( dd ) ) : print ( dd [ i ] ) <NEWLINE>
def solve ( L ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> s = [ 0 ] * m <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if L [ k ] == 1 : <NEWLINE> <INDENT> cost += A [ k ] [ 0 ] <NEWLINE> for l in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> s [ l - 1 ] += A [ k ] [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( s [ i ] >= x for i in range ( m ) ) : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> L = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) != 0 : <NEWLINE> <INDENT> L [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , solve ( L ) ) <NEWLINE> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dis_list = [ ] <NEWLINE> my_count = Counter ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> my_count [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> my_count [ a ] += 1 <NEWLINE> my_count [ b ] += 1 <NEWLINE> <DEDENT> my_count = sorted ( my_count . items ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( my_count [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> E = [ deque ( ) for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> par = [ - 1 ] * N <NEWLINE> q = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> c = 0 <NEWLINE> while q : <NEWLINE> <INDENT> v , p = q . popleft ( ) <NEWLINE> <NL> if par [ v ] != - 1 : continue <NEWLINE> par [ v ] = p + 1 <NEWLINE> c += 1 <NEWLINE> <NL> for u in E [ v ] : <NEWLINE> <INDENT> if par [ u ] != - 1 : continue <NEWLINE> q . append ( ( u , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if c < N : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , par [ 1 : ] ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> A = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = int ( S [ - 1 - i ] ) <NEWLINE> A . append ( ( A [ - 1 ] + ( s * pow ( 10 , i , 2019 ) ) ) % 2019 ) <NEWLINE> <DEDENT> d = { } <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if not A [ i ] in d : <NEWLINE> <INDENT> d [ A [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in d . keys ( ) : <NEWLINE> <INDENT> ans += d [ k ] * ( d [ k ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> original = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> trial_num = int ( input ( ) ) <NEWLINE> <NL> total = sum ( original ) <NEWLINE> <COMMENT> <NL> count_dict = collections . Counter ( original ) <NEWLINE> <NL> for i in range ( trial_num ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total += ( c - b ) * count_dict [ b ] <NEWLINE> print ( total ) <NEWLINE> <NL> if c in count_dict . keys ( ) : <NEWLINE> <INDENT> count_dict [ c ] += count_dict [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_dict [ c ] = count_dict [ b ] <NEWLINE> <DEDENT> count_dict [ b ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> roop = [ 1 ] <NEWLINE> stayed = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> next_city = l [ roop [ - 1 ] - 1 ] <NEWLINE> if stayed [ next_city - 1 ] : <NEWLINE> <INDENT> endindex = i <NEWLINE> for j , r in enumerate ( roop ) : <NEWLINE> <INDENT> if r == next_city : <NEWLINE> <INDENT> startindex = j <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( next_city ) <NEWLINE> stayed [ next_city - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if k < startindex : <NEWLINE> <INDENT> print ( roop [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dis = endindex - startindex + 1 <NEWLINE> a = ( k - startindex ) % dis <NEWLINE> print ( roop [ a + startindex ] ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> L = [ 0 ] * n <NEWLINE> R = [ 0 ] * n <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> L [ i ] = i + ai <NEWLINE> R [ i ] = i - ai <NEWLINE> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> c = Counter ( R ) <NEWLINE> for Li in L : <NEWLINE> <INDENT> count += c . get ( Li , 0 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> flg = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num [ i ] == 0 : <NEWLINE> <INDENT> flg = 1 ; <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if flg == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> ans = num [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= num [ i ] <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 and flg == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans <= 10 ** 18 and flg == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> arr . sort ( ) <NEWLINE> if x in arr : <NEWLINE> <INDENT> i = arr . index ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> if not i and i != 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> j = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> row = i - j <NEWLINE> high = i + j <NEWLINE> if x - j not in arr : <NEWLINE> <INDENT> print ( x - j ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif x + j not in arr : <NEWLINE> <INDENT> print ( x + j ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> print ( x - 1 ) <NEWLINE>
import math <NEWLINE> <NL> input1 = input ( ) . split ( ) <NEWLINE> A = int ( input1 [ 0 ] ) <NEWLINE> B = int ( input1 [ 1 ] ) <NEWLINE> N = int ( input1 [ 2 ] ) <NEWLINE> <NL> x = 0 <NEWLINE> result = 0 <NEWLINE> if N >= B - 1 : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> result = ( A * ( x % B ) - ( A * x ) % B ) / B <NEWLINE> <DEDENT> elif N < B - 1 : <NEWLINE> <INDENT> x = N <NEWLINE> result = ( A * ( x % B ) - ( A * x ) % B ) / B <NEWLINE> <NL> <DEDENT> print ( int ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ 0 ] + A + [ 0 ] <NEWLINE> dist = [ 0 ] * ( N + 1 ) <NEWLINE> S = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> S += abs ( A [ i ] - A [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dist [ i ] = S + abs ( A [ i - 1 ] - A [ i + 1 ] ) - ( abs ( A [ i - 1 ] - A [ i ] ) + abs ( A [ i ] - A [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( dist [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> ans = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> t [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ans -= b * t [ b ] <NEWLINE> ans += c * t [ b ] <NEWLINE> t [ c ] += t [ b ] <NEWLINE> t [ b ] = 0 <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> temp = N // i <NEWLINE> ans += i * temp * ( temp + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def comb ( n , k , mod ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n - k < k : <NEWLINE> <INDENT> k = n - k <NEWLINE> <DEDENT> c = 1 <NEWLINE> for x in range ( n - k + 1 , n + 1 ) : <NEWLINE> <INDENT> c = ( c * x ) % mod <NEWLINE> <DEDENT> d = 1 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d = ( d * x ) % mod <NEWLINE> <DEDENT> c = c * pow ( d , mod - 2 , mod ) <NEWLINE> return c % mod <NEWLINE> <DEDENT> def f ( i , j ) : <NEWLINE> <INDENT> return comb ( i + j , i , mod ) <NEWLINE> <DEDENT> ans = f ( r2 + 1 , c2 + 1 ) - f ( r2 + 1 , c1 ) - f ( r1 , c2 + 1 ) + f ( r1 , c1 ) <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
n , m , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> b = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( m ) ] <NEWLINE> c = [ [ 0 for j in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> value = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> value = value + a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> c [ i ] [ j ] = value <NEWLINE> <NL> <DEDENT> <DEDENT> for i in c : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> CurrentMoney = 1000 <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> Stocks = 0 <NEWLINE> if A [ i ] < A [ i + 1 ] : Stocks = CurrentMoney // A [ i ] <NEWLINE> CurrentMoney += ( A [ i + 1 ] - A [ i ] ) * Stocks <NEWLINE> <NL> <DEDENT> print ( CurrentMoney ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> height = input ( ) <NEWLINE> height = height . split ( ) <NEWLINE> height = [ int ( s ) for s in height ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> <NL> d = dict ( collections . Counter ( [ i + height [ i ] for i in range ( N ) ] ) ) <NEWLINE> ans = sum ( [ d . get ( i - height [ i ] , 0 ) for i in range ( N ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if S <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> d = [ [ 0 for i in range ( S + 1 ) ] for j in range ( S + 1 ) ] <NEWLINE> d [ 3 ] [ 1 ] = 1 <NEWLINE> for j in range ( S - 3 ) : <NEWLINE> <INDENT> for i in range ( S ) : <NEWLINE> <INDENT> d [ j + 4 ] [ i + 1 ] = ( d [ j + 3 ] [ i + 1 ] + d [ j + 1 ] [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( sum ( d [ S ] ) % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> S . sort ( ) <NEWLINE> <NL> dup = 0 ; <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> if S [ i ] == S [ i - 1 ] : <NEWLINE> <INDENT> dup += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - dup ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> class MaxPrice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . min_price = math . inf <NEWLINE> self . max_price = - math . inf <NEWLINE> self . max_diff = - math . inf <NEWLINE> <NL> <DEDENT> def set_price ( self , p ) : <NEWLINE> <INDENT> if self . max_price < p : <NEWLINE> <INDENT> self . max_price = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . max_diff < p - self . max_price : <NEWLINE> <INDENT> self . max_diff = p - self . max_price <NEWLINE> <NL> <DEDENT> <DEDENT> if p < self . min_price : <NEWLINE> <INDENT> self . min_price = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . max_diff < p - self . min_price : <NEWLINE> <INDENT> self . max_diff = p - self . min_price <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mp = MaxPrice ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> mp . set_price ( p ) <NEWLINE> <DEDENT> print ( mp . max_diff ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ [ ] for _ in range ( 10 ) ] <NEWLINE> <NL> while n : <NEWLINE> <INDENT> c , g = map ( int , input ( ) . split ( ) ) <NEWLINE> books [ g - 1 ] . append ( c ) <NEWLINE> n -= 1 <NEWLINE> <NL> <DEDENT> books_acc = [ [ 0 ] + list ( accumulate ( c + i * 2 for i , c in enumerate ( sorted ( q , reverse = True ) ) ) ) for q in books ] <NEWLINE> <NL> <NL> def memoize ( f ) : <NEWLINE> <INDENT> memo = [ [ - 1 ] * ( k + 1 ) for _ in range ( 10 ) ] <NEWLINE> <NL> def main ( x , y ) : <NEWLINE> <INDENT> if x > 9 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> result = memo [ x ] [ y ] <NEWLINE> if result < 0 : <NEWLINE> <INDENT> result = memo [ x ] [ y ] = f ( x , y ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> return main <NEWLINE> <NL> <NL> <DEDENT> @ memoize <NEWLINE> def combi ( g , remain ) : <NEWLINE> <INDENT> book_acc = list ( books_acc [ g ] ) <NEWLINE> salable = min ( remain + 1 , len ( book_acc ) ) <NEWLINE> return max ( [ book_acc [ i ] + combi ( g + 1 , remain - i ) for i in range ( salable ) ] , default = 0 ) <NEWLINE> <NL> <NL> <DEDENT> print ( combi ( 0 , k ) ) <NEWLINE>
<NL> from math import gcd <NEWLINE> def lcm ( i , j ) : <NEWLINE> <INDENT> return i * j // gcd ( i , j ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> lst = [ [ ] ] <NEWLINE> weight = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> def setWeight ( n ) : <NEWLINE> <INDENT> p , q , r , b = lst [ n ] <NEWLINE> if weight [ n ] != - 1 : pass <NEWLINE> elif r == 0 and b == 0 : <NEWLINE> <INDENT> weight [ n ] = ( p + q ) // gcd ( p , q ) <NEWLINE> <DEDENT> elif r == 0 : <NEWLINE> <INDENT> setWeight ( b ) <NEWLINE> l = lcm ( weight [ b ] * q , p ) <NEWLINE> weight [ n ] = l // q + l // p <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> setWeight ( r ) <NEWLINE> l = lcm ( weight [ r ] * p , q ) <NEWLINE> weight [ n ] = l // p + l // q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if weight [ r ] == - 1 : setWeight ( r ) <NEWLINE> if weight [ b ] == - 1 : setWeight ( b ) <NEWLINE> l = lcm ( weight [ r ] * p , weight [ b ] * q ) <NEWLINE> weight [ n ] = l // p + l // q <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if weight [ i + 1 ] == - 1 : <NEWLINE> <INDENT> setWeight ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( weight ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = min ( [ N , B - 1 ] ) <NEWLINE> print ( ( A * t // B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> cnt [ elem ] += 1 <NEWLINE> <NL> <DEDENT> unique = [ ] <NEWLINE> for i in range ( 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> unique . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> a = list ( set ( a ) ) <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> for m in range ( elem * 2 , 10 ** 6 + 1 , elem ) : <NEWLINE> <INDENT> cnt [ m ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for elem in unique : <NEWLINE> <INDENT> if cnt [ elem ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> ans = <STRING> <NEWLINE> list_1 = [ ] <NEWLINE> list_n = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ab [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> list_1 . append ( ab [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif ab [ i ] [ 1 ] == n : <NEWLINE> <INDENT> list_n . append ( ab [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( list_1 ) & set ( list_n ) ) > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( D [ math . ceil ( ( N ) / 2 ) ] - D [ math . ceil ( ( N ) / 2 ) - 1 ] ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * ( 4 * 10 ** 4 ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> li = [ ans [ i - j [ 0 ] ] + j [ 1 ] for j in ab ] <NEWLINE> ans [ i ] = min ( li ) <NEWLINE> <DEDENT> print ( ans [ h ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> limit = pow ( 10 , 18 ) <NEWLINE> <NL> nums = list ( input ( ) . split ( ) ) <NEWLINE> <NL> for num in nums : <NEWLINE> <INDENT> num = int ( num ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> accum = 1 <NEWLINE> for num in nums : <NEWLINE> <INDENT> num = int ( num ) <NEWLINE> try : <NEWLINE> <INDENT> accum *= num <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> accum = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if accum > limit : <NEWLINE> <INDENT> accum = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( accum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> SUM = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> SUM += A [ i ] <NEWLINE> <DEDENT> SUM = SUM * SUM <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> SUM -= A [ i ] * A [ i ] <NEWLINE> <DEDENT> SUM = SUM // 2 <NEWLINE> SUM %= MOD <NEWLINE> print ( SUM ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> ans = [ [ 0 for _ in range ( l ) ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ i ] [ j ] + a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ans_row in ans : <NEWLINE> <INDENT> print ( * ans_row ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = [ ] <NEWLINE> for _ in range ( n ) : c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> dic [ ( c [ i ] [ 0 ] - c [ j ] [ 0 ] , c [ i ] [ 1 ] - c [ j ] [ 1 ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> if dict ( dic ) : print ( n - max ( dic . values ( ) ) ) <NEWLINE> else : print ( 1 ) <NEWLINE>
N , K = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> b . append ( j ) <NEWLINE> <DEDENT> <DEDENT> b1 = list ( dict . fromkeys ( b ) ) <NEWLINE> for i in b1 : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> values = [ s ] <NEWLINE> <NL> for i in range ( 1000000 ) : <NEWLINE> <INDENT> s = func_f ( values [ i ] ) <NEWLINE> if s in values : <NEWLINE> <INDENT> return [ i + 2 ] <NEWLINE> <DEDENT> values . append ( s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def func_f ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return int ( n / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 3 * n + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 5 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 18 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 114 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <DEDENT> if FLAG_LOG : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> if lines_result == lines_export : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> finished = time . time ( ) <NEWLINE> duration = finished - started <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( ( i + 1 ) % 2 == 1 and a [ i ] % 2 == 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import * <NEWLINE> z , v , a = input , range , print <NEWLINE> h , w , k = map ( int , z ( ) . split ( ) ) ; r , s , t , u = map ( lambda x : int ( x ) - 1 , z ( ) . split ( ) ) ; b = [ z ( ) for _ in v ( h ) ] ; l = [ [ - 1 ] * w for _ in v ( h ) ] ; l [ r ] [ s ] = 0 ; d = deque ( [ ( r , s ) ] ) <NEWLINE> while d : <NEWLINE> <INDENT> x , y = d . popleft ( ) ; j = l [ x ] [ y ] <NEWLINE> if ( x == t ) & ( y == u ) : exit ( a ( j ) ) <NEWLINE> for e , f in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> for i in v ( 1 , k + 1 ) : <NEWLINE> <INDENT> p , q = x + e * i , y + f * i <NEWLINE> if not ( ( 0 <= p < h ) & ( 0 <= q < w ) ) or b [ p ] [ q ] == <STRING> or 0 <= l [ p ] [ q ] <= j : break <NEWLINE> if l [ p ] [ q ] < 0 : d += [ ( p , q ) ] ; l [ p ] [ q ] = j + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a ( - 1 ) <NEWLINE>
<NL> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> score = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if score [ 0 ] == score [ 1 ] == score [ 2 ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if score [ 0 ] == - 1 or score [ 1 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if score [ 0 ] + score [ 1 ] >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif score [ 0 ] + score [ 1 ] >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif score [ 0 ] + score [ 1 ] >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif score [ 0 ] + score [ 1 ] >= 30 : <NEWLINE> <INDENT> if score [ 2 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if score [ 2 ] >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s1 = ( a - 1 ) // c <NEWLINE> s2 = ( a - 1 ) // d <NEWLINE> s3 = ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) <NEWLINE> S = ( a - 1 ) - ( s1 + s2 - s3 ) <NEWLINE> <NL> l1 = b // c <NEWLINE> l2 = b // d <NEWLINE> l3 = b // ( c * d // math . gcd ( c , d ) ) <NEWLINE> L = b - ( l1 + l2 - l3 ) <NEWLINE> <NL> print ( L - S ) <NEWLINE>
from collections import deque <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> Map = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> Map += [ [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] for _ in range ( h ) ] <NEWLINE> Map += [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( h + 2 ) : <NEWLINE> <INDENT> for j in range ( w + 2 ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> stack = deque ( [ ( 1 , 1 ) ] ) <NEWLINE> Map [ 1 ] [ 1 ] = 1 <NEWLINE> moved = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x , y = stack . popleft ( ) <NEWLINE> for s , t in moved : <NEWLINE> <INDENT> if Map [ x + s ] [ y + t ] == <STRING> : <NEWLINE> <INDENT> stack . append ( ( x + s , y + t ) ) <NEWLINE> Map [ x + s ] [ y + t ] = Map [ x ] [ y ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> goal = Map [ - 2 ] [ - 2 ] <NEWLINE> if goal == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt - goal ) <NEWLINE> <DEDENT>
def print_list_inline ( tr_list ) : <NEWLINE> <INDENT> inline = map ( lambda string : <STRING> . format ( string ) , tr_list ) <NEWLINE> inline = list ( inline ) <NEWLINE> print ( ( <STRING> ) . join ( inline ) ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> sum_col = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list_row = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> sum_row = sum ( list_row ) <NEWLINE> list_row . append ( sum_row ) <NEWLINE> for j in range ( len ( list_row ) ) : <NEWLINE> <INDENT> sum_col [ j ] += list_row [ j ] <NEWLINE> <DEDENT> print_list_inline ( list_row ) <NEWLINE> <DEDENT> print_list_inline ( sum_col ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> RGB = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> cnt = collections . Counter ( S ) <NEWLINE> ans = cnt [ <STRING> ] * cnt [ <STRING> ] * cnt [ <STRING> ] <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ 2 * j - i ] == RGB [ 3 - RGB . index ( S [ i ] ) - RGB . index ( S [ j ] ) ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> r = len ( [ i for i , x in enumerate ( s ) if x == <STRING> ] ) <NEWLINE> g = len ( [ i for i , x in enumerate ( s ) if x == <STRING> ] ) <NEWLINE> b = len ( [ i for i , x in enumerate ( s ) if x == <STRING> ] ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( list ( set ( c ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> asum = alist [ 0 ] <NEWLINE> for a in alist [ 1 : ] : <NEWLINE> <INDENT> asum ^= a <NEWLINE> <NL> <DEDENT> import copy <NEWLINE> a_ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> asum ^= alist [ i ] <NEWLINE> a_ans . append ( asum ) <NEWLINE> asum ^= alist [ i ] <NEWLINE> <DEDENT> print ( <STRING> . join ( [ str ( a ) for a in a_ans ] ) ) <NEWLINE>
h , a , * m = open ( 0 ) <NEWLINE> h , w , k , a , b , f , g = map ( int , ( h + a ) . split ( ) ) <NEWLINE> d = [ I : = h * w ] * I <NEWLINE> m += d , <NEWLINE> q = [ a : = ~ w + a * w + b ] <NEWLINE> d [ a ] = 1 <NEWLINE> for s in q : <NEWLINE> <INDENT> for y , x in ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) : <NEWLINE> <INDENT> for z in range ( k ) : <NEWLINE> <INDENT> i , j = s // w + y * ~ z , s % w + x * ~ z ; t = i * w + j ; p = d [ s ] + 1 <NEWLINE> if <STRING> != m [ i ] [ j ] or d [ t ] < p : break <NEWLINE> if d [ t ] > p : q += t , ; d [ t ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d [ ~ w + f * w + g ] % I - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = b * a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> gcd2 = [ [ 0 for i in range ( K ) ] for i in range ( K ) ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> gcd2 [ i ] [ j ] = math . gcd ( i + 1 , j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> sum += math . gcd ( gcd2 [ i ] [ j ] , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n %= bin ( n ) . count ( <STRING> ) <NEWLINE> ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> cnt = x . count ( <STRING> ) <NEWLINE> <NL> if cnt == 1 : <NEWLINE> <INDENT> for k in x [ : - 1 ] : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> xNum = 0 <NEWLINE> for k in x : <NEWLINE> <INDENT> xNum <<= 1 <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> xNum += 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> p = xNum % ( cnt + 1 ) <NEWLINE> m = xNum % ( cnt - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( f ( ( p + pow ( 2 , n - i - 1 , cnt + 1 ) ) % ( cnt + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( f ( ( m - pow ( 2 , n - i - 1 , cnt - 1 ) ) % ( cnt - 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> stores = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> sorted_sotres = sorted ( stores , key = lambda x : x [ 0 ] ) <NEWLINE> total = 0 <NEWLINE> ans = 0 <NEWLINE> for cost , number in sorted_sotres : <NEWLINE> <INDENT> if number > m : <NEWLINE> <INDENT> ans += cost * m <NEWLINE> break <NEWLINE> <DEDENT> elif number == m : <NEWLINE> <INDENT> ans += cost * number <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cost * number <NEWLINE> <DEDENT> m -= number <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> R = set ( [ ] ) <NEWLINE> G = set ( [ ] ) <NEWLINE> B = set ( [ ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> temp = S [ i ] <NEWLINE> if temp == <STRING> : <NEWLINE> <INDENT> R . add ( i ) <NEWLINE> <DEDENT> elif temp == <STRING> : <NEWLINE> <INDENT> G . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> all = [ R , G , B ] <NEWLINE> <NL> M = [ len ( R ) , len ( G ) , len ( B ) ] <NEWLINE> res = M [ 0 ] * M [ 1 ] * M [ 2 ] <NEWLINE> index = M . index ( max ( M ) ) <NEWLINE> <NL> most = all . pop ( index ) <NEWLINE> first = all [ 0 ] <NEWLINE> second = all [ 1 ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for f in first : <NEWLINE> <INDENT> for s in second : <NEWLINE> <INDENT> temp1 = s * 2 - f <NEWLINE> temp2 = f * 2 - s <NEWLINE> temp3 = ( f + s ) // 2 <NEWLINE> if ( True ) & ( temp1 in most ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if ( True ) & ( temp2 in most ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if ( s + f ) % 2 == 0 : <NEWLINE> <INDENT> if temp3 in most : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res -= count <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> l = [ 0 ] * mod <NEWLINE> l [ 0 ] = 1 <COMMENT> <NEWLINE> ans = 0 <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> <NL> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> r += int ( i ) * t <NEWLINE> r %= mod <COMMENT> <NEWLINE> l [ r ] += 1 <NEWLINE> t *= 10 <NEWLINE> t %= mod <COMMENT> <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> asum = [ 0 ] * ( n + 1 ) <NEWLINE> bsum = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> asum [ i + 1 ] = a [ i ] + asum [ i ] <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> bsum [ j + 1 ] = b [ j ] + bsum [ j ] <NEWLINE> <DEDENT> j = m <NEWLINE> res = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if asum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while asum [ i ] + bsum [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> res = max ( res , i + j ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> <NL> print ( max ( l ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( - 118 , 119 , 1 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 118 , 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> arg = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in arg : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for m in arg : <NEWLINE> <INDENT> ans *= m <NEWLINE> <NL> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> fb = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> if i < m : <NEWLINE> <INDENT> a , b = map ( int , x . split ( ) ) <NEWLINE> fb [ a - 1 ] += 1 <NEWLINE> fb [ b - 1 ] += 1 <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , d = map ( int , x . split ( ) ) <NEWLINE> if uf . _root ( c - 1 ) == uf . _root ( d - 1 ) : <NEWLINE> <INDENT> fb [ c - 1 ] += 1 <NEWLINE> fb [ d - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = [ - uf . table [ uf . _root ( i ) ] - 1 - fb [ i ] for i in range ( n ) ] <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> answer [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for n in answer : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
import fractions <NEWLINE> import math <NEWLINE> <NL> A , B = map ( fractions . Fraction , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( math . floor ( A * B ) ) ) <NEWLINE>
ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nokori = ls [ - 1 ] <NEWLINE> nokori_ = ls [ - 1 ] <NEWLINE> sum_max = 0 <NEWLINE> for i , j in zip ( ls [ : - 1 ] , [ 1 , 0 , - 1 ] ) : <NEWLINE> <INDENT> nokori -= i <NEWLINE> if nokori > 0 : <NEWLINE> <INDENT> sum_max += i * j <NEWLINE> <DEDENT> elif nokori == 0 : <NEWLINE> <INDENT> sum_max += i * j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_max += nokori_ * j <NEWLINE> break <NEWLINE> <DEDENT> nokori_ = nokori <NEWLINE> <DEDENT> print ( sum_max ) <NEWLINE>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( pi * r ** 2 , 2 * pi * r ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> is_p = [ 1 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT> if is_p [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> is_p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = Counter ( a ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if is_p [ i ] and c [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def gcd ( n , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> return gcd ( m , n % m ) <NEWLINE> <NL> <DEDENT> def make ( a , b ) : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> return ( 0 , 0 , 0 ) <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> return ( 0 , 1 , 0 ) <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return ( 1 , 0 , 0 ) <NEWLINE> <NL> <DEDENT> s = 1 if a * b > 0 else - 1 <NEWLINE> a , b = abs ( a ) , abs ( b ) <NEWLINE> <NL> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> <NL> return ( a , b , s ) <NEWLINE> <NL> <DEDENT> ABS = Counter ( [ make ( * map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for a , b , s in list ( ABS . keys ( ) ) : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p = ABS [ ( a , b , s ) ] <NEWLINE> n = ABS [ ( b , a , - s ) ] <NEWLINE> <NL> ABS [ ( a , b , s ) ] = 0 <NEWLINE> ABS [ ( b , a , - s ) ] = 0 <NEWLINE> <NL> cnt = pow ( 2 , p , MOD ) + pow ( 2 , n , MOD ) - 1 <NEWLINE> ans = ( ans * cnt ) % MOD <NEWLINE> <NL> <DEDENT> ans += ABS [ ( 0 , 0 , 0 ) ] <NEWLINE> <NL> print ( ( ans - 1 ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> max_s = - 10 ** 9 <NEWLINE> min_s = s [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> max_s = max ( max_s , s [ i ] - min_s ) <NEWLINE> min_s = min ( min_s , s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max_s ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> lcm = n * m // math . gcd ( n , m ) <NEWLINE> <NL> x = { } <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> x [ lcm // n * i ] = c <NEWLINE> <NL> <DEDENT> for i , c in enumerate ( t ) : <NEWLINE> <COMMENT> <NL> <INDENT> pos , char = lcm // m * i , c <NEWLINE> if pos in x and x [ pos ] != char : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
<COMMENT> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , a1 , a2 , a3 , a4 , a5 , a6 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . face = [ a1 , a2 , a3 , a4 , a5 , a6 ] <NEWLINE> self . v = [ a5 , a1 , a2 , a6 ] <COMMENT> <NEWLINE> self . h = [ a4 , a1 , a3 , a6 ] <COMMENT> <NEWLINE> self . det = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . v [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 1 ] , self . v [ 2 ] , self . v [ 3 ] , self . v [ 0 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 3 ] , self . v [ 0 ] , self . v [ 1 ] , self . v [ 2 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 3 ] , self . h [ 0 ] , self . h [ 1 ] , self . h [ 2 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 1 ] , self . h [ 2 ] , self . h [ 3 ] , self . h [ 0 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <DEDENT> def searchFace ( self , a ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if a == self . face [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> b = i + 1 <NEWLINE> <DEDENT> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def detJudge ( self , x ) : <COMMENT> <NEWLINE> <INDENT> y = int ( 7 / 2 - abs ( x - 7 / 2 ) ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . det *= - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def rightSide ( self , top , front ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if top == 1 and front == 2 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif top == 2 and front == 3 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif top == 3 and front == 1 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif top == 1 and front == 3 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif top == 3 and front == 2 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif top == 2 and front == 1 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> if self . det == - 1 : <NEWLINE> <INDENT> r = 7 - r <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> diceAmount = int ( input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for i in range ( diceAmount ) : <NEWLINE> <INDENT> d = [ int ( j ) for j in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> dice = Dice ( d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] ) <NEWLINE> dices . append ( dice ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> import random <NEWLINE> match = 0 <NEWLINE> diceCount = 1 <NEWLINE> while match == 0 and diceCount < diceAmount : <NEWLINE> <INDENT> for d2 in range ( 1 , diceAmount ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> while match == 0 and i < 27 : <NEWLINE> <INDENT> j = random . randint ( 0 , 3 ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> dices [ d2 ] . north ( ) <NEWLINE> <DEDENT> elif j == 1 : <NEWLINE> <INDENT> dices [ d2 ] . south ( ) <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dices [ d2 ] . east ( ) <NEWLINE> <DEDENT> elif j == 3 : <NEWLINE> <INDENT> dices [ d2 ] . west ( ) <NEWLINE> <DEDENT> for d1 in range ( d2 ) : <NEWLINE> <INDENT> if ( dices [ d1 ] . v == dices [ d2 ] . v and dices [ d1 ] . h == dices [ d2 ] . h ) : <NEWLINE> <INDENT> match += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> diceCount += 1 <NEWLINE> <DEDENT> if match >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from math import gcd <NEWLINE> r = range ( 1 , int ( input ( ) ) + 1 ) <NEWLINE> print ( sum ( gcd ( gcd ( i , j ) , k ) for i in r for j in r for k in r ) ) <NEWLINE>
def eratosthenes ( n ) : <NEWLINE> <INDENT> is_prime = [ True for i in range ( n + 1 ) ] <NEWLINE> is_prime [ 0 ] , is_prime [ 1 ] = False , False <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> for j in range ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> N = 10 ** 5 <NEWLINE> <NL> prime = eratosthenes ( N ) <NEWLINE> prime_num = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for p in prime : <NEWLINE> <INDENT> prime_num [ p ] = 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> ans = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> if prime_num [ i ] == 1 and prime_num [ ( i + 1 ) // 2 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> ans [ i ] = count <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans [ r ] - ans [ l - 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Money = 1000 <NEWLINE> Kabu = 0 <NEWLINE> <NL> def MoneyWar ( Money , Kabu , A , N ) : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> Kounyu = math . floor ( Money / A [ i ] ) <NEWLINE> Money -= A [ i ] * Kounyu <NEWLINE> Kabu += Kounyu <NEWLINE> <NL> <DEDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> Money += Kabu * A [ i ] <NEWLINE> Kabu = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if Kabu > 0 : <NEWLINE> <INDENT> Money += Kabu * A [ - 1 ] <NEWLINE> <NL> <DEDENT> return Money <NEWLINE> <NL> <DEDENT> print ( MoneyWar ( Money , Kabu , A , N ) ) <NEWLINE>
import numpy as np <NEWLINE> from numpy . fft import rfft , irfft <NEWLINE> <NL> p = 200003 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . zeros ( p - 1 ) <NEWLINE> <NL> g = 1 <NEWLINE> d = { } <NEWLINE> p2 = [ 1 ] * ( p - 1 ) <NEWLINE> for i in range ( p - 1 ) : <NEWLINE> <INDENT> d [ g ] = i <NEWLINE> p2 [ i ] = g <NEWLINE> g *= 2 <NEWLINE> g %= p <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a [ d [ A [ i ] ] ] += 1 <NEWLINE> <NL> <DEDENT> b = rfft ( a , 2 * p - 2 ) <NEWLINE> b = irfft ( b * b , 2 * p - 2 ) <NEWLINE> b = np . rint ( b ) . astype ( np . int64 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( p - 1 ) : <NEWLINE> <INDENT> ans += ( b [ i ] + b [ i + p - 1 ] ) * p2 [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans -= A [ i ] ** 2 % p <NEWLINE> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
def cal ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = i * ans <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> cal ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = As [ 0 ] <NEWLINE> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> result = result * As [ i + 1 ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
kazulist = [ ] <NEWLINE> for i in range ( - 100 , 200 ) : <NEWLINE> <INDENT> kazulist . append ( i ) <NEWLINE> <NL> <DEDENT> a = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> target = int ( a [ 0 ] ) <NEWLINE> syokyo = int ( a [ 1 ] ) <NEWLINE> <NL> if syokyo != 0 : <NEWLINE> <INDENT> b = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> for i in b : <NEWLINE> <INDENT> kazulist . remove ( int ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> saisyosa = 100 <NEWLINE> kotae = 0 <NEWLINE> for i in kazulist : <NEWLINE> <INDENT> sa = target - int ( i ) <NEWLINE> <COMMENT> <NL> if sa < 0 : <NEWLINE> <INDENT> sa *= - 1 <NEWLINE> <DEDENT> if sa < saisyosa : <NEWLINE> <INDENT> saisyosa = sa <NEWLINE> kotae = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def f ( x , y , z ) : <NEWLINE> <INDENT> return x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> upper = int ( math . sqrt ( N ) ) + 1 <NEWLINE> <NL> for x in range ( 1 , upper + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , upper + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , upper + 1 ) : <NEWLINE> <INDENT> v = f ( x , y , z ) <NEWLINE> if v <= N : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> p = [ 0 ] * 10 ** 6 <NEWLINE> for i in range ( 2 , 10 ** 6 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> p [ i ] = 1 <NEWLINE> j = 2 <NEWLINE> while i * j < 10 ** 6 : <NEWLINE> <INDENT> p [ i * j ] = - 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if p [ i ] < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 1 <NEWLINE> while N % pow ( i , j ) == 0 : <NEWLINE> <INDENT> N //= pow ( i , j ) <NEWLINE> j += 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if p [ i ] < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while N % i == 0 : <NEWLINE> <INDENT> N //= i <NEWLINE> <NL> <DEDENT> <DEDENT> if N > 10 ** 6 : <NEWLINE> <INDENT> i = 2 <NEWLINE> f = True <NEWLINE> while i <= N ** 0.5 : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for u in g [ v ] : <COMMENT> <NEWLINE> <INDENT> if arr [ u ] >= arr [ v ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> per = True <NEWLINE> while per == True : <NEWLINE> <INDENT> for index in range ( n ) : <NEWLINE> <INDENT> num = a [ index ] <NEWLINE> ans = divmod ( num , 2 ) <NEWLINE> if num == 0 or ans [ 1 ] != 0 : <NEWLINE> <INDENT> per = False <NEWLINE> break <NEWLINE> <DEDENT> a [ index ] = ans [ 0 ] <NEWLINE> <DEDENT> if per == True : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
from calendar import isleap <NEWLINE> <NL> flag = False <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> flag = True <NEWLINE> ans = [ i for i in range ( a , b + 1 ) if isleap ( i ) ] <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) if len ( ans ) else <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ 1 ] <NEWLINE> cnt = 1 <NEWLINE> b = 10 ** 7 <NEWLINE> ans = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> s = List [ i ] <NEWLINE> arr . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans [ s ] == 1 : <NEWLINE> <INDENT> b = arr . index ( List [ s - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ s ] += 1 <NEWLINE> s = List [ s - 1 ] <NEWLINE> arr . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = len ( arr ) <NEWLINE> c = int ( ( K - b ) % ( l - b ) ) <NEWLINE> <NL> if K - b > 0 : <NEWLINE> <INDENT> print ( arr [ b + c ] ) <NEWLINE> <DEDENT> elif K - b == 0 : <NEWLINE> <INDENT> print ( arr [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( arr [ K ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aa = set ( A ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> if ( 0 not in aa ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> ans *= A [ i ] <NEWLINE> <NL> <DEDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> for x in range ( M ) : <NEWLINE> <INDENT> t = ( - 1 ) * heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , ( - 1 ) * ( t // 2 ) ) <NEWLINE> <DEDENT> print ( - 1 * sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> max_x = 10 ** 18 <NEWLINE> <NL> result = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> result *= int ( x ) <NEWLINE> if result == 0 or result > max_x : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result > max_x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1000000000000000000 and 0 not in a_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> <NL> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( b , c ) , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . key = num <NEWLINE> self . p = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> class BinarySearchTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y is None : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> node = self . root <NEWLINE> while node : <NEWLINE> <INDENT> if node . key == key : return node <NEWLINE> if key < node . key : <NEWLINE> <INDENT> node = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . right <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def find_minimum ( self , node ) : <NEWLINE> <INDENT> while node . left : node = node . left <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def delete ( self , node ) : <NEWLINE> <INDENT> if node . left and node . right : <NEWLINE> <INDENT> m = self . find_minimum ( node . right ) <NEWLINE> node . key = m . key <NEWLINE> self . delete ( m ) <NEWLINE> <DEDENT> elif node . left : <NEWLINE> <INDENT> self . update ( node , node . left ) <NEWLINE> <DEDENT> elif node . right : <NEWLINE> <INDENT> self . update ( node , node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . update ( node , None ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , node , new_node ) : <NEWLINE> <INDENT> if node . key < node . p . key : <NEWLINE> <INDENT> node . p . left = new_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . p . right = new_node <NEWLINE> <DEDENT> if new_node : <NEWLINE> <INDENT> new_node . p = node . p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def print_inorder ( node ) : <NEWLINE> <INDENT> if node is None : return <NEWLINE> print_inorder ( node . left ) <NEWLINE> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> print_inorder ( node . right ) <NEWLINE> <NL> <DEDENT> def print_preorder ( node ) : <NEWLINE> <INDENT> if node is None : return <NEWLINE> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> print_preorder ( node . left ) <NEWLINE> print_preorder ( node . right ) <NEWLINE> <NL> <DEDENT> T = BinarySearchTree ( ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> params = input ( ) . split ( ) <NEWLINE> if params [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . insert ( Node ( int ( params [ 1 ] ) ) ) <NEWLINE> <DEDENT> elif params [ 0 ] == <STRING> : <NEWLINE> <INDENT> if T . find ( int ( params [ 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif params [ 0 ] == <STRING> : <NEWLINE> <INDENT> node = T . find ( int ( params [ 1 ] ) ) <NEWLINE> if node : T . delete ( node ) <NEWLINE> <DEDENT> elif params [ 0 ] == <STRING> : <NEWLINE> <INDENT> print_inorder ( T . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> print_preorder ( T . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> <NL> pl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pl . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> m = pl [ 0 ] <NEWLINE> M = pl [ 0 ] <NEWLINE> difM = pl [ 1 ] - pl [ 0 ] <NEWLINE> <NL> for i , p in enumerate ( pl [ 1 : ] ) : <NEWLINE> <INDENT> if p < m : <NEWLINE> <INDENT> m = p <NEWLINE> continue <NEWLINE> <DEDENT> if p - m > difM : <NEWLINE> <INDENT> difM = p - m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( difM ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> bits = set ( ) <NEWLINE> c1 = 0 <NEWLINE> count = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x in bits : <NEWLINE> <INDENT> y = x <NEWLINE> while c1 < y and y in bits : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> if y <= c1 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> if y == 0 and count != x : <NEWLINE> <INDENT> c1 = max ( x , c1 ) <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bits . add ( y ) <NEWLINE> ans . append ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> if y == 0 : <NEWLINE> <INDENT> if i <= n - 2 : <NEWLINE> <INDENT> ans . append ( <STRING> * ( n - 2 - i ) + <STRING> ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> for i in range ( y + 1 , x + 1 ) : <NEWLINE> <INDENT> bits . remove ( i ) <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> bits . add ( x ) <NEWLINE> count += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> countN = 0 <NEWLINE> sum = [ 0 ] * N <NEWLINE> for i , name in enumerate ( An ) : <NEWLINE> <INDENT> if i + name < N : <NEWLINE> <INDENT> sum [ i + name ] = sum [ i + name ] + 1 <NEWLINE> <DEDENT> if i - name >= 0 : <NEWLINE> <INDENT> countN = countN + sum [ i - name ] <NEWLINE> <DEDENT> <DEDENT> print ( countN ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> n = I ( ) <NEWLINE> <NL> <COMMENT> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> prev_col = [ 0 ] * ( n + 1 ) <NEWLINE> a_b = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> a_b . append ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> check = [ - 1 ] * ( n + 1 ) <NEWLINE> check [ 0 ] = 0 <NEWLINE> check [ 1 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> k = max ( len ( graph [ i ] ) , k ) <NEWLINE> <DEDENT> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> ans = dict ( ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> check [ v ] = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if check [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = cnt + 1 <NEWLINE> if prev_col [ v ] == cnt : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> prev_col [ i ] = cnt <NEWLINE> ans [ str ( min ( i , v ) ) + <STRING> + str ( max ( i , v ) ) ] = cnt <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE> for key in a_b : <NEWLINE> <INDENT> print ( ans [ key ] ) <NEWLINE> <DEDENT>
MOD = 998244353 <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> segments = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> dp = [ 0 ] * ( 2 * N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for s , t in segments : <NEWLINE> <INDENT> t += 1 <NEWLINE> dp [ i + s ] += dp [ i ] if i != 0 else 1 <NEWLINE> dp [ i + t ] -= dp [ i ] if i != 0 else 1 <NEWLINE> <DEDENT> dp [ i + 1 ] += dp [ i ] <NEWLINE> dp [ i + 1 ] %= MOD <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from sys import stdin <NEWLINE> imput = stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <COMMENT> <NL> <NL> num_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> num_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> uf . union ( num_list [ i ] [ 0 ] - 1 , num_list [ i ] [ 1 ] - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
array = [ ] <NEWLINE> for i in range ( 3 , int ( input ( ) ) + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 or <STRING> in str ( i ) : <NEWLINE> <INDENT> array . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in array : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = 0 <NEWLINE> c = 0 <NEWLINE> x1 = 0 <NEWLINE> t = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c > x : <NEWLINE> <INDENT> x = c <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> if c > x1 : <NEWLINE> <INDENT> x1 = c <NEWLINE> <NL> <DEDENT> t . append ( max ( x1 , x ) ) <NEWLINE> <DEDENT> print ( max ( t ) ) <NEWLINE>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , num , prv = None , nxt = None ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . prv = prv <NEWLINE> self . nxt = nxt <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <NL> <DEDENT> def insert ( self , num ) : <NEWLINE> <INDENT> new_elem = Node ( num ) <NEWLINE> <NL> if self . start is None : <NEWLINE> <INDENT> self . start = self . last = new_elem <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_elem . nxt = self . start <NEWLINE> self . start . prv = new_elem <NEWLINE> self . start = new_elem <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_num ( self , target ) : <NEWLINE> <INDENT> it = self . start <NEWLINE> while it is not None : <NEWLINE> <INDENT> if it . num == target : <NEWLINE> <INDENT> if it . prv is None and it . nxt is None : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if it . prv is not None : <NEWLINE> <INDENT> it . prv . nxt = it . nxt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start = self . start . nxt <NEWLINE> <NL> <DEDENT> if it . nxt is not None : <NEWLINE> <INDENT> it . nxt . prv = it . prv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . last = self . last . prv <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> it = it . nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_start ( self ) : <NEWLINE> <INDENT> if self . start is self . last : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start . nxt . prv = None <NEWLINE> self . start = self . start . nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> if self . start is self . last : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . last . prv . nxt = None <NEWLINE> self . last = self . last . prv <NEWLINE> <NL> <DEDENT> <DEDENT> def get_content ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> it = self . start <NEWLINE> <NL> while it is not None : <NEWLINE> <INDENT> ret . append ( it . num ) <NEWLINE> it = it . nxt <NEWLINE> <NL> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def _main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> lst = DoublyLinkedList ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . insert ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_num ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_start ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_last ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst . get_content ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arui = [ 0 ] * ( N + 1 ) <NEWLINE> brui = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> arui [ i + 1 ] = a [ i ] + arui [ i ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> brui [ i + 1 ] = b [ i ] + brui [ i ] <NEWLINE> <NL> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if arui [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while brui [ j ] > K - arui [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import minimum_spanning_tree <NEWLINE> from scipy . sparse import csr_matrix , coo_matrix , lil_matrix <NEWLINE> from operator import itemgetter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( ( x , y , i ) ) <NEWLINE> <NL> <DEDENT> data = [ 10 , 20 , 30 , 40 ] <NEWLINE> row = [ 0 , 0 , 1 , 1 ] <NEWLINE> col = [ 1 , 2 , 0 , 2 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> data = [ ] <NEWLINE> row = [ ] <NEWLINE> col = [ ] <NEWLINE> <NL> P . sort ( ) <NEWLINE> D = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , p = P [ i ] <NEWLINE> c , d , q = P [ i + 1 ] <NEWLINE> cost = min ( abs ( a - c ) , abs ( b - d ) ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( p ) <NEWLINE> col . append ( q ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( q ) <NEWLINE> col . append ( p ) <NEWLINE> D [ ( p , q ) ] = cost <NEWLINE> D [ ( q , p ) ] = cost <NEWLINE> <NL> <DEDENT> P . sort ( key = itemgetter ( 1 ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , p = P [ i ] <NEWLINE> c , d , q = P [ i + 1 ] <NEWLINE> if ( p , q ) in D : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost = min ( abs ( a - c ) , abs ( b - d ) ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( p ) <NEWLINE> col . append ( q ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( q ) <NEWLINE> col . append ( p ) <NEWLINE> D [ ( p , q ) ] = cost <NEWLINE> D [ ( q , p ) ] = cost <NEWLINE> <NL> <DEDENT> coo = coo_matrix ( ( data , ( row , col ) ) , ( N , N ) ) <NEWLINE> mst = minimum_spanning_tree ( coo ) <NEWLINE> print ( int ( mst . sum ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s = s - a [ i ] <NEWLINE> total = total + a [ i ] * s % 1000000007 <NEWLINE> <NL> <DEDENT> print ( total % 1000000007 ) <NEWLINE>
from itertools import combinations <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> if i == j and j == k and i == k : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> elif i != j and j != k and i != k : <NEWLINE> <INDENT> x = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 3 <NEWLINE> <NL> <DEDENT> total += x * gcd_list ( [ i , j , k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> can = 1 <NEWLINE> zero = 0 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> zero = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> <DEDENT> if ( zero == 0 ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> can = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( can == 1 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
[ n , m ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> A = [ [ 0 ] * m for x in range ( n ) ] <NEWLINE> B = [ 0 ] * m <NEWLINE> counter = 0 <NEWLINE> while counter < n : <NEWLINE> <INDENT> A [ counter ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> while counter < m : <NEWLINE> <INDENT> B [ counter ] = int ( raw_input ( ) ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> while counter < n : <NEWLINE> <INDENT> result = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> result += A [ counter ] [ j ] * B [ j ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT>
def between ( x , y , a ) : <NEWLINE> <INDENT> lrg = max ( x , y ) <NEWLINE> sml = min ( x , y ) <NEWLINE> if ( sml <= a <= lrg ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> while ( True ) : <NEWLINE> <INDENT> pos = [ 10 , 10 ] <NEWLINE> result = <STRING> <NEWLINE> N = int ( input ( ) ) <COMMENT> <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> jewelPositions = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> jewelPos = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> jewelPositions . append ( jewelPos ) <NEWLINE> <NL> <DEDENT> M = int ( input ( ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> instruction = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if ( result == <STRING> ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> instruction [ 1 ] = int ( instruction [ 1 ] ) <NEWLINE> if ( instruction [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> move = ( <STRING> , instruction [ 1 ] ) <NEWLINE> <DEDENT> elif ( instruction [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> move = ( <STRING> , - 1 * instruction [ 1 ] ) <NEWLINE> <DEDENT> elif ( instruction [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> move = ( <STRING> , instruction [ 1 ] ) <NEWLINE> <DEDENT> elif ( instruction [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> move = ( <STRING> , - 1 * instruction [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise NotImplementedError <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> jewelToRemove = [ ] <NEWLINE> for jewel in jewelPositions : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> <NL> <NL> if ( ( move [ 0 ] == <STRING> ) and ( pos [ 1 ] == jewel [ 1 ] ) and ( between ( 0 , move [ 1 ] , jewel [ 0 ] - pos [ 0 ] ) ) ) or ( ( move [ 0 ] == <STRING> ) and ( pos [ 0 ] == jewel [ 0 ] ) and ( between ( 0 , move [ 1 ] , jewel [ 1 ] - pos [ 1 ] ) ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> jewelToRemove . append ( jewel ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> for jewel in jewelToRemove : <NEWLINE> <INDENT> jewelPositions . remove ( jewel ) <NEWLINE> <NL> <DEDENT> if ( move [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> pos [ 0 ] += move [ 1 ] <NEWLINE> <DEDENT> elif ( move [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> pos [ 1 ] += move [ 1 ] <NEWLINE> <NL> <DEDENT> if not jewelPositions : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if v > w and abs ( a - b ) / ( v - w ) <= t : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> link = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> link [ A [ i ] [ 0 ] - 1 ] . append ( A [ i ] [ 1 ] - 1 ) <NEWLINE> link [ A [ i ] [ 1 ] - 1 ] . append ( A [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ans [ P [ i ] [ 0 ] - 1 ] += P [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> dist = [ - 1 for _ in range ( N ) ] <NEWLINE> dist [ 0 ] = 0 <NEWLINE> d = deque ( [ 0 ] ) <NEWLINE> while d : <NEWLINE> <INDENT> now = d . pop ( ) <NEWLINE> for i in range ( len ( link [ now ] ) ) : <NEWLINE> <INDENT> if dist [ link [ now ] [ i ] ] == - 1 : <NEWLINE> <INDENT> ans [ link [ now ] [ i ] ] += ans [ now ] <NEWLINE> dist [ link [ now ] [ i ] ] = 0 <NEWLINE> d . append ( link [ now ] [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i != N - 1 : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> b = N // i <NEWLINE> ans += i * b * ( b + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> samu = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> k = int ( 2 * j - i ) <NEWLINE> if ( 0 <= k < n ) : <NEWLINE> <INDENT> if ( s [ k ] == <STRING> ) : <NEWLINE> <INDENT> samu -= 1 <NEWLINE> <DEDENT> <DEDENT> k = int ( 2 * i - j ) <NEWLINE> if ( 0 <= k < n ) : <NEWLINE> <INDENT> if ( s [ k ] == <STRING> ) : <NEWLINE> <INDENT> samu -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( i % 2 == j % 2 ) : <NEWLINE> <INDENT> k = int ( ( i + j ) / 2 ) <NEWLINE> if ( s [ k ] == <STRING> ) : <NEWLINE> <INDENT> samu -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( samu ) <NEWLINE>
MOD = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> def modinv ( a , mod ) : <NEWLINE> <INDENT> return pow ( a , mod - 2 , mod ) % mod <NEWLINE> <NL> <DEDENT> def comb ( n , r , mod ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> res = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> res = res * ( n - i ) % mod <NEWLINE> res = res * modinv ( i + 1 , mod ) % mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = ( pow ( 2 , n , MOD ) - 1 - comb ( n , a , MOD ) - comb ( n , b , MOD ) ) % MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> print ( ( A * x // B ) - A * ( x // B ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> P = 2019 <NEWLINE> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> now , ans = 0 , 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( S [ i ] ) * _10 ) % P <NEWLINE> _10 *= 10 <NEWLINE> _10 %= P <NEWLINE> ans += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter as C <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = C ( [ input ( ) for _ in range ( n ) ] ) <NEWLINE> <NL> print ( sum ( [ 1 for v in a . values ( ) if v % 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INFTY = 1000000001 <NEWLINE> cnt = [ 0 ] <NEWLINE> <NL> def merge ( left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : left + n1 ] <NEWLINE> R = A [ mid : mid + n2 ] <NEWLINE> L . append ( INFTY ) <NEWLINE> R . append ( INFTY ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> merge_sort ( left , mid ) <NEWLINE> merge_sort ( mid , right ) <NEWLINE> merge ( left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> merge_sort ( 0 , N ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( cnt [ 0 ] ) <NEWLINE>
import itertools <NEWLINE> I = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> H , W , D = I [ : 3 ] <NEWLINE> A = I [ 3 : 3 + H * W ] <NEWLINE> Q = I [ 3 + H * W ] <NEWLINE> LR = I [ 4 + H * W : ] <NEWLINE> <NL> a_i = [ 0 ] * ( H * W + 1 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> a_i [ a ] = i <NEWLINE> <NL> <NL> <DEDENT> def calc ( a1 ) : <NEWLINE> <INDENT> a2 = a1 + D <NEWLINE> hw1 = a_i [ a1 ] <NEWLINE> h1 , w1 = divmod ( hw1 , W ) <NEWLINE> hw2 = a_i [ a2 ] <NEWLINE> h2 , w2 = divmod ( hw2 , W ) <NEWLINE> return abs ( h2 - h1 ) + abs ( w2 - w1 ) <NEWLINE> <NL> <NL> <DEDENT> score = [ 0 ] + [ calc ( i ) for i in range ( 1 , H * W + 1 - D ) ] <NEWLINE> cum = [ [ 0 ] + list ( itertools . accumulate ( score [ i : : D ] ) ) for i in range ( D ) ] <NEWLINE> ans = [ ] <NEWLINE> for l , r in zip ( LR [ : : 2 ] , LR [ 1 : : 2 ] ) : <NEWLINE> <INDENT> ans += [ cum [ r % D ] [ r // D ] - cum [ l % D ] [ l // D ] ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import itertools <NEWLINE> <NL> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> ai , bi , ci , di = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> c . append ( ci ) <NEWLINE> d . append ( di ) <NEWLINE> <NL> <DEDENT> A = [ i for i in range ( 1 , M + 1 ) ] <COMMENT> <NEWLINE> <NL> A_pattern = list ( itertools . combinations_with_replacement ( A , N ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a_pattern in A_pattern : <COMMENT> <NEWLINE> <INDENT> ansi = 0 <NEWLINE> for i in range ( Q ) : <COMMENT> <NEWLINE> <INDENT> if a_pattern [ b [ i ] - 1 ] - a_pattern [ a [ i ] - 1 ] == c [ i ] : <COMMENT> <NEWLINE> <INDENT> ansi += d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , ansi ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> if int ( N ) != 0 : <NEWLINE> <INDENT> data_size = len ( N ) <NEWLINE> for data_size in range ( data_size ) : <NEWLINE> <INDENT> sum += int ( N [ data_size ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <NL> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ma = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ma . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> t = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = False <NEWLINE> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> for j in range ( n - m + 1 ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> ll = ma [ i + k ] [ j : j + m ] <NEWLINE> if ll != t [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> b = 0 <NEWLINE> g = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if S [ 2 * j - i ] != S [ j ] and S [ 2 * j - i ] != S [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * b * g - t ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> flg = 0 <NEWLINE> head = <STRING> <NEWLINE> tail = <STRING> <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if len ( query ) == 1 : <NEWLINE> <INDENT> head , tail = tail , head <NEWLINE> flg += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T , F , C = query <NEWLINE> if int ( F ) == 1 : <NEWLINE> <INDENT> head += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail += C <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg % 2 : <NEWLINE> <INDENT> print ( head [ : : - 1 ] + S [ : : - 1 ] + tail ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( head [ : : - 1 ] + S + tail ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> v = [ 0 ] * N <NEWLINE> w = [ 0 ] * N <NEWLINE> dp = [ [ 0 for i in range ( W + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if j < w [ i ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i + 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - w [ i ] ] + v [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 0 ] [ W ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) [ 0 ] for _ in range ( N ) ] <NEWLINE> A = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( A ) != 0 : <NEWLINE> <INDENT> C = collections . Counter ( A ) . most_common ( ) <NEWLINE> v , c = zip ( * C ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for a , b , c in itertools . combinations ( c , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += a * b * c <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> mydict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = <STRING> . join ( sorted ( s [ i ] ) ) <NEWLINE> if tmp not in mydict : <NEWLINE> <INDENT> mydict [ tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += mydict [ tmp ] <NEWLINE> mydict [ tmp ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> num = int ( input ( ) ) <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> if num <= 2 : <NEWLINE> <INDENT> a_list = [ i for i in range ( 1 , num + 1 ) ] <NEWLINE> comb_list = list ( itertools . product ( a_list , repeat = 3 ) ) <NEWLINE> print ( sum ( [ gcd_list ( x ) for x in comb_list ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a_list = [ i for i in range ( 1 , num + 1 ) ] <NEWLINE> comb_list = list ( itertools . combinations_with_replacement ( a_list , 3 ) ) <NEWLINE> test = sum ( [ gcd_list ( x ) for x in comb_list ] ) * 3 <NEWLINE> <NL> comb_list_dup = [ [ i , i , i ] for i in a_list ] <NEWLINE> duplica = sum ( [ gcd_list ( x ) for x in comb_list_dup ] ) * 2 <NEWLINE> <NL> comb_list_unique = list ( itertools . combinations ( a_list , 3 ) ) <NEWLINE> unique = sum ( [ gcd_list ( x ) for x in comb_list_unique ] ) * 3 <NEWLINE> print ( test - duplica + unique ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( f_i . readline ( ) ) <NEWLINE> <NL> lx = [ ] <NEWLINE> ly = [ ] <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , f_i . readline ( ) . split ( ) ) <NEWLINE> lx . append ( x ) <NEWLINE> ly . append ( y ) <NEWLINE> li . append ( i ) <NEWLINE> <NL> <DEDENT> x_width = max ( lx ) - min ( lx ) <NEWLINE> y_width = max ( ly ) - min ( ly ) <NEWLINE> if x_width > y_width : <NEWLINE> <INDENT> P = list ( zip ( lx , ly , li ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( zip ( ly , lx , li ) ) <NEWLINE> <DEDENT> P . sort ( ) <NEWLINE> <NL> interval = int ( math . sqrt ( n ) ) <NEWLINE> <NL> low = [ v1 for v1 , v2 , i in P [ : : interval ] ] <NEWLINE> high = [ v1 for v1 , v2 , i in P [ interval - 1 : : interval ] ] + [ float ( <STRING> ) ] <NEWLINE> <NL> S = [ ] <NEWLINE> v2_sec_list = [ ] <NEWLINE> for i in range ( 0 , n , interval ) : <NEWLINE> <INDENT> si = P [ i : i + interval ] <NEWLINE> si . sort ( key = itemgetter ( 1 ) ) <NEWLINE> v2_s = [ p [ 1 ] for p in si ] <NEWLINE> v2_sec_list . append ( v2_s ) <NEWLINE> S . append ( si ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> <NL> q = f_i . readline ( ) <NEWLINE> <NL> for l in f_i : <NEWLINE> <INDENT> sx , tx , sy , ty = map ( int , l . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> if x_width > y_width : <NEWLINE> <INDENT> for i in range ( bisect_left ( high , sx ) , bisect_right ( low , tx ) ) : <NEWLINE> <INDENT> v = S [ i ] <NEWLINE> k = v2_sec_list [ i ] <NEWLINE> for j in range ( bisect_left ( k , sy ) , bisect_right ( k , ty ) ) : <NEWLINE> <INDENT> if sx <= v [ j ] [ 0 ] <= tx : <NEWLINE> <INDENT> a . append ( v [ j ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( bisect_left ( high , sy ) , bisect_right ( low , ty ) ) : <NEWLINE> <INDENT> v = S [ i ] <NEWLINE> k = v2_sec_list [ i ] <NEWLINE> for j in range ( bisect_left ( k , sx ) , bisect_right ( k , tx ) ) : <NEWLINE> <INDENT> if sy <= v [ j ] [ 0 ] <= ty : <NEWLINE> <INDENT> a . append ( v [ j ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> A . extend ( a ) <NEWLINE> <DEDENT> A . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = input ( ) . split ( <STRING> ) <NEWLINE> sum = 1 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if array [ j ] == <STRING> : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> <DEDENT> if sum != 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> sum = sum * int ( array [ i ] ) <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> score_a = 0 <NEWLINE> score_b = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> ( a , b ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> score_a = score_a + a + b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> score_b = score_b + a + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score_a = score_a + a <NEWLINE> score_b = score_b + b <NEWLINE> <DEDENT> n = n - 1 <NEWLINE> <DEDENT> print score_a , score_b <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def do ( ) : <NEWLINE> <INDENT> n , m , k = INTM ( ) <NEWLINE> A = LIST ( ) <NEWLINE> B = LIST ( ) <NEWLINE> As = [ 0 ] * ( n + 1 ) <NEWLINE> Bs = [ 0 ] * ( m + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> As [ i + 1 ] = As [ i ] + A [ i ] <NEWLINE> <DEDENT> A = As <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> Bs [ i + 1 ] = Bs [ i ] + B [ i ] <NEWLINE> <DEDENT> B = Bs <NEWLINE> <COMMENT> <NL> <NL> if A [ - 1 ] + B [ - 1 ] <= k : <NEWLINE> <INDENT> ans = n + m <NEWLINE> <NL> <DEDENT> b_s = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <NL> <INDENT> if A [ i ] > k : <NEWLINE> <COMMENT> <NL> <INDENT> temp = i - 1 <NEWLINE> ans = max ( ans , temp ) <NEWLINE> break <NEWLINE> <DEDENT> for i2 in range ( b_s , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if A [ i ] + B [ i2 ] <= k : <NEWLINE> <INDENT> temp = i + i2 <NEWLINE> b_s = i2 <NEWLINE> <COMMENT> <NL> ans = max ( ans , temp ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( num , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
b = 0 <NEWLINE> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> if b : print ( ) <NEWLINE> b = 1 <NEWLINE> s , t = map ( int , e . split ( ) ) <NEWLINE> u = [ y for y in range ( s , t + 1 ) if y % 4 == 0 and y % 100 != 0 or y % 400 == 0 ] <NEWLINE> if u : <NEWLINE> <INDENT> for y in u : print ( y ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A ^= a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ A ^ x for x in a ] <NEWLINE> print ( * ans ) <NEWLINE>
import math <NEWLINE> <NL> def comb_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // math . factorial ( r ) // math . factorial ( n - r ) <NEWLINE> <NL> <DEDENT> S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> <NL> mods = [ 0 ] * 2019 <COMMENT> <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> tmp = 1 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> current = int ( S [ i ] ) * tmp + current <NEWLINE> mod = current % 2019 <NEWLINE> mods [ mod ] += 1 <NEWLINE> tmp = tmp * 10 % 2019 <NEWLINE> <NL> <DEDENT> for mod in mods : <NEWLINE> <INDENT> if mod > 1 : <NEWLINE> <INDENT> ans += comb_count ( mod , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> item = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> t = ( sum ( item ) ** 2 - sum ( [ i ** 2 for i in item ] ) ) <NEWLINE> <NL> print ( int ( t * pow ( 2 , - 1 , mod ) ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> minus , plus = [ ] , [ ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> minus . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = sum ( [ abs ( x ) for x in a ] ) <NEWLINE> <NL> if len ( minus ) % 2 == 0 : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if plus == [ ] or abs ( minus [ - 1 ] ) < plus [ 0 ] : <NEWLINE> <INDENT> print ( tmp + minus [ - 1 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tmp - plus [ 0 ] * 2 ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> danmen = input ( ) <NEWLINE> depth = [ ] <NEWLINE> tmp_dpt = 0 <NEWLINE> <NL> for line in danmen : <NEWLINE> <INDENT> depth . append ( tmp_dpt ) <NEWLINE> <NL> if line == <STRING> : <NEWLINE> <INDENT> tmp_dpt -= 1 <NEWLINE> <DEDENT> elif line == <STRING> : <NEWLINE> <INDENT> tmp_dpt += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> depth . append ( tmp_dpt ) <NEWLINE> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> L = [ ] <NEWLINE> <NL> while i < len ( danmen ) : <NEWLINE> <INDENT> if len ( set ( danmen [ i : ] ) ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if danmen [ i ] == <STRING> : <NEWLINE> <INDENT> if depth [ i ] in depth [ i + 1 : ] : <NEWLINE> <INDENT> stack = 0 <NEWLINE> area = 0 <NEWLINE> <NL> for line in danmen [ i : ] : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> area += 1 + 2 * stack <NEWLINE> stack += 1 <NEWLINE> <DEDENT> elif line == <STRING> : <NEWLINE> <INDENT> stack -= 1 <NEWLINE> area += 1 + 2 * stack <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> area += 2 * stack <NEWLINE> <NL> <DEDENT> if stack == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if area != 0 : <NEWLINE> <INDENT> L . append ( area // 2 ) <NEWLINE> i += depth [ i + 1 : ] . index ( depth [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( L ) ) <NEWLINE> print ( len ( L ) , * L ) <NEWLINE>
import math <NEWLINE> <NL> n , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> parents = [ - 1 ] * n <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parents [ x ] = find ( parents [ x ] ) <NEWLINE> return parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if parents [ x ] > parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> parents [ x ] += parents [ y ] <NEWLINE> parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - parents [ find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> def members ( x ) : <NEWLINE> <INDENT> root = find ( x ) <NEWLINE> return [ i for i in range ( n ) if find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( ) : <NEWLINE> <INDENT> return len ( roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( ) : <NEWLINE> <INDENT> return { r : members ( r ) for r in roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , members ( r ) ) for r in roots ( ) ) <NEWLINE> <NL> <DEDENT> C = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( A - 1 , B - 1 ) <NEWLINE> <STRING> <NEWLINE> <DEDENT> print ( group_count ( ) - 1 ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> <NL> def solve ( data ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for name , win , lose , draw in data : <NEWLINE> <INDENT> score = win * 3 + draw * 1 <NEWLINE> result . append ( [ name , score ] ) <NEWLINE> <DEDENT> result . sort ( key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> first_data_set = True <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> name , win , lose , draw = input ( ) . split ( ) <NEWLINE> data . append ( [ name , int ( win ) , int ( lose ) , int ( draw ) ] ) <NEWLINE> <DEDENT> result = solve ( data ) <NEWLINE> <NL> if first_data_set : <NEWLINE> <INDENT> first_data_set = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> for r in result : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , r ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( i + a [ i ] + 1 ) <NEWLINE> r . append ( i - a [ i ] + 1 ) <NEWLINE> <DEDENT> cl = collections . Counter ( l ) <NEWLINE> cr = collections . Counter ( r ) <NEWLINE> ans = 0 <NEWLINE> for k , v in cl . items ( ) : <NEWLINE> <INDENT> ans += v * cr [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import operator <NEWLINE> from itertools import repeat <NEWLINE> from functools import partial , reduce <NEWLINE> from typing import Any , Callable , Iterable , Tuple , Union <NEWLINE> <NL> Indices = Union [ int , slice , Tuple [ Union [ int , slice ] ] ] <NEWLINE> <NL> ndgetter = ( <NEWLINE> <INDENT> lambda a , i : a , <NEWLINE> lambda a , i : a [ i [ 0 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] , <NEWLINE> <DEDENT> ) <NEWLINE> ndinitializor = ( <NEWLINE> <INDENT> lambda s , v : [ v ] * s , <NEWLINE> lambda s , v : [ v ] * s [ 0 ] , <NEWLINE> lambda s , v : [ [ v ] * s [ 1 ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ v ] * s [ 2 ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ [ v ] * s [ 3 ] for _ in range ( s [ 2 ] ) ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ [ [ v ] * s [ 4 ] for _ in range ( s [ 3 ] ) ] for _ in range ( s [ 2 ] ) ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ [ [ [ v ] * s [ 5 ] for _ in range ( s [ 4 ] ) ] for _ in range ( s [ 3 ] ) ] for _ in range ( s [ 2 ] ) ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> <DEDENT> ) <NEWLINE> ndshapegetter = ( <NEWLINE> <INDENT> lambda a : len ( a ) , <NEWLINE> lambda a : ( len ( a ) , ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> nditerator = ( <NEWLINE> <INDENT> lambda s : s , <NEWLINE> lambda s : ( ( i , ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k , l ) for l in range ( s [ 3 ] ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k , l , m ) for m in range ( s [ 4 ] ) for l in range ( s [ 3 ] ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k , l , m , n ) for n in range ( s [ 5 ] ) for m in range ( s [ 4 ] ) for l in range ( s [ 3 ] ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> class nd ( object ) : <NEWLINE> <INDENT> __slots__ = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> <NL> def __init__ ( self , data : list , shape : Tuple [ int ] ) : <NEWLINE> <INDENT> self . _data = data <NEWLINE> self . shape = shape <NEWLINE> self . _getter_getter = ndgetter [ len ( self . shape ) ] <NEWLINE> self . _setter_getter = ndgetter [ len ( self . shape ) - 1 ] <NEWLINE> self . _iterator = nditerator [ len ( self . shape ) ] <NEWLINE> self . _initializer = ndinitializor [ len ( self . shape ) ] <NEWLINE> <NL> <DEDENT> def __len__ ( self ) : <NEWLINE> <INDENT> return len ( self . _data ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , key ) : <NEWLINE> <INDENT> return self . _data [ key ] <NEWLINE> <NL> <DEDENT> def __setitem__ ( self , key , value ) : <NEWLINE> <INDENT> self . _data [ key ] = value <NEWLINE> <NL> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> cls = type ( self ) <NEWLINE> sub_shape = self . shape [ 1 : ] <NEWLINE> if 0 < len ( sub_shape ) : <NEWLINE> <INDENT> return ( cls ( v , sub_shape ) for v in self . _data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return iter ( self . _data ) <NEWLINE> <NL> <DEDENT> <DEDENT> def at ( self , indices : Tuple [ int ] ) : <NEWLINE> <INDENT> return self . _getter_getter ( self . _data , indices ) <NEWLINE> <NL> <DEDENT> def set_at ( self , indices : Tuple [ int ] , value ) : <NEWLINE> <INDENT> self . _setter_getter ( self . _data , indices [ : - 1 ] ) [ indices [ - 1 ] ] = value <NEWLINE> <NL> <DEDENT> def fill ( self , value ) : <NEWLINE> <INDENT> for indices in self . _iterator ( self . shape ) : <NEWLINE> <INDENT> self . _setter_getter ( self . _data , indices [ : - 1 ] ) [ indices [ - 1 ] ] = value <NEWLINE> <NL> <DEDENT> <DEDENT> def apply_indices_inplace ( self , func : Callable [ [ Any , Tuple [ int ] ] , Any ] ) : <NEWLINE> <INDENT> for indices in self . _iterator ( self . shape ) : <NEWLINE> <INDENT> a = self . _setter_getter ( self . _data , indices [ : - 1 ] ) <NEWLINE> a [ indices [ - 1 ] ] = func ( a [ indices [ - 1 ] ] , indices ) <NEWLINE> <DEDENT> <DEDENT> def apply_inplace ( self , func : Callable [ [ Any ] , Any ] ) : <NEWLINE> <INDENT> for indices in self . _iterator ( self . shape ) : <NEWLINE> <INDENT> a = self . _setter_getter ( self . _data , indices [ : - 1 ] ) <NEWLINE> a [ indices [ - 1 ] ] = func ( a [ indices [ - 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> def apply_indices ( self , func : Callable [ [ Any , Tuple [ int ] ] , Any ] ) : <NEWLINE> <INDENT> new_data = self . _initializer ( self . shape , None ) <NEWLINE> for indices in self . _iterator ( self . shape ) : <NEWLINE> <INDENT> a = self . _setter_getter ( new_data , indices [ : - 1 ] ) <NEWLINE> a [ indices [ - 1 ] ] = func ( a [ indices [ - 1 ] ] , indices ) <NEWLINE> <DEDENT> return nd ( new_data , self . shape ) <NEWLINE> <DEDENT> def apply ( self , func : Callable [ [ Any ] , Any ] ) : <NEWLINE> <INDENT> new_data = self . _initializer ( self . shape , None ) <NEWLINE> for indices in self . _iterator ( self . shape ) : <NEWLINE> <INDENT> a = self . _setter_getter ( new_data , indices [ : - 1 ] ) <NEWLINE> a [ indices [ - 1 ] ] = func ( a [ indices [ - 1 ] ] ) <NEWLINE> <DEDENT> return nd ( new_data , self . shape ) <NEWLINE> <NL> <DEDENT> def operate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> return self . apply ( lambda element : operator ( element , other ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . apply_indices ( <NEWLINE> <INDENT> lambda element , indices : operator ( <NEWLINE> <INDENT> element , <NEWLINE> self . _getter_getter ( other , indices ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> def roperate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> return self . apply ( lambda element : operator ( other , element ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . apply_indices ( <NEWLINE> <INDENT> lambda element , indices : operator ( <NEWLINE> <INDENT> self . _getter_getter ( other , indices ) , <NEWLINE> element <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> def ioperate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> self . apply_inplace ( lambda element : operator ( element , other ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . apply_indices_inplace ( <NEWLINE> <INDENT> lambda element , indices : operator ( <NEWLINE> <INDENT> element , <NEWLINE> self . _getter_getter ( other , indices ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT> def rioperate ( self , other , operator ) : <NEWLINE> <INDENT> if not isinstance ( other , list ) : <NEWLINE> <INDENT> return self . apply_inplace ( lambda element : operator ( other , element ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . apply_indices_inplace ( <NEWLINE> <INDENT> lambda element , indices : operator ( <NEWLINE> <INDENT> self . _getter_getter ( other , indices ) , <NEWLINE> element <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return self <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . add ) <NEWLINE> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . add ) <NEWLINE> <DEDENT> def __iadd__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . add ) <NEWLINE> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . sub ) <NEWLINE> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . sub ) <NEWLINE> <DEDENT> def __isub__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . sub ) <NEWLINE> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . mul ) <NEWLINE> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . mul ) <NEWLINE> <DEDENT> def __imul__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . mul ) <NEWLINE> <DEDENT> def __matmul__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . matmul ) <NEWLINE> <DEDENT> def __rmatmul__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . matmul ) <NEWLINE> <DEDENT> def __imatmul__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . matmul ) <NEWLINE> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . truediv ) <NEWLINE> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . truediv ) <NEWLINE> <DEDENT> def __itruediv__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . truediv ) <NEWLINE> <DEDENT> def __floordiv__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . floordiv ) <NEWLINE> <DEDENT> def __rfloordiv__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . floordiv ) <NEWLINE> <DEDENT> def __ifloordiv__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . floordiv ) <NEWLINE> <DEDENT> def __mod__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . mod ) <NEWLINE> <DEDENT> def __rmod__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . mod ) <NEWLINE> <DEDENT> def __imod__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . mod ) <NEWLINE> <DEDENT> def __divmod__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . divmod ) <NEWLINE> <DEDENT> def __rdivmod__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . divmod ) <NEWLINE> <DEDENT> def __idivmod__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . divmod ) <NEWLINE> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . pow ) <NEWLINE> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . pow ) <NEWLINE> <DEDENT> def __ipow__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . pow ) <NEWLINE> <DEDENT> def __lshift__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . lshift ) <NEWLINE> <DEDENT> def __rlshift__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . lshift ) <NEWLINE> <DEDENT> def __ilshift__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . lshift ) <NEWLINE> <DEDENT> def __rshift__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . rshift ) <NEWLINE> <DEDENT> def __rrshift__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . rshift ) <NEWLINE> <DEDENT> def __irshift__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . rshift ) <NEWLINE> <DEDENT> def __and__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . and_ ) <NEWLINE> <DEDENT> def __rand__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . and_ ) <NEWLINE> <DEDENT> def __iand__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . and_ ) <NEWLINE> <DEDENT> def __xor__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . xor ) <NEWLINE> <DEDENT> def __rxor__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . xor ) <NEWLINE> <DEDENT> def __ixor__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . xor ) <NEWLINE> <DEDENT> def __or__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . or_ ) <NEWLINE> <DEDENT> def __ror__ ( self , other ) : <NEWLINE> <INDENT> return self . roperate ( other , operator . or_ ) <NEWLINE> <DEDENT> def __ior__ ( self , other ) : <NEWLINE> <INDENT> return self . ioperate ( other , operator . or_ ) <NEWLINE> <DEDENT> def __neg__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . neg ) <NEWLINE> <DEDENT> def __pos__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . pos ) <NEWLINE> <DEDENT> def __abs__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . abs ) <NEWLINE> <DEDENT> def __invert__ ( self , other ) : <NEWLINE> <INDENT> return self . apply ( other , operator . invert ) <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . lt ) <NEWLINE> <DEDENT> def __le__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . le ) <NEWLINE> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . eq ) <NEWLINE> <DEDENT> def __ne__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . ne ) <NEWLINE> <DEDENT> def __gt__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . gt ) <NEWLINE> <DEDENT> def __ge__ ( self , other ) : <NEWLINE> <INDENT> return self . operate ( other , operator . ge ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def full ( cls , fill_value , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] ) : <NEWLINE> <INDENT> if isinstance ( shape , int ) : <NEWLINE> <INDENT> return cls ( ndinitializor [ 0 ] ( shape , fill_value ) , ( shape , ) ) <NEWLINE> <DEDENT> elif not isinstance ( shape , tuple ) : <NEWLINE> <INDENT> shape = tuple ( shape ) <NEWLINE> <DEDENT> return cls ( ndinitializor [ len ( shape ) ] ( shape , fill_value ) , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def list_fromiter ( cls , iterable , ndim = 1 ) : <NEWLINE> <INDENT> if ndim == 1 : <NEWLINE> <INDENT> return list ( iterable ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return list ( map ( cls . list_fromiter , iterable ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def fromiter ( cls , iterable , ndim = 1 ) : <NEWLINE> <INDENT> new_data = cls . list_fromiter ( iterable , ndim ) <NEWLINE> return cls ( new_data , ndshapegetter [ ndim ] ( new_data ) ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def nones ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] ) : <NEWLINE> <INDENT> return cls . full ( None , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def zeros ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] , type = int ) : <NEWLINE> <INDENT> return cls . full ( type ( 0 ) , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def ones ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] , type = int ) : <NEWLINE> <INDENT> return cls . full ( type ( 1 ) , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def partial_map ( cls , func , * left_args , ** left_kwargs ) : <NEWLINE> <INDENT> def nd_func ( a : nd , * right_args , ** right_kwargs ) : <NEWLINE> <INDENT> return cls . fromiter ( <NEWLINE> <INDENT> func ( * left_args , v , * right_args , ** left_kwargs , ** right_kwargs ) <NEWLINE> for v in a . _data <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return nd_func <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def vectorize ( cls , func , * left_args , ** left_kwargs ) : <NEWLINE> <INDENT> def nd_func ( a : nd , * right_args , ** right_kwargs ) : <NEWLINE> <INDENT> return a . apply ( lambda v : func ( <NEWLINE> <INDENT> * left_args , v , * right_args , ** left_kwargs , ** right_kwargs <NEWLINE> <DEDENT> ) ) <NEWLINE> <DEDENT> return nd_func <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def bytes_to_str ( x : bytes ) : <NEWLINE> <INDENT> return x . decode ( <STRING> ) <NEWLINE> <NL> <DEDENT> def inputs ( func = bytes_to_str , sep = None , maxsplit = - 1 ) : <NEWLINE> <INDENT> return map ( func , sys . stdin . buffer . readline ( ) . split ( sep = sep , maxsplit = maxsplit ) ) <NEWLINE> <NL> <DEDENT> def inputs_1d ( func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd ( inputs ( func , ** kwargs ) ) <NEWLINE> <NL> <DEDENT> def inputs_2d ( nrows : int , func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd . fromiter ( <NEWLINE> <INDENT> ( inputs ( func , ** kwargs ) for _ in range ( nrows ) ) , <NEWLINE> ndim = 2 <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def inputs_2d_T ( nrows : int , func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd . fromiter ( <NEWLINE> <INDENT> zip ( * ( inputs ( func , ** kwargs ) for _ in range ( nrows ) ) ) , <NEWLINE> ndim = 2 <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> import operator <NEWLINE> from typing import Optional <NEWLINE> <NL> <NL> class BreadthFirstSearch ( object ) : <NEWLINE> <INDENT> def __init__ ( self , shape : Tuple [ int ] ) : <NEWLINE> <INDENT> self . shape = shape <NEWLINE> self . pushed = nd . zeros ( shape , type = bool ) <NEWLINE> self . _deque = deque ( ) <NEWLINE> <NL> <DEDENT> def push ( self , position : Tuple [ int ] ) : <NEWLINE> <INDENT> if not self . pushed . at ( position ) : <NEWLINE> <INDENT> self . pushed . set_at ( position , True ) <NEWLINE> self . _deque . append ( position ) <NEWLINE> <NL> <DEDENT> <DEDENT> def peek ( self ) -> Optional [ Tuple [ int ] ] : <NEWLINE> <INDENT> return self . _deque [ 0 ] if self . _deque else None <NEWLINE> <NL> <DEDENT> def pop ( self ) -> Optional [ Tuple [ int ] ] : <NEWLINE> <INDENT> return self . _deque . popleft ( ) if self . _deque else None <NEWLINE> <NL> <DEDENT> def __bool__ ( self ) : <NEWLINE> <INDENT> return bool ( self . _deque ) <NEWLINE> <NL> <DEDENT> <DEDENT> from bisect import bisect_left , bisect_right <NEWLINE> <NL> <NL> N , M = inputs ( int ) <NEWLINE> A , B , C = inputs_2d_T ( N , int ) <NEWLINE> D , E , F = inputs_2d_T ( M , int ) <NEWLINE> xs = sorted ( set ( C ) ) <NEWLINE> ys = sorted ( set ( D ) ) <NEWLINE> <NL> x_guard = nd . zeros ( ( len ( xs ) + 1 , len ( ys ) + 1 ) , type = bool ) <NEWLINE> y_guard = nd . zeros ( ( len ( xs ) + 1 , len ( ys ) + 1 ) , type = bool ) <NEWLINE> <NL> C = nd . partial_map ( bisect_right , xs ) ( C ) <NEWLINE> A = nd . partial_map ( bisect_left , ys ) ( A ) <NEWLINE> A += 1 <NEWLINE> B = nd . partial_map ( bisect_right , ys ) ( B ) <NEWLINE> <NL> D = nd . partial_map ( bisect_right , ys ) ( D ) <NEWLINE> E = nd . partial_map ( bisect_left , xs ) ( E ) <NEWLINE> E += 1 <NEWLINE> F = nd . partial_map ( bisect_right , xs ) ( F ) <NEWLINE> <NL> for a , b , c in zip ( A , B , C ) : <NEWLINE> <INDENT> for y in range ( a , b ) : <NEWLINE> <INDENT> x_guard [ c ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for d , e , f in zip ( D , E , F ) : <NEWLINE> <INDENT> for x in range ( e , f ) : <NEWLINE> <INDENT> y_guard [ x ] [ d ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> cow = ( <NEWLINE> <INDENT> bisect_right ( xs , 0 ) , <NEWLINE> bisect_right ( ys , 0 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> bfs = BreadthFirstSearch ( shape = ( len ( xs ) + 1 , len ( ys ) + 1 ) ) <NEWLINE> bfs . push ( cow ) <NEWLINE> <NL> area = 0 <NEWLINE> while bfs : <NEWLINE> <INDENT> xi , yi = bfs . pop ( ) <NEWLINE> <NL> if 0 < xi < len ( xs ) and 0 < yi < len ( ys ) : <NEWLINE> <INDENT> area += ( xs [ xi ] - xs [ xi - 1 ] ) * ( ys [ yi ] - ys [ yi - 1 ] ) <NEWLINE> if not x_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi - 1 , yi ) ) <NEWLINE> <DEDENT> if not x_guard [ xi + 1 ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi + 1 , yi ) ) <NEWLINE> <DEDENT> if not y_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi , yi - 1 ) ) <NEWLINE> <DEDENT> if not y_guard [ xi ] [ yi + 1 ] : <NEWLINE> <INDENT> bfs . push ( ( xi , yi + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> area = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( area ) <NEWLINE> <NL>
import math <NEWLINE> import itertools <NEWLINE> def gcd ( x , y , z ) : <NEWLINE> <INDENT> xy = math . gcd ( x , y ) <NEWLINE> xyz = math . gcd ( xy , z ) <NEWLINE> return xyz <NEWLINE> <DEDENT> k1 = int ( input ( ) ) <NEWLINE> k = list ( range ( 1 , k1 + 1 ) ) <NEWLINE> l = [ ] <NEWLINE> for i in itertools . combinations_with_replacement ( k , 3 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> num = 0 <NEWLINE> for h in l : <NEWLINE> <INDENT> t = gcd ( h [ 0 ] , h [ 1 ] , h [ 2 ] ) <NEWLINE> if h [ 0 ] == h [ 1 ] == h [ 2 ] : <NEWLINE> <INDENT> num += t <NEWLINE> <DEDENT> elif h [ 0 ] == h [ 1 ] or h [ 1 ] == h [ 2 ] or h [ 2 ] == h [ 0 ] : <NEWLINE> <INDENT> num += 3 * t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += 6 * t <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> reverse = False <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> query = list ( input ( ) . split ( ) ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> reverse ^= True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if reverse : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> s . append ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( query [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> s . appendleft ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s = <STRING> . join ( s ) <NEWLINE> if reverse : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> if x > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> m = 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( m * 10 + 7 ) % k <NEWLINE> <DEDENT> if m % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( N ) ] <NEWLINE> k = sorted ( l ) <NEWLINE> cnt = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if k [ i ] != k [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from functools import lru_cache <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> sorted_a = <STRING> <NEWLINE> m = dict ( { } ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = <STRING> . join ( list ( map ( lambda x : str ( int ( x ) - 1 ) , input ( ) . split ( ) ) ) ) <NEWLINE> sorted_a = <STRING> . join ( list ( sorted ( A ) ) ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> q . append ( ( A , 0 ) ) <NEWLINE> m [ A ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , x = q . popleft ( ) <NEWLINE> if a in m and m [ a ] < x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == ( len ( a ) - 1 ) // 2 : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for j in range ( i + 2 , len ( a ) + 1 ) : <NEWLINE> <INDENT> next_a = a [ : i : ] + a [ : : - 1 ] [ len ( a ) - j : len ( a ) - i : ] + a [ j : : ] <NEWLINE> if next_a in m : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> q . append ( ( next_a , x + 1 ) ) <NEWLINE> m [ next_a ] = x + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m2 = dict ( { } ) <NEWLINE> q = deque ( ) <NEWLINE> q . append ( ( sorted_a , 0 ) ) <NEWLINE> m2 [ sorted_a ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , x = q . popleft ( ) <NEWLINE> if a in m2 and m2 [ a ] < x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == ( len ( a ) - 1 ) // 2 : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for j in range ( i + 2 , len ( a ) + 1 ) : <NEWLINE> <INDENT> next_a = a [ : i : ] + a [ : : - 1 ] [ len ( a ) - j : len ( a ) - i : ] + a [ j : : ] <NEWLINE> if next_a in m2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( next_a , x + 1 ) ) <NEWLINE> m2 [ next_a ] = x + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ret = sys . maxsize <NEWLINE> for a , x in m . items ( ) : <NEWLINE> <INDENT> if a in m2 : <NEWLINE> <INDENT> ret = min ( ret , x + m2 [ a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ret == sys . maxsize : <NEWLINE> <INDENT> print ( len ( A ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> <NL> n = x // 100 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> tmp -= i * 100 <NEWLINE> if 5 * i >= tmp : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> out = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> RGBs = list ( itertools . permutations ( [ <STRING> , <STRING> , <STRING> ] , 3 ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( N - i * 2 ) : <NEWLINE> <INDENT> if ( S [ j ] , S [ j + i ] , S [ j + i * 2 ] ) in RGBs : <NEWLINE> <INDENT> out -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> clip = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> clip . add ( S ) <NEWLINE> <NL> <NL> <DEDENT> print ( len ( clip ) ) <NEWLINE>
def paintout_graph ( s , g , color ) : <NEWLINE> <INDENT> cnt , pre_color = 0 , s [ 0 ] <NEWLINE> que = [ 0 ] <NEWLINE> for pos in que : <NEWLINE> <INDENT> if s [ pos ] == pre_color : <NEWLINE> <INDENT> s [ pos ] = color <NEWLINE> cnt += 1 <NEWLINE> que . extend ( g [ pos ] ) <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> def bfs ( s , graph ) : <NEWLINE> <INDENT> que = deque ( [ ( s , 0 , 0 ) ] ) <NEWLINE> while True : <NEWLINE> <INDENT> s , pre_cnt , depth = que . popleft ( ) <NEWLINE> pre_color = s [ 0 ] <NEWLINE> <NL> colors = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> colors . remove ( pre_color ) <NEWLINE> <NL> for si , color in zip ( ( s , s [ : ] ) , colors ) : <NEWLINE> <INDENT> cnt = paintout_graph ( si , graph , color ) <NEWLINE> if cnt == len ( si ) : <NEWLINE> <INDENT> return depth <NEWLINE> <DEDENT> if cnt == pre_cnt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> que . append ( ( si , cnt , depth + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> from collections import deque <NEWLINE> def paintout_sq ( s , color , w , h , x , y ) : <NEWLINE> <INDENT> neighbor , pre_color = set ( ) , s [ y * w + x ] <NEWLINE> <NL> que = deque ( [ ( x , y ) ] ) <NEWLINE> while len ( que ) : <NEWLINE> <INDENT> x , y = que . pop ( ) <NEWLINE> pos = y * w + x <NEWLINE> if s [ pos ] == pre_color : <NEWLINE> <INDENT> s [ pos ] = color <NEWLINE> if 0 < x : que . append ( ( x - 1 , y ) ) <NEWLINE> if 0 < y : que . append ( ( x , y - 1 ) ) <NEWLINE> if x + 1 < w : que . append ( ( x + 1 , y ) ) <NEWLINE> if y + 1 < h : que . append ( ( x , y + 1 ) ) <NEWLINE> <DEDENT> elif s [ pos ] != color and isinstance ( s [ pos ] , int ) : <NEWLINE> <INDENT> neighbor . update ( [ s [ pos ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return neighbor <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> w , h = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = [ f . readline ( ) . split ( ) for _ in range ( h ) ] <NEWLINE> s = [ y for x in s for y in x ] <NEWLINE> p = [ ] <NEWLINE> graph = { } <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> pos = y * w + x <NEWLINE> if s [ pos ] in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> k = len ( p ) <NEWLINE> p . append ( s [ pos ] ) <NEWLINE> neighbor = paintout_sq ( s , k , w , h , x , y ) <NEWLINE> neighbor = list ( neighbor ) <NEWLINE> try : <NEWLINE> <INDENT> graph [ k ] . expand ( neighbor ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> graph [ k ] = neighbor <NEWLINE> <DEDENT> for ni in neighbor : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> graph [ ni ] . append ( k ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> graph [ ni ] = [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( bfs ( p , graph ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minus = [ ] <NEWLINE> plus = [ ] <NEWLINE> for x in xlst : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> minus . append ( - 1 * x ) <NEWLINE> <DEDENT> elif x > 0 : <NEWLINE> <INDENT> plus . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> minus . append ( 0 ) <NEWLINE> minus = minus [ : : - 1 ] <NEWLINE> plus = [ 0 ] + plus <NEWLINE> ans = 10 ** 20 <NEWLINE> ml = len ( minus ) <NEWLINE> pl = len ( plus ) <NEWLINE> <NL> pos = min ( k , ml - 1 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> mm = minus [ pos ] <NEWLINE> pp = plus [ k - pos ] <NEWLINE> ans_tmp = max ( mm , pp ) + min ( mm , pp ) * 2 <NEWLINE> ans = min ( ans , ans_tmp ) <NEWLINE> pos -= 1 <NEWLINE> if pos == - 1 or k - pos == pl : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> def mul ( x ) : <NEWLINE> <INDENT> l = 1 <NEWLINE> if 0 in x : <NEWLINE> <INDENT> l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in x : <NEWLINE> <INDENT> l = l * i <NEWLINE> if l > 10 ** 18 : <NEWLINE> <INDENT> l = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <DEDENT> print ( mul ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <COMMENT> <NL> if k < n and ( s [ i ] != s [ j ] and s [ j ] != s [ k ] <NEWLINE> <INDENT> and s [ i ] != s [ k ] ) and j - i == k - j : <NEWLINE> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input1 = input ( ) . split ( ) <NEWLINE> N = int ( input1 [ 0 ] ) <NEWLINE> M = int ( input1 [ 1 ] ) <NEWLINE> <NL> H = [ 0 ] * N <NEWLINE> input2 = input ( ) . split ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H [ i ] = int ( input2 [ i ] ) <NEWLINE> <NL> <DEDENT> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> input3 = input ( ) . split ( ) <NEWLINE> A [ i ] = int ( input3 [ 0 ] ) <NEWLINE> B [ i ] = int ( input3 [ 1 ] ) <NEWLINE> <NL> <DEDENT> mountain = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ A [ i ] - 1 ] <= H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> mountain [ A [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> if H [ B [ i ] - 1 ] <= H [ A [ i ] - 1 ] : <NEWLINE> <INDENT> mountain [ B [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if mountain [ i ] == 0 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> DP = [ 0 ] * ( S + 1 ) <NEWLINE> Mod = 10 ** 9 + 7 <NEWLINE> <NL> if S >= 3 : <NEWLINE> <INDENT> DP [ 0 ] = 1 <NEWLINE> DP [ 1 ] = 0 <NEWLINE> DP [ 2 ] = 0 <NEWLINE> for TS in range ( 3 , S + 1 ) : <NEWLINE> <INDENT> DP [ TS ] = DP [ TS - 1 ] + DP [ TS - 3 ] <NEWLINE> <DEDENT> print ( DP [ S ] % Mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xor_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xor_sum = xor_sum ^ A [ i ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( xor_sum ^ A [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> k = int ( k ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> sums = [ ] <NEWLINE> K = k - 1 <NEWLINE> for i in range ( K , n - 1 ) : <NEWLINE> <INDENT> if ( a [ i - K ] < a [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> n = len ( t ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> i = str ( i ) . zfill ( 3 ) <NEWLINE> f = True <NEWLINE> x = - 1 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> x = s . find ( i [ j ] , x + 1 ) <NEWLINE> f = f and bool ( x >= 0 ) <NEWLINE> <DEDENT> ans += f <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = { } <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 10000 , 100000 ) : <NEWLINE> <INDENT> L = list ( str ( i ) ) <NEWLINE> if L == list ( reversed ( L ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> N [ i ] = cnt <NEWLINE> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( N [ B ] - N [ A - 1 ] if A > 10000 else N [ B ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( a [ i ] - ( i + 1 ) ) <NEWLINE> <NL> <DEDENT> arr . sort ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> s = 0 <NEWLINE> b = arr [ n // 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += abs ( a [ i ] - ( b + ( i + 1 ) ) ) <NEWLINE> <DEDENT> ans . append ( s ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( ans [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> b = arr [ n // 2 + 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += abs ( a [ i ] - ( b + ( i + 1 ) ) ) <NEWLINE> <DEDENT> ans . append ( s ) <NEWLINE> <NL> print ( min ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> <NL> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - 1 * root [ r ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> n_list = map ( int , input ( ) . split ( ) ) <NEWLINE> n_dic = { } <NEWLINE> for n in n_list : <NEWLINE> <INDENT> n_dic . setdefault ( n , 0 ) <NEWLINE> n_dic [ n ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n_dic . setdefault ( c , 0 ) <NEWLINE> n_dic [ c ] += b <NEWLINE> <NL> <DEDENT> com_list = [ ] <NEWLINE> <NL> for score , num in n_dic . items ( ) : <NEWLINE> <INDENT> heapq . heappush ( com_list , ( - score , num ) ) <NEWLINE> <NL> <DEDENT> taken = 0 <NEWLINE> result = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> score , num = heapq . heappop ( com_list ) <NEWLINE> score = - score <NEWLINE> if N - taken > num : <NEWLINE> <INDENT> result += score * num <NEWLINE> taken += num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += score * ( N - taken ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from math import floor <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> print ( floor ( a * x / b ) - a * floor ( x / b ) ) <NEWLINE>
n , m , v , p = map ( int , input ( ) . split ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alst . sort ( reverse = True ) <NEWLINE> left = p - 1 <NEWLINE> right = n <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> pos = ( left + right ) // 2 <NEWLINE> if alst [ pos ] + m < alst [ p - 1 ] : <NEWLINE> <INDENT> right = pos <NEWLINE> continue <NEWLINE> <DEDENT> cnt = ( p - 1 ) * m <NEWLINE> base = alst [ pos ] + m <NEWLINE> for i in range ( p - 1 , n ) : <NEWLINE> <INDENT> cnt += min ( m , base - alst [ i ] ) <NEWLINE> <DEDENT> if cnt >= m * v : <NEWLINE> <INDENT> left = pos <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = pos <NEWLINE> <DEDENT> <DEDENT> print ( left + 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in [ 0 ] * n ] <NEWLINE> s2 = [ ] <NEWLINE> s3 = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> temp = [ 0 , 0 ] <NEWLINE> m = 0 <NEWLINE> now = 0 <NEWLINE> for i in s . strip ( <STRING> ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now -= 1 <NEWLINE> <DEDENT> m = min ( m , now ) <NEWLINE> <DEDENT> temp = [ - m , ( s . count ( <STRING> ) - s . count ( <STRING> ) ) - m ] <NEWLINE> if temp [ 0 ] < temp [ 1 ] : <NEWLINE> <INDENT> s2 . append ( temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s3 . append ( temp ) <NEWLINE> <DEDENT> <DEDENT> s2 . sort ( key = lambda x : ( x [ 0 ] ) ) <NEWLINE> s3 . sort ( key = lambda x : ( - x [ 1 ] ) ) <NEWLINE> cnt = 0 <NEWLINE> for i , j in s2 : <NEWLINE> <INDENT> cnt -= i <NEWLINE> if cnt < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> cnt += j <NEWLINE> <DEDENT> for i , j in s3 : <NEWLINE> <INDENT> cnt -= i <NEWLINE> if cnt < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> cnt += j <NEWLINE> <DEDENT> if cnt != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import heapq , math <NEWLINE> from itertools import zip_longest , permutations , combinations , combinations_with_replacement <NEWLINE> from itertools import accumulate , dropwhile , takewhile , groupby <NEWLINE> from functools import lru_cache <NEWLINE> from copy import deepcopy <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def ok ( X ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += ( a - 1 ) // X <NEWLINE> <NL> <DEDENT> return cnt <= K <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> l , r = 0 , 1000000000 <NEWLINE> <NL> while l + 1 < r : <NEWLINE> <INDENT> c = ( l + r ) // 2 <NEWLINE> if ok ( c ) : <NEWLINE> <INDENT> r = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = c <NEWLINE> <NL> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> D = { } <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> if j - A [ j ] in D : <NEWLINE> <INDENT> ans += D [ j - A [ j ] ] <NEWLINE> <DEDENT> if j + A [ j ] in D : <NEWLINE> <INDENT> D [ j + A [ j ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ j + A [ j ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> que = [ ( - ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) , 0 , 0 , 0 ) ] <NEWLINE> is_pushed = { ( 0 , 0 , 0 ) : 1 } <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> v , p , q , r = heapq . heappop ( que ) <NEWLINE> print ( - v ) <NEWLINE> if p + 1 < x and not is_pushed . get ( ( p + 1 , q , r ) ) : <NEWLINE> <INDENT> heapq . heappush ( que , ( - ( a [ p + 1 ] + b [ q ] + c [ r ] ) , p + 1 , q , r ) ) <NEWLINE> is_pushed [ ( p + 1 , q , r ) ] = 1 <NEWLINE> <DEDENT> if q + 1 < y and not is_pushed . get ( ( p , q + 1 , r ) ) : <NEWLINE> <INDENT> heapq . heappush ( que , ( - ( a [ p ] + b [ q + 1 ] + c [ r ] ) , p , q + 1 , r ) ) <NEWLINE> is_pushed [ ( p , q + 1 , r ) ] = 1 <NEWLINE> <DEDENT> if r + 1 < z and not is_pushed . get ( ( p , q , r + 1 ) ) : <NEWLINE> <INDENT> heapq . heappush ( que , ( - ( a [ p ] + b [ q ] + c [ r + 1 ] ) , p , q , r + 1 ) ) <NEWLINE> is_pushed [ ( p , q , r + 1 ) ] = 1 <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> a = collections . deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b [ 0 ] == <STRING> : a . appendleft ( b [ 7 : ] ) <NEWLINE> elif b [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : a . remove ( b [ 7 : ] ) <NEWLINE> except : pass <NEWLINE> <DEDENT> elif len ( b ) > 10 : a . popleft ( ) <NEWLINE> elif len ( b ) > 6 : a . pop ( ) <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> import numpy as np <NEWLINE> N , M , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> abcd = np . zeros ( ( Q , 4 ) , dtype = int ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> abcd [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> abcd [ : , 0 ] -= 1 <COMMENT> <NEWLINE> abcd [ : , 1 ] -= 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> ans = [ ] <NEWLINE> <COMMENT> <NL> for a in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> A = np . array ( a , dtype = int ) <NEWLINE> X = np . where ( A [ abcd [ : , 1 ] ] - A [ abcd [ : , 0 ] ] == abcd [ : , 2 ] ) <NEWLINE> ans . append ( np . sum ( abcd [ X , 3 ] ) ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> for A in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = UnionFind ( N ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> G . union ( a - 1 , b - 1 ) <NEWLINE> ans = max ( ans , G . size ( a - 1 ) ) <NEWLINE> <DEDENT> if M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> _ = sys . stdin . readline ( ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> Q = int ( sys . stdin . readline ( ) ) <NEWLINE> replace_map = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> nums = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> nums [ a ] = nums [ a ] + 1 if a in nums else 1 <NEWLINE> <NL> <DEDENT> previous_sum = 0 <NEWLINE> for search , replace in replace_map : <NEWLINE> <INDENT> replaced_count = 0 <NEWLINE> if search in nums : <NEWLINE> <INDENT> replaced_count = nums [ search ] <NEWLINE> nums [ replace ] = nums [ replace ] + replaced_count if replace in nums else replaced_count <NEWLINE> del nums [ search ] <NEWLINE> <DEDENT> if previous_sum == 0 : <NEWLINE> <INDENT> previous_sum = np . dot ( list ( nums . keys ( ) ) , list ( nums . values ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> previous_sum += replaced_count * ( replace - search ) <NEWLINE> <DEDENT> print ( previous_sum ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> Pushed = [ False ] * N <NEWLINE> Pushed [ 0 ] = True <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i = A [ i ] - 1 <NEWLINE> cnt += 1 <NEWLINE> if Pushed [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> Pushed [ i ] = True <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> neg = [ ] <NEWLINE> zero = 0 <NEWLINE> pos = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> neg . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> pos . sort ( ) <NEWLINE> neg . sort ( reverse = True ) <NEWLINE> <NL> if len ( pos ) == 0 : <NEWLINE> <INDENT> res = 1 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> neg . reverse ( ) <NEWLINE> <DEDENT> for a in neg [ : K ] : <NEWLINE> <INDENT> res *= a <NEWLINE> res %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> res = pos . pop ( ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> while K > 1 and len ( pos ) > 1 and len ( neg ) > 1 : <NEWLINE> <INDENT> if pos [ - 1 ] * pos [ - 2 ] > neg [ - 1 ] * neg [ - 2 ] : <NEWLINE> <INDENT> res *= pos . pop ( ) <NEWLINE> res %= mod <NEWLINE> res *= pos . pop ( ) <NEWLINE> res %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res *= neg . pop ( ) <NEWLINE> res %= mod <NEWLINE> res *= neg . pop ( ) <NEWLINE> res %= mod <NEWLINE> <DEDENT> K -= 2 <NEWLINE> <DEDENT> while K > 1 and len ( pos ) > 1 : <NEWLINE> <INDENT> res *= pos . pop ( ) <NEWLINE> res %= mod <NEWLINE> res *= pos . pop ( ) <NEWLINE> res %= mod <NEWLINE> K -= 2 <NEWLINE> <DEDENT> while K > 1 and len ( neg ) > 1 : <NEWLINE> <INDENT> res *= neg . pop ( ) <NEWLINE> res %= mod <NEWLINE> res *= neg . pop ( ) <NEWLINE> res %= mod <NEWLINE> K -= 2 <NEWLINE> <DEDENT> while K and pos : <NEWLINE> <INDENT> res *= pos . pop ( ) <NEWLINE> res %= mod <NEWLINE> K -= 1 <NEWLINE> <DEDENT> while K and neg : <NEWLINE> <INDENT> res *= neg . pop ( ) <NEWLINE> res %= mod <NEWLINE> K -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> class factorials : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = 1 <COMMENT> <NEWLINE> self . factorials = [ ] <NEWLINE> self . update_factorials ( n ) <NEWLINE> <NL> <DEDENT> def update_factorials ( self , n ) : <NEWLINE> <INDENT> if self . n >= n : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> for i in range ( self . n + 1 , n + 1 ) : <NEWLINE> <INDENT> done = False <NEWLINE> limit = int ( i ** 0.5 ) <NEWLINE> for j in self . factorials : <NEWLINE> <INDENT> if j > limit : break <NEWLINE> if not i % j : <NEWLINE> <INDENT> done = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not done : <NEWLINE> <INDENT> self . factorials . append ( i ) <NEWLINE> <DEDENT> <DEDENT> self . n = n <NEWLINE> return None <NEWLINE> <NL> <DEDENT> def factorials_list ( self ) : <NEWLINE> <INDENT> return self . factorials <NEWLINE> <NL> <DEDENT> def check_fact ( self , x ) : <NEWLINE> <INDENT> if x > self . n ** 2 : <NEWLINE> <INDENT> self . update_factorials ( int ( x ** 0.5 ) + 1 ) <NEWLINE> <DEDENT> MAX = int ( math . sqrt ( x ) ) <NEWLINE> for f in self . factorials : <NEWLINE> <INDENT> if f > MAX : break <NEWLINE> if not x % f : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def prime_factorization ( self , val , divisors = None ) : <NEWLINE> <COMMENT> <NL> <INDENT> max_n = int ( math . sqrt ( val ) ) <NEWLINE> if self . n < max_n : <NEWLINE> <INDENT> self . update_factorials ( max_n ) <NEWLINE> <DEDENT> if divisors == None : <NEWLINE> <INDENT> divisors = defaultdict ( lambda : 0 ) <NEWLINE> <DEDENT> for f in self . factorials : <NEWLINE> <INDENT> if f > val : break <NEWLINE> while True : <NEWLINE> <INDENT> if not val % f : <NEWLINE> <INDENT> divisors [ f ] += 1 <NEWLINE> val //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if val > 1 : <NEWLINE> <INDENT> divisors [ val ] += 1 <NEWLINE> <DEDENT> return divisors <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> facts = factorials ( int ( N ** 0.5 ) ) <NEWLINE> dic = facts . prime_factorization ( N ) <NEWLINE> <COMMENT> <NL> ret = 0 <NEWLINE> <NL> def dfs ( x , l , v ) : <NEWLINE> <INDENT> nonlocal ret <NEWLINE> <COMMENT> <NL> xx , ll = x [ 0 ] , l [ 0 ] <NEWLINE> if len ( x ) == 1 : <NEWLINE> <INDENT> for i in range ( ll + 1 ) : <NEWLINE> <INDENT> tmp = v * ( xx ** i ) <NEWLINE> <COMMENT> <NL> if tmp == 1 : continue <NEWLINE> if N % ( tmp - 1 ) == N // ( tmp - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ret += tmp - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ll + 1 ) : <NEWLINE> <INDENT> tmp = v * xx ** i <NEWLINE> dfs ( x [ 1 : ] , l [ 1 : ] , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( list ( dic . keys ( ) ) , list ( dic . values ( ) ) , 1 ) <NEWLINE> <NL> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( min ( X ) , max ( X ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in X : <NEWLINE> <INDENT> cnt += ( j - i ) ** 2 <NEWLINE> <DEDENT> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 0 <NEWLINE> im = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if abs ( ai ) >= abs ( m ) : <NEWLINE> <INDENT> m = ai <NEWLINE> im = i <NEWLINE> <DEDENT> <DEDENT> print ( 2 * n - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( im + 1 , i + 1 ) <NEWLINE> <NL> <DEDENT> if m > 0 : <NEWLINE> <INDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , n ) ) : <NEWLINE> <INDENT> print ( i + 1 , i ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = n % k <NEWLINE> b = k - a <NEWLINE> print ( min ( a , b ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> elif s [ : k ] . replace ( <STRING> , <STRING> ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s . replace ( <STRING> , <STRING> ) [ 0 ] ) <NEWLINE> <DEDENT>
import re <NEWLINE> <NL> x = input ( ) <NEWLINE> pattern = <STRING> <NEWLINE> pat = re . search ( pattern , x ) <NEWLINE> if pat : <NEWLINE> <INDENT> print ( len ( pat . group ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> abss = [ [ abs ( A [ i ] [ j ] - B [ i ] [ j ] ) for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> dp = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 << ( abss [ 0 ] [ 0 ] + 13000 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i != h - 1 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = dp [ i + 1 ] [ j ] | dp [ i ] [ j ] << abss [ i + <NEWLINE> <INDENT> 1 ] [ j ] | dp [ i ] [ j ] >> abss [ i + 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if j != w - 1 : <NEWLINE> <INDENT> dp [ i ] [ j + 1 ] = dp [ i ] [ j + 1 ] | dp [ i ] [ j ] << abss [ i ] [ j + <NEWLINE> <INDENT> 1 ] | dp [ i ] [ j ] >> abss [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = 0 <NEWLINE> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( ans & ( 1 << ( 13000 - a ) ) ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( ans & ( 1 << ( 13000 + a ) ) ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> ans = 0 <NEWLINE> x = 1 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ( ( ( m * pow ( m - 1 , n - i - 1 , mod ) ) % mod ) * x ) % mod <NEWLINE> ans %= mod <NEWLINE> x = ( x * ( n - i - 1 ) * pow ( i + 1 , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> black = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - black <NEWLINE> black += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> LineData = np . int64 ( sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> LineData = LineData . reshape ( - 1 , 3 ) <NEWLINE> A , B , C = LineData [ : N ] . T <NEWLINE> D , E , F = LineData [ N : ] . T <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> X = np . unique ( np . concatenate ( [ D , [ - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , [ - INF , INF ] ] ) ) <NEWLINE> A = np . searchsorted ( X , A ) <NEWLINE> B = np . searchsorted ( X , B , <STRING> ) - 1 <NEWLINE> C = np . searchsorted ( Y , C ) <NEWLINE> D = np . searchsorted ( X , D ) <NEWLINE> E = np . searchsorted ( Y , E ) <NEWLINE> F = np . searchsorted ( Y , F , <STRING> ) - 1 <NEWLINE> <NL> area = cal_area ( A , B , C , D , E , F , X , Y ) <NEWLINE> <NL> if area == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def cal_area ( A , B , C , D , E , F , X , Y ) : <NEWLINE> <INDENT> x = np . searchsorted ( X , 0 , <STRING> ) - 1 <NEWLINE> y = np . searchsorted ( Y , 0 , <STRING> ) - 1 <NEWLINE> <NL> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> A = A . tolist ( ) <NEWLINE> B = B . tolist ( ) <NEWLINE> C = C . tolist ( ) <NEWLINE> D = D . tolist ( ) <NEWLINE> E = E . tolist ( ) <NEWLINE> F = F . tolist ( ) <NEWLINE> X = X . tolist ( ) <NEWLINE> Y = Y . tolist ( ) <NEWLINE> DX = DX . tolist ( ) <NEWLINE> DY = DY . tolist ( ) <NEWLINE> <NL> LenX = len ( X ) <NEWLINE> LenY = len ( Y ) <NEWLINE> <NL> visit = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> visit [ x ] [ y ] = True <NEWLINE> area = 0 <NEWLINE> queue = [ ( x , y ) ] <NEWLINE> <NL> LineX = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> LineY = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> <NL> for x1 , x2 , y in zip ( A , B , C ) : <NEWLINE> <INDENT> for x in range ( x1 , x2 ) : <NEWLINE> <INDENT> LineY [ x ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for x , y1 , y2 in zip ( D , E , F ) : <NEWLINE> <INDENT> for y in range ( y1 , y2 ) : <NEWLINE> <INDENT> LineX [ x ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> while queue : <NEWLINE> <INDENT> x , y = queue . pop ( ) <NEWLINE> <NL> if x == 0 or x == LenX - 1 or y == 0 or y == LenY - 1 : <NEWLINE> <INDENT> area = 0 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> area += DX [ x ] * DY [ y ] <NEWLINE> <NL> if not LineX [ x ] [ y ] and not visit [ x - 1 ] [ y ] : <NEWLINE> <INDENT> visit [ x - 1 ] [ y ] = True <NEWLINE> queue . append ( ( x - 1 , y ) ) <NEWLINE> <DEDENT> if not LineY [ x ] [ y ] and not visit [ x ] [ y - 1 ] : <NEWLINE> <INDENT> visit [ x ] [ y - 1 ] = True <NEWLINE> queue . append ( ( x , y - 1 ) ) <NEWLINE> <DEDENT> if not LineX [ x + 1 ] [ y ] and not visit [ x + 1 ] [ y ] : <NEWLINE> <INDENT> visit [ x + 1 ] [ y ] = True <NEWLINE> queue . append ( ( x + 1 , y ) ) <NEWLINE> <DEDENT> if not LineY [ x ] [ y + 1 ] and not visit [ x ] [ y + 1 ] : <NEWLINE> <INDENT> visit [ x ] [ y + 1 ] = True <NEWLINE> queue . append ( ( x , y + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return area <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if A . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> line = a . split ( ) <NEWLINE> x = int ( line [ 0 ] ) <NEWLINE> y = int ( line [ 1 ] ) <NEWLINE> z1 = x * y <NEWLINE> z2 = x * 2 + y * 2 <NEWLINE> z3 = str ( z1 ) <NEWLINE> z4 = str ( z2 ) <NEWLINE> print ( z3 , z4 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> sum_res = sum ( A ) <NEWLINE> counter = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> counter [ a ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_res = sum_res - ( counter [ B ] * B ) <NEWLINE> sum_res = sum_res + ( counter [ B ] * C ) <NEWLINE> counter [ C ] += counter [ B ] <NEWLINE> counter [ B ] = 0 <NEWLINE> print ( sum_res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> S_2 = sum ( map ( lambda x : x * x , A ) ) <NEWLINE> <NL> ans = ( S * S - S_2 ) // 2 <COMMENT> <NEWLINE> <NL> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
<NL> <NL> <NL> <NL> data = input ( ) . split ( ) <NEWLINE> <NL> N , k = int ( data [ 0 ] ) , int ( data [ 1 ] ) <NEWLINE> <NL> tab = [ ] <NEWLINE> <NL> data = input ( ) . split ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tab . append ( int ( data [ i ] ) - 1 ) <NEWLINE> <NL> <NL> <DEDENT> parcour = [ ] <NEWLINE> tmp = [ 0 ] * N <NEWLINE> <NL> position = 0 <NEWLINE> <NL> while ( tmp [ position ] == 0 ) : <NEWLINE> <INDENT> parcour . append ( position ) <NEWLINE> tmp [ position ] = 1 <NEWLINE> position = tab [ position ] <NEWLINE> <DEDENT> i = 0 <NEWLINE> while parcour [ i ] != position : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> sizeCycle = len ( parcour ) - i <NEWLINE> <NL> <COMMENT> <NL> if ( k < len ( parcour ) ) : <NEWLINE> <INDENT> print ( parcour [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( parcour [ i + ( ( k - i ) % sizeCycle ) ] + 1 ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = sum ( a ) <NEWLINE> aa = np . array ( np . cumsum ( a ) , dtype = <STRING> ) <NEWLINE> all_a = sum ( a ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( a [ i ] % mod * ( all_a - aa [ i ] ) % mod ) <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dic_a = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a in dic_a : <NEWLINE> <INDENT> dic_a [ a ] += 1 <NEWLINE> dic_a [ a ] = dic_a [ a ] % 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_a [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( list ( dic_a . values ( ) ) ) ) <NEWLINE>
l = [ ] <NEWLINE> i = 1 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l . append ( x ) <NEWLINE> print ( <STRING> . format ( i , l [ i - 1 ] ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans != - 1 : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> elif a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> while M : <NEWLINE> <INDENT> A [ - 1 ] //= 2 <NEWLINE> M -= 1 <NEWLINE> i = - 2 <NEWLINE> while M and ( - N <= i and A [ i ] >= A [ - 1 ] ) : <NEWLINE> <INDENT> A [ i ] //= 2 <NEWLINE> M -= 1 <NEWLINE> i -= 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> ans = R * G * B <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k in range ( i + 1 , N ) : <NEWLINE> <INDENT> if ( k + i ) % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( k + i ) // 2 <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> import statistics <NEWLINE> import math <NEWLINE> from decimal import Decimal <NEWLINE> from decimal import Decimal , ROUND_HALF_UP , ROUND_HALF_EVEN , ROUND_DOWN <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> <NL> n = get_int ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> youso = [ ] <NEWLINE> aite = [ [ 0 ] * 20 for i in range ( 20 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> wk = Decimal ( s ) <NEWLINE> wk = wk - wk . quantize ( Decimal ( <STRING> ) , rounding = ROUND_DOWN ) <NEWLINE> seisu = Decimal . is_zero ( wk ) <NEWLINE> <NL> if seisu : <NEWLINE> <INDENT> if <STRING> in s : <NEWLINE> <INDENT> s_i , s_d = s . split ( <STRING> ) <NEWLINE> s = s_i <NEWLINE> <NL> <DEDENT> count2 = 0 <NEWLINE> wk = int ( s ) <NEWLINE> for ii in range ( 0 , 19 ) : <NEWLINE> <INDENT> if wk % 2 == 0 : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> wk = wk // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> count5 = 0 <NEWLINE> wk = int ( s ) <NEWLINE> for ii in range ( 0 , 19 ) : <NEWLINE> <INDENT> if wk % 5 == 0 : <NEWLINE> <INDENT> count5 += 1 <NEWLINE> wk = wk // 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> count5 = min ( 9 , count5 ) <NEWLINE> count2 = min ( 9 , count2 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> s_i , s_d = s . split ( <STRING> ) <NEWLINE> <NL> while s_d [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s_d = s_d [ : - 1 ] <NEWLINE> <NL> <DEDENT> count2 = 0 <NEWLINE> wk = int ( s_i + s_d ) <NEWLINE> for ii in range ( 0 , 19 ) : <NEWLINE> <INDENT> if ( wk * 2 ) % 10 == 0 : <NEWLINE> <INDENT> wk = wk * 2 / 10 <NEWLINE> count2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> count5 = 0 <NEWLINE> wk = int ( s_i + s_d ) <NEWLINE> for ii in range ( 0 , 19 ) : <NEWLINE> <INDENT> if ( wk * 5 ) % 10 == 0 : <NEWLINE> <INDENT> wk = wk * 5 / 10 <NEWLINE> count5 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> count2_wk = - len ( s_d ) + count5 <NEWLINE> count5 = min ( 9 , - len ( s_d ) + count2 ) <NEWLINE> count2 = min ( 9 , count2_wk ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> youso . append ( [ count2 , count5 ] ) <NEWLINE> aite [ 10 - count2 ] [ 10 - count5 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> aite2 = [ [ 0 ] * 20 for i in range ( 20 ) ] <NEWLINE> for i in range ( 0 , 20 ) : <NEWLINE> <INDENT> for ii in range ( 0 , 20 ) : <NEWLINE> <INDENT> for iii in range ( i , 20 ) : <NEWLINE> <INDENT> for iiii in range ( ii , 20 ) : <NEWLINE> <INDENT> aite2 [ iii ] [ iiii ] += aite [ i ] [ ii ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> y1 = youso [ i ] <NEWLINE> if y1 [ 0 ] >= 0 and y1 [ 1 ] >= 0 : <NEWLINE> <INDENT> ans += aite2 [ 10 + y1 [ 0 ] ] [ 10 + y1 [ 1 ] ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += aite2 [ 10 + y1 [ 0 ] ] [ 10 + y1 [ 1 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> import bisect <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def solve ( N , K , As ) : <NEWLINE> <INDENT> originalK = K <NEWLINE> <COMMENT> <NL> minus = [ a for a in As if a < 0 ] <NEWLINE> minus . sort ( reverse = True ) <NEWLINE> zero = [ a for a in As if a == 0 ] <NEWLINE> plus = [ a for a in As if a > 0 ] <NEWLINE> plus . sort ( ) <NEWLINE> <NL> if len ( zero ) and len ( zero ) > N - K : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> while K >= 2 and ( len ( plus ) >= 2 or len ( minus ) >= 2 ) : <NEWLINE> <INDENT> p1 = - 1 <NEWLINE> p2 = - 1 <NEWLINE> m = - 1 <NEWLINE> if len ( plus ) >= 1 : <NEWLINE> <INDENT> p1 = plus [ - 1 ] <NEWLINE> <DEDENT> if len ( plus ) >= 2 : <NEWLINE> <INDENT> p2 = plus [ - 1 ] * plus [ - 2 ] <NEWLINE> <DEDENT> if len ( minus ) >= 2 : <NEWLINE> <INDENT> m = minus [ - 1 ] * minus [ - 2 ] <NEWLINE> <NL> <DEDENT> if m >= p2 : <NEWLINE> <INDENT> ans *= ( m % MOD ) <NEWLINE> ans %= MOD <NEWLINE> minus . pop ( ) <NEWLINE> minus . pop ( ) <NEWLINE> K -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= ( p1 % MOD ) <NEWLINE> ans %= MOD <NEWLINE> plus . pop ( ) <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while K > 0 : <NEWLINE> <INDENT> if len ( plus ) : <NEWLINE> <INDENT> ans *= plus . pop ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= minus . pop ( 0 ) <NEWLINE> <DEDENT> K -= 1 <NEWLINE> <DEDENT> if ans < 0 and zero : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> minus = [ a for a in As if a < 0 ] <NEWLINE> plus = [ a for a in As if a > 0 ] <NEWLINE> minus . sort ( ) <NEWLINE> plus . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for _ in range ( originalK ) : <NEWLINE> <INDENT> if plus and minus : <NEWLINE> <INDENT> if abs ( plus [ - 1 ] ) < abs ( minus [ - 1 ] ) : <NEWLINE> <INDENT> ans *= plus . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= minus . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif plus : <NEWLINE> <INDENT> ans *= plus . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= minus . pop ( ) <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def slowsolve ( N , K , As ) : <NEWLINE> <INDENT> ans = - 10 ** 9 <NEWLINE> for p in itertools . combinations ( As , K ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> for i in p : <NEWLINE> <INDENT> k *= i <NEWLINE> <DEDENT> ans = max ( ans , k ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def rand ( N , a , b ) : <NEWLINE> <INDENT> import random <NEWLINE> return [ random . randint ( a , b ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( solve ( N , K , As ) ) <NEWLINE> <DEDENT>
flag = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % 400 == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif i % 100 != 0 and i % 4 == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> <DEDENT> if a != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a *= l [ i ] <NEWLINE> if a > 1000000000000000000 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> g1 = [ math . gcd ( x , y ) for x in range ( 1 , N + 1 ) for y in range ( 1 , N + 1 ) ] <NEWLINE> g2 = [ math . gcd ( x , y ) for x in g1 for y in range ( 1 , N + 1 ) ] <NEWLINE> print ( sum ( g2 ) ) <NEWLINE>
import sys , math <NEWLINE> <NL> def calcweight_tree ( N_vertices , edges , times , inf ) : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> <NL> distance = 0 <NEWLINE> <NL> passed = [ False ] * N_vertices <NEWLINE> <NL> travel_max = - inf <NEWLINE> for i in range ( N_vertices ) : <NEWLINE> <INDENT> if ( passed [ i ] == False ) : <NEWLINE> <INDENT> distance = 0 <NEWLINE> left = i <NEWLINE> cost_sum = 0 <NEWLINE> costs = [ ] <NEWLINE> min_distance = inf <NEWLINE> while ( True ) : <NEWLINE> <INDENT> dest = edges [ left ] [ 1 ] <NEWLINE> cost = edges [ dest ] [ 0 ] <NEWLINE> if ( passed [ dest ] == False ) : <NEWLINE> <COMMENT> <NL> <INDENT> passed [ dest ] = True <NEWLINE> cost_sum += cost <NEWLINE> costs . append ( cost_sum ) <NEWLINE> left = dest <NEWLINE> if ( min_distance > cost ) : <NEWLINE> <INDENT> min_distance = cost <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> period = len ( costs ) <NEWLINE> increase_period = cost_sum <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> remainder = times % period <NEWLINE> cost_minus = [ 0 ] <NEWLINE> for j in range ( period - 1 ) : <NEWLINE> <INDENT> cost_minus . append ( costs [ j ] ) <NEWLINE> <DEDENT> if ( increase_period <= 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> costs_last = [ ] <NEWLINE> <COMMENT> <NL> remainder2 = remainder % period <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> for j in range ( period ) : <NEWLINE> <INDENT> costs_last . append ( costs [ j ] ) <NEWLINE> <DEDENT> for j in range ( period ) : <NEWLINE> <INDENT> costs_last . append ( costs_last [ j ] + increase_period ) <NEWLINE> <DEDENT> maxvalue = - inf <NEWLINE> <COMMENT> <NL> for j in range ( period ) : <NEWLINE> <INDENT> maxvalue_candidate = max ( costs_last [ j : j + period ] ) <NEWLINE> if ( maxvalue_candidate - cost_minus [ j ] > maxvalue ) : <NEWLINE> <INDENT> maxvalue = maxvalue_candidate - cost_minus [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> travel_max = max ( maxvalue , travel_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs_last = [ ] <NEWLINE> <COMMENT> <NL> remainder2 = remainder % period <NEWLINE> times_period = times // period - 1 <NEWLINE> add_n = times_period * increase_period <NEWLINE> <COMMENT> <NL> for j in range ( remainder2 , period ) : <NEWLINE> <INDENT> costs_last . append ( costs [ j ] + add_n ) <NEWLINE> <DEDENT> for j in range ( 0 , remainder2 ) : <NEWLINE> <INDENT> costs_last . append ( costs [ j ] + add_n + increase_period ) <NEWLINE> <DEDENT> for j in range ( period ) : <NEWLINE> <INDENT> costs_last . append ( costs_last [ j ] + increase_period ) <NEWLINE> <DEDENT> maxvalue = - inf <NEWLINE> <COMMENT> <NL> for j in range ( period ) : <NEWLINE> <INDENT> maxvalue_candidate = max ( costs_last [ j : j + period ] ) <NEWLINE> if ( maxvalue_candidate - cost_minus [ j ] > maxvalue ) : <NEWLINE> <INDENT> maxvalue = maxvalue_candidate - cost_minus [ j ] <NEWLINE> <DEDENT> <DEDENT> travel_max = max ( maxvalue , travel_max ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> return travel_max <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> PList = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> CList = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 10 <NEWLINE> <NL> <NL> N_vertices = N <NEWLINE> <NL> edges3 = [ ] <NEWLINE> costs = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> edges3 . append ( [ CList [ i ] , PList [ i ] - 1 ] ) <NEWLINE> <NL> <DEDENT> weight = calcweight_tree ( N_vertices , edges3 , K , inf ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> print ( weight ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> height = h [ 0 ] <NEWLINE> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i ] <= height : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> height = h [ i ] <NEWLINE> l . append ( cnt ) <NEWLINE> <DEDENT> print ( max ( l ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( a_list ) <NEWLINE> num_a = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in a_list : <NEWLINE> <INDENT> num_a [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum_a + c * num_a [ b - 1 ] - b * num_a [ b - 1 ] <NEWLINE> num_a [ c - 1 ] += num_a [ b - 1 ] <NEWLINE> num_a [ b - 1 ] = 0 <NEWLINE> print ( sum_a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = { } <NEWLINE> for i in d : <NEWLINE> <INDENT> if i not in cnt : <NEWLINE> <INDENT> cnt [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = True <NEWLINE> for i in t : <NEWLINE> <INDENT> if i in cnt : <NEWLINE> <INDENT> if cnt [ i ] > 0 : <NEWLINE> <INDENT> cnt [ i ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> <DEDENT> ] <NEWLINE> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
def gcda ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> r = a % b <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcda ( r , b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcda ( a , b ) <NEWLINE> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> shukai = 360 <NEWLINE> while True : <NEWLINE> <INDENT> if shukai % X == 0 : <NEWLINE> <INDENT> print ( shukai // X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shukai = lcm ( shukai , X ) <NEWLINE> <DEDENT> <DEDENT>
def process ( ) : <NEWLINE> <INDENT> count = int ( input ( ) ) <NEWLINE> nums_str = input ( ) . split ( ) <NEWLINE> nums_int = [ ] <NEWLINE> for strn in nums_str : <NEWLINE> <INDENT> nums_int . append ( int ( strn ) ) <NEWLINE> <NL> <DEDENT> if 0 in nums_int : <NEWLINE> <INDENT> result = 0 <NEWLINE> return result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for intn in nums_int : <NEWLINE> <INDENT> result *= intn <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> return result <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> print ( process ( ) ) <NEWLINE>
s = input ( ) <NEWLINE> a = 0 <NEWLINE> now = 1 <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> for i in list ( s ) [ : : - 1 ] : <NEWLINE> <INDENT> a = ( a + now * int ( i ) ) % 2019 <NEWLINE> l [ a ] += 1 <NEWLINE> <NL> now *= 10 <NEWLINE> now %= 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += ( i - 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans + l [ 0 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> city = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> city [ a - 1 ] += 1 <NEWLINE> city [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( city [ i ] ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 1 , 0 , 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 3 , S + 1 ) : <NEWLINE> <INDENT> cnt = dp [ i - 1 ] + dp [ i - 3 ] <NEWLINE> cnt %= mod <NEWLINE> dp . append ( cnt ) <NEWLINE> <NL> <DEDENT> ans = dp [ S ] <NEWLINE> print ( ans ) <NEWLINE>
mod = 1000000007 <NEWLINE> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , mod ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = list ( range ( 1 , n + 1 ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> count += i <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
<COMMENT> <NL> All = 0 <NEWLINE> q = [ ] <NEWLINE> Queue = [ ] <NEWLINE> tmp , time = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> p , zi = input ( ) . split ( ) <NEWLINE> q . append ( [ p , int ( zi ) ] ) <NEWLINE> <DEDENT> while len ( q ) > 0 : <NEWLINE> <INDENT> if q [ 0 ] [ 1 ] <= time : <NEWLINE> <INDENT> All += q [ 0 ] [ 1 ] <NEWLINE> v = q . pop ( 0 ) <NEWLINE> Queue . append ( [ v [ 0 ] , All ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> All += time <NEWLINE> q [ 0 ] [ 1 ] -= time <NEWLINE> last = q . pop ( 0 ) <NEWLINE> q . append ( last ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( Queue ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( Queue [ i ] [ 0 ] , Queue [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 10 ** 18 <NEWLINE> ans = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > MAX : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , n ) ) <NEWLINE> x = sum ( a ) % 9 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> base = np . ones ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> base [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> base [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> base [ a - 1 ] = 0 <NEWLINE> base [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( np . sum ( base ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> Q = int ( readline ( ) ) <NEWLINE> <NL> t = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> s = sum ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> t [ a ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> s -= B * t [ B ] <NEWLINE> s += C * t [ B ] <NEWLINE> t [ C ] += t [ B ] <NEWLINE> t [ B ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> dp = [ [ 0 ] * ( 2 ) for i in range ( 2 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nextDP = [ [ 0 ] * ( 2 ) for i in range ( 2 ) ] <NEWLINE> nextDP [ 1 ] [ 1 ] += ( dp [ 0 ] [ 1 ] + dp [ 1 ] [ 0 ] + dp [ 1 ] [ 1 ] * 10 ) % p <NEWLINE> nextDP [ 1 ] [ 0 ] += ( dp [ 1 ] [ 0 ] * 9 + dp [ 0 ] [ 0 ] ) % p <NEWLINE> nextDP [ 0 ] [ 1 ] += ( dp [ 0 ] [ 1 ] * 9 + dp [ 0 ] [ 0 ] ) % p <NEWLINE> nextDP [ 0 ] [ 0 ] += ( dp [ 0 ] [ 0 ] * 8 ) % p <NEWLINE> dp = nextDP <NEWLINE> <DEDENT> print ( dp [ 1 ] [ 1 ] % p ) <NEWLINE>
def function ( a ) : <NEWLINE> <INDENT> for j in range ( 2 , a ) : <NEWLINE> <INDENT> if a % j == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if j ** 2 > a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> s += function ( a ) <NEWLINE> <DEDENT> print ( n - s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> s = [ ] <NEWLINE> mod = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dpsum = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in lr : <NEWLINE> <INDENT> l , r = j <NEWLINE> li = i - r <NEWLINE> ri = i - l <NEWLINE> if ri < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li = max ( 1 , li ) <NEWLINE> dp [ i ] += dpsum [ ri ] - dpsum [ li - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> dpsum [ i ] = dpsum [ i - 1 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) ; <NEWLINE> <NL> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = - 1 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if i > 0 : dp [ i ] += dp [ i - 1 ] <NEWLINE> dp [ i ] %= 998244353 <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if i + l > n : continue <NEWLINE> dp [ i + l ] += dp [ i ] <NEWLINE> dp [ min ( n , i + r + 1 ) ] -= dp [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 2 ] % 998244353 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> boss_nums = input ( ) <NEWLINE> boss_nums = boss_nums . split ( ) <NEWLINE> <NL> subordinate = [ 0 ] * n <NEWLINE> <NL> for num in boss_nums : <NEWLINE> <INDENT> num = int ( num ) <NEWLINE> subordinate [ num - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for num in range ( 0 , n ) : <NEWLINE> <INDENT> print ( subordinate [ num ] ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> upper = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> middle = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lower = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> upper . sort ( ) <NEWLINE> middle . sort ( ) <NEWLINE> lower . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> mid = middle [ i ] <NEWLINE> index_up = bisect . bisect_left ( upper , mid ) <NEWLINE> index_low = bisect . bisect_right ( lower , mid ) <NEWLINE> <NL> cnt += index_up * ( N - index_low ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> <NL> print ( s , l ) <NEWLINE>
import bisect <NEWLINE> <NL> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L_sorted = sorted ( L , reverse = False ) <COMMENT> <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <COMMENT> <NEWLINE> <INDENT> a = L_sorted [ i ] <NEWLINE> b = L_sorted [ j ] <COMMENT> <NEWLINE> count += bisect . bisect_left ( L_sorted , a + b ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> f = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> s = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if s < n + 1 : <NEWLINE> <INDENT> f [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( f [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> L = [ 0 ] * ( 100001 ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ c ] += L [ b ] <NEWLINE> s += L [ b ] * ( c - b ) <NEWLINE> L [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> m = 1000000007 <NEWLINE> s1 = sum ( l ) <NEWLINE> s1 = ( s1 * s1 ) <NEWLINE> s2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s2 = s2 + l [ i ] * l [ i ] <NEWLINE> <DEDENT> print ( ( ( s1 - s2 ) // 2 ) % m ) <NEWLINE>
class RangeMaximumQuery : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . dat = [ 0 ] * ( 2 * n - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += self . size - 1 <NEWLINE> self . dat [ i ] = x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> d1 = self . dat [ i * 2 + 1 ] <NEWLINE> d2 = self . dat [ i * 2 + 2 ] <NEWLINE> if d1 > d2 : <NEWLINE> <INDENT> self . dat [ i ] = d1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . dat [ i ] = d2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def getmax ( self , a , b , k , l , r ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif a <= l and r <= b : <NEWLINE> <INDENT> return self . dat [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = self . getmax ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) <NEWLINE> vr = self . getmax ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) <NEWLINE> if vl > vr : <NEWLINE> <INDENT> return vl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return vr <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> from math import ceil , log <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 2 ** ceil ( log ( n , 2 ) ) <NEWLINE> W = RangeMaximumQuery ( s ) <NEWLINE> for a_i in A : <NEWLINE> <INDENT> cost = W . getmax ( 0 , a_i - 1 , 0 , 0 , s ) + a_i <NEWLINE> W . update ( a_i - 1 , cost ) <NEWLINE> <DEDENT> ans = n * ( n + 1 ) // 2 - W . getmax ( 0 , n , 0 , 0 , s ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
from math import factorial <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> disabled = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if ( l [ i ] + l [ j ] ) <= l [ k ] or l [ i ] == l [ j ] or l [ j ] == l [ k ] : <NEWLINE> <INDENT> disabled += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if n >= 3 : <NEWLINE> <INDENT> print ( int ( factorial ( n ) / factorial ( 3 ) / factorial ( n - 3 ) - disabled ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> now = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> od = [ - 1 ] * ( n + 1 ) <NEWLINE> c = 1 <NEWLINE> l = 0 <NEWLINE> <NL> v = 1 <NEWLINE> <NL> while od [ v ] == - 1 : <NEWLINE> <INDENT> od [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <NL> <DEDENT> c = len ( s ) - od [ v ] <NEWLINE> l = od [ v ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : return x <NEWLINE> return gcd ( y , x % y ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if len ( set ( [ a , b , c ] ) ) == 3 : res += gcd ( gcd ( a , b ) , c ) * 6 <NEWLINE> elif len ( set ( [ a , b , c ] ) ) == 2 : res += gcd ( gcd ( a , b ) , c ) * 3 <NEWLINE> else : res += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def check ( x ) : <NEWLINE> <INDENT> if x % 4 == 0 : <NEWLINE> <INDENT> if x % 100 != 0 : return x <NEWLINE> elif x % 400 == 0 : return x <NEWLINE> <NL> <DEDENT> <DEDENT> def make ( a , b ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for _ in range ( a , b + 1 ) : <NEWLINE> <INDENT> if box [ 0 ] <= _ <= box [ - 1 ] : <NEWLINE> <INDENT> if _ in box : <NEWLINE> <INDENT> count = 1 <NEWLINE> print ( _ ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = check ( _ ) <NEWLINE> if temp != None : <NEWLINE> <INDENT> box . append ( temp ) <NEWLINE> count = 1 <NEWLINE> print ( _ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == 0 : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> box = [ 2004 ] <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in stdin . readlines ( ) : <NEWLINE> <INDENT> make ( a , b ) <NEWLINE> a , b = map ( int , _ . split ( ) ) <NEWLINE> if a == b == 0 : break <NEWLINE> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> road = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ x ] . append ( y ) <NEWLINE> <DEDENT> flag = [ 0 ] * ( N + 1 ) <NEWLINE> dist = [ 0 ] * ( N + 1 ) <NEWLINE> def distance ( i ) : <COMMENT> <NEWLINE> <INDENT> if flag [ i ] == 1 : <NEWLINE> <INDENT> return dist [ i ] <NEWLINE> <NL> <DEDENT> if road [ i ] == [ ] : <COMMENT> <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> long_dist = 0 <NEWLINE> tmp = 0 <NEWLINE> for dirct in road [ i ] : <NEWLINE> <INDENT> tmp = 1 + distance ( dirct ) <NEWLINE> long_dist = max ( long_dist , tmp ) <NEWLINE> <DEDENT> flag [ i ] = 1 <NEWLINE> dist [ i ] = long_dist <NEWLINE> return long_dist <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , distance ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> sides = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sides . sort ( ) <NEWLINE> if sides [ - 1 ] ** 2 == sides [ - 2 ] ** 2 + sides [ - 3 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> <COMMENT> <NL> INF = 1 << 50 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = readInt ( ) <NEWLINE> c_sum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c_sum . append ( c_sum [ i ] + a [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( c_sum [ - 1 ] - c_sum [ i + 1 ] ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> A = input ( ) <NEWLINE> n = len ( A ) <NEWLINE> c = Counter ( A ) <NEWLINE> <NL> ans = 1 <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans -= v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections , sys <NEWLINE> def s ( ) : <NEWLINE> <INDENT> d = collections . deque ( ) <NEWLINE> input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e [ 0 ] : d . appendleft ( e [ 7 : - 1 ] ) <NEWLINE> else : <NEWLINE> <INDENT> if <STRING> == e [ 6 ] : <NEWLINE> <INDENT> m = e [ 7 : - 1 ] <NEWLINE> if m in d : d . remove ( m ) <NEWLINE> <DEDENT> elif len ( e ) % 2 : d . pop ( ) <NEWLINE> else : d . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * d ) <NEWLINE> <DEDENT> s ( ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if ( z >= 0 and z <= y ) : <NEWLINE> <INDENT> if ( x == y and y == z ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif ( x == y or y == z or z == x ) : <NEWLINE> <INDENT> cnt += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if A >= K : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += A <NEWLINE> if A + B >= K : <NEWLINE> <INDENT> ans = A <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count -= ( K - ( A + B ) ) <NEWLINE> ans = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> gcd_ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( gcd_ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def f ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = int ( 1e18 ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in arr : <NEWLINE> <COMMENT> <NL> <INDENT> ans = ans * i <NEWLINE> if ans > x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> f ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> least = 1 <NEWLINE> result = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> result [ a - 1 ] += 1 <NEWLINE> if a != least : <NEWLINE> <INDENT> least = a <NEWLINE> <NL> <DEDENT> <DEDENT> for r in result : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> num ^= a <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans = a ^ num <NEWLINE> l . append ( ans ) <NEWLINE> <DEDENT> print ( * l ) <NEWLINE>
<COMMENT> <NL> from math import gcd <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> cnt = 0 <NEWLINE> while n > a : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * 10001 <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> val = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if val < len ( ans ) : <NEWLINE> <INDENT> ans [ val ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> A = a = int ( input ( ) ) <NEWLINE> count = 2 <NEWLINE> samenumcount = 0 <NEWLINE> y = [ ] <NEWLINE> <NL> if A == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> while A != 1 and count < np . sqrt ( a ) : <NEWLINE> <INDENT> if A % count == 0 : <NEWLINE> <INDENT> samenumcount += 1 <NEWLINE> y . append ( count ** samenumcount ) <NEWLINE> A = A / count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> samenumcount = 0 <NEWLINE> <DEDENT> <DEDENT> if A != 1 : <NEWLINE> <INDENT> y . append ( A ) <NEWLINE> <DEDENT> y . sort ( ) <NEWLINE> count2 = 0 <NEWLINE> for i in y : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a % i == 0 : <NEWLINE> <INDENT> a = a / i <NEWLINE> count2 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count2 == 0 : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> <NL> <DEDENT> print ( count2 ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> limit = 2500 <NEWLINE> s = min ( s , limit ) <NEWLINE> path = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> coin = [ ( 0 , 0 ) ] <NEWLINE> time = [ [ float ( <STRING> ) for _ in range ( limit + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> queue = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ u ] . append ( ( v , a , b ) ) <NEWLINE> path [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> coin . append ( ( c , d ) ) <NEWLINE> <NL> <DEDENT> time [ 1 ] [ s ] = 0 <NEWLINE> heapq . heappush ( queue , ( 0 , 1 , s ) ) <NEWLINE> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> t , v , c = heapq . heappop ( queue ) <NEWLINE> for nv , na , nb in path [ v ] : <NEWLINE> <INDENT> if na > c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif time [ nv ] [ c - na ] <= t + nb : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time [ nv ] [ c - na ] = t + nb <NEWLINE> heapq . heappush ( queue , ( t + nb , nv , c - na ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> nc = min ( c + coin [ v ] [ 0 ] , limit ) <NEWLINE> nt = t + coin [ v ] [ 1 ] <NEWLINE> if time [ v ] [ nc ] <= nt : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time [ v ] [ nc ] = nt <NEWLINE> heapq . heappush ( queue , ( nt , v , nc ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( min ( time [ i ] ) ) <NEWLINE> <DEDENT>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for j in range ( A ) : <NEWLINE> <INDENT> if B != [ ] : B . pop ( ) <NEWLINE> <DEDENT> print ( sum ( B ) ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> A , B , C = sorted ( A ) , sorted ( B ) , sorted ( C ) <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> mf = math . floor <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> i = n <NEWLINE> <DEDENT> elif n >= b : <NEWLINE> <INDENT> i = b - 1 <NEWLINE> <DEDENT> c = mf ( a * i / b ) - a * mf ( i / b ) <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> count = 0 <NEWLINE> m = 0 <NEWLINE> G = [ ] <NEWLINE> <NL> def insertion_sort ( A , N , g ) : <NEWLINE> <INDENT> global count <NEWLINE> for i in range ( g , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> count += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def shell_sort ( A , N ) : <NEWLINE> <INDENT> global m , G <NEWLINE> m = math . floor ( math . log ( 2 * N + 1 , 3 ) ) <NEWLINE> G = [ int ( ( pow ( 3 , i ) - 1 ) / 2 ) for i in range ( m , 0 , - 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> insertion_sort ( A , N , G [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> shell_sort ( A , n ) <NEWLINE> <NL> print ( m ) <NEWLINE> print ( <STRING> . join ( [ str ( h ) for h in G ] ) ) <NEWLINE> print ( count ) <NEWLINE> for x in A : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> p = sum ( A ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> p -= A [ j ] <NEWLINE> B . append ( p % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> count += ( A [ i ] * B [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( count % ( 10 ** 9 + 7 ) ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( n % bin ( n ) . count ( <STRING> ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> p = X . count ( <STRING> ) <NEWLINE> rem_plus = 0 <NEWLINE> rem_minus = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = N - i - 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif p > 1 : <NEWLINE> <INDENT> rem_minus = ( rem_minus + pow ( 2 , k , p - 1 ) ) % ( p - 1 ) <NEWLINE> <DEDENT> rem_plus = ( rem_plus + pow ( 2 , k , p + 1 ) ) % ( p + 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> k = N - i - 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( f ( ( rem_plus + pow ( 2 , k , p + 1 ) ) % ( p + 1 ) ) + 1 ) <NEWLINE> <DEDENT> elif p > 1 : <NEWLINE> <INDENT> print ( f ( ( rem_minus - pow ( 2 , k , p - 1 ) ) % ( p - 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( p [ 0 : K ] ) <NEWLINE> s = ans <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> s += p [ i + K - 1 ] - p [ i - 1 ] <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> print ( ans / 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> num = 1 <NEWLINE> n = 7 <NEWLINE> <NL> if ( k % 2 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if ( n % k == 0 ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = ( n * 10 + 7 ) % k <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def read_int ( ) : <NEWLINE> <INDENT> l = sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( <STRING> ) <NEWLINE> return int ( l [ 0 ] ) <NEWLINE> <NL> <DEDENT> def read_int_list ( ) : <NEWLINE> <INDENT> l = sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( <STRING> ) <NEWLINE> return [ int ( i ) for i in l ] <NEWLINE> <NL> <DEDENT> N , M , K = tuple ( read_int_list ( ) ) <NEWLINE> A = read_int_list ( ) <NEWLINE> B = read_int_list ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum_k = 0 <NEWLINE> <NL> ai = 0 <NEWLINE> bi = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if sum_k + A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum_k += A [ i ] <NEWLINE> ai = i + 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> if sum_k + B [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum_k += B [ i ] <NEWLINE> bi = i + 1 <NEWLINE> <NL> <DEDENT> ans = ai + bi <NEWLINE> <NL> for i in range ( ai - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum_k -= A [ i ] <NEWLINE> ai = i <NEWLINE> while bi < len ( B ) and sum_k + B [ bi ] <= K : <NEWLINE> <INDENT> sum_k += B [ bi ] <NEWLINE> bi += 1 <NEWLINE> <DEDENT> ans = max ( ans , ai + bi ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> p = 1 <NEWLINE> c = 0 <NEWLINE> l = 0 <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> if p > 1000000000000000000 : <NEWLINE> <INDENT> l = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p *= a [ i ] <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif l == 1 or p > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> l = int ( math . sqrt ( N ) ) <NEWLINE> <NL> for i in range ( 1 , l ) : <NEWLINE> <INDENT> for j in range ( 1 , l ) : <NEWLINE> <INDENT> for k in range ( 1 , l ) : <NEWLINE> <INDENT> a = ( i + j + k ) ** 2 - ( i * j + j * k + k * i ) <NEWLINE> if a <= N : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
def prod ( li , MOD ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for a in li : <NEWLINE> <INDENT> ret *= a <NEWLINE> ret %= MOD <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 1_000_000_007 <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == K : <NEWLINE> <INDENT> print ( prod ( aaa , MOD ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> aaa . sort ( key = lambda x : abs ( x ) ) <NEWLINE> if sum ( a < 0 for a in aaa [ - K : ] ) % 2 == 0 : <NEWLINE> <INDENT> print ( prod ( aaa [ - K : ] , MOD ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if all ( a <= 0 for a in aaa ) : <NEWLINE> <INDENT> bbb = aaa [ : K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 = min ( [ a for a in aaa [ - K : ] if a > 0 ] ) , min ( [ a for a in aaa [ : - K ] if a < 0 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> x1 , y1 = 1 , 0 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> x2 , y2 = max ( [ a for a in aaa [ - K : ] if a < 0 ] ) , max ( [ a for a in aaa [ : - K ] if a >= 0 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> x2 , y2 = 1 , 0 <NEWLINE> <DEDENT> bbb = aaa [ - K : ] <NEWLINE> if abs ( x2 * y1 ) > abs ( x1 * y2 ) : <NEWLINE> <INDENT> bbb . remove ( x1 ) <NEWLINE> bbb . append ( y1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bbb . remove ( x2 ) <NEWLINE> bbb . append ( y2 ) <NEWLINE> <DEDENT> <DEDENT> print ( prod ( bbb , MOD ) ) <NEWLINE> <DEDENT>
T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> base = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> temp = A [ - i ] <NEWLINE> for x in base : <NEWLINE> <INDENT> temp = min ( temp , temp ^ x ) <NEWLINE> <DEDENT> if temp != 0 : <NEWLINE> <INDENT> if S [ - i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> base . append ( temp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if ( len ( s ) < 5 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = [ 0 ] * 2019 <NEWLINE> t [ 0 ] = 1 <NEWLINE> p = 0 <NEWLINE> temp = 0 <NEWLINE> temp2 = 1 <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> temp2 *= 10 <NEWLINE> temp2 %= 2019 <NEWLINE> t [ ( temp + temp2 * int ( s [ - i ] ) ) % 2019 ] += 1 <NEWLINE> temp += temp2 * int ( s [ - i ] ) <NEWLINE> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> p += ( t [ i ] * ( t [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> S = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for d in range ( D ) ] ) <NEWLINE> <NL> L = np . empty ( 26 , int ) <NEWLINE> L [ : ] = - 1 <NEWLINE> <NL> X = [ [ - 1 ] for _ in range ( 26 ) ] <NEWLINE> T = [ ] <NEWLINE> <NL> score = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> t = int ( input ( ) ) - 1 <NEWLINE> T . append ( t ) <NEWLINE> L [ t ] = d <NEWLINE> score += S [ d , t ] - np . dot ( C , d - L ) <NEWLINE> X [ t ] . append ( d ) <NEWLINE> <NL> <DEDENT> for x in X : <NEWLINE> <INDENT> x . append ( D ) <NEWLINE> <NL> <DEDENT> M = int ( input ( ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> d , q = map ( int , input ( ) . split ( ) ) <NEWLINE> d -= 1 <NEWLINE> q -= 1 <NEWLINE> <NL> t = T [ d ] <NEWLINE> T [ d ] = q <NEWLINE> <NL> i = bisect_left ( X [ t ] , d ) <NEWLINE> d_prev = X [ t ] [ i - 1 ] <NEWLINE> d_next = X [ t ] [ i + 1 ] <NEWLINE> <NL> dd = d - d_prev - 1 <NEWLINE> score += C [ t ] * ( dd + 1 ) * dd // 2 <NEWLINE> dd = d_next - d - 1 <NEWLINE> score += C [ t ] * ( dd + 1 ) * dd // 2 <NEWLINE> dd = d_next - d_prev - 1 <NEWLINE> score -= C [ t ] * ( dd + 1 ) * dd // 2 <NEWLINE> <NL> X [ t ] . pop ( i ) <NEWLINE> <NL> i = bisect_left ( X [ q ] , d ) <NEWLINE> d_prev = X [ q ] [ i - 1 ] <NEWLINE> d_next = X [ q ] [ i ] <NEWLINE> <NL> dd = d - d_prev - 1 <NEWLINE> score -= C [ q ] * ( dd + 1 ) * dd // 2 <NEWLINE> dd = d_next - d - 1 <NEWLINE> score -= C [ q ] * ( dd + 1 ) * dd // 2 <NEWLINE> dd = d_next - d_prev - 1 <NEWLINE> score += C [ q ] * ( dd + 1 ) * dd // 2 <NEWLINE> <NL> X [ q ] . insert ( i , d ) <NEWLINE> <NL> score += S [ d , q ] - S [ d , t ] <NEWLINE> <NL> print ( score ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ k for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> A [ t - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] - q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
roadcnt , money = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> while True : <NEWLINE> <INDENT> road = [ ] <NEWLINE> for r in range ( roadcnt ) : <NEWLINE> <INDENT> road . append ( [ int ( n ) for n in input ( ) . split ( <STRING> ) ] ) <NEWLINE> <DEDENT> road = sorted ( road , key = lambda x : x [ 1 ] ) <NEWLINE> while money > 0 and len ( road ) > 0 : <NEWLINE> <INDENT> if road [ - 1 ] [ 0 ] - money < 0 : <NEWLINE> <INDENT> money -= road [ - 1 ] [ 0 ] <NEWLINE> road . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> road [ - 1 ] [ 0 ] -= money <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ro in road : <NEWLINE> <INDENT> ans += ro [ 0 ] * ro [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> roadcnt , money = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> if roadcnt == 0 and money == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> <NL> nox = [ ] <NEWLINE> idxs = [ ] <NEWLINE> ans = 0 <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> if c != <STRING> : <NEWLINE> <INDENT> nox . append ( c ) <NEWLINE> idxs . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if nox != nox [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( nox ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( nox ) % 2 == 0 : <NEWLINE> <INDENT> left = len ( nox ) // 2 - 1 <NEWLINE> right = len ( nox ) // 2 <NEWLINE> <NL> left_idx = idxs [ left ] <NEWLINE> right_idx = idxs [ right ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> center = len ( nox ) // 2 <NEWLINE> left_idx = idxs [ center ] <NEWLINE> right_idx = idxs [ center ] <NEWLINE> <NL> <DEDENT> while not ( left_idx == 0 and right_idx == N - 1 ) : <NEWLINE> <INDENT> if s [ left_idx ] == s [ right_idx ] : <NEWLINE> <INDENT> if left_idx > 0 and right_idx < N - 1 : <NEWLINE> <INDENT> left_idx -= 1 <NEWLINE> right_idx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if left_idx <= idxs [ 0 ] and right_idx >= idxs [ - 1 ] and ( left_idx > 0 or right_idx < N - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if left_idx > 0 : <NEWLINE> <INDENT> left_idx -= 1 <NEWLINE> <DEDENT> if right_idx < N - 1 : <NEWLINE> <INDENT> right_idx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif s [ left_idx ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if left_idx > 0 : <NEWLINE> <INDENT> left_idx -= 1 <NEWLINE> <DEDENT> <DEDENT> elif s [ right_idx ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if right_idx < N - 1 : <NEWLINE> <INDENT> right_idx += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in B : <NEWLINE> <INDENT> B [ i ] = 0 <NEWLINE> <DEDENT> B [ i ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
H = [ ] <NEWLINE> W = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H . append ( x ) <NEWLINE> W . append ( y ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> for j in range ( H [ i ] ) : <COMMENT> <NEWLINE> <INDENT> if j + 1 == H [ i ] : <NEWLINE> <INDENT> print ( W [ i ] * <STRING> + <STRING> ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W [ i ] * <STRING> ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> n = min ( b - 1 , n ) <NEWLINE> <NL> print ( ( a * n ) // b - a * ( n // b ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> mincost = [ None ] * n <NEWLINE> <NL> def cost ( n , h ) : <NEWLINE> <INDENT> if ( mincost [ n - 1 ] is not None ) : <NEWLINE> <INDENT> return mincost [ n - 1 ] <NEWLINE> <DEDENT> elif ( n == 1 ) : <NEWLINE> <INDENT> mincost [ n - 1 ] = 0 <NEWLINE> <DEDENT> elif ( n == 2 ) : <NEWLINE> <INDENT> mincost [ n - 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mincost [ n - 1 ] = min ( cost ( n - 1 , h ) + abs ( h [ n - 1 ] - h [ n - 2 ] ) , cost ( n - 2 , h ) + abs ( h [ n - 1 ] - h [ n - 3 ] ) ) <NEWLINE> <DEDENT> return mincost [ n - 1 ] <NEWLINE> <NL> <DEDENT> h = [ None ] * n <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( cost ( n , h ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) ; <NEWLINE> i = 0 ; <NEWLINE> if n == k : <NEWLINE> <INDENT> print ( 0 ) ; <NEWLINE> <DEDENT> elif n < k : <NEWLINE> <INDENT> print ( min ( n , k - n ) ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = ( n - k ) % k ; <NEWLINE> if v * 2 >= k : <NEWLINE> <INDENT> print ( k - v ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v ) ; <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( N - K ) : <NEWLINE> <INDENT> if A [ j + K ] > A [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> zyunban = [ 0 ] * n <NEWLINE> t = 1 <NEWLINE> <NL> for x in an : <NEWLINE> <INDENT> zyunban [ x - 1 ] = t <NEWLINE> t += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> zyunban = list ( map ( str , zyunban ) ) <NEWLINE> <NL> print ( <STRING> . join ( zyunban ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if N == 3 : <NEWLINE> <INDENT> print ( a [ 0 ] + a [ 1 ] ) <NEWLINE> <DEDENT> ans1 = 2 * sum ( a [ 0 : N // 2 ] ) - a [ 0 ] <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> if N % 2 == 1 and N != 3 : <NEWLINE> <INDENT> print ( ans1 + a [ N // 2 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> s = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if s < 3 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = s // 3 <NEWLINE> q = s % 3 <NEWLINE> if q == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif q == 1 : <NEWLINE> <INDENT> ans += p <NEWLINE> <DEDENT> elif q == 2 : <NEWLINE> <INDENT> if p == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += p + math . factorial ( p ) // ( math . factorial ( p - 2 ) * math . factorial ( 2 ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , p ) : <NEWLINE> <INDENT> ans += math . factorial ( ( s - 3 * ( p - i ) ) + ( p - i - 1 ) ) // ( math . factorial ( ( s - 3 * ( p - i ) ) ) * math . factorial ( p - i - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ss = set ( list ( S ) ) <NEWLINE> st = set ( list ( T ) ) <NEWLINE> if not ( st <= ss ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> alpha = { chr ( 97 + i ) : [ ] for i in range ( 26 ) } <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> alpha [ s ] . append ( i + 1 ) <NEWLINE> <DEDENT> n = len ( S ) <NEWLINE> now = 0 <NEWLINE> ans = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if alpha [ t ] [ - 1 ] <= now : <NEWLINE> <INDENT> ans += ( n - now ) + alpha [ t ] [ 0 ] <NEWLINE> now = alpha [ t ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = bisect_left ( alpha [ t ] , now + 1 ) <NEWLINE> ans += alpha [ t ] [ i ] - now <NEWLINE> now = alpha [ t ] [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> tree = { n : { } for n in range ( N ) } <NEWLINE> children = set ( ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> inp = [ int ( m ) for m in input ( ) . split ( ) ] <NEWLINE> tree [ inp [ 0 ] ] [ <STRING> ] = inp [ 2 : ] <NEWLINE> children . update ( inp [ 2 : ] ) <NEWLINE> <NL> <DEDENT> parent = set ( [ n for n in range ( N ) ] ) . difference ( children ) . pop ( ) <NEWLINE> tree [ parent ] [ <STRING> ] = 0 <NEWLINE> tree [ parent ] [ <STRING> ] = - 1 <NEWLINE> <NL> siblings = tree [ parent ] [ <STRING> ] <NEWLINE> for c in siblings : <NEWLINE> <INDENT> tree [ c ] [ <STRING> ] = 1 <NEWLINE> tree [ c ] [ <STRING> ] = parent <NEWLINE> <NL> <DEDENT> depth = 2 <NEWLINE> while len ( children ) : <NEWLINE> <INDENT> children = children . difference ( siblings ) <NEWLINE> next_gen = [ ] <NEWLINE> for s in siblings : <NEWLINE> <INDENT> next_gen . extend ( tree [ s ] [ <STRING> ] ) <NEWLINE> for c in tree [ s ] [ <STRING> ] : <NEWLINE> <INDENT> tree [ c ] [ <STRING> ] = depth <NEWLINE> tree [ c ] [ <STRING> ] = s <NEWLINE> <DEDENT> <DEDENT> siblings = next_gen <NEWLINE> depth += 1 <NEWLINE> <NL> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if tree [ n ] [ <STRING> ] == 0 : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> elif tree [ n ] [ <STRING> ] == [ ] : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ n ] [ <STRING> ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( n , tree [ n ] [ <STRING> ] , tree [ n ] [ <STRING> ] , tree [ n ] [ <STRING> ] , tree [ n ] [ <STRING> ] ) ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( A [ K - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> point [ a ] += b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> point [ next ] += point [ now ] <NEWLINE> <COMMENT> <NL> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> big = 10 ** 18 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ans == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans *= a <NEWLINE> if ans > big : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> num_li = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> c = collections . Counter ( li ) <NEWLINE> <NL> li_sum = sum ( li ) <NEWLINE> <NL> for i , j in num_li : <NEWLINE> <INDENT> s = 0 <NEWLINE> if i in c : <NEWLINE> <INDENT> cnt = c . pop ( i ) <NEWLINE> c [ j ] += cnt <NEWLINE> li_sum = li_sum - ( i * cnt ) + ( j * cnt ) <NEWLINE> <DEDENT> print ( li_sum ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = { 0 : 0 , 1 : 300000 , 2 : 200000 , 3 : 100000 } <NEWLINE> if a > 3 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a <NEWLINE> <DEDENT> if b > 3 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = b <NEWLINE> <DEDENT> if x == 1 and y == 1 : <NEWLINE> <INDENT> ans = 1000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lst [ x ] + lst [ y ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += y * ( y + 1 ) * i / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
H , W = input ( ) . split ( <STRING> ) <NEWLINE> H = int ( H ) <NEWLINE> W = int ( W ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> print ( a ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> out = 0 <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> combi = list ( permutations ( [ <STRING> , <STRING> , <STRING> ] , 3 ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( n - i * 2 ) : <NEWLINE> <INDENT> if ( s [ j ] , s [ j + i ] , s [ j + i * 2 ] ) in combi : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> table = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for l in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> table [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> k = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> output = <STRING> . join ( map ( str , table [ i ] [ j ] ) ) <NEWLINE> print ( <STRING> % output ) <NEWLINE> <DEDENT> if k < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> kabu = 0 <NEWLINE> money = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if al [ i ] < al [ i + 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> money += kabu * al [ i ] <NEWLINE> kabu = 0 <NEWLINE> <COMMENT> <NL> kabu += money // al [ i ] <NEWLINE> money = money % al [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> money += kabu * al [ i ] <NEWLINE> kabu = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money + kabu * al [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> counter = [ 0 ] * N <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * N <NEWLINE> <NL> def dfs ( v , seen , G , counter ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> if not seen [ u ] : <NEWLINE> <INDENT> counter [ u ] += counter [ v ] <NEWLINE> dfs ( u , seen , G , counter ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , seen , G , counter ) <NEWLINE> <NL> for c in counter : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> counter = [ 0 for _ in range ( n ) ] <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> counter [ int ( i ) - 1 ] += 1 <NEWLINE> <DEDENT> for j in counter : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k <= n : <NEWLINE> <INDENT> takahashi = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> takahashi = a [ takahashi ] - 1 <NEWLINE> <DEDENT> print ( takahashi + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = 0 <NEWLINE> takahashi = start <NEWLINE> trajectory = [ takahashi ] <NEWLINE> loop_start = - 1 <NEWLINE> loop_end = - 1 <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> takahashi = a [ takahashi ] - 1 <NEWLINE> if visited [ takahashi ] : <NEWLINE> <INDENT> loop_start = trajectory . index ( takahashi ) <NEWLINE> break <NEWLINE> <DEDENT> visited [ takahashi ] = True <NEWLINE> trajectory . append ( takahashi ) <NEWLINE> <DEDENT> print ( trajectory [ loop_start : ] [ ( k - loop_start ) % ( i + 1 - loop_start ) ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 2 ) : nums [ i - 1 ] = abs ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <NL> ans = sum ( nums ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans - nums [ i - 1 ] - nums [ i ] + abs ( a [ i + 1 ] - a [ i - 1 ] ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K <= A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K > A and K <= A + B : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> ans = 0 <NEWLINE> import bisect <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> y = bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += x * ( n - y ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def power ( x , y , p ) : <NEWLINE> <INDENT> if y == 0 : return 1 % p <NEWLINE> res = 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> x = x % p <NEWLINE> <NL> if ( x == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> while ( y > 0 ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( ( y & 1 ) == 1 ) : <NEWLINE> <INDENT> res = ( res * x ) % p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> y = y >> 1 <COMMENT> <NEWLINE> x = ( x * x ) % p <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> F = [ 0 , 1 , 1 ] <NEWLINE> for i in range ( 3 , 200001 ) : <NEWLINE> <INDENT> F += [ 1 + F [ i % ( bin ( i ) . count ( <STRING> ) ) ] ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ones = s . count ( <STRING> ) <NEWLINE> a = ones - 1 <NEWLINE> b = ones <NEWLINE> c = ones + 1 <NEWLINE> moda = modb = modc = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> pos = n - 1 - i <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a > 0 : moda = ( moda + power ( 2 , pos , a ) ) % a <NEWLINE> modc = ( modc + power ( 2 , pos , c ) ) % c <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> add = power ( 2 , n - 1 - i , c ) <NEWLINE> ans = ( modc + add ) % c <NEWLINE> <COMMENT> <NL> print ( F [ ans ] + 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if a <= 0 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> sub = power ( 2 , n - 1 - i , a ) <NEWLINE> ans = ( moda - sub ) % a <NEWLINE> print ( F [ ans ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def readString ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <DEDENT> def readInteger ( ) : <NEWLINE> <INDENT> return int ( readString ( ) ) <NEWLINE> <NL> <DEDENT> def readStringSet ( n ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . split ( <STRING> ) [ : n ] <NEWLINE> <NL> <DEDENT> def readIntegerSet ( n ) : <NEWLINE> <INDENT> return list ( map ( int , readStringSet ( n ) ) ) <NEWLINE> <NL> <DEDENT> def readIntegerMatrix ( n , m ) : <NEWLINE> <INDENT> return reduce ( lambda acc , _ : acc + [ readIntegerSet ( m ) ] , range ( 0 , n ) , [ ] ) <NEWLINE> <NL> <DEDENT> def main ( N , X , M ) : <NEWLINE> <INDENT> A = X <NEWLINE> m = { A : A } <NEWLINE> i = - 1 <NEWLINE> for j in range ( 1 , M ) : <NEWLINE> <INDENT> A = ( A * A ) % M if M > 0 else 0 <NEWLINE> if A in m : <NEWLINE> <INDENT> i = list ( m . keys ( ) ) . index ( A ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ A ] = A <NEWLINE> <NL> <DEDENT> <DEDENT> if i == - 1 : <NEWLINE> <INDENT> return sum ( m . values ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = list ( m . values ( ) ) <NEWLINE> s1 = sum ( l [ : i ] ) <NEWLINE> len_repeat = len ( l ) - i <NEWLINE> s2 = sum ( l [ i : ] ) <NEWLINE> <NL> return s1 + int ( ( N - i ) / len_repeat ) * s2 + sum ( l [ i : ( N - i ) % len_repeat + i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _N , _X , _M = readIntegerSet ( 3 ) <NEWLINE> <NL> print ( main ( _N , _X , _M ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mul = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> mul = 0 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> mul *= i <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ None ] * n <NEWLINE> all = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> all = all ^ a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = str ( all ^ a [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , s ) : <NEWLINE> <INDENT> self . s = [ 0 for _ in range ( 6 ) ] <NEWLINE> self . s [ 0 ] = s [ 0 ] <NEWLINE> self . s [ 1 ] = s [ 1 ] <NEWLINE> self . s [ 2 ] = s [ 2 ] <NEWLINE> self . s [ 3 ] = s [ 3 ] <NEWLINE> self . s [ 4 ] = s [ 4 ] <NEWLINE> self . s [ 5 ] = s [ 5 ] <NEWLINE> <NL> <DEDENT> def roll ( self , direction ) : <COMMENT> <NEWLINE> <INDENT> temp = self . s [ 0 ] <NEWLINE> if direction == <STRING> : <NEWLINE> <INDENT> self . s [ 0 ] = self . s [ 3 ] <NEWLINE> self . s [ 3 ] = self . s [ 5 ] <NEWLINE> self . s [ 5 ] = self . s [ 2 ] <NEWLINE> self . s [ 2 ] = temp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . s [ 0 ] = self . s [ 1 ] <NEWLINE> self . s [ 1 ] = self . s [ 5 ] <NEWLINE> self . s [ 5 ] = self . s [ 4 ] <NEWLINE> self . s [ 4 ] = temp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . s [ 0 ] = self . s [ 4 ] <NEWLINE> self . s [ 4 ] = self . s [ 5 ] <NEWLINE> self . s [ 5 ] = self . s [ 1 ] <NEWLINE> self . s [ 1 ] = temp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . s [ 0 ] = self . s [ 2 ] <NEWLINE> self . s [ 2 ] = self . s [ 5 ] <NEWLINE> self . s [ 5 ] = self . s [ 3 ] <NEWLINE> self . s [ 3 ] = temp <NEWLINE> <NL> <DEDENT> <DEDENT> def setposition ( self , a , b ) : <NEWLINE> <INDENT> for _ in range ( 6 ) : <NEWLINE> <INDENT> if self . s [ 0 ] == a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . roll ( <STRING> ) <NEWLINE> if self . s [ 0 ] == a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> for _ in range ( 6 ) : <NEWLINE> <INDENT> if self . s [ 1 ] == b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . roll ( <STRING> ) <NEWLINE> self . roll ( <STRING> ) <NEWLINE> self . roll ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice1 = Dice ( s ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice2 = Dice ( s ) <NEWLINE> <NL> answer = <STRING> <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice1 . roll ( <STRING> ) <NEWLINE> dice1 . roll ( <STRING> ) <NEWLINE> dice1 . roll ( <STRING> ) <NEWLINE> if dice1 . s == dice2 . s : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> <DEDENT> dice1 . roll ( <STRING> ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice1 . roll ( <STRING> ) <NEWLINE> dice1 . roll ( <STRING> ) <NEWLINE> dice1 . roll ( <STRING> ) <NEWLINE> if dice1 . s == dice2 . s : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> <DEDENT> dice1 . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> result [ a - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , result ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g = n // i <NEWLINE> ans += i * ( g * ( g + 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = s . split ( ) <NEWLINE> n = [ ] <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> n . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> isSorted = False <NEWLINE> <NL> while ( not isSorted ) : <NEWLINE> <INDENT> isSorted = True <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if n [ i ] < n [ i + 1 ] : <NEWLINE> <INDENT> temp = n [ i ] <NEWLINE> n [ i ] = n [ i + 1 ] <NEWLINE> n [ i + 1 ] = temp <NEWLINE> isSorted = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n [ 0 ] , n [ 1 ] , n [ 2 ] , n [ 3 ] , n [ 4 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> py = [ list ( map ( int , input ( ) . split ( ) ) ) + [ i ] for i in range ( M ) ] <NEWLINE> py . sort ( ) <NEWLINE> P = py [ 0 ] [ 0 ] <NEWLINE> c = 0 <NEWLINE> ans = [ ] <NEWLINE> for p , y , i in py : <NEWLINE> <INDENT> if p == P : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = p <NEWLINE> c = 1 <NEWLINE> <DEDENT> ansc = str ( c ) <NEWLINE> ansp = str ( p ) <NEWLINE> anser = <STRING> * ( 6 - len ( ansp ) ) + ansp + <STRING> * ( 6 - len ( ansc ) ) + ansc <NEWLINE> ans . append ( [ i , anser ] ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> for i , anser in ans : <NEWLINE> <INDENT> print ( anser ) <NEWLINE> <DEDENT>
def solve ( n , a , b , c , s_ls ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = s_ls [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> return False , [ ] <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> elif a == b == 1 and c == 0 : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex = s_ls [ i + 1 ] <NEWLINE> if nex == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> return False , [ ] <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> elif c == b == 1 and a == 0 : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex = s_ls [ i + 1 ] <NEWLINE> if nex == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c >= b : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> return False , [ ] <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif a == c == 1 and b == 0 : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex = s_ls [ i + 1 ] <NEWLINE> if nex == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True , ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s_ls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s_ls . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> res , ans = solve ( n , a , b , c , s_ls ) <NEWLINE> if not res : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> DP = [ 0 ] * ( S + 1 ) <NEWLINE> Mod = 10 ** 9 + 7 <NEWLINE> if S >= 3 : <NEWLINE> <INDENT> DP [ 0 ] = 1 <NEWLINE> DP [ 1 ] = 0 <NEWLINE> DP [ 2 ] = 0 <NEWLINE> for TS in range ( 3 , S + 1 ) : <NEWLINE> <INDENT> DP [ TS ] = ( DP [ TS - 1 ] + DP [ TS - 3 ] ) % Mod <NEWLINE> <DEDENT> print ( DP [ S ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_s = sum ( a ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b = a [ i ] <NEWLINE> a_s -= b <NEWLINE> s += b * ( a_s ) <NEWLINE> s %= mod <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> accumls = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> accumls . append ( accumls [ - 1 ] + ls [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += ls [ i ] * ( accumls [ - 1 ] - accumls [ i + 1 ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from typing import NoReturn <NEWLINE> <NL> <NL> def my_sum ( start : int , end : int ) : <NEWLINE> <INDENT> if start < 0 : <NEWLINE> <INDENT> return my_sum ( 1 - start , end ) <NEWLINE> <DEDENT> elif start > 1 : <NEWLINE> <INDENT> return my_sum ( 1 , end ) - my_sum ( 1 , start - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return end * ( end + 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) -> NoReturn : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> p : int = 10 ** 9 + 7 <NEWLINE> <NL> answer = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> min_val : int = my_sum ( 0 , i - 1 ) <NEWLINE> max_val : int = my_sum ( n - i + 1 , n ) <NEWLINE> answer += max_val - min_val + 1 <NEWLINE> <NL> <DEDENT> print ( answer % p ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> c1 = { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } <NEWLINE> c2 = { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } <NEWLINE> c3 = { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } <NEWLINE> c4 = { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> if int ( b ) == 1 : <NEWLINE> <INDENT> c1 [ int ( f ) ] [ int ( r ) - 1 ] = c1 [ int ( f ) ] [ int ( r ) - 1 ] + int ( v ) <NEWLINE> <DEDENT> elif int ( b ) == 2 : <NEWLINE> <INDENT> c2 [ int ( f ) ] [ int ( r ) - 1 ] = c2 [ int ( f ) ] [ int ( r ) - 1 ] + int ( v ) <NEWLINE> <DEDENT> elif int ( b ) == 3 : <NEWLINE> <INDENT> c3 [ int ( f ) ] [ int ( r ) - 1 ] = c3 [ int ( f ) ] [ int ( r ) - 1 ] + int ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c4 [ int ( f ) ] [ int ( r ) - 1 ] = c4 [ int ( f ) ] [ int ( r ) - 1 ] + int ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in ( 1 , 2 , 3 ) : <NEWLINE> <INDENT> result = <STRING> + str ( c1 [ i ] [ 0 ] ) <NEWLINE> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> result = result + <STRING> + str ( c1 [ i ] [ j ] ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ( 1 , 2 , 3 ) : <NEWLINE> <INDENT> result = <STRING> + str ( c2 [ i ] [ 0 ] ) <NEWLINE> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> result = result + <STRING> + str ( c2 [ i ] [ j ] ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ( 1 , 2 , 3 ) : <NEWLINE> <INDENT> result = <STRING> + str ( c3 [ i ] [ 0 ] ) <NEWLINE> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> result = result + <STRING> + str ( c3 [ i ] [ j ] ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ( 1 , 2 , 3 ) : <NEWLINE> <INDENT> result = <STRING> + str ( c4 [ i ] [ 0 ] ) <NEWLINE> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> result = result + <STRING> + str ( c4 [ i ] [ j ] ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> L_2 = 2 <NEWLINE> L_1 = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L = L_1 + L_2 <NEWLINE> L_2 = L_1 <NEWLINE> L_1 = L <NEWLINE> <DEDENT> print ( L ) <NEWLINE>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> g = deque ( ) <NEWLINE> p = deque ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> a = 0 <NEWLINE> if len ( g ) > 0 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( p ) > 0 and p [ - 1 ] [ 0 ] > g [ - 1 ] : <NEWLINE> <INDENT> a += p [ - 1 ] [ 1 ] <NEWLINE> p . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> a += i - g [ - 1 ] <NEWLINE> p . append ( [ g [ - 1 ] , a ] ) <NEWLINE> g . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> p [ i ] = p [ i ] [ 1 ] <NEWLINE> <DEDENT> if len ( p ) > 0 : <NEWLINE> <INDENT> print ( sum ( p ) ) <NEWLINE> print ( len ( p ) , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , p ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> out = [ 0 ] * int ( n ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for a_i in a : <NEWLINE> <INDENT> a_i = int ( a_i ) <NEWLINE> out [ a_i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for out_i in out : <NEWLINE> <INDENT> print ( out_i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( [ b , i ] ) <NEWLINE> graph [ b ] . append ( [ a , i ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n - 1 ) <NEWLINE> <NL> q = deque ( [ [ 1 , 0 , 0 ] ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v , pcol , root = q . popleft ( ) <NEWLINE> cnt = 1 <NEWLINE> for node in graph [ v ] : <NEWLINE> <INDENT> if node [ 0 ] == root : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt == pcol : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans [ node [ 1 ] ] = cnt <NEWLINE> q . append ( [ node [ 0 ] , cnt , v ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> D = [ ] <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> D . append ( S [ i ] ) <NEWLINE> <DEDENT> D . append ( <STRING> ) <NEWLINE> P = <STRING> . join ( D ) <NEWLINE> print ( P ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from math import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readTuples ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> H , W , M = readInts ( ) <NEWLINE> <NL> dic1 = Counter ( ) <NEWLINE> dic2 = Counter ( ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> dic1 [ h ] += 1 <NEWLINE> dic2 [ w ] += 1 <NEWLINE> s . add ( ( h , w ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for h , w in s : <NEWLINE> <INDENT> ans = max ( ans , dic1 [ h ] + dic2 [ w ] - 1 ) <NEWLINE> <NL> <DEDENT> dic1 = dic1 . most_common ( ) <NEWLINE> dic2 = dic2 . most_common ( ) <NEWLINE> max1 = dic1 [ 0 ] [ 1 ] <NEWLINE> max2 = dic2 [ 0 ] [ 1 ] <NEWLINE> <NL> for k1 , v1 in dic1 : <NEWLINE> <INDENT> if v1 < max1 : <NEWLINE> <INDENT> break <COMMENT> <NEWLINE> <DEDENT> for k2 , v2 in dic2 : <NEWLINE> <INDENT> if v2 < max2 : <NEWLINE> <INDENT> break <COMMENT> <NEWLINE> <DEDENT> if ( k1 , k2 ) in s : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> ans = max ( ans , v1 + v2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> li = [ abs ( hc [ i ] - hc [ j ] ) + dp [ j ] for j in range ( max ( i - K , 0 ) , i ) ] <NEWLINE> dp [ i ] = min ( li ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> def bfs ( graph , N , start ) : <NEWLINE> <INDENT> visited = [ 0 ] * N <NEWLINE> visited [ start ] = 1 <NEWLINE> que = deque ( [ start ] ) <NEWLINE> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> for n in graph [ node ] : <NEWLINE> <INDENT> if not visited [ n ] : <NEWLINE> <INDENT> visited [ n ] = node + 1 <NEWLINE> que . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> visited = bfs ( graph , N , 0 ) [ 1 : ] <NEWLINE> if all ( visited ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * visited , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def BinarySearch ( n , S , t ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> left = 0 <NEWLINE> right = n - 1 <NEWLINE> <NL> while left <= right : <NEWLINE> <INDENT> center = ( left + right ) // 2 <NEWLINE> <NL> if t > S [ center ] : <NEWLINE> <INDENT> left = center + 1 <NEWLINE> <DEDENT> elif t < S [ center ] : <NEWLINE> <INDENT> right = center - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return center <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> T = [ int ( t ) for t in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for t in T : <NEWLINE> <INDENT> if BinarySearch ( n , S , t ) != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ k + i ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = list ( set ( A ) ) <NEWLINE> <NL> if len ( B ) % 2 == 0 : <NEWLINE> <INDENT> print ( len ( B ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( B ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> str_list = [ ] <NEWLINE> count = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> str_list . append ( s ) <NEWLINE> <DEDENT> str_list . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if str_list [ i ] != str_list [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = n // j <NEWLINE> ans += a * ( a + 1 ) * j // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hl = [ 0 ] * h <NEWLINE> wl = [ 0 ] * w <NEWLINE> dic = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dic . add ( ( x , y ) ) <NEWLINE> hl [ x - 1 ] += 1 <NEWLINE> wl [ y - 1 ] += 1 <NEWLINE> <NL> <DEDENT> h_max = max ( hl ) <NEWLINE> r = [ i for i in range ( h ) if hl [ i ] == h_max ] <NEWLINE> w_max = max ( wl ) <NEWLINE> c = [ i for i in range ( w ) if wl [ i ] == w_max ] <NEWLINE> <NL> flg = 0 <NEWLINE> for rc in r : <NEWLINE> <INDENT> for cc in c : <NEWLINE> <INDENT> if ( rc + 1 , cc + 1 ) not in dic : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( num ) : <NEWLINE> <INDENT> if num % ( x + 1 ) == 0 : ans += num // ( x + 1 ) - 1 <NEWLINE> else : ans += num // ( x + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s1 = [ ] <NEWLINE> s2 = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> s1 . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( s1 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sum ( s1 ) % 10 == 0 : <NEWLINE> <INDENT> print ( sum ( s1 ) - min ( s1 ) + sum ( s2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( s1 ) + sum ( s2 ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = input ( ) . split ( ) <NEWLINE> n = int ( N [ 0 ] ) <NEWLINE> m = int ( N [ 1 ] ) <NEWLINE> way = np . zeros ( n ) <NEWLINE> count = 0 <NEWLINE> h = input ( ) . split ( ) <NEWLINE> ans = 0 <NEWLINE> w = 0 <NEWLINE> r = np . zeros ( n ) <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] ) <NEWLINE> if int ( h [ b - 1 ] ) > int ( h [ c - 1 ] ) : <NEWLINE> <INDENT> r [ b - 1 ] += 1 <NEWLINE> r [ c - 1 ] = - 1000000 <NEWLINE> <DEDENT> elif int ( h [ c - 1 ] ) > int ( h [ b - 1 ] ) : <NEWLINE> <INDENT> r [ c - 1 ] += 1 <NEWLINE> r [ b - 1 ] = - 1000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ b - 1 ] = - 1000000 <NEWLINE> r [ c - 1 ] = - 1000000 <NEWLINE> <DEDENT> <DEDENT> print ( np . count_nonzero ( r >= 0 ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> z = len ( S ) - len ( T ) <NEWLINE> <NL> res = [ ] <NEWLINE> cnt = 0 <NEWLINE> if z == 0 : <NEWLINE> <INDENT> for a , b in zip ( S , T ) : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> exit ( ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( z ) : <NEWLINE> <INDENT> s = S [ i : i + len ( T ) ] <NEWLINE> cnt = 0 <NEWLINE> for j , k in zip ( s , T ) : <NEWLINE> <INDENT> if j != k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> res . append ( cnt ) <NEWLINE> <DEDENT> print ( min ( res ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def log ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x1 -= 1 <NEWLINE> y1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> y2 -= 1 <NEWLINE> m = [ ] <NEWLINE> costs1 = [ [ None for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> costs2 = [ [ None for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> m . append ( list ( input ( ) . strip ( ) ) ) <NEWLINE> <DEDENT> q1 = deque ( ) <NEWLINE> q1 . append ( ( x1 , y1 , 0 ) ) <NEWLINE> costs1 [ x1 ] [ y1 ] = 0 <NEWLINE> q2 = deque ( ) <NEWLINE> q2 . append ( ( x2 , y2 , 0 ) ) <NEWLINE> costs2 [ x2 ] [ y2 ] = 0 <NEWLINE> directions = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while q1 and q2 : <NEWLINE> <INDENT> ( x , y , cost ) = q1 . popleft ( ) <NEWLINE> if not costs2 [ x ] [ y ] is None : <NEWLINE> <INDENT> print ( cost + costs2 [ x ] [ y ] ) <NEWLINE> return <NEWLINE> <DEDENT> for ( add_x , add_y ) in directions : <NEWLINE> <INDENT> for dist in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> new_x = x + add_x * dist <NEWLINE> new_y = y + add_y * dist <NEWLINE> if new_x >= h or new_x < 0 or new_y >= w or new_y < 0 or m [ new_x ] [ new_y ] == <STRING> or ( ( not costs1 [ new_x ] [ new_y ] is None ) and costs1 [ new_x ] [ new_y ] < cost + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if costs1 [ new_x ] [ new_y ] is None : <NEWLINE> <INDENT> costs1 [ new_x ] [ new_y ] = cost + 1 <NEWLINE> q1 . append ( ( new_x , new_y , cost + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ( x , y , cost ) = q2 . popleft ( ) <NEWLINE> if not costs1 [ x ] [ y ] is None : <NEWLINE> <INDENT> print ( cost + costs1 [ x ] [ y ] ) <NEWLINE> return <NEWLINE> <DEDENT> for ( add_x , add_y ) in directions : <NEWLINE> <INDENT> for dist in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> new_x = x + add_x * dist <NEWLINE> new_y = y + add_y * dist <NEWLINE> if new_x >= h or new_x < 0 or new_y >= w or new_y < 0 or m [ new_x ] [ new_y ] == <STRING> or ( ( not costs2 [ new_x ] [ new_y ] is None ) and costs2 [ new_x ] [ new_y ] < cost + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if costs2 [ new_x ] [ new_y ] is None : <NEWLINE> <INDENT> costs2 [ new_x ] [ new_y ] = cost + 1 <NEWLINE> q2 . append ( ( new_x , new_y , cost + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> import heapq <NEWLINE> import cProfile <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from functools import reduce <NEWLINE> import math <NEWLINE> import string <NEWLINE> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def get_tuple ( ) : <NEWLINE> <INDENT> return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def get_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , k = get_tuple ( ) <NEWLINE> ls = get_list ( ) <NEWLINE> j = 0 <NEWLINE> i = k <NEWLINE> while i < n : <NEWLINE> <INDENT> if ls [ j ] >= ls [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> result = sum ( list ( map ( int , str ( n ) ) ) ) <NEWLINE> <NL> if result % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minp = 2 * 10 ** 5 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minp >= p [ i ] : <NEWLINE> <INDENT> minp = p [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> f = [ 0 ] * ( n + 1 ) <NEWLINE> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> k = d . popleft ( ) <NEWLINE> f [ k ] = 1 <NEWLINE> for i in l [ k ] : <NEWLINE> <INDENT> if f [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = k <NEWLINE> d . append ( i ) <NEWLINE> f [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if ans [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = n // i <NEWLINE> res += i * x * ( x + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( res ) ) <NEWLINE>
<COMMENT> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , a1 , a2 , a3 , a4 , a5 , a6 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . face = [ a1 , a2 , a3 , a4 , a5 , a6 ] <NEWLINE> self . v = [ a5 , a1 , a2 , a6 ] <COMMENT> <NEWLINE> self . h = [ a4 , a1 , a3 , a6 ] <COMMENT> <NEWLINE> self . det = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . v [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 1 ] , self . v [ 2 ] , self . v [ 3 ] , self . v [ 0 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 3 ] , self . v [ 0 ] , self . v [ 1 ] , self . v [ 2 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 3 ] , self . h [ 0 ] , self . h [ 1 ] , self . h [ 2 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 1 ] , self . h [ 2 ] , self . h [ 3 ] , self . h [ 0 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <DEDENT> def searchFace ( self , a ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if a == self . face [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> b = i + 1 <NEWLINE> <DEDENT> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def detJudge ( self , x ) : <COMMENT> <NEWLINE> <INDENT> y = int ( 7 / 2 - abs ( x - 7 / 2 ) ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . det *= - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def rightSide ( self , top , front ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if top == 1 and front == 2 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif top == 2 and front == 3 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif top == 3 and front == 1 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif top == 1 and front == 3 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif top == 3 and front == 2 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif top == 2 and front == 1 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> if self . det == - 1 : <NEWLINE> <INDENT> r = 7 - r <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> diceAmount = int ( input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for i in range ( diceAmount ) : <NEWLINE> <INDENT> d = [ int ( j ) for j in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> dice = Dice ( d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] ) <NEWLINE> dices . append ( dice ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> import random <NEWLINE> match = 0 <NEWLINE> diceCount = 1 <NEWLINE> while match == 0 and diceCount < diceAmount : <NEWLINE> <INDENT> for d2 in range ( 1 , diceAmount ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> while match == 0 and i < 27 : <NEWLINE> <INDENT> j = random . randint ( 0 , 3 ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> dices [ d2 ] . north ( ) <NEWLINE> <DEDENT> elif j == 1 : <NEWLINE> <INDENT> dices [ d2 ] . south ( ) <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dices [ d2 ] . east ( ) <NEWLINE> <DEDENT> elif j == 3 : <NEWLINE> <INDENT> dices [ d2 ] . west ( ) <NEWLINE> <DEDENT> for d1 in range ( d2 ) : <NEWLINE> <INDENT> if dices [ d1 ] . v == dices [ d2 ] . v and dices [ d1 ] . h == dices [ d2 ] . h : <NEWLINE> <INDENT> match += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> diceCount += 1 <NEWLINE> <DEDENT> if match >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( int ( 1e9 ) ) <NEWLINE> <NL> class uft : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . __N = N <NEWLINE> self . __arr = [ - 1 ] * ( N + 1 ) <NEWLINE> <DEDENT> def fp ( self , x ) : <NEWLINE> <INDENT> if self . __arr [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __arr [ x ] = self . fp ( self . __arr [ x ] ) <NEWLINE> return self . __arr [ x ] <NEWLINE> <DEDENT> <DEDENT> def add ( self , x , y ) : <NEWLINE> <INDENT> px = self . fp ( x ) <NEWLINE> py = self . fp ( y ) <NEWLINE> if px > py : <NEWLINE> <INDENT> px , py = py , px <NEWLINE> <DEDENT> if px == py : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> self . __arr [ px ] += self . __arr [ py ] <NEWLINE> self . __arr [ py ] = px <NEWLINE> <DEDENT> def groups ( self ) : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> for i in self . __arr : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT> def show_arr ( self ) : <NEWLINE> <INDENT> print ( self . __arr ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> UFT = uft ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> UFT . add ( A , B ) <NEWLINE> <DEDENT> print ( UFT . groups ( ) - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> x = s [ i : i + len ( t ) ] <NEWLINE> count = sum ( 1 for a , b in zip ( t , x ) if a != b ) <NEWLINE> res . append ( count ) <NEWLINE> <NL> <DEDENT> print ( min ( res ) ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> import networkx as nx <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = np . frombuffer ( read ( ) , <STRING> ) . reshape ( N , - 1 ) [ : , : M ] . astype ( <STRING> ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> E = [ ] <NEWLINE> <NL> for i , j in itertools . product ( range ( N ) , range ( M ) ) : <NEWLINE> <INDENT> if S [ i , j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( i + j ) & 1 : <NEWLINE> <INDENT> A . append ( ( i , j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j in A : <NEWLINE> <INDENT> for dx , dy in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> i1 , j1 = i + dx , j + dy <NEWLINE> if 0 <= i1 < N and 0 <= j1 < M and S [ i1 , j1 ] != <STRING> : <NEWLINE> <INDENT> E . append ( ( ( i , j ) , ( i1 , j1 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( A , bipartite = 0 ) <NEWLINE> G . add_nodes_from ( B , bipartite = 1 ) <NEWLINE> G . add_edges_from ( E ) <NEWLINE> <NL> M = nx . bipartite . maximum_matching ( G , A ) <NEWLINE> for key , item in M . items ( ) : <NEWLINE> <INDENT> i , j = key <NEWLINE> i1 , j1 = item <NEWLINE> if i1 == i + 1 : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> elif i1 == i - 1 : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> elif j1 == j + 1 : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> S [ i , j ] , S [ i1 , j1 ] = a , b <NEWLINE> <NL> <DEDENT> print ( len ( M ) // 2 ) <NEWLINE> for row in S : <NEWLINE> <INDENT> print ( <STRING> . join ( row ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> from decimal import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> A = [ ] <NEWLINE> for n in input ( ) . split ( ) : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> dp [ n ] += 1 <NEWLINE> A . append ( n ) <NEWLINE> <DEDENT> ans = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> diff = dp [ B ] * ( C - B ) <NEWLINE> ans += diff <NEWLINE> print ( ans ) <NEWLINE> dp [ C ] += dp [ B ] <NEWLINE> dp [ B ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> g = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> t = sum ( a ) <NEWLINE> s = [ ] <NEWLINE> <NL> for aj in a : <NEWLINE> <INDENT> g [ aj ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if g [ b ] != 0 : <NEWLINE> <INDENT> t = t + c * g [ b ] - b * g [ b ] <NEWLINE> g [ c ] = g [ c ] + g [ b ] <NEWLINE> g [ b ] = 0 <NEWLINE> s . append ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in range ( q ) : <NEWLINE> <INDENT> print ( s [ m ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( Ai ) for Ai in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> product = 1 <NEWLINE> for Ai in A : <NEWLINE> <INDENT> product *= Ai <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( product ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P . sort ( ) <NEWLINE> print ( sum ( P [ : K ] ) ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> t = 1000 <NEWLINE> Slen = 1000 <NEWLINE> Tlen = 1000 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> k = S [ i ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> Slen = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> k = T [ j ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> Tlen = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Slen - Tlen + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( Tlen ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> t = min ( t , Tlen - s ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h_list = [ 0 ] * h <NEWLINE> w_list = [ 0 ] * w <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> h_w_list = set ( ) <NEWLINE> <NL> for zzz in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> bom_h , bom_w = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> h_list [ bom_h - 1 ] += 1 <NEWLINE> w_list [ bom_w - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> h_w_list . add ( ( bom_h , bom_w ) ) <NEWLINE> <NL> <DEDENT> mh = max ( h_list ) <NEWLINE> mw = max ( w_list ) <NEWLINE> h_max_indexs = [ i for i , v in enumerate ( h_list ) if v == mh ] <NEWLINE> w_max_indexs = [ i for i , v in enumerate ( w_list ) if v == mw ] <NEWLINE> <NL> double_chance = False <NEWLINE> <COMMENT> <NL> for h_index in h_max_indexs : <NEWLINE> <INDENT> if double_chance : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for w_index in w_max_indexs : <NEWLINE> <INDENT> if double_chance : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> chance = ( h_index + 1 , w_index + 1 ) not in h_w_list <NEWLINE> <NL> if chance : <NEWLINE> <INDENT> double_chance = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if double_chance : <NEWLINE> <INDENT> result = mh + mw <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = mh + mw - 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_plus_index = list ( A [ i ] + i + 1 for i in range ( N ) ) <NEWLINE> A_plus_index = Counter ( A_plus_index ) <NEWLINE> index_minus_A = list ( i + 1 - A [ i ] for i in range ( N ) ) <NEWLINE> ans = 0 <NEWLINE> for a in index_minus_A : <NEWLINE> <INDENT> ans += A_plus_index . get ( a , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> ai = [ 0 ] * n <NEWLINE> aj = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ai [ i ] = a [ i ] + i + 1 <NEWLINE> aj [ i ] = i + 1 - a [ i ] <NEWLINE> <DEDENT> aj_num = collections . Counter ( aj ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> aj_num [ aj [ i ] ] -= 1 <NEWLINE> result += aj_num [ ai [ i ] ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 : 3 ] ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * r ** 2 ) + <STRING> % ( 2 * math . pi * r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = ( 10 ** 9 ) + 7 <NEWLINE> answer = 0 <NEWLINE> sum_A = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum_A -= A [ i ] <NEWLINE> answer += A [ i ] * sum_A % mod <NEWLINE> <DEDENT> print ( answer % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) + 1 <NEWLINE> leaves = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nod = 0 <NEWLINE> total = 0 <NEWLINE> <NL> maxx = [ 0 ] * ( N + 1 ) <NEWLINE> <COMMENT> <NL> maxx [ 0 ] = 1 <NEWLINE> if N == 1 and leaves [ 0 ] == 1 : <NEWLINE> <INDENT> total = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> notleave = maxx [ i - 1 ] - leaves [ i - 1 ] <NEWLINE> if notleave <= 0 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> maxx [ i ] = notleave * 2 <NEWLINE> if maxx [ i ] < leaves [ i ] : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ii = N - i <NEWLINE> <COMMENT> <NL> newnod = int ( ( nod + 1 ) / 2 ) + leaves [ ii ] <NEWLINE> if newnod > maxx [ ii ] : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> newnod = nod + leaves [ ii ] <NEWLINE> if newnod > maxx [ ii ] : newnod = maxx [ ii ] <NEWLINE> if newnod <= 0 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> total += newnod <NEWLINE> nod = newnod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if total <= 0 : total = - 1 <NEWLINE> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for b in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += int ( ( n - 1 ) / b ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ql = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> ql . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def check ( t ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for q in ql : <NEWLINE> <INDENT> if t [ q [ 1 ] - 1 ] - t [ q [ 0 ] - 1 ] == q [ 2 ] : <NEWLINE> <INDENT> ret += q [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> print ( max ( map ( check , itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) ) ) <NEWLINE>
input_str = input ( ) <NEWLINE> <NL> translate_num = ( int ( input_str ) ) ** 3 <NEWLINE> <NL> print ( translate_num ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> l = sum ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> d = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] = ( l + sum ( j [ : i ] ) ) * ( n - i ) <NEWLINE> if d [ i ] < d [ i - 1 ] : <NEWLINE> <INDENT> print ( d [ i - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : print ( d [ - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> L = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ 0 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ 2 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Ans = L [ 0 ] * L [ 1 ] * L [ 2 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> n = min ( N , ( N + i ) // 2 + 1 ) <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> t = S [ j ] <NEWLINE> if s != t : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= N - 1 : <NEWLINE> <INDENT> u = S [ k ] <NEWLINE> if t != u and u != s : <NEWLINE> <INDENT> Ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . face = { 12 : 3 , 13 : 5 , 14 : 2 , 15 : 4 , 21 : 4 , 23 : 1 , 24 : 6 , 26 : 3 , 31 : 2 , 32 : 6 , 35 : 1 , 36 : 5 , 41 : 5 , 42 : 1 , 45 : 6 , 46 : 2 , 51 : 3 , 53 : 6 , 54 : 1 , 56 : 4 , 62 : 4 , 63 : 2 , 64 : 5 , 65 : 3 } <NEWLINE> <NL> <DEDENT> def right_face ( self , face ) : <NEWLINE> <INDENT> return self . face [ face ] <NEWLINE> <NL> <DEDENT> <DEDENT> d = Dice ( ) <NEWLINE> dice = [ dice for dice in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> face_up , face_front = input ( ) . split ( ) <NEWLINE> face_up = dice . index ( face_up ) <NEWLINE> face_front = dice . index ( face_front ) <NEWLINE> face = str ( face_up + 1 ) + str ( face_front + 1 ) <NEWLINE> face = int ( face ) <NEWLINE> n = d . right_face ( face ) <NEWLINE> print ( dice [ n - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> Y1 = Y [ : N // 2 ] <NEWLINE> Y2 = Y [ N // 2 : ] <NEWLINE> ans1 = Y1 [ - 1 ] <NEWLINE> ans2 = Y2 [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] <= ans1 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> m = a [ - 1 ] + 1 <NEWLINE> cnt = [ 0 ] * m <NEWLINE> for ai in a : <NEWLINE> <INDENT> if cnt [ ai ] != 0 : <NEWLINE> <INDENT> cnt [ ai ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( ai , m , ai ) : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans += ( cnt [ ai ] == 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ans * a > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 2 * min ( x , y ) < max ( x , y ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( 2 * x - y ) // 3 <NEWLINE> m = ( 2 * y - x ) // 3 <NEWLINE> <COMMENT> <NL> if n == 0 or m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> def ka ( x ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> while x != 1 : <NEWLINE> <INDENT> a *= x <NEWLINE> x -= 1 <NEWLINE> a %= mod <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = ( ka ( n + m ) * pow ( ka ( m ) , mod - 2 , mod ) % mod ) * ( pow ( ka ( n ) , mod - 2 , mod ) ) % mod <NEWLINE> print ( ans ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd , e <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby , combinations_with_replacement <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> import random <NEWLINE> import time <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> start = time . time ( ) <NEWLINE> <NL> D = INT ( ) <NEWLINE> C = LIST ( ) <NEWLINE> s = [ LIST ( ) for _ in range ( D ) ] <NEWLINE> <NL> def compute_score ( out ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> last [ out [ d ] ] = d + 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> score -= ( d + 1 - last [ i ] ) * c [ i ] <NEWLINE> <DEDENT> score += s [ d ] [ out [ d ] ] <NEWLINE> <NL> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def decrease ( d , j ) : <COMMENT> <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> tmp += C [ i ] * ( d - last [ i ] ) <NEWLINE> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> def init ( ) : <COMMENT> <NEWLINE> <INDENT> global now <NEWLINE> for i in range ( D ) : <COMMENT> <NEWLINE> <INDENT> ma = - INF <NEWLINE> ma_idx = None <NEWLINE> for j in range ( 26 ) : <COMMENT> <NEWLINE> <INDENT> tmp = now <NEWLINE> tmp += s [ i ] [ j ] <NEWLINE> tmp -= decrease ( i + 1 , j ) <NEWLINE> if tmp > ma : <NEWLINE> <INDENT> ma = tmp <NEWLINE> ma_idx = j <NEWLINE> <DEDENT> <DEDENT> now = ma <NEWLINE> last [ ma_idx ] = i + 1 <NEWLINE> score [ ma_idx ] += s [ i ] [ ma_idx ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> score [ j ] -= C [ j ] * ( i + 1 - last [ j ] ) <NEWLINE> <DEDENT> last [ ma_idx ] = i + 1 <NEWLINE> ans [ i ] = ma_idx + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( d , q ) : <COMMENT> <NEWLINE> <INDENT> d -= 1 <NEWLINE> q -= 1 <NEWLINE> c = ans [ d ] - 1 <COMMENT> <NEWLINE> ans [ d ] = q + 1 <NEWLINE> last_c = 0 <NEWLINE> last_q = 0 <NEWLINE> score_c = 0 <NEWLINE> score_q = 0 <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if ans [ j ] - 1 == c : <NEWLINE> <INDENT> last_c = j + 1 <NEWLINE> score_c += s [ j ] [ c ] <NEWLINE> <DEDENT> elif ans [ j ] - 1 == q : <NEWLINE> <INDENT> last_q = j + 1 <NEWLINE> score_q += s [ j ] [ q ] <NEWLINE> <DEDENT> score_c -= C [ c ] * ( j + 1 - last_c ) <NEWLINE> score_q -= C [ q ] * ( j + 1 - last_q ) <NEWLINE> <DEDENT> score [ c ] = score_c <NEWLINE> score [ q ] = score_q <NEWLINE> <NL> <DEDENT> def swap ( d ) : <COMMENT> <NEWLINE> <INDENT> update ( d , ans [ d ] ) <NEWLINE> update ( d + 1 , ans [ d - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * D <NEWLINE> last = [ 0 ] * 26 <NEWLINE> score = [ 0 ] * 26 <NEWLINE> now = 0 <NEWLINE> <NL> init ( ) <NEWLINE> <NL> TL = 1.8 - ( time . time ( ) - start ) <NEWLINE> start = time . time ( ) <NEWLINE> T0 = 2e3 <NEWLINE> T1 = 6e2 <NEWLINE> T = T0 <NEWLINE> randint = random . randint <NEWLINE> rand = random . random <NEWLINE> while 1 : <NEWLINE> <INDENT> t = ( time . time ( ) - start ) / TL <NEWLINE> if t >= 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> T = pow ( T0 , 1 - t ) * pow ( T1 , t ) <NEWLINE> if rand ( ) < 0.5 : <COMMENT> <NEWLINE> <INDENT> d = randint ( 1 , D ) <NEWLINE> q = randint ( 1 , 26 ) <NEWLINE> old = ans [ d - 1 ] <NEWLINE> old_score = score . copy ( ) <NEWLINE> s_old = sum ( score ) <NEWLINE> update ( d , q ) <NEWLINE> s_new = sum ( score ) <NEWLINE> if s_new <= s_old or ( s_old - s_new ) >= T and ( ( s_old - s_new ) <= T and pow ( e , ( s_old - s_new ) / T ) >= rand ( ) ) : <COMMENT> <NEWLINE> <INDENT> score = old_score <NEWLINE> ans [ d - 1 ] = old <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> d = randint ( 1 , D - 1 ) <NEWLINE> old = ans [ d - 1 ] <NEWLINE> old_score = score . copy ( ) <NEWLINE> s_old = sum ( score ) <NEWLINE> swap ( d ) <NEWLINE> s_new = sum ( score ) <NEWLINE> if s_new <= s_old or ( s_old - s_new ) >= T and ( ( s_old - s_new ) <= T and pow ( e , ( s_old - s_new ) / T ) >= rand ( ) ) : <NEWLINE> <INDENT> score = old_score <NEWLINE> ans [ d - 1 ] = old <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> hlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt_ind_minus_height = { } <NEWLINE> cnt_height_plus_ind = { } <NEWLINE> cnt_height_minus_ind = { } <NEWLINE> cnt_minus_height_minus_ind = { } <NEWLINE> <NL> for ind in range ( n ) : <NEWLINE> <INDENT> height = hlist [ ind ] <NEWLINE> if ind - height not in cnt_ind_minus_height : <NEWLINE> <INDENT> cnt_ind_minus_height [ ind - height ] = 0 <NEWLINE> <DEDENT> cnt_ind_minus_height [ ind - height ] += 1 <NEWLINE> <NL> if ind + height not in cnt_height_plus_ind : <NEWLINE> <INDENT> cnt_height_plus_ind [ ind + height ] = 0 <NEWLINE> <DEDENT> cnt_height_plus_ind [ ind + height ] += 1 <NEWLINE> <NL> if height - ind not in cnt_height_minus_ind : <NEWLINE> <INDENT> cnt_height_minus_ind [ height - ind ] = 0 <NEWLINE> <DEDENT> cnt_height_minus_ind [ height - ind ] += 1 <NEWLINE> <NL> if - ind - height not in cnt_minus_height_minus_ind : <NEWLINE> <INDENT> cnt_minus_height_minus_ind [ - height - ind ] = 0 <NEWLINE> <DEDENT> cnt_minus_height_minus_ind [ - height - ind ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for val in cnt_height_minus_ind : <NEWLINE> <INDENT> if val in cnt_minus_height_minus_ind : <NEWLINE> <INDENT> ans += cnt_height_minus_ind [ val ] * cnt_minus_height_minus_ind [ val ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for val in cnt_height_plus_ind : <NEWLINE> <INDENT> if val in cnt_ind_minus_height : <NEWLINE> <INDENT> ans += cnt_height_plus_ind [ val ] * cnt_ind_minus_height [ val ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = 0 <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M += u * ( N - v + 1 ) <NEWLINE> <DEDENT> V = 0 <NEWLINE> for r in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> V += r * ( N - r + 1 ) <NEWLINE> <DEDENT> print ( V - M ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> high = low = None <NEWLINE> while True : <NEWLINE> <INDENT> if X + diff not in P : <NEWLINE> <INDENT> high = X + diff <NEWLINE> <DEDENT> if X - diff not in P : <NEWLINE> <INDENT> low = X - diff <NEWLINE> <DEDENT> if high is None and low is None : <NEWLINE> <INDENT> diff += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if high == low : <NEWLINE> <INDENT> print ( low ) <NEWLINE> <DEDENT> elif low is None : <NEWLINE> <INDENT> print ( high ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( low ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> ans += b [ i ] * ( b [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans - ( b [ a [ i ] ] - 1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> num = 7 % k <NEWLINE> first = num <NEWLINE> ans = 1 <NEWLINE> while num != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> num = ( num * 10 + 7 ) % k <NEWLINE> if num == first or ans > 2000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> ins = input ( ) . split ( ) <NEWLINE> h = int ( ins [ 0 ] ) <NEWLINE> w = int ( ins [ 1 ] ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w - 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> A = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <NL> print ( A ) <NEWLINE>
def f ( x ) : return int ( a * x / b ) - a * int ( x / b ) <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( min ( b - 1 , n ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> inputs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] <NEWLINE> inputs = inputs [ 1 ] <NEWLINE> <NL> if ( 0 in inputs ) : <NEWLINE> <INDENT> output = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = reduce ( ( lambda x , y : - 1 if ( x * y ) > 1e18 or x < 0 or y < 0 else ( x * y ) ) , inputs ) <NEWLINE> <NL> <DEDENT> print ( output ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> now = 1 <NEWLINE> for i in sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) : <NEWLINE> <INDENT> if ( now == i ) : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> for j in range ( i - now - 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> now = i <NEWLINE> sum = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> while ( now < N ) : <NEWLINE> <INDENT> now += 1 <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys , collections <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> a = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> di = 10 ** 9 + 7 <NEWLINE> cum = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> cum [ i ] = ( cum [ i + 1 ] + a [ i ] ) % di <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = ( s + ( a [ i ] * cum [ i + 1 ] ) % di ) % di <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( s ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
import math <NEWLINE> <NL> x , y , X , Y = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( math . sqrt ( ( x - X ) ** 2 + ( y - Y ) ** 2 ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> friends_map = { n : set ( ) for n in range ( N ) } <NEWLINE> remain_user = set ( ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> friends_map [ a ] . add ( b ) <NEWLINE> friends_map [ b ] . add ( a ) <NEWLINE> remain_user . add ( a ) <NEWLINE> remain_user . add ( b ) <NEWLINE> <NL> <DEDENT> stack = deque ( ) <NEWLINE> stack . appendleft ( 0 ) <NEWLINE> <NL> max_group = 1 <NEWLINE> watch = [ 0 ] * N <NEWLINE> count = 0 <NEWLINE> while stack : <NEWLINE> <INDENT> now = stack . popleft ( ) <NEWLINE> <NL> if watch [ now ] == 0 : <NEWLINE> <INDENT> remain_user . discard ( now ) <NEWLINE> watch [ now ] = 1 <NEWLINE> count += 1 <NEWLINE> <NL> for next_node in friends_map [ now ] : <NEWLINE> <INDENT> if watch [ next_node ] == 0 : <NEWLINE> <INDENT> stack . appendleft ( next_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not stack : <NEWLINE> <INDENT> max_group = max ( count , max_group ) <NEWLINE> <NL> if remain_user : <NEWLINE> <INDENT> stack . appendleft ( remain_user . pop ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_group ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> <NL> def bfs ( x1 , y1 , d ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( ( d , x1 , y1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> d , x1 , y1 = q . popleft ( ) <NEWLINE> <NL> M [ x1 ] [ y1 ] = d <NEWLINE> <NL> if [ x1 , y1 ] == [ xg , yg ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> <NL> if ( 0 <= x2 < H ) and ( 0 <= y2 < W ) : <NEWLINE> <INDENT> if m [ x2 ] [ y2 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] == - 1 : <NEWLINE> <INDENT> M [ x2 ] [ y2 ] = d + 1 <NEWLINE> q . append ( ( d + 1 , x2 , y2 ) ) <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = xs - 1 , ys - 1 , xg - 1 , yg - 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> <NL> bfs ( xs , ys , 0 ) <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> <NL> n = functools . partial ( functools . reduce , operator . mul ) <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> start = int ( input ( ) ) - 1 <COMMENT> <NEWLINE> goal = int ( input ( ) ) - 1 <COMMENT> <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> nums = [ [ i for i in range ( n ) ] ] <COMMENT> <NEWLINE> bars = [ ] <COMMENT> <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> bars . append ( s ) <NEWLINE> new = nums [ - 1 ] [ : ] <NEWLINE> <NL> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> new [ j ] , new [ j + 1 ] = new [ j + 1 ] , new [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> nums . append ( new ) <NEWLINE> <NL> <DEDENT> to_goal = nums [ - 1 ] [ goal ] <COMMENT> <NEWLINE> <NL> if to_goal == start : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> for i , status in enumerate ( nums [ 1 : ] ) : <NEWLINE> <INDENT> to_goal_ind = status . index ( to_goal ) <COMMENT> <NEWLINE> start_ind = status . index ( start ) <COMMENT> <NEWLINE> ind1 , ind2 = min ( to_goal_ind , start_ind ) , max ( to_goal_ind , start_ind ) <NEWLINE> <NL> if ind2 - ind1 == 1 : <COMMENT> <NEWLINE> <INDENT> if ( bars [ i ] [ ind1 ] == <STRING> ) and ( ind1 == 0 or bars [ i ] [ ind1 - 1 ] == <STRING> ) and ( ind2 == n - 1 or bars [ i ] [ ind2 ] == <STRING> ) : <COMMENT> <NEWLINE> <INDENT> print ( i + 1 , ind1 + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> coin = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for v in itertools . combinations ( books , i ) : <NEWLINE> <INDENT> comb = list ( v ) <NEWLINE> result = np . sum ( comb , axis = 0 ) <NEWLINE> <NL> flag = True <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if result [ j ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> coin . append ( result [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( coin ) > 0 : <NEWLINE> <INDENT> coin . sort ( reverse = False ) <NEWLINE> print ( coin [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
numbers = input ( ) <NEWLINE> <NL> if numbers [ 1 ] == numbers [ 2 ] : <NEWLINE> <INDENT> if numbers . count ( numbers [ 1 ] ) >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> H , W = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> if H == 1 or W == 1 : <NEWLINE> <INDENT> res = 1 <NEWLINE> <DEDENT> elif H % 2 == 1 and W % 2 == 1 : <NEWLINE> <INDENT> res = H * W // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = H * W // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = [ 0 ] * N <NEWLINE> G = [ 0 ] * N <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R [ i ] += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( R ) * sum ( G ) * sum ( B ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( ( N + i + 3 ) // 2 , N ) ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = sorted ( x ) <NEWLINE> key1 = lis [ n // 2 - 1 ] <NEWLINE> key2 = lis [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> if i > key1 : <NEWLINE> <INDENT> print ( key1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( key2 ) <NEWLINE> <DEDENT> <DEDENT>
from functools import reduce <NEWLINE> <NL> def extended_euclid ( a , b ) : <NEWLINE> <INDENT> x1 , y1 , m = 1 , 0 , a <NEWLINE> x2 , y2 , n = 0 , 1 , b <NEWLINE> while m % n != 0 : <NEWLINE> <INDENT> q , r = divmod ( m , n ) <NEWLINE> x1 , y1 , m , x2 , y2 , n = x2 , y2 , n , x1 - q * x2 , y1 - q * y2 , r <NEWLINE> <DEDENT> return x2 , y2 , n <NEWLINE> <NL> <DEDENT> def modular_inverse ( a , mod ) : <NEWLINE> <INDENT> x , _ , g = extended_euclid ( a , mod ) <NEWLINE> if g != 1 : <NEWLINE> <INDENT> return None <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x % mod <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( A , key = abs , reverse = True ) <NEWLINE> cand = [ ] <NEWLINE> minus = False <NEWLINE> last_plus , last_minus = None , None <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> cand . append ( a ) <NEWLINE> if a < 0 : minus = not minus ; last_minus = a <NEWLINE> elif a > 0 : last_plus = a <NEWLINE> else : minus = False <NEWLINE> <DEDENT> ans = reduce ( lambda x , y : x * y % MOD , cand ) <NEWLINE> if minus and K != N : <NEWLINE> <INDENT> non_neg , neg = None , None <NEWLINE> for a in A [ K : ] : <NEWLINE> <INDENT> if a >= 0 and non_neg is None : non_neg = a <NEWLINE> elif a < 0 and neg is None : neg = a <NEWLINE> if non_neg is not None and neg is not None : break <NEWLINE> <DEDENT> if non_neg is None : <NEWLINE> <INDENT> if last_plus : <NEWLINE> <INDENT> ans *= modular_inverse ( last_plus , MOD ) * neg ; ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda x , y : x * y % MOD , A [ : : - 1 ] [ : K ] ) <NEWLINE> <DEDENT> <DEDENT> elif neg is None : <NEWLINE> <INDENT> ans *= modular_inverse ( last_minus , MOD ) * non_neg ; ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if last_plus and abs ( last_plus * non_neg ) < abs ( last_minus * neg ) : <NEWLINE> <INDENT> ans *= modular_inverse ( last_plus , MOD ) * neg ; ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= modular_inverse ( last_minus , MOD ) * non_neg ; ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> flag = False <NEWLINE> for a in range ( 120 ) : <NEWLINE> <INDENT> for b in range ( 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> A = a <NEWLINE> B = b <NEWLINE> flag = True <NEWLINE> <NL> <DEDENT> if a ** 5 + b ** 5 == X : <NEWLINE> <INDENT> A = a <NEWLINE> B = - b <NEWLINE> <NL> <DEDENT> if - a ** 5 + b ** 5 == X : <NEWLINE> <INDENT> A = - a <NEWLINE> B = b <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <COMMENT> <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> <DEDENT> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def max_members_group ( self ) : <NEWLINE> <INDENT> return max ( [ self . size ( r ) for r in self . roots ( ) ] ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ input ( ) . split ( ) for _ in range ( m ) ] <NEWLINE> <NL> UF = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> UF . union ( int ( data [ i ] [ 0 ] ) - 1 , int ( data [ i ] [ 1 ] ) - 1 ) <NEWLINE> <DEDENT> print ( UF . max_members_group ( ) ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = <STRING> <NEWLINE> cnt = 0 <NEWLINE> base = 26 <NEWLINE> while n >= base ** cnt : <NEWLINE> <INDENT> n -= base ** cnt <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> <COMMENT> <NL> for i in range ( cnt - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> res = n // ( base ** i ) <NEWLINE> ans += ls [ res ] <NEWLINE> n -= base ** i * res <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X < 0 : <NEWLINE> <INDENT> X *= - 1 <NEWLINE> <DEDENT> n = X // D <NEWLINE> m = min ( K , n ) <NEWLINE> <NL> X -= m * D <NEWLINE> K -= m <NEWLINE> if K % 2 : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> l = read ( ) . decode ( ) . split ( ) <NEWLINE> c = Counter ( l ) <NEWLINE> <NL> max = c . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> ans = [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= max ] <NEWLINE> <NL> print ( <STRING> . join ( sorted ( ans ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> n = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> ans += a * n <NEWLINE> n += a <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> dic = Counter ( a ) <NEWLINE> <NL> for i in set ( a ) : <NEWLINE> <INDENT> if 1 < dic [ i ] : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a = list ( set ( a ) ) <NEWLINE> a_max = max ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if a_max < i * j : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cnt [ i * j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if cnt [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> b = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> b . append ( k + 100 ) <NEWLINE> cnt = 0 <NEWLINE> ans1 , ans2 = 0 , 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a [ i + 1 ] += a [ i ] <NEWLINE> if a [ i + 1 ] <= k : <NEWLINE> <INDENT> ans1 = i + 2 <NEWLINE> <DEDENT> <DEDENT> for j in range ( m - 1 ) : <NEWLINE> <INDENT> b [ j + 1 ] += b [ j ] <NEWLINE> if b [ j + 1 ] <= k : <NEWLINE> <INDENT> ans2 = j + 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans1 , ans2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nokori = k - a [ i ] <NEWLINE> r , l = 0 , m <NEWLINE> if nokori < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if b [ 0 ] > nokori : <NEWLINE> <INDENT> ans = max ( i + 1 , ans ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while ( l - r > 1 ) : <NEWLINE> <INDENT> if b [ ( r + l ) // 2 ] <= nokori : <NEWLINE> <INDENT> r = ( r + l ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = ( r + l ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( i + l + 1 , ans ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> if flag == 3 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if ans != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> return N , A , B , C <NEWLINE> <NL> <NL> <DEDENT> def get_lb ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess > key : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> <DEDENT> return high <NEWLINE> <NL> <NL> <DEDENT> def get_ub ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess < key : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , A : list , B : list , C : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> C = sorted ( C ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B_i = B [ i ] <NEWLINE> ans += ( get_ub ( A , B_i ) + 1 ) * ( N - get_lb ( C , B_i ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , A , B , C = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , A , B , C ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def solve ( stns , idx , mem ) : <NEWLINE> <NL> <INDENT> if idx >= len ( stns ) - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if idx in mem : <NEWLINE> <INDENT> return mem [ idx ] <NEWLINE> <NL> <DEDENT> if idx == len ( stns ) - 2 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> final_step = abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> mem [ idx ] = final_step <NEWLINE> return final_step <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> step1 = solve ( stns , idx + 1 , mem ) + abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> <COMMENT> <NL> step2 = solve ( stns , idx + 2 , mem ) + abs ( stns [ idx ] - stns [ idx + 2 ] ) <NEWLINE> <NL> min_cost = min ( step1 , step2 ) <NEWLINE> mem [ idx ] = min_cost <NEWLINE> <NL> return min_cost <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def take_input ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <INDENT> reader = ( s . rstrip ( ) for s in sys . stdin ) <NEWLINE> input = reader . __next__ <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> stns = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mem = { } <NEWLINE> res = solve ( stns , 0 , mem ) <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> take_input ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from heapq import * <NEWLINE> <NL> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> s = min ( [ s , 50 * n ] ) <NEWLINE> tree = [ [ ] for _i in range ( n + 1 ) ] <NEWLINE> for _i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ u ] . append ( [ v , a , b ] ) <NEWLINE> tree [ v ] . append ( [ u , a , b ] ) <NEWLINE> <NL> <DEDENT> cd = [ [ 0 , 0 ] ] <NEWLINE> for _i in range ( n ) : <NEWLINE> <INDENT> cd . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ float ( <STRING> ) for _i in range ( 50 * n + 1 ) ] for _j in range ( n + 1 ) ] <NEWLINE> hq = [ [ 0 , 1 , s ] ] <NEWLINE> dp [ 1 ] [ s ] = 0 <NEWLINE> heapify ( hq ) <NEWLINE> while hq : <NEWLINE> <INDENT> t , p , g = heappop ( hq ) <NEWLINE> if g + cd [ p ] [ 0 ] <= 50 * n : <NEWLINE> <INDENT> x , y = t + cd [ p ] [ 1 ] , min ( [ g + cd [ p ] [ 0 ] , 50 * n ] ) <NEWLINE> if dp [ p ] [ y ] > x : <NEWLINE> <INDENT> dp [ p ] [ y ] = x <NEWLINE> heappush ( hq , [ x , p , y ] ) <NEWLINE> <DEDENT> <DEDENT> for x , y , z in tree [ p ] : <NEWLINE> <INDENT> if g - y >= 0 and dp [ x ] [ g - y ] > t + z : <NEWLINE> <INDENT> dp [ x ] [ g - y ] = t + z <NEWLINE> heappush ( hq , [ t + z , x , g - y ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in dp [ 2 : ] : <NEWLINE> <INDENT> print ( min ( i ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def to_irreducible ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return [ 0 , 1 ] <NEWLINE> <DEDENT> GCD = gcd ( a , b ) <NEWLINE> return [ a // GCD , b // GCD ] <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> daiichi_dict = defaultdict ( int ) <NEWLINE> daini_dict = defaultdict ( int ) <NEWLINE> zero_cases = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero_cases += 1 <NEWLINE> <DEDENT> elif a * b >= 0 and b != 0 : <NEWLINE> <INDENT> a , b = to_irreducible ( abs ( a ) , abs ( b ) ) <NEWLINE> daiichi_dict [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = to_irreducible ( abs ( b ) , abs ( a ) ) <NEWLINE> daini_dict [ ( a , b ) ] += 1 <NEWLINE> daiichi_dict [ ( a , b ) ] += 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for key , value_daiichi in daiichi_dict . items ( ) : <NEWLINE> <INDENT> value_daini = daini_dict [ key ] <NEWLINE> ans *= ( 2 ** value_daiichi + 2 ** value_daini - 1 ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ( ans + zero_cases - 1 ) % MOD ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 10 ** 18 <NEWLINE> if 0 in set ( a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for ai in a [ 1 : ] : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i ** 2 <= N : <NEWLINE> <INDENT> M = max ( M , i ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
import sys <NEWLINE> from collections import Counter as cc <NEWLINE> from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> <COMMENT> <NL> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> c = cc ( a ) <NEWLINE> N = sum ( c . values ( ) ) <NEWLINE> cache = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = float ) <NEWLINE> cache [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> @ njit ( cache = True ) <NEWLINE> def dfs ( x , y , z , N , cache ) : <NEWLINE> <INDENT> if x + y + z == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if cache [ x ] [ y ] [ z ] >= 0 : <NEWLINE> <INDENT> return cache [ x ] [ y ] [ z ] <NEWLINE> <DEDENT> tmp = 1 <NEWLINE> if x > 0 : <NEWLINE> <INDENT> tmp += dfs ( x - 1 , y , z , N , cache ) * x / N <NEWLINE> <DEDENT> if y > 0 : <NEWLINE> <INDENT> tmp += dfs ( x + 1 , y - 1 , z , N , cache ) * y / N <NEWLINE> <DEDENT> if z > 0 : <NEWLINE> <INDENT> tmp += dfs ( x , y + 1 , z - 1 , N , cache ) * z / N <NEWLINE> <DEDENT> tmp *= N / ( x + y + z ) <NEWLINE> cache [ x ] [ y ] [ z ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> dfs ( c [ 1 ] , c [ 2 ] , c [ 3 ] , N , cache ) <NEWLINE> print ( cache [ c [ 1 ] ] [ c [ 2 ] ] [ c [ 3 ] ] ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cumsum = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> cumsum [ i ] = cumsum [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cumsum [ i ] = cumsum [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cumsum [ r - 1 ] - cumsum [ l - 1 ] ) <NEWLINE> <DEDENT>
from bisect import bisect_left as BL <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> def isok ( border ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res += N - BL ( A , border - A [ i ] ) <NEWLINE> <DEDENT> return res >= M <NEWLINE> <NL> <NL> <DEDENT> ok = 0 <NEWLINE> ng = A [ - 1 ] * 2 + 1 <NEWLINE> mid = ( ok + ng ) // 2 <NEWLINE> <NL> <COMMENT> <NL> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> B = reversed ( A ) <NEWLINE> SB = [ 0 ] <NEWLINE> for b in B : <NEWLINE> <INDENT> SB . append ( b + SB [ - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> shake_c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> goodshake = N - BL ( A , ok - A [ i ] ) <NEWLINE> shake_c += goodshake <NEWLINE> ans += A [ i ] * goodshake <NEWLINE> ans += SB [ goodshake ] <NEWLINE> <DEDENT> ans -= ( shake_c - M ) * ok <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def calc ( x , y , r , d , nd ) : <NEWLINE> <INDENT> x = x + r * math . cos ( math . radians ( d ) ) <NEWLINE> y = y + r * math . sin ( math . radians ( d ) ) <NEWLINE> d -= nd <NEWLINE> return x , y , d <NEWLINE> <NL> <DEDENT> x = y = 0 <NEWLINE> d = 90 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> r , nd = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if r == nd == 0 : break <NEWLINE> x , y , d = calc ( x , y , r , d , nd ) <NEWLINE> <NL> <DEDENT> print ( int ( x ) ) <NEWLINE> print ( int ( y ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> r1 , c1 , r2 , c2 = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> C = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> dxy = [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dists = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> dists [ r1 ] [ c1 ] = 0 <NEWLINE> q = deque ( [ ( r1 , c1 ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> if y == r2 and x == c2 : <NEWLINE> <INDENT> print ( dists [ y ] [ x ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for dx , dy in dxy : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> nx , ny = x + dx * i , y + dy * i <NEWLINE> if not 0 <= nx < W : break <NEWLINE> if not 0 <= ny < H : break <NEWLINE> if C [ ny ] [ nx ] == <STRING> : break <NEWLINE> if dists [ ny ] [ nx ] <= dists [ y ] [ x ] : break <NEWLINE> if dists [ ny ] [ nx ] <= dists [ y ] [ x ] + 1 : continue <NEWLINE> dists [ ny ] [ nx ] = dists [ y ] [ x ] + 1 <NEWLINE> q . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy <NEWLINE> res = numpy . cumsum ( range ( n + 2 ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> s += ( res [ n + 1 ] - res [ n + 1 - i ] - res [ i ] + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> ans += a [ i ] * s <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) . strip ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> cnt_A = Counter ( A_list ) <NEWLINE> max_num = max ( A_list ) <NEWLINE> <NL> <NL> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> if A_list [ i ] not in cnt_A : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( 2 , max_num // A_list [ i ] + 1 ) : <NEWLINE> <INDENT> n = A_list [ i ] * j <NEWLINE> <NL> if n in cnt_A : <NEWLINE> <INDENT> del cnt_A [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = [ k for k , v in cnt_A . items ( ) if v == 1 ] <NEWLINE> print ( len ( ans ) if ans else 0 ) <NEWLINE>
d = set ( ) <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> c , g = input ( ) . split ( ) <NEWLINE> if <STRING> == c [ 0 ] : d |= set ( [ g ] ) <NEWLINE> else : print ( [ <STRING> , <STRING> ] [ g in d ] ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> dp [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( dp [ i ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> d [ 0 ] += 1 <NEWLINE> <NL> mod = 0 <NEWLINE> R = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( mod + R * int ( S [ len ( S ) - i - 1 ] ) ) % 2019 <NEWLINE> R = R * 10 % 2019 <NEWLINE> d [ mod ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ret = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ret [ input ( ) ] = 0 <NEWLINE> <DEDENT> print ( len ( ret . keys ( ) ) ) <NEWLINE>
def solve ( n , A ) : <NEWLINE> <INDENT> def cycles ( ) : <NEWLINE> <INDENT> V = [ False ] * n <NEWLINE> B = sorted ( A ) <NEWLINE> T = { B [ i ] : i for i in range ( n ) } <NEWLINE> C = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if V [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cur = i <NEWLINE> cycle = [ ] <NEWLINE> while not V [ cur ] : <NEWLINE> <INDENT> V [ cur ] = True <NEWLINE> cycle . append ( cur ) <NEWLINE> cur = T [ A [ cur ] ] <NEWLINE> <DEDENT> C . append ( cycle ) <NEWLINE> <NL> <DEDENT> return C <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> s = min ( A ) <NEWLINE> <NL> for cycle in cycles ( ) : <NEWLINE> <INDENT> S = sum ( [ A [ i ] for i in cycle ] ) <NEWLINE> m = min ( [ A [ i ] for i in cycle ] ) <NEWLINE> an = len ( cycle ) <NEWLINE> ans += min ( S + ( an - 2 ) * m , m + S + ( an + 1 ) * s ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> print ( solve ( n , A ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> case = input ( ) <NEWLINE> if case == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + case ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lw = [ input ( ) for i in range ( n ) ] <NEWLINE> used = set ( ) <NEWLINE> cond = True <NEWLINE> last = lw [ 0 ] [ 0 ] <NEWLINE> for w in lw : <NEWLINE> <INDENT> if w in used or last != w [ 0 ] : <NEWLINE> <INDENT> cond = False <NEWLINE> break <NEWLINE> <DEDENT> used . add ( w ) <NEWLINE> last = w [ - 1 ] <NEWLINE> <DEDENT> print ( <STRING> if cond else <STRING> ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> data [ a ] . append ( b ) <NEWLINE> data [ b ] . append ( a ) <NEWLINE> <DEDENT> hantei = [ False ] * n <NEWLINE> hantei [ 0 ] = True <NEWLINE> deq = deque ( [ 0 ] ) <NEWLINE> while deq : <NEWLINE> <INDENT> k = deq . popleft ( ) <NEWLINE> for i in data [ k ] : <NEWLINE> <INDENT> if hantei [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> hantei [ i ] = True <NEWLINE> ans [ i ] = k <NEWLINE> deq . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = ( n * ( n - 1 ) // 2 ) <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def bit_add ( arr , n , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> arr [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bit_sum ( arr , i ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> result += arr [ i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> N , Q = inp [ : 2 ] <NEWLINE> C = inp [ 2 : 2 + N ] <NEWLINE> L , R = inp [ 2 + N : : 2 ] - 1 , inp [ 3 + N : : 2 ] - 1 <NEWLINE> <NL> just_left = { } <NEWLINE> segments = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = C [ i ] <NEWLINE> if c in just_left : <NEWLINE> <INDENT> segments . append ( ( i , 0 , just_left [ c ] , 0 ) ) <NEWLINE> <DEDENT> just_left [ c ] = i <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> segments . append ( ( R [ i ] , 1 , L [ i ] , i ) ) <NEWLINE> <NL> <DEDENT> segments . sort ( ) <NEWLINE> bit = np . zeros ( N + 2 , dtype = np . int64 ) <NEWLINE> ans = np . zeros ( Q , dtype = np . int64 ) <NEWLINE> <NL> for r , tp , l , i in segments : <NEWLINE> <INDENT> if tp == 0 : <NEWLINE> <INDENT> bit_add ( bit , N + 2 , l + 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> base = r - l + 1 <NEWLINE> ans [ i ] = base - ( bit_sum ( bit , r + 2 ) - bit_sum ( bit , l + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> inp = np . fromstring ( open ( 0 ) . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( abs ( a ) - abs ( b + 1 ) ) % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a += A [ i ] <NEWLINE> <DEDENT> ans = a <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> a = a - A [ i - k ] + A [ i ] <NEWLINE> if ans < a : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> ans = a <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> memo = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> memo [ a ] += 1 <NEWLINE> if memo [ a ] < 2 : <NEWLINE> <INDENT> for i in range ( 2 * a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> memo [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if memo [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> nh = [ 0 ] * H <NEWLINE> nw = [ 0 ] * W <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> d [ ( h , w ) ] = 1 <NEWLINE> nh [ h ] += 1 <NEWLINE> nw [ w ] += 1 <NEWLINE> <DEDENT> hmax = max ( nh ) <NEWLINE> wmax = max ( nw ) <NEWLINE> is_h = [ i for i in range ( H ) if nh [ i ] == hmax ] <NEWLINE> is_w = [ i for i in range ( W ) if nw [ i ] == wmax ] <NEWLINE> <NL> for i_h , i_w in itertools . product ( is_h , is_w ) : <NEWLINE> <INDENT> if ( i_h , i_w ) not in d : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( hmax + wmax - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 100 : <NEWLINE> <INDENT> print ( 0 if X <= 50 else 101 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> lst = [ 0 ] + list ( set ( range ( 1 , 101 ) ) - p ) + [ 101 ] <NEWLINE> lst2 = [ abs ( lst [ i ] - X ) for i in range ( len ( lst ) ) ] <NEWLINE> min_ = min ( lst2 ) <NEWLINE> print ( lst [ lst2 . index ( min_ ) ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = ( n - 1 ) * n // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= int ( A [ i ] ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> target = a [ 0 : k ] <NEWLINE> p = sum ( target ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> ans = p - a [ i ] + a [ i + k ] <NEWLINE> <COMMENT> <NL> if ans > p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> p = ans <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( a [ 1 ] , len ( b ) ) : <NEWLINE> <INDENT> if b [ i ] > b [ i - a [ 1 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> all_price = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( i == N ) : <NEWLINE> <INDENT> all_price += abs ( A [ i - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> all_price += abs ( A [ i ] - now ) <NEWLINE> now = A [ i ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> print ( all_price + abs ( A [ i + 1 ] - 0 ) - <NEWLINE> <INDENT> ( abs ( A [ i ] - 0 ) + abs ( A [ i + 1 ] - A [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( i == N - 1 ) : <NEWLINE> <INDENT> print ( all_price + abs ( A [ i - 1 ] - 0 ) - <NEWLINE> <INDENT> ( abs ( A [ i ] - A [ i - 1 ] ) + abs ( abs ( A [ i ] - 0 ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( all_price + abs ( A [ i - 1 ] - A [ i + 1 ] ) - <NEWLINE> <INDENT> ( abs ( A [ i - 1 ] - A [ i ] ) + abs ( A [ i ] - A [ i + 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mini = 10 ** 9 <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] <= mini : <NEWLINE> <INDENT> mini = P [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> * S , = map ( int , S [ : : - 1 ] ) <NEWLINE> R = [ 0 ] * 2019 <NEWLINE> <NL> p = 0 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> q = 10 ** ( i % 224 ) % 2019 <NEWLINE> p += s * q <NEWLINE> p %= 2019 <NEWLINE> R [ p ] += 1 <NEWLINE> <NL> <DEDENT> ans = R [ 0 ] <NEWLINE> for r in R : <NEWLINE> <INDENT> ans += r * ( r - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from fractions import gcd <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 6 + 5 <NEWLINE> chk = [ 0 ] * m <NEWLINE> for i in a : <NEWLINE> <INDENT> chk [ i ] += 1 <NEWLINE> <DEDENT> pw = 1 <NEWLINE> for i in range ( 2 , m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , m , i ) : <NEWLINE> <INDENT> cnt += chk [ j ] <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pw = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> g = a [ 0 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> g = gcd ( g , i ) <NEWLINE> <DEDENT> if pw == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif g == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> hs = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> step = 0 <NEWLINE> while ( True ) : <NEWLINE> <NL> <INDENT> if ( sum ( hs ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> start = None <NEWLINE> stop = None <NEWLINE> <NL> for i , h in enumerate ( hs ) : <NEWLINE> <NL> <INDENT> if ( h > 0 and start is None ) : <NEWLINE> <INDENT> start = i <NEWLINE> <DEDENT> if ( h == 0 and start is not None and stop is None ) : <NEWLINE> <INDENT> stop = i <NEWLINE> <NL> <DEDENT> <DEDENT> if ( start is not None and stop is None ) : <NEWLINE> <INDENT> stop = len ( hs ) <NEWLINE> <NL> <DEDENT> for i in range ( start , stop ) : <NEWLINE> <INDENT> hs [ i ] -= 1 <NEWLINE> <NL> <DEDENT> step += 1 <NEWLINE> <NL> <DEDENT> print ( step ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = input ( ) <NEWLINE> c = int ( 0 ) <NEWLINE> <NL> for i in range ( int ( a [ 0 ] ) ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if b [ int ( a [ 0 ] ) ] != <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <NL> <DEDENT> for i in range ( int ( a [ 0 ] ) + 1 , int ( a [ 0 ] ) + int ( a [ 1 ] ) + 1 ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> passed = 0 <NEWLINE> oversea = 0 <NEWLINE> yep = False <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if passed < ( a + b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> passed += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if oversea < b and passed < ( a + b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> passed += 1 <NEWLINE> oversea += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> <NL> nax = int ( math . sqrt ( N ) ) <NEWLINE> <NL> for x in range ( 1 , nax ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> temp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if temp <= N : <NEWLINE> <INDENT> if x == y and y != z : <NEWLINE> <INDENT> ans [ temp - 1 ] += 3 <NEWLINE> <DEDENT> elif y == z and z != x : <NEWLINE> <INDENT> ans [ temp - 1 ] += 3 <NEWLINE> <DEDENT> elif z == x and x != y : <NEWLINE> <INDENT> ans [ temp - 1 ] += 3 <NEWLINE> <DEDENT> elif x == y == z : <NEWLINE> <INDENT> ans [ temp - 1 ] += 1 <NEWLINE> <DEDENT> elif x != y and y != z and z != x : <NEWLINE> <INDENT> ans [ temp - 1 ] += 6 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for anss in ans : <NEWLINE> <INDENT> print ( anss ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] = 1 <NEWLINE> digit = 1 <NEWLINE> temp = 0 <NEWLINE> <NL> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> temp = ( temp + digit * int ( i ) ) % 2019 <NEWLINE> mod [ temp ] += 1 <NEWLINE> digit = ( digit * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for m in mod : <NEWLINE> <INDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in num_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d . get ( i + a [ i ] , 0 ) == 0 : <NEWLINE> <INDENT> d [ i + a [ i ] ] = [ 0 , 0 ] <NEWLINE> <DEDENT> if d . get ( i - a [ i ] , 0 ) == 0 : <NEWLINE> <INDENT> d [ i - a [ i ] ] = [ 0 , 0 ] <NEWLINE> <DEDENT> d [ i + a [ i ] ] [ 0 ] += 1 <NEWLINE> d [ i - a [ i ] ] [ 1 ] += 1 <NEWLINE> <DEDENT> for v in d . values ( ) : <NEWLINE> <INDENT> ans += v [ 0 ] * v [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <NL> if n >= b - 1 : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <NL> <DEDENT> return a * x // b - x // b * a <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> <NL> def min2 ( x , y ) : return x if x <= y else y <NEWLINE> <NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> items = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> items . sort ( ) <NEWLINE> <NL> dp = [ INF ] * ( H + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for vi , wi in items : <NEWLINE> <INDENT> for j in range ( H - vi + 1 ) : <NEWLINE> <INDENT> dp [ j + vi ] = min2 ( dp [ j + vi ] , dp [ j ] + wi ) <NEWLINE> <DEDENT> for j in range ( max ( 0 , H - vi + 1 ) , H + 1 ) : <NEWLINE> <INDENT> dp [ H ] = min2 ( dp [ H ] , dp [ j ] + wi ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( dp [ H ] ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
class Tree : <NEWLINE> <INDENT> def __init__ ( self , ary ) : <NEWLINE> <INDENT> self . nodes = [ <NEWLINE> <INDENT> Node ( node , self ) for node in sorted ( ary , key = lambda x : x [ 0 ] ) <NEWLINE> <DEDENT> ] <NEWLINE> [ node . set ( ) for node in self . nodes ] <NEWLINE> for node in self . nodes : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> node . set_depth ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> [ node . output ( ) for node in self . nodes ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , node , tree ) : <NEWLINE> <INDENT> self . tree = tree <NEWLINE> self . no = node [ 0 ] <NEWLINE> self . parent = - 1 <NEWLINE> self . right = False <NEWLINE> self . left = False <NEWLINE> self . children = node [ 2 : ] <NEWLINE> <NL> <DEDENT> def set ( self ) : <NEWLINE> <INDENT> if self . children : <NEWLINE> <INDENT> for i , child in enumerate ( self . children ) : <NEWLINE> <INDENT> self . tree . nodes [ child ] . parent = self . no <NEWLINE> if i < len ( self . children ) - 1 : <NEWLINE> <INDENT> self . tree . nodes [ child ] . right = self . children [ i + 1 ] <NEWLINE> <DEDENT> self . left = self . children [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def set_depth ( self , d ) : <NEWLINE> <INDENT> self . depth = d <NEWLINE> if type ( self . right ) != bool : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . set_depth ( d ) <NEWLINE> <DEDENT> if type ( self . left ) != bool : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . set_depth ( d + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> elif not self . children : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( <NEWLINE> <INDENT> self . no , self . parent , self . depth , kind , self . children ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ary = [ [ int ( _ ) for _ in line . strip ( ) . split ( ) ] for line in sys . stdin ] <NEWLINE> <COMMENT> <NL> tree = Tree ( ary ) <NEWLINE> tree . output ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> over = False <NEWLINE> zero = False <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> zero = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> s *= A [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> over = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if over : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> A [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> templ , tempr = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( templ ) <NEWLINE> r . append ( tempr ) <NEWLINE> <DEDENT> ans = min ( r ) - max ( l ) + 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> h = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> matrix = [ [ ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> matrix [ a ] . append ( b ) <NEWLINE> matrix [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> bads = { } <NEWLINE> good = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if bads . get ( i , 0 ) == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> for t in matrix [ i ] : <NEWLINE> <INDENT> if h [ i ] <= h [ t ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if t > i : <NEWLINE> <INDENT> bads [ t ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> good += 1 <NEWLINE> <DEDENT> <DEDENT> print ( good ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> return N , As <NEWLINE> <NL> <NL> <DEDENT> def func ( N , As ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> s = As [ - 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> t = As [ - 1 * ( i + 2 ) ] <NEWLINE> ans += s * t <NEWLINE> s += t <NEWLINE> <DEDENT> return ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , As = read ( ) <NEWLINE> print ( func ( N , As ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> is_fwd = True <NEWLINE> before = <STRING> <NEWLINE> after = <STRING> <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> fields = [ i for i in input ( ) . split ( ) ] <NEWLINE> t = int ( fields [ 0 ] ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> is_fwd = not is_fwd <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> f = int ( fields [ 1 ] ) <NEWLINE> c = fields [ 2 ] <NEWLINE> if ( f == 1 ) == is_fwd : <NEWLINE> <INDENT> before += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> after += c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = before [ : : - 1 ] + s + after <NEWLINE> if is_fwd : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> friendlist = [ 0 for i in range ( N + 2 ) ] <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> ab = [ [ int ( i ) for i in input ( ) . split ( <STRING> ) ] for j in range ( N ) ] <NEWLINE> a = [ ab [ i ] [ 0 ] for i in range ( N ) ] <NEWLINE> b = [ ab [ i ] [ 1 ] for i in range ( N ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> <NL> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( a [ i - 1 ] , min ( a [ i ] , N + 2 ) ) : <NEWLINE> <INDENT> friendlist [ j ] += i <NEWLINE> <DEDENT> <DEDENT> for i in range ( a [ N - 1 ] , N + 2 ) : <NEWLINE> <INDENT> friendlist [ i ] += N <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( b [ i - 1 ] + 1 , min ( b [ i ] + 1 , N + 2 ) ) : <NEWLINE> <INDENT> friendlist [ j ] -= i <NEWLINE> <DEDENT> <DEDENT> for i in range ( b [ N - 1 ] + 1 , N + 2 ) : <NEWLINE> <INDENT> friendlist [ i ] -= N <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> k = N + 1 <NEWLINE> i = 0 <NEWLINE> while k >= 0 : <NEWLINE> <INDENT> if friendlist [ k ] >= k - 1 : <NEWLINE> <INDENT> i = k - 1 <NEWLINE> break <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h . sort ( key = lambda x : - x [ 2 ] ) <NEWLINE> hmax = h [ 0 ] [ 2 ] + abs ( i - h [ 0 ] [ 0 ] ) + abs ( j - h [ 0 ] [ 1 ] ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <NL> <INDENT> if max ( hmax - abs ( h [ k ] [ 0 ] - i ) - abs ( h [ k ] [ 1 ] - j ) , 0 ) != h [ k ] [ 2 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ i , j , hmax ] <NEWLINE> <NL> <DEDENT> if ( len ( ans ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( len ( ans ) ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = map ( str , ans ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> al_s = sorted ( al , reverse = True ) <NEWLINE> c = Counter ( al_s ) <NEWLINE> ck = list ( c . keys ( ) ) <NEWLINE> cv = list ( c . values ( ) ) <NEWLINE> <NL> <NL> for a in al : <NEWLINE> <INDENT> if a == ck [ 0 ] : <NEWLINE> <INDENT> if cv [ 0 ] == 1 : <NEWLINE> <INDENT> print ( ck [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ck [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ck [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> routes = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> routes [ x - 1 ] . append ( y - 1 ) <NEWLINE> routes [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <NL> <DEDENT> rooms = [ 0 for i in range ( n ) ] <COMMENT> <NEWLINE> marks = [ 0 for i in range ( n ) ] <COMMENT> <NEWLINE> rooms_rate = [ [ 0 ] ] <COMMENT> <NEWLINE> rooms [ 0 ] = 1 <NEWLINE> <NL> turn = 0 <NEWLINE> for i in rooms_rate : <NEWLINE> <INDENT> newrate = [ ] <NEWLINE> for j in rooms_rate [ turn ] : <COMMENT> <NEWLINE> <INDENT> for k in routes [ j ] : <NEWLINE> <INDENT> if ( rooms [ k ] == 0 ) : <COMMENT> <NEWLINE> <INDENT> rooms [ k ] = 1 <NEWLINE> marks [ k ] = j <COMMENT> <NEWLINE> newrate . append ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> rooms_rate . append ( newrate ) <NEWLINE> if ( len ( newrate ) == 0 ) : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> turn = turn + 1 <NEWLINE> <NL> <NL> <DEDENT> if ( all ( rooms ) == True ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( str ( int ( marks [ i ] ) + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> if N <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> r = N <NEWLINE> for w in range ( N ) : <NEWLINE> <INDENT> if c [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> r += - 1 <NEWLINE> if r == - 1 or c [ r ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if r < w : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = { } <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( i + l [ i ] ) <NEWLINE> b [ i - l [ i ] ] = b . get ( i - l [ i ] , 0 ) + 1 <NEWLINE> <NL> <DEDENT> for av in a : <NEWLINE> <INDENT> ans = ans + b . get ( av , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
alpha = <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> len_alpha = 26 <NEWLINE> tmp = N <NEWLINE> calc = tmp <NEWLINE> cnt = 1 <NEWLINE> <NL> while tmp > 0 : <NEWLINE> <INDENT> calc = tmp <NEWLINE> tmp -= ( len_alpha ** cnt ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> res = <STRING> <NEWLINE> for i in range ( 1 , cnt - 1 ) : <NEWLINE> <INDENT> tmp = int ( ( calc - 1 ) / ( len_alpha ** ( cnt - i - 1 ) ) ) <NEWLINE> calc -= tmp * len_alpha ** ( cnt - i - 1 ) <NEWLINE> res += alpha [ tmp ] <NEWLINE> <NL> <DEDENT> res += alpha [ calc - 1 ] <NEWLINE> print ( res ) <NEWLINE>
def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> global m , G <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> G = [ ] <NEWLINE> h = 1 <NEWLINE> for i in range ( 1 , 999999 ) : <NEWLINE> <INDENT> if h > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <NL> <DEDENT> G . reverse ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> m = len ( G ) <NEWLINE> shellSort ( A , n ) <NEWLINE> <STRING> <NEWLINE> <NL> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( a - b ) <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> <DEDENT>
_ = input ( ) <NEWLINE> nums = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> res = 0 <NEWLINE> sums = [ ] <NEWLINE> for n in nums [ 1 : ] [ : : - 1 ] : <NEWLINE> <INDENT> if sums : <NEWLINE> <INDENT> sums . append ( sums [ - 1 ] + n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sums . append ( n ) <NEWLINE> <DEDENT> <DEDENT> sums . reverse ( ) <NEWLINE> <COMMENT> <NL> for i , ni in enumerate ( nums [ : - 1 ] ) : <NEWLINE> <INDENT> res += ni * sums [ i ] <NEWLINE> res %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lh = [ ] <NEWLINE> lw = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> h1 , w1 = map ( int , input ( ) . split ( ) ) <NEWLINE> lh . append ( h1 ) <NEWLINE> lw . append ( w1 ) <NEWLINE> <NL> <DEDENT> if h == 1 or w == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from collections import Counter as co <NEWLINE> ch = co ( lh ) . most_common ( ) <NEWLINE> cw = co ( lw ) . most_common ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> tmp = ch [ 0 ] [ 0 ] <NEWLINE> lh_c = [ i for i , x in enumerate ( lh ) if x == tmp ] <NEWLINE> lw_tmp = lw [ : ] <NEWLINE> for j in sorted ( lh_c , reverse = True ) : <NEWLINE> <INDENT> lw_tmp . pop ( j ) <NEWLINE> <DEDENT> if len ( lw_tmp ) == 0 : <NEWLINE> <INDENT> print ( ch [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cw_tmp = co ( lw_tmp ) . most_common ( ) <NEWLINE> ans = ch [ 0 ] [ 1 ] + cw_tmp [ 0 ] [ 1 ] <NEWLINE> <NL> tmp = cw [ 0 ] [ 0 ] <NEWLINE> lw_c = [ i for i , x in enumerate ( lw ) if x == tmp ] <NEWLINE> lh_tmp = lh [ : ] <NEWLINE> for j in sorted ( lw_c , reverse = True ) : <NEWLINE> <INDENT> lh_tmp . pop ( j ) <NEWLINE> <DEDENT> if len ( lh_tmp ) == 0 : <NEWLINE> <INDENT> print ( cw [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ch_tmp = co ( lh_tmp ) . most_common ( ) <NEWLINE> ans = max ( ans , cw [ 0 ] [ 1 ] + ch_tmp [ 0 ] [ 1 ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
input ( ) <NEWLINE> l = sorted ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> spots = [ l . pop ( ) ] <NEWLINE> x = len ( l ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> n = l . pop ( ) <NEWLINE> answer += spots [ i ] <NEWLINE> spots . append ( n ) <NEWLINE> spots . append ( n ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = np . fromstring ( input ( ) , sep = <STRING> , dtype = np . int64 ) <NEWLINE> b = np . bitwise_xor . reduce ( a ) <NEWLINE> c = np . bitwise_xor ( a , b ) <NEWLINE> print ( * c , sep = <STRING> ) <NEWLINE>
import itertools <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> min_index = p . index ( min ( p ) ) <NEWLINE> minv = p . pop ( min_index ) <NEWLINE> ans += minv <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h , w ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> for j in range ( i [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * i [ 1 ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from random import random , randint <NEWLINE> <NL> K = 26 <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . append ( q ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> last = [ - 1 for i in range ( K ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> x . append ( pow ( s [ i ] [ j ] * c [ j ] * ( i - last [ j ] ) , 3 ) ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> sum += x [ j ] <NEWLINE> <NL> <DEDENT> for j in range ( K ) : <NEWLINE> <INDENT> x [ j ] /= sum <NEWLINE> <NL> <DEDENT> prob = random ( ) <NEWLINE> cur = 0 <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> if cur + x [ j ] <= prob : <NEWLINE> <INDENT> cur += x [ j ] <NEWLINE> continue <NEWLINE> <DEDENT> ans . append ( j ) <NEWLINE> last [ j ] = i <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_result ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> last = [ - 1 for i in range ( K ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> res += s [ i ] [ ans [ i ] ] <NEWLINE> last [ ans [ i ] ] = i <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> res -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> for qq in range ( 100 ) : <NEWLINE> <INDENT> i = randint ( 0 , d - 1 ) <NEWLINE> nw = randint ( 0 , K - 1 ) <NEWLINE> <NL> old = ans [ i ] <NEWLINE> old_res = get_result ( ) <NEWLINE> <NL> ans [ i ] = nw <NEWLINE> res = get_result ( ) <NEWLINE> <NL> if res < old_res : <NEWLINE> <INDENT> ans [ i ] = old <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for u in ans : <NEWLINE> <INDENT> print ( u + 1 ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = 1 <NEWLINE> rm = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = max ( la , a ) <NEWLINE> rm = min ( rm , b ) <NEWLINE> <DEDENT> print ( max ( 0 , rm - la + 1 ) ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> for i in lists : <NEWLINE> <INDENT> num [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( num [ j ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rowsum = [ 0 ] * h <NEWLINE> rowmax = 0 <NEWLINE> colsum = [ 0 ] * w <NEWLINE> colmax = 0 <NEWLINE> targets = defaultdict ( int ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> hi -= 1 <NEWLINE> wi -= 1 <NEWLINE> rowsum [ hi ] += 1 <NEWLINE> rowmax = max ( rowmax , rowsum [ hi ] ) <NEWLINE> colsum [ wi ] += 1 <NEWLINE> colmax = max ( colmax , colsum [ wi ] ) <NEWLINE> targets [ ( hi , wi ) ] = 1 <NEWLINE> <NL> <DEDENT> rowindices = [ ] <NEWLINE> for i , v in enumerate ( rowsum ) : <NEWLINE> <INDENT> if v == rowmax : <NEWLINE> <INDENT> rowindices . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> colindices = [ ] <NEWLINE> for i , v in enumerate ( colsum ) : <NEWLINE> <INDENT> if v == colmax : <NEWLINE> <INDENT> colindices . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = rowmax + colmax - 1 <NEWLINE> for ri in rowindices : <NEWLINE> <INDENT> for ci in colindices : <NEWLINE> <INDENT> if targets [ ( ri , ci ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( rowmax + colmax ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while a : <NEWLINE> <INDENT> b , a = a , b % a <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> s = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> s += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> s += gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = s * 6 + int ( 0.5 * n * ( n + 1 ) ) <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> profit = R [ 1 ] - R [ 0 ] <NEWLINE> mn = R [ 0 ] <NEWLINE> R . pop ( 0 ) <NEWLINE> for i in R : <NEWLINE> <INDENT> if profit < i - mn : <NEWLINE> <INDENT> profit = i - mn <NEWLINE> if 0 > i - mn : <NEWLINE> <INDENT> mn = i <NEWLINE> <DEDENT> <DEDENT> elif mn > i : <NEWLINE> <INDENT> mn = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( profit ) <NEWLINE>
def xyz ( a , b , c , k ) : <NEWLINE> <INDENT> if k == a : <NEWLINE> <INDENT> return ( k ) <NEWLINE> <DEDENT> if a > k : <NEWLINE> <INDENT> return ( k ) <NEWLINE> <DEDENT> sum1 = a <NEWLINE> if a + b >= k : <NEWLINE> <INDENT> return ( a ) <NEWLINE> <DEDENT> d = k - a - b <NEWLINE> sum1 = sum1 - d <NEWLINE> return ( sum1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = xyz ( a , b , c , k ) <NEWLINE> print ( d ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( input ( ) for i in range ( n ) ) <NEWLINE> a = collections . Counter ( l ) <NEWLINE> a = list ( a . values ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
from collections import deque <NEWLINE> q = deque ( ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> N , M = MI ( ) <NEWLINE> g = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> check = [ 0 ] * ( N + 1 ) <NEWLINE> check [ 1 ] = 1 <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> q . append ( 1 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for u in g [ v ] : <NEWLINE> <INDENT> if check [ u ] == 0 : <NEWLINE> <INDENT> check [ u ] = 1 <NEWLINE> ans [ u ] = v <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def digit_sum ( s ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for digit in str ( s ) : <NEWLINE> <INDENT> ans += int ( digit ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if digit_sum ( digit_sum ( digit_sum ( n ) ) ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> mod = 1000000000 + 7 <NEWLINE> result = 0 <NEWLINE> <NL> rightTotal = sum ( arr ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> rightTotal -= arr [ i ] <NEWLINE> result += ( arr [ i ] * rightTotal ) % mod <NEWLINE> <NL> <DEDENT> print ( result % mod ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> calculate ( N , ARR ) <NEWLINE>
<COMMENT> <NL> import sys , math , numpy as np <NEWLINE> <COMMENT> <NL> from sys import stdin , stdout ; mod = int ( 1e9 + 7 ) ; from statistics import mode <NEWLINE> from collections import * ; from math import ceil , floor , inf , factorial , gcd , log2 , sqrt <NEWLINE> ii1 = lambda : int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> is1 = lambda : stdin . readline ( ) . strip ( ) <NEWLINE> iia = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> isa = lambda : stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def lcm ( a , b ) : return ( a * b ) // gcd ( a , b ) <NEWLINE> def setbits ( n ) : return bin ( n ) . count ( <STRING> ) <NEWLINE> def resetbits ( n ) : return bin ( n ) . count ( <STRING> ) <NEWLINE> def modinv ( n , p ) : return pow ( n , p - 2 , p ) <NEWLINE> def ncr ( n , r ) : <NEWLINE> <INDENT> num , den = 1 , 1 ; r = min ( n , n - r ) <NEWLINE> for i in range ( r ) : num *= ( n - i ) ; den *= ( i + 1 ) <NEWLINE> return num // den <NEWLINE> <DEDENT> def ncr_p ( n , r , p ) : <NEWLINE> <INDENT> num , den = 1 , 1 ; r = min ( r , n - r ) <NEWLINE> for i in range ( r ) : num = ( num * ( n - i ) ) % p ; den = ( den * ( i + 1 ) ) % p <NEWLINE> return ( num * modinv ( den , p ) ) % p <NEWLINE> <DEDENT> def isPrime ( num ) : <NEWLINE> <INDENT> if num <= 1 : return False <NEWLINE> if num == 2 or n == 3 : return True <NEWLINE> if ( num % 2 == 0 or num % 3 == 0 ) : return False <NEWLINE> m = int ( num ** 0.5 ) + 1 <NEWLINE> for i in range ( 5 , m , 6 ) : <NEWLINE> <INDENT> if ( num % i == 0 or num % ( i + 2 ) == 0 ) : return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> def bin_search ( arr , low , high , val ) : <NEWLINE> <INDENT> while low <= high : <NEWLINE> <INDENT> mid = low + ( high - low ) // 2 ; <NEWLINE> if arr [ mid ] == val : return mid <NEWLINE> elif arr [ mid ] < val : low = mid + 1 <NEWLINE> else : high = mid - 1 <NEWLINE> <DEDENT> return - 1 <NEWLINE> <DEDENT> def sumofdigit ( num ) : <NEWLINE> <INDENT> count = 0 ; <NEWLINE> while num : count += num % 10 ; num //= 10 ; <NEWLINE> return count ; <NEWLINE> <DEDENT> def inputmatrix ( ) : <NEWLINE> <INDENT> r , c = iia ( ) ; mat = [ 0 ] * r ; <NEWLINE> for i in range ( r ) : mat [ i ] = iia ( ) ; <NEWLINE> return r , c , mat ; <NEWLINE> <DEDENT> def prefix_sum ( n , arr ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : arr [ i ] += arr [ i - 1 ] <NEWLINE> return arr ; <NEWLINE> <DEDENT> def binomial ( n , k ) : <NEWLINE> <INDENT> if 0 <= k <= n : <NEWLINE> <INDENT> ntok = 1 ; ktok = 1 <NEWLINE> for t in range ( 1 , min ( k , n - k ) + 1 ) : ntok *= n ; ktok *= t ; n -= 1 <NEWLINE> return ntok // ktok <NEWLINE> <DEDENT> else : return 0 <NEWLINE> <DEDENT> def divisors ( n ) : <NEWLINE> <INDENT> res = [ ] ; <NEWLINE> for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if i == n // i : res . append ( i ) <NEWLINE> else : res . append ( i ) ; res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> return res ; <NEWLINE> <NL> <NL> <DEDENT> def fun ( k ) : <NEWLINE> <INDENT> current = 7 <NEWLINE> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> if current % k == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> current *= 10 <NEWLINE> current += 7 <NEWLINE> current = current % k <NEWLINE> <DEDENT> return - 1 <NEWLINE> <DEDENT> k = ii1 ( ) <NEWLINE> print ( fun ( k ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> town = 0 <NEWLINE> visited = [ town ] <NEWLINE> index = 0 <NEWLINE> visited_index = { town : index } <NEWLINE> loop = None <NEWLINE> while K > 0 : <NEWLINE> <INDENT> K -= 1 <NEWLINE> town = A [ town ] <NEWLINE> if town in visited_index : <NEWLINE> <INDENT> loop = visited [ visited_index [ town ] : ] <NEWLINE> break <NEWLINE> <DEDENT> visited . append ( town ) <NEWLINE> index += 1 <NEWLINE> visited_index [ town ] = index <NEWLINE> <NL> <DEDENT> if loop : <NEWLINE> <INDENT> K %= len ( loop ) <NEWLINE> print ( loop [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( town + 1 ) <NEWLINE> <DEDENT>
p = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> LRs = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> A = [ 0 ] * ( 2 * n + 1 ) <NEWLINE> for lj , rj in LRs : <NEWLINE> <INDENT> A [ lj ] += 1 <NEWLINE> A [ rj + 1 ] -= 1 <NEWLINE> <DEDENT> s = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s = ( s + A [ i ] ) % p <NEWLINE> for lj , rj in LRs : <NEWLINE> <INDENT> A [ i + lj ] += s <NEWLINE> A [ i + rj + 1 ] -= s <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> banpei = 1000000001 <NEWLINE> L = A [ left : mid ] + [ banpei ] <NEWLINE> R = A [ mid : right ] + [ banpei ] <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <NL> <DEDENT> def merge_Sort ( A , left , right ) : <NEWLINE> <INDENT> if 1 < right - left : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_Sort ( A , left , mid ) <NEWLINE> merge_Sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_Sort ( A , 0 , n ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = [ ] <NEWLINE> <NL> size = 1 <NEWLINE> while size < n : <NEWLINE> <INDENT> size *= 2 <NEWLINE> <DEDENT> size = size * 2 - 1 <NEWLINE> <NL> seg_tree = [ 2 ** 31 - 1 for x in range ( size ) ] <NEWLINE> <NL> def update ( i , x ) : <NEWLINE> <INDENT> ind = size // 2 + i <NEWLINE> seg_tree [ ind ] = x <NEWLINE> <NL> while ind : <NEWLINE> <INDENT> ind = ( ind - 1 ) // 2 <NEWLINE> ch1 = seg_tree [ ind * 2 + 1 ] <NEWLINE> ch2 = seg_tree [ ind * 2 + 2 ] <NEWLINE> seg_tree [ ind ] = min ( ch1 , ch2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( s , t , k , l , r ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r < s or t < l : <NEWLINE> <INDENT> return 10 ** 20 <NEWLINE> <COMMENT> <NL> <DEDENT> if s <= l and r <= t : <NEWLINE> <INDENT> return seg_tree [ k ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> vl = find ( s , t , k * 2 + 1 , l , ( l + r ) // 2 ) <NEWLINE> vr = find ( s , t , k * 2 + 2 , ( l + r ) // 2 + 1 , r ) <NEWLINE> <NL> return min ( vl , vr ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if com == 0 : <NEWLINE> <INDENT> update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer . append ( find ( x , y , 0 , 0 , size // 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in answer : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] <NEWLINE> X = [ True ] * N <NEWLINE> X [ 0 ] = False <NEWLINE> num = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> num = A [ num - 1 ] <NEWLINE> if X [ num - 1 ] : <NEWLINE> <INDENT> l . append ( num ) <NEWLINE> X [ num - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = l . index ( num ) <NEWLINE> l = l [ q : ] <NEWLINE> print ( l [ ( K - q ) % len ( l ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if 2 * j - i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] != s [ j ] != s [ 2 * j - i ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> chk = [ 0 ] * N <NEWLINE> start = - 1 <NEWLINE> ido = [ 0 ] <NEWLINE> chk [ 0 ] = 1 <NEWLINE> index = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> index = a [ index ] - 1 <NEWLINE> if chk [ index ] == 0 : <NEWLINE> <INDENT> chk [ index ] += 1 <NEWLINE> cnt += 1 <NEWLINE> ido . append ( index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = index <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt >= K : <NEWLINE> <INDENT> print ( ido [ K ] + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = ido . index ( start ) <NEWLINE> ido = ido [ tmp : ] <NEWLINE> K -= tmp <NEWLINE> print ( ido [ K % len ( ido ) ] + 1 ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> resultA = N * 100 // 108 <NEWLINE> resultB = resultA + 1 <NEWLINE> valueA = resultA * 108 // 100 <NEWLINE> valueB = resultB * 108 // 100 <NEWLINE> <NL> if N == valueA : <NEWLINE> <INDENT> print ( resultA ) <NEWLINE> <DEDENT> elif N == valueB : <NEWLINE> <INDENT> print ( resultB ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> input ( ) <NEWLINE> math_dic = collections . Counter ( ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> num = int ( input ( ) ) <NEWLINE> total_num = sum ( [ index * value for index , value in math_dic . items ( ) ] ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a not in math_dic : <NEWLINE> <INDENT> print ( total_num ) <NEWLINE> continue <NEWLINE> <DEDENT> if b not in math_dic : <NEWLINE> <INDENT> math_dic [ b ] = 0 <NEWLINE> <DEDENT> total_num -= a * math_dic [ a ] <NEWLINE> total_num += b * math_dic [ a ] <NEWLINE> math_dic [ b ] += math_dic . pop ( a ) <NEWLINE> print ( total_num ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 * 7 ) <NEWLINE> <NL> def bit_fullsearch ( target ) : <NEWLINE> <INDENT> n = len ( target ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> tmp . append ( target [ j ] ) <NEWLINE> <DEDENT> <DEDENT> ret . append ( tmp ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for l in bit_fullsearch ( lst ) : <NEWLINE> <INDENT> tmp = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> for k in l : <NEWLINE> <INDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> tmp [ i ] += k [ i ] <NEWLINE> <DEDENT> <DEDENT> if min ( tmp [ 1 : ] ) >= x : <NEWLINE> <INDENT> ans = min ( ans , tmp [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != float ( <STRING> ) else - 1 ) <NEWLINE>
import sys <NEWLINE> res = dict ( ) <NEWLINE> dll = [ None ] * 2000000 <NEWLINE> left = 0 <NEWLINE> right = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for inpt in sys . stdin . read ( ) . splitlines ( ) : <NEWLINE> <INDENT> i = inpt . split ( ) <NEWLINE> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> x = int ( i [ 1 ] ) <NEWLINE> dll [ left ] = x <NEWLINE> if ( x in res ) : <NEWLINE> <INDENT> res [ x ] . add ( left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ x ] = set ( [ left ] ) <NEWLINE> <DEDENT> left += 1 <NEWLINE> <DEDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> x = int ( i [ 1 ] ) <NEWLINE> if ( x in res ) : <NEWLINE> <INDENT> ind = max ( res [ x ] ) <NEWLINE> dll [ ind ] = None <NEWLINE> res [ x ] . remove ( ind ) <NEWLINE> if ( len ( res [ x ] ) == 0 ) : <NEWLINE> <INDENT> del res [ x ] <NEWLINE> <DEDENT> if ( ind == ( left - 1 ) ) : <NEWLINE> <INDENT> left = ind <NEWLINE> <DEDENT> if ( ind == right ) : <NEWLINE> <INDENT> right += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> left -= 1 <NEWLINE> x = dll [ left ] <NEWLINE> res [ x ] . remove ( left ) <NEWLINE> if ( len ( res [ x ] ) == 0 ) : <NEWLINE> <INDENT> del res [ x ] <NEWLINE> <DEDENT> dll [ left ] = None <NEWLINE> <DEDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> right += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ret = [ ] <NEWLINE> for x in dll [ right : left ] : <NEWLINE> <INDENT> if ( x is not None ) : <NEWLINE> <INDENT> ret . append ( str ( x ) ) <NEWLINE> <DEDENT> <DEDENT> ret . reverse ( ) <NEWLINE> print ( <STRING> . join ( ret ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> modlis = [ 0 for i in range ( 2019 ) ] <NEWLINE> modlis [ 0 ] = 1 <NEWLINE> t = 0 <NEWLINE> m = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = ( t + int ( s [ n - 1 - i ] ) * m ) % 2019 <NEWLINE> m = m * 10 % 2019 <NEWLINE> modlis [ t ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += ( modlis [ i ] * ( modlis [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = [ 0 ] * n <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> c = l [ i ] <NEWLINE> k [ c - 1 ] = k [ c - 1 ] + 1 <NEWLINE> <DEDENT> for j in range ( len ( k ) ) : <NEWLINE> <INDENT> print ( k [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> all_sum = 0 <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> all_sum += a [ i ] * s <NEWLINE> <NL> <DEDENT> print ( all_sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> def dijkstra ( n , s , g ) : <NEWLINE> <INDENT> h = [ ( 0 , s ) ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> cost = [ float ( <STRING> ) ] * ( n + 1 ) <COMMENT> <NEWLINE> cost [ s ] = 0 <NEWLINE> <NL> while h : <NEWLINE> <INDENT> c , v = heapq . heappop ( h ) <NEWLINE> if c > cost [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for d , u in g [ v ] : <NEWLINE> <INDENT> d_s_u = d + cost [ v ] <NEWLINE> if d_s_u < cost [ u ] : <NEWLINE> <INDENT> cost [ u ] = d_s_u <NEWLINE> heapq . heappush ( h , ( d_s_u , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * abc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for a , b , c in zip ( * [ iter ( abc ) ] * 3 ) : <NEWLINE> <INDENT> g [ a ] . append ( [ c , b ] ) <NEWLINE> g [ b ] . append ( [ c , a ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> checked = [ [ False ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cost = dijkstra ( n , i , g ) <NEWLINE> for j , k in g [ i ] : <NEWLINE> <INDENT> if checked [ i ] [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j > cost [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> checked [ i ] [ k ] = True <NEWLINE> checked [ k ] [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> c = Counter ( S ) <NEWLINE> ans = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = a [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> if x <= m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> m = x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( n ) - 1 for n in input ( ) . split ( ) ] <NEWLINE> <NL> pos , root , cnt , lst = 0 , { } , 0 , [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if cnt == K : <NEWLINE> <INDENT> ans = pos + 1 <NEWLINE> break <NEWLINE> <DEDENT> if pos in root : <NEWLINE> <INDENT> ans = lst [ root [ pos ] + ( K - root [ pos ] ) % ( cnt - root [ pos ] ) ] + 1 <NEWLINE> break <NEWLINE> <DEDENT> root [ pos ] = cnt <NEWLINE> lst . append ( pos ) <NEWLINE> cnt += 1 <NEWLINE> pos = A [ pos ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( len ( set ( [ input ( ) for i in range ( n ) ] ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = len ( g ) * len ( b ) * len ( r ) <NEWLINE> r = set ( r ) <NEWLINE> g = set ( g ) <NEWLINE> b = set ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 and int ( ( i + j ) / 2 ) in b : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> if abs ( i - j ) + max ( i , j ) in b : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> if min ( i , j ) - abs ( i - j ) in b : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
F = [ 0 for i in range ( 10 ) ] <NEWLINE> def dfloor ( l ) : <NEWLINE> <INDENT> f = F . copy ( ) <NEWLINE> f [ l [ 0 ] - 1 ] = l [ 1 ] <NEWLINE> return f <NEWLINE> <NL> <DEDENT> H = { 1 : [ F , F , F ] , <NEWLINE> <INDENT> 2 : [ F , F , F ] , <NEWLINE> 3 : [ F , F , F ] , <NEWLINE> 4 : [ F , F , F ] } <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> p = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a , b , c , d = tuple ( int ( n ) for n in input ( ) . split ( ) ) <NEWLINE> H [ a ] [ b - 1 ] = [ H [ a ] [ b - 1 ] [ h ] + dfloor ( [ c , d ] ) [ h ] for h in range ( 10 ) ] <NEWLINE> <DEDENT> for I in H . values ( ) : <NEWLINE> <INDENT> p += 1 <NEWLINE> for i in I : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , i ) ) ) <NEWLINE> <DEDENT> if p != 4 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> hyoukou = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> roadssta = [ ] <NEWLINE> roadsfin = [ ] <NEWLINE> <NL> ten = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> base = input ( ) . split ( ) <NEWLINE> a = int ( base [ 0 ] ) <NEWLINE> b = int ( base [ 1 ] ) <NEWLINE> if hyoukou [ a - 1 ] > hyoukou [ b - 1 ] : <NEWLINE> <INDENT> ten [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif hyoukou [ a - 1 ] < hyoukou [ b - 1 ] : <NEWLINE> <INDENT> ten [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ten [ a - 1 ] = 0 <NEWLINE> ten [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ten . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def digit_sum ( n , b ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> res = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> res += n % b <NEWLINE> n //= b <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> if n == s : <NEWLINE> <INDENT> ans = n + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if digit_sum ( n , b ) == s : <NEWLINE> <INDENT> ans = b <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> b = ( n - s ) // p + 1 <NEWLINE> if b >= 2 and digit_sum ( n , b ) == s : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> if b >= 1 and digit_sum ( n , b + 1 ) == s : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = b + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( y - 1 ) <NEWLINE> edge [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( node , tmp ) : <NEWLINE> <INDENT> a [ node ] += tmp <NEWLINE> b [ node ] = 1 <NEWLINE> for i in edge [ node ] : <NEWLINE> <INDENT> if b [ i ] == 0 : <NEWLINE> <INDENT> dfs ( i , a [ node ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> l = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <NL> <DEDENT> s = sum ( a ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * l [ b ] <NEWLINE> l [ c ] += l [ b ] <NEWLINE> l [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <NL> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n , m = len ( s ) , len ( t ) <NEWLINE> print ( min ( sum ( si != ti for si , ti in zip ( s [ i : i + m ] , t ) ) for i in range ( n - m + 1 ) ) ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> town_loop = [ 1 ] <NEWLINE> used = [ - 1 ] * n <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> next_town = alist [ town_loop [ i ] - 1 ] <NEWLINE> <NL> if used [ next_town - 1 ] == - 1 : <NEWLINE> <INDENT> town_loop . append ( next_town ) <NEWLINE> used [ next_town - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> loop_start = town_loop . index ( next_town ) <NEWLINE> if len ( town_loop ) == k + 1 : <NEWLINE> <INDENT> print ( town_loop [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o = len ( town_loop ) - loop_start <NEWLINE> print ( town_loop [ ( ( k - loop_start ) % o ) + loop_start ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if n * a < b : <NEWLINE> <INDENT> print ( n * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
n , q , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> a [ i ] -= a [ i - 1 ] <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> count -= a [ i ] * s if a [ i ] > 0 else a [ i ] * t <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count += a [ l ] * s if a [ l ] > 0 else a [ l ] * t <NEWLINE> a [ l ] += x <NEWLINE> count -= a [ l ] * s if a [ l ] > 0 else a [ l ] * t <NEWLINE> if r < n : <NEWLINE> <INDENT> count += a [ r + 1 ] * s if a [ r + 1 ] > 0 else a [ r + 1 ] * t <NEWLINE> a [ r + 1 ] -= x <NEWLINE> count -= a [ r + 1 ] * s if a [ r + 1 ] > 0 else a [ r + 1 ] * t <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n_input = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n_input + 1 ) : <NEWLINE> <INDENT> n = n_input // i <NEWLINE> ans += n * ( 1 + n ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
lsnum = list ( input ( ) ) <NEWLINE> lsnum1 = [ int ( i ) for i in lsnum ] <NEWLINE> ls = [ <STRING> , <STRING> ] <NEWLINE> for i in range ( 2 ** 3 ) : <NEWLINE> <INDENT> ans = lsnum1 [ 0 ] <NEWLINE> for j in range ( 3 ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> ans += lsnum1 [ j + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= lsnum1 [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> if ans == 7 : <NEWLINE> <INDENT> bit = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans2 = lsnum [ 0 ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( ( bit >> i ) & 1 ) : <NEWLINE> <INDENT> ans2 += <STRING> + lsnum [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += <STRING> + lsnum [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans2 + <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> n = A [ i ] * A [ i + 1 ] <NEWLINE> n = n % mod <NEWLINE> s += n <NEWLINE> s %= mod <NEWLINE> A [ i + 1 ] += A [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> tb = [ <NEWLINE> <INDENT> [ math . gcd ( a , b ) for a in range ( 0 , 201 ) ] <NEWLINE> for b in range ( 0 , 201 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> x = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = tb [ a ] [ b ] <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x += tb [ t ] [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> count = 0 <NEWLINE> ironbar = list ( accumulate ( A ) ) <NEWLINE> <NL> min_value = ironbar [ - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> bet = abs ( ironbar [ i ] - ( ironbar [ - 1 ] - ironbar [ i ] ) ) <NEWLINE> <NL> if min_value > bet : <NEWLINE> <INDENT> min_value = bet <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_value ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a * b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1 <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * 100002 <NEWLINE> for x in A : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> C [ x + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( C ) ) <NEWLINE>
from collections import deque <NEWLINE> queue = deque ( [ ] ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> _ = queue . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> _ = queue . pop ( ) <NEWLINE> <DEDENT> elif <STRING> in command : <NEWLINE> <INDENT> _ , x = command . split ( ) <NEWLINE> try : <NEWLINE> <INDENT> queue . remove ( x ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> _ , x = command . split ( ) <NEWLINE> queue . appendleft ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( queue ) ) <NEWLINE>
<COMMENT> <NL> <NL> from math import floor <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = eval ( input ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = eval ( input ( ) ) <NEWLINE> ls . append ( m ) <NEWLINE> <DEDENT> ls . remove ( max ( ls ) ) <NEWLINE> ls . remove ( min ( ls ) ) <NEWLINE> print ( floor ( sum ( ls ) / len ( ls ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from math import floor , ceil , pi , factorial <NEWLINE> from operator import itemgetter <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI2 ( ) : return [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> def MXI ( ) : return [ [ LI ( ) ] for i in range ( n ) ] <NEWLINE> def SI ( ) : return input ( ) . rstrip ( ) <NEWLINE> def printns ( x ) : print ( <STRING> . join ( x ) ) <NEWLINE> def printni ( x ) : print ( <STRING> . join ( list ( map ( str , x ) ) ) ) <NEWLINE> inf = 10 ** 17 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , m , que = MI ( ) <NEWLINE> lis = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = MI ( ) <NEWLINE> lis [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> lis [ i ] = list ( accumulate ( lis [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> lis [ j + 1 ] [ i ] += lis [ j ] [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( que ) : <NEWLINE> <INDENT> p , q = MI ( ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> ans = lis [ q - 1 ] [ q - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lis [ q - 1 ] [ q - 1 ] - lis [ p - 2 ] [ q - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> s = int ( n ** ( 1 / 2 ) ) + 1 <NEWLINE> for i in range ( 1 , s ) : <NEWLINE> <INDENT> for j in range ( 1 , s ) : <NEWLINE> <INDENT> for k in range ( 1 , s ) : <NEWLINE> <INDENT> b = i * i + j * j + k * k + i * j + j * k + k * i - 1 <NEWLINE> if b < n : <NEWLINE> <INDENT> a [ b ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> p = M <NEWLINE> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ p ] > K - A [ i ] : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + p ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> q = [ ] <NEWLINE> heapq . heappush ( q , - arr [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( q ) <NEWLINE> tmp *= - 1 <NEWLINE> ans += tmp <NEWLINE> heapq . heappush ( q , - arr [ i ] ) <NEWLINE> heapq . heappush ( q , - arr [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def bin_tree ( lst , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> info = [ [ - 1 , - 1 , - 1 , - 1 , - 1 , - 1 ] for n in range ( 0 , n ) ] <NEWLINE> degree = 0 <NEWLINE> for node , left , right in lst : <NEWLINE> <INDENT> if left >= 0 : <NEWLINE> <INDENT> info [ left ] [ 1 ] = node <NEWLINE> info [ left ] [ 2 ] = right <NEWLINE> degree += 1 <NEWLINE> <NL> <DEDENT> if right >= 0 : <NEWLINE> <INDENT> info [ right ] [ 1 ] = node <NEWLINE> info [ right ] [ 2 ] = left <NEWLINE> degree += 1 <NEWLINE> <NL> <DEDENT> info [ node ] [ 0 ] = node <NEWLINE> info [ node ] [ 3 ] = degree <NEWLINE> <NL> degree = 0 <NEWLINE> <NL> <DEDENT> root = - 1 <NEWLINE> for node in info : <NEWLINE> <INDENT> root = node [ 0 ] <NEWLINE> if node [ 1 ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> get_depth ( lst , root , info ) <NEWLINE> get_height ( lst , root , info ) <NEWLINE> print_info ( info ) <NEWLINE> <NL> <NL> <DEDENT> def get_height ( tree , root , info ) : <NEWLINE> <INDENT> def _get_height ( node , depth ) : <NEWLINE> <INDENT> if node == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> left_height = _get_height ( tree [ node ] [ 1 ] , depth + 1 ) <NEWLINE> right_height = _get_height ( tree [ node ] [ 2 ] , depth + 1 ) <NEWLINE> <NL> if left_height > right_height : <NEWLINE> <INDENT> info [ node ] [ 5 ] = left_height <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> info [ node ] [ 5 ] = right_height <NEWLINE> <NL> <DEDENT> return info [ node ] [ 5 ] + 1 <NEWLINE> <NL> <DEDENT> _get_height ( root , 0 ) <NEWLINE> <NL> <NL> <DEDENT> def get_depth ( tree , root , info ) : <NEWLINE> <INDENT> def _get_depth ( node , depth ) : <NEWLINE> <INDENT> if node == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> info [ node ] [ 4 ] = depth <NEWLINE> _get_depth ( tree [ node ] [ 1 ] , depth + 1 ) <NEWLINE> _get_depth ( tree [ node ] [ 2 ] , depth + 1 ) <NEWLINE> <NL> <DEDENT> _get_depth ( root , 0 ) <NEWLINE> <NL> <NL> <DEDENT> def print_info ( info ) : <NEWLINE> <INDENT> for node , parent , sibling , degree , depth , height in info : <NEWLINE> <INDENT> if parent == - 1 : <NEWLINE> <INDENT> _type = <STRING> <NEWLINE> <DEDENT> elif degree != 0 : <NEWLINE> <INDENT> _type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _type = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( node , parent , sibling , degree , depth , height , _type ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = [ [ int ( n ) for n in val . split ( ) ] for val in sys . stdin . readlines ( ) ] <NEWLINE> lst . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> bin_tree ( lst , n ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def search ( l , dic1 , dic2 ) : <NEWLINE> <INDENT> if not l : <NEWLINE> <INDENT> return ( dic2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = l . pop ( ) <NEWLINE> for y in dic1 [ x ] : <NEWLINE> <INDENT> if dic2 [ y ] == 0 : <NEWLINE> <INDENT> l . appendleft ( y ) <NEWLINE> dic2 [ y ] = x <NEWLINE> <DEDENT> <DEDENT> return search ( l , dic1 , dic2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ i + 1 for i in range ( n ) ] <NEWLINE> dic1 = { i : [ ] for i in l } <NEWLINE> dic2 = { i : 0 for i in l } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dic1 [ a ] . append ( b ) <NEWLINE> dic1 [ b ] . append ( a ) <NEWLINE> <DEDENT> l = deque ( dic1 [ 1 ] ) <NEWLINE> for z in l : <NEWLINE> <INDENT> dic2 [ z ] = 1 <NEWLINE> <NL> <DEDENT> d = search ( l , dic1 , dic2 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for k in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( dic2 [ k ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . sort ( reverse = True ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> ans = 0 ; break <NEWLINE> <DEDENT> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 ; break <NEWLINE> <DEDENT> ans = ans * i <NEWLINE> <DEDENT> <DEDENT> print ( - 1 if ans > ( 10 ** 18 ) else ans ) <NEWLINE>
S = [ 0 for i in range ( 300000 ) ] <NEWLINE> S2 = [ ] <NEWLINE> A = [ - 1 , 1 ] <NEWLINE> for i in range ( 1 , int ( 300000 / 7 ) + 1 ) : <NEWLINE> <INDENT> d = 7 * i <NEWLINE> for a in A : <NEWLINE> <INDENT> da = d + a <NEWLINE> if da < 300000 and S [ da ] == 0 : <NEWLINE> <INDENT> S2 . append ( da ) <NEWLINE> for j in range ( 2 , int ( 300000 / 2 ) ) : <NEWLINE> <INDENT> if da * j >= 300000 : break <NEWLINE> S [ da * j ] = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( str ( n ) + <STRING> , <STRING> . join ( [ str ( x ) for x in S2 if n % x == 0 and x <= n ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> count = 0 <NEWLINE> for l in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( l , m ) <NEWLINE> for n in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( x , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> def gud ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gud ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> a = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( n , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> comb_count = { 1 : 1 , 2 : 3 , 3 : 6 } <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * comb_count [ len ( set ( [ a , b , c ] ) ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> while H != 0 or W != 0 : <NEWLINE> <INDENT> S = <STRING> <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> S = <STRING> <NEWLINE> for i in range ( W - 2 ) : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> S += <STRING> <NEWLINE> print ( S ) <NEWLINE> <DEDENT> S = <STRING> <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> print ( S , end = <STRING> ) <NEWLINE> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = int ( input ( ) ) <NEWLINE> c = ( a * b ) // math . gcd ( a , b ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> c = ( c * b ) // math . gcd ( c , b ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) - 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = int ( A [ N ] ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while N > 0 : <NEWLINE> <INDENT> ans = ans * A [ N - 1 ] <NEWLINE> N = N - 1 <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> N = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = N <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power = power % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( power ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> from collections import Counter <NEWLINE> <NL> cnt = Counter ( ) <NEWLINE> for line in stdin : <NEWLINE> <INDENT> start , end = ( int ( s ) for s in line . split ( ) ) <NEWLINE> if start or end : <NEWLINE> <INDENT> cnt [ start ] += 1 <NEWLINE> cnt [ end ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> semi_eulerian = sum ( i % 2 for i in cnt . values ( ) ) == 2 <NEWLINE> if semi_eulerian and cnt [ 1 ] % 2 and cnt [ 2 ] % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> cnt . clear ( ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> d_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> d_c = collections . Counter ( d_list ) <NEWLINE> t_c = collections . Counter ( t_list ) <NEWLINE> <NL> for i in t_c : <NEWLINE> <INDENT> if t_c [ i ] <= d_c [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import heapq as hq <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( ( b , 1 ) ) <NEWLINE> edges [ b ] . append ( ( a , 1 ) ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> d = [ INF ] * N <NEWLINE> d [ 0 ] = 0 <NEWLINE> prev = [ None ] * N <NEWLINE> q = [ ( 0 , 0 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> dist , i = hq . heappop ( q ) <NEWLINE> if d [ i ] < dist : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j , w in edges [ i ] : <NEWLINE> <INDENT> if d [ j ] > d [ i ] + w : <NEWLINE> <INDENT> d [ j ] = d [ i ] + w <NEWLINE> prev [ j ] = i <NEWLINE> hq . heappush ( q , ( d [ j ] , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> path = deque ( ) <NEWLINE> i = N - 1 <NEWLINE> while prev [ i ] != 0 : <NEWLINE> <INDENT> path . append ( prev [ i ] ) <NEWLINE> i = prev [ i ] <NEWLINE> <DEDENT> fncq = deque ( [ 0 ] ) <NEWLINE> snkq = deque ( [ N - 1 ] ) <NEWLINE> fnc = 1 <NEWLINE> snk = 1 <NEWLINE> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> visited [ N - 1 ] = True <NEWLINE> while path : <NEWLINE> <INDENT> v = path . pop ( ) <NEWLINE> fncq . append ( v ) <NEWLINE> visited [ v ] = True <NEWLINE> fnc += 1 <NEWLINE> if path : <NEWLINE> <INDENT> v = path . popleft ( ) <NEWLINE> snkq . append ( v ) <NEWLINE> visited [ v ] = True <NEWLINE> snk += 1 <NEWLINE> <DEDENT> <DEDENT> po = [ fncq , snkq ] <NEWLINE> while fncq or snkq : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> q = po [ i ] <NEWLINE> if q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w , _ in edges [ v ] : <NEWLINE> <INDENT> if not visited [ w ] : <NEWLINE> <INDENT> visited [ w ] = True <NEWLINE> q . append ( w ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> fnc += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> snk += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if fnc > snk else <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> visited = [ 0 ] * n <NEWLINE> visited [ 0 ] = 1 <NEWLINE> visit_list = [ 0 ] <NEWLINE> visit = 0 <NEWLINE> while True : <NEWLINE> <INDENT> new_visit = a [ visit ] <NEWLINE> if visited [ new_visit ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited [ new_visit ] = 1 <NEWLINE> visit_list . append ( new_visit ) <NEWLINE> visit = new_visit <NEWLINE> <NL> <DEDENT> period_first_index = visit_list . index ( a [ visit_list [ - 1 ] ] ) <NEWLINE> period_list = visit_list [ period_first_index : ] <NEWLINE> <NL> if k < len ( visit_list ) : <NEWLINE> <INDENT> print ( visit_list [ k ] + 1 ) <NEWLINE> <DEDENT> elif k == len ( visit_list ) : <NEWLINE> <INDENT> print ( a [ visit_list [ - 1 ] ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( period_list [ ( k - period_first_index ) % len ( period_list ) ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> good = [ True ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> b = b - 1 <NEWLINE> if not H [ a ] > H [ b ] : <NEWLINE> <INDENT> good [ a ] = False <NEWLINE> <DEDENT> if not H [ a ] < H [ b ] : <NEWLINE> <INDENT> good [ b ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ 1 if good [ i ] else 0 for i in range ( N ) ] ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> for n in stdin : <NEWLINE> <INDENT> if int ( n ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> bottom_total = [ ] <NEWLINE> right_total = [ ] <NEWLINE> for _ in range ( int ( n ) ) : <NEWLINE> <INDENT> line = input ( ) . split ( <STRING> ) <NEWLINE> total = 0 <NEWLINE> for i , v in enumerate ( line ) : <NEWLINE> <INDENT> print ( repr ( int ( v ) ) . rjust ( 5 ) , end = <STRING> ) <NEWLINE> total += int ( v ) <NEWLINE> if len ( bottom_total ) < i + 1 : <NEWLINE> <INDENT> bottom_total . append ( int ( v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom_total [ i ] += int ( v ) <NEWLINE> <DEDENT> <DEDENT> right_total . append ( total ) <NEWLINE> print ( repr ( right_total [ _ ] ) . rjust ( 5 ) ) <NEWLINE> <NL> <DEDENT> for num in bottom_total : <NEWLINE> <INDENT> print ( repr ( num ) . rjust ( 5 ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( repr ( sum ( bottom_total ) ) . rjust ( 5 ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> hight = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tenbou = [ input ( ) . split ( ) for l in range ( M ) ] <NEWLINE> result = [ 1 ] * N <NEWLINE> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x = int ( tenbou [ i ] [ 0 ] ) - 1 <NEWLINE> y = int ( tenbou [ i ] [ 1 ] ) - 1 <NEWLINE> if hight [ x ] > hight [ y ] : <NEWLINE> <INDENT> result [ y ] = 0 <NEWLINE> <DEDENT> elif hight [ y ] == hight [ x ] : <NEWLINE> <INDENT> result [ x ] = 0 <NEWLINE> result [ y ] = 0 <NEWLINE> <DEDENT> elif hight [ y ] > hight [ x ] : <NEWLINE> <INDENT> result [ x ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( result . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 , 1 ) : <NEWLINE> <INDENT> t = int ( n / i ) <NEWLINE> sum += i * t * ( t + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( sum ) ) <NEWLINE> <NL>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 9 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = i ( ) <NEWLINE> S = [ l ( ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> pq = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> for j in S : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pq . append ( ( i [ 0 ] - j [ 0 ] , i [ 1 ] - j [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> for p , q in set ( pq ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> for j in S : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i [ 0 ] - j [ 0 ] , i [ 1 ] - j [ 1 ] ) == ( p , q ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( N - ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> <NL> S , stack = [ ] , [ ] <NEWLINE> N = 0 <NEWLINE> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> global N <NEWLINE> N , A , B , C = rmi ( ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S . append ( r ( ) ) <NEWLINE> <DEDENT> enable = dfs ( stack , 0 , A , B , C ) <NEWLINE> w ( <STRING> if enable else <STRING> ) <NEWLINE> if enable : <NEWLINE> <INDENT> wm ( * stack , delim = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( stack , index , a , b , c ) -> bool : <NEWLINE> <INDENT> if N <= index : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> inst = S [ index ] <NEWLINE> if inst == <STRING> : <NEWLINE> <INDENT> if a <= 0 and b <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < a : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a - 1 , b + 1 , c ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if 0 < b : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a + 1 , b - 1 , c ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> if a <= 0 and c <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < a : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a - 1 , b , c + 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if 0 < c : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a + 1 , b , c - 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b <= 0 and c <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < b : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a , b - 1 , c + 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if 0 < c : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a , b + 1 , c - 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def r ( ) -> str : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def ri ( ) -> int : <NEWLINE> <INDENT> return int ( r ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rmi ( delim : str = <STRING> ) -> tuple : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( delim ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def w ( data ) -> None : <NEWLINE> <INDENT> print ( data ) <NEWLINE> <NL> <NL> <DEDENT> def wm ( * data , delim : str = <STRING> ) -> None : <NEWLINE> <INDENT> print ( delim . join ( map ( str , data ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> ul = int ( n ** 0.5 ) <NEWLINE> <NL> for i in range ( 1 , ul ) : <NEWLINE> <INDENT> for j in range ( 1 , ul ) : <NEWLINE> <INDENT> for k in range ( 1 , ul ) : <NEWLINE> <INDENT> d [ i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d . get ( j , 0 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def get_distance ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> d = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> return d <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> Data = input ( ) . split ( ) <NEWLINE> x1 = float ( Data [ 0 ] ) <NEWLINE> y1 = float ( Data [ 1 ] ) <NEWLINE> x2 = float ( Data [ 2 ] ) <NEWLINE> y2 = float ( Data [ 3 ] ) <NEWLINE> <NL> d = get_distance ( x1 , y1 , x2 , y2 ) <NEWLINE> print ( d ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( sorted ( a ) ) ) <NEWLINE>
import heapq <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( [ c , b - 1 ] ) <NEWLINE> G [ b - 1 ] . append ( [ c , a - 1 ] ) <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def dijkstra ( s , N , G ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * N <NEWLINE> d [ s ] = 0 <NEWLINE> hq = [ [ 0 , s ] ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> while len ( hq ) > 0 : <NEWLINE> <INDENT> v , i = heapq . heappop ( hq ) <NEWLINE> if d [ i ] < v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for c , j in G [ i ] : <NEWLINE> <INDENT> if d [ j ] > d [ i ] + c : <NEWLINE> <INDENT> d [ j ] = d [ i ] + c <NEWLINE> heapq . heappush ( hq , [ d [ j ] , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> D = dijkstra ( K - 1 , N , G ) <NEWLINE> <NL> dist = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dist [ i ] = D [ x - 1 ] + D [ y - 1 ] <NEWLINE> <NL> <DEDENT> for d in dist : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> if n & 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( a [ : : - 2 ] + a [ 1 : : 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( a [ - 1 : 0 : - 2 ] + a [ : : 2 ] ) ) <NEWLINE> <DEDENT>
class FordFulkerson : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , V , E , source , sink ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . V = V <NEWLINE> self . E = [ [ ] for _ in range ( V ) ] <NEWLINE> for fr in range ( V ) : <NEWLINE> <INDENT> for to , cap in E [ fr ] : <NEWLINE> <INDENT> self . E [ fr ] . append ( [ to , cap , len ( self . E [ to ] ) ] ) <NEWLINE> self . E [ to ] . append ( [ fr , 0 , len ( self . E [ fr ] ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> self . maxflow = self . ford_fulkerson ( source , sink ) <NEWLINE> <NL> <DEDENT> def ford_fulkerson ( self , source , sink , INF = 10 ** 9 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def dfs ( vertex , sink , flow ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if vertex == sink : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> used [ vertex ] = True <NEWLINE> for i , ( to , cap , rev ) in enumerate ( self . E [ vertex ] ) : <NEWLINE> <INDENT> if not used [ to ] and cap > 0 : <NEWLINE> <INDENT> d = dfs ( to , sink , min ( flow , cap ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> self . E [ vertex ] [ i ] [ 1 ] -= d <NEWLINE> self . E [ to ] [ rev ] [ 1 ] += d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> maxflow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> used = [ False ] * self . V <NEWLINE> flow = dfs ( source , sink , INF ) <NEWLINE> if flow == 0 : <NEWLINE> <INDENT> return maxflow <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxflow += flow <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( V ) ] <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> u , v , cap = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ u ] . append ( ( v , cap ) ) <NEWLINE> <DEDENT> print ( FordFulkerson ( V , edge , 0 , V - 1 ) . maxflow ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , M = I ( ) <NEWLINE> X = l ( ) <NEWLINE> X . sort ( ) <NEWLINE> kyori = [ ] <NEWLINE> <NL> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if M == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( X ) - 1 ) : <NEWLINE> <INDENT> s = X [ i + 1 ] - X [ i ] <NEWLINE> kyori . append ( s ) <NEWLINE> <NL> <DEDENT> kyori . sort ( ) <NEWLINE> kyori . reverse ( ) <NEWLINE> <NL> for j in range ( N - 1 ) : <NEWLINE> <INDENT> kyori . pop ( 0 ) <NEWLINE> <NL> <DEDENT> print ( sum ( kyori ) ) <NEWLINE>
s , t = [ input ( ) for i in range ( 2 ) ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> d = len ( t ) <NEWLINE> for a , b in zip ( s [ i : ] , t ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> <DEDENT> c . append ( d ) <NEWLINE> <DEDENT> print ( min ( c ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_lists = [ a , b , c ] <NEWLINE> maximum = a <NEWLINE> if maximum < b : maximum = b <NEWLINE> if maximum < c : maximum = c <NEWLINE> <NL> max_index = num_lists . index ( maximum ) <NEWLINE> num_lists . pop ( max_index ) <NEWLINE> <NL> remainder = num_lists [ 0 ] + num_lists [ 1 ] <NEWLINE> if maximum == remainder : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = { i : i for i in range ( 1 , n + 1 ) } <NEWLINE> self . rank = { i : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> self . size = { i : 1 for i in range ( 1 , n + 1 ) } <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if x != self . par [ x ] : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> <DEDENT> return self . par [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> px , py = self . find ( x ) , self . find ( y ) <NEWLINE> res = 0 <NEWLINE> if px != py : <NEWLINE> <INDENT> if self . rank [ px ] < self . rank [ py ] : <NEWLINE> <INDENT> self . par [ px ] = py <NEWLINE> self . size [ py ] += self . size [ px ] <NEWLINE> res = self . size [ py ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ py ] = px <NEWLINE> self . size [ px ] += self . size [ py ] <NEWLINE> if self . rank [ px ] == self . rank [ py ] : <NEWLINE> <INDENT> self . rank [ px ] += 1 <NEWLINE> <DEDENT> res = self . size [ px ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = max ( ans , uf . union ( a , b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> Max = a [ - 1 ] <NEWLINE> memo = [ 1 ] * ( Max + 1 ) <NEWLINE> count = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> if memo [ t ] == 1 : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> for j in [ t * k for k in range ( 1 , Max // t + 1 ) ] : <NEWLINE> <INDENT> memo [ j ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if memo [ a [ n - 1 ] ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <STRING> <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( inp ) <NEWLINE> arr = [ 1 ] * ( max ( inp ) + 1 ) <NEWLINE> inp . sort ( ) <NEWLINE> d = Counter ( [ ] ) <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if c [ i ] >= 1 and arr [ i ] == 1 : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 <NEWLINE> while k * i < len ( arr ) : <NEWLINE> <INDENT> arr [ k * i ] = 0 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for item in d . keys ( ) : <NEWLINE> <INDENT> if c [ item ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> aa = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> x = sum ( aa ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x -= aa [ i ] <NEWLINE> ans += aa [ i ] * x <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> dp = [ False for _ in range ( x + 1 ) ] <NEWLINE> dp [ 0 ] = True <NEWLINE> <NL> if 1 <= x < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> for i in range ( 100 , x + 1 ) : <NEWLINE> <INDENT> tmp = False <NEWLINE> for j in range ( 6 ) : <NEWLINE> <INDENT> if i - ( 100 + j ) >= 0 : <NEWLINE> <INDENT> tmp = ( tmp or dp [ i - ( 100 + j ) ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> if dp [ x ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
INF = 10 ** 20 <NEWLINE> <NL> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> manju_lst = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> manju_lst . sort ( reverse = True ) <NEWLINE> <NL> acc = 0 <NEWLINE> cum_sum = [ 0 ] <NEWLINE> for manju in manju_lst : <NEWLINE> <INDENT> acc += manju <NEWLINE> cum_sum . append ( acc ) <NEWLINE> <NL> <DEDENT> clst = [ ] <NEWLINE> elst = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c , e = map ( int , input ( ) . split ( ) ) <NEWLINE> clst . append ( c ) <NEWLINE> elst . append ( e ) <NEWLINE> <NL> <DEDENT> dp = [ [ INF ] * ( m + 1 ) for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> cx = clst [ x ] <NEWLINE> ex = elst [ x ] <NEWLINE> for y in range ( m , 0 , - 1 ) : <NEWLINE> <INDENT> if y >= cx : <NEWLINE> <INDENT> dp [ x ] [ y ] = min ( dp [ x - 1 ] [ y ] , dp [ x - 1 ] [ y - cx ] + ex ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y + 1 <= m : <NEWLINE> <INDENT> dp [ x ] [ y ] = min ( dp [ x - 1 ] [ y ] , dp [ x ] [ y + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] [ y ] = min ( dp [ x - 1 ] [ y ] , ex ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ cum_sum [ x ] - dp [ n - 1 ] [ x ] for x in range ( m + 1 ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> S = list ( set ( S ) ) <NEWLINE> print ( len ( S ) ) <NEWLINE>
n = m = int ( input ( ) ) <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> m = m // i * ( i - 1 ) <NEWLINE> while n % i == 0 : n //= i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n != 1 : m = m // n * ( n - 1 ) <NEWLINE> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> nl = [ ] <NEWLINE> jo = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nl . append ( int ( a [ i ] ) ) <NEWLINE> jo = jo ^ int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = nl [ i ] ^ jo <NEWLINE> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> q = deque ( range ( 1 , 10 ) ) <NEWLINE> <NL> for i in range ( k - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = q . popleft ( ) <NEWLINE> y = int ( str ( x ) [ - 1 ] ) <NEWLINE> if y - 1 >= 0 : <NEWLINE> <INDENT> q . append ( int ( str ( x ) + str ( y - 1 ) ) ) <NEWLINE> <DEDENT> q . append ( int ( str ( x ) + str ( x ) [ - 1 ] ) ) <NEWLINE> if y + 1 < 10 : <NEWLINE> <INDENT> q . append ( int ( str ( x ) + str ( y + 1 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( q [ 0 ] ) <NEWLINE> <NL> <NL>
def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> G = [ ] <NEWLINE> G . append ( 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 3 * G [ - 1 ] + 1 <NEWLINE> if tmp > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> G . reverse ( ) <NEWLINE> m = len ( G ) <NEWLINE> <NL> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> cnt = insertionSort ( A , n , G [ i ] , cnt ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> shellSort ( a , n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> <NL> def swap ( a , b ) : <NEWLINE> <INDENT> return max ( a , b ) , min ( a , b ) <NEWLINE> <NL> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> _ = input ( ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> an . sort ( ) <NEWLINE> target = an [ - 1 ] / 2 <NEWLINE> res = min ( enumerate ( an ) , key = lambda x : abs ( target - x [ 1 ] ) ) <NEWLINE> print ( an [ - 1 ] , res [ 1 ] ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> p = factorization ( x ) <NEWLINE> p = make_divisors ( x ) <NEWLINE> <COMMENT> <NL> Bas = 0 <NEWLINE> Aas = 0 <NEWLINE> <NL> flg = False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> _p = p [ i ] <NEWLINE> <COMMENT> <NL> B = int ( - _p / 2 ) <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> xnew = ( B + _p ) ** 5 - B ** 5 <NEWLINE> <COMMENT> <NL> if xnew == x : <NEWLINE> <INDENT> Bas = B <NEWLINE> Aas = B + _p <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> if xnew > x : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> B += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> products = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> for can_w , can_v in products : <NEWLINE> <INDENT> dp [ can_w : ] = np . maximum ( dp [ can_w : ] , dp [ : - can_w ] + can_v ) <NEWLINE> <NL> <DEDENT> print ( np . max ( dp ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> import heapq <NEWLINE> G = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> k = i [ 1 ] <NEWLINE> G [ i [ 0 ] ] = list ( zip ( i [ 2 : : 2 ] , i [ 3 : : 2 ] ) ) <NEWLINE> <NL> <DEDENT> def dijkstra ( G ) : <NEWLINE> <INDENT> d = [ 0 ] + [ float ( <STRING> ) ] * ( n - 1 ) <NEWLINE> Q = [ ( d [ i ] , i ) for i in range ( n ) ] <NEWLINE> heapq . heapify ( Q ) <NEWLINE> while len ( Q ) != 0 : <NEWLINE> <INDENT> _ , u = heapq . heappop ( Q ) <NEWLINE> for v , c in G [ u ] : <NEWLINE> <INDENT> if d [ v ] > d [ u ] + c : <NEWLINE> <INDENT> d [ v ] = d [ u ] + c <NEWLINE> heapq . heappush ( Q , ( d [ v ] , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> for i , j in enumerate ( dijkstra ( G ) ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ i for i in range ( n ) ] <NEWLINE> self . components = n <COMMENT> <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = self . root ( self . p [ x ] ) <NEWLINE> return self . p [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . root ( x ) , self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> self . components -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return ( self . root ( x ) == self . root ( y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> X , Y = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( [ x , i ] ) <NEWLINE> Y . append ( [ y , i ] ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> Y . sort ( ) <NEWLINE> <NL> edges = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> edges . append ( [ X [ i + 1 ] [ 0 ] - X [ i ] [ 0 ] , X [ i ] [ 1 ] , X [ i + 1 ] [ 1 ] ] ) <NEWLINE> edges . append ( [ Y [ i + 1 ] [ 0 ] - Y [ i ] [ 0 ] , Y [ i ] [ 1 ] , Y [ i + 1 ] [ 1 ] ] ) <NEWLINE> <DEDENT> edges . sort ( ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> ans = 0 <NEWLINE> for cost , s , t in edges : <NEWLINE> <INDENT> if UF . same ( s , t ) : continue <NEWLINE> <NL> UF . unite ( s , t ) <NEWLINE> ans += cost <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x_sort = sorted ( x [ : ] ) <NEWLINE> a , b = x_sort [ n // 2 - 1 ] , x_sort [ n // 2 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
def rerooting ( n , edges , identity , merge , add_node ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> G = [ [ ] for _ in range ( n ) ] <NEWLINE> G_idxs = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> G_idxs [ a ] . append ( len ( G [ b ] ) ) <NEWLINE> G_idxs [ b ] . append ( len ( G [ a ] ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> parents = [ 0 ] * n <NEWLINE> order = [ ] <COMMENT> <NEWLINE> stack = [ 0 ] <NEWLINE> parents [ 0 ] = - 1 <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> p = parents [ v ] <NEWLINE> order . append ( v ) <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> if p != u : <NEWLINE> <INDENT> stack . append ( u ) <NEWLINE> parents [ u ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> subtree_res = [ [ 0 ] * len ( Gv ) for Gv in G ] <NEWLINE> <COMMENT> <NL> for v in order [ : 0 : - 1 ] : <NEWLINE> <INDENT> p = parents [ v ] <NEWLINE> result = identity <NEWLINE> for idx_Gv , ( u , subtree_res_v_i ) in enumerate ( zip ( G [ v ] , subtree_res [ v ] ) ) : <NEWLINE> <INDENT> if p == u : <NEWLINE> <INDENT> parent_idx = idx_Gv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = merge ( result , subtree_res_v_i ) <NEWLINE> <DEDENT> <DEDENT> idx_p2v = G_idxs [ v ] [ parent_idx ] <NEWLINE> subtree_res [ p ] [ idx_p2v ] = add_node ( result , v ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> results = [ 0 ] * n <NEWLINE> for v in order : <NEWLINE> <INDENT> subtree_res_v = subtree_res [ v ] <NEWLINE> cum = identity <NEWLINE> cum_from_tail = [ identity ] <NEWLINE> for r in subtree_res_v [ : 0 : - 1 ] : <NEWLINE> <INDENT> cum = merge ( r , cum ) <NEWLINE> cum_from_tail . append ( cum ) <NEWLINE> <DEDENT> cum_from_tail . reverse ( ) <NEWLINE> cum = identity <NEWLINE> for r , cum_t , u , idx_u2v in zip ( subtree_res_v , cum_from_tail , G [ v ] , G_idxs [ v ] ) : <NEWLINE> <INDENT> result = add_node ( merge ( cum , cum_t ) , v ) <NEWLINE> subtree_res [ u ] [ idx_u2v ] = result <NEWLINE> cum = merge ( cum , r ) <NEWLINE> <DEDENT> results [ v ] = add_node ( cum , v ) <NEWLINE> <DEDENT> return results <NEWLINE> <NL> <NL> <DEDENT> class Combination : <NEWLINE> <INDENT> def __init__ ( self , n_max , mod = 10 ** 9 + 7 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . mod = mod <NEWLINE> f = 1 <NEWLINE> self . fac = fac = [ f ] <NEWLINE> for i in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> fac . append ( f ) <NEWLINE> <DEDENT> f = pow ( f , mod - 2 , mod ) <NEWLINE> self . facinv = facinv = [ f ] <NEWLINE> for i in range ( n_max , 0 , - 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> facinv . append ( f ) <NEWLINE> <DEDENT> facinv . reverse ( ) <NEWLINE> <NL> <DEDENT> def __call__ ( self , n , r ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> AB = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> comb = Combination ( 202020 ) <NEWLINE> identity = ( 1 , 0 ) <NEWLINE> merge = lambda a , b : ( a [ 0 ] * b [ 0 ] % mod * comb ( a [ 1 ] + b [ 1 ] , a [ 1 ] ) % mod , a [ 1 ] + b [ 1 ] ) <NEWLINE> add_node = lambda value , idx : ( value [ 0 ] , value [ 1 ] + 1 ) <NEWLINE> Ans = rerooting ( N , AB , identity , merge , add_node ) <NEWLINE> print ( <STRING> . join ( str ( ans ) for ans , _ in Ans ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vo1 = v [ 1 : : 2 ] <NEWLINE> ve2 = v [ 0 : : 2 ] <NEWLINE> co1_k , co1_v = zip ( * Counter ( vo1 ) . most_common ( ) ) <NEWLINE> ce2_k , ce2_v = zip ( * Counter ( ve2 ) . most_common ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if vo1 == ve2 : <NEWLINE> <INDENT> if len ( ce2_k ) <= 2 : <NEWLINE> <INDENT> ans = sum ( ce2_v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( ce2_v ) + sum ( co1_v [ 2 : ] ) <NEWLINE> <DEDENT> <DEDENT> elif len ( co1_v ) == len ( ce2_v ) == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif co1_k [ 0 ] == ce2_k [ 0 ] : <NEWLINE> <INDENT> if len ( co1_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( ce2_v [ 1 : ] ) <NEWLINE> <DEDENT> elif len ( ce2_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( co1_v [ 1 : ] ) <NEWLINE> <DEDENT> elif len ( co1_v ) == len ( ce2_v ) == 2 : <NEWLINE> <INDENT> ans1 = co1_v [ 1 ] + ce2_v [ 0 ] <NEWLINE> ans2 = co1_v [ 0 ] + ce2_v [ 1 ] <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> elif len ( co1_v ) == 2 : <NEWLINE> <INDENT> ans1 = co1_v [ 1 ] + ce2_v [ 0 ] + sum ( ce2_v [ 2 : ] ) <NEWLINE> ans2 = co1_v [ 0 ] + sum ( ce2_v [ 1 : ] ) <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> elif len ( ce2_v ) == 2 : <NEWLINE> <INDENT> ans1 = ce2_v [ 1 ] + co1_v [ 0 ] + sum ( co1_v [ 2 : ] ) <NEWLINE> ans2 = ce2_v [ 0 ] + sum ( co1_v [ 1 : ] ) <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = sum ( co1_v [ 1 : ] ) + ce2_v [ 0 ] + sum ( ce2_v [ 2 : ] ) <NEWLINE> ans2 = sum ( ce2_v [ 1 : ] ) + co1_v [ 0 ] + sum ( co1_v [ 2 : ] ) <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( co1_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( ce2_v [ 1 : ] ) <NEWLINE> <DEDENT> elif len ( ce2_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( co1_v [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( co1_v [ 1 : ] ) + sum ( ce2_v [ 1 : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from heapq import heapify , heappush , heappop <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a1 = a [ 0 : n ] <NEWLINE> a_m = a [ n : 2 * n ] <NEWLINE> a2 = [ - x for x in a [ 2 * n : 3 * n ] ] <COMMENT> <NEWLINE> <NL> a1_sums = [ sum ( a1 ) ] <NEWLINE> a2_sums = [ sum ( a2 ) ] <NEWLINE> heapify ( a1 ) <NEWLINE> heapify ( a2 ) <NEWLINE> <NL> <COMMENT> <NL> for aa in a_m : <NEWLINE> <INDENT> heappush ( a1 , aa ) <NEWLINE> p = heappop ( a1 ) <NEWLINE> a1_sums . append ( a1_sums [ - 1 ] + aa - p ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a_m . reverse ( ) <NEWLINE> for aa in a_m : <NEWLINE> <INDENT> heappush ( a2 , - aa ) <NEWLINE> p = heappop ( a2 ) <NEWLINE> a2_sums . append ( a2_sums [ - 1 ] - aa - p ) <NEWLINE> <NL> <DEDENT> max_val = - float ( <STRING> ) <NEWLINE> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> max_val = max ( max_val , a1_sums [ i ] + a2_sums [ n - i ] ) <NEWLINE> <NL> <DEDENT> print ( max_val ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> log = [ ] <NEWLINE> check = [ False ] * N <NEWLINE> <NL> def func ( x , iter ) : <NEWLINE> <INDENT> x = A [ x - 1 ] <NEWLINE> <NL> if iter + 1 == K : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> if check [ x - 1 ] : <NEWLINE> <INDENT> ix = log . index ( x ) <NEWLINE> loop = log [ ix : ] <NEWLINE> tmp = ( K - iter - 1 ) % len ( loop ) <NEWLINE> return loop [ tmp ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log . append ( x ) <NEWLINE> check [ x - 1 ] = True <NEWLINE> iter += 1 <NEWLINE> return func ( x , iter ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( func ( 1 , 0 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , ary ) : <NEWLINE> <INDENT> self . top , self . south , self . east , self . west , self . north , self . bottom = ary <NEWLINE> <NL> <DEDENT> def roll_n ( self ) : <NEWLINE> <INDENT> self . top , self . north , self . bottom , self . south = self . south , self . top , self . north , self . bottom <NEWLINE> <NL> <DEDENT> def roll_e ( self ) : <NEWLINE> <INDENT> self . top , self . east , self . bottom , self . west = self . west , self . top , self . east , self . bottom <NEWLINE> <NL> <DEDENT> def twist ( self ) : <NEWLINE> <INDENT> self . north , self . east , self . south , self . west = self . west , self . north , self . east , self . south <NEWLINE> <NL> <DEDENT> def isEqual ( self , dice ) : <NEWLINE> <INDENT> if self . top == dice . top and self . south == dice . south and self . east == dice . east and self . west == dice . west and self . north == dice . north and self . bottom == dice . bottom : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dice1 = Dice ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice2 = Dice ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = False <NEWLINE> <NL> for i in range ( 6 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> dice1 . roll_n ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice1 . roll_e ( ) <NEWLINE> <NL> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if dice1 . isEqual ( dice2 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice1 . twist ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ ] <NEWLINE> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( l + 1 , r + 1 ) : <NEWLINE> <INDENT> t . append ( ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( t ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> suma = [ 0 for i in range ( len ( a ) + 1 ) ] <NEWLINE> sumb = [ 0 for i in range ( len ( b ) + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , len ( a ) + 1 ) : <NEWLINE> <INDENT> suma [ i ] = suma [ i - 1 ] + a [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( b ) + 1 ) : <NEWLINE> <INDENT> sumb [ i ] = sumb [ i - 1 ] + b [ i - 1 ] <NEWLINE> <NL> <DEDENT> mnum = 0 <NEWLINE> best = len ( sumb ) <NEWLINE> for i in range ( len ( suma ) ) : <NEWLINE> <INDENT> for j in range ( best ) [ : : - 1 ] : <NEWLINE> <INDENT> if suma [ i ] + sumb [ j ] <= k : <NEWLINE> <INDENT> mnum = max ( mnum , i + j ) <NEWLINE> best = j + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mnum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Acount = [ 0 for i in range ( N ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Acount [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( Acount [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s = sorted ( A , reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != s [ 0 ] : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> books = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> books . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> books = sorted ( books , reverse = False ) <NEWLINE> <COMMENT> <NL> <NL> ans = 10 ** 10000 <NEWLINE> import itertools <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in itertools . combinations ( books , i ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> l = [ 0 ] * m <COMMENT> <NEWLINE> money = 0 <NEWLINE> for k in j : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> money += k [ 0 ] <COMMENT> <NEWLINE> <COMMENT> <NL> for o in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l [ o - 1 ] += k [ o ] <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if all ( a >= x for a in l ) : <NEWLINE> <INDENT> if money < ans : <NEWLINE> <INDENT> ans = money <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == 10 ** 10000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> from math import log , floor <NEWLINE> dic = { } <NEWLINE> for v1 , v2 in zip ( range ( 26 ) , <STRING> ) : <NEWLINE> <INDENT> dic [ v1 ] = v2 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += dic [ n % 26 ] <NEWLINE> n //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z , ans = 0 , float ( <STRING> ) <NEWLINE> while z ** 3 <= e : <NEWLINE> <INDENT> r = e - z ** 3 <NEWLINE> y = int ( r ** 0.5 ) <NEWLINE> x = r - y ** 2 <NEWLINE> ans = min ( ans , x + y + z ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> * P , = map ( int , input ( ) . split ( ) ) <NEWLINE> memo = { ( n - 1 , i ) : i for i in range ( P [ - 1 ] + 1 ) } <NEWLINE> def dfs ( pos , t ) : <NEWLINE> <INDENT> if ( pos , t ) in memo : <NEWLINE> <INDENT> return memo [ pos , t ] <NEWLINE> <DEDENT> res = memo [ pos , t ] = dfs ( pos + 1 , max ( 0 , P [ pos + 1 ] - t ) ) + t * 2 <NEWLINE> return res <NEWLINE> <DEDENT> print ( min ( dfs ( 0 , P [ 0 ] - i ) + i for i in range ( P [ 0 ] + 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> s = 0 <NEWLINE> m = 10 ** 9 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if ai <= 0 : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> ai *= ( - 1 ) <NEWLINE> <DEDENT> s += ai <NEWLINE> if m > ai : <NEWLINE> <INDENT> m = ai <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = s <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = s - 2 * m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = False <NEWLINE> total = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif total <= 10 ** 18 : <NEWLINE> <INDENT> total *= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = True <NEWLINE> <DEDENT> <DEDENT> if B or total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <NL> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> mod = 998244353 <NEWLINE> <NL> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> acc = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for l , r in lr : <NEWLINE> <INDENT> if i - l >= 0 : <NEWLINE> <INDENT> acc += dp [ i - l ] <NEWLINE> acc %= mod <NEWLINE> <DEDENT> if i - r - 1 >= 0 : <NEWLINE> <INDENT> acc -= dp [ i - r - 1 ] <NEWLINE> acc %= mod <NEWLINE> <DEDENT> dp [ i ] = acc <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <NL> <INDENT> cnt += math . gcd ( m , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a = [ 0 ] * int ( input ( ) ) <NEWLINE> for i in input ( ) . split ( ) : a [ int ( i ) - 1 ] += 1 <NEWLINE> print ( * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> max_diff = - float ( <STRING> ) <NEWLINE> min_n = p [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> max_diff = max ( max_diff , p [ i ] - min_n ) <NEWLINE> min_n = min ( min_n , p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max_diff ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> scores = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> gcd_ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> score = math . gcd ( gcd_ab , c ) <NEWLINE> scores += score <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( scores ) <NEWLINE>
input ( ) <NEWLINE> x = input ( ) <NEWLINE> a = x . split ( ) <NEWLINE> b = list ( map ( int , a ) ) <NEWLINE> print ( <STRING> . format ( min ( b ) , max ( b ) , sum ( b ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> count = N - K + 2 <NEWLINE> for y in range ( K , N + 2 ) : <NEWLINE> <INDENT> min = int ( y * ( 0 + y - 1 ) / 2 ) <NEWLINE> max = int ( y * ( N - y + 1 + N ) / 2 ) <NEWLINE> answer += ( max + 1 - min ) <NEWLINE> <DEDENT> print ( answer % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ord ( s [ i ] ) >= ord ( <STRING> ) and ord ( s [ i ] ) <= ord ( <STRING> ) : <NEWLINE> <INDENT> print ( chr ( ord ( s [ i ] ) - 32 ) , end = <STRING> ) <NEWLINE> <DEDENT> elif ord ( s [ i ] ) >= ord ( <STRING> ) and ord ( s [ i ] ) <= ord ( <STRING> ) : <NEWLINE> <INDENT> print ( chr ( ord ( s [ i ] ) + 32 ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( a ) / n <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += ( i - m ) ** 2 <NEWLINE> <DEDENT> print ( ( s / n ) ** 0.5 ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> from bisect import bisect_left , bisect_right , insort <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def MS ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = MI ( ) <NEWLINE> a = LI ( ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> memo = [ - 1 ] * n <NEWLINE> memo [ 0 ] = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if memo [ a [ ans [ i - 1 ] - 1 ] - 1 ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = a [ ans [ i - 1 ] - 1 ] <NEWLINE> s += 1 <NEWLINE> memo [ ans [ i ] - 1 ] = s <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> t = memo [ a [ ans [ i - 1 ] - 1 ] - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k <= t : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <DEDENT> elif t == 0 : <NEWLINE> <INDENT> print ( ans [ ( k - 1 ) % ( s - t + 1 ) + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ ( k - ( t - 1 ) - 1 ) % ( s - t + 1 ) + t ] ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> s = len ( S ) <NEWLINE> cnt = 0 <NEWLINE> A = [ 0 ] * 2019 <NEWLINE> r = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> x = ( r + pow ( 10 , i , 2019 ) * int ( S [ s - i - 1 ] ) ) % 2019 <NEWLINE> A [ x ] += 1 <NEWLINE> r = x <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 2019 ) : <NEWLINE> <INDENT> if A [ i ] >= 2 : <NEWLINE> <INDENT> cnt += A [ i ] * ( A [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> cnt += A [ 0 ] * ( A [ 0 ] + 1 ) // 2 <NEWLINE> <NL> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = sorted ( lst , reverse = True ) <NEWLINE> class Queue : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . queue_lst = [ ] <NEWLINE> self . first_flag = True <NEWLINE> self . count = 0 <NEWLINE> self . index = 0 <NEWLINE> <NL> <DEDENT> def add ( self , friend_val ) : <NEWLINE> <INDENT> if self . first_flag : <NEWLINE> <INDENT> self . queue_lst . append ( friend_val ) <NEWLINE> self . first_flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . queue_lst . append ( friend_val ) <NEWLINE> self . queue_lst . append ( friend_val ) <NEWLINE> self . count += self . queue_lst [ self . index ] <NEWLINE> self . index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> queue = Queue ( ) <NEWLINE> <NL> for i in lst : <NEWLINE> <INDENT> queue . add ( i ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( queue . count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def solve_beam ( ) : <NEWLINE> <INDENT> D = int ( readline ( ) ) <NEWLINE> C = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> N = 26 <NEWLINE> <NL> lasts = [ 0 ] * N <NEWLINE> <NL> ans = [ None ] * D <NEWLINE> <NL> W , DEPTH = 2 , 8 <NEWLINE> <NL> def rec ( day , rem ) : <NEWLINE> <INDENT> if rem == 0 or day > D : <NEWLINE> <INDENT> return 0 , 0 <NEWLINE> <DEDENT> gains = [ ( S [ day - 1 ] [ t ] + ( day - lasts [ t ] ) * C [ t ] , t ) for t in range ( N ) ] <NEWLINE> gains . sort ( reverse = True ) <NEWLINE> max_gain = - 1e10 <NEWLINE> max_gain_t = 0 <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> gain , t = gains [ i ] <NEWLINE> _t = lasts [ t ] <NEWLINE> lasts [ t ] = day <NEWLINE> f_gain , _ = rec ( day + 1 , rem - 1 ) <NEWLINE> lasts [ t ] = _t <NEWLINE> gain += f_gain <NEWLINE> if gain > max_gain : <NEWLINE> <INDENT> max_gain = gain <NEWLINE> max_gain_t = t <NEWLINE> <NL> <DEDENT> <DEDENT> return max_gain , max_gain_t <NEWLINE> <NL> <DEDENT> for day in range ( D ) : <NEWLINE> <INDENT> _ , t = rec ( day , DEPTH ) <NEWLINE> lasts [ t ] = day <NEWLINE> ans [ day - 1 ] = t <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve_beam ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> m *= i <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> m = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import sys <NEWLINE> s2nn = lambda s : [ int ( c ) for c in s . split ( <STRING> ) ] <NEWLINE> ss2nn = lambda ss : [ int ( s ) for s in ss ] <NEWLINE> ss2nnn = lambda ss : [ s2nn ( s ) for s in ss ] <NEWLINE> i2s = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> i2n = lambda : int ( i2s ( ) ) <NEWLINE> i2nn = lambda : s2nn ( i2s ( ) ) <NEWLINE> ii2ss = lambda n : [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> ii2sss = lambda n : [ list ( sys . stdin . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> ii2nn = lambda n : ss2nn ( ii2ss ( n ) ) <NEWLINE> ii2nnn = lambda n : ss2nnn ( ii2ss ( n ) ) <NEWLINE> from collections import deque <COMMENT> <NEWLINE> from collections import defaultdict <COMMENT> <NEWLINE> from heapq import heapify , heappush , heappop , heappushpop <COMMENT> <NEWLINE> from bisect import bisect_left , bisect_right <COMMENT> <NEWLINE> sys . setrecursionlimit ( int ( 1e+6 ) ) <NEWLINE> MOD = int ( 1e+9 ) + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = i2nn ( ) <NEWLINE> A = i2nn ( ) <NEWLINE> <COMMENT> <NL> if N == K : <NEWLINE> <INDENT> n = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> n = ( n * a ) % MOD <NEWLINE> <DEDENT> print ( n ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> Ap = [ n for n in A if n >= 0 ] <NEWLINE> An = [ - n for n in A if n < 0 ] <NEWLINE> Ap . sort ( ) <NEWLINE> Ap . reverse ( ) <NEWLINE> An . sort ( ) <NEWLINE> An . reverse ( ) <NEWLINE> Np = len ( Ap ) <NEWLINE> Nn = len ( An ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if N == Nn and K % 2 == 1 : <NEWLINE> <INDENT> n = 1 <NEWLINE> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> n = ( n * A [ i ] ) % MOD <NEWLINE> <DEDENT> print ( n ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> n = 1 <NEWLINE> k = K <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> n = ( n * Ap [ i ] ) % MOD <NEWLINE> i += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> while k > 0 : <NEWLINE> <INDENT> if Np - i < 2 : <NEWLINE> <INDENT> n = ( n * An [ j ] ) % MOD <NEWLINE> j += 1 <NEWLINE> n = ( n * An [ j ] ) % MOD <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif Nn - j < 2 : <NEWLINE> <INDENT> n = ( n * Ap [ i ] ) % MOD <NEWLINE> i += 1 <NEWLINE> n = ( n * Ap [ i ] ) % MOD <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> np = Ap [ i ] * Ap [ i + 1 ] <NEWLINE> nn = An [ j ] * An [ j + 1 ] <NEWLINE> if np >= nn : <NEWLINE> <INDENT> n = ( n * np ) % MOD <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = ( n * nn ) % MOD <NEWLINE> j += 2 <NEWLINE> <DEDENT> <DEDENT> k -= 2 <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dd = defaultdict ( lambda : 0 ) <NEWLINE> for aa in a : dd [ aa ] += 1 <NEWLINE> <NL> ans = 0 <NEWLINE> for aa in dd . keys ( ) : <NEWLINE> <INDENT> ca = dd [ aa ] <NEWLINE> if ca >= aa : <NEWLINE> <INDENT> ans += ca - aa <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ca <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = 1 <NEWLINE> for num in A : <NEWLINE> <INDENT> tmp *= num <NEWLINE> if tmp > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp <= 1e18 : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> <DEDENT> elif 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> digits = deque ( ) <NEWLINE> alpha = ord ( <STRING> ) - 1 <NEWLINE> maxex = int ( math . log ( n - 1 , 26 ) ) <NEWLINE> ex = 1 <NEWLINE> for ex in range ( 1 , maxex + 2 ) : <NEWLINE> <INDENT> bb = pow ( 26 , ex - 1 ) <NEWLINE> aa = bb * 26 <NEWLINE> rem = n % aa // bb <NEWLINE> n -= bb * rem <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rem += 26 <NEWLINE> n -= aa <NEWLINE> <DEDENT> digits . appendleft ( chr ( alpha + rem ) ) <NEWLINE> <NL> <DEDENT> [ print ( d , end = <STRING> ) for d in digits ] <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> dates = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> X = dates [ 0 ] <NEWLINE> K = dates [ 1 ] <NEWLINE> D = dates [ 2 ] <NEWLINE> numDiv = math . ceil ( abs ( X ) / D ) <NEWLINE> <NL> if numDiv < K : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> X -= numDiv * D <NEWLINE> K -= numDiv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += numDiv * D <NEWLINE> K -= numDiv <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> X -= K * D <NEWLINE> K = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += K * D <NEWLINE> K = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if X >= 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X + D ) ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k - 1 , n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> if a [ i + 1 ] > a [ i - k + 1 ] else <STRING> ) <NEWLINE> <DEDENT>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , num ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S_list = list ( input ( ) ) <NEWLINE> <NL> rsum = 0 <NEWLINE> gsum = 0 <NEWLINE> bsum = 0 <NEWLINE> <NL> for s in S_list : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> rsum += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> gsum += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> bsum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = rsum * gsum * bsum <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> p = ( n - i - 1 ) // 2 <NEWLINE> for j in range ( 1 , p + 1 ) : <NEWLINE> <INDENT> if S_list [ i ] != S_list [ i + j ] and S_list [ i + 2 * j ] != S_list [ i + j ] and S_list [ i ] != S_list [ i + 2 * j ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> <NL> print ( floor ( A * x / B ) - A * floor ( x / B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> ikiti = pow ( 10 , 18 ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ikiti = pow ( 10 , 18 ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > ikiti : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= ikiti : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> line = [ <STRING> ] * ( N + 1 ) * 2 <NEWLINE> rev = False <NEWLINE> pos = N <NEWLINE> line [ pos ] = S <NEWLINE> leftPos = pos - 1 <NEWLINE> rightPos = pos + 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) . split ( ) <NEWLINE> if len ( A ) == 1 : <NEWLINE> <INDENT> rev = not rev <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> if rev == False : <NEWLINE> <INDENT> pos = leftPos <NEWLINE> leftPos -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = rightPos <NEWLINE> rightPos += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rev == False : <NEWLINE> <INDENT> pos = rightPos <NEWLINE> rightPos += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = leftPos <NEWLINE> leftPos -= 1 <NEWLINE> <DEDENT> <DEDENT> line [ pos ] = A [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = line [ leftPos + 1 : rightPos ] <NEWLINE> ans = <STRING> . join ( ans ) <NEWLINE> if rev == False : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
def integerCards ( n , m , alist , bclist ) : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> alist . sort ( ) <NEWLINE> bclist . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for b , c in bclist : <NEWLINE> <INDENT> for _ in range ( b ) : <NEWLINE> <INDENT> if alist [ count ] < c : <NEWLINE> <INDENT> alist [ count ] = c <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if count == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if count == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return sum ( alist ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bclist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> print ( integerCards ( n , m , alist , bclist ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n0 = A . count ( 0 ) <NEWLINE> n1 = A . count ( 1 ) <NEWLINE> import math <NEWLINE> ans = 1 <NEWLINE> if N - n0 - n1 > 60 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 or ans == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif math . log10 ( A [ i ] ) + math . log10 ( ans ) > 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> b = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> return N , A , B , C <NEWLINE> <NL> <NL> <DEDENT> def get_lb ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess > key : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> <DEDENT> return high <NEWLINE> <NL> <NL> <DEDENT> def get_ub ( l : list , key : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = - 1 <NEWLINE> high = len ( l ) <NEWLINE> while 1 < high - low : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = l [ mid ] <NEWLINE> if guess < key : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , A : list , B : list , C : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> C = sorted ( C ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B_i = B [ i ] <NEWLINE> ans += ( get_ub ( A , B_i ) + 1 ) * ( N - get_lb ( C , B_i ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , A , B , C = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , A , B , C ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = min ( A ) // ( k + 1 ) <NEWLINE> r = max ( A ) <NEWLINE> m = ( l + r ) // 2 + 1 <NEWLINE> <NL> while 1 : <NEWLINE> <NL> <INDENT> m = ( l + r ) // 2 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> m = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> n = sum ( [ int ( ( A [ i ] - 0.1 ) // ( m ) ) for i in range ( len ( A ) ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if n <= k : <NEWLINE> <INDENT> if r == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r = m - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l == m : <NEWLINE> <INDENT> m += 1 <NEWLINE> break <NEWLINE> <DEDENT> l = m + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> class RPN ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . top = 0 <NEWLINE> self . S = [ ] <NEWLINE> self . MAX = 100 <NEWLINE> <NL> <DEDENT> def isEmpty ( self ) : <NEWLINE> <INDENT> return self . top == 0 <NEWLINE> <NL> <DEDENT> def isFull ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . top >= self . MAX <NEWLINE> <NL> <DEDENT> def push ( self , x ) : <NEWLINE> <INDENT> if self . isFull ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> self . top += 1 <NEWLINE> self . S . append ( x ) <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> if self . isEmpty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> self . top -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> return self . S . pop ( self . top ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> X = input ( ) . split ( <STRING> ) <NEWLINE> rpn = RPN ( ) <NEWLINE> for x in X : <NEWLINE> <COMMENT> <NL> <INDENT> if x . isnumeric ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> rpn . push ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> num_2 = rpn . pop ( ) <NEWLINE> num_1 = rpn . pop ( ) <NEWLINE> res = eval ( str ( num_1 ) + x + str ( num_2 ) ) <NEWLINE> rpn . push ( res ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rpn . pop ( ) ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = N % K <NEWLINE> <NL> print ( min ( s , K - s ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> not_wet = [ True ] * ( n + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> not_wet [ a ] = False <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not_wet [ i ] : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for t in range ( h * w ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> ll = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> l [ ll [ j ] - 1 ] = [ i , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> r = [ [ 0 ] for dd in range ( d ) ] <NEWLINE> for dd in range ( d ) : <NEWLINE> <INDENT> if dd == 0 : <NEWLINE> <INDENT> k = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = dd <NEWLINE> <DEDENT> while k + d <= h * w : <NEWLINE> <INDENT> r [ dd ] . append ( r [ dd ] [ - 1 ] + abs ( l [ k + d - 1 ] [ 0 ] - l [ k - 1 ] [ 0 ] ) + abs ( l [ k + d - 1 ] [ 1 ] - l [ k - 1 ] [ 1 ] ) ) <NEWLINE> k += d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for qq in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % d == 0 : <NEWLINE> <INDENT> p = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = a % d <NEWLINE> <DEDENT> aa = ( a - p ) // d <NEWLINE> bb = ( b - p ) // d <NEWLINE> ans = r [ a % d ] [ bb ] - r [ a % d ] [ aa ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> alphabet = [ None ] + [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> <NL> rest = [ ] <NEWLINE> while n != 0 : <NEWLINE> <INDENT> rest . append ( n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> rest . reverse ( ) <NEWLINE> <NL> for i in range ( len ( rest ) - 1 ) : <NEWLINE> <INDENT> if rest [ len ( rest ) - 1 - i ] <= 0 : <NEWLINE> <INDENT> rest [ len ( rest ) - 1 - i ] += 26 <NEWLINE> rest [ len ( rest ) - 2 - i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> if rest [ 0 ] <= 0 : <NEWLINE> <INDENT> rest = rest [ 1 : ] <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( len ( rest ) ) : <NEWLINE> <INDENT> ans += alphabet [ rest [ i ] ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def convert ( S ) : <NEWLINE> <INDENT> i , * d = S . split ( <STRING> ) <NEWLINE> i = int ( i ) * 1_000_000_000 <NEWLINE> if d : <NEWLINE> <INDENT> return i + int ( d [ 0 ] . ljust ( 9 , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def div_cnt ( n , d ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while n % d == 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> n //= d <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> @ njit ( i8 ( i8 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( table ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> cur = table [ i ] [ j ] <NEWLINE> if cur == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 18 - i , 19 ) : <NEWLINE> <INDENT> for l in range ( 18 - j , 19 ) : <NEWLINE> <INDENT> if k == i and j == l : <NEWLINE> <INDENT> ans += cur * ( cur - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cur * table [ k ] [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( convert ( input ( ) ) for _ in range ( N ) ) <NEWLINE> divs = [ ( div_cnt ( a , 2 ) , div_cnt ( a , 5 ) ) for a in A ] <NEWLINE> <NL> table = np . zeros ( ( 19 , 19 ) , np . int64 ) <NEWLINE> for t , f in divs : <NEWLINE> <INDENT> table [ min ( t , 18 ) ] [ min ( f , 18 ) ] += 1 <NEWLINE> <DEDENT> print ( solve ( table ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if d . get ( s , 0 ) == 0 : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from fractions import Fraction <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> <NL> k = 0 <NEWLINE> while True : <NEWLINE> <INDENT> k += 1 <NEWLINE> s = x * k <NEWLINE> if s % 360 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
from collections import deque <NEWLINE> def bfs ( maze , visited , sy , sx , gy , gx ) : <NEWLINE> <INDENT> queue = deque ( [ [ sy , sx ] ] ) <NEWLINE> visited [ sy ] [ sx ] = 0 <NEWLINE> while queue : <NEWLINE> <COMMENT> <NL> <INDENT> y , x = queue . popleft ( ) <COMMENT> <NEWLINE> if [ y , x ] == [ gy , gx ] : <COMMENT> <NEWLINE> <INDENT> return visited [ y ] [ x ] <NEWLINE> <DEDENT> for j , k in ( [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> l = 1 <NEWLINE> while p == 0 : <NEWLINE> <INDENT> new_y , new_x = y + j * l , x + k * l <NEWLINE> if ( 0 <= new_y < H ) and ( 0 <= new_x < W ) : <NEWLINE> <INDENT> if maze [ new_y ] [ new_x ] == <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif visited [ new_y ] [ new_x ] == - 1 : <COMMENT> <NEWLINE> <INDENT> visited [ new_y ] [ new_x ] = visited [ y ] [ x ] + 1 <NEWLINE> queue . append ( [ new_y , new_x ] ) <COMMENT> <NEWLINE> <DEDENT> elif visited [ new_y ] [ new_x ] < visited [ y ] [ x ] + 1 : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> l += 1 <NEWLINE> if l == K + 1 : <NEWLINE> <INDENT> p = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = x1 - 1 , y1 - 1 , x2 - 1 , y2 - 1 <NEWLINE> C = [ 0 ] * H <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> C [ i ] = str ( input ( ) ) <NEWLINE> <DEDENT> visited = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> bfs ( C , visited , x1 , y1 , x2 , y2 ) <NEWLINE> <COMMENT> <NL> print ( visited [ x2 ] [ y2 ] ) <NEWLINE> <NL> <NL> <NL>
while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = a . split ( <STRING> ) <NEWLINE> H = int ( b [ 0 ] ) <NEWLINE> W = int ( b [ 1 ] ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> c = <STRING> * W <NEWLINE> print ( c ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = s . count <NEWLINE> a = c ( <STRING> ) * c ( <STRING> ) * c ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( ( n - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i + 2 * j ] != s [ i ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> m = int ( input ( ) ) <NEWLINE> rel = sorted ( [ [ int ( s ) for s in input ( ) . split ( <STRING> ) ] for i in range ( m ) ] , key = lambda x : x [ 0 ] ) <NEWLINE> isf = [ False for i in range ( n ) ] <NEWLINE> inv = [ False for i in range ( n ) ] <NEWLINE> isf [ 0 ] = True <NEWLINE> for r in rel : <NEWLINE> <INDENT> if r [ 0 ] == 1 : isf [ r [ 1 ] - 1 ] = True <NEWLINE> <DEDENT> for r in rel : <NEWLINE> <INDENT> if isf [ r [ 0 ] - 1 ] == True : inv [ r [ 1 ] - 1 ] = True <NEWLINE> elif isf [ r [ 1 ] - 1 ] == True : inv [ r [ 0 ] - 1 ] = True <NEWLINE> <DEDENT> print ( inv . count ( True ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> cnt_l = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> cnt_r = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> <NL> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt_l [ i ] = cnt_l [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_l [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt_r [ i ] = cnt_r [ i + 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_r [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for l , r in zip ( cnt_l , cnt_r ) : <NEWLINE> <INDENT> ans += max ( l , r ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( N ) <NEWLINE> s = <STRING> <NEWLINE> if N < 1000 : <NEWLINE> <INDENT> ans = 1000 - N <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> s = S [ len ( S ) - 1 - i ] + s <NEWLINE> <NL> <DEDENT> n = int ( s ) <NEWLINE> ans = 1000 - n <NEWLINE> if ans == 1000 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> zero_pad = <STRING> * ( W + 2 ) <NEWLINE> s = [ ] <NEWLINE> s . append ( zero_pad ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( zero_pad ) <NEWLINE> <NL> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if s [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> if s [ h - 1 ] [ w ] == <STRING> and s [ h + 1 ] [ w ] == <STRING> and s [ h ] [ w - 1 ] == <STRING> and s [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K == N + 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif K == N : <NEWLINE> <INDENT> print ( N + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> def tousawa ( shokou , makkou , kosu ) : <NEWLINE> <INDENT> return int ( ( shokou + makkou ) * kosu / 2 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> ans += tousawa ( N - i + 1 , N , i ) - tousawa ( 0 , i - 1 , i ) + 1 <NEWLINE> <DEDENT> print ( int ( ans % ( 10 ** 9 + 7 ) ) ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if ( a [ len ( a ) - 1 ] == <STRING> ) : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> print ( a + <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> o = [ int ( i ) for i in a ] <NEWLINE> for idx in range ( 0 , int ( n / 2 ) ) : <NEWLINE> <INDENT> w = o [ idx ] <NEWLINE> o [ idx ] = o [ n - idx - 1 ] <NEWLINE> o [ n - idx - 1 ] = w <NEWLINE> <NL> <DEDENT> for idx in range ( n ) : <NEWLINE> <INDENT> print ( o [ idx ] , end = <STRING> ) <NEWLINE> if idx == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
def bfs ( field , start_i , start_j , w , h ) : <NEWLINE> <INDENT> OFFSETS = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> queue = [ ( start_i , start_j ) ] <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> i , j = queue . pop ( ) <NEWLINE> field [ i ] [ j ] = <STRING> <NEWLINE> <NL> for di , dj in OFFSETS : <NEWLINE> <INDENT> if i + di < 0 or i + di >= h : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j + dj < 0 or j + dj >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ i + di ] [ j + dj ] == <STRING> : <NEWLINE> <INDENT> queue . append ( ( i + di , j + dj ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> w , h = [ int ( s ) for s in input ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> num_island = 0 <NEWLINE> <NL> field = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> field . append ( input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> num_island += 1 <NEWLINE> bfs ( field , i , j , w , h ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num_island ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> position = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> distance = math . sqrt ( ( position [ 2 ] - position [ 0 ] ) ** 2 + ( position [ 3 ] - position [ 1 ] ) ** 2 ) <NEWLINE> print ( <STRING> . format ( distance ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> dx = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dy = [ - 1 , 0 , 1 , 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> for d in range ( 4 ) : <NEWLINE> <INDENT> if 0 <= i + dy [ d ] < h and 0 <= j + dx [ d ] < w : <NEWLINE> <INDENT> count += 1 if field [ i + dy [ d ] ] [ j + dx [ d ] ] == <STRING> else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if count < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = sorted ( X ) <NEWLINE> list = [ X [ i ] - X [ i - 1 ] for i in range ( 1 , M ) ] <NEWLINE> list = sorted ( list ) <NEWLINE> list1 = list [ : M - N ] <NEWLINE> print ( sum ( list1 ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int ) <NEWLINE> for i , ( w , v ) in enumerate ( wv ) : <NEWLINE> <INDENT> dp [ i + 1 ] = np . maximum ( dp [ i + 1 ] , dp [ i ] ) <NEWLINE> dp [ i + 1 ] [ w : ] = np . maximum ( dp [ i + 1 ] [ w : ] , dp [ i ] [ : - w ] + v ) <NEWLINE> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def generate_buidlings ( building , floor , room ) : <NEWLINE> <INDENT> empty_buildings = { <NEWLINE> <INDENT> key : [ [ 0 for col in range ( room ) ] for row in range ( floor ) ] <NEWLINE> for key in range ( 1 , building + 1 ) <NEWLINE> <DEDENT> } <NEWLINE> return empty_buildings <NEWLINE> <NL> <NL> <DEDENT> def occupy_buildings ( empty_buildings ) : <NEWLINE> <INDENT> occupied_buildings = generate_buidlings ( 4 , 3 , 10 ) <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lst = [ int ( num ) for num in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> occupied_buildings [ lst [ 0 ] ] [ lst [ 1 ] - 1 ] [ lst [ 2 ] - 1 ] += lst [ 3 ] <NEWLINE> <NL> <DEDENT> return occupied_buildings <NEWLINE> <NL> <NL> <DEDENT> def print_buildings ( ) : <NEWLINE> <INDENT> separator = <STRING> <NEWLINE> occupied_buildings = occupy_buildings ( generate_buidlings ( 4 , 3 , 10 ) ) <NEWLINE> <NL> for idx , ( key , value ) in enumerate ( occupied_buildings . items ( ) ) : <NEWLINE> <INDENT> for floor in value : <NEWLINE> <INDENT> print ( <STRING> % tuple ( floor ) ) <NEWLINE> <DEDENT> if idx < 3 : <NEWLINE> <INDENT> print ( separator ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print_buildings ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
str_input = input ( ) <NEWLINE> list_input = str_input . split ( <STRING> ) <NEWLINE> a = int ( list_input [ 0 ] ) <NEWLINE> b = int ( list_input [ 1 ] ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , heapq <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = bisect . bisect_right ( A , i ) - bisect . bisect_left ( A , i ) <NEWLINE> b = bisect . bisect_right ( B , i ) - bisect . bisect_left ( B , i ) <NEWLINE> <NL> if a + b > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> B = B [ : : - 1 ] <NEWLINE> <NL> j , bef = 0 , - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != bef : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> if A [ i ] == B [ i ] : <NEWLINE> <INDENT> while j < N : <NEWLINE> <INDENT> if A [ j ] != B [ i ] and B [ j ] != A [ i ] : <NEWLINE> <INDENT> B [ i ] , B [ j ] = B [ j ] , B [ i ] <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> bef = A [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for b in B : <NEWLINE> <INDENT> print ( b , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> mydict = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if ( s in mydict ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mydict [ s ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( len ( mydict ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> k = 1e18 <NEWLINE> while ( n > i ) : <NEWLINE> <INDENT> if ( p [ i ] == 0 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> i = 0 <NEWLINE> while ( n > i ) : <NEWLINE> <INDENT> ans *= p [ i ] <NEWLINE> if ( ans > k ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D1 = defaultdict ( int ) <NEWLINE> D2 = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> D1 [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N , 2 ) : <NEWLINE> <INDENT> D2 [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> D1_sorted = sorted ( D1 . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) + [ ( - 1 , 0 ) ] <NEWLINE> D2_sorted = sorted ( D2 . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) + [ ( - 1 , 0 ) ] <NEWLINE> i , j = 0 , 0 <NEWLINE> while i < len ( D1_sorted ) - 1 and j < len ( D2_sorted ) - 1 : <NEWLINE> <INDENT> if D1_sorted [ i ] [ 0 ] != D2_sorted [ j ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif D1_sorted [ i ] [ 1 ] > D2_sorted [ j ] [ 1 ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> elif D1_sorted [ i ] [ 1 ] < D2_sorted [ j ] [ 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if D1_sorted [ i + 1 ] [ 1 ] > D2_sorted [ j + 1 ] [ 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - D1_sorted [ i ] [ 1 ] - D2_sorted [ j ] [ 1 ] ) <NEWLINE>
total = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> num_high = int ( total [ 0 ] ) <NEWLINE> ans = num_high <NEWLINE> num_load = int ( total [ 1 ] ) <NEWLINE> height = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> ans = [ 0 for i in range ( num_high ) ] <NEWLINE> <NL> for j in range ( num_load ) : <NEWLINE> <INDENT> list = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> check_a = int ( list [ 0 ] ) <NEWLINE> check_b = int ( list [ 1 ] ) <NEWLINE> if int ( height [ check_a - 1 ] ) <= int ( height [ check_b - 1 ] ) : <NEWLINE> <INDENT> ans [ check_a - 1 ] = 1 <NEWLINE> <DEDENT> if int ( height [ check_b - 1 ] ) <= int ( height [ check_a - 1 ] ) : <NEWLINE> <INDENT> ans [ check_b - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 0 ) ) <NEWLINE>
dp = [ [ 0 for _ in range ( 1001 ) ] for _ in range ( 11 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 9 , - 1 , - 1 ) : <NEWLINE> <INDENT> for k in range ( 1001 - i ) : <NEWLINE> <INDENT> dp [ j + 1 ] [ k + i ] += dp [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( dp [ n ] [ s ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H == 0 & W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <COMMENT> <NEWLINE> <DEDENT> print ( ) <COMMENT> <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
nyukyo = [ [ [ 0 for i in range ( 10 ) ] for m in range ( 3 ) ] for n in range ( 4 ) ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> handan = input ( ) . split ( ) <NEWLINE> handan = list ( map ( int , handan ) ) <NEWLINE> nyukyo [ handan [ 0 ] - 1 ] [ handan [ 1 ] - 1 ] [ handan [ 2 ] - 1 ] += handan [ 3 ] <NEWLINE> <NL> <DEDENT> for m in nyukyo [ 0 ] : <NEWLINE> <INDENT> t = list ( map ( str , m ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( t ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for m in nyukyo [ 1 ] : <NEWLINE> <INDENT> t = list ( map ( str , m ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( t ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for m in nyukyo [ 2 ] : <NEWLINE> <INDENT> t = list ( map ( str , m ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( t ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for m in nyukyo [ 3 ] : <NEWLINE> <INDENT> t = list ( map ( str , m ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( t ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ [ ] for j in range ( M ) ] <NEWLINE> <NL> if N % 2 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> ans [ i ] . append ( i + 1 ) <NEWLINE> ans [ i ] . append ( N - i - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> memo = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> memo = i <NEWLINE> if ( i + 1 ) * 4 >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ i ] . append ( i + 1 ) <NEWLINE> ans [ i ] . append ( N - i - 1 ) <NEWLINE> memo += 1 <NEWLINE> <NL> <DEDENT> for j in range ( memo , M ) : <NEWLINE> <INDENT> ans [ j ] . append ( j + 1 ) <NEWLINE> ans [ j ] . append ( N - j - 2 ) <NEWLINE> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K >= A : <NEWLINE> <INDENT> result = A <NEWLINE> K -= A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = K <NEWLINE> K = 0 <NEWLINE> <NL> <DEDENT> if K >= B : <NEWLINE> <INDENT> K -= B <NEWLINE> <NL> <DEDENT> if K > 0 : <NEWLINE> <INDENT> result -= K <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> allxor = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> allxor ^= a <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( allxor ^ a , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> Al = list ( input ( ) . split ( ) ) <NEWLINE> cdict = Counter ( Al ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( cdict [ str ( i + 1 ) ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <NL> <INDENT> if 2 * j - i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ j ] != S [ 2 * j - i ] and S [ 2 * j - i ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - ( x + y ) <NEWLINE> if 0 <= z <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for i in range ( N ) ] <NEWLINE> visited = [ - 1 for i in range ( N ) ] <NEWLINE> dist = [ 1000000000 for i in range ( N ) ] <NEWLINE> last = [ - 1 for i in range ( N ) ] <NEWLINE> i = 0 <NEWLINE> dist [ 0 ] = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ A - 1 ] . append ( B - 1 ) <NEWLINE> edge [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> Q = deque ( ) <NEWLINE> Q . append ( 0 ) <NEWLINE> while Q : <NEWLINE> <INDENT> i = Q . popleft ( ) <NEWLINE> if visited [ i ] == - 1 : <NEWLINE> <INDENT> for j in edge [ i ] : <NEWLINE> <INDENT> if dist [ j ] > dist [ i ] + 1 : <NEWLINE> <INDENT> dist [ j ] = dist [ i ] + 1 <NEWLINE> last [ j ] = i + 1 <NEWLINE> <DEDENT> if visited [ j ] == - 1 : <NEWLINE> <INDENT> Q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> visited [ i ] = 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( last [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> d , w , h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d == 0 and w == 0 and h == 0 : break <NEWLINE> vmin = min ( d * d + w * w , d * d + h * h , w * w + h * h ) <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> print ( <STRING> if ( 2 * r ) ** 2 > vmin else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def counting_sort ( A , k ) : <NEWLINE> <INDENT> B = [ 0 ] * len ( A ) <NEWLINE> C = [ 0 ] * k <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> C [ i ] += C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for a in reversed ( A ) : <NEWLINE> <INDENT> B [ C [ a ] - 1 ] = a <NEWLINE> C [ a ] -= 1 <NEWLINE> <NL> <DEDENT> return B <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( * counting_sort ( A , 10001 ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> for i in range ( - 200 , 201 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 201 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import numba as nb <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> size = n // 2 <NEWLINE> MOD = 998244353 <NEWLINE> dp_can = np . zeros ( ( n + 1 , size + 1 , size + 1 ) , dtype = np . int8 ) <NEWLINE> dp_cnt = np . zeros ( ( n + 1 , size + 1 , size + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> dp_cnt [ n , 0 ] = 1 <NEWLINE> for j in range ( size ) : <NEWLINE> <INDENT> dp_cnt [ n , j + 1 ] = np . cumsum ( dp_cnt [ n , j ] ) % MOD <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( size + 1 ) : <NEWLINE> <INDENT> dp_cnt [ i , j ] = np . cumsum ( dp_cnt [ i + 1 , j ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( size + 1 ) : <NEWLINE> <INDENT> dp_cnt [ i , : , k ] = np . cumsum ( dp_cnt [ i + 1 , : , k ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp_can [ 0 , 0 , 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp_can [ i + 1 ] |= dp_can [ i ] <NEWLINE> if s [ i ] == 0 : <NEWLINE> <INDENT> dp_can [ i + 1 , 1 : , : - 1 ] |= dp_can [ i , : - 1 , 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_can [ i + 1 , : - 1 , 1 : ] |= dp_can [ i , 1 : , : - 1 ] <NEWLINE> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> if s [ i ] == 0 or s [ i + 1 ] == 0 : <NEWLINE> <INDENT> dp_can [ i + 2 , 1 : , : ] |= dp_can [ i , : - 1 , : ] <NEWLINE> <DEDENT> if s [ i ] == 1 or s [ i + 1 ] == 1 : <NEWLINE> <INDENT> dp_can [ i + 2 , : , 1 : ] |= dp_can [ i , : , : - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp_can [ 1 : , 0 , 0 ] = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( size + 1 ) : <NEWLINE> <INDENT> for k in range ( size + 1 ) : <NEWLINE> <INDENT> if dp_can [ i , j , k ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans = ( ans + dp_cnt [ i , j , k ] ) % MOD <NEWLINE> <NL> a , b = j , k <NEWLINE> for h in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ h ] == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> if a < 0 or b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp_can [ h , a , b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> s = np . array ( [ int ( c ) for c in input ( ) ] , dtype = np . int8 ) <NEWLINE> print ( solve ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> result = result * a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> memo = [ 0 ] * 2019 <NEWLINE> memo [ 0 ] += 1 <NEWLINE> <NL> num = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> num += int ( i ) * t <NEWLINE> num %= 2019 <NEWLINE> t *= 10 <NEWLINE> t %= 2019 <NEWLINE> memo [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p in memo : <NEWLINE> <INDENT> ans += p * ( p - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> h = NLI ( ) <NEWLINE> <NL> dp = [ 0 for _ in range ( ( 10 ** 5 ) + 10 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> for n in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ n ] = min ( dp [ n - 2 ] + abs ( h [ n ] - h [ n - 2 ] ) , dp [ n - 1 ] + abs ( h [ n ] - h [ n - 1 ] ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def max_heapify ( A , H , i ) : <NEWLINE> <INDENT> target = A [ i ] <NEWLINE> <NL> m = i <NEWLINE> l = i * 2 <NEWLINE> while l <= H : <NEWLINE> <INDENT> largest = target <NEWLINE> if A [ l ] > target : <NEWLINE> <INDENT> m = l <NEWLINE> largest = A [ m ] <NEWLINE> <NL> <DEDENT> r = l + 1 <NEWLINE> if r <= H and A [ r ] > largest : <NEWLINE> <INDENT> m = r <NEWLINE> largest = A [ m ] <NEWLINE> <NL> <DEDENT> if m != i : <NEWLINE> <INDENT> A [ i ] = largest <NEWLINE> i = m <NEWLINE> l = i * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A [ m ] = target <NEWLINE> <NL> <DEDENT> def build_max_heap ( A , i ) : <NEWLINE> <INDENT> if i < 2 : return <NEWLINE> last = A [ i ] <NEWLINE> p = i // 2 <NEWLINE> while p > 0 and A [ p ] < last : <NEWLINE> <INDENT> A [ i ] = A [ p ] <NEWLINE> i = p <NEWLINE> p = i // 2 <NEWLINE> <DEDENT> A [ i ] = last <NEWLINE> <NL> <DEDENT> A = [ 0 ] <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . append ( int ( line [ 7 : ] ) ) <NEWLINE> build_max_heap ( A , len ( A ) - 1 ) <NEWLINE> <DEDENT> elif line [ 1 ] == <STRING> : <NEWLINE> <INDENT> if len ( A ) <= 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif len ( A ) <= 2 : <NEWLINE> <INDENT> print ( A . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ 1 ] ) <NEWLINE> A [ 1 ] = A . pop ( ) <NEWLINE> max_heapify ( A , len ( A ) - 1 , 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> <NL> for ni in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ni * ni <= n : <NEWLINE> <INDENT> if n % ni == 0 : <NEWLINE> <INDENT> list . append ( max ( len ( str ( ni ) ) , len ( str ( n // ni ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min ( list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> for cnt , item in enumerate ( a , 1 ) : <NEWLINE> <INDENT> if cnt == n : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( item , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> cur = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ls = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if len ( ls ) == 1 : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ls [ 1 ] == <STRING> : <NEWLINE> <INDENT> if cur % 2 == 0 : <NEWLINE> <INDENT> s . appendleft ( ls [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( ls [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if cur % 2 == 0 : <NEWLINE> <INDENT> s . append ( ls [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( ls [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cur % 2 == 0 : <NEWLINE> <INDENT> print ( * s , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * list ( s ) [ : : - 1 ] , sep = <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> history = [ ] <NEWLINE> mark = set ( ) <NEWLINE> <NL> pos = 0 <NEWLINE> cnt = 0 <NEWLINE> while pos not in mark and cnt < k : <NEWLINE> <INDENT> history . append ( pos ) <NEWLINE> mark . add ( pos ) <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt == k : <NEWLINE> <INDENT> print ( pos + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_before = history . index ( pos ) <NEWLINE> print ( history [ cnt_before + ( k - cnt_before ) % ( cnt - cnt_before ) ] + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( n for n in range ( N + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> L = i * ( i - 1 ) // 2 <NEWLINE> R = i * ( 2 * N + 1 - i ) // 2 <NEWLINE> ans += ( R - L + 1 ) <NEWLINE> <DEDENT> print ( ans % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 201 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 201 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( [ a + b , b - a ] [ b % a > 0 ] ) <NEWLINE>
mod = 998244353 <NEWLINE> <NL> <COMMENT> <NL> def main ( N , S ) : <NEWLINE> <INDENT> dp = [ 0 if n != 0 else 1 for n in range ( N ) ] <COMMENT> <NEWLINE> A = [ 0 if n != 0 else 1 for n in range ( N ) ] <COMMENT> <NEWLINE> <NL> for i in range ( 1 , N ) : <COMMENT> <NEWLINE> <INDENT> for l , r in S : <COMMENT> <NEWLINE> <INDENT> if i - l < 0 : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] += A [ i - l ] - A [ max ( i - r , 0 ) - 1 ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> dp [ i ] %= mod <NEWLINE> A [ i ] = ( A [ i - 1 ] + dp [ i ] ) % mod <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = { tuple ( map ( int , input ( ) . split ( ) ) ) for k in range ( K ) } <NEWLINE> S = sorted ( list ( S ) , key = lambda x : x [ 0 ] ) <COMMENT> <NEWLINE> main ( N , S ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans_list = [ ] <NEWLINE> from copy import deepcopy <NEWLINE> def dfs ( x , M , N , ans ) : <NEWLINE> <INDENT> if len ( ans ) <= N : <NEWLINE> <INDENT> ans . append ( x ) <NEWLINE> if len ( ans ) == N : <NEWLINE> <INDENT> ans_list . append ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x , M + 1 ) : <NEWLINE> <INDENT> tmp = deepcopy ( ans ) <NEWLINE> dfs ( i , M , N , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> q = dfs ( 1 , M , N , [ ] ) <NEWLINE> <NL> f = 0 <NEWLINE> for A in ans_list : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> f = max ( f , cnt ) <NEWLINE> <NL> <DEDENT> print ( f ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> nums = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nums . append ( [ ] ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> nums [ i ] . append ( [ ] ) <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> nums [ i ] [ j ] . append ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> nums [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i , building in enumerate ( nums ) : <NEWLINE> <INDENT> for floor in building : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , floor ) ) ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> check = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for key in A : <NEWLINE> <INDENT> check [ key ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if check [ B ] == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = C - B <NEWLINE> ans += check [ B ] * x <NEWLINE> print ( ans ) <NEWLINE> check [ C ] += check [ B ] <NEWLINE> check [ B ] = 0 <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : exit ( print ( x ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> if x not in p : exit ( print ( x ) ) <NEWLINE> h = 101 <NEWLINE> l = 0 <NEWLINE> for i in range ( x , 101 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> h = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( x , 0 , - 1 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> l = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if abs ( x - h ) >= abs ( x - l ) : print ( l ) <NEWLINE> if abs ( x - l ) > abs ( x - h ) : print ( h ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> ans = - 1 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> x = ( x + 7 * pow ( 10 , i , k ) ) % k <NEWLINE> if x == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> input_weekday = input ( ) <NEWLINE> <NL> <COMMENT> <NL> result = 0 <NEWLINE> if input_weekday == <STRING> : <NEWLINE> <INDENT> result = 7 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 6 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 5 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 4 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 3 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 2 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return divisors <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a_b = sorted ( make_divisors ( n ) ) <NEWLINE> flag = False <NEWLINE> for i in a_b : <NEWLINE> <INDENT> if i ** 5 == n : <NEWLINE> <INDENT> print ( i , 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( - int ( np . sqrt ( n ) ) , int ( np . sqrt ( n + 1 ) ) ) : <NEWLINE> <INDENT> if ( i + b ) ** 5 - b ** 5 == n : <NEWLINE> <INDENT> print ( i + b , b ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import Counter <NEWLINE> a = [ ] <NEWLINE> while p % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> p //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f <= p : <NEWLINE> <INDENT> if p % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> p //= f <NEWLINE> <DEDENT> elif f * f > p : <NEWLINE> <INDENT> a . append ( p ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> c = Counter ( a ) <NEWLINE> ans = 1 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> if v >= n : <NEWLINE> <INDENT> ans *= k ** ( v // n ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ np . asarray ( input ( ) . split ( ) , dtype = int ) for i in range ( N ) ] <NEWLINE> min_cost = 10 ** 9 <NEWLINE> def dfs ( cost , C , depth = 0 ) : <NEWLINE> <INDENT> global min_cost <NEWLINE> if ( C >= K ) . all ( ) : <NEWLINE> <INDENT> min_cost = min ( [ cost , min_cost ] ) <NEWLINE> return <NEWLINE> <DEDENT> if depth == N : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dfs ( cost + Q [ depth ] [ 0 ] , C + Q [ depth ] [ 1 : ] , depth + 1 ) <NEWLINE> dfs ( cost , C , depth + 1 ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , np . zeros ( M ) ) <NEWLINE> <NL> print ( min_cost ) if min_cost != 10 ** 9 else print ( - 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( K , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = A [ i ] / A [ i - K ] <NEWLINE> if n > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> plus = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> plus [ i ] = i + A [ i ] <NEWLINE> <NL> <DEDENT> minus = [ 0 ] * ( N - 1 ) <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> minus [ j - 1 ] = j - A [ j ] <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> c = dict ( collections . Counter ( minus ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum += c . get ( plus [ i ] , 0 ) <NEWLINE> c [ minus [ i ] ] -= 1 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
def min_disc ( points ) : <NEWLINE> <INDENT> from random import sample <NEWLINE> N = len ( points ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return points [ 0 ] , 0 <NEWLINE> <DEDENT> points = sample ( points , N ) <NEWLINE> def cross ( a , b ) : <NEWLINE> <INDENT> return a . real * b . imag - a . imag * b . real <NEWLINE> <DEDENT> def norm2 ( a ) : <NEWLINE> <INDENT> return a . real * a . real + a . imag * a . imag <NEWLINE> <DEDENT> def make_circle_3 ( a , b , c ) : <NEWLINE> <INDENT> A , B , C = norm2 ( b - c ) , norm2 ( c - a ) , norm2 ( a - b ) <NEWLINE> S = cross ( b - a , c - a ) <NEWLINE> p = ( A * ( B + C - A ) * a + B * ( C + A - B ) * b + C * ( A + B - C ) * c ) / ( 4 * S * S ) <NEWLINE> radius = abs ( p - a ) <NEWLINE> return p , radius <NEWLINE> <DEDENT> def make_circle_2 ( a , b ) : <NEWLINE> <INDENT> c = ( a + b ) / 2 <NEWLINE> radius = abs ( a - c ) <NEWLINE> return c , radius <NEWLINE> <DEDENT> def in_circle ( point , circle ) : <NEWLINE> <INDENT> return abs ( point - circle [ 0 ] ) <= circle [ 1 ] + 1e-7 <NEWLINE> <DEDENT> p0 = points [ 0 ] <NEWLINE> circle = make_circle_2 ( p0 , points [ 1 ] ) <NEWLINE> for i , p_i in enumerate ( points [ 2 : ] , 2 ) : <NEWLINE> <INDENT> if not in_circle ( p_i , circle ) : <NEWLINE> <INDENT> circle = make_circle_2 ( p0 , p_i ) <NEWLINE> for j , p_j in enumerate ( points [ 1 : i ] , 1 ) : <NEWLINE> <INDENT> if not in_circle ( p_j , circle ) : <NEWLINE> <INDENT> circle = make_circle_2 ( p_i , p_j ) <NEWLINE> for p_k in points [ : j ] : <NEWLINE> <INDENT> if not in_circle ( p_k , circle ) : <NEWLINE> <INDENT> circle = make_circle_3 ( p_i , p_j , p_k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return circle <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> XY = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> XY . append ( x + y * 1j ) <NEWLINE> <DEDENT> center , rad = min_disc ( XY ) <NEWLINE> print ( rad ) <NEWLINE>
from bisect import bisect <NEWLINE> <NL> X , N = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = sorted ( [ int ( n ) for n in input ( ) . split ( ) ] ) <NEWLINE> if X not in P : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> idx = bisect ( P , X ) <NEWLINE> ans_r = 101 <NEWLINE> ans_l = 0 <NEWLINE> for i in range ( P [ idx - 1 ] , 101 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> ans_r = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , P [ idx - 1 ] ) : <NEWLINE> <INDENT> if j not in P : <NEWLINE> <INDENT> ans_l = j <NEWLINE> <DEDENT> <DEDENT> if abs ( X - ans_l ) == abs ( ans_r - X ) : <NEWLINE> <INDENT> print ( min ( [ ans_l , ans_r ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_l if abs ( X - ans_l ) < abs ( ans_r - X ) else ans_r ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> total = 0 <NEWLINE> y = sum ( list1 ) <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> y = y - list1 [ i ] <NEWLINE> total += list1 [ i ] * y % mod <NEWLINE> <NL> <DEDENT> total = total % mod <NEWLINE> print ( total ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( max ( alst ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = 1 <NEWLINE> r = max ( alst ) <NEWLINE> <NL> while r != l : <NEWLINE> <INDENT> pos = ( r + l ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for a in alst : <NEWLINE> <INDENT> cnt += ( a - 1 ) // pos <NEWLINE> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> r = pos <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = pos + 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
T = input ( ) <NEWLINE> T_trans = <STRING> <NEWLINE> for i in T : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> T_trans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T_trans += i <NEWLINE> <DEDENT> <DEDENT> print ( T_trans ) <NEWLINE>
def ch ( x ) : <NEWLINE> <INDENT> if x in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return int ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calc ( x ) : <NEWLINE> <INDENT> if x [ 2 ] == <STRING> : <NEWLINE> <INDENT> return x [ 0 ] + x [ 1 ] <NEWLINE> <DEDENT> elif x [ 2 ] == <STRING> : <NEWLINE> <INDENT> return x [ 0 ] - x [ 1 ] <NEWLINE> <DEDENT> elif x [ 2 ] == <STRING> : <NEWLINE> <INDENT> return x [ 0 ] * x [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> N = list ( map ( ch , input ( ) . split ( ) ) ) <NEWLINE> <NL> st = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if len ( N ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( type ( N [ 0 ] ) is int ) : <NEWLINE> <INDENT> st . append ( N [ 0 ] ) <NEWLINE> N . pop ( 0 ) <NEWLINE> <DEDENT> elif ( type ( N [ 0 ] ) is str ) : <NEWLINE> <INDENT> st [ - 2 ] = calc ( [ st [ - 2 ] , st [ - 1 ] , N [ 0 ] ] ) <NEWLINE> st . pop ( - 1 ) <NEWLINE> N . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( * st ) <NEWLINE> <NL> <NL>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = <STRING> <NEWLINE> d = { } <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> cnt = s . count ( l [ i ] ) <NEWLINE> pre = 0 <NEWLINE> if cnt > 0 : <NEWLINE> <INDENT> for j in range ( cnt ) : <NEWLINE> <INDENT> pos = s . find ( l [ i ] , pre ) <NEWLINE> pre = pos + 1 <NEWLINE> for m in range ( min ( len ( s ) - pos , k ) ) : <NEWLINE> <INDENT> if s [ pos : pos + m + 1 ] not in d : <NEWLINE> <INDENT> d [ s [ pos : pos + m + 1 ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( d ) >= k : <NEWLINE> <INDENT> dl = [ ] <NEWLINE> for i in d . keys ( ) : <NEWLINE> <INDENT> dl . append ( i ) <NEWLINE> <DEDENT> dl . sort ( ) <NEWLINE> print ( dl [ k - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> ope = tmp [ 0 ] <NEWLINE> if ope == <STRING> : <NEWLINE> <INDENT> m = tmp [ 1 ] <NEWLINE> d . appendleft ( m ) <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> m = tmp [ 1 ] <NEWLINE> if m in d : <NEWLINE> <INDENT> d . remove ( m ) <NEWLINE> <DEDENT> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> def count ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n : <NEWLINE> <INDENT> cnt += n % 2 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> LIMIT = 5 * 10 ** 5 <NEWLINE> dp = [ 0 ] * LIMIT <NEWLINE> for i in range ( 1 , LIMIT ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i % count ( i ) ] + 1 <NEWLINE> <NL> <DEDENT> c = x . count ( <STRING> ) <NEWLINE> a = int ( x , 2 ) % ( c + 1 ) <NEWLINE> <NL> if c == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( dp [ ( a + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> b = int ( x , 2 ) % ( c - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( dp [ ( a + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ ( b - pow ( 2 , n - i - 1 , c - 1 ) ) % ( c - 1 ) ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a *= L [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
num = n = int ( input ( ) ) <NEWLINE> <NL> price = [ ] <NEWLINE> max_pro = - 999999999 <NEWLINE> <NL> while ( n > 0 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> price . append ( x ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> min = price [ 0 ] <NEWLINE> for i in range ( 1 , num ) : <NEWLINE> <INDENT> pro = price [ i ] - min <NEWLINE> <NL> if ( max_pro < pro ) : <NEWLINE> <INDENT> max_pro = pro <NEWLINE> <DEDENT> if ( min > price [ i ] ) : <NEWLINE> <INDENT> min = price [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( max_pro ) ) <NEWLINE>
import math <NEWLINE> <NL> n , ans = int ( input ( ) ) , 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ansA , ansB , ansC = 0 , 0 , 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> ansC += a + 1 <NEWLINE> for b in range ( k - a - 1 ) : <NEWLINE> <INDENT> GCDab = math . gcd ( a + 1 , a + b + 2 ) <NEWLINE> ansB += GCDab <NEWLINE> for c in range ( k - a - b - 2 ) : <NEWLINE> <INDENT> GCDabc = math . gcd ( GCDab , a + b + c + 3 ) <NEWLINE> ansA += GCDabc <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ansA * 6 + ansB * 6 + ansC <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ 2 * j - i ] != S [ i ] and S [ 2 * j - i ] != S [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( R * G * B - count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count_R = 0 <NEWLINE> count_G = 0 <NEWLINE> count_B = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count_R = count_R + 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> count_G = count_G + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_B = count_B + 1 <NEWLINE> <DEDENT> <DEDENT> count = count_R * count_G * count_B <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> count = count - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans_list [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans_list ) ) ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> tt = 1 <NEWLINE> for _ in range ( 0 , tt ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> arr = input ( ) . split ( <STRING> ) <NEWLINE> arr = sorted ( arr ) <NEWLINE> mult = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> mult *= int ( arr [ i ] ) <NEWLINE> <NL> if mult > 10 ** 18 : <NEWLINE> <INDENT> mult = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mult ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = list ( input ( ) ) [ : - 1 ] <NEWLINE> n = len ( N ) <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = N [ i ] <NEWLINE> a = int ( s ) <NEWLINE> b += a <NEWLINE> b %= 9 <NEWLINE> <DEDENT> if b % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> f = 1 <NEWLINE> while f * f < m + 1 : <NEWLINE> <INDENT> if m % f == 0 : <NEWLINE> <INDENT> d . append ( f ) <NEWLINE> d . append ( m // f ) <NEWLINE> <DEDENT> f += 1 <NEWLINE> <DEDENT> d . sort ( reverse = True ) <NEWLINE> for i in d : <NEWLINE> <INDENT> if ( m - i * n ) >= 0 and ( m - i * n ) % i == 0 : break <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sorted ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( h [ i + k - 1 ] - h [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for b in range ( a , m + 1 ) : <NEWLINE> <INDENT> for c in range ( b , m + 1 ) : <NEWLINE> <INDENT> for d in range ( c , m + 1 ) : <NEWLINE> <INDENT> for e in range ( d , m + 1 ) : <NEWLINE> <INDENT> for f in range ( e , m + 1 ) : <NEWLINE> <INDENT> for g in range ( f , m + 1 ) : <NEWLINE> <INDENT> for h in range ( g , m + 1 ) : <NEWLINE> <INDENT> for i in range ( h , m + 1 ) : <NEWLINE> <INDENT> for j in range ( i , m + 1 ) : <NEWLINE> <INDENT> s = [ 0 , a , b , c , d , e , f , g , h , i , j ] <NEWLINE> cnt = 0 <NEWLINE> for w , x , y , z in abcd : <NEWLINE> <INDENT> if s [ x ] - s [ w ] == y : <NEWLINE> <INDENT> cnt += z <NEWLINE> <DEDENT> <DEDENT> ans = max ( cnt , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = r * r * pi <NEWLINE> b = ( r + r ) * pi <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = x <NEWLINE> judge = True <NEWLINE> if ( n != 0 ) : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> judge = False <NEWLINE> <NL> <DEDENT> if ( n == 1 ) : <NEWLINE> <INDENT> if ( x == p [ 0 ] ) : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> judge = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ( judge ) : <NEWLINE> <INDENT> check = True <NEWLINE> s_list = [ ] <NEWLINE> l_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( x - i == p [ j ] ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if ( check ) : <NEWLINE> <INDENT> s_list . append ( x - i ) <NEWLINE> <DEDENT> check = True <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( x + i == p [ j ] ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if ( check ) : <NEWLINE> <INDENT> l_list . append ( x + i ) <NEWLINE> <DEDENT> check = True <NEWLINE> <DEDENT> if ( l_list == [ ] ) : <NEWLINE> <INDENT> ans = max ( s_list ) <NEWLINE> <DEDENT> if ( s_list == [ ] ) : <NEWLINE> <INDENT> ans = min ( l_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( abs ( x - min ( l_list ) ) > abs ( x - max ( s_list ) ) ) : <NEWLINE> <INDENT> ans = max ( s_list ) <NEWLINE> <DEDENT> elif ( abs ( x - min ( l_list ) ) == abs ( x - max ( s_list ) ) ) : <NEWLINE> <INDENT> ans = max ( s_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( l_list ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> N , K = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] / A [ i - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] <NEWLINE> <NL> def calc ( A , n , dp ) : <NEWLINE> <INDENT> dp += [ A [ 0 ] * A [ 1 ] ] <NEWLINE> rsum = A [ 0 ] + A [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp += [ dp [ - 1 ] + rsum * A [ i ] ] <NEWLINE> rsum += A [ i ] <NEWLINE> <NL> <DEDENT> i = dp . index ( max ( dp ) ) <NEWLINE> rsum = 0 <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> rsum += A [ j ] <NEWLINE> <DEDENT> res = max ( dp ) <NEWLINE> dp2 = max ( dp ) <NEWLINE> for j in range ( 0 , i ) : <NEWLINE> <INDENT> rsum -= A [ j ] <NEWLINE> dp2 -= A [ j ] * rsum <NEWLINE> res = max ( dp2 , res ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> ans = calc ( a , n , dp ) % mod <NEWLINE> print ( ans ) <NEWLINE> <NL>
def D ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> mod = 0 <NEWLINE> for i , element in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> mod += int ( element ) * pow ( 10 , i , 2019 ) <NEWLINE> mods [ mod % 2019 ] += 1 <NEWLINE> <DEDENT> print ( sum ( map ( lambda x : int ( x * ( x - 1 ) / 2 ) , mods ) ) ) <NEWLINE> <DEDENT> D ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 in A : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : ans = - 1 ; break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> ( h , w ) = [ int ( i ) for i in stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import re <NEWLINE> <NL> pattern = [ ] <NEWLINE> <NL> s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> <NL> s = s + s <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> matchOB = re . search ( p , s ) <NEWLINE> <NL> if matchOB : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> A , B , K = il ( ) <NEWLINE> st = set ( ) <NEWLINE> for a in range ( A , A + K ) : <NEWLINE> <INDENT> if a > B : break <NEWLINE> st . add ( a ) <NEWLINE> <DEDENT> for b in reversed ( range ( B - K + 1 , B + 1 ) ) : <NEWLINE> <INDENT> if b < A : break <NEWLINE> st . add ( b ) <NEWLINE> <DEDENT> print ( * sorted ( st ) , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> S = map ( int , input ( ) . split ( ) ) <NEWLINE> K = ( list ( range ( 0 , 102 ) ) ) <NEWLINE> for i in S : <NEWLINE> <INDENT> K . remove ( i ) <NEWLINE> <DEDENT> L = [ ] <NEWLINE> for i in K : <NEWLINE> <INDENT> L . append ( abs ( x - i ) ) <NEWLINE> <DEDENT> m = min ( L ) <NEWLINE> ind_m = L . index ( m ) <NEWLINE> print ( K [ ind_m ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> sa = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ c ] += s [ b ] <NEWLINE> sa += ( c - b ) * s [ b ] <NEWLINE> s [ b ] = 0 <NEWLINE> print ( sa ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
import math <NEWLINE> <NL> def solve ( n , m , k , a_lst , b_lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> aa_lst = make_sum_list ( a_lst , k ) <NEWLINE> bb_lst = make_sum_list ( b_lst , k ) <NEWLINE> len_aa = len ( aa_lst ) <NEWLINE> len_bb = len ( bb_lst ) <NEWLINE> <NL> <COMMENT> <NL> if len_aa == 0 : <NEWLINE> <INDENT> if len_bb == 0 : return 0 <NEWLINE> else : return len_bb <NEWLINE> <DEDENT> elif len_bb == 0 : return len_aa <NEWLINE> <NL> <COMMENT> <NL> if aa_lst [ - 1 ] + bb_lst [ - 1 ] <= k : return len_aa + len_bb <NEWLINE> <NL> <COMMENT> <NL> max_read = max ( len_aa , len_bb ) <NEWLINE> <NL> <COMMENT> <NL> for i in reversed ( range ( len_aa ) ) : <NEWLINE> <INDENT> time = aa_lst [ i ] <NEWLINE> read = i + 1 <NEWLINE> if read + len_bb + 1 <= max_read : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> imax = len_bb - 1 <NEWLINE> imin = 0 <NEWLINE> imid = len_bb // 2 <NEWLINE> while True : <NEWLINE> <INDENT> if time + bb_lst [ imid ] <= k : <NEWLINE> <COMMENT> <NL> <INDENT> if imax - imid <= 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if time + bb_lst [ imax ] <= k : <NEWLINE> <INDENT> read += imax + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> read += imid + 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> imin = imid <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if imid - imin <= 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if time + bb_lst [ imin ] <= k : <NEWLINE> <INDENT> read += imin + 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> imax = imid <NEWLINE> <DEDENT> imid = ( imin + imax ) // 2 <NEWLINE> <DEDENT> max_read = max ( read , max_read ) <NEWLINE> <DEDENT> return max_read <NEWLINE> <NL> <NL> <DEDENT> def make_sum_list ( lst , max ) : <NEWLINE> <INDENT> sum_lst = [ ] <NEWLINE> sum = 0 <NEWLINE> for n in lst : <NEWLINE> <INDENT> sum += n <NEWLINE> if sum > max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum_lst . append ( sum ) <NEWLINE> <DEDENT> return sum_lst <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = solve ( n , m , k , a_lst , b_lst ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> sample_input = list ( range ( 3 ) ) <NEWLINE> sample_input [ 0 ] = <STRING> <NEWLINE> sample_input [ 1 ] = <STRING> <NEWLINE> sample_input [ 2 ] = <STRING> <NEWLINE> give_sample_input = None <NEWLINE> if give_sample_input is not None : <NEWLINE> <INDENT> sample_input_list = sample_input [ give_sample_input ] . split ( <STRING> ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sample_input_list . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def swap_list_item ( lst , i , j ) : <NEWLINE> <INDENT> tmp = lst [ i ] <NEWLINE> lst [ i ] = lst [ j ] <NEWLINE> lst [ j ] = tmp <NEWLINE> <NL> <DEDENT> num_of_data = int ( input ( ) ) <NEWLINE> list_of_data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> swap_count = 0 <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> n = num_of_data - 1 <NEWLINE> while n >= 1 : <NEWLINE> <INDENT> if list_of_data [ n ] < list_of_data [ n - 1 ] : <NEWLINE> <INDENT> swap_list_item ( list_of_data , n , n - 1 ) <NEWLINE> flag = True <NEWLINE> swap_count += 1 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result = <STRING> <NEWLINE> for number in list_of_data : <NEWLINE> <INDENT> result += str ( number ) + <STRING> <NEWLINE> <DEDENT> print ( result . strip ( ) ) <NEWLINE> print ( swap_count ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> lim_n = int ( sqrt ( n * 2 ) ) <NEWLINE> result = [ 0 ] * n <NEWLINE> <NL> for i in range ( 2 , lim_n + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 2 , j + 1 ) : <NEWLINE> <INDENT> p = i ** 2 + j ** 2 + k ** 2 <NEWLINE> if p > 2 * n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if p % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( j + k ) - i < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i == j and j == k : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> result [ p // 2 - 1 ] += 1 <NEWLINE> <DEDENT> elif i != j and j != k : <NEWLINE> <INDENT> result [ p // 2 - 1 ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ p // 2 - 1 ] += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for item in result : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <DEDENT>
import collections <NEWLINE> d = collections . deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> e = input ( ) <NEWLINE> if <STRING> == e [ 0 ] : d . appendleft ( e . split ( ) [ 1 ] ) <NEWLINE> else : <NEWLINE> <INDENT> if <STRING> == e [ 6 ] : <NEWLINE> <INDENT> m = e . split ( ) [ 1 ] <NEWLINE> if m in d : d . remove ( m ) <NEWLINE> <DEDENT> elif len ( e ) % 2 : d . popleft ( ) <NEWLINE> else : d . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * d ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l1_cnt = Counter ( l1 ) <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> l2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l2_cnt = Counter ( l2 ) <NEWLINE> l2_set = set ( l2 ) <NEWLINE> <NL> for i in l2_set : <NEWLINE> <INDENT> if l2_cnt [ i ] <= l1_cnt [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = 1000000000000000000 <NEWLINE> b = 1 <NEWLINE> cek = True <NEWLINE> zero = a . count ( 0 ) <NEWLINE> if zero > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = b * a [ i ] <NEWLINE> if b > q : <NEWLINE> <INDENT> cek = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cek : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( list ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> d [ ai ] . append ( bi ) <NEWLINE> d [ bi ] . append ( ai ) <NEWLINE> <NL> <DEDENT> bad = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if - 1 in d [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flg = True <NEWLINE> for nei_peak in d [ i ] : <NEWLINE> <INDENT> if h [ i ] <= h [ nei_peak ] : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> for nei_peak in d [ i ] : <NEWLINE> <INDENT> d [ nei_peak ] = [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def assign_color ( ) : <NEWLINE> <INDENT> _id = 1 <NEWLINE> for m in range ( vertices_num ) : <NEWLINE> <INDENT> if vertices_status_list [ m ] == - 1 : <NEWLINE> <INDENT> graph_dfs ( m , _id ) <NEWLINE> _id += 1 <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def graph_dfs ( vertex , color ) : <NEWLINE> <INDENT> vertices_stack = list ( ) <NEWLINE> vertices_stack . append ( vertex ) <NEWLINE> vertices_status_list [ vertex ] = color <NEWLINE> while vertices_stack : <NEWLINE> <INDENT> current_vertex = vertices_stack [ - 1 ] <NEWLINE> vertices_stack . pop ( ) <NEWLINE> for v in adj_list [ current_vertex ] : <NEWLINE> <INDENT> if vertices_status_list [ v ] == - 1 : <NEWLINE> <INDENT> vertices_status_list [ v ] = color <NEWLINE> vertices_stack . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices_num , relation_num = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> <NL> relation_info = _input [ 1 : relation_num + 1 ] <NEWLINE> <NL> question_num = int ( _input [ relation_num + 1 ] ) <NEWLINE> question_list = _input [ relation_num + 2 : ] <NEWLINE> <NL> adj_list = [ [ ] for _ in range ( vertices_num ) ] <NEWLINE> vertices_status_list = [ - 1 ] * vertices_num <NEWLINE> <NL> for relation in relation_info : <NEWLINE> <INDENT> key , value = map ( int , relation . split ( ) ) <NEWLINE> adj_list [ key ] . append ( value ) <NEWLINE> adj_list [ value ] . append ( key ) <NEWLINE> <NL> <DEDENT> assign_color ( ) <NEWLINE> <NL> <COMMENT> <NL> for question in question_list : <NEWLINE> <INDENT> start , target = map ( int , question . split ( ) ) <NEWLINE> if vertices_status_list [ start ] == vertices_status_list [ target ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> <NL> from collections import deque <NEWLINE> tmp = deque ( [ A [ 0 ] ] ) <NEWLINE> <NL> for x in A [ 1 : ] : <NEWLINE> <INDENT> ans += tmp . popleft ( ) <NEWLINE> tmp . append ( x ) <NEWLINE> tmp . append ( x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = set ( range ( 1 , n + 1 ) ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> s . discard ( int ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> AB_list = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> parents = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def find ( x : int ) -> int : <NEWLINE> <INDENT> if parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> parents [ x ] = find ( parents [ x ] ) <NEWLINE> return parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> root_x = find ( x ) <NEWLINE> root_y = find ( y ) <NEWLINE> <NL> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> depth_x = parents [ root_x ] <NEWLINE> depth_y = parents [ root_y ] <NEWLINE> <NL> if depth_x <= depth_y : <NEWLINE> <INDENT> parents [ root_y ] = root_x <NEWLINE> <NL> if depth_x == depth_y : <NEWLINE> <INDENT> parents [ root_x ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> parents [ root_x ] = root_y <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> for a , b in AB_list : <NEWLINE> <INDENT> union ( a , b ) <NEWLINE> <NL> <DEDENT> group = [ find ( num ) for num in range ( 1 , N + 1 ) ] <NEWLINE> cnt = Counter ( group ) <NEWLINE> <NL> print ( cnt . most_common ( 1 ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = a [ i - 1 ] <NEWLINE> <NL> <DEDENT> did = set ( ) <NEWLINE> route = [ 1 ] <NEWLINE> <NL> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> route . append ( now ) <NEWLINE> if now in did : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> did . add ( now ) <NEWLINE> <NL> <DEDENT> if k < 10 ** 6 : <NEWLINE> <INDENT> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( route ) ) : <NEWLINE> <INDENT> if route [ i ] == route [ - 1 ] : <NEWLINE> <INDENT> roop = route [ i : - 1 ] <NEWLINE> print ( roop [ ( k - i ) % len ( roop ) ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( ( N // i ) * ( ( N // i ) + 1 ) // 2 ) * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> [ H , W ] = [ int ( x ) for x in line . split ( ) ] <NEWLINE> if [ H , W ] == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE> <DEDENT>
<NL> def parse ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = [ ] <NEWLINE> for a in input ( ) . split ( <STRING> ) : <NEWLINE> <INDENT> A . append ( int ( a ) - 1 ) <NEWLINE> <DEDENT> return N , K , A <NEWLINE> <NL> <DEDENT> def fast_pow ( x , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> K = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 != 0 : <NEWLINE> <INDENT> K *= x <NEWLINE> <DEDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <NL> <DEDENT> return K * x <NEWLINE> <NL> <DEDENT> def fast_mod ( x , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> return x & ( N - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x % N <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K , A = parse ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> town = 0 <NEWLINE> route = [ 0 ] <NEWLINE> loop_start_index = None <NEWLINE> i = 0 <NEWLINE> visited = [ False for i in range ( N ) ] <NEWLINE> visited [ 0 ] = True <NEWLINE> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> town = A [ town ] <NEWLINE> <NL> if visited [ town ] : <NEWLINE> <COMMENT> <NL> <INDENT> loop_start_index = route . index ( town ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> visited [ town ] = True <NEWLINE> route . append ( town ) <NEWLINE> <NL> <DEDENT> if loop_start_index == None : <NEWLINE> <INDENT> print ( town + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_route = route [ loop_start_index : ] <NEWLINE> <COMMENT> <NL> print ( loop_route [ ( K - ( i + 1 ) ) % len ( loop_route ) ] + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> exit ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> route = [ ] <NEWLINE> next_town = A [ 0 ] <NEWLINE> town = 0 <NEWLINE> while not ( next_town in route ) : <COMMENT> <NEWLINE> <INDENT> route . append ( town ) <NEWLINE> next_town = A [ town ] <NEWLINE> town = next_town <NEWLINE> <DEDENT> once_route = route [ : route . index ( next_town ) ] <NEWLINE> loop_route = route [ route . index ( next_town ) : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if K >= len ( route ) and len ( once_route ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> loop_K = K - len ( route ) <NEWLINE> print ( loop_route [ fast_mod ( loop_K , len ( loop_route ) ) ] + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( route [ fast_mod ( K , len ( route ) ) ] + 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> c = 0 <NEWLINE> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> if c >= n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> i = l [ i - 1 ] <NEWLINE> <DEDENT>
def get_cycle ( pre , nxt , root ) : <NEWLINE> <INDENT> cycles , checked = [ ] , set ( ) <NEWLINE> <NL> <COMMENT> <NL> checked |= { root } <NEWLINE> que = nxt [ root ] [ : ] <NEWLINE> while que : <NEWLINE> <INDENT> root_linked = que . pop ( ) <NEWLINE> checked |= { root_linked } <NEWLINE> if nxt [ root_linked ] : <NEWLINE> <INDENT> que . extend ( nxt [ root_linked ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( pre ) ) : <NEWLINE> <INDENT> if i in checked : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> checking = set ( ) <NEWLINE> while i not in checked : <NEWLINE> <INDENT> checked |= { i } <NEWLINE> checking |= { i } <NEWLINE> i = pre [ i ] <NEWLINE> <DEDENT> if i not in checking : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> checking . clear ( ) <NEWLINE> while i not in checking : <NEWLINE> <INDENT> checking |= { i } <NEWLINE> i = pre [ i ] <NEWLINE> <NL> <DEDENT> cycles . append ( checking ) <NEWLINE> <DEDENT> return cycles <NEWLINE> <NL> <DEDENT> def cycle_cost ( cycles , m ) : <NEWLINE> <INDENT> return sum ( m [ ci ] for cycle in cycles for ci in cycle ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict <NEWLINE> from itertools import product <NEWLINE> def chi_liu_edmonds ( g , v , r ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = [ float ( <STRING> ) ] * v <NEWLINE> pre = [ None ] * v <NEWLINE> for s , t in product ( range ( v ) , repeat = 2 ) : <NEWLINE> <INDENT> if g [ s ] [ t ] < m [ t ] : <NEWLINE> <INDENT> m [ t ] = g [ s ] [ t ] <NEWLINE> pre [ t ] = s <NEWLINE> <DEDENT> <DEDENT> nxt = defaultdict ( list ) <NEWLINE> for t , s in enumerate ( pre ) : <NEWLINE> <INDENT> if s is not None : <NEWLINE> <INDENT> nxt [ s ] . append ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> cycles = get_cycle ( pre , nxt , r ) <NEWLINE> <NL> <COMMENT> <NL> if len ( cycles ) == 0 : <NEWLINE> <INDENT> m [ r ] = 0 <NEWLINE> return sum ( m ) <NEWLINE> <NL> <DEDENT> not_cycle = set ( range ( v ) ) . difference ( * cycles ) <NEWLINE> <COMMENT> <NL> abridger = { ni : i for i , ni in enumerate ( not_cycle ) } <NEWLINE> abridger . update ( { ci : i + len ( not_cycle ) for i , cycle in enumerate ( cycles ) for ci in cycle } ) <NEWLINE> v_dash = len ( not_cycle ) + len ( cycles ) <NEWLINE> g_dash = [ [ float ( <STRING> ) ] * v_dash for _ in range ( v_dash ) ] <NEWLINE> for s , t in product ( range ( v ) , repeat = 2 ) : <NEWLINE> <INDENT> s_dash , t_dash = abridger [ s ] , abridger [ t ] <NEWLINE> if s_dash != t_dash : <NEWLINE> <INDENT> d = g [ s ] [ t ] if t in not_cycle else g [ s ] [ t ] - g [ pre [ t ] ] [ t ] <NEWLINE> if g_dash [ s_dash ] [ t_dash ] > d : <NEWLINE> <INDENT> g_dash [ s_dash ] [ t_dash ] = d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return chi_liu_edmonds ( g_dash , v_dash , abridger [ r ] ) + cycle_cost ( cycles , m ) <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> v , e , r = map ( int , readline ( ) . split ( ) ) <NEWLINE> g = [ [ float ( <STRING> ) ] * v for _ in range ( v ) ] <NEWLINE> <NL> for _ in range ( e ) : <NEWLINE> <INDENT> s , t , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> if t == r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> g [ s ] [ t ] = d <NEWLINE> <DEDENT> print ( chi_liu_edmonds ( g , v , r ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a [ i ] + a_sum [ i ] ) <NEWLINE> <DEDENT> b_sum = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b [ i ] + b_sum [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a_sum [ i ] + b_sum [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = N <NEWLINE> a = ans // K <NEWLINE> b = ans % K <NEWLINE> <NL> if a > 0 : <NEWLINE> <INDENT> ans = N - K * a <NEWLINE> a = ans // K <NEWLINE> b = ans % K <NEWLINE> <NL> <DEDENT> if a == 0 : <NEWLINE> <INDENT> if ans > abs ( ans - K ) : <NEWLINE> <INDENT> print ( abs ( ans - K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> <NL> r = 0 <NEWLINE> <NL> if n == s : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n < s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> sq = int ( math . sqrt ( n ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> for i in range ( 2 , sq + 1 ) : <NEWLINE> <INDENT> nt = n <NEWLINE> st = 0 <NEWLINE> <NL> while nt > 0 : <NEWLINE> <INDENT> st += nt % i <NEWLINE> nt //= i <NEWLINE> <NL> <DEDENT> if st == s : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( sq + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> b = ( n - s ) // i + 1 <NEWLINE> <NL> st = n % b + n // b <NEWLINE> <NL> if n // b != b and st == s : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> AS = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> AS . sort ( reverse = True ) <NEWLINE> MAX_AS = AS [ 0 ] <NEWLINE> table = [ 0 ] * ( MAX_AS + 1 ) <COMMENT> <NEWLINE> <NL> alreadyVisited = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = dx = AS [ i ] <NEWLINE> if alreadyVisited . get ( x , False ) : <NEWLINE> <INDENT> table [ x ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> alreadyVisited [ x ] = True <NEWLINE> <NL> table [ x ] = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x += dx <NEWLINE> if x > MAX_AS : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> table [ x ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( table ) ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> dx = abs ( x1 - x2 ) <NEWLINE> dy = abs ( y1 - y2 ) <NEWLINE> print ( math . sqrt ( dx * dx + dy * dy ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> c = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c . append ( a [ - 1 ] . pop ( 0 ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 10 ** 8 <NEWLINE> <NL> for i in range ( 1 << n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> check = True <NEWLINE> d = [ 0 for i in range ( m ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> cost += c [ j ] <NEWLINE> for i2 in range ( m ) : <NEWLINE> <INDENT> d [ i2 ] += a [ j ] [ i2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( m ) : <NEWLINE> <INDENT> if d [ k ] < x : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if ans == 10 ** 8 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> return gcd ( b , a ) <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> if gcd ( K , 10 ) != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> K //= 7 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> cur = 1 <NEWLINE> while cur % K != 0 : <NEWLINE> <INDENT> cur += pow ( 10 , ans , K ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ [ ] for _ in range ( m ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : <NEWLINE> <INDENT> d [ a - 1 ] . append ( - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = [ ] <NEWLINE> heapq . heapify ( t ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for dd in d [ i ] : <NEWLINE> <INDENT> heapq . heappush ( t , dd ) <NEWLINE> <DEDENT> if t : <NEWLINE> <INDENT> ans += heapq . heappop ( t ) * ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def binary_search ( K , A , F ) : <NEWLINE> <INDENT> ng = - 1 <NEWLINE> ok = 10 ** 18 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> need_k = 0 <NEWLINE> for a , f in zip ( A , F ) : <NEWLINE> <INDENT> need_k += max ( 0 , a - mid // f ) <NEWLINE> <DEDENT> if need_k <= K : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> ans = binary_search ( K , A , F ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * N <NEWLINE> def rec ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> res = max ( res , rec ( nv ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> res = max ( res , rec ( v ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h = [ 0 for i in range ( N - 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> h [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if ans < count : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> <NL> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> for u , v in uv : <NEWLINE> <INDENT> u -= 1 <NEWLINE> v -= 1 <NEWLINE> adj [ u ] . append ( v ) <NEWLINE> adj [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> arrived = [ False ] * n <NEWLINE> <NL> ans = [ None ] * n <NEWLINE> ans [ 0 ] = 1 <NEWLINE> <NL> dp = [ INF ] * n <NEWLINE> <NL> <NL> def dfs ( u ) : <NEWLINE> <INDENT> arrived [ u ] = True <NEWLINE> for v in adj [ u ] : <NEWLINE> <INDENT> if not arrived [ v ] : <NEWLINE> <INDENT> idx = bisect_left ( dp , a [ v ] ) <NEWLINE> tmp = dp [ idx ] <NEWLINE> dp [ idx ] = a [ v ] <NEWLINE> ans [ v ] = bisect_left ( dp , INF - 1 ) <NEWLINE> dfs ( v ) <NEWLINE> dp [ idx ] = tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dp [ 0 ] = a [ 0 ] <NEWLINE> dfs ( 0 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL>
import numpy as np <NEWLINE> import math <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif N > 30 and A . count ( 1 ) < 10 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = functools . reduce ( operator . mul , A ) <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n_drop , cloth = int ( input ( ) ) , [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( 10 ) ] <NEWLINE> n_stain = sum ( sum ( i ) for i in cloth ) <NEWLINE> n = ( n_stain - 5 * n_drop ) // 4 <NEWLINE> <NL> drops_candidate = [ ] <NEWLINE> dl = 0 <NEWLINE> while 2 * dl <= n : <NEWLINE> <INDENT> dm = n - 2 * dl <NEWLINE> ds = n_drop - dm - dl <NEWLINE> if ds >= 0 : <NEWLINE> <INDENT> drops_candidate . append ( [ ds , dm , dl ] ) <NEWLINE> <DEDENT> dl += 1 <NEWLINE> <NL> <DEDENT> dx = ( 0 , - 1 , 1 , 0 , 0 , - 1 , - 1 , 1 , 1 , - 2 , 2 , 0 , 0 ) <NEWLINE> dy = ( 0 , 0 , 0 , - 1 , 1 , - 1 , 1 , - 1 , 1 , 0 , 0 , - 2 , 2 ) <NEWLINE> dd = ( 5 , 9 , 13 ) <NEWLINE> <NL> <NL> def find ( cloth , drops , pointer ) : <NEWLINE> <INDENT> global dy , dx , dd <NEWLINE> for p in range ( pointer , 100 ) : <NEWLINE> <INDENT> if cloth [ p // 10 ] [ p % 10 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pointer += 1 <NEWLINE> <DEDENT> for d in range ( 3 ) : <NEWLINE> <INDENT> if not drops [ d ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dn = dd [ d ] <NEWLINE> mir = int ( d == 2 ) <NEWLINE> mar = 9 - mir <NEWLINE> for i in range ( dn ) : <NEWLINE> <INDENT> x , y = pointer % 10 + dx [ i ] , pointer // 10 + dy [ i ] <NEWLINE> if not mir < x < mar or not mir < y < mar : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( dn ) : <NEWLINE> <INDENT> if not cloth [ y + dy [ j ] ] [ x + dx [ j ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( dn ) : <NEWLINE> <INDENT> cloth [ y + dy [ j ] ] [ x + dx [ j ] ] -= 1 <NEWLINE> <DEDENT> drops [ d ] -= 1 <NEWLINE> if sum ( drops ) : <NEWLINE> <INDENT> result = find ( cloth , drops , pointer ) <NEWLINE> if result : <NEWLINE> <INDENT> result . append ( ( x , y , d + 1 ) ) <NEWLINE> return result <NEWLINE> <DEDENT> for i in range ( dn ) : <NEWLINE> <INDENT> cloth [ y + dy [ i ] ] [ x + dx [ i ] ] += 1 <NEWLINE> <DEDENT> drops [ d ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ ( x , y , d + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> for drops in drops_candidate : <NEWLINE> <INDENT> history = find ( cloth , drops , 0 ) <NEWLINE> if history != False : <NEWLINE> <INDENT> for h in history : <NEWLINE> <INDENT> print ( * h ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a += i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> b += math . gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> c += math . gcd ( x , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = a + b + c <NEWLINE> print ( ans ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> if r * R + g * G > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( N - r * R - g * G ) % B != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> N , M = map ( int , r ( ) . split ( ) ) <NEWLINE> city = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , r ( ) . split ( ) ) <NEWLINE> city [ a ] . append ( b ) <NEWLINE> city [ b ] . append ( a ) <NEWLINE> <DEDENT> check = [ True ] + [ False ] * ( N ) <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> stack = [ v ] <NEWLINE> while stack : <NEWLINE> <INDENT> cur = stack . pop ( ) <NEWLINE> check [ cur ] = True <NEWLINE> for v in city [ cur ] : <NEWLINE> <INDENT> if not check [ v ] : <NEWLINE> <INDENT> stack . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if not check [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> An_input = input ( ) . split ( ) <NEWLINE> An = [ int ( s ) for s in An_input ] <NEWLINE> <NL> cnt = 0 <NEWLINE> k = 0 <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> k += An [ i ] <NEWLINE> cnt += k * An [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = cnt % M <NEWLINE> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> myans = [ 0 for n in range ( N + 1 ) ] <NEWLINE> upper = int ( N ** ( 2 / 3 ) ) <NEWLINE> <COMMENT> <NL> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v < N + 1 : <NEWLINE> <INDENT> myans [ v ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a , b in enumerate ( myans ) : <NEWLINE> <INDENT> if a != 0 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> hn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ 0 ] * ( n - 1 ) <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if hn [ i + 1 ] <= hn [ i ] : <NEWLINE> <INDENT> ls [ i ] = 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> x = x * A [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= b : <NEWLINE> <INDENT> print ( int ( a * ( b - 1 ) / b ) - a * int ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * n / b ) - a * int ( n / b ) ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) ; c += 1 <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( c , x ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> def main4 ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> L = ( N * M ) // math . gcd ( N , M ) <NEWLINE> <NL> pair = dict ( ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> idx = ( i - 1 ) * ( L // N ) + 1 <NEWLINE> pair [ idx ] = S [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> idx = ( i - 1 ) * ( L // M ) + 1 <NEWLINE> <NL> if idx in pair . keys ( ) : <NEWLINE> <INDENT> if pair [ idx ] != T [ i - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = N // i <NEWLINE> total += ( a * i + i ) * a <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( int ( total / 2 ) ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = False <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000001 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans < 1000000000000000001 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> peaks = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> ans = [ 0 ] + [ 1 for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if peaks [ x ] > peaks [ y ] : <NEWLINE> <INDENT> ans [ y ] = 0 <NEWLINE> <DEDENT> elif peaks [ x ] < peaks [ y ] : <NEWLINE> <INDENT> ans [ x ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ x ] = 0 <NEWLINE> ans [ y ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( n , k , r , s , p , t ) : <NEWLINE> <INDENT> winHand = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> bestHandMemo = [ <STRING> ] * ( n + 1 ) <COMMENT> <NEWLINE> <NL> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> def calcPoint ( char ) : <NEWLINE> <INDENT> if char == <STRING> : <NEWLINE> <INDENT> return p <NEWLINE> <DEDENT> elif char == <STRING> : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> elif char == <STRING> : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT> def dp ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> elif i <= k : <NEWLINE> <INDENT> bestHandMemo [ i - 1 ] = winHand [ t [ i - 1 ] ] <COMMENT> <NEWLINE> return dp ( i - 1 ) + calcPoint ( t [ i - 1 ] ) <NEWLINE> <DEDENT> elif winHand [ t [ i - 1 ] ] == bestHandMemo [ i - k - 1 ] : <NEWLINE> <INDENT> bestHandMemo [ i - 1 ] = <STRING> <COMMENT> <NEWLINE> return dp ( i - 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> bestHandMemo [ i - 1 ] = winHand [ t [ i - 1 ] ] <NEWLINE> return dp ( i - 1 ) + calcPoint ( t [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> memo [ i ] = dp ( i ) <NEWLINE> <NL> <DEDENT> return memo [ n ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> R , S , P = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> print ( solve ( N , K , R , S , P , T ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> int1 = lambda x : int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> <NL> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> n = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> <NL> A = [ 0 ] * n <NEWLINE> times = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = S [ i ] * times % mod <NEWLINE> times = times * 10 % mod <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> R = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R [ i + 1 ] = ( R [ i ] + A [ i ] ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> cnt = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> r = R [ i ] % mod <NEWLINE> <COMMENT> <NL> ans = ans + cnt . get ( r , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cnt [ r ] = cnt . get ( r , 0 ) + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> c = Counter ( a ) <NEWLINE> m = max ( a ) + 1 <NEWLINE> dp = [ False ] * m <NEWLINE> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if dp [ ai ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( ai , m , ai ) : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> s_rev = S [ : : - 1 ] <NEWLINE> <NL> r_list = [ 0 ] * 2019 <NEWLINE> r_list [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> num += d * int ( s_rev [ i ] ) <NEWLINE> num %= 2019 <NEWLINE> r_list [ num ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += r_list [ i ] * ( r_list [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> N = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n >= N : <NEWLINE> <INDENT> c [ N - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in c : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from math import ceil <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for i in range ( 1 , ceil ( n / 2 ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if i * j < n : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if int ( n ** 0.5 ) == n ** 0.5 : <NEWLINE> <INDENT> print ( res * 2 + int ( n ** 0.5 ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res * 2 + int ( n ** 0.5 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def dfs ( x , y , fru ) : <NEWLINE> <COMMENT> <NL> <INDENT> field [ x ] [ y ] = <STRING> <NEWLINE> <COMMENT> <NL> for dx in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> if 0 <= nx and nx < H and field [ nx ] [ y ] == fru : <NEWLINE> <INDENT> dfs ( nx , y , fru ) <NEWLINE> <DEDENT> <DEDENT> for dy in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> if 0 <= ny and ny < W and field [ x ] [ ny ] == fru : <NEWLINE> <INDENT> dfs ( x , ny , fru ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solv ( H , W ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( i , j , <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( i , j , <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( i , j , <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> f = 0 <NEWLINE> while ( f == 0 ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H != 0 and W != 0 : <NEWLINE> <INDENT> field = [ ] <COMMENT> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> solv ( H , W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i == len ( a ) - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum = sum + math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> n = range ( 1 , int ( input ( ) ) + 1 ) <NEWLINE> ppp = list ( itertools . combinations ( n , 3 ) ) <NEWLINE> pp = list ( itertools . combinations ( n , 2 ) ) <NEWLINE> asum , bsum , csum = 0 , 0 , 0 <NEWLINE> for p in ppp : <NEWLINE> <INDENT> asum += math . gcd ( math . gcd ( p [ 0 ] , p [ 1 ] ) , p [ 2 ] ) <NEWLINE> <NL> <DEDENT> for p in pp : <NEWLINE> <INDENT> bsum += math . gcd ( p [ 0 ] , p [ 1 ] ) <NEWLINE> <NL> <DEDENT> for p in n : <NEWLINE> <INDENT> csum += p <NEWLINE> <NL> <DEDENT> print ( asum * 6 + bsum * 6 + csum ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> max_num = A [ - 1 ] <NEWLINE> counter = Counter ( A ) <NEWLINE> s = set ( ) <NEWLINE> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if counter [ a ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> idx = 1 <NEWLINE> while a * idx <= max_num : <NEWLINE> <INDENT> s . add ( a * idx ) <NEWLINE> idx += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> <COMMENT> <NL> N //= 26 <NEWLINE> <NL> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
def call ( a ) : <NEWLINE> <INDENT> if a % 3 == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> while a != 0 : <NEWLINE> <INDENT> if a % 10 == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> a //= 10 <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if call ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> money = 1000 <NEWLINE> stock = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ls [ i ] < ls [ i + 1 ] : <NEWLINE> <INDENT> s = money // ls [ i ] <NEWLINE> money -= s * ls [ i ] <NEWLINE> stock += s <NEWLINE> <DEDENT> elif ls [ i ] > ls [ i + 1 ] : <NEWLINE> <INDENT> money += ls [ i ] * stock <NEWLINE> stock = 0 <NEWLINE> <DEDENT> <DEDENT> money += ls [ N - 1 ] * stock <NEWLINE> <NL> print ( money ) <NEWLINE>
s = input ( ) <NEWLINE> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if i == len ( s ) + 1 : <NEWLINE> <INDENT> print ( 1 ) ; exit ( ) <NEWLINE> <DEDENT> if s [ i - 1 ] != <STRING> : <NEWLINE> <INDENT> t = i <NEWLINE> ans = int ( s [ i - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if int ( input ( ) ) < t : <NEWLINE> <INDENT> print ( 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def is_prime ( num ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif not num & 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , math . ceil ( math . sqrt ( num ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = len ( [ num for num in nums if is_prime ( num ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = dict ( ( i , 0 ) for i in range ( 1 , n + 1 ) ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if k - q + a [ i ] > 0 else <STRING> ) <NEWLINE> <DEDENT>
x = sum ( list ( map ( int , input ( ) ) ) ) <NEWLINE> <NL> if x % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> rem = a [ i ] - 1 <NEWLINE> ans [ rem ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from itertools import combinations_with_replacement as cwr <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> n = range ( 1 , K + 1 ) <NEWLINE> total = 0 <NEWLINE> <NL> for a , b , c in cwr ( n , 3 ) : <NEWLINE> <INDENT> d = gcd ( gcd ( a , b ) , c ) <NEWLINE> if a == b == c : <NEWLINE> <INDENT> total += d <NEWLINE> <DEDENT> elif a != b != c : <NEWLINE> <INDENT> total += d * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += d * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans + math . floor ( ( N - 1 ) / a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> count = 0 <NEWLINE> <NL> a , b , c = 1 , 1 , 1 <NEWLINE> <NL> while a <= n : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if a == 1 : <NEWLINE> <INDENT> ans = ans + ( ( n // a ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> if n // a == 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> ans = ans + ( ( n // a ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + ( ( n // a ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> a += 1 <NEWLINE> b , c = 1 , 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans - 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> fact_count = [ 0 for _ in range ( K + 1 ) ] <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> fact_count [ k ] = K // k <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> count = [ 0 for _ in range ( K + 1 ) ] <NEWLINE> for k in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> c = pow ( fact_count [ k ] , N , mod ) <NEWLINE> j = 2 * k <NEWLINE> l = 2 <NEWLINE> while ( j <= K ) : <NEWLINE> <INDENT> c -= count [ j ] <NEWLINE> l += 1 <NEWLINE> j = k * l <NEWLINE> <DEDENT> count [ k ] = c <NEWLINE> c = c * k % mod <NEWLINE> ans += c <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s_2 = 0 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> s_2 += i ** 2 <NEWLINE> <NL> <DEDENT> ans = ( sum ( a_list ) ** 2 - s_2 ) // 2 <NEWLINE> <NL> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans * i % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if K == 1 : <NEWLINE> <INDENT> print ( A [ 0 ] % MOD ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if K % 2 == 1 and A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if K % 2 == 1 and A [ 0 ] < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * A [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N - A . count ( 0 ) < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A [ - 1 ] >= 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * A [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = N - 1 <NEWLINE> t = [ ] <NEWLINE> c = 0 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> tk = K - 1 <NEWLINE> flg = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tk = K <NEWLINE> flg = False <NEWLINE> <DEDENT> while c < tk : <NEWLINE> <INDENT> if A [ l ] * A [ l + 1 ] <= A [ r ] * A [ r - 1 ] : <NEWLINE> <INDENT> t . append ( A [ r ] ) <NEWLINE> t . append ( A [ r - 1 ] ) <NEWLINE> r -= 2 <NEWLINE> c += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . append ( A [ l ] ) <NEWLINE> t . append ( A [ l + 1 ] ) <NEWLINE> l += 2 <NEWLINE> c += 2 <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> t . append ( A [ l ] ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in t : <NEWLINE> <INDENT> ans = ans * i % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> d = { } <NEWLINE> count = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in d : <NEWLINE> <INDENT> count += d [ s ] <NEWLINE> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> import math <NEWLINE> import os <NEWLINE> import random <NEWLINE> import re <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> change = n % 1000 <NEWLINE> if change : <NEWLINE> <INDENT> print ( 1000 - change ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <NL>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , S : str ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> sub = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> if j * 2 - i < N and S [ j * 2 - i ] == <STRING> : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> if j * 2 - i < N and S [ j * 2 - i ] == <STRING> : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> if j * 2 - i < N and S [ j * 2 - i ] == <STRING> : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> if j * 2 - i < N and S [ j * 2 - i ] == <STRING> : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> if j * 2 - i < N and S [ j * 2 - i ] == <STRING> : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> if j * 2 - i < N and S [ j * 2 - i ] == <STRING> : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - sub ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> S = next ( tokens ) <COMMENT> <NEWLINE> solve ( N , S ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> if n == 0 : <NEWLINE> <INDENT> if As [ 0 ] == 1 : print ( 1 ) <NEWLINE> else : print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if As [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> acc_r = list ( accumulate ( As [ : : - 1 ] ) ) <NEWLINE> acc_r = acc_r [ : : - 1 ] <NEWLINE> <COMMENT> <NL> acc = acc_r [ 1 : ] + [ acc_r [ - 1 ] ] <NEWLINE> p = 1 <NEWLINE> ans = 1 <NEWLINE> for s , a in zip ( acc , As ) : <NEWLINE> <INDENT> p = min ( ( p - a ) * 2 , s ) <NEWLINE> if p < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans += p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> base = np . zeros ( n ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> base [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( int ( base [ i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> ct = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ct -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ct ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> G . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = [ ] <NEWLINE> sign = [ - 1 ] * N <NEWLINE> sign [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> while q : <NEWLINE> <INDENT> x = q . pop ( 0 ) <NEWLINE> for nv in G [ x ] : <NEWLINE> <INDENT> if sign [ nv ] == - 1 : <NEWLINE> <INDENT> sign [ nv ] = x <NEWLINE> q . append ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( sign [ i ] + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> x , n = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if n > 0 : <NEWLINE> <INDENT> p = set ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = set ( ) <NEWLINE> <NL> <DEDENT> b , e = x , x <NEWLINE> while b in p and e in p : <NEWLINE> <INDENT> b -= 1 <NEWLINE> e += 1 <NEWLINE> <NL> <DEDENT> if b not in p : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> b = [ 0 , 0 ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ a ] += v <NEWLINE> if b [ 0 ] == a and v > 0 : b [ 1 ] += v <NEWLINE> elif b [ 0 ] == a : mx = max ( c [ 0 : ] ) ; b [ 0 ] , b [ 1 ] = min ( [ i for i , value in enumerate ( c ) if value == mx ] ) , mx <NEWLINE> elif b [ 1 ] < c [ a ] : b [ 0 ] , b [ 1 ] = a , c [ a ] <NEWLINE> elif b [ 1 ] == c [ a ] and b [ 0 ] > a : b [ 0 ] , b [ 1 ] = a , c [ a ] <NEWLINE> print ( * b ) <NEWLINE> <DEDENT>
def nabeatsu ( n ) : <NEWLINE> <INDENT> if ( n % 3 == 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> temp = n <NEWLINE> while ( temp > 0 ) : <NEWLINE> <INDENT> if ( temp % 10 == 3 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> temp = temp // 10 <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if ( nabeatsu ( i + 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i + 1 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> r = 1 <NEWLINE> upper = pow ( 10 , 18 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r *= A [ i ] <NEWLINE> <NL> if r > upper : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hl = input ( ) . split ( ) <NEWLINE> shl = [ int ( x ) for x in hl ] <NEWLINE> vl = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if shl [ a - 1 ] > shl [ b - 1 ] : <NEWLINE> <INDENT> vl . add ( b - 1 ) <NEWLINE> <DEDENT> elif shl [ a - 1 ] < shl [ b - 1 ] : <NEWLINE> <INDENT> vl . add ( a - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl . add ( a - 1 ) <NEWLINE> vl . add ( b - 1 ) <NEWLINE> <DEDENT> <DEDENT> lshl = len ( shl ) <NEWLINE> lvl = len ( vl ) <NEWLINE> ans = lshl - lvl <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> b = [ 0 ] * 2019 <NEWLINE> b [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> m = 2019 <NEWLINE> c = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now += int ( s [ i ] ) * c <NEWLINE> now = now % m <NEWLINE> c = c * 10 <NEWLINE> ans = ans + b [ now ] <NEWLINE> b [ now ] = b [ now ] + 1 <NEWLINE> c = c % m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Y = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Y . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( Y ) ) ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . height = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def get_root ( self , i ) : <NEWLINE> <INDENT> if self . parent [ i ] == i : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ i ] = self . get_root ( self . parent [ i ] ) <NEWLINE> return self . parent [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , i , j ) : <NEWLINE> <INDENT> root_i = self . get_root ( i ) <NEWLINE> root_j = self . get_root ( j ) <NEWLINE> if root_i != root_j : <NEWLINE> <INDENT> if self . height [ root_i ] < self . height [ root_j ] : <NEWLINE> <INDENT> self . parent [ root_i ] = root_j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ root_j ] = root_i <NEWLINE> if self . height [ root_i ] == self . height [ root_j ] : <NEWLINE> <INDENT> self . height [ root_i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def is_in_group ( self , i , j ) : <NEWLINE> <INDENT> if self . get_root ( i ) == self . get_root ( j ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . unite ( A , B ) <NEWLINE> <NL> <DEDENT> check = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> check [ uf . get_root ( i ) ] += 1 <NEWLINE> <DEDENT> print ( max ( check ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import math <NEWLINE> <NL> def cnt ( n , i ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = n - 3 * i <NEWLINE> m = i - 1 <NEWLINE> return math . factorial ( l + m ) // ( math . factorial ( l ) * math . factorial ( m ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if n == 2 or n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> iter = n // 3 <NEWLINE> for i in range ( 1 , iter + 1 ) : <NEWLINE> <INDENT> if i * 3 <= n : <NEWLINE> <INDENT> ans += cnt ( n , i ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if 12 < int ( s [ : 2 ] ) or 0 == int ( s [ : 2 ] ) : <NEWLINE> <INDENT> if 12 >= int ( s [ 2 : ] ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif 1 <= int ( s [ : 2 ] ) <= 12 : <NEWLINE> <INDENT> if 12 >= int ( s [ 2 : ] ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
[ X , K , D ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = abs ( X ) <NEWLINE> Y = K % 2 <NEWLINE> if X // D < K : <NEWLINE> <INDENT> if ( X // D ) % 2 == Y : <NEWLINE> <INDENT> X = X % D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = D - X % D <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> X = X - K * D <NEWLINE> <NL> <DEDENT> print ( X ) <NEWLINE>
alph = <STRING> <NEWLINE> def acc_seq ( i ) : <NEWLINE> <INDENT> return 26 * ( pow ( 26 , i ) - 1 ) // 25 <NEWLINE> <NL> <DEDENT> def name_dog ( digit , at , name ) : <NEWLINE> <INDENT> if digit == 1 : <NEWLINE> <INDENT> return name + alph [ at ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> group = at // pow ( 26 , digit - 1 ) <NEWLINE> at -= pow ( 26 , digit - 1 ) * group <NEWLINE> name += alph [ group ] <NEWLINE> return name_dog ( digit - 1 , at , name ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> digit = 1 <NEWLINE> while ( n > acc_seq ( digit ) ) : <NEWLINE> <INDENT> digit += 1 <NEWLINE> <NL> <DEDENT> at = abs ( n - acc_seq ( digit - 1 ) - 1 ) <NEWLINE> print ( name_dog ( digit , at , <STRING> ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> c *= b [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> n = float ( input ( ) ) <NEWLINE> area = <STRING> % float ( n ** 2 * math . pi ) <NEWLINE> circ = <STRING> % float ( n * 2 * math . pi ) <NEWLINE> print ( area , circ ) <NEWLINE>
from decimal import * <NEWLINE> import re <NEWLINE> def solve2 ( m , n ) : <NEWLINE> <INDENT> maxreplen = 160 <NEWLINE> PREC = 200 <NEWLINE> getcontext ( ) . prec = PREC <NEWLINE> x = Decimal ( m ) / Decimal ( n ) <NEWLINE> s = x . to_eng_string ( ) <NEWLINE> if len ( s ) < PREC : <NEWLINE> <INDENT> return ( s [ 2 : ] , <STRING> ) <NEWLINE> <DEDENT> rep = 1 <NEWLINE> while True : <NEWLINE> <INDENT> r = <STRING> % ( rep , int ( maxreplen / rep ) - 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = re . search ( r , s ) <NEWLINE> if a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rep += 1 <NEWLINE> if rep > maxreplen : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> u = s [ 2 : a . start ( ) + len ( a . group ( 1 ) ) ] <NEWLINE> v = ( <STRING> * PREC + <STRING> * len ( a . group ( 1 ) ) ) [ - len ( u ) : ] <NEWLINE> return ( u , v ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> s , t = solve2 ( m , n ) <NEWLINE> print ( s ) <NEWLINE> if t != <STRING> : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <NL> <NL> <NL> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> L = [ 0 ] * len ( s ) <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] <NEWLINE> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( L [ r - 1 ] - L [ l - 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> S [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> <NL> print ( <STRING> . join ( S ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> n = len ( t ) <NEWLINE> m = len ( s ) <NEWLINE> mn = n <NEWLINE> for i in range ( m - n + 1 ) : <NEWLINE> <INDENT> err = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> err += 1 <NEWLINE> <DEDENT> <DEDENT> mn = min ( mn , err ) <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> x += ( N - 1 ) // n <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> def nibun ( L , l , r , target ) : <NEWLINE> <NL> <INDENT> wrk = - ( - ( l + r ) // 2 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if r == l : <NEWLINE> <INDENT> if r == len ( L ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return wrk + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if l == ( len ( L ) - 1 ) : <NEWLINE> <INDENT> if L [ wrk - 1 ] > target : <NEWLINE> <INDENT> return wrk <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if L [ wrk ] == target : <NEWLINE> <INDENT> return wrk + 1 <NEWLINE> <NL> <DEDENT> elif L [ wrk ] > target : <NEWLINE> <INDENT> return nibun ( L , l , wrk - 1 , target ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return nibun ( L , wrk , r , target ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i , e in enumerate ( B ) : <NEWLINE> <INDENT> s += e <NEWLINE> b . append ( s ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s += A [ i ] <NEWLINE> if s > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wrk = nibun ( b , - 1 , len ( b ) , K - s ) <NEWLINE> <NL> ans = max ( ans , i + wrk ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> MOD = 998244353 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n , k = INTM ( ) <NEWLINE> lrs = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> lrs . append ( LIST ( ) ) <NEWLINE> <DEDENT> pt = np . array ( [ 0 ] * ( ( 2 * n ) + 1 ) ) <NEWLINE> rui = np . array ( [ 0 ] * ( ( 2 * n ) + 1 ) ) <NEWLINE> pt [ n - 1 ] = 1 <NEWLINE> rui [ n - 1 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nt = n - 1 + i <NEWLINE> for l , r in lrs : <NEWLINE> <INDENT> pt [ nt ] = ( pt [ nt ] - rui [ nt - r - 1 ] + rui [ nt - l ] ) % MOD <NEWLINE> <DEDENT> rui [ nt ] = ( rui [ nt - 1 ] + pt [ nt ] ) % MOD <NEWLINE> <DEDENT> print ( pt [ 2 * n - 2 ] % MOD ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * N <NEWLINE> <NL> idx = 0 <NEWLINE> stp = 0 <NEWLINE> ans = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> stp += 1 <NEWLINE> idx = A [ idx ] - 1 <NEWLINE> if c [ idx ] == 0 and idx != 0 : <NEWLINE> <INDENT> c [ idx ] = stp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp1 = c [ idx ] <NEWLINE> tmp2 = stp - tmp1 <NEWLINE> break <NEWLINE> <DEDENT> if stp >= K : <NEWLINE> <INDENT> ans = idx + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans > 0 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k1 = K - tmp1 <NEWLINE> k2 = k1 % tmp2 <NEWLINE> for _ in range ( k2 ) : <NEWLINE> <INDENT> idx = A [ idx ] - 1 <NEWLINE> <DEDENT> print ( idx + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 not in A : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N_list = [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H_list [ A - 1 ] >= H_list [ B - 1 ] : <NEWLINE> <INDENT> N_list [ B - 1 ] = 1 <NEWLINE> <DEDENT> if H_list [ A - 1 ] <= H_list [ B - 1 ] : <NEWLINE> <INDENT> N_list [ A - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( N_list . count ( 0 ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_ = max ( A ) <NEWLINE> A_ = list ( set ( A ) ) <NEWLINE> dp = [ True ] * ( a_ + 1 ) <NEWLINE> C = [ 0 ] * ( a_ + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> A_ . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A_ : <NEWLINE> <INDENT> tmp = a <NEWLINE> if dp [ tmp ] : <NEWLINE> <INDENT> tmp += a <NEWLINE> while tmp <= a_ : <NEWLINE> <INDENT> dp [ tmp ] = False <NEWLINE> tmp += a <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for a in A_ : <NEWLINE> <INDENT> if dp [ a ] : <NEWLINE> <INDENT> if C [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = sorted ( l ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += bisect_left ( l , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> d = Counter ( A ) <COMMENT> <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = d [ b ] <COMMENT> <NEWLINE> d [ b ] = 0 <COMMENT> <NEWLINE> d [ c ] += tmp <COMMENT> <NEWLINE> ans += ( c - b ) * tmp <COMMENT> <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> if tmp in dic : <NEWLINE> <INDENT> dic [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ tmp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in dic : <NEWLINE> <INDENT> dic [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ C ] = B <NEWLINE> <NL> <DEDENT> <DEDENT> dic = sorted ( dic . items ( ) , reverse = True ) <NEWLINE> <NL> ans , cnt = 0 , 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> k , v = dic [ i ] <NEWLINE> cnt += v <NEWLINE> if cnt < N : <NEWLINE> <INDENT> ans += k * v <NEWLINE> <DEDENT> elif cnt == N : <NEWLINE> <INDENT> ans += k * v <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += k * ( v - ( cnt - N ) ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> best = 0 <NEWLINE> a_time = 0 <NEWLINE> b_time = sum ( B ) <NEWLINE> b_i = len ( B ) - 1 <NEWLINE> end_flag = False <NEWLINE> for a_i in range ( N + 1 ) : <NEWLINE> <INDENT> a_time += A [ a_i ] <NEWLINE> while a_time + b_time > K : <NEWLINE> <INDENT> if b_i == 0 : <NEWLINE> <INDENT> end_flag = True <NEWLINE> break <NEWLINE> <DEDENT> b_time -= B [ b_i ] <NEWLINE> b_i -= 1 <NEWLINE> <NL> <DEDENT> if end_flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a_i + b_i > best : <NEWLINE> <INDENT> best = a_i + b_i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( best ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = n // ( a + b ) <NEWLINE> t = n % ( a + b ) <NEWLINE> print ( s * a + min ( t , a ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( s ) / n <NEWLINE> a = sum ( ( x - m ) ** 2 for x in s ) / n <NEWLINE> print ( a ** 0.5 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> if i >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT>
ans = 1 <NEWLINE> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ A ] . append ( - B ) <NEWLINE> <NL> <DEDENT> hq = [ ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for b in AB [ i ] : <NEWLINE> <INDENT> heapq . heappush ( hq , b ) <NEWLINE> <NL> <DEDENT> if len ( hq ) > 0 : <NEWLINE> <INDENT> ans += - heapq . heappop ( hq ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> result = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> for cnt in counts : <NEWLINE> <INDENT> result += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def bfs ( MAZE , start , seen ) : <NEWLINE> <INDENT> queue = deque ( [ start + ( 0 , ) ] ) <NEWLINE> max_count = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , count = queue . popleft ( ) <NEWLINE> max_count = max ( max_count , count ) <NEWLINE> if ( y , x ) in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( ( y , x ) ) <NEWLINE> for i , j in ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> next_y , next_x = y + i , x + j <NEWLINE> <COMMENT> <NL> if not ( next_y , next_x ) in seen and MAZE [ next_y ] [ next_x ] == <STRING> : <NEWLINE> <INDENT> queue . append ( ( next_y , next_x , count + 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return max_count <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> MAZE = [ <STRING> * ( W + 2 ) ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = <STRING> + s + <STRING> <NEWLINE> MAZE . append ( s ) <NEWLINE> <DEDENT> MAZE . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ways = [ ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if MAZE [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ways . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> max_count = 0 <NEWLINE> for s_i , s_j in ways : <NEWLINE> <INDENT> seen = set ( ( s_i , s_j ) ) <NEWLINE> min_count = bfs ( MAZE , ( s_i , s_j ) , seen ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> max_count = max ( max_count , min_count ) <NEWLINE> <NL> <DEDENT> print ( max_count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq as hp <NEWLINE> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , end , cost ) : <NEWLINE> <INDENT> self . to = end <NEWLINE> self . cost = cost <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Dijkstra : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . _node = V <NEWLINE> self . _graph = [ [ ] for i in range ( self . _node ) ] <NEWLINE> self . _inf = sys . maxsize <NEWLINE> self . dist = [ self . _inf for i in range ( self . _node ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , st , ed , cost ) : <NEWLINE> <INDENT> self . _graph [ st ] . append ( Edge ( ed , cost ) ) <NEWLINE> <DEDENT> def solve ( self , s ) : <NEWLINE> <INDENT> que = [ ] <NEWLINE> self . dist [ s ] = 0 <NEWLINE> hp . heappush ( que , ( 0 , s ) ) <NEWLINE> while que : <NEWLINE> <INDENT> cur_cost , cur_vertex = hp . heappop ( que ) <NEWLINE> if self . dist [ cur_vertex ] < cur_cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for e in self . _graph [ cur_vertex ] : <NEWLINE> <INDENT> if cur_cost + e . cost < self . dist [ e . to ] : <NEWLINE> <INDENT> self . dist [ e . to ] = cur_cost + e . cost <NEWLINE> hp . heappush ( que , ( self . dist [ e . to ] , e . to ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> dk = Dijkstra ( V ) <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> dk . add_edge ( s , t , d ) <NEWLINE> <DEDENT> dk . solve ( r ) <NEWLINE> for value in dk . dist : <NEWLINE> <INDENT> if value == sys . maxsize : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( value ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for _ in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = mi ( ) <NEWLINE> Q = li2 ( M ) <NEWLINE> <COMMENT> <NL> <NL> l = [ N ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ind = max ( 0 , Q [ i ] [ 0 ] - 1 ) <NEWLINE> l [ ind ] = min ( Q [ i ] [ 1 ] - 1 , l [ ind ] ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> l [ i ] = min ( l [ i ] , l [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> i = l [ i ] <NEWLINE> cnt += 1 <NEWLINE> if l [ i ] == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def SI ( ) : return input ( ) . rstrip ( ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> h , w = MI ( ) <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> lis = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = SI ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> lis [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> step = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ - 1 , 0 ] , [ 1 , 0 ] ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> for x , y in step : <NEWLINE> <INDENT> if not ( 0 <= i + x < h and 0 <= j + y < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if lis [ i ] [ j ] != lis [ i + x ] [ j + y ] : <NEWLINE> <INDENT> uf . union ( w * i + j , w * ( i + x ) + ( j + y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> dic = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> dic [ uf . find ( w * i + j ) ] [ lis [ i ] [ j ] == 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for p in dic . keys ( ) : <NEWLINE> <INDENT> ans += dic [ p ] [ 0 ] * dic [ p ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = input ( ) <NEWLINE> my_list = [ ] <NEWLINE> j = 0 <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> my_list . append ( i ) <NEWLINE> <NL> <DEDENT> if my_list [ 0 ] == my_list [ 1 ] == my_list [ 2 ] or my_list [ 1 ] == my_list [ 2 ] == my_list [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> skill_book = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> skill_book . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> box = [ ] <NEWLINE> flag = 1 <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> total = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> total = [ x + y for ( x , y ) in zip ( total , skill_book [ j ] ) ] <NEWLINE> <DEDENT> <DEDENT> over = 1 <NEWLINE> for j in range ( 1 , len ( total ) ) : <NEWLINE> <INDENT> if not ( total [ j ] >= X ) : <NEWLINE> <INDENT> over = 0 <NEWLINE> <DEDENT> <DEDENT> if over == 1 and len ( total ) > 0 : <NEWLINE> <INDENT> box . append ( total [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( box ) > 0 : <NEWLINE> <INDENT> print ( min ( box ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> self . parent = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , i ) : <NEWLINE> <INDENT> if self . parent [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> r = self . root ( self . parent [ i ] ) <NEWLINE> self . parent [ i ] = r <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def unite ( self , i , j ) : <NEWLINE> <INDENT> i = self . root ( i ) <NEWLINE> j = self . root ( j ) <NEWLINE> <NL> if i == j : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if i > j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <NL> <DEDENT> self . parent [ i ] += self . parent [ j ] <NEWLINE> self . parent [ j ] = i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def same ( self , i , j ) : <NEWLINE> <INDENT> return self . root ( i ) == self . root ( j ) <NEWLINE> <NL> <DEDENT> def size ( self , i ) : <NEWLINE> <INDENT> return - self . parent [ self . root ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> forest = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> forest . unite ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if forest . same ( i , p [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from typing import List , Tuple <NEWLINE> from math import sqrt <NEWLINE> from enum import Enum <NEWLINE> <NL> EPS = 1e-10 <NEWLINE> <NL> <NL> def float_equal ( x : float , y : float ) -> bool : <NEWLINE> <INDENT> return abs ( x - y ) < EPS <NEWLINE> <NL> <NL> <DEDENT> class PointLocation ( Enum ) : <NEWLINE> <INDENT> COUNTER_CLOCKWISE = 1 <NEWLINE> CLOCKWISE = 2 <NEWLINE> ONLINE_BACK = 3 <NEWLINE> ONLINE_FRONT = 4 <NEWLINE> ON_SEGMENT = 5 <NEWLINE> <NL> <NL> <DEDENT> class Point : <NEWLINE> <NL> <INDENT> def __init__ ( self , x : float = 0.0 , y : float = 0.0 ) -> None : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) -> str : <NEWLINE> <INDENT> return <STRING> . format ( self . x , self . y ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other : object ) -> bool : <NEWLINE> <INDENT> if not isinstance ( other , Point ) : <NEWLINE> <COMMENT> <NL> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return float_equal ( self . x , other . x ) and float_equal ( self . y , other . y ) <NEWLINE> <NL> <DEDENT> def __add__ ( self , other : <STRING> ) -> <STRING> : <NEWLINE> <INDENT> return Point ( self . x + other . x , self . y + other . y ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , other : <STRING> ) -> <STRING> : <NEWLINE> <INDENT> return Point ( self . x - other . x , self . y - other . y ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , k : float ) -> <STRING> : <NEWLINE> <INDENT> return Point ( self . x * k , self . y * k ) <NEWLINE> <NL> <DEDENT> def __rmul__ ( self , k : float ) -> <STRING> : <NEWLINE> <INDENT> return self * k <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , k : float ) -> <STRING> : <NEWLINE> <INDENT> return Point ( self . x / k , self . y / k ) <NEWLINE> <NL> <DEDENT> def __lt__ ( self , other : <STRING> ) -> bool : <NEWLINE> <INDENT> return self . y < other . y if abs ( self . x - other . x ) < EPS else self . x < other . x <NEWLINE> <NL> <DEDENT> def norm ( self ) : <NEWLINE> <INDENT> return self . x * self . x + self . y * self . y <NEWLINE> <NL> <DEDENT> def abs ( self ) : <NEWLINE> <INDENT> return sqrt ( self . norm ( ) ) <NEWLINE> <NL> <DEDENT> def dot ( self , other : <STRING> ) -> float : <NEWLINE> <INDENT> return self . x * other . x + self . y * other . y <NEWLINE> <NL> <DEDENT> def cross ( self , other : <STRING> ) -> float : <NEWLINE> <INDENT> return self . x * other . y - self . y * other . x <NEWLINE> <NL> <DEDENT> def is_orthogonal ( self , other : <STRING> ) -> bool : <NEWLINE> <INDENT> return float_equal ( self . dot ( other ) , 0.0 ) <NEWLINE> <NL> <DEDENT> def is_parallel ( self , other : <STRING> ) -> bool : <NEWLINE> <INDENT> return float_equal ( self . cross ( other ) , 0.0 ) <NEWLINE> <NL> <DEDENT> def distance ( self , other : <STRING> ) -> float : <NEWLINE> <INDENT> return ( self - other ) . abs ( ) <NEWLINE> <NL> <DEDENT> def in_side_of ( self , seg : <STRING> ) -> bool : <NEWLINE> <INDENT> return seg . vector ( ) . dot ( <NEWLINE> <INDENT> Segment ( seg . p1 , self ) . vector ( ) ) >= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def in_width_of ( self , seg : <STRING> ) -> bool : <NEWLINE> <INDENT> return self . in_side_of ( seg ) and self . in_side_of ( seg . reverse ( ) ) <NEWLINE> <NL> <DEDENT> def distance_to_line ( self , seg : <STRING> ) -> float : <NEWLINE> <INDENT> return abs ( ( self - seg . p1 ) . cross ( seg . vector ( ) ) ) / seg . length ( ) <NEWLINE> <NL> <DEDENT> def distance_to_segment ( self , seg : <STRING> ) -> float : <NEWLINE> <INDENT> if not self . in_side_of ( seg ) : <NEWLINE> <INDENT> return self . distance ( seg . p1 ) <NEWLINE> <DEDENT> if not self . in_side_of ( seg . reverse ( ) ) : <NEWLINE> <INDENT> return self . distance ( seg . p2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . distance_to_line ( seg ) <NEWLINE> <NL> <DEDENT> <DEDENT> def location ( self , seg : <STRING> ) -> PointLocation : <NEWLINE> <INDENT> p = self - seg . p1 <NEWLINE> d = seg . vector ( ) . cross ( p ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> return PointLocation . CLOCKWISE <NEWLINE> <DEDENT> elif d > 0 : <NEWLINE> <INDENT> return PointLocation . COUNTER_CLOCKWISE <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if seg . p2 . x != seg . p1 . x : <NEWLINE> <INDENT> r = ( self . x - seg . p1 . x ) / ( seg . p2 . x - seg . p1 . x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( self . y - seg . p1 . y ) / ( seg . p2 . y - seg . p1 . y ) <NEWLINE> <DEDENT> if r < 0 : <NEWLINE> <INDENT> return PointLocation . ONLINE_BACK <NEWLINE> <DEDENT> elif r > 1 : <NEWLINE> <INDENT> return PointLocation . ONLINE_FRONT <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return PointLocation . ON_SEGMENT <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> Vector = Point <NEWLINE> <NL> <NL> class Segment : <NEWLINE> <NL> <INDENT> def __init__ ( self , p1 : Point = None , p2 : Point = None ) -> None : <NEWLINE> <INDENT> self . p1 : Point = Point ( ) if p1 is None else p1 <NEWLINE> self . p2 : Point = Point ( ) if p2 is None else p2 <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) -> str : <NEWLINE> <INDENT> return <STRING> . format ( self . p1 , self . p2 ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other : object ) -> bool : <NEWLINE> <INDENT> if not isinstance ( other , Segment ) : <NEWLINE> <COMMENT> <NL> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return self . p1 == other . p1 and self . p2 == other . p2 <NEWLINE> <NL> <DEDENT> def vector ( self ) -> Vector : <NEWLINE> <INDENT> return self . p2 - self . p1 <NEWLINE> <NL> <DEDENT> def reverse ( self ) -> <STRING> : <NEWLINE> <INDENT> return Segment ( self . p2 , self . p1 ) <NEWLINE> <NL> <DEDENT> def length ( self ) -> float : <NEWLINE> <INDENT> return self . p1 . distance ( self . p2 ) <NEWLINE> <NL> <DEDENT> def is_orthogonal ( self , other : <STRING> ) -> bool : <NEWLINE> <INDENT> return self . vector ( ) . is_orthogonal ( other . vector ( ) ) <NEWLINE> <NL> <DEDENT> def is_parallel ( self , other : <STRING> ) -> bool : <NEWLINE> <INDENT> return self . vector ( ) . is_parallel ( other . vector ( ) ) <NEWLINE> <NL> <DEDENT> def projection ( self , p : Point ) -> Point : <NEWLINE> <INDENT> v = self . vector ( ) <NEWLINE> vp = p - self . p1 <NEWLINE> return v . dot ( vp ) / v . norm ( ) * v + self . p1 <NEWLINE> <NL> <DEDENT> def reflection ( self , p : Point ) -> Point : <NEWLINE> <INDENT> x = self . projection ( p ) <NEWLINE> return p + 2 * ( x - p ) <NEWLINE> <NL> <DEDENT> def intersect_ratio ( self , other : <STRING> ) -> Tuple [ float , float ] : <NEWLINE> <INDENT> a = self . vector ( ) <NEWLINE> b = other . vector ( ) <NEWLINE> c = self . p1 - other . p1 <NEWLINE> s = b . cross ( c ) / a . cross ( b ) <NEWLINE> t = a . cross ( c ) / a . cross ( b ) <NEWLINE> return s , t <NEWLINE> <NL> <DEDENT> def intersects ( self , other : <STRING> ) -> bool : <NEWLINE> <INDENT> s , t = self . intersect_ratio ( other ) <NEWLINE> return ( 0 <= s <= 1 ) and ( 0 <= t <= 1 ) <NEWLINE> <NL> <DEDENT> def intersection ( self , other : <STRING> ) -> Point : <NEWLINE> <INDENT> s , _ = self . intersect_ratio ( other ) <NEWLINE> return self . p1 + s * self . vector ( ) <NEWLINE> <NL> <DEDENT> def distance_with_segment ( self , other : <STRING> ) -> float : <NEWLINE> <INDENT> if not self . is_parallel ( other ) and self . intersects ( other ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( <NEWLINE> <INDENT> self . p1 . distance_to_segment ( other ) , <NEWLINE> self . p2 . distance_to_segment ( other ) , <NEWLINE> other . p1 . distance_to_segment ( self ) , <NEWLINE> other . p2 . distance_to_segment ( self ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> Line = Segment <NEWLINE> <NL> <NL> class Circle : <NEWLINE> <NL> <INDENT> def __init__ ( self , c : Point = None , r : float = 0.0 ) -> None : <NEWLINE> <INDENT> self . c : Point = Point ( ) if c is None else c <NEWLINE> self . r : float = r <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other : object ) -> bool : <NEWLINE> <INDENT> if not isinstance ( other , Circle ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return self . c == other . c and self . r == other . r <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) -> str : <NEWLINE> <INDENT> return <STRING> . format ( self . c , self . r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) -> None : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = Segment ( Point ( x0 , y0 ) , Point ( x1 , y1 ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> x2 , y2 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( Point ( x2 , y2 ) . location ( s ) . name ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import collections , math <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> ls = collections . Counter ( s ) <NEWLINE> lt = collections . Counter ( t ) <NEWLINE> <NL> time_dict = { } <NEWLINE> tmp = 0 <NEWLINE> max_time = 0 <COMMENT> <NEWLINE> for t_key , t_val in lt . items ( ) : <NEWLINE> <INDENT> if t_key not in ls : <COMMENT> <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> tt = list ( t [ : : - 1 ] ) <COMMENT> <NEWLINE> idx = 0 <NEWLINE> ss = s <COMMENT> <NEWLINE> while tt != [ ] : <COMMENT> <NEWLINE> <INDENT> next_t = tt . pop ( ) <COMMENT> <NEWLINE> idx = ss . find ( next_t ) <COMMENT> <NEWLINE> if idx == - 1 : <COMMENT> <NEWLINE> <INDENT> cnt += len ( ss ) <COMMENT> <NEWLINE> idx = s . find ( next_t ) <COMMENT> <NEWLINE> ss = s [ idx + 1 : ] <COMMENT> <NEWLINE> cnt += idx + 1 <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> cnt += idx + 1 <COMMENT> <NEWLINE> ss = ss [ idx + 1 : ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from numpy import prod <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> appearances = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for c in S : <NEWLINE> <INDENT> appearances [ c ] += 1 <NEWLINE> <DEDENT> print ( prod ( list ( appearances . values ( ) ) ) - sum ( sum ( len ( set ( S [ start ] + S [ start + step ] + S [ start + step * 2 ] ) ) == 3 for start in range ( N - step * 2 ) ) for step in range ( 1 , N // 2 + 1 ) ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r ** 2 * math . pi , r * 2 * math . pi ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d = int ( read ( ) ) <NEWLINE> c = [ int ( i ) for i in read ( ) . split ( ) ] <NEWLINE> s = [ [ int ( i ) for i in read ( ) . split ( ) ] for _ in range ( d ) ] <NEWLINE> t = [ int ( read ( ) ) - 1 for _ in range ( d ) ] <NEWLINE> m = int ( read ( ) ) <NEWLINE> query = [ [ int ( i ) - 1 for i in read ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> score = 0 <NEWLINE> last = [ [ 0 ] * 26 for _ in range ( d ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> score += s [ i ] [ t [ i ] ] <NEWLINE> if i > 0 : <NEWLINE> <INDENT> last [ i ] = last [ i - 1 ] . copy ( ) <NEWLINE> <DEDENT> last [ i ] [ t [ i ] ] = i + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> score -= c [ j ] * ( i + 1 - last [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for di , qi in query : <NEWLINE> <INDENT> hi = t [ di ] <NEWLINE> t [ di ] = qi <NEWLINE> score -= s [ di ] [ hi ] <NEWLINE> score += s [ di ] [ qi ] <NEWLINE> if di == 0 : <NEWLINE> <INDENT> last [ di ] [ hi ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last [ di ] [ hi ] = last [ di - 1 ] [ hi ] <NEWLINE> <DEDENT> score -= c [ hi ] * ( di + 1 - last [ di ] [ hi ] ) <NEWLINE> score += c [ qi ] * ( di + 1 - last [ di ] [ qi ] ) <NEWLINE> last [ di ] [ qi ] = di + 1 <NEWLINE> for i in range ( di + 1 , d ) : <NEWLINE> <INDENT> score += c [ hi ] * ( i + 1 - last [ i ] [ hi ] ) <NEWLINE> if t [ i ] != hi : <NEWLINE> <INDENT> last [ i ] [ hi ] = last [ i - 1 ] [ hi ] <NEWLINE> score -= c [ hi ] * ( i + 1 - last [ i ] [ hi ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( di + 1 , d ) : <NEWLINE> <INDENT> score += c [ qi ] * ( i + 1 - last [ i ] [ qi ] ) <NEWLINE> if t [ i ] != qi : <NEWLINE> <INDENT> last [ i ] [ qi ] = last [ i - 1 ] [ qi ] <NEWLINE> score -= c [ qi ] * ( i + 1 - last [ i ] [ qi ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dict = { } <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s not in dict : dict [ s ] = 1 <NEWLINE> else : dict [ s ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in dict . values ( ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( N ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> a [ i ] = S <NEWLINE> <DEDENT> c = len ( set ( a ) ) <NEWLINE> print ( c ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= 1 : <NEWLINE> <INDENT> P = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = [ ] <NEWLINE> <NL> <DEDENT> c = 200 <NEWLINE> for x in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if x in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = abs ( X - x ) <NEWLINE> if tmp < c : <NEWLINE> <INDENT> c = tmp <NEWLINE> ans = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 10 ** 5 <NEWLINE> a = [ 0 ] + a <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> x = i <NEWLINE> for j in range ( i , 101 ) : <NEWLINE> <INDENT> y = j <NEWLINE> for k in range ( i , j + 1 ) : <NEWLINE> <INDENT> z = k <NEWLINE> total = int ( ( ( x + y ) ** 2 + ( y + z ) ** 2 + ( z + x ) ** 2 ) / 2 ) <NEWLINE> if ( x == y and y == z ) : <NEWLINE> <INDENT> a [ total ] += 1 <NEWLINE> <DEDENT> elif ( x == y or y == z or z == x ) : <NEWLINE> <INDENT> a [ total ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ total ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a [ l ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( a [ ( ( a . index ( S ) + 1 ) ) % 3 ] ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( X , - 2 , - 1 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> a = abs ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( X + 1 , 102 ) : <NEWLINE> <INDENT> if j not in P : <NEWLINE> <INDENT> b = abs ( j - X ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a <= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> s1 = n // ( 26 ** j ) <NEWLINE> s2 = n % ( 26 ** j ) <NEWLINE> if s2 == 0 : <NEWLINE> <INDENT> s1 -= 1 <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> if s1 >= 26 : <NEWLINE> <INDENT> s1 = 25 <NEWLINE> ans . append ( lis [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( lis [ s1 ] ) <NEWLINE> <DEDENT> n -= ( 26 ** j ) * s1 <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> ans . append ( lis [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> T = [ ] <NEWLINE> T = list ( input ( ) ) <NEWLINE> values = np . array ( T ) <NEWLINE> searchval = <STRING> <NEWLINE> ii = np . where ( values == searchval ) [ 0 ] <NEWLINE> <NL> if len ( ii ) > 0 : <NEWLINE> <INDENT> for k in ii : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> if len ( T ) > 1 : <NEWLINE> <INDENT> if T [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k + 1 < len ( T ) : <NEWLINE> <INDENT> if T [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> T [ k ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> newT = <STRING> . join ( map ( str , T ) ) <NEWLINE> print ( newT ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = dict ( ) <NEWLINE> ans = 0 <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if M > A [ i ] [ 1 ] : <NEWLINE> <INDENT> M -= A [ i ] [ 1 ] <NEWLINE> ans += A [ i ] [ 0 ] * A [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ i ] [ 0 ] * M <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> from sys import stdin <NEWLINE> <NL> import time <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> <NL> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> temp = stdin . readline ( ) . split ( ) <NEWLINE> N = int ( temp [ 0 ] ) <NEWLINE> M = int ( temp [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> probs = np . zeros ( 1 ) . astype ( <STRING> ) <NEWLINE> <NL> for i , m in enumerate ( range ( M , N + 2 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == 0 : <NEWLINE> <INDENT> small = np . sum ( np . arange ( m ) ) <NEWLINE> <COMMENT> <NL> large = np . sum ( np . arange ( N + 1 - m , N + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> small = ( small + m - 1 ) . astype ( <STRING> ) <NEWLINE> large = ( large + ( N + 1 - m ) ) . astype ( <STRING> ) <NEWLINE> <DEDENT> probs = probs + ( large - small + 1 ) <NEWLINE> <NL> <DEDENT> print ( int ( probs % ( 1e9 + 7 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> yen = 1000 <NEWLINE> <NL> if N % 1000 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while N > 0 : <NEWLINE> <INDENT> N = N - yen <NEWLINE> <DEDENT> ans = abs ( N ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> al . append ( a ) <NEWLINE> <NL> <DEDENT> al . insert ( 0 , 0 ) <NEWLINE> ans = - 1 <NEWLINE> push = 1 <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> light = al [ push ] <NEWLINE> push = light <NEWLINE> if light == 2 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> D = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> times = [ 0 ] * 24 <NEWLINE> times [ 0 ] = 1 <NEWLINE> for d in D : <NEWLINE> <INDENT> times [ d ] += 1 <NEWLINE> <NL> <DEDENT> if max ( times ) > 2 or times [ 0 ] == 2 or times [ 12 ] == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 2 ** 11 ) : <NEWLINE> <INDENT> positions = [ 0 ] <NEWLINE> for j in range ( 1 , 12 ) : <NEWLINE> <INDENT> if times [ j ] == 2 : <NEWLINE> <INDENT> positions . append ( j ) <NEWLINE> positions . append ( 24 - j ) <NEWLINE> <DEDENT> elif times [ j ] == 1 : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> positions . append ( 24 - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> positions . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if times [ 12 ] == 1 : <NEWLINE> <INDENT> positions . append ( 12 ) <NEWLINE> <DEDENT> positions . sort ( ) <NEWLINE> <COMMENT> <NL> lp = len ( positions ) <NEWLINE> d = float ( <STRING> ) <NEWLINE> for p in range ( lp ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p == lp - 1 : <NEWLINE> <INDENT> diff = 24 - positions [ p ] + positions [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = positions [ p + 1 ] - positions [ p ] <NEWLINE> <DEDENT> d = min ( d , diff if diff != 24 else 0 ) <NEWLINE> <DEDENT> ans = max ( ans , d ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> groups = [ 0 ] * ( N + 1 ) <NEWLINE> group_num_list = [ [ 0 ] ] <NEWLINE> group_num = 1 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if groups [ A ] != 0 and groups [ B ] != 0 : <NEWLINE> <INDENT> if groups [ A ] != groups [ B ] : <NEWLINE> <INDENT> lower = min ( groups [ A ] , groups [ B ] ) <NEWLINE> higher = max ( groups [ A ] , groups [ B ] ) <NEWLINE> for i in group_num_list [ higher ] : <NEWLINE> <INDENT> groups [ i ] = lower <NEWLINE> <DEDENT> tmp = group_num_list [ higher ] <NEWLINE> group_num_list [ lower ] . extend ( tmp ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> elif groups [ A ] != 0 : <NEWLINE> <INDENT> groups [ B ] = groups [ A ] <NEWLINE> group_num_list [ groups [ A ] ] . append ( int ( B ) ) <NEWLINE> <DEDENT> elif groups [ B ] != 0 : <NEWLINE> <INDENT> groups [ A ] = groups [ B ] <NEWLINE> group_num_list [ groups [ B ] ] . append ( int ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> groups [ A ] = group_num <NEWLINE> groups [ B ] = group_num <NEWLINE> group_num_list . append ( [ int ( A ) , int ( B ) ] ) <NEWLINE> group_num += 1 <NEWLINE> <DEDENT> <DEDENT> counter = Counter ( groups ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if len ( group_num_list ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif int ( counter . most_common ( ) [ 0 ] [ 0 ] ) != 0 : <NEWLINE> <INDENT> print ( counter . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( counter . most_common ( ) [ 1 ] [ 1 ] ) <NEWLINE> <DEDENT>
A_V = input ( ) . split ( ) <NEWLINE> A = int ( A_V [ 0 ] ) <NEWLINE> V = int ( A_V [ 1 ] ) <NEWLINE> B_W = input ( ) . split ( ) <NEWLINE> B = int ( B_W [ 0 ] ) <NEWLINE> W = int ( B_W [ 1 ] ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V - W <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif T < abs ( B - A ) / ( V - W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , parent_id = - 1 , depth = 0 , children = [ ] ) : <NEWLINE> <INDENT> self . parent_id = parent_id <NEWLINE> self . depth = depth <NEWLINE> self . children = children <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> node_list = [ None ] * int ( lines [ 0 ] ) <COMMENT> <NEWLINE> child_parent_map = [ None ] * int ( lines [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> for line in lines [ 1 : ] : <NEWLINE> <INDENT> node_id , _ , * children = [ int ( x ) for x in line . strip ( ) . split ( <STRING> ) ] <NEWLINE> node_list [ node_id ] = Node ( children = children ) <NEWLINE> for child in children : <NEWLINE> <INDENT> child_parent_map [ child ] = node_id <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for node_id , node in enumerate ( node_list ) : <NEWLINE> <INDENT> if child_parent_map [ node_id ] is not None : <NEWLINE> <INDENT> node . parent_id = child_parent_map [ node_id ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for node_id , node in enumerate ( node_list ) : <NEWLINE> <INDENT> current_id = node_id <NEWLINE> current_depth = 0 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if node_list [ current_id ] . parent_id == - 1 : <NEWLINE> <INDENT> node . depth = current_depth <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current_id = node_list [ current_id ] . parent_id <NEWLINE> current_depth += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for node_id , node in enumerate ( node_list ) : <NEWLINE> <INDENT> if node . parent_id == - 1 : <NEWLINE> <INDENT> node_type = <STRING> <NEWLINE> <DEDENT> elif len ( node . children ) == 0 : <NEWLINE> <INDENT> node_type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node_type = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( node_id , node . parent_id , node . depth , node_type , node . children ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def factors ( n ) : <NEWLINE> <INDENT> l = int ( math . sqrt ( n ) ) + 1 <NEWLINE> ret = { } <NEWLINE> nf2 = 0 <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> nf2 += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> if nf2 != 0 : <NEWLINE> <INDENT> ret [ 2 ] = nf2 <NEWLINE> <DEDENT> nf3 = 0 <NEWLINE> while n % 3 == 0 : <NEWLINE> <INDENT> nf3 += 1 <NEWLINE> n //= 3 <NEWLINE> <DEDENT> if nf3 != 0 : <NEWLINE> <INDENT> ret [ 3 ] = nf3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> i = 6 <NEWLINE> while i * i <= n + 1 : <NEWLINE> <INDENT> p1 , p2 = i - 1 , i + 1 <NEWLINE> nfp1 = 0 <NEWLINE> while n % p1 == 0 : <NEWLINE> <INDENT> nfp1 += 1 <NEWLINE> n //= p1 <NEWLINE> <DEDENT> if nfp1 != 0 : <NEWLINE> <INDENT> ret [ p1 ] = nfp1 <NEWLINE> <DEDENT> nfp2 = 0 <NEWLINE> while n % p2 == 0 : <NEWLINE> <INDENT> nfp2 += 1 <NEWLINE> n //= p2 <NEWLINE> <DEDENT> if nfp2 != 0 : <NEWLINE> <INDENT> ret [ p2 ] = nfp2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> i += 6 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ret [ n ] = 1 <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def minimum_sum ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> n = int ( math . sqrt ( x ) ) <NEWLINE> while ( n + 1 ) * ( n + 2 ) <= 2 * x : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> return n <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> fs = factors ( N ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for f in fs : <NEWLINE> <INDENT> ans += minimum_sum ( fs [ f ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> ZtoA = <STRING> <NEWLINE> diff = sorted ( list ( set ( ZtoA ) ^ set ( S ) ) ) <NEWLINE> if len ( S ) < 26 : <NEWLINE> <INDENT> print ( S + diff [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S == ZtoA : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 25 ) : <NEWLINE> <INDENT> if S [ i ] < S [ i + 1 ] : <NEWLINE> <INDENT> k = i <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( k + 1 , 26 ) : <NEWLINE> <INDENT> if S [ k ] < S [ i ] : <NEWLINE> <INDENT> a = min ( a , S [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( S [ : k ] + a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> ans += 6 * n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( i , j ) <NEWLINE> ans += 6 * n <NEWLINE> <DEDENT> <DEDENT> print ( ans + sum ( list ( i for i in range ( K + 1 ) ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for _ in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def f ( j ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while j : <NEWLINE> <INDENT> j %= bin ( j ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> X = int ( S , 2 ) <NEWLINE> <NL> <COMMENT> <NL> pcx = S . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> pc1 = X % ( pcx - 1 ) if pcx > 1 else 0 <NEWLINE> pc2 = X % ( pcx + 1 ) <NEWLINE> <NL> for i , y in enumerate ( S ) : <NEWLINE> <INDENT> k = N - 1 - i <NEWLINE> if y == <STRING> : <NEWLINE> <INDENT> print ( f ( ( pc2 + pow ( 2 , k , pcx + 1 ) ) % ( pcx + 1 ) ) + 1 ) <NEWLINE> <DEDENT> elif pcx > 1 : <NEWLINE> <INDENT> print ( f ( ( pc1 - pow ( 2 , k , pcx - 1 ) ) % ( pcx - 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LIM = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > LIM : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> c = 2019 <NEWLINE> tm = 1 <NEWLINE> ti = int ( s [ - 1 ] ) <NEWLINE> co = [ 0 ] * 2019 <NEWLINE> co [ ti ] += 1 <NEWLINE> for i in range ( 1 , l ) : <NEWLINE> <INDENT> tm = tm * 10 % c <NEWLINE> ti += int ( s [ l - i - 1 ] ) * tm <NEWLINE> ti = ti % c <NEWLINE> co [ ti ] += 1 <NEWLINE> <DEDENT> if co [ 0 ] != 0 : <NEWLINE> <INDENT> co [ 0 ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in co ] ) ) <NEWLINE>
<COMMENT> <NL> <NL> s = str ( int ( input ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : exit ( print ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ ( i + 1 ) * 100 , a , b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 10 ** 10 <NEWLINE> if k < L [ - 1 ] [ 0 ] * L [ - 1 ] [ 1 ] : <NEWLINE> <INDENT> if k % L [ - 1 ] [ 0 ] != 0 : <NEWLINE> <INDENT> ans = ( k // L [ - 1 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( k // L [ - 1 ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> li = [ ] <NEWLINE> score , score_zan , cnt = 0 , 0 , 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> score += ( L [ j ] [ 0 ] * L [ j ] [ 1 ] + L [ j ] [ 2 ] ) <NEWLINE> cnt += L [ j ] [ 1 ] <NEWLINE> score_zan = k - score <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( L [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if score > 0 and score_zan <= 0 : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> li . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> if li and score_zan > 0 : <NEWLINE> <INDENT> if score_zan < li [ 0 ] [ 0 ] * li [ 0 ] [ 1 ] : <NEWLINE> <INDENT> ans = min ( ans , cnt + score_zan // li [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = [ ] <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m == - 1 or f == - 1 : <NEWLINE> <INDENT> A . append ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> A . append ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= m + f < 80 : <NEWLINE> <INDENT> A . append ( <STRING> ) <NEWLINE> <DEDENT> elif ( 50 <= m + f < 65 ) or ( ( 30 <= m + f < 50 ) and ( 50 <= r ) ) : <NEWLINE> <INDENT> A . append ( <STRING> ) <NEWLINE> <DEDENT> elif ( 30 <= m + f < 50 ) : <NEWLINE> <INDENT> A . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = i + a [ j ] <NEWLINE> <DEDENT> x = i / ( 4 * m ) <NEWLINE> print ( <STRING> if a [ m - 1 ] >= x else <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> ans += k * v <NEWLINE> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ C ] += d [ B ] <NEWLINE> ans -= B * d [ B ] <NEWLINE> ans += C * d [ B ] <NEWLINE> del d [ B ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> <NL> t = [ 0 ] * n <NEWLINE> dp = [ 0 ] * 2020 <NEWLINE> t [ 0 ] = int ( s [ - 1 ] ) <NEWLINE> dp [ t [ 0 ] ] += 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + int ( s [ - 2 - i ] ) * pow ( 10 , i + 1 , mod ) <NEWLINE> t [ i + 1 ] %= mod <NEWLINE> dp [ t [ i + 1 ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for D in dp [ 1 : ] : <NEWLINE> <INDENT> ans += D * ( D - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans + ( dp [ 0 ] + 1 ) * ( dp [ 0 ] ) // 2 ) <NEWLINE> <NL> <NL>
def resolve ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> def popcount ( n ) : <NEWLINE> <INDENT> c = format ( n , <STRING> ) . count ( <STRING> ) <NEWLINE> if c != 0 : <NEWLINE> <INDENT> return n % c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n = popcount ( n ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> cnt = x . count ( <STRING> ) <NEWLINE> x10 = int ( x , 2 ) <NEWLINE> ans = [ ] <NEWLINE> a = x10 % ( cnt + 1 ) <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = x10 % ( cnt - 1 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> and cnt == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> elif x [ i ] == <STRING> : <NEWLINE> <INDENT> cal = ( b - pow ( 2 , n - 1 - i , cnt - 1 ) ) % ( cnt - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cal = ( a + pow ( 2 , n - 1 - i , cnt + 1 ) ) % ( cnt + 1 ) <NEWLINE> <DEDENT> print ( f ( cal ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> visited [ 1 ] = 0 <NEWLINE> will = [ ] <NEWLINE> root = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> will . append ( 1 ) <NEWLINE> <NL> while will : <NEWLINE> <INDENT> visit = will . pop ( 0 ) <NEWLINE> for i in root [ visit ] : <NEWLINE> <INDENT> if visited [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> will . append ( i ) <NEWLINE> visited [ i ] = visit <NEWLINE> <NL> <DEDENT> <DEDENT> if visited [ 1 : ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , len ( visited ) ) : <NEWLINE> <INDENT> print ( visited [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def cumsum ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for v in l : <NEWLINE> <INDENT> s += v <NEWLINE> yield s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> a = [ 0 ] + list ( cumsum ( A ) ) <NEWLINE> b = [ 0 ] + list ( cumsum ( B ) ) <NEWLINE> ans = 0 <NEWLINE> n = N + 1 <NEWLINE> m = M <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( m , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= K : <NEWLINE> <INDENT> m = j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 1 ] <NEWLINE> flag = [ 0 , 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> x = A [ 1 ] <NEWLINE> while flag [ x ] == 0 : <NEWLINE> <INDENT> t . append ( x ) <NEWLINE> flag [ x ] = 1 <NEWLINE> x = A [ x ] <NEWLINE> <NL> <DEDENT> if k <= len ( t ) - 1 : <NEWLINE> <INDENT> print ( t [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = t [ t . index ( x ) : ] <NEWLINE> k = k - ( len ( t ) - 1 ) <NEWLINE> k %= len ( l ) <NEWLINE> print ( l [ k - 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> c_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_score = - ( 1 << 64 ) <NEWLINE> cycles = [ ] <NEWLINE> cycled = [ False ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cycled [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cycle = [ i ] <NEWLINE> cycled [ i ] = True <NEWLINE> while p_list [ cycle [ - 1 ] ] != cycle [ 0 ] : <NEWLINE> <INDENT> cycle . append ( p_list [ cycle [ - 1 ] ] ) <NEWLINE> cycled [ cycle [ - 1 ] ] = True <NEWLINE> <NL> <DEDENT> cycles . append ( cycle ) <NEWLINE> <NL> <DEDENT> for cycle in cycles : <NEWLINE> <INDENT> cycle_len = len ( cycle ) <NEWLINE> <NL> accum = [ 0 ] <NEWLINE> for i in range ( cycle_len * 2 ) : <NEWLINE> <INDENT> accum . append ( accum [ - 1 ] + c_list [ cycle [ i % cycle_len ] ] ) <NEWLINE> <NL> <DEDENT> cycle_score = accum [ cycle_len ] <NEWLINE> <NL> max_series_sums = [ max ( [ accum [ i + length ] - accum [ i ] <NEWLINE> <INDENT> for i in range ( cycle_len ) ] ) <NEWLINE> for length in range ( cycle_len + 1 ) ] <NEWLINE> <NL> <DEDENT> if cycle_len >= k : <NEWLINE> <INDENT> score = max ( max_series_sums [ 1 : k + 1 ] ) <NEWLINE> <DEDENT> elif cycle_score <= 0 : <NEWLINE> <INDENT> score = max ( max_series_sums [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_cycle_num , cycle_rem = divmod ( k , cycle_len ) <NEWLINE> score = max ( cycle_score * ( max_cycle_num - 1 ) + max ( max_series_sums ) , <NEWLINE> <INDENT> cycle_score * max_cycle_num + max ( max_series_sums [ : cycle_rem + 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_score = max ( max_score , score ) <NEWLINE> <NL> <DEDENT> print ( max_score ) <NEWLINE>
N = input ( ) <NEWLINE> if ( int ( N ) >= 100 ) : <NEWLINE> <INDENT> s = int ( N [ len ( N ) - 3 ] ) * 100 + int ( N [ len ( N ) - 2 ] ) * 10 + int ( N [ len ( N ) - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = int ( N ) <NEWLINE> <DEDENT> if ( s == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import time <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> listSum = [ 1 , 3 , 6 ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> sumGCD = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> sumGCD += gcd ( a , b , c ) * listSum [ len ( set ( [ a , b , c ] ) ) - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sumGCD ) <NEWLINE> <NL> <NL> <DEDENT> def gcd ( a , b , c ) : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> s = time . time ( ) <NEWLINE> main ( ) <NEWLINE> <COMMENT> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> flag = False <NEWLINE> answer = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer *= a <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> if ab == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> ans [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 0 <NEWLINE> ANS = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ANS += max ( 0 , MAX - A [ i ] ) <NEWLINE> MAX = max ( MAX , A [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ANS ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> dp [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , len ( dp ) , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( N % K , - N % K ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> M = N <NEWLINE> result = [ ] <NEWLINE> i = 2 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> N //= i <NEWLINE> result . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if N > 1 : <NEWLINE> <INDENT> result . append ( N ) <NEWLINE> <DEDENT> print ( str ( M ) + <STRING> + <STRING> . join ( map ( str , result ) ) ) <NEWLINE>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> x = 7 <NEWLINE> for ans in range ( 1 , K * 2 ) : <NEWLINE> <NL> <INDENT> if x % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> for j in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ i - 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> u = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> u *= i <NEWLINE> if u > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( u ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> n = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> n . append ( t ) <NEWLINE> <DEDENT> n = np . array ( n ) <NEWLINE> dl = [ 0 ] <NEWLINE> s = np . ceil ( n / 10 ) * 10 <NEWLINE> <NL> if max ( n % 10 ) == 0 : <NEWLINE> <INDENT> print ( int ( np . sum ( s ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m = [ e for e in n % 10 if e not in dl ] <NEWLINE> print ( int ( np . sum ( s ) - ( 10 - min ( m ) ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n <= k : <NEWLINE> <INDENT> print ( min ( n , k - n ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if n > k : <NEWLINE> <INDENT> n = n % k <NEWLINE> print ( min ( n , k - n ) ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> data_dict = { } <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 3 * k * k - 3 * k + 1 <NEWLINE> for x in range ( 2 , k - 1 ) : <NEWLINE> <INDENT> for y in range ( x + 1 , k ) : <NEWLINE> <INDENT> key = str ( x ) + <STRING> + str ( y ) <NEWLINE> if key in data_dict : <NEWLINE> <INDENT> c = data_dict [ key ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = gcd ( x , y ) <NEWLINE> data_dict [ key ] = c <NEWLINE> <DEDENT> for z in range ( y + 1 , k + 1 ) : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> ans += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = str ( c ) + <STRING> + str ( z ) <NEWLINE> if key in data_dict : <NEWLINE> <INDENT> ans += data_dict [ key ] * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = gcd ( c , z ) <NEWLINE> data_dict [ key ] = d <NEWLINE> ans += d * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in range ( 2 , k ) : <NEWLINE> <INDENT> for y in range ( x + 1 , k + 1 ) : <NEWLINE> <INDENT> key = str ( x ) + <STRING> + str ( y ) <NEWLINE> if key in data_dict : <NEWLINE> <INDENT> ans += data_dict [ key ] * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = gcd ( x , y ) <NEWLINE> data_dict [ key ] = d <NEWLINE> ans += d * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> ans += x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = [ int ( xn ) for xn in input ( ) . split ( ) ] <NEWLINE> x_sorted = sorted ( x ) <NEWLINE> idx_median = n // 2 <NEWLINE> median_low = x_sorted [ idx_median - 1 ] <NEWLINE> median_high = x_sorted [ idx_median ] <NEWLINE> for xn in x : <NEWLINE> <INDENT> print ( median_high if xn <= median_low else median_low ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> while d <= X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> d += L [ i ] <NEWLINE> i += 1 <NEWLINE> if i == N : <NEWLINE> <INDENT> if d <= X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ni = np . array ( [ i for i in range ( n ) ] ) <NEWLINE> <NL> ap = a + ni <NEWLINE> an = ( a - ni ) * - 1 <NEWLINE> <NL> cp = Counter ( ap ) <NEWLINE> cn = Counter ( an ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in cp . keys ( ) : <NEWLINE> <INDENT> ans += cp [ i ] * cn [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = { } <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> i , j , k = str ( i ) , str ( j ) , str ( k ) <NEWLINE> x [ i + j + k ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i , j , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> key = str ( i - 1 ) + str ( j - 1 ) + str ( k - 1 ) <NEWLINE> x [ key ] = x [ key ] + int ( l ) <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> i , j , k = str ( i ) , str ( j ) , str ( k ) <NEWLINE> if k != <STRING> : <NEWLINE> <INDENT> print ( <STRING> + str ( x [ i + j + k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( x [ i + j + k ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if int ( i ) + 1 < 4 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P2 = P [ K : ] <NEWLINE> <NL> max_sum = 0 <NEWLINE> sum_ = sum ( P [ : K ] ) <NEWLINE> <NL> for p , q in zip ( P , P2 ) : <NEWLINE> <INDENT> max_sum = max ( max_sum , sum_ ) <NEWLINE> sum_ += q - p <NEWLINE> <NL> <DEDENT> max_sum = max ( max_sum , sum_ ) <NEWLINE> <NL> res = ( max_sum + K ) / 2 <NEWLINE> print ( res ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ ] <NEWLINE> a = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> add = 0 <NEWLINE> check = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if check and s [ i ] == <STRING> : <NEWLINE> <INDENT> add += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> check = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> a [ i ] += add <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( a [ c - 1 ] - a [ b - 1 ] ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> i_ins = [ ] <NEWLINE> for x in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i // x != 0 and i % x == 0 : <NEWLINE> <INDENT> i_ins . append ( x ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> i_j_ins = [ ] <NEWLINE> for y in i_ins : <NEWLINE> <INDENT> if j // y != 0 and j % y == 0 : <NEWLINE> <INDENT> i_j_ins . append ( y ) <NEWLINE> <DEDENT> <DEDENT> if i_j_ins [ - 1 ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> count = count + i_j_ins [ - 1 ] * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> i_j_k_ins = [ ] <NEWLINE> for z in reversed ( i_j_ins ) : <NEWLINE> <INDENT> if k // z != 0 and k % z == 0 : <NEWLINE> <INDENT> i_j_k_ins . append ( z ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> count = count + i_j_k_ins [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> sum_rgb = r * g * b <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> sum_rgb -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum_rgb ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input_num = input ( ) <NEWLINE> sum_num = 0 <NEWLINE> <NL> for i in range ( len ( input_num ) ) : <NEWLINE> <INDENT> chushutsu = int ( input_num [ i ] ) <NEWLINE> sum_num += chushutsu <NEWLINE> <NL> <DEDENT> if sum_num % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> print ( [ 360 * n // x for n in range ( 1 , 500 ) if 360 * n % x == 0 ] [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MX = 100005 <NEWLINE> cnt = [ 0 ] * MX <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> tot = 0 <NEWLINE> for i in range ( 1 , MX ) : <NEWLINE> <INDENT> tot += cnt [ i ] * i <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tot += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( tot ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> set_a = set ( a ) <NEWLINE> if 0 in set_a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for elem in a : <NEWLINE> <INDENT> res *= elem <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> print ( line . rstrip ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n , q = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> sets = [ set ( [ i ] ) for i in range ( n ) ] <NEWLINE> <NL> def unite ( Sx , Sy ) : <NEWLINE> <INDENT> return Sx | Sy <NEWLINE> <NL> <DEDENT> def search ( x ) : <NEWLINE> <INDENT> global sets <NEWLINE> flag = False <NEWLINE> for i in range ( len ( sets ) ) : <NEWLINE> <INDENT> if x in sets [ i ] : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> global sets <NEWLINE> flag = 0 <NEWLINE> for set in sets : <NEWLINE> <INDENT> if x in set : <NEWLINE> <INDENT> if y in set : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> query , x , y = input ( ) . split ( <STRING> ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> if query == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> i_x = search ( x ) <NEWLINE> i_y = search ( y ) <NEWLINE> if i_x != None and i_y != None and i_x != i_y : <NEWLINE> <INDENT> sets [ i_x ] = unite ( sets [ i_x ] , sets [ i_y ] ) <NEWLINE> del sets [ i_y ] <NEWLINE> <DEDENT> <DEDENT> elif query == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( same ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> f [ i ] = f [ i ] + 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( f [ i ] ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> while b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> if k < 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from __future__ import division , print_function <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> INFTY = 1 << 30 <NEWLINE> a = [ None ] * 2000001 <NEWLINE> h = 0 <NEWLINE> ret = deque ( [ ] ) <NEWLINE> <NL> def maxHeapify ( i ) : <NEWLINE> <INDENT> global a , h <NEWLINE> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> if l <= h and a [ l ] > a [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= h and a [ r ] > a [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> a [ i ] , a [ largest ] = a [ largest ] , a [ i ] <NEWLINE> maxHeapify ( largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def extract ( ) : <NEWLINE> <INDENT> global a , h <NEWLINE> if h < 1 : <NEWLINE> <INDENT> return - INFTY <NEWLINE> <DEDENT> maxv = a [ 1 ] <NEWLINE> a [ 1 ] = a [ h ] <NEWLINE> h -= 1 <NEWLINE> maxHeapify ( 1 ) <NEWLINE> return maxv <NEWLINE> <NL> <DEDENT> def increaseKey ( i , k ) : <NEWLINE> <INDENT> global a <NEWLINE> if k < a [ i ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> a [ i ] = k <NEWLINE> while i > 1 and a [ i // 2 ] < a [ i ] : <NEWLINE> <INDENT> a [ i ] , a [ i // 2 ] = a [ i // 2 ] , a [ i ] <NEWLINE> i = i // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( k ) : <NEWLINE> <INDENT> global a , h <NEWLINE> h += 1 <NEWLINE> a [ h ] = - INFTY <NEWLINE> increaseKey ( h , k ) <NEWLINE> <NL> <DEDENT> for com in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( int ( com [ 7 : ] ) ) <NEWLINE> <DEDENT> elif com [ 1 ] == <STRING> : <NEWLINE> <INDENT> ret . append ( extract ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in list ( ret ) ] ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( n - k ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ch += 1 <NEWLINE> cw += 1 <NEWLINE> dh += 1 <NEWLINE> dw += 1 <NEWLINE> <NL> <NL> s = [ <STRING> * ( w + 4 ) ] <NEWLINE> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) [ : - 1 ] + <STRING> ) <NEWLINE> <DEDENT> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> <NL> <NL> ans = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for i in range ( h + 4 ) : <NEWLINE> <INDENT> for j in range ( w + 4 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans [ ch ] [ cw ] = 0 <NEWLINE> <NL> move = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> move2 = [ ( - 2 , - 2 ) , ( - 2 , - 1 ) , ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , 2 ) , ( - 1 , - 2 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , ( 0 , - 2 ) , ( 0 , - 1 ) , ( 0 , 0 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 1 , - 2 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 1 , 2 ) , ( 2 , - 2 ) , ( 2 , - 1 ) , ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , 2 ) ] <NEWLINE> <NL> not_yet = deque ( [ ( ch , cw ) ] ) <NEWLINE> one_time = deque ( [ ] ) <NEWLINE> <NL> while len ( not_yet ) > 0 : <NEWLINE> <INDENT> x , y = not_yet . popleft ( ) <NEWLINE> one_time . append ( ( x , y ) ) <NEWLINE> for ( p , q ) in move : <NEWLINE> <INDENT> v1 , v2 = x + p , y + q <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <NEWLINE> <INDENT> not_yet . append ( ( v1 , v2 ) ) <NEWLINE> ans [ v1 ] [ v2 ] = ans [ x ] [ y ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( not_yet ) == 0 : <NEWLINE> <INDENT> while len ( one_time ) > 0 : <NEWLINE> <INDENT> x2 , y2 = one_time . popleft ( ) <NEWLINE> for ( v1 , v2 ) in move2 : <NEWLINE> <INDENT> i , j = x2 + v1 , y2 + v2 <NEWLINE> if ans [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> not_yet . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if ( n <= N ) : <NEWLINE> <INDENT> count [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> sg = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> sg . append ( s ) <NEWLINE> <DEDENT> sgc = collections . Counter ( sg ) <NEWLINE> print ( len ( sgc ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> gifts = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> gifts . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( gifts ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> now = 0 <NEWLINE> l [ now ] = 1 <NEWLINE> count = 0 <NEWLINE> loop = [ 0 ] <NEWLINE> <NL> while count < K : <NEWLINE> <INDENT> count += 1 <NEWLINE> now = A [ now ] - 1 <NEWLINE> loop . append ( now ) <NEWLINE> if l [ now ] == 1 : <NEWLINE> <INDENT> loop = loop [ loop . index ( now ) : - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ now ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = loop [ ( K - count ) % len ( loop ) ] <NEWLINE> print ( ans + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for a in li_a : <NEWLINE> <INDENT> dic [ a ] = dic . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( dic . get ( i , 0 ) ) <NEWLINE> <DEDENT>
class unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , a ) : <NEWLINE> <INDENT> if self . parents [ a ] < 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> self . parents [ a ] = self . find ( self . parents [ a ] ) <NEWLINE> return self . parents [ a ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self ) : <NEWLINE> <INDENT> return len ( list ( filter ( lambda x : x < 0 , self . parents ) ) ) - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = unionfind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uf . union ( tmp [ 0 ] - 1 , tmp [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . size ( ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = deque ( ) <NEWLINE> G = deque ( ) <NEWLINE> B = deque ( ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> rgb = len ( R ) * len ( G ) * len ( B ) <NEWLINE> import bisect <NEWLINE> <COMMENT> <NL> R_one = [ 0 for _ in range ( N + 3 ) ] <NEWLINE> G_one = [ 0 for _ in range ( N + 3 ) ] <NEWLINE> B_one = [ 0 for _ in range ( N + 3 ) ] <NEWLINE> <NL> for r in R : <NEWLINE> <INDENT> R_one [ r ] = 1 <NEWLINE> <DEDENT> for g in G : <NEWLINE> <INDENT> G_one [ g ] = 1 <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> B_one [ b ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if i in R : <NEWLINE> <INDENT> lest1 = G_one <NEWLINE> lest2 = B_one <NEWLINE> <DEDENT> elif i in G : <NEWLINE> <INDENT> lest1 = B_one <NEWLINE> lest2 = R_one <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lest1 = R_one <NEWLINE> lest2 = G_one <NEWLINE> <DEDENT> max_j_width = int ( ( N - 1 - i ) / 2 ) + 1 <NEWLINE> for j in range ( 1 , max_j_width + 1 ) : <NEWLINE> <INDENT> if lest1 [ i + j ] == lest2 [ i + 2 * j ] == 1 : <NEWLINE> <INDENT> rgb -= 1 <NEWLINE> <DEDENT> elif lest2 [ i + j ] == lest1 [ i + 2 * j ] == 1 : <NEWLINE> <INDENT> rgb -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( rgb ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> A , B , N = MAP ( ) <NEWLINE> <NL> x = N <NEWLINE> <NL> ans1 = ( A * ( B - 1 ) // B ) - A * ( ( B - 1 ) // B ) <NEWLINE> ans2 = ( ( A * N ) // B ) - A * ( N // B ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if N < B : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( ans1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> exit ( ) <NEWLINE> <COMMENT> <NL> memo = [ 0 ] * ( B + 1 ) <NEWLINE> ma = 0 <NEWLINE> for x in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> memo [ x ] = int ( ( A * ( x ) / B ) ) - A * ( ( x ) // B ) <NEWLINE> ma = max ( memo [ x ] , ma ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( memo ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> if N >= B : <NEWLINE> <INDENT> ans = ma <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = memo [ N ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . sort ( np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> max_num = a [ - 1 ] + 1 <NEWLINE> dp = np . array ( [ 0 ] * ( max_num ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif np . all ( a == a [ 0 ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif np . count_nonzero ( a == 1 ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> for j in np . arange ( i , max_num , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( np . count_nonzero ( dp [ a ] == 1 ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ( i + 1 ) + L [ i ] for i in range ( N ) ] <NEWLINE> s = Counter ( s ) <NEWLINE> d = [ ( i + 1 ) - L [ i ] for i in range ( N ) ] <NEWLINE> d = Counter ( d ) <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> ans += s [ i ] * d [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> way = [ [ ] for i in range ( n ) ] <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> way [ a - 1 ] . append ( b - 1 ) <NEWLINE> way [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> high = True <NEWLINE> for j in way [ i ] : <NEWLINE> <INDENT> if H [ i ] <= H [ j ] : <NEWLINE> <INDENT> high = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if high : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> X = [ int ( T ) for T in input ( ) . split ( ) ] <NEWLINE> DP = [ [ [ 0 ] * ( N + 1 ) for TS in range ( 0 , 50 * N + 1 ) ] for TI in range ( 0 , N + 1 ) ] <NEWLINE> DP [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for TI in range ( 0 , N ) : <NEWLINE> <INDENT> for TS in range ( 0 , 50 * N + 1 ) : <NEWLINE> <INDENT> for TK in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if DP [ TI ] [ TS ] [ TK ] != 0 : <NEWLINE> <INDENT> DP [ TI + 1 ] [ TS ] [ TK ] += DP [ TI ] [ TS ] [ TK ] <NEWLINE> DP [ TI + 1 ] [ TS + X [ TI ] ] [ TK + 1 ] += DP [ TI ] [ TS ] [ TK ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( DP [ N ] [ A * TA ] [ TA ] for TA in range ( 1 , N + 1 ) ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all = 0 <NEWLINE> <NL> c = collections . Counter ( num_list ) <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> all += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> print ( all - c [ num_list [ k ] ] + 1 ) <NEWLINE> <DEDENT>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> <NL> first_harf = Y [ : int ( N / 2 ) ] <NEWLINE> second_harf = Y [ int ( N / 2 ) : ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] <= first_harf [ - 1 ] : <NEWLINE> <INDENT> print ( second_harf [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( first_harf [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - 1 < N : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * N / B ) ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= ( B - 1 ) : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> print ( ( A * x // B ) - A * ( x // B ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = dict ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> D [ i ] = h [ i - 1 ] <NEWLINE> <DEDENT> L = [ 1 for i in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if D [ a ] > D [ b ] : <NEWLINE> <INDENT> L [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif D [ a ] == D [ b ] : <NEWLINE> <INDENT> L [ a - 1 ] = 0 <NEWLINE> L [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for e in L : <NEWLINE> <INDENT> ans += e <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> paths = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> paths [ i + 1 ] = A_i [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> state = 1 <NEWLINE> steps = 0 <NEWLINE> flag = False <NEWLINE> known_states = { } <NEWLINE> <NL> while steps < K : <NEWLINE> <INDENT> known_states [ state ] = steps <COMMENT> <NEWLINE> <NL> state = paths [ state ] <COMMENT> <NEWLINE> steps += 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <NL> if state in known_states and not flag : <COMMENT> <NEWLINE> <INDENT> loop_steps = steps - known_states [ state ] <NEWLINE> K = ( steps - loop_steps ) + ( K - ( steps - loop_steps ) ) % loop_steps <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> state = 1 <NEWLINE> steps = 0 <NEWLINE> <COMMENT> <NL> flag = True <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( state ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nets = [ 0 ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> nets [ a - 1 ] = max ( nets [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> nets [ b - 1 ] = max ( nets [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( h [ i ] > nets [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> room = queue . Queue ( ) <NEWLINE> room . put ( l [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += room . get ( ) <NEWLINE> room . put ( l [ i ] ) <NEWLINE> room . put ( l [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - h * 3600 ) // 60 <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : a += [ a [ - 1 ] + 1 ] <NEWLINE> else : a += [ a [ - 1 ] ] <NEWLINE> <DEDENT> w = s . count ( <STRING> ) <NEWLINE> print ( min ( i - a [ i ] * 2 + w for i in range ( n + 1 ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = [ 1 ] <NEWLINE> D = { 1 } <NEWLINE> i = 0 <NEWLINE> C1 = [ ] <NEWLINE> C2 = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if A [ i ] not in D : <NEWLINE> <INDENT> C . append ( A [ i ] ) <NEWLINE> D . add ( A [ i ] ) <NEWLINE> i = A [ i ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = C . index ( A [ i ] ) <NEWLINE> C1 = C [ : index ] <NEWLINE> C2 = C [ index : ] <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if K <= len ( C1 ) - 1 : <NEWLINE> <INDENT> print ( C1 [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( K - len ( C1 ) ) % len ( C2 ) <NEWLINE> print ( C2 [ r ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ - 1 , 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> P . sort ( reverse = True ) <NEWLINE> <NL> if k > len ( P ) : <NEWLINE> <INDENT> k = len ( P ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( P [ c : ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> N = int ( stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Q = int ( stdin . readline ( ) ) <NEWLINE> D = dict ( ) <NEWLINE> S = set ( A ) <NEWLINE> sum = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for y in range ( 0 , N ) : <NEWLINE> <INDENT> sum += A [ y ] <NEWLINE> if y > 0 and A [ y ] != A [ y - 1 ] : <NEWLINE> <INDENT> D [ A [ y - 1 ] ] = count <NEWLINE> count = 1 <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if y == N - 1 : <NEWLINE> <INDENT> D [ A [ y ] ] = count <NEWLINE> <NL> <DEDENT> <DEDENT> for u in range ( 0 , Q ) : <NEWLINE> <INDENT> U = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> if U [ 0 ] in D : <NEWLINE> <INDENT> sum += ( D [ U [ 0 ] ] ) * ( U [ 1 ] - U [ 0 ] ) <NEWLINE> if U [ 1 ] in D : <NEWLINE> <INDENT> D [ U [ 1 ] ] += D [ U [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ U [ 1 ] ] = D [ U [ 0 ] ] <NEWLINE> <DEDENT> D [ U [ 0 ] ] = 0 <NEWLINE> <NL> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> ans = sum ( arr ) <NEWLINE> <NL> hashmap = { } <NEWLINE> for val in arr : <NEWLINE> <INDENT> if val in hashmap : <NEWLINE> <INDENT> hashmap [ val ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hashmap [ val ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while q > 0 : <NEWLINE> <NL> <INDENT> [ x , y ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if x in hashmap : <NEWLINE> <INDENT> if y in hashmap : <NEWLINE> <INDENT> hashmap [ y ] += hashmap [ x ] <NEWLINE> ans -= hashmap [ x ] * x <NEWLINE> ans += y * hashmap [ x ] <NEWLINE> del hashmap [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = hashmap [ x ] * x <NEWLINE> ans -= diff <NEWLINE> hashmap [ y ] = hashmap [ x ] <NEWLINE> del hashmap [ x ] <NEWLINE> add = hashmap [ y ] * y <NEWLINE> ans += add <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> q -= 1 <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> C = [ 0 ] * N <NEWLINE> c = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . append ( A [ 0 ] ) <NEWLINE> R . append ( A [ 1 ] ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> C [ i ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ i ] = c <NEWLINE> <DEDENT> <DEDENT> C [ N - 1 ] = c <NEWLINE> S += <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> if S [ R [ i ] - 1 ] == <STRING> and S [ R [ i ] ] == <STRING> : <NEWLINE> <INDENT> p = C [ R [ i ] - 1 ] - C [ L [ i ] - 1 ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = C [ R [ i ] - 1 ] - C [ L [ i ] - 1 ] <NEWLINE> <DEDENT> if S [ L [ i ] - 1 ] == <STRING> and S [ L [ i ] ] == <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( min ( a ) , end = <STRING> ) <NEWLINE> print ( max ( a ) , end = <STRING> ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> mod_count = [ 0 ] * 2019 <NEWLINE> mod_count [ 0 ] = 1 <NEWLINE> ssum = 0 <NEWLINE> for i , c in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> ssum = ( ssum + int ( c ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> mod_count [ ssum ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ m * ( m - 1 ) for m in mod_count ] ) // 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> nums = [ i for i in range ( n + 1 ) ] <NEWLINE> judge = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> price = i * 10000 + j * 5000 + ( n - i - j ) * 1000 <NEWLINE> if y == price : <NEWLINE> <INDENT> judge += 1 <NEWLINE> print ( str ( i ) + <STRING> + str ( j ) + <STRING> + str ( n - i - j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if judge == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if judge == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b0 = [ ] <NEWLINE> b1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b0 . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b1 . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 != 0 : <NEWLINE> <INDENT> b0 = list ( reversed ( b0 ) ) <NEWLINE> b = b0 + b1 <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b1 = list ( reversed ( b1 ) ) <NEWLINE> b = b1 + b0 <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h [ A - 1 ] = max ( H [ B - 1 ] , h [ A - 1 ] ) <NEWLINE> h [ B - 1 ] = max ( H [ A - 1 ] , h [ B - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > h [ i ] or h [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> counter = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i , int ( ( N - 1 ) / i ) ) + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from math import ceil as C , floor as F , sqrt <NEWLINE> from collections import defaultdict as D , Counter as CNT <NEWLINE> from functools import reduce as R <NEWLINE> <NL> ALP = <STRING> <NEWLINE> alp = <STRING> <NEWLINE> def _X ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> def _S ( ss ) : return tuple ( ss ) if len ( ss ) > 1 else ss [ 0 ] <NEWLINE> def S ( ) : return _S ( _X ( ) ) <NEWLINE> def Ss ( ) : return list ( S ( ) ) <NEWLINE> def _I ( ss ) : return tuple ( [ int ( s ) for s in ss ] ) if isinstance ( ss , tuple ) else int ( ss ) <NEWLINE> def I ( ) : return _I ( S ( ) ) <NEWLINE> def _Is ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Is ( ) : return _Is ( I ( ) ) <NEWLINE> <NL> a , b , c , k = Is ( ) <NEWLINE> <NL> a = min ( a , k ) <NEWLINE> k -= a <NEWLINE> <NL> b = min ( b , k ) <NEWLINE> k -= b <NEWLINE> <NL> c = min ( c , k ) <NEWLINE> k -= c <NEWLINE> <NL> print ( a - c ) <NEWLINE>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xLongLeft = x - r <NEWLINE> xLongRight = x + r <NEWLINE> <NL> yLongTop = y + r <NEWLINE> yLongBot = y - r <NEWLINE> <NL> if ( ( xLongLeft >= 0 and yLongBot >= 0 ) and ( xLongRight <= w and yLongTop <= h ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = <STRING> . format ( r ** 2 * pi ) <NEWLINE> l = <STRING> . format ( r * 2 * pi ) <NEWLINE> <NL> print ( s , l ) <NEWLINE>
while ( 1 ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> H = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> HD = [ 0 ] * 1500 ** 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> tmp += H [ j ] <NEWLINE> HD [ tmp ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> W = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , M ) : <NEWLINE> <INDENT> tmp += W [ j ] <NEWLINE> ans += HD [ tmp ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
from collections import Counter <NEWLINE> import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> MX = 10 ** 6 <NEWLINE> P = [ 0 ] * ( MX + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if P [ a ] == 0 : <NEWLINE> <INDENT> for i in range ( MX + 1 ) : <NEWLINE> <INDENT> x = a * i <NEWLINE> if x > MX : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P [ x ] = 1 <NEWLINE> <DEDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ x , y , z ] <NEWLINE> list . sort ( ) <NEWLINE> <NL> print ( list [ 0 ] , list [ 1 ] , list [ 2 ] , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def abc166_e ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i , x in enumerate ( A , 1 ) : <NEWLINE> <INDENT> ans += d [ i - x ] <NEWLINE> d [ x + i ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> abc166_e ( ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> l = [ 0 ] * len ( S ) <NEWLINE> q = 1 <NEWLINE> l [ 0 ] = int ( S [ len ( S ) - 1 ] ) <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> t = int ( S [ len ( S ) - i - 1 ] ) <NEWLINE> q = q * 10 % 2019 <NEWLINE> l [ i ] = ( t * q + l [ i - 1 ] % 2019 ) % 2019 <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> m = [ 0 ] * len ( S ) <NEWLINE> k = 1 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if l [ i ] != l [ i + 1 ] : <NEWLINE> <INDENT> m [ i ] = int ( k * ( k - 1 ) / 2 ) <NEWLINE> k = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ i ] = 0 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> if k != 1 : <NEWLINE> <INDENT> m [ len ( S ) - 1 ] = int ( k * ( k - 1 ) / 2 ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( m ) + a ) <NEWLINE>
import math <NEWLINE> <NL> my_value = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( pow ( my_value , 2 ) * math . pi , 2 * math . pi * my_value ) ) <NEWLINE>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_A . sort ( reverse = True ) <NEWLINE> list_B . sort ( reverse = True ) <NEWLINE> list_C . sort ( reverse = True ) <NEWLINE> <NL> list_N = list_A [ : x ] + list_B [ : y ] + list_C [ : min ( c , x + y ) ] <NEWLINE> list_N . sort ( reverse = True ) <NEWLINE> print ( sum ( list_N [ : x + y ] ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( len ( np . unique ( S ) ) ) <NEWLINE>
<COMMENT> <NL> from bisect import bisect_left <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n = int ( args [ 0 ] ) <NEWLINE> A = list ( map ( int , args [ 1 ] . split ( ) ) ) <NEWLINE> <NL> ret = 0 <NEWLINE> X = defaultdict ( list ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> X [ a + i ] . append ( i ) <NEWLINE> <NL> <DEDENT> for j , a in enumerate ( A ) : <NEWLINE> <INDENT> if 0 <= j - a : <NEWLINE> <INDENT> ret += bisect_left ( X [ j - a ] , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> <NL> state = [ - 1 for i in range ( 100010 ) ] <NEWLINE> <NL> def step_state ( n , broken ) : <NEWLINE> <INDENT> if state [ n ] != - 1 : <NEWLINE> <INDENT> return state [ n ] <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> state [ 0 ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> if broken [ 1 ] : <NEWLINE> <INDENT> state [ 1 ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state [ 1 ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if broken [ n - 1 ] and broken [ n - 2 ] : <NEWLINE> <INDENT> state [ n ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> elif broken [ n - 1 ] : <NEWLINE> <INDENT> state [ n ] = step_state ( n - 2 , broken ) % MOD <NEWLINE> return state [ n ] <NEWLINE> <DEDENT> elif broken [ n - 2 ] : <NEWLINE> <INDENT> state [ n ] = step_state ( n - 1 , broken ) % MOD <NEWLINE> return state [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state [ n ] = ( step_state ( n - 1 , broken ) + step_state ( n - 2 , broken ) ) % MOD <NEWLINE> return state [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for i in range ( m ) ] ) <NEWLINE> broken = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> broken [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> answer = step_state ( n , broken ) <NEWLINE> <NL> print ( answer ) <NEWLINE> <DEDENT>
import math <NEWLINE> result = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( a , b ) == 1 : <NEWLINE> <INDENT> result += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b_i = int ( b [ : - 3 ] ) <NEWLINE> b_f = int ( b [ - 2 : ] ) <NEWLINE> if b_f == 0 : <NEWLINE> <INDENT> print ( a * b_i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b_m = a * b_f <NEWLINE> if b_m < 100 : <NEWLINE> <INDENT> print ( a * b_i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( a * b_i + int ( str ( b_m ) [ : - 2 ] ) ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> C = [ [ 0 for _ in range ( l ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> C [ i ] [ j ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> for row in C : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , row ) ) ) ) <NEWLINE> <NL> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> anss = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for x in range ( 1 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + x * z + y * z <NEWLINE> if tmp <= N : <NEWLINE> <INDENT> anss [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( anss [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> multi_sum = 1 <NEWLINE> LIMIT = 1000000000000000000 <NEWLINE> <NL> if 0 not in a_list : <NEWLINE> <INDENT> for a_i in a_list : <NEWLINE> <INDENT> multi_sum *= a_i <NEWLINE> if multi_sum > LIMIT : <NEWLINE> <INDENT> multi_sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> multi_sum = 0 <NEWLINE> <NL> <DEDENT> print ( multi_sum ) <NEWLINE> <NL>
import numpy as np <NEWLINE> <NL> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p [ int ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if k - ( q - p [ i ] ) > 0 else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> heapq . heappush ( plus , - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( minus , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <NL> <COMMENT> <NL> if len ( plus ) < K - min ( ( K - K % 2 ) , ( len ( minus ) - len ( minus ) % 2 ) ) : <NEWLINE> <INDENT> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> heapq . heappush ( plus , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( minus , - a ) <NEWLINE> <NL> <DEDENT> <DEDENT> while K > 0 : <NEWLINE> <INDENT> if plus : <NEWLINE> <INDENT> x = plus [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = float ( <STRING> ) <NEWLINE> <NL> <DEDENT> if minus : <NEWLINE> <INDENT> y = - minus [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = float ( <STRING> ) <NEWLINE> <NL> <DEDENT> if abs ( x ) <= abs ( y ) : <NEWLINE> <INDENT> ans *= x <NEWLINE> if plus : <NEWLINE> <INDENT> heapq . heappop ( plus ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans *= y <NEWLINE> if minus : <NEWLINE> <INDENT> heapq . heappop ( minus ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans %= MOD <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> while K > 0 : <NEWLINE> <INDENT> if K >= 2 and len ( minus ) >= 2 and len ( plus ) >= 2 : <NEWLINE> <INDENT> x1 = plus [ 0 ] <NEWLINE> x2 = plus [ 1 ] <NEWLINE> y1 = minus [ 0 ] <NEWLINE> y2 = minus [ 1 ] <NEWLINE> if x1 * x2 <= y1 * y2 : <NEWLINE> <INDENT> y1 = heapq . heappop ( minus ) <NEWLINE> y2 = heapq . heappop ( minus ) <NEWLINE> ans *= ( y1 * y2 ) <NEWLINE> ans %= MOD <NEWLINE> K -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = - heapq . heappop ( plus ) <NEWLINE> ans *= x1 <NEWLINE> ans %= MOD <NEWLINE> K -= 1 <NEWLINE> <DEDENT> <DEDENT> elif K >= 2 and len ( minus ) >= 2 : <NEWLINE> <INDENT> y1 = heapq . heappop ( minus ) <NEWLINE> y2 = heapq . heappop ( minus ) <NEWLINE> ans *= ( y1 * y2 ) <NEWLINE> ans %= MOD <NEWLINE> K -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = - heapq . heappop ( plus ) <NEWLINE> ans *= x <NEWLINE> ans %= MOD <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( 10 ** 4 + 50 ) ] <NEWLINE> <NL> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if tmp < 10 ** 4 + 50 : <NEWLINE> <INDENT> ans [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> <NL> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if ( 2 * y - x ) % 3 != 0 or ( 2 * x - y ) % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a , b = ( 2 * y - x ) // 3 , ( 2 * x - y ) // 3 <NEWLINE> <NL> r = min ( a , b ) <NEWLINE> <NL> if r == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numerator = reduce ( lambda x , y : x * y % mod , range ( a + b - r + 1 , a + b + 1 ) ) <NEWLINE> denominator = reduce ( lambda x , y : x * y % mod , range ( 1 , r + 1 ) ) <NEWLINE> print ( numerator * pow ( denominator , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> c = 1 <NEWLINE> if 1 <= K <= 200 : <NEWLINE> <INDENT> sum_abc = K * ( K + 1 ) / 2 <NEWLINE> sum_abc = int ( sum_abc ) <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = math . gcd ( a , c ) <NEWLINE> d = 3 * d <NEWLINE> sum_abc = sum_abc + d <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <DEDENT> if K >= 3 : <NEWLINE> <INDENT> i = 1 <NEWLINE> j = 2 <NEWLINE> k = 3 <NEWLINE> for k in range ( 3 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , k ) : <NEWLINE> <INDENT> for i in range ( 1 , j ) : <NEWLINE> <INDENT> e = gcd ( i , j , k ) <NEWLINE> e = 6 * e <NEWLINE> sum_abc = sum_abc + e <NEWLINE> i += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum_abc ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = ( float ( i ) for i in input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( a ) <NEWLINE> t = 4 <NEWLINE> s = [ ] <NEWLINE> for i in sorted ( count . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) : <NEWLINE> <INDENT> if i [ 1 ] >= 4 and t == 4 : <NEWLINE> <INDENT> print ( i [ 0 ] ** 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i [ 1 ] >= 2 and t != 0 : <NEWLINE> <INDENT> t -= 2 <NEWLINE> s . append ( i [ 0 ] ) <NEWLINE> <DEDENT> elif t == 0 : break <NEWLINE> <NL> <DEDENT> if len ( s ) != 0 : print ( s [ 0 ] * s [ 1 ] ) <NEWLINE> else : print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> count = 0 <NEWLINE> while a < N : <NEWLINE> <INDENT> count = count + ( N - 1 ) // a <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> A . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l = [ 0 ] * ( N + 1 ) <NEWLINE> now = 1 <NEWLINE> i = 1 <NEWLINE> while l [ now ] == 0 : <NEWLINE> <INDENT> l [ now ] = i <NEWLINE> now = A [ now ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> if K < l [ now ] : <NEWLINE> <INDENT> ans = l . index ( K + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( K - l [ now ] + 1 ) % ( len ( [ x for x in l if x != 0 ] ) - l [ now ] + 1 ) <NEWLINE> ans = l . index ( l [ now ] + k ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , b , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = N // ( b + r ) <NEWLINE> s = N % ( b + r ) <NEWLINE> <NL> if s >= b : <NEWLINE> <INDENT> print ( ( t + 1 ) * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t * b + s ) <NEWLINE> <DEDENT>
H = 1 <NEWLINE> W = 1 <NEWLINE> while H and W : <NEWLINE> <INDENT> H , W = input ( ) . split ( ) <NEWLINE> H = int ( H ) <NEWLINE> W = int ( W ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> town = [ 0 ] * n <NEWLINE> info = [ 1 ] <NEWLINE> now = 1 <NEWLINE> while town [ now - 1 ] == 0 : <NEWLINE> <INDENT> town [ now - 1 ] += 1 <NEWLINE> now = a [ now - 1 ] <NEWLINE> info . append ( now ) <NEWLINE> <DEDENT> loop_list = list ( info [ info . index ( now ) : - 1 ] ) <NEWLINE> loop_len = len ( loop_list ) <NEWLINE> before_loop_list = list ( info [ : info . index ( now ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if k < len ( before_loop_list ) : <NEWLINE> <INDENT> print ( before_loop_list [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop_list [ ( ( k - len ( before_loop_list ) ) % loop_len ) ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n , m = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> E = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> E [ s ] . add ( t ) <NEWLINE> E [ t ] . add ( s ) <NEWLINE> <NL> <DEDENT> def dfs ( current , prev ) : <NEWLINE> <INDENT> global timer <NEWLINE> prenum [ current ] = timer <NEWLINE> lowest [ current ] = prenum [ current ] <NEWLINE> timer += 1 <NEWLINE> <NL> visited [ current ] = 1 <NEWLINE> <NL> for v in E [ current ] : <NEWLINE> <INDENT> if visited [ v ] == 0 : <NEWLINE> <INDENT> parent [ v ] = current <NEWLINE> dfs ( v , current ) <NEWLINE> lowest [ current ] = min ( lowest [ current ] , lowest [ v ] ) <NEWLINE> <DEDENT> elif v != prev : <COMMENT> <NEWLINE> <INDENT> lowest [ current ] = min ( lowest [ current ] , prenum [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> prenum = [ None ] * n <NEWLINE> parent = [ None ] * n <NEWLINE> lowest = [ float ( <STRING> ) ] * n <NEWLINE> timer = 1 <NEWLINE> visited = [ 0 ] * n <NEWLINE> <NL> dfs ( 0 , - 1 ) <NEWLINE> <NL> ap = [ ] <NEWLINE> np = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p = parent [ i ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> np += 1 <NEWLINE> <DEDENT> elif prenum [ p ] <= lowest [ i ] : <NEWLINE> <INDENT> ap . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if np > 1 : <NEWLINE> <INDENT> ap . append ( 0 ) <NEWLINE> <NL> <DEDENT> ap = list ( set ( ap ) ) <NEWLINE> ap . sort ( ) <NEWLINE> if ap : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , ap ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> Smx = 0 <NEWLINE> if B < N : <NEWLINE> <INDENT> N = B <NEWLINE> <DEDENT> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if i < N - A : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = int ( ( A * ( i % B ) - ( ( A * i ) % B ) ) / B ) <NEWLINE> if Smx < S : <NEWLINE> <INDENT> Smx = S <NEWLINE> <DEDENT> <DEDENT> print ( Smx ) <NEWLINE>
MAX_P = 100000 * 10000 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w = list ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def check ( p ) : <NEWLINE> <INDENT> k_no = 1 <NEWLINE> tmp = 0 <NEWLINE> for i , wi in enumerate ( w ) : <NEWLINE> <INDENT> if wi > p : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> if tmp + wi > p : <NEWLINE> <INDENT> if k_no == k : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k_no += 1 <NEWLINE> tmp = wi <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp += wi <NEWLINE> <DEDENT> <DEDENT> return len ( w ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> left = 1 <NEWLINE> right = MAX_P <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> v = check ( mid ) <COMMENT> <NEWLINE> if v < n : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if check ( left ) >= n : <NEWLINE> <INDENT> return left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return right <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> K = int ( K ) <NEWLINE> N = [ ] <NEWLINE> if B - A > K : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> N . append ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> if not i in N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i < A + K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> elif i > B - K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
num = float ( input ( ) ) <NEWLINE> area = num * num * 3.141592653589 <NEWLINE> circle = 3.141592653589 * ( num * 2 ) <NEWLINE> print ( area , circle ) <NEWLINE>
l = ( 1260 - 540 ) + 1 <NEWLINE> while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> T = [ [ 0 ] * l for _ in range ( M ) ] <NEWLINE> r = int ( input ( ) ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> t , n , m , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if s == 1 : <NEWLINE> <INDENT> T [ m - 1 ] [ t - 540 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ m - 1 ] [ t - 540 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> used = { } <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> t1 , t2 , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if not ( m - 1 ) in used : <NEWLINE> <INDENT> T_range = [ ] <NEWLINE> flg = True if T [ m - 1 ] [ 0 ] >= 1 else False <NEWLINE> lb = 0 <NEWLINE> for j in range ( l - 1 ) : <NEWLINE> <INDENT> T [ m - 1 ] [ j + 1 ] += T [ m - 1 ] [ j ] <NEWLINE> if flg and T [ m - 1 ] [ j + 1 ] == 0 : <NEWLINE> <INDENT> T_range . append ( ( lb + 540 , j + 1 + 540 ) ) <NEWLINE> flg = False <NEWLINE> <DEDENT> elif ( not flg ) and T [ m - 1 ] [ j + 1 ] >= 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> lb = ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> T_range . append ( ( lb + 540 , 1261 ) ) <NEWLINE> <DEDENT> used [ m - 1 ] = T_range <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a , b in used [ m - 1 ] : <NEWLINE> <INDENT> if not ( b < t1 or t2 < a ) : <NEWLINE> <INDENT> ans += ( min ( t2 , b ) - max ( t1 , a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
base = 127 <NEWLINE> mask = ( 1 << 32 ) - 1 <NEWLINE> <NL> <NL> def calc_hash ( f , pl , tl ) : <NEWLINE> <INDENT> dl = tl - pl <NEWLINE> tmp = set ( ) <NEWLINE> <NL> t = 1 <NEWLINE> for _ in range ( pl ) : <NEWLINE> <INDENT> t = ( t * base ) & mask <NEWLINE> <DEDENT> e = 0 <NEWLINE> for i in range ( pl ) : <NEWLINE> <INDENT> e = ( e * base + f [ i ] ) & mask <NEWLINE> <DEDENT> for i in range ( dl ) : <NEWLINE> <INDENT> tmp . add ( e ) <NEWLINE> e = ( e * base - t * f [ i ] + f [ i + pl ] ) & mask <NEWLINE> <DEDENT> tmp . add ( e ) <NEWLINE> return tmp <NEWLINE> <NL> <NL> <DEDENT> t = [ ord ( c ) for c in input ( ) . strip ( ) ] <NEWLINE> tl = len ( t ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ps = [ input ( ) . strip ( ) for _ in range ( q ) ] <NEWLINE> h = dict ( ) <NEWLINE> c = dict ( ) <NEWLINE> a = [ ] <NEWLINE> for p in ps : <NEWLINE> <INDENT> if p in c : <NEWLINE> <INDENT> a . append ( c [ p ] ) <NEWLINE> continue <NEWLINE> <DEDENT> p = [ ord ( c ) for c in p ] <NEWLINE> pl = len ( p ) <NEWLINE> if pl > tl : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> bs = min ( 19 , pl ) <NEWLINE> keys = calc_hash ( p , bs , pl ) <NEWLINE> if bs not in h : <NEWLINE> <INDENT> h [ bs ] = calc_hash ( t , bs , tl ) <NEWLINE> <DEDENT> a . append ( 1 if keys . issubset ( h [ bs ] ) else 0 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
import math <NEWLINE> xa , ya , xb , yb = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( ( xa - xb ) ** 2 + ( ya - yb ) ** 2 ) ) ) <NEWLINE>
def calc_dynamic ( n , x , m ) : <NEWLINE> <COMMENT> <NL> <INDENT> cal_result = { } <NEWLINE> <NL> <COMMENT> <NL> cal_result [ 1 ] = x <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cal_result [ i + 1 ] = cal_result [ i ] ** 2 % m <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return sum ( cal_result . values ( ) ) <NEWLINE> <NL> <DEDENT> def calc_dynamic2 ( n , x , m ) : <NEWLINE> <INDENT> cal_result_0 = 0 <NEWLINE> cal_result_1 = 0 <NEWLINE> <NL> <COMMENT> <NL> cal_result_0 = x <NEWLINE> total = x <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cal_result_1 = cal_result_0 * cal_result_0 % m <NEWLINE> cal_result_0 = cal_result_1 <NEWLINE> total += cal_result_1 <NEWLINE> <NL> <DEDENT> return total <NEWLINE> <NL> <DEDENT> def calc_dynamic3 ( n , x , m ) : <NEWLINE> <COMMENT> <NL> <INDENT> cal_result = { } <NEWLINE> cal_result_0 = 0 <NEWLINE> cal_result_1 = 0 <NEWLINE> loop_range = ( 0 , 0 ) <NEWLINE> <NL> <COMMENT> <NL> cal_result_0 = x <NEWLINE> total = x <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cal_result_1 = cal_result_0 * cal_result_0 % m <NEWLINE> cal_result_0 = cal_result_1 <NEWLINE> total += cal_result_1 <NEWLINE> if cal_result_1 in cal_result : <NEWLINE> <INDENT> loop_range = ( cal_result [ cal_result_1 ] , i , cal_result_0 , cal_result_1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cal_result [ cal_result_1 ] = ( i , total ) <NEWLINE> <NL> <DEDENT> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> return total <NEWLINE> <NL> <DEDENT> hoge = i <NEWLINE> r = i - loop_range [ 0 ] [ 0 ] <NEWLINE> v = total - loop_range [ 0 ] [ 1 ] <NEWLINE> hoge += r <NEWLINE> total += v * ( ( n - hoge ) // r ) <NEWLINE> hoge += r * ( ( n - hoge ) // r ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> cal_result_0 = loop_range [ 2 ] <NEWLINE> cal_result_1 = loop_range [ 3 ] <NEWLINE> for i in range ( hoge - r + 1 , n ) : <NEWLINE> <INDENT> cal_result_1 = cal_result_0 * cal_result_0 % m <NEWLINE> cal_result_0 = cal_result_1 <NEWLINE> total += cal_result_1 <NEWLINE> <NL> <DEDENT> return total <NEWLINE> <NL> <DEDENT> [ n , x , m ] = map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( calc_dynamic3 ( n , x , m ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist . sort ( reverse = True ) <NEWLINE> sumscore = alist [ 0 ] <NEWLINE> for n in range ( 1 , int ( N / 2 ) ) : <NEWLINE> <INDENT> sumscore = sumscore + alist [ n ] * 2 <NEWLINE> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> sumscore += alist [ n + 1 ] <NEWLINE> <NL> <DEDENT> print ( sumscore ) <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import os <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 0 ] * n <NEWLINE> for i in a_list : <NEWLINE> <INDENT> result [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in result : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> line = input ( ) <NEWLINE> ln = 0 <NEWLINE> d = 1 <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> for i in range ( 1 , len ( line ) + 1 ) : <NEWLINE> <INDENT> ti1 = ( ln + ( int ( line [ - 1 * i ] ) * d ) ) % 2019 <NEWLINE> counts [ ti1 ] += 1 <NEWLINE> ln = ti1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> total = 0 <NEWLINE> counts [ 0 ] += 1 <NEWLINE> for i in range ( len ( counts ) ) : <NEWLINE> <INDENT> total += counts [ i ] * ( counts [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( total ) ) <NEWLINE>
import itertools as it <NEWLINE> <NL> N = list ( input ( ) ) <NEWLINE> l = len ( N ) <NEWLINE> a = N [ 0 ] + <STRING> * ( l - 1 ) <COMMENT> <NEWLINE> <NL> ans = int ( N [ 0 ] ) + 9 * ( l - 1 ) <NEWLINE> <NL> if int ( <STRING> . join ( N ) ) != int ( a ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = [ float ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) ) ) <NEWLINE>
import heapq <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> money_max = 50 * N <NEWLINE> S = min ( S , money_max ) <NEWLINE> dp = [ [ float ( <STRING> ) ] * ( money_max + 1 ) for _ in range ( N ) ] <NEWLINE> dp [ 0 ] [ S ] = 0 <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> exchange = [ None ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> G [ u ] . append ( [ v , a , b ] ) <NEWLINE> G [ v ] . append ( [ u , a , b ] ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> exchange [ i ] = [ c , d ] <NEWLINE> <DEDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> heapq . heappush ( q , [ 0 , 0 , S ] ) <NEWLINE> while 0 < len ( q ) : <NEWLINE> <INDENT> pre_time , idx , s = heapq . heappop ( q ) <NEWLINE> if dp [ idx ] [ s ] < pre_time : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ex = min ( s + exchange [ idx ] [ 0 ] , money_max ) <NEWLINE> if dp [ idx ] [ s ] + exchange [ idx ] [ 1 ] < dp [ idx ] [ ex ] : <NEWLINE> <INDENT> dp [ idx ] [ ex ] = dp [ idx ] [ s ] + exchange [ idx ] [ 1 ] <NEWLINE> heapq . heappush ( q , [ dp [ idx ] [ ex ] , idx , ex ] ) <NEWLINE> <DEDENT> for to , money , time in G [ idx ] : <NEWLINE> <INDENT> if money <= s : <NEWLINE> <INDENT> if dp [ idx ] [ s ] + time < dp [ to ] [ s - money ] : <NEWLINE> <INDENT> dp [ to ] [ s - money ] = dp [ idx ] [ s ] + time <NEWLINE> heapq . heappush ( q , [ dp [ to ] [ s - money ] , to , s - money ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( dp [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> m = int ( s [ 5 : 7 ] ) <NEWLINE> if m <= 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> if n >= b : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> print ( math . floor ( ( a * x ) / b ) - a * math . floor ( x / b ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( n , k ) : <NEWLINE> <INDENT> n %= k <NEWLINE> return min ( n , abs ( n - k ) ) <NEWLINE> <NL> <DEDENT> print ( solve ( N , K ) ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> point = [ k ] * ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> point [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if point [ i ] - q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A_set = list ( set ( A_list ) ) <NEWLINE> maxA = A_set [ - 1 ] <NEWLINE> dp = [ 1 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> <NL> cntli = [ 0 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> unique = [ ] <NEWLINE> for i in A_list : <NEWLINE> <INDENT> cntli [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( ( ( 10 ** 6 ) + 1 ) ) : <NEWLINE> <INDENT> if cntli [ i ] == 1 : <NEWLINE> <INDENT> unique . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for elem in A_set : <NEWLINE> <INDENT> for i in range ( 2 * elem , 10 ** 6 + 1 , elem ) : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in unique : <NEWLINE> <INDENT> if not ( dp [ i ] == 0 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = k * d <NEWLINE> <NL> x = abs ( x ) <NEWLINE> flag = 0 <NEWLINE> <NL> if x >= num : <NEWLINE> <INDENT> print ( x - num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x > d : <NEWLINE> <INDENT> j = int ( x / d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x * 2 > d : <NEWLINE> <INDENT> j = 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if j == 0 : <NEWLINE> <INDENT> b = x <NEWLINE> <DEDENT> elif j == 1 and flag == 1 : <NEWLINE> <INDENT> b = d - x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = x % ( d * j ) <NEWLINE> <DEDENT> min = min ( b , d - b ) <NEWLINE> max = max ( b , d - b ) <NEWLINE> if min == d - b : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> if ( k - j ) % 2 == 0 : <NEWLINE> <INDENT> print ( min ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> array = dict ( ) <NEWLINE> for i in data : <NEWLINE> <INDENT> if i in array : <NEWLINE> <INDENT> array [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = 0 <NEWLINE> for i , j in array . items ( ) : <NEWLINE> <INDENT> total += i * j <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> dt = 0 <NEWLINE> quary = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if quary [ 0 ] not in array : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif quary [ 1 ] in array : <NEWLINE> <INDENT> dt = ( quary [ 1 ] - quary [ 0 ] ) * array [ quary [ 0 ] ] <NEWLINE> array [ quary [ 1 ] ] += array [ quary [ 0 ] ] <NEWLINE> del array [ quary [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dt = ( quary [ 1 ] - quary [ 0 ] ) * array [ quary [ 0 ] ] <NEWLINE> array [ quary [ 1 ] ] = array [ quary [ 0 ] ] <NEWLINE> del array [ quary [ 0 ] ] <NEWLINE> <NL> <DEDENT> total += dt <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> gou = 0 <NEWLINE> if s [ 0 ] == <STRING> or s [ 1 ] == <STRING> or s [ 2 ] == <STRING> : <NEWLINE> <INDENT> gou = 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> and s [ 1 ] == <STRING> : <NEWLINE> <INDENT> gou = 2 <NEWLINE> <DEDENT> if s [ 1 ] == <STRING> and s [ 2 ] == <STRING> : <NEWLINE> <INDENT> gou = 2 <NEWLINE> <DEDENT> if s [ 1 ] == <STRING> and s [ 2 ] == <STRING> and s [ 0 ] == <STRING> : <NEWLINE> <INDENT> gou = 3 <NEWLINE> <DEDENT> print ( gou ) <NEWLINE>
def function ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> paths = [ ] <NEWLINE> for _ in range ( N + 1 ) : <NEWLINE> <INDENT> paths . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for _m in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ A ] . append ( B ) <NEWLINE> paths [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * ( N + 1 ) <NEWLINE> dist [ 1 ] = 0 <NEWLINE> pre = [ - 1 ] * ( N + 1 ) <NEWLINE> q = [ 1 ] <COMMENT> <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> i = q . pop ( 0 ) <NEWLINE> for ne in paths [ i ] : <NEWLINE> <INDENT> if dist [ ne ] == - 1 : <NEWLINE> <INDENT> dist [ ne ] = dist [ i ] + 1 <NEWLINE> pre [ ne ] = i <NEWLINE> q . append ( ne ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> pre . pop ( 0 ) <NEWLINE> pre . pop ( 0 ) <NEWLINE> for d in pre : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> function ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = i * ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> ans_a , ans_b = a , b <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans_a , ans_b ) <NEWLINE>
MOD = 2019 <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> nums = [ 0 ] * N <NEWLINE> nums [ - 1 ] = int ( S [ - 1 ] ) % MOD <NEWLINE> for i in range ( - 2 , - N - 1 , - 1 ) : <NEWLINE> <INDENT> nums [ i ] = ( int ( S [ i ] ) * pow ( 10 , - ( i + 1 ) , MOD ) + nums [ i + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> a = [ 0 ] * 2019 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ nums [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( a [ 0 ] + sum ( [ ( a [ i ] * ( a [ i ] - 1 ) ) // 2 for i in range ( 2019 ) ] ) ) <NEWLINE>
def bubble_sort ( ls ) : <NEWLINE> <INDENT> flag = True <NEWLINE> i = 0 <NEWLINE> ch = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in reversed ( range ( i + 1 , len ( ls ) ) ) : <NEWLINE> <INDENT> if ls [ j ] < ls [ j - 1 ] : <NEWLINE> <INDENT> ls [ j ] , ls [ j - 1 ] = ls [ j - 1 ] , ls [ j ] <NEWLINE> flag = True <NEWLINE> ch += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return ch <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ch = bubble_sort ( ls ) <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> if i == len ( ls ) - 1 : <NEWLINE> <INDENT> print ( ls [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ls [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ch ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AM = [ ] <NEWLINE> AP = [ ] <NEWLINE> AMlist = [ 0 ] * N <NEWLINE> APlist = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> plus = i + 1 + A [ i ] <NEWLINE> AP . append ( plus ) <NEWLINE> if AP [ i ] <= N : <NEWLINE> <INDENT> APlist [ AP [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> minus = i + 1 - A [ i ] <NEWLINE> AM . append ( minus ) <NEWLINE> if AM [ i ] > 0 and AM [ i ] <= N : <NEWLINE> <INDENT> AMlist [ AM [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> ans += APlist [ j ] * AMlist [ j ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> R = c . count ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( R ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> keisu = [ 0 ] * n <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> keisu [ i ] += t <NEWLINE> t += a [ i ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * keisu [ i ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( ans % ( 1000000000 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def name ( n ) : <NEWLINE> <INDENT> if ( n == 0 ) : <NEWLINE> <INDENT> return <STRING> ; <NEWLINE> <DEDENT> n -= 1 <NEWLINE> return name ( n // 26 ) + chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> <NL> <DEDENT> print ( name ( n ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> a . append ( 1000000 ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> j = 0 <NEWLINE> if a [ j ] == 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == a [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
from collections import * <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> l += [ i + j ] <NEWLINE> r += [ i - j ] <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> l = Counter ( l ) <NEWLINE> for r in r : <NEWLINE> <INDENT> cnt += l . get ( r , 0 ) <NEWLINE> <NL> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE> <NL>
import re <NEWLINE> <NL> class Num : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . x ) <NEWLINE> <NL> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return Num ( self . x + other . x ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return Num ( self . x - other . x ) <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> return Num ( int ( self . x / other . x ) ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> return Num ( self . x * other . x ) <NEWLINE> <NL> <DEDENT> def __neg__ ( self ) : <NEWLINE> <INDENT> return Num ( - self . x ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> expr = input ( ) [ 0 : - 1 ] <NEWLINE> expr = re . sub ( <STRING> , <STRING> , expr ) <NEWLINE> print ( eval ( expr ) ) <NEWLINE> <DEDENT>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> m = np . array ( [ [ 0 if i == <STRING> else 1 for i in input ( ) ] for i in range ( H ) ] ) <NEWLINE> l , r , u , d = np . zeros ( ( 4 , H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * m [ i ] <NEWLINE> d [ - i - 1 ] = ( d [ - i ] + 1 ) * m [ - i - 1 ] <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> r [ : , i ] = ( r [ : , i - 1 ] + 1 ) * m [ : , i ] <NEWLINE> l [ : , - i - 1 ] = ( l [ : , - i ] + 1 ) * m [ : , - i - 1 ] <NEWLINE> <DEDENT> print ( int ( np . max ( u + r + l + d ) ) - 3 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> V = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> fees = [ [ math . inf ] * V for i in range ( V ) ] <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> fees [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( E ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> fees [ a - 1 ] [ b - 1 ] = c <NEWLINE> fees [ b - 1 ] [ a - 1 ] = d <NEWLINE> <DEDENT> start , end , funding , cost = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> for j in range ( V ) : <NEWLINE> <INDENT> for k in range ( V ) : <NEWLINE> <INDENT> if ( fees [ j ] [ k ] > fees [ j ] [ i ] + fees [ i ] [ k ] ) : <NEWLINE> <INDENT> fees [ j ] [ k ] = fees [ j ] [ i ] + fees [ i ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( fees [ start - 1 ] [ end - 1 ] == math . inf or fees [ end - 1 ] [ start - 1 ] == math . inf ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( funding - cost - fees [ start - 1 ] [ end - 1 ] - fees [ end - 1 ] [ start - 1 ] ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> minutes_a = 0 <NEWLINE> count_a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if minutes_a + A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> minutes_a += A [ i ] <NEWLINE> count_a += 1 <NEWLINE> <NL> <DEDENT> ans = count_a <NEWLINE> minutes_b = 0 <NEWLINE> count_b = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if minutes_a + minutes_b + B [ i ] > K : <NEWLINE> <INDENT> found = False <NEWLINE> while count_a > 0 : <NEWLINE> <INDENT> minutes_a -= A [ count_a - 1 ] <NEWLINE> count_a -= 1 <NEWLINE> if minutes_a + minutes_b + B [ i ] <= K : <NEWLINE> <INDENT> minutes_b += B [ i ] <NEWLINE> count_b += 1 <NEWLINE> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not found : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> minutes_b += B [ i ] <NEWLINE> count_b += 1 <NEWLINE> <DEDENT> ans = max ( ans , count_a + count_b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for letter in s : <NEWLINE> <INDENT> if letter == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif letter == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif letter == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> total = r * g * b <NEWLINE> subs = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= n - 1 : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif s [ j ] == s [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif s [ k ] == s [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> subs += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = total - subs <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num1 = [ 0 ] * ( 2 * ( 10 ** 5 ) + 10 ) <NEWLINE> num2 = [ 0 ] * ( 2 * ( 10 ** 5 ) + 10 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] + i + 1 < 2 * ( 10 ** 5 ) + 5 : <NEWLINE> <INDENT> num1 [ a [ i ] + i + 1 ] += 1 <NEWLINE> <DEDENT> if a [ i ] + 1 < i + 1 : <NEWLINE> <INDENT> num2 [ - a [ i ] + i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( num1 ) ) : <NEWLINE> <INDENT> ans += num1 [ i ] * num2 [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 0 in L ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> sum_l = 1 <NEWLINE> for x in L : <NEWLINE> <INDENT> sum_l *= x <NEWLINE> if ( sum_l > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_l ) <NEWLINE>
def bfs ( fd , n ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in visited : continue <NEWLINE> volume = 1 <NEWLINE> queue = fd [ i ] <NEWLINE> visited . add ( i ) <NEWLINE> while queue : <NEWLINE> <INDENT> x = queue . pop ( ) <NEWLINE> if x in visited : continue <NEWLINE> visited . add ( x ) <NEWLINE> volume += 1 <NEWLINE> queue |= fd [ x ] <NEWLINE> <DEDENT> ans = max ( ans , volume ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> fd = { i + 1 : set ( ) for i in range ( n ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> fd [ a ] . add ( b ) <NEWLINE> fd [ b ] . add ( a ) <NEWLINE> <DEDENT> print ( bfs ( fd , n ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minlist = [ ] <NEWLINE> maxlist = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> if b - i >= a : <NEWLINE> <INDENT> minlist . append ( a + i ) <NEWLINE> <DEDENT> if b - i >= a + k : <NEWLINE> <INDENT> maxlist . insert ( 0 , b - i ) <NEWLINE> <DEDENT> <DEDENT> ans = minlist + maxlist <NEWLINE> set ( ans ) <NEWLINE> for i in range ( 0 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> counter = defaultdict ( int ) <NEWLINE> for x in A : <NEWLINE> <INDENT> counter [ x ] += 1 <NEWLINE> <NL> <DEDENT> total = sum ( A ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> total += ( c - b ) * counter [ b ] <NEWLINE> counter [ c ] += counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = set ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> targets = set ( range ( - 101 , 102 ) ) - P <NEWLINE> if targets : <NEWLINE> <INDENT> print ( min ( [ ( target , abs ( X - target ) ) for target in targets ] , key = lambda x : x [ 1 ] ) [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> def lis_linear ( a , n ) : <NEWLINE> <INDENT> dp = [ 0 for i in range ( n ) ] <NEWLINE> longest = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> max_val = 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if a [ j ] < a [ i ] and max_val < dp [ j ] + 1 : <NEWLINE> <INDENT> max_val = dp [ j ] + 1 <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = max_val <NEWLINE> if dp [ i ] > longest : longest = dp [ i ] <NEWLINE> <DEDENT> return longest <NEWLINE> <NL> <DEDENT> def lis_binary ( a , n ) : <NEWLINE> <INDENT> tail = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > tail [ - 1 ] : <NEWLINE> <INDENT> tail . append ( a [ i ] ) <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( len ( tail ) ) : <NEWLINE> <INDENT> if a [ i ] <= tail [ j ] : <NEWLINE> <INDENT> tail [ j ] = a [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return len ( tail ) <NEWLINE> <NL> <DEDENT> print ( lis_binary ( a , n ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 for i in range ( n ) ] <NEWLINE> y = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] : <NEWLINE> <INDENT> y . append ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> y . sort ( ) <NEWLINE> z = len ( y ) <NEWLINE> i = 0 <NEWLINE> while ( z > k ) : <NEWLINE> <INDENT> s += y [ i ] <NEWLINE> z -= 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 or y == 0 or x < 0 or y < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif W == x or H == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif W < x or H < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif W < x + r or H < y + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> import math <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ABs = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> lonlieness = 0 <NEWLINE> pairs = { } <NEWLINE> for AB in ABs : <NEWLINE> <INDENT> a , b = AB <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> lonlieness += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> a , b = - 1 , 0 <NEWLINE> bad_a , bad_b = 0 , 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> a , b = ( 0 , 1 ) <NEWLINE> bad_a , bad_b = - 1 , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _gcd = math . gcd ( a , b ) <NEWLINE> a //= _gcd <NEWLINE> b //= _gcd <NEWLINE> bad_a = - b <NEWLINE> bad_b = a <NEWLINE> if b < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if bad_b < 0 : <NEWLINE> <INDENT> bad_a , bad_b = - bad_a , - bad_b <NEWLINE> <DEDENT> <DEDENT> pairs . setdefault ( ( a , b ) , 0 ) <NEWLINE> pairs . setdefault ( ( bad_a , bad_b ) , 0 ) <COMMENT> <NEWLINE> pairs [ ( a , b ) ] += 1 <NEWLINE> <NL> <DEDENT> permutations = [ ] <NEWLINE> for i , pair in enumerate ( pairs . keys ( ) ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b = pair <NEWLINE> bad_a , bad_b = - b , a <NEWLINE> if bad_b < 0 : <NEWLINE> <INDENT> bad_a , bad_b = - bad_a , - bad_b <NEWLINE> <DEDENT> group_num = pow ( 2 , pairs [ ( a , b ) ] , mod ) - 1 <NEWLINE> badgroup_num = pow ( 2 , pairs [ ( bad_a , bad_b ) ] , mod ) - 1 <NEWLINE> permutations . append ( group_num + badgroup_num + 1 ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for p in permutations : <NEWLINE> <INDENT> result = result * p % mod <NEWLINE> <NL> <DEDENT> result = ( result + lonlieness - 1 ) % mod <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Si = input ( ) <NEWLINE> if not Si in l : <NEWLINE> <INDENT> l . add ( Si ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> y = list ( map ( int , x ) ) <NEWLINE> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> seen = [ False ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = [ - 1 ] * n <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> seen [ 0 ] = True <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for i in graph [ now ] : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ i ] = True <NEWLINE> q . append ( i ) <NEWLINE> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = now <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ <STRING> ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 1 and s == 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif num [ s - 1 ] != <STRING> and num [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> num [ s - 1 ] = c <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if num [ j ] == <STRING> : <NEWLINE> <INDENT> num [ j ] = 0 <NEWLINE> <DEDENT> if n > 1 and num [ 0 ] == 0 : <NEWLINE> <INDENT> num [ 0 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( int ( <STRING> . join ( map ( str , num ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( sum ( ( n - 1 ) // i for i in range ( 1 , n ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ True ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> ab [ b - 1 ] = False <NEWLINE> <DEDENT> elif h [ b - 1 ] > h [ a - 1 ] : <NEWLINE> <INDENT> ab [ a - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab [ a - 1 ] = False <NEWLINE> ab [ b - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ab . count ( True ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * a + 2 * b ) ; <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> y = bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += x * ( n - y ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if N > k and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def print_A ( A ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( A [ i ] ) ) <NEWLINE> if i != len ( A ) - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while ( j >= 0 ) and ( A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( A , n , G ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( len ( G ) ) : <NEWLINE> <INDENT> cnt += insertionSort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def get_gap ( n ) : <NEWLINE> <INDENT> G = [ ] <NEWLINE> h = 1 <NEWLINE> cnt = 1 <NEWLINE> while h <= n : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if len ( G ) == 0 : G . append ( 1 ) <NEWLINE> return list ( reversed ( G ) ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> G = get_gap ( n ) <NEWLINE> m = len ( G ) <NEWLINE> cnt = shellSort ( A , n , G ) <NEWLINE> <NL> print ( m ) <NEWLINE> print_A ( G ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) ** 2 <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( a [ i ] ** 2 ) <NEWLINE> <DEDENT> s = ( s - sum ( b ) ) // 2 <NEWLINE> mod = s % ( 10 ** 9 + 7 ) <NEWLINE> print ( mod ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> F = sys . stdin <NEWLINE> Continue = True <NEWLINE> while Continue : <NEWLINE> <INDENT> N = int ( F . readline ( ) . strip ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> Continue = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Score = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Score [ i ] = int ( F . readline ( ) . strip ( <STRING> ) ) <NEWLINE> <DEDENT> Score . sort ( ) <NEWLINE> print ( sum ( Score [ 1 : N - 1 ] ) // ( N - 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> st = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> mod_res_dic = { 0 : [ 0 ] } <NEWLINE> tmp_mod_val = 0 <NEWLINE> r_st = <STRING> . join ( list ( reversed ( st ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( r_st ) ) : <NEWLINE> <INDENT> target_st = r_st [ i : i + 1 ] <NEWLINE> <COMMENT> <NL> tmp_mod_val += int ( target_st ) * pow ( 10 , i , 2019 ) <NEWLINE> tmp_mod_val %= 2019 <NEWLINE> ls = mod_res_dic . setdefault ( tmp_mod_val , [ ] ) <NEWLINE> ls . append ( i - 1 ) <NEWLINE> if len ( ls ) > 1 : <NEWLINE> <INDENT> cnt += len ( ls ) - 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( int ( cnt ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> dic = { } <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> nod = [ [ ] ] <NEWLINE> keep = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> nod . append ( [ ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> nod [ a - 1 ] . append ( b ) <NEWLINE> nod [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> use = deque ( ) <NEWLINE> use . append ( 1 ) <NEWLINE> for i in range ( 0 , 10 ** 100 ) : <NEWLINE> <INDENT> if bool ( use ) : <NEWLINE> <INDENT> sss = use . popleft ( ) <NEWLINE> for j in nod [ sss - 1 ] : <NEWLINE> <INDENT> if not j in dic : <NEWLINE> <INDENT> keep [ j - 1 ] = sss <NEWLINE> use . append ( j ) <NEWLINE> dic [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> keep . pop ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for x in keep : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
aoj = True <NEWLINE> while aoj : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h == 0 or w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for h in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> wa += gcd ( gcd ( i , j ) , h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( wa ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> n = 0 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> n += ( 1 if c % i == 0 else 0 ) <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ a ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( a + 1 , a + b ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> goto = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> goto [ AB [ i ] [ 0 ] ] . append ( AB [ i ] [ 1 ] ) <NEWLINE> goto [ AB [ i ] [ 1 ] ] . append ( AB [ i ] [ 0 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> parent = [ 0 for i in range ( N + 1 ) ] <NEWLINE> done = [ 0 for i in range ( N + 1 ) ] <NEWLINE> done [ 1 ] = 1 <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> r = q . popleft ( ) <NEWLINE> for t in goto [ r ] : <NEWLINE> <INDENT> if done [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ t ] = r <NEWLINE> done [ t ] = 1 <NEWLINE> q . append ( t ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( parent [ i ] ) <NEWLINE> <DEDENT>
n , p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = [ int ( i ) for i in list ( input ( ) ) ] [ : : - 1 ] <NEWLINE> summ = 0 <NEWLINE> ans = 0 <NEWLINE> cnt = [ 0 ] * p <COMMENT> <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = s [ i ] * pow ( 10 , i , p ) <NEWLINE> summ = ( summ + d ) % p <NEWLINE> cnt [ summ ] += 1 <NEWLINE> <NL> <DEDENT> if p in [ 2 , 5 ] : <COMMENT> <NEWLINE> <INDENT> if p == 2 : <NEWLINE> <INDENT> ok_list = [ 0 , 2 , 4 , 6 , 8 ] <NEWLINE> <DEDENT> if p == 5 : <NEWLINE> <INDENT> ok_list = [ 0 , 5 ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = s [ i ] <NEWLINE> if d in ok_list : <NEWLINE> <INDENT> ans += n - i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> for i in range ( p ) : <NEWLINE> <INDENT> ans += cnt [ i ] * ( cnt [ i ] - 1 ) // 2 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> <NL> kouho = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> ans = s [ : i ] <NEWLINE> tmp = s [ i : ( i + len ( t ) ) ] <NEWLINE> <NL> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if tmp [ j ] == t [ j ] : <NEWLINE> <INDENT> ans += t [ j ] <NEWLINE> <DEDENT> elif tmp [ j ] == <STRING> : <NEWLINE> <INDENT> ans += t [ j ] <NEWLINE> <DEDENT> elif tmp [ j ] != <STRING> and tmp [ j ] != t [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = ans + s [ ( i + len ( t ) ) : ] <NEWLINE> <NL> if len ( ans ) == len ( s ) : <NEWLINE> <INDENT> kouho . append ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( kouho ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> answers = [ ] <NEWLINE> for j in kouho : <NEWLINE> <NL> <INDENT> tmp_ans = <STRING> <NEWLINE> for k in range ( len ( j ) ) : <NEWLINE> <INDENT> if j [ k ] == <STRING> : <NEWLINE> <INDENT> tmp_ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_ans += j [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> answers . append ( tmp_ans ) <NEWLINE> <NL> <DEDENT> answers = sorted ( answers ) <NEWLINE> print ( answers [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> from collections import deque <NEWLINE> d = deque ( A ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += d . popleft ( ) <NEWLINE> continue <NEWLINE> <DEDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans += d [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += d . popleft ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> count = ( ( n - 1 ) * 2 ) - 1 <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if ( i * 2 >= n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( 2 , n ) : <NEWLINE> <INDENT> if ( i * j < n ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = list ( map ( lambda x : int ( x ) - a , input ( ) . split ( ) ) ) <NEWLINE> b = max ( max ( [ x for x in X ] ) + a , a ) <NEWLINE> dp = [ [ 0 ] * ( 2 * b * n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ b * n ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 * b * n + 1 ) : <NEWLINE> <INDENT> if 0 <= j - X [ i - 1 ] < 2 * b * n : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - X [ i - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ b * n ] - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> result += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( result [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> state_of_up_or_down = False <NEWLINE> money = 1000 <NEWLINE> min_price = a [ 0 ] <NEWLINE> max_price = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> max_price = a [ i ] <NEWLINE> state_of_up_or_down = True <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> money = ( money // min_price ) * max_price + money % min_price <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> money = ( money // min_price ) * max_price + money % min_price <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if state_of_up_or_down : <NEWLINE> <INDENT> money = ( money // min_price ) * max_price + money % min_price <NEWLINE> state_of_up_or_down = False <NEWLINE> <COMMENT> <NL> <DEDENT> min_price = a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
from math import log2 , ceil <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> tn = 2 ** ceil ( log2 ( n ) ) <NEWLINE> self . a = [ 2 ** 31 - 1 ] * ( tn * 2 ) <NEWLINE> self . l = tn * 2 <NEWLINE> self . tn = tn <NEWLINE> <NL> <DEDENT> def find ( self , c , l , r , s , t ) : <NEWLINE> <INDENT> if self . a [ c ] == - 1 : <NEWLINE> <INDENT> return self . a [ c // 2 ] <NEWLINE> <DEDENT> if s <= l and r <= t : <NEWLINE> <INDENT> return self . a [ c ] <NEWLINE> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> if t <= mid : <NEWLINE> <INDENT> return self . find ( c * 2 , l , mid , s , t ) <NEWLINE> <DEDENT> elif s > mid : <NEWLINE> <INDENT> return self . find ( c * 2 + 1 , mid + 1 , r , s , t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( <NEWLINE> <INDENT> self . find ( c * 2 , l , mid , s , mid ) , <NEWLINE> self . find ( c * 2 + 1 , mid + 1 , r , mid + 1 , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def update ( self , c , l , r , s , t , x , f = None ) : <NEWLINE> <NL> <INDENT> if f is None and self . a [ c ] == - 1 : <NEWLINE> <INDENT> f = self . a [ c // 2 ] <NEWLINE> <NL> <DEDENT> if l == s and r == t : <NEWLINE> <INDENT> return self . set ( c , x ) <NEWLINE> <NL> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> if t <= mid : <NEWLINE> <INDENT> rv , f = self . get_child ( c , c * 2 + 1 , f ) <NEWLINE> u = min ( self . update ( c * 2 , l , mid , s , t , x , f ) , rv ) <NEWLINE> <DEDENT> elif s > mid : <NEWLINE> <INDENT> lv , f = self . get_child ( c , c * 2 , f ) <NEWLINE> u = min ( lv , self . update ( c * 2 + 1 , mid + 1 , r , s , t , x , f ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u = min ( <NEWLINE> <INDENT> self . update ( c * 2 , l , mid , s , mid , x , f ) , <NEWLINE> self . update ( c * 2 + 1 , mid + 1 , r , mid + 1 , t , x , f ) ) <NEWLINE> <DEDENT> if f is not None : <NEWLINE> <INDENT> u = min ( f , u ) <NEWLINE> <DEDENT> <DEDENT> self . a [ c ] = u <NEWLINE> <NL> return u <NEWLINE> <NL> <DEDENT> def set ( self , c , x ) : <NEWLINE> <INDENT> self . a [ c ] = x <NEWLINE> if c * 2 < self . l : <NEWLINE> <INDENT> self . a [ c * 2 ] = self . a [ c * 2 + 1 ] = - 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def get_child ( self , c , child , f ) : <NEWLINE> <INDENT> if f is not None : <NEWLINE> <INDENT> return self . set ( child , f ) , f <NEWLINE> <DEDENT> v = self . a [ child ] <NEWLINE> if v == - 1 : <NEWLINE> <INDENT> f = self . a [ c ] <NEWLINE> v = self . set ( child , f ) <NEWLINE> <DEDENT> return v , f <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> st = SegmentTree ( n ) <NEWLINE> buf = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> s , t , x = map ( int , query [ 1 : ] ) <NEWLINE> st . update ( 1 , 0 , st . tn - 1 , s , t , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s , t = map ( int , query [ 1 : ] ) <NEWLINE> buf . append ( st . find ( 1 , 0 , st . tn - 1 , s , t ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , buf ) ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x + 1 ) : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z > x or z > y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y == z : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> count += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = 0 <NEWLINE> list . sort ( b , reverse = True ) <NEWLINE> ans += b . pop ( 0 ) <NEWLINE> b . extend ( b ) <NEWLINE> list . sort ( b , reverse = True ) <NEWLINE> <NL> ans += sum ( b [ 0 : a - 2 ] ) <NEWLINE> print ( str ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , int ( N ** 0.5 ) ) : <NEWLINE> <INDENT> if i ** 2 >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( 1 , int ( N ** 0.5 ) ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + i * j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( 1 , int ( N ** 0.5 ) ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <= N : <NEWLINE> <INDENT> ans [ i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
LIMIT = 1000000000000000000 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <COMMENT> <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> answer = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> answer *= a [ i ] <NEWLINE> if answer > LIMIT : <NEWLINE> <INDENT> if 0 in a [ i : ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> s = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = [ str ( i ) for i in range ( 1 , 14 ) ] <NEWLINE> c = [ x + <STRING> + y for x , y in itertools . product ( s , n ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c . remove ( input ( ) ) <NEWLINE> <DEDENT> if c != [ ] : print ( <STRING> . join ( c ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = [ 0 ] <NEWLINE> B_sum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_sum . append ( A_sum [ - 1 ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B_sum . append ( B_sum [ - 1 ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j_max = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( j_max , - 1 , - 1 ) : <NEWLINE> <INDENT> time = A_sum [ i ] + B_sum [ j ] <NEWLINE> if time > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j_max = j <NEWLINE> ans = max ( i + j , ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> min_cost = float ( <STRING> ) <NEWLINE> for bit in product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> skill = [ 0 ] * m <NEWLINE> for i , b in enumerate ( bit ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> cost += books [ i ] [ 0 ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> skill [ j ] += books [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if x <= min ( i for i in skill ) : <NEWLINE> <INDENT> min_cost = min ( min_cost , cost ) <NEWLINE> <DEDENT> <DEDENT> print ( min_cost if min_cost != float ( <STRING> ) else - 1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global node_chk <NEWLINE> global edge_chk <NEWLINE> global B <NEWLINE> global connect <NEWLINE> global value <NEWLINE> <NL> node_chk [ v ] = 1 <NEWLINE> connect [ v ] = value <NEWLINE> for x in B [ v ] : <NEWLINE> <INDENT> if ( node_chk [ x ] == 0 ) : <NEWLINE> <INDENT> dfs ( x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> B = [ [ ] for i in range ( n ) ] <COMMENT> <NEWLINE> edge_chk = [ [ ] for i in range ( n ) ] <NEWLINE> node_chk = [ 0 for i in range ( n ) ] <NEWLINE> connect = [ 0 for i in range ( n ) ] <NEWLINE> value = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B [ A [ 0 ] ] . append ( A [ 1 ] ) <NEWLINE> B [ A [ 1 ] ] . append ( A [ 0 ] ) <NEWLINE> edge_chk [ A [ 0 ] ] . append ( 0 ) <NEWLINE> edge_chk [ A [ 1 ] ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( node_chk [ i ] == 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i ) <NEWLINE> value += 1 <NEWLINE> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> start , target = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( connect [ start ] == connect [ target ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> def get_array ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> start = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> start = ( start * 10 + 7 ) % n <NEWLINE> if start == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> P = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> P [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( P [ i ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxint = 50 * N <NEWLINE> <NL> dp = [ [ [ 0 ] * ( maxint + 1 ) for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for xi , xe in enumerate ( x , 1 ) : <NEWLINE> <INDENT> for j in range ( xi + 1 ) : <NEWLINE> <INDENT> for k in range ( maxint + 1 ) : <NEWLINE> <INDENT> dp [ xi ] [ j ] [ k ] = dp [ xi - 1 ] [ j ] [ k ] <NEWLINE> <NL> if j >= 0 and k >= xe : <NEWLINE> <INDENT> dp [ xi ] [ j ] [ k ] += dp [ xi - 1 ] [ j - 1 ] [ k - xe ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res += dp [ N ] [ i ] [ i * A ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> par = [ i for i in range ( N ) ] <COMMENT> <NEWLINE> rank = [ 0 ] * N <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def find ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <COMMENT> <NEWLINE> y = find ( y ) <COMMENT> <NEWLINE> <COMMENT> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ x ] = y <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ y ] = x <COMMENT> <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> find ( i ) <NEWLINE> <DEDENT> c = Counter ( par ) <NEWLINE> c = c . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> print ( c ) <NEWLINE>
import random <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> ans = 0 <NEWLINE> a = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> res = - float ( <STRING> ) <NEWLINE> index = 0 <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> x = k <NEWLINE> tnplast = last <NEWLINE> tnplast [ x ] = i <NEWLINE> tnp = 0 <NEWLINE> tnp += s [ i - 1 ] [ x ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> tnp -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> if ( tnp > res ) : <NEWLINE> <INDENT> res = tnp <NEWLINE> index = k + 1 <NEWLINE> <DEDENT> <DEDENT> ans += res <NEWLINE> a . append ( index ) <NEWLINE> <NL> <DEDENT> def rec ( t ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> l = [ 0 ] * 26 <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> x = t [ i - 1 ] - 1 <NEWLINE> l [ x ] = i <NEWLINE> r += s [ i - 1 ] [ x ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> r -= c [ j ] * ( i - l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> x = random . randrange ( 1 , d + 1 ) <NEWLINE> y = random . randrange ( 1 , 27 ) <NEWLINE> t = a <NEWLINE> t [ x - 1 ] = y <NEWLINE> A = rec ( t ) <NEWLINE> if ( ans < A ) : <NEWLINE> <INDENT> a = t <NEWLINE> ans = A <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a , sep = <STRING> ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> tbl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tbl . append ( [ b , a ] ) <NEWLINE> <DEDENT> tbl . sort ( ) <NEWLINE> ans = saw = 0 <NEWLINE> seen = [ 0 ] * 101 <NEWLINE> for i in range ( 1 , 32 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i < tbl [ j ] [ 1 ] or tbl [ j ] [ 0 ] < i : continue <NEWLINE> if seen [ j ] : continue <NEWLINE> ans += 100 ; seen [ j ] = 1 ; saw += 1 <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> print ( ans + ( 31 - saw ) * 50 ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> sample_input = list ( range ( 3 ) ) <NEWLINE> sample_input [ 0 ] = <STRING> <NEWLINE> sample_input [ 1 ] = <STRING> <NEWLINE> sample_input [ 2 ] = <STRING> <NEWLINE> give_sample_input = None <NEWLINE> if give_sample_input is not None : <NEWLINE> <INDENT> sample_input_list = sample_input [ give_sample_input ] . split ( <STRING> ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sample_input_list . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> from collections import deque <NEWLINE> <NL> num_of_command = int ( input ( ) ) <NEWLINE> doubly_list = deque ( ) <NEWLINE> for n in range ( num_of_command ) : <NEWLINE> <INDENT> str_command = input ( ) <NEWLINE> if str_command == <STRING> : <NEWLINE> <INDENT> doubly_list . popleft ( ) <NEWLINE> continue <NEWLINE> <DEDENT> elif str_command == <STRING> : <NEWLINE> <INDENT> doubly_list . pop ( ) <NEWLINE> continue <NEWLINE> <DEDENT> command_name = str_command . split ( ) [ 0 ] <NEWLINE> command_obj = int ( str_command . split ( ) [ 1 ] ) <NEWLINE> if command_name == <STRING> : <NEWLINE> <INDENT> doubly_list . appendleft ( command_obj ) <NEWLINE> <DEDENT> elif command_name == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> doubly_list . remove ( command_obj ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> output = <STRING> <NEWLINE> for item in doubly_list : <NEWLINE> <INDENT> output += str ( item ) + <STRING> <NEWLINE> <DEDENT> output = output . rstrip ( ) <NEWLINE> print ( output ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( 1 , N // i + 1 ) : <NEWLINE> <INDENT> k = N - i * j <NEWLINE> if k > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> str1 = sys . stdin . read ( ) <NEWLINE> dict1 = { } <NEWLINE> for char in str1 . lower ( ) : <NEWLINE> <INDENT> if not char . isalpha ( ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dict1 . __contains__ ( char ) : <NEWLINE> <INDENT> dict1 [ char ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict1 [ char ] = 1 <NEWLINE> <DEDENT> <DEDENT> for char in string . ascii_lowercase : <NEWLINE> <INDENT> print ( char + <STRING> + ( str ( dict1 [ char ] ) if dict1 . __contains__ ( char ) else <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 ; <NEWLINE> for num in num_list : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in num_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> def f ( i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> b [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> def g ( i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i : <NEWLINE> <INDENT> s += b [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> ( n , q , * w ) , a , * t = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> b = [ 0 ] * - ~ n <NEWLINE> * map ( f , range ( 1 , n + 1 ) , a ) , <NEWLINE> for q , l , r in t : <NEWLINE> <INDENT> if q : w += g ( r ) - g ( l ) , <NEWLINE> else : f ( l + 1 , r ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , w ) ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
dic1 = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> dic2 = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> def to_digit ( ss ) : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> for s in ss : <NEWLINE> <INDENT> ret += dic1 [ s ] <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def to_alpha ( digit ) : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> ind = 0 <NEWLINE> end = len ( digit ) <NEWLINE> <NL> while ind + 5 < end : <NEWLINE> <INDENT> ret += dic2 [ digit [ ind : ind + 5 ] ] <NEWLINE> ind += 5 <NEWLINE> <NL> <DEDENT> if digit [ ind : ] : <NEWLINE> <INDENT> ret += dic2 [ digit [ ind : ] + <STRING> * ( 5 - end + ind ) ] <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( to_alpha ( to_digit ( input ( ) ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c . get ( i + 1 , <STRING> ) ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> a_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a_i . count ( 0 ) > 0 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> for x in a_i : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> card = [ list ( map ( int , i . rstrip ( ) . split ( ) ) ) for i in sys . stdin . readlines ( ) ] <NEWLINE> card = sorted ( card , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> A = sorted ( A ) <NEWLINE> i = 0 <NEWLINE> for b , c in card : <NEWLINE> <INDENT> for _ in range ( b ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif A [ i ] >= c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = c <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] = a <NEWLINE> B [ i ] = b <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> N_q , N_mod = divmod ( N , 2 ) <NEWLINE> if N_mod == 1 : <NEWLINE> <INDENT> ans = B [ N_q ] - A [ N_q ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B [ N_q - 1 ] - A [ N_q - 1 ] + B [ N_q ] - A [ N_q ] + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> k = int ( k ) <NEWLINE> ans = 0 <NEWLINE> <NL> if a > 0 and k > 0 and a <= k : <NEWLINE> <INDENT> k = k - a <NEWLINE> ans = ans + a <NEWLINE> <DEDENT> elif a > 0 and k > 0 and a > k : <NEWLINE> <INDENT> ans = ans + k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> if b > 0 and k > 0 and b <= k : <NEWLINE> <INDENT> k = k - b <NEWLINE> <DEDENT> elif b > 0 and k > 0 and b > k : <NEWLINE> <INDENT> k = 0 <NEWLINE> <NL> <DEDENT> if c > 0 and k > 0 and c <= k : <NEWLINE> <INDENT> k = k - c <NEWLINE> ans = ans - c <NEWLINE> <DEDENT> elif c > 0 and c > 0 and c > k : <NEWLINE> <INDENT> ans = ans - k <NEWLINE> k = 0 <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> l = read ( ) . decode ( ) . split ( ) <NEWLINE> c = Counter ( l ) <NEWLINE> <NL> max = c . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> ans = [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= max ] <NEWLINE> <NL> print ( <STRING> . join ( sorted ( ans ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> print ( 0 , - 1 ) ; exit ( ) <NEWLINE> <NL> <DEDENT> num_li = [ i ** 5 for i in range ( 1 , 1000 ) ] <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> a = num_li [ i ] <NEWLINE> if x - a in num_li : <NEWLINE> <INDENT> b = num_li . index ( x - a ) + 1 <NEWLINE> a = - ( num_li . index ( a ) + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if x + a in num_li : <NEWLINE> <INDENT> b = num_li . index ( x + a ) + 1 <NEWLINE> a = num_li . index ( a ) + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b , a ) <NEWLINE>
import sys <NEWLINE> import resource <NEWLINE> <NL> sys . setrecursionlimit ( 20000 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) ] <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> a -= 1 ; b -= 1 <NEWLINE> e [ a ] . append ( b ) ; e [ b ] . append ( a ) <NEWLINE> <DEDENT> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( c [ : - 1 ] ) ) <NEWLINE> visited = [ False for i in range ( n ) ] <NEWLINE> node = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> def dfs ( pos ) : <NEWLINE> <INDENT> global cnt , node , c <NEWLINE> if visited [ pos ] : return <NEWLINE> visited [ pos ] = True <NEWLINE> for p in e [ pos ] : <NEWLINE> <INDENT> dfs ( p ) <NEWLINE> <DEDENT> node [ pos ] = c [ cnt ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> . join ( map ( str , node ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * ( N - K + 1 ) <NEWLINE> a [ 0 ] = sum ( P [ : K ] ) <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] - P [ i - 1 ] + P [ i + K - 1 ] <NEWLINE> <NL> <DEDENT> print ( ( max ( a ) + K ) / 2 ) <NEWLINE>
x , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_set = set ( p ) <NEWLINE> flag = 0 <NEWLINE> if x not in p_set : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if x + count not in p_set : <NEWLINE> <INDENT> ans = x + count <NEWLINE> flag = 1 <NEWLINE> <DEDENT> if x - count not in p_set : <NEWLINE> <INDENT> ans = x - count <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> p . sort ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> d , cnt = 0 , 1 <NEWLINE> for li in l : <NEWLINE> <INDENT> d += li <NEWLINE> if d <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = input ( ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit <COMMENT> <NEWLINE> <NL> def imos ( n , a ) : <NEWLINE> <NL> <INDENT> l = np . zeros ( ( n + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <COMMENT> <NEWLINE> start = max ( 0 , i - ai ) <COMMENT> <NEWLINE> end = min ( n , i + ai + 1 ) <COMMENT> <NEWLINE> l [ start ] += 1 <COMMENT> <NEWLINE> l [ end ] -= 1 <NEWLINE> <DEDENT> return np . cumsum ( l ) [ : n ] <COMMENT> <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> a = imos ( n , a ) <NEWLINE> if a . min ( ) == n : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> latsum = sum ( a ) - a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * latsum <NEWLINE> ans %= int ( 1e9 + 7 ) <NEWLINE> latsum -= a [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> <NL> <NL> a , b = 0 , 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 2 <NEWLINE> break <NEWLINE> <DEDENT> elif i < len ( s ) - 2 : <NEWLINE> <INDENT> if s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 3 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> a = ( 4 * h * n ) - N * h - N * n <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = ( N * h * n ) / a <NEWLINE> if w . is_integer ( ) and 0 < w : <NEWLINE> <INDENT> print ( h , n , int ( w ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> dq = deque ( ) <NEWLINE> for _ in [ None ] * int ( input ( ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = s . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b in dq : <NEWLINE> <INDENT> dq . remove ( b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import queue <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> connedted_room_list = [ [ ] for i in range ( N ) ] <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> connedted_room_list [ A - 1 ] . append ( B - 1 ) <NEWLINE> connedted_room_list [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> answer_list = [ - 1 for i in range ( N ) ] <NEWLINE> answer_list [ 0 ] = 0 <NEWLINE> <NL> next_rooms_queue = queue . Queue ( ) <NEWLINE> next_rooms_queue . put ( 0 ) <NEWLINE> now_room = int ( ) <NEWLINE> while not next_rooms_queue . empty ( ) : <NEWLINE> <INDENT> now_room = next_rooms_queue . get ( ) <NEWLINE> for i in connedted_room_list [ now_room ] : <NEWLINE> <INDENT> if answer_list [ i ] == - 1 : <NEWLINE> <INDENT> answer_list [ i ] = now_room <NEWLINE> next_rooms_queue . put ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> is_escapable = True <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if answer_list [ i ] == - 1 : <NEWLINE> <INDENT> is_escapable = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_escapable : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( answer_list [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> BC = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> BC . append ( [ b , c ] ) <NEWLINE> <NL> <DEDENT> C = Counter ( A ) <NEWLINE> S = sum ( [ k * v for k , v in C . items ( ) ] ) <NEWLINE> for bc in BC : <NEWLINE> <INDENT> b = bc [ 0 ] <NEWLINE> c = bc [ 1 ] <NEWLINE> if b in C : <NEWLINE> <INDENT> bf = C [ b ] <NEWLINE> S += ( c - b ) * bf <NEWLINE> if c in C : <NEWLINE> <INDENT> C [ c ] += C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ c ] = C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def fn ( N ) : <NEWLINE> <INDENT> lis = [ ] <NEWLINE> i = 1 <NEWLINE> T = - 1 <NEWLINE> while i ** 2 <= 2 * N : <NEWLINE> <INDENT> lis . append ( i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> rtn = [ 0 ] * N <NEWLINE> for i , a in enumerate ( lis ) : <NEWLINE> <INDENT> for j in range ( i , len ( lis ) ) : <NEWLINE> <INDENT> b = lis [ j ] <NEWLINE> for k in range ( j , len ( lis ) ) : <NEWLINE> <INDENT> c = lis [ k ] <NEWLINE> tmp = a ** 2 + b ** 2 + c ** 2 <NEWLINE> if tmp % 2 == 0 and tmp <= 2 * N : <NEWLINE> <INDENT> x , y , z = ( a - b + c ) / 2 , ( a + b - c ) / 2 , ( b + c - a ) / 2 <NEWLINE> if x % 1 == 0 and y % 1 == 0 and z % 1 == 0 : <NEWLINE> <INDENT> if x > 0 and y > 0 and z > 0 : <NEWLINE> <INDENT> if x == y and y == z : rtn [ int ( tmp / 2 ) - 1 ] += 1 <NEWLINE> elif x == y or y == z or z == x : rtn [ int ( tmp / 2 ) - 1 ] += 3 <NEWLINE> else : rtn [ int ( tmp / 2 ) - 1 ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return rtn <NEWLINE> <NL> <NL> <DEDENT> lis = fn ( N ) <NEWLINE> for i in range ( N ) : print ( lis [ i ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> bCount = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> bCount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += bCount <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import collections as coun <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> def mod10 ( x ) : <NEWLINE> <INDENT> return ( 10 ** ( x % 224 ) ) % 2019 <NEWLINE> <DEDENT> dp = [ - 1 ] * n <NEWLINE> tmp = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> dp [ i ] = int ( s [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i + 1 ] + int ( s [ i ] ) * pow ( 10 , n - 1 - i , 2019 ) ) % 2019 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> p = - 1 <NEWLINE> for i in range ( len ( dp ) - 1 ) : <NEWLINE> <INDENT> if dp [ i ] == dp [ i + 1 ] : <NEWLINE> <INDENT> dp [ i ] = p <NEWLINE> p = p - 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> c = coun . Counter ( dp ) <NEWLINE> sum = 0 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> sum += v * ( v - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in dp : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if dp [ - 1 ] == 0 : <NEWLINE> <INDENT> sum = sum - 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def print_list ( lst ) : <NEWLINE> <INDENT> a = <STRING> . join ( list ( map ( str , lst ) ) ) <NEWLINE> print ( <STRING> + a ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> lst = [ [ [ 0 for w in range ( 10 ) ] for q in range ( 3 ) ] for e in range ( 4 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if ( i != 0 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print_list ( lst [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> p = math . pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> a = r * r * p <NEWLINE> b = 2 * r * p <NEWLINE> <NL> c = round ( a , 5 ) <NEWLINE> d = round ( b , 5 ) <NEWLINE> <NL> print ( str ( c ) + <STRING> + str ( d ) ) <NEWLINE> <NL>
import bisect <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import queue <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def read_values ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def read_index ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def read_list ( ) : return list ( read_values ( ) ) <NEWLINE> def read_lists ( N ) : return [ read_list ( ) for n in range ( N ) ] <NEWLINE> def init_dp1 ( init , N ) : return [ init for _ in range ( N ) ] <NEWLINE> def init_dp2 ( init , N , M ) : return [ [ init for _ in range ( M ) ] for _ in range ( N ) ] <NEWLINE> <NL> <NL> class V : <NEWLINE> <INDENT> def __init__ ( self , f , v = None ) : <NEWLINE> <INDENT> self . f = f <NEWLINE> self . v = v <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . v ) <NEWLINE> <NL> <DEDENT> def ud ( self , n ) : <NEWLINE> <INDENT> if n is None : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . v is None : <NEWLINE> <INDENT> self . v = n <NEWLINE> return <NEWLINE> <DEDENT> self . v = self . f ( self . v , n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> for B in range ( 1001 ) : <NEWLINE> <INDENT> A5 = X + B ** 5 <NEWLINE> A = int ( A5 ** 0.2 ) if A5 > 0 else int ( ( - A5 ) ** 0.2 ) * - 1 <NEWLINE> if A ** 5 == A5 : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> A5 = X - B ** 5 <NEWLINE> A = int ( A5 ** 0.2 ) if A5 > 0 else int ( ( - A5 ) ** 0.2 ) * - 1 <NEWLINE> if A ** 5 == A5 : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_s = sorted ( a ) <NEWLINE> b = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = b * a_s [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
string = input ( ) <NEWLINE> <NL> for s in string : <NEWLINE> <INDENT> if s . isupper ( ) : <NEWLINE> <INDENT> print ( s . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , bisect <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> <NL> def dijkstra ( s , n ) : <COMMENT> <NEWLINE> <INDENT> dist = [ inf ] * n <NEWLINE> hq = [ ( 0 , s ) ] <COMMENT> <NEWLINE> dist [ s ] = 0 <NEWLINE> seen = [ False ] * n <COMMENT> <NEWLINE> while hq : <NEWLINE> <INDENT> v = heappop ( hq ) [ 1 ] <COMMENT> <NEWLINE> seen [ v ] = True <NEWLINE> for to , cost in adj [ v ] : <COMMENT> <NEWLINE> <INDENT> if seen [ to ] == False and dist [ v ] + cost < dist [ to ] : <NEWLINE> <INDENT> dist [ to ] = dist [ v ] + cost <NEWLINE> heappush ( hq , ( dist [ to ] , to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> N = ni ( ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = na ( ) <NEWLINE> adj [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> adj [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = na ( ) <NEWLINE> ans = [ ] <NEWLINE> d = dijkstra ( K - 1 , N ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = na ( ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> ans . append ( d [ x ] + d [ y ] ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> from numba import njit , i8 <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = np . array ( [ int ( i ) - 1 for i in input ( ) . split ( ) ] , np . int64 ) <NEWLINE> c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int64 ) <NEWLINE> <NL> @ njit ( i8 ( i8 , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def calc_score ( x , p , c ) : <NEWLINE> <INDENT> n = p . size <NEWLINE> score = 0 <NEWLINE> score_list = np . zeros ( n , np . int64 ) <NEWLINE> cnt = 0 <NEWLINE> visit = [ 0 ] * n <NEWLINE> while not visit [ p [ x ] ] : <NEWLINE> <INDENT> x = p [ x ] <NEWLINE> visit [ x ] = 1 <NEWLINE> cnt += 1 <NEWLINE> if cnt <= k : <NEWLINE> <INDENT> score += c [ x ] <NEWLINE> score_list [ cnt - 1 ] = score <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return score_list [ : k ] . max ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if score > 0 : <NEWLINE> <INDENT> tmp = np . arange ( cnt ) <NEWLINE> return ( score_list [ tmp ] + ( ( k - 1 - tmp ) // cnt ) * score ) . max ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return score_list [ : cnt ] . max ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( calc_score ( i , p , c ) for i in range ( n ) ) <NEWLINE> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * 101 <NEWLINE> <NL> for i in P : <NEWLINE> <INDENT> A [ i ] = 1 <NEWLINE> <NL> <DEDENT> if A [ X ] == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if ( X - count ) >= 0 : <NEWLINE> <INDENT> if ( X - count ) < 101 : <NEWLINE> <INDENT> if A [ X - count ] == 0 : <NEWLINE> <INDENT> print ( X - count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> count = - count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = - count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> b = a <NEWLINE> ans += gcd ( a , b , c ) * 3 <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> b = c <NEWLINE> ans += gcd ( a , b , c ) * 3 <NEWLINE> <DEDENT> <DEDENT> print ( ans + sum ( [ i for i in range ( 1 , k + 1 ) ] ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( gcd2 , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> hit = 0 <NEWLINE> blow = 0 <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = line . split ( ) <NEWLINE> B = [ n for n in input ( ) . split ( ) ] <NEWLINE> for i in B : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> if A . index ( i ) == B . index ( i ) : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hit , blow ) <NEWLINE> <DEDENT>
from functools import lru_cache <NEWLINE> import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pair , setwise = True , True <NEWLINE> x , y = set ( ) , a [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if pair : <NEWLINE> <INDENT> ap = set ( prime_factorize ( i ) ) <NEWLINE> if len ( x & ap ) > 0 : <NEWLINE> <INDENT> pair = False <NEWLINE> <DEDENT> x |= ap <NEWLINE> <DEDENT> y = math . gcd ( y , i ) <NEWLINE> <DEDENT> if pair : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def prime_factorize ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> arr = [ ] <NEWLINE> <COMMENT> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> arr . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> for f in primes ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> while n % f == 0 : <NEWLINE> <INDENT> arr . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def primes ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if is_prime [ i ] ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def is_prime ( n : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> a = [ 0 ] * k <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> aa = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> a [ i ] = aa <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> l = len ( a [ i ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> s [ a [ i ] [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = b - 1 <NEWLINE> if x > n : <NEWLINE> <INDENT> x = n <NEWLINE> <NL> <DEDENT> result = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> s = int ( N / i ) + 1 <NEWLINE> for j in range ( s + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if N - i * j > 0 : <NEWLINE> <INDENT> result = result + j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 800 * N <NEWLINE> if N < 15 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> if 15 <= N < 30 : <NEWLINE> <INDENT> y = 200 <NEWLINE> <DEDENT> if 30 <= N < 45 : <NEWLINE> <INDENT> y = 400 <NEWLINE> <DEDENT> if 45 <= N < 60 : <NEWLINE> <INDENT> y = 600 <NEWLINE> <DEDENT> if 60 <= N < 75 : <NEWLINE> <INDENT> y = 800 <NEWLINE> <DEDENT> if 75 <= N < 90 : <NEWLINE> <INDENT> y = 1000 <NEWLINE> <DEDENT> if 90 <= N <= 100 : <NEWLINE> <INDENT> y = 1200 <NEWLINE> <DEDENT> print ( x - y ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <INDENT> for l in range ( 1 , k ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( p ) <NEWLINE> p . sort ( ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> a += p [ i ] <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if n < b - 1 : <NEWLINE> <INDENT> x = n <NEWLINE> ans = math . floor ( a * ( x % b ) / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> ans = math . floor ( a * ( x % b ) / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if H == 0 and W == 0 : exit ( ) <NEWLINE> for i in ( range ( H ) ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
I = input ( ) . split ( ) <NEWLINE> H = int ( I [ 0 ] ) <NEWLINE> W = int ( I [ 1 ] ) <NEWLINE> h = H <NEWLINE> w = W <NEWLINE> while H != 0 or W != 0 : <NEWLINE> <INDENT> while h > 0 : <NEWLINE> <INDENT> w = W <NEWLINE> while w > 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> w -= 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE> h -= 1 <NEWLINE> <DEDENT> I = input ( ) . split ( ) <NEWLINE> H = int ( I [ 0 ] ) <NEWLINE> W = int ( I [ 1 ] ) <NEWLINE> h = H <NEWLINE> w = W <NEWLINE> print ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> harry = np . array ( h ) <NEWLINE> ans = np . count_nonzero ( harry >= K ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> maL = 0 <NEWLINE> miR = N <NEWLINE> for g in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> maL = max ( maL , L ) <NEWLINE> miR = min ( miR , R ) <NEWLINE> <DEDENT> if maL <= miR : <NEWLINE> <INDENT> print ( miR - maL + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K < A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> if A <= K < A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> if A + B <= K <= A + B + C : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> flag = [ 0 ] * ( 10 ** 6 + 5 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> flag [ A [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if flag [ A [ i ] ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i > 0 and A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> flag [ A [ i ] ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> for num in range ( A [ i ] * 2 , A [ - 1 ] + 1 , A [ i ] ) : <NEWLINE> <INDENT> flag [ num ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = max ( t , c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> t = max ( t , c ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
x , k , d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> x = abs ( x ) <NEWLINE> <NL> a = int ( x / d ) <NEWLINE> <NL> <NL> if a > k : <NEWLINE> <INDENT> a = k <NEWLINE> <NL> <DEDENT> k -= a <NEWLINE> <NL> x -= a * d <NEWLINE> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> x = abs ( x - d ) <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
def Class ( x ) : <NEWLINE> <INDENT> if x <= 48.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 48.0 < x <= 51.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 51.0 < x <= 54.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 54.0 < x <= 57.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 57.0 < x <= 60.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 60.0 < x <= 64.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 64.0 < x <= 69.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 69.0 < x <= 75.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 75.0 < x <= 81.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 81.0 < x <= 91.0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x = float ( input ( ) ) <NEWLINE> Class ( x ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Li = [ [ ] for y in range ( n ) ] <NEWLINE> Li2 = [ ] <NEWLINE> a = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> Li [ x ] += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for x in range ( m ) : <NEWLINE> <INDENT> Li2 . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( m ) : <NEWLINE> <INDENT> a += Li [ x ] [ y ] * Li2 [ y ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE> a = 0 <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> h , w = inintm ( ) <NEWLINE> grid = [ ] <NEWLINE> now = [ 0 , 0 ] <NEWLINE> fw = 0 <NEWLINE> fh = 0 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> grid . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> while now != [ h - 1 , w - 1 ] : <NEWLINE> <INDENT> if now [ 0 ] == h - 1 : <NEWLINE> <INDENT> if fh == 0 and now [ 1 ] != 0 : <NEWLINE> <INDENT> if grid [ h - 1 ] [ now [ 1 ] + 1 ] == <STRING> and grid [ h - 1 ] [ now [ 1 ] - 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ h - 1 , now [ 1 ] + 1 ] <NEWLINE> fh = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if grid [ h - 1 ] [ now [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ h - 1 , now [ 1 ] + 1 ] <NEWLINE> fh = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif now [ 1 ] == w - 1 : <NEWLINE> <INDENT> if fw == 0 and now [ 0 ] != 0 : <NEWLINE> <INDENT> if grid [ now [ 0 ] + 1 ] [ w - 1 ] == <STRING> and grid [ now [ 0 ] - 1 ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] + 1 , w - 1 ] <NEWLINE> fw = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if grid [ now [ 0 ] + 1 ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] + 1 , w - 1 ] <NEWLINE> fw = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if grid [ now [ 0 ] + 1 ] [ now [ 1 ] ] == <STRING> and grid [ now [ 0 ] ] [ now [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] + 1 , now [ 1 ] ] <NEWLINE> <DEDENT> elif grid [ now [ 0 ] + 1 ] [ now [ 1 ] ] == <STRING> and grid [ now [ 0 ] ] [ now [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> now = [ now [ 0 ] , now [ 1 ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if fh == 0 and grid [ h - 1 ] [ w - 2 ] == <STRING> and ( h >= 2 and w >= 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ABCD = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> lst = [ i for i in range ( M ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for tmp in combinations_with_replacement ( lst , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> if tmp [ b - 1 ] - tmp [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ad_ls = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ad_ls [ a - 1 ] . append ( [ b - 1 , w ] ) <NEWLINE> ad_ls [ b - 1 ] . append ( [ a - 1 , w ] ) <NEWLINE> <NL> <DEDENT> cost_ls = [ 0 ] * n <NEWLINE> done_ls = [ 0 ] * n <NEWLINE> def dfs ( v , c ) : <NEWLINE> <INDENT> for new , cost in ad_ls [ v ] : <NEWLINE> <INDENT> if not done_ls [ new ] : <NEWLINE> <INDENT> cost_ls [ new ] = c + cost <NEWLINE> done_ls [ new ] = 1 <NEWLINE> dfs ( new , c + cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> color_ls = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> color_ls [ i ] = cost_ls [ i ] % 2 <NEWLINE> <NL> <DEDENT> for color in color_ls : <NEWLINE> <INDENT> print ( color ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> q = max ( x , y ) % min ( x , y ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> return [ min ( x , y ) , 0 ] <NEWLINE> <DEDENT> return gcd ( min ( x , y ) , q ) <NEWLINE> <NL> <DEDENT> print ( max ( gcd ( a , b ) ) ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for x in range ( 1 , int ( math . sqrt ( n + 1 ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( ( math . sqrt ( n + 1 ) ) ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( ( math . sqrt ( n + 1 ) ) ) + 1 ) : <NEWLINE> <INDENT> ans . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> counter = Counter ( ans ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( counter [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if b > n : <NEWLINE> <COMMENT> <NL> <INDENT> print ( a * n // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> x = 2 * b - 1 <NEWLINE> first = a * ( b - 1 ) // b <NEWLINE> second = ( a * x ) // b - a * ( x // b ) <NEWLINE> print ( first if first >= second else second ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def is_sankaku ( v ) : <NEWLINE> <INDENT> x = ( math . sqrt ( 8 * v + 1 ) - 1 ) / 2 <NEWLINE> return x == int ( x ) <NEWLINE> <NL> <DEDENT> def check ( lst ) : <NEWLINE> <INDENT> for i , v in enumerate ( lst ) : <NEWLINE> <INDENT> if v != i + 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif i == len ( lst ) - 1 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if not is_sankaku ( sum ( lst ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> result = - 1 <NEWLINE> for count in range ( 10000 ) : <NEWLINE> <INDENT> if check ( lst ) : <NEWLINE> <INDENT> result = count <NEWLINE> break <NEWLINE> <DEDENT> spam = len ( lst ) <NEWLINE> lst = [ x - 1 for x in lst if x - 1 > 0 ] <NEWLINE> lst . append ( spam ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> mod = 2019 <NEWLINE> cnt = [ 0 ] * mod <NEWLINE> x = 1 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> total = 0 <NEWLINE> for s in s : <NEWLINE> <INDENT> total += int ( s ) * x <NEWLINE> total %= mod <NEWLINE> cnt [ total ] += 1 <NEWLINE> x *= 10 <NEWLINE> x %= mod <NEWLINE> <NL> <NL> <DEDENT> ans = sum ( i * ( i - 1 ) // 2 for i in cnt ) <NEWLINE> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> n = 1000 - N <NEWLINE> if N == 2000 or N == 3000 or N == 4000 or N == 5000 or N == 6000 or N == 7000 or N == 8000 or N == 9000 or N == 10000 or N == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1000 < N : <NEWLINE> <INDENT> m = n * ( - 1 ) <NEWLINE> if m < 10 : <NEWLINE> <INDENT> print ( 1000 - m ) <NEWLINE> <DEDENT> elif m < 100 : <NEWLINE> <INDENT> print ( 1000 - ( int ( str ( m ) [ - 2 ] ) * 10 ) + ( int ( str ( m ) [ - 1 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( ( int ( str ( m ) [ - 3 ] ) * 100 ) + ( int ( str ( m ) [ - 2 ] ) * 10 ) + ( int ( str ( m ) [ - 1 ] ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pathes = { i : set ( ) for i in range ( 1 , n + 1 ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> pathes [ ai ] . add ( bi ) <NEWLINE> pathes [ bi ] . add ( ai ) <NEWLINE> <NL> <DEDENT> queue = deque ( ) <NEWLINE> queue . append ( 1 ) <NEWLINE> <NL> ans = [ None ] * n <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> if len ( queue ) == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> i = queue . popleft ( ) <NEWLINE> next_room = pathes [ i ] <NEWLINE> for j in next_room : <NEWLINE> <INDENT> if ans [ j - 1 ] == None : <NEWLINE> <INDENT> ans [ j - 1 ] = str ( i ) <NEWLINE> queue . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans [ 0 ] = <STRING> <NEWLINE> <NL> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> LIMIT = 10 ** 18 <NEWLINE> <NL> if 0 in set ( As ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for a in As : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > LIMIT : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = 1 <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ i ] != l [ i + 1 ] : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = b = - 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 2 <NEWLINE> break <NEWLINE> <DEDENT> elif i + 2 < n and s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 3 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
S = input ( ) <NEWLINE> mod = 2019 <NEWLINE> <NL> t = len ( S ) <NEWLINE> l = [ 0 ] * ( t + 1 ) <NEWLINE> for i in range ( t - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> l [ i ] = ( l [ i + 1 ] + int ( S [ i ] ) * pow ( 10 , t - i - 1 , mod ) ) % mod <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> <NL> def nC2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> l = list ( Counter ( l ) . values ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += nC2 ( i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x [ 0 ] > x [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x [ 0 ] < x [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> A = sorted ( readInts ( ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> cnt = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> dic [ i ] += 1 <NEWLINE> <DEDENT> A = list ( set ( A ) ) <NEWLINE> <COMMENT> <NL> is_prime = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( A ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if is_prime [ A [ i ] ] == True : <NEWLINE> <INDENT> for j in range ( 2 * A [ i ] , 10 ** 6 + 1 , A [ i ] ) : <NEWLINE> <INDENT> is_prime [ j ] = False <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> if A [ 0 ] == 1 : <NEWLINE> <INDENT> if dic [ 1 ] >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if is_prime [ a ] and not dic [ a ] >= 2 : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x < y : <NEWLINE> <INDENT> t = x <NEWLINE> x = y <NEWLINE> y = t <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f_dict = { <NEWLINE> <INDENT> 0 : 1 <NEWLINE> <DEDENT> } <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> if f_dict . get ( n ) : <NEWLINE> <INDENT> return f_dict . get ( n ) <NEWLINE> <DEDENT> return ( 3 + f ( n - 1 ) * 2 ) <NEWLINE> <NL> <NL> <DEDENT> patty_dict = { <NEWLINE> <INDENT> 0 : 1 <NEWLINE> <DEDENT> } <NEWLINE> def total_patty ( n ) : <NEWLINE> <INDENT> if patty_dict . get ( n ) : <NEWLINE> <INDENT> return patty_dict . get ( n ) <NEWLINE> <DEDENT> return ( 1 + 2 * total_patty ( n - 1 ) ) <NEWLINE> <NL> <DEDENT> def count_patty ( n , x ) : <NEWLINE> <INDENT> if n == 0 and x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif 1 <= x and x <= f ( n - 1 ) + 1 : <NEWLINE> <INDENT> return count_patty ( n - 1 , x - 1 ) <NEWLINE> <DEDENT> elif x == f ( n - 1 ) + 2 : <NEWLINE> <INDENT> return total_patty ( n - 1 ) + 1 <NEWLINE> <DEDENT> elif f ( n - 1 ) + 2 <= x and x <= 2 * f ( n - 1 ) + 2 : <NEWLINE> <INDENT> return total_patty ( n - 1 ) + 1 + count_patty ( n - 1 , x - f ( n - 1 ) - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return total_patty ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count_patty ( n , x ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( a ) <NEWLINE> <DEDENT> pattern = [ ] <NEWLINE> toBuy = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> toBuy = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> toBuy . append ( C [ j ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> pattern . append ( toBuy ) <NEWLINE> <COMMENT> <NL> <DEDENT> X = [ 0 ] * m <COMMENT> <NEWLINE> xsum = 0 <COMMENT> <NEWLINE> sum = 0 <COMMENT> <NEWLINE> min = 12000000 <NEWLINE> check = 0 <NEWLINE> for tb in pattern : <COMMENT> <NEWLINE> <INDENT> sum = 0 <NEWLINE> xsum = 0 <NEWLINE> X = [ 0 ] * m <NEWLINE> for c in tb : <NEWLINE> <INDENT> for j in range ( len ( c ) ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> sum += c [ j ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xsum += c [ j ] <COMMENT> <NEWLINE> X [ j - 1 ] += c [ j ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if xsum < x * m : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for eX in X : <NEWLINE> <INDENT> if eX < x : <NEWLINE> <INDENT> check = 1 <NEWLINE> <DEDENT> <DEDENT> if check == 1 : <NEWLINE> <INDENT> check = 0 <NEWLINE> continue <NEWLINE> <DEDENT> if sum < min : <NEWLINE> <INDENT> min = sum <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min == 12000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = sum ( a ) <NEWLINE> s = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> c = ( c + ( a [ i ] * ( sum - s ) ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li . append ( 0 ) <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> li [ x - 1 ] += 1 <NEWLINE> <DEDENT> for s in li : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> after_a = max ( 0 , a - k ) <NEWLINE> after_b = b <NEWLINE> if after_a == 0 : <NEWLINE> <INDENT> k -= a <NEWLINE> after_b = max ( 0 , b - k ) <NEWLINE> <NL> <DEDENT> print ( after_a , after_b ) <NEWLINE>
x , n = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if n : <NEWLINE> <INDENT> p = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if x in p : <NEWLINE> <INDENT> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if not x - i in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif not x + i in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , s , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> d = np . zeros ( s + 1 , dtype = np . int64 ) <NEWLINE> d [ 0 ] = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> p = d * 2 <NEWLINE> if x <= s : <NEWLINE> <INDENT> p [ x : ] += d [ : s - x + 1 ] <NEWLINE> <DEDENT> p %= mod <NEWLINE> d = p <NEWLINE> <DEDENT> print ( d [ - 1 ] ) <NEWLINE>
def inserts ( N ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> for n in N : <NEWLINE> <INDENT> print ( n , end = <STRING> ) <NEWLINE> if k < len ( N ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( N ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> v = N [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and N [ j ] > v : <NEWLINE> <INDENT> N [ j + 1 ] = N [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> N [ j + 1 ] = v <NEWLINE> k = 1 <NEWLINE> for n in N : <NEWLINE> <INDENT> print ( n , end = <STRING> ) <NEWLINE> if k < len ( N ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inserts ( numbers ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> dic = defaultdict ( bool ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dic [ a ] = not dic [ a ] <NEWLINE> <NL> <DEDENT> print ( sum ( dic . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , _ , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> print ( A - max ( [ 0 , K - A - B ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * ( 10 ** 4 + 1 ) <NEWLINE> import math <NEWLINE> import numpy <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> tmp = ( i + j + k ) ** 2 - ( i * j + j * k + i * k ) <NEWLINE> if tmp <= 10 ** 4 : <NEWLINE> <INDENT> A [ tmp ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in A [ 1 : N + 1 ] : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> a [ l [ i ] - 1 ] = a [ l [ i ] - 1 ] + 1 <NEWLINE> <DEDENT> for n in a : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = sum ( a ) - a [ 0 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * sum <NEWLINE> if ( i == n - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= a [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans %= 10 ** 9 + 7 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import Counter , defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CA = Counter ( A ) <NEWLINE> d = defaultdict ( lambda : False ) <NEWLINE> T = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> A . sort ( ) <NEWLINE> Z = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if CA [ a ] == 1 and not T [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if not Z [ a ] : <NEWLINE> <INDENT> Z [ a ] = True <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if i * a > 10 ** 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> T [ i * a ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Combination : <NEWLINE> <INDENT> def __init__ ( self , n_max , mod = 998244353 ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . modinv = self . make_modinv_list ( n_max ) <NEWLINE> self . fac , self . facinv = self . make_factorial_list ( n_max ) <NEWLINE> <NL> <DEDENT> def __call__ ( self , n , r ) : <NEWLINE> <INDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def make_factorial_list ( self , n ) : <NEWLINE> <INDENT> fac = [ 1 ] <NEWLINE> facinv = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fac . append ( fac [ i - 1 ] * i % self . mod ) <NEWLINE> facinv . append ( facinv [ i - 1 ] * self . modinv [ i ] % self . mod ) <NEWLINE> <DEDENT> return fac , facinv <NEWLINE> <NL> <DEDENT> def make_modinv_list ( self , n ) : <NEWLINE> <INDENT> modinv = [ 0 ] * ( n + 1 ) <NEWLINE> modinv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> modinv [ i ] = self . mod - self . mod // i * modinv [ self . mod % i ] % self . mod <NEWLINE> <DEDENT> return modinv <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> modPow = [ 1 ] <NEWLINE> mPow = 1 <NEWLINE> ans = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> if k == n - 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> comb = Combination ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> mPow = ( mPow * ( m - 1 ) ) % mod <NEWLINE> modPow . append ( mPow ) <NEWLINE> <DEDENT> for i in range ( n - 1 - k , n ) : <NEWLINE> <INDENT> ans += ( ( ( m * modPow [ i ] ) % mod ) * comb ( n - 1 , i ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> min = ( ( i - 1 ) * i ) // 2 <NEWLINE> max = ( ( 2 * n - i + 1 ) * i ) // 2 <NEWLINE> ans += max - min + 1 <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
A = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> A . append ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> def triangle_types ( X ) : <NEWLINE> <INDENT> num_of_normal = 0 <NEWLINE> num_of_right = 0 <NEWLINE> num_of_acute = 0 <NEWLINE> num_of_obtuse = 0 <NEWLINE> <NL> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> a , b , c = [ X [ i ] [ j ] for j in range ( 3 ) ] <NEWLINE> if ( a < b + c and b < a + c and c < a + b ) : <NEWLINE> <INDENT> num_of_normal += 1 <NEWLINE> if ( a ** 2 == b ** 2 + c ** 2 ) : <NEWLINE> <INDENT> num_of_right += 1 <NEWLINE> <DEDENT> elif ( a ** 2 < b ** 2 + c ** 2 ) : <NEWLINE> <INDENT> num_of_acute += 1 <NEWLINE> <DEDENT> elif ( a ** 2 > b ** 2 + c ** 2 ) : <NEWLINE> <INDENT> num_of_obtuse += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( num_of_normal , num_of_right , num_of_acute , num_of_obtuse ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> triangle_types ( A ) <NEWLINE> <DEDENT>
import queue <NEWLINE> <NL> nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> in_degs = [ 0 ] * nv <NEWLINE> q = queue . Queue ( ) <NEWLINE> outs = { } <NEWLINE> o = [ ] <NEWLINE> <NL> for _ in range ( ne ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if s in outs : outs [ s ] . append ( t ) <NEWLINE> else : outs [ s ] = [ t ] <NEWLINE> <NL> in_degs [ t ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( nv ) : <NEWLINE> <INDENT> if in_degs [ i ] == 0 : q . put ( i ) <NEWLINE> <NL> <DEDENT> while not q . empty ( ) : <NEWLINE> <INDENT> v = q . get ( ) <NEWLINE> o . append ( v ) <NEWLINE> <NL> if v in outs : <NEWLINE> <INDENT> for out in outs [ v ] : <NEWLINE> <INDENT> in_degs [ out ] -= 1 <NEWLINE> if in_degs [ out ] == 0 : q . put ( out ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> [ print ( v ) for v in o ] <NEWLINE>
from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_score = - 10 ** 10 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> val = c [ i ] <NEWLINE> <NL> next_i = p [ i ] - 1 <NEWLINE> while next_i != i : <NEWLINE> <INDENT> count += 1 <NEWLINE> val += c [ next_i ] <NEWLINE> next_i = p [ next_i ] - 1 <NEWLINE> <NL> <DEDENT> if val > 0 : <NEWLINE> <INDENT> loop_num = ( k // count - 1 ) <NEWLINE> tmp_score = loop_num * val <NEWLINE> max_score = max ( tmp_score , max_score ) <NEWLINE> num = k % count + count <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp_score = 0 <NEWLINE> num = min ( k , count ) <NEWLINE> <NL> <DEDENT> next_i = i <NEWLINE> for _ in range ( num ) : <NEWLINE> <INDENT> next_i = p [ next_i ] - 1 <NEWLINE> tmp_score += c [ next_i ] <NEWLINE> max_score = max ( tmp_score , max_score ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> k = I ( ) <NEWLINE> ans = - 1 <NEWLINE> a = [ 0 ] * ( k + 1 ) <NEWLINE> a [ 1 ] = 7 % k <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] * 10 + 7 ) % k <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<STRING> <NEWLINE> def factorize ( n ) : <NEWLINE> <INDENT> b = 2 <NEWLINE> fct = [ ] <NEWLINE> while b * b <= n : <NEWLINE> <INDENT> while n % b == 0 : <NEWLINE> <INDENT> n //= b <NEWLINE> fct . append ( b ) <NEWLINE> <DEDENT> b = b + 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> fct . append ( n ) <NEWLINE> <DEDENT> return fct <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> N , P = map ( int , pin ( ) . split ( ) ) <NEWLINE> l = factorize ( P ) <NEWLINE> d = list ( set ( l ) ) <NEWLINE> ans = 1 <NEWLINE> for i in d : <NEWLINE> <INDENT> t = l . count ( i ) <NEWLINE> if t >= N : <NEWLINE> <INDENT> ans *= i ** ( int ( t / N ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> def gcd_three ( a , b , c ) : <NEWLINE> <INDENT> r = math . gcd ( a , b ) <NEWLINE> if ( r == 1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return math . gcd ( r , c ) <NEWLINE> <DEDENT> <DEDENT> sum = 0 <NEWLINE> if ( K > 2 ) : <NEWLINE> <INDENT> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd_three ( a , b , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( a , b ) * 6 <NEWLINE> <DEDENT> <DEDENT> sum += K * ( K + 1 ) // 2 <NEWLINE> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> PRECISION_DIGITS = 9 <NEWLINE> cnt = { } <NEWLINE> <NL> <NL> for n in range ( N ) : <NEWLINE> <INDENT> tmpA = float ( input ( ) ) <NEWLINE> tmpA = round ( tmpA * ( 10 ** PRECISION_DIGITS ) ) <NEWLINE> <COMMENT> <NL> <NL> two = 0 <NEWLINE> five = 0 <NEWLINE> while ( tmpA % 2 ) == 0 : <NEWLINE> <INDENT> two += 1 <NEWLINE> tmpA /= 2 <NEWLINE> <DEDENT> while ( tmpA % 5 ) == 0 : <NEWLINE> <INDENT> five += 1 <NEWLINE> tmpA /= 5 <NEWLINE> <NL> <DEDENT> if ( two , five ) in cnt : <NEWLINE> <INDENT> cnt [ ( two , five ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ ( two , five ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> keys = sorted ( cnt . keys ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for t1 in keys : <NEWLINE> <INDENT> for t2 in keys : <NEWLINE> <COMMENT> <NL> <INDENT> if 18 <= t1 [ 0 ] + t2 [ 0 ] and 18 <= t1 [ 1 ] + t2 [ 1 ] : <NEWLINE> <INDENT> cnt1 = cnt [ ( t1 [ 0 ] , t1 [ 1 ] ) ] <NEWLINE> cnt2 = cnt [ ( t2 [ 0 ] , t2 [ 1 ] ) ] <NEWLINE> if t1 < t2 : <NEWLINE> <INDENT> ans += int ( cnt1 * cnt2 ) <NEWLINE> <DEDENT> elif t1 == t2 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += int ( cnt1 * ( cnt1 - 1 ) / 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K > A : <NEWLINE> <INDENT> M = K - A <NEWLINE> L = abs ( M - B ) <NEWLINE> print ( A - L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xp = [ i for i in x if i >= 0 ] <NEWLINE> xn = [ i for i in x if i < 0 ] <NEWLINE> xn . reverse ( ) <NEWLINE> lp = len ( xp ) <NEWLINE> ln = len ( xn ) <NEWLINE> if lp == 0 : <NEWLINE> <INDENT> print ( - xn [ K - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ln == 0 : <NEWLINE> <INDENT> print ( xp [ K - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> pc = min ( K , lp ) <NEWLINE> pp = xp [ pc - 1 ] <NEWLINE> if K > lp : <NEWLINE> <INDENT> nc = K - lp <NEWLINE> np = - xn [ nc - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nc = 0 <NEWLINE> np = 0 <NEWLINE> <DEDENT> ans = pp + np + min ( pp , np ) <NEWLINE> for i in range ( pc - 1 ) : <NEWLINE> <INDENT> if nc == ln : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pp = xp [ pc - i - 2 ] <NEWLINE> np = - xn [ nc ] <NEWLINE> nc += 1 <NEWLINE> ans = min ( ans , pp + np + min ( pp , np ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def dotes ( S , K ) : <NEWLINE> <INDENT> if K == len ( S ) or len ( S ) < K : <NEWLINE> <INDENT> return S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S [ : K ] <NEWLINE> S = S + <STRING> <NEWLINE> return S <NEWLINE> <DEDENT> <DEDENT> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( dotes ( S , K ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> if n > 3 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> ans += <STRING> . join ( a [ : : - 2 ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> ans += <STRING> + <STRING> . join ( a [ 0 : : 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> + <STRING> . join ( a [ 1 : : 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( a [ i ] ) <NEWLINE> ans . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> h = int ( a // 3600 ) <NEWLINE> m = int ( ( a % 3600 ) // 60 ) <NEWLINE> s = int ( ( a % 3600 ) % 60 ) <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> d [ s ] = 0 <NEWLINE> <NL> <DEDENT> print ( len ( d ) ) <NEWLINE>
def check ( a , b , H , L ) : <NEWLINE> <NL> <NL> <INDENT> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> L [ a - 1 ] = 0 <NEWLINE> <DEDENT> if H [ b - 1 ] <= H [ a - 1 ] : <NEWLINE> <INDENT> L [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> count = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> check ( a , b , H , L ) <NEWLINE> <NL> <DEDENT> for i in L : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> if 2 * ( ( x + 1 ) ** 2 ) + 4 > 2 * N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> if ( ( x + y ) ** 2 + ( y + 1 ) ** 2 + ( 1 + x ) ** 2 ) > 2 * N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , 100 ) : <NEWLINE> <COMMENT> <NL> <INDENT> score = ( ( x + y ) ** 2 + ( y + z ) ** 2 + ( z + x ) ** 2 ) // 2 <NEWLINE> if score > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ score ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bs = [ ls [ i ] - i - 1 for i in range ( n ) ] <NEWLINE> bs . sort ( ) <NEWLINE> <COMMENT> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> a = round ( n / 2 ) <NEWLINE> <COMMENT> <NL> can = [ bs [ a ] , bs [ a - 1 ] , math . floor ( ( bs [ a ] + bs [ a - 1 ] ) / 2 ) , math . ceil ( ( bs [ a ] + bs [ a - 1 ] ) / 2 ) ] <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> can = [ bs [ 0 ] , bs [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = math . floor ( n / 2 ) <NEWLINE> <COMMENT> <NL> can = [ bs [ a + 1 ] , bs [ a - 1 ] , bs [ a ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = 10 ** 27 <NEWLINE> for k in can : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for kn in bs : <NEWLINE> <INDENT> ans += abs ( kn - k ) <NEWLINE> <COMMENT> <NL> <DEDENT> result = min ( result , ans ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = set ( ) <NEWLINE> Hlis = [ 0 ] * H <NEWLINE> Wlis = [ 0 ] * W <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> Ch , Cm = map ( int , input ( ) . split ( ) ) <NEWLINE> Hlis [ Ch - 1 ] += 1 <NEWLINE> Wlis [ Cm - 1 ] += 1 <NEWLINE> lis . add ( ( Ch , Cm ) ) <NEWLINE> <NL> <DEDENT> Hmax = max ( Hlis ) <NEWLINE> Hidx = [ i + 1 for i , v in enumerate ( Hlis ) if v == Hmax ] <NEWLINE> Wmax = max ( Wlis ) <NEWLINE> Widx = [ i + 1 for i , v in enumerate ( Wlis ) if v == Wmax ] <NEWLINE> <NL> for i in range ( len ( Hidx ) ) : <NEWLINE> <INDENT> for j in range ( len ( Widx ) ) : <NEWLINE> <INDENT> if ( Hidx [ i ] , Widx [ j ] ) not in lis : <NEWLINE> <INDENT> print ( Hmax + Wmax ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( Hmax + Wmax - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> li = [ ] <NEWLINE> for line in stdin : <NEWLINE> <INDENT> compress = False <NEWLINE> num = 1 <NEWLINE> for c in line : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> compress = True <NEWLINE> <DEDENT> elif compress : <NEWLINE> <INDENT> compress = False <NEWLINE> num = int ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( c * num ) <NEWLINE> num = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( li ) , end = <STRING> ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( n , kd , precalc_x , precalc_y ) : <NEWLINE> <INDENT> ans = np . full ( n + 1 , 10 ** 18 , dtype = np . int64 ) <NEWLINE> <NL> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> k = kd [ bit ] <NEWLINE> v = bit <NEWLINE> while v : <NEWLINE> <INDENT> ans [ k ] = min ( ans [ k ] , np . minimum ( precalc_x [ v ] , precalc_y [ v ^ bit ] ) . sum ( ) ) <NEWLINE> v = ( v - 1 ) & bit <NEWLINE> <DEDENT> ans [ k ] = min ( ans [ k ] , np . minimum ( precalc_x [ 0 ] , precalc_y [ bit ] ) . sum ( ) ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> n = inp [ 0 ] <NEWLINE> xxx = inp [ 1 : : 3 ] <NEWLINE> yyy = inp [ 2 : : 3 ] <NEWLINE> ppp = inp [ 3 : : 3 ] <NEWLINE> <NL> bit_d = ( ( ( np . arange ( 1 << n ) [ : , None ] & ( 1 << np . arange ( n ) ) ) ) > 0 ) . astype ( np . int64 ) <NEWLINE> precalc_x = abs ( ( xxx [ None , : ] * bit_d ) [ ... , None ] - xxx [ None , None , : ] ) . min ( axis = 1 ) * ppp [ None , : ] <NEWLINE> precalc_y = abs ( ( yyy [ None , : ] * bit_d ) [ ... , None ] - yyy [ None , None , : ] ) . min ( axis = 1 ) * ppp [ None , : ] <NEWLINE> kd = bit_d . sum ( axis = 1 ) <NEWLINE> <NL> ans = solve ( n , kd , precalc_x , precalc_y ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> K = INT ( ) <NEWLINE> <NL> tmp = 7 <NEWLINE> ans = 1 <NEWLINE> p = 1 <NEWLINE> mo = tmp % K <NEWLINE> checked = [ 0 ] * ( K + 1 ) <NEWLINE> checked [ mo ] = 1 <NEWLINE> while mo != 0 : <NEWLINE> <INDENT> mo += 7 * pow ( 10 , p , K ) <NEWLINE> mo %= K <NEWLINE> p += 1 <NEWLINE> if checked [ mo ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> checked [ mo ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> def solve1 ( N , K , heights ) : <NEWLINE> <INDENT> heights += [ INF ] * K <NEWLINE> costs = [ INF ] * ( N + K ) <NEWLINE> costs [ 0 ] = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> newcost = costs [ i ] + abs ( heights [ i + k ] - heights [ i ] ) <NEWLINE> if newcost < costs [ i + k ] : <NEWLINE> <INDENT> costs [ i + k ] = newcost <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return costs [ N - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , K , heights ) : <NEWLINE> <INDENT> costs = [ 0 ] * N <NEWLINE> costs [ 0 ] = 0 <NEWLINE> costs [ 1 ] = abs ( heights [ 1 ] - heights [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> costs [ i ] = min ( <NEWLINE> <INDENT> costs [ j ] + abs ( heights [ i ] - heights [ j ] ) <NEWLINE> for j in range ( max ( i - K , 0 ) , i ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> return costs [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def solve3 ( N , heights ) : <NEWLINE> <INDENT> costs = [ None ] * N <NEWLINE> costs [ 0 ] = 0 <NEWLINE> costs [ 1 ] = abs ( heights [ 1 ] - heights [ 0 ] ) <NEWLINE> <NL> def get_cost ( i ) : <NEWLINE> <INDENT> if costs [ i ] != None : <NEWLINE> <INDENT> return costs [ i ] <NEWLINE> <NL> <DEDENT> c = min ( <NEWLINE> <INDENT> get_cost ( i - 2 ) + abs ( heights [ i ] - heights [ i - 2 ] ) , <NEWLINE> get_cost ( i - 1 ) + abs ( heights [ i ] - heights <NEWLINE> <INDENT> [ i - 1 ] ) , <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> costs [ i ] = c <NEWLINE> return c <NEWLINE> <NL> <DEDENT> return get_cost ( N - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( N , K , heights ) ) <NEWLINE> <NL> <NL> <DEDENT> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( arr , arr [ i ] + arr [ j ] ) <NEWLINE> if k > j : <NEWLINE> <INDENT> ans += k - j - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> c = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> ans += c - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> x = 7 % k <NEWLINE> cnt = 1 <NEWLINE> <NL> while 10000 : <NEWLINE> <INDENT> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> x = x * 10 + 7 <NEWLINE> x = x % k <NEWLINE> <NL> cnt += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> cnt = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for a in range ( 1 , n ) : <NEWLINE> <INDENT> j = i + a <NEWLINE> k = j + a <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
class Gcd : <NEWLINE> <NL> <INDENT> def __init__ ( self , K ) : <NEWLINE> <INDENT> self . table = [ [ None ] * K for i in range ( K ) ] <NEWLINE> return <NEWLINE> <NL> <DEDENT> def gcd ( self , x , y ) : <NEWLINE> <INDENT> if self . table [ x - 1 ] [ y - 1 ] is not None : <NEWLINE> <INDENT> return self . table [ x - 1 ] [ y - 1 ] <NEWLINE> <NL> <DEDENT> if x == y : <NEWLINE> <INDENT> self . table [ x - 1 ] [ y - 1 ] = x <NEWLINE> return x <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> z = x % y <NEWLINE> if z == 0 : <NEWLINE> <INDENT> self . table [ x - 1 ] [ y - 1 ] = y <NEWLINE> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = self . gcd ( z , y ) <NEWLINE> self . table [ x - 1 ] [ y - 1 ] = z <NEWLINE> return z <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return self . gcd ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def quest_c ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> gcd = Gcd ( K ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = gcd . gcd ( a , b ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> sum += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd . gcd ( d , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> quest_c ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mini = 0 <NEWLINE> maxi = 10 ** 9 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if mini < l : <NEWLINE> <INDENT> mini = l <NEWLINE> <DEDENT> if r < maxi : <NEWLINE> <INDENT> maxi = r <NEWLINE> <DEDENT> <DEDENT> t = maxi - mini + 1 <NEWLINE> if maxi < mini : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> S = list ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> right_flag = False <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> and right_flag is False : <NEWLINE> <INDENT> right_index = i <NEWLINE> right_flag = True <NEWLINE> <DEDENT> elif s == <STRING> and right_flag : <NEWLINE> <INDENT> right_flag = False <NEWLINE> cnt = i - right_index <NEWLINE> odd = cnt // 2 <NEWLINE> even = cnt - odd <NEWLINE> ans [ i - 1 ] += even <NEWLINE> ans [ i ] += odd <NEWLINE> <DEDENT> <DEDENT> left_flag = False <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] , 1 ) : <NEWLINE> <INDENT> if s == <STRING> and left_flag is False : <NEWLINE> <INDENT> left_index = i <NEWLINE> left_flag = True <NEWLINE> <DEDENT> elif s == <STRING> and left_flag : <NEWLINE> <INDENT> left_flag = False <NEWLINE> cnt = i - left_index <NEWLINE> odd = cnt // 2 <NEWLINE> even = cnt - odd <NEWLINE> ans [ - i + 1 ] += even <NEWLINE> ans [ - i ] += odd <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ( A [ i ] , 1 ) for i in range ( N ) ] <NEWLINE> <NL> changes = [ None ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> changes [ i ] = ( c , b ) <NEWLINE> <NL> <DEDENT> allVals = A + changes <NEWLINE> <NL> allVals . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> i = 0 <NEWLINE> j = - 1 <NEWLINE> res = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j += 1 <NEWLINE> res += allVals [ j ] [ 0 ] * allVals [ j ] [ 1 ] <NEWLINE> i += allVals [ j ] [ 1 ] <NEWLINE> <NL> if i >= N : <NEWLINE> <INDENT> res -= allVals [ j ] [ 0 ] * ( i - N ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> print ( math . factorial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if set ( t ) & set ( s ) == set ( t ) : <NEWLINE> <INDENT> n = - 1 <NEWLINE> c = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> n = s . find ( i , n + 1 ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> n = s . find ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( n + len ( s ) * c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> count = Counter ( A ) <NEWLINE> <NL> s = 0 <NEWLINE> for c in list ( count . values ( ) ) : <NEWLINE> <INDENT> s += c * ( c - 1 ) / 2 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> n = count [ a ] <NEWLINE> ans = s - n * ( n - 1 ) / 2 + ( n - 1 ) * ( n - 2 ) / 2 <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n == 2 or n == 3 or n == 5 or n == 7 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> print ( len ( [ x for x in A if is_prime ( x ) ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> list = [ ] <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> U = s [ i : i + len ( t ) ] <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if U [ j ] != t [ j ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> list . append ( n ) <NEWLINE> <DEDENT> print ( min ( list ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 999999999999999999 <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> t = [ 0 ] * m <NEWLINE> temp = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> temp = temp + a [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> t [ k ] = t [ k ] + a [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( t ) >= x : <NEWLINE> <INDENT> ans = min ( ans , temp ) <NEWLINE> <DEDENT> <DEDENT> if ans == 999999999999999999 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> d = [ <STRING> ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 6 ) : <NEWLINE> <INDENT> for k in range ( len ( d ) ) : <NEWLINE> <INDENT> if s [ i : j ] not in d and s [ i : j ] < d [ k ] : <NEWLINE> <INDENT> d . insert ( k , s [ i : j ] ) <NEWLINE> if len ( d ) > 5 : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> graph [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K -= 1 <NEWLINE> query = [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <NL> seen = { K } <NEWLINE> v = [ K ] <NEWLINE> distfromK = [ 0 ] * N <NEWLINE> while len ( v ) != 0 : <COMMENT> <NEWLINE> <INDENT> for nv in graph [ v [ 0 ] ] : <NEWLINE> <INDENT> if nv [ 0 ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> distfromK [ nv [ 0 ] ] = distfromK [ v [ 0 ] ] + nv [ 1 ] <NEWLINE> v . append ( nv [ 0 ] ) <NEWLINE> seen . add ( nv [ 0 ] ) <NEWLINE> <DEDENT> v . pop ( 0 ) <NEWLINE> <NL> <DEDENT> for q in query : <NEWLINE> <INDENT> print ( distfromK [ q [ 0 ] - 1 ] + distfromK [ q [ 1 ] - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if i + k < n : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bc = sorted ( bc , key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> sub = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sub += [ bc [ i ] [ 1 ] ] * bc [ i ] [ 0 ] <NEWLINE> if len ( sub ) > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += sub <NEWLINE> <NL> print ( sum ( sorted ( A , reverse = True ) [ : n ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = str ( input ( ) ) <NEWLINE> list [ A ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( list ) ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> height = 0 <NEWLINE> res = 1 <NEWLINE> def checkF ( k , x ) : <NEWLINE> <INDENT> if k > x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> height += List [ i ] <NEWLINE> res += 1 <NEWLINE> if checkF ( height , X ) : <NEWLINE> <INDENT> res = res - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> area = a * b <NEWLINE> length = 2 * ( a + b ) <NEWLINE> <NL> print ( area , end = <STRING> ) <NEWLINE> print ( length ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> dp = [ 0 ] * a [ n - 1 ] <NEWLINE> ans = 0 <NEWLINE> temp2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if temp2 == a [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> temp2 = 0 <NEWLINE> <DEDENT> if dp [ a [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> temp = a [ i ] <NEWLINE> temp2 = a [ i ] <NEWLINE> while temp <= a [ n - 1 ] : <NEWLINE> <INDENT> dp [ temp - 1 ] = 1 <NEWLINE> temp = temp + a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
