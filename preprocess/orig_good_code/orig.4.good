x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n , m = ( 2 * x - y ) / 3 , ( 2 * y - x ) / 3 <NEWLINE> ans = 0 <NEWLINE> if n >= 0 and m >= 0 : <NEWLINE> <INDENT> n , m = int ( n ) , int ( m ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( min ( m , n ) ) : <NEWLINE> <INDENT> ans = ans * ( n + m - i ) % mod <NEWLINE> ans *= pow ( i + 1 , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if A [ i ] != A [ i + 1 ] or A [ i ] != i + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ans * 2 % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , N , 2 ) : <NEWLINE> <INDENT> if A [ i ] != A [ i + 1 ] or A [ i ] != i + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ans * 2 % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> def dfs ( node ) : <NEWLINE> <INDENT> for adjnode in edges [ node ] : <NEWLINE> <INDENT> if colors [ adjnode [ 0 ] ] == - 1 : <NEWLINE> <INDENT> if adjnode [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> colors [ adjnode [ 0 ] ] = colors [ node ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> colors [ adjnode [ 0 ] ] = colors [ node ] ^ 1 <NEWLINE> <DEDENT> dfs ( adjnode [ 0 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> edges = { e : [ ] for e in range ( n ) } <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edges [ u ] . append ( ( v , w ) ) <NEWLINE> edges [ v ] . append ( ( u , w ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> colors = [ - 1 ] * n <NEWLINE> colors [ 0 ] = 0 <NEWLINE> dfs ( 0 ) <NEWLINE> <COMMENT> <NL> print ( * colors , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w , h0 , w0 = map ( int , input ( ) . split ( ) ) <NEWLINE> if h0 == w0 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x , y = h // h0 , w // w0 <NEWLINE> a1cnt = h0 * w0 - 1 <NEWLINE> a1sum , a2sum = h * w - x * y , x * y <NEWLINE> a1 = ( ( pow ( 10 , 9 ) - 1 ) // a1cnt ) <NEWLINE> a2 = - ( a1 * a1cnt + 1 ) <NEWLINE> asum = a1 * a1sum + a2 * a2sum <NEWLINE> print ( <STRING> if asum > 0 else <STRING> ) <NEWLINE> if asum > 0 : <NEWLINE> <INDENT> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> a = [ 0 ] * w <NEWLINE> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> a [ j - 1 ] = a2 if i % h0 == j % w0 == 0 else a1 <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <DEDENT> <DEDENT>
from heapq import heapify , heappush , heappop <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - x for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapify ( A ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = - heappop ( A ) <NEWLINE> <COMMENT> <NL> tmp = tmp // 2 <NEWLINE> <COMMENT> <NL> heappush ( A , - tmp ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <NL> <DEDENT> ans = abs ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> s = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> str_list = set ( ) <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> if j > len ( s ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> str_list . add ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> str_list = list ( str_list ) <NEWLINE> str_list . sort ( ) <NEWLINE> print ( str_list [ K - 1 ] ) <NEWLINE> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> fr = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> fr [ a ] . append ( b ) <NEWLINE> fr [ b ] . append ( a ) <NEWLINE> <DEDENT> def dfs ( fr , cur , parent , index , li ) : <NEWLINE> <INDENT> children = fr [ cur ] <NEWLINE> for chi in children : <NEWLINE> <INDENT> if chi == parent or used [ chi ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ chi ] = index <NEWLINE> li . append ( chi ) <NEWLINE> dfs ( fr , chi , cur , index , li ) <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> used = [ - 1 ] * N <COMMENT> <NEWLINE> renketu = [ ] <NEWLINE> index = 0 <NEWLINE> fr [ a ] . remove ( b ) <NEWLINE> fr [ b ] . remove ( a ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if used [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li = [ j ] <NEWLINE> used [ j ] = index <NEWLINE> dfs ( fr , j , - 1 , index , li ) <NEWLINE> index += 1 <NEWLINE> renketu . append ( li ) <NEWLINE> <DEDENT> if len ( renketu ) != 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> fr [ a ] . append ( b ) <NEWLINE> fr [ b ] . append ( a ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n > m // 2 : <NEWLINE> <INDENT> print ( m // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> c = n % ( m // 2 ) <NEWLINE> d = m - 2 * c <NEWLINE> c += d // 4 <NEWLINE> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ P [ 0 ] ] <NEWLINE> for i in P [ 1 : ] : <NEWLINE> <INDENT> if i < Q [ - 1 ] : <NEWLINE> <INDENT> Q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( Q ) ) <NEWLINE>
import numpy as np <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def fft_convolve ( f , g ) : <NEWLINE> <INDENT> Lf , Lg = f . shape [ - 1 ] , g . shape [ - 1 ] <NEWLINE> L = Lf + Lg - 1 <NEWLINE> fft_len = 1 << L . bit_length ( ) <NEWLINE> fh , fl = f >> 15 , f & ( 1 << 15 ) - 1 <NEWLINE> gh , gl = g >> 15 , g & ( 1 << 15 ) - 1 <NEWLINE> def conv ( f , g ) : <NEWLINE> <INDENT> Ff = np . fft . rfft ( f , fft_len ) <NEWLINE> Fg = np . fft . rfft ( g , fft_len ) <NEWLINE> h = np . fft . irfft ( Ff * Fg ) <NEWLINE> return np . rint ( h ) [ ... , : L ] . astype ( np . int64 ) % MOD <NEWLINE> <DEDENT> x = conv ( fl , gl ) <NEWLINE> z = conv ( fh , gh ) <NEWLINE> y = conv ( fl + fh , gl + gh ) - x - z <NEWLINE> return ( x + ( y << 15 ) + ( z << 30 ) ) % MOD <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Rob = list ( s . split ( <STRING> ) ) <NEWLINE> <NL> X = [ len ( r ) for r in Rob [ : : 2 ] ] <NEWLINE> Y = [ len ( r ) for r in Rob [ 1 : : 2 ] ] <NEWLINE> <NL> if x < 0 : <NEWLINE> <INDENT> y = abs ( y ) <NEWLINE> Xst = X [ 0 ] <NEWLINE> X = sorted ( X [ 1 : ] ) <NEWLINE> if abs ( x - Xst ) <= sum ( X ) and y <= sum ( Y ) : <NEWLINE> <INDENT> f = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for i in X : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * i + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> f = np . convolve ( f , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagX = f [ abs ( x - Xst ) + sum ( X ) ] <NEWLINE> g = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for j in Y : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * j + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> g = np . convolve ( g , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagY = g [ y + sum ( Y ) ] <NEWLINE> if FlagX and FlagY : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x , y = abs ( x ) , abs ( y ) <NEWLINE> if x <= sum ( X ) and y <= sum ( Y ) : <NEWLINE> <INDENT> f = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for i in X : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * i + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> f = np . convolve ( f , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagX = f [ x + sum ( X ) ] <NEWLINE> g = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for j in Y : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * j + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> g = np . convolve ( g , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagY = g [ y + sum ( Y ) ] <NEWLINE> if FlagX and FlagY : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 998244353 <NEWLINE> r = range <NEWLINE> f = [ 1 ] <NEWLINE> for i in r ( k ) : f += [ - ~ i * f [ i ] % p ] <NEWLINE> a = 0 <NEWLINE> for i in r ( n - 1 , k ) : a += f [ k - 1 ] * pow ( f [ i ] * f [ k - 1 - i ] , - 1 , p ) <NEWLINE> print ( a % p ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for X in range ( K + 1 ) : <NEWLINE> <INDENT> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> Z = S - X - Y <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> ac = Counter ( A ) <NEWLINE> <NL> td = dict ( ) <NEWLINE> for k , v in ac . items ( ) : <NEWLINE> <INDENT> if v % 2 == 0 : <NEWLINE> <INDENT> td [ k ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> td [ k ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> two = 0 <NEWLINE> for k , v in td . items ( ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if two % 2 == 0 : <NEWLINE> <INDENT> ans += two <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two -= 1 <NEWLINE> ans += two <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> from itertools import combinations <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mn = 10 ** 18 <NEWLINE> for B in combinations ( range ( 1 , N ) , K - 1 ) : <COMMENT> <NEWLINE> <INDENT> mx = A [ 0 ] <COMMENT> <NEWLINE> score = 0 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> if n in B : <COMMENT> <NEWLINE> <INDENT> if A [ n ] <= mx : <COMMENT> <NEWLINE> <INDENT> mx += 1 <NEWLINE> score += ( mx - A [ n ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> mx = A [ n ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mx = max ( mx , A [ n ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> mn = min ( mn , score ) <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> from scipy . sparse . csgraph import csgraph_from_dense <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> G = [ [ INF ] * ( N + 1 ) for n in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] [ b ] = c <NEWLINE> G [ b ] [ a ] = c <NEWLINE> <DEDENT> G = csgraph_from_dense ( G , null_value = INF ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> Queries = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> Queries . append ( ( s , t ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> cost = floyd_warshall ( G ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> no_refuel = [ [ 1 if x <= L else INF for x in c ] for c in cost ] <NEWLINE> no_refuel = csgraph_from_dense ( no_refuel , null_value = INF ) <NEWLINE> refuel_count = floyd_warshall ( no_refuel ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for s , t in Queries : <NEWLINE> <INDENT> d = refuel_count [ s ] [ t ] <NEWLINE> ans . append ( int ( d - 1 ) if d != INF else - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def h ( temp ) : <NEWLINE> <INDENT> if temp [ 0 ] == <STRING> : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> elif temp [ 0 ] == <STRING> : <NEWLINE> <INDENT> if temp [ 2 ] == <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def H ( temp , y , a ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> if a == 0 or a == 2 : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if y [ a ] [ 4 - j ] != temp [ 0 ] : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> temp . remove ( temp [ 0 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> for j in range ( 6 ) : <NEWLINE> <INDENT> if y [ a ] [ 5 - j ] != temp [ 0 ] : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> temp . remove ( temp [ 0 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 7 ) : <NEWLINE> <INDENT> if y [ a ] [ 6 - j ] != temp [ 0 ] : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> temp . remove ( temp [ 0 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> s = input ( ) <NEWLINE> y = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> temp = [ ] <NEWLINE> t = [ ] <NEWLINE> k = len ( s ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> temp . append ( s [ k - i - 1 ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> while len ( temp ) != 0 and c == 1 : <NEWLINE> <INDENT> a = h ( temp ) <NEWLINE> c = H ( temp , y , a ) <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> x = <STRING> <NEWLINE> a_idx = 0 <NEWLINE> b_idx = 0 <NEWLINE> c_idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if a_idx == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = str ( a [ a_idx ] ) <NEWLINE> a_idx += 1 <NEWLINE> <DEDENT> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if b_idx == len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = str ( b [ b_idx ] ) <NEWLINE> b_idx += 1 <NEWLINE> <DEDENT> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if c_idx == len ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = str ( c [ c_idx ] ) <NEWLINE> c_idx += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> <NL> av = s / 2 <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x += A [ i ] <NEWLINE> <NL> if x < av < x + A [ i + 1 ] : <NEWLINE> <NL> <INDENT> y = s - x - A [ i + 1 ] <NEWLINE> <NL> if x > y : <NEWLINE> <INDENT> print ( A [ i + 1 ] - x + y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i + 1 ] - y + x ) <NEWLINE> <DEDENT> <DEDENT> elif x == av : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> ans = ( ans * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s = int ( input ( ) . rstrip ( ) ) <NEWLINE> A [ s - 1 ] += 1 <NEWLINE> <DEDENT> for k in A : <NEWLINE> <INDENT> if K - ( Q - k ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( ( i , x , y ) ) <NEWLINE> <DEDENT> xx = sorted ( xy , key = lambda x : x [ 1 ] ) <NEWLINE> yy = sorted ( xy , key = lambda x : x [ 2 ] ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> li . append ( ( xx [ i ] [ 0 ] , xx [ i + 1 ] [ 0 ] , xx [ i + 1 ] [ 1 ] - xx [ i ] [ 1 ] ) ) <NEWLINE> li . append ( ( yy [ i ] [ 0 ] , yy [ i + 1 ] [ 0 ] , yy [ i + 1 ] [ 2 ] - yy [ i ] [ 2 ] ) ) <NEWLINE> <DEDENT> li . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , li ) : <NEWLINE> <INDENT> self . li = li <NEWLINE> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . li [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . li [ x ] = self . root ( self . li [ x ] ) <NEWLINE> return self . li [ x ] <NEWLINE> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . li [ ry ] = rx <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <DEDENT> <DEDENT> uf = UnionFind ( list ( range ( n ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x , y , cost in li : <NEWLINE> <INDENT> if uf . same ( x , y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> uf . unite ( x , y ) <NEWLINE> ans += cost <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( int ( N / 2 ) * ( N - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( N - 1 ) / 2 ) * N ) <NEWLINE> <DEDENT>
from networkx import * <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = MultiDiGraph ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_node ( i , demand = - c ) <NEWLINE> G . add_weighted_edges_from ( [ ( i , - 1 , x + y ) , ( i , - 2 , x - y ) , ( i , - 3 , - x + y ) , ( i , - 4 , - x - y ) ] , capacity = c ) <NEWLINE> <DEDENT> for i in range ( N , N * 2 ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_node ( i , demand = c ) <NEWLINE> G . add_weighted_edges_from ( [ ( - 1 , i , - x - y ) , ( - 2 , i , - x + y ) , ( - 3 , i , x - y ) , ( - 4 , i , x + y ) ] , capacity = c ) <NEWLINE> <NL> <DEDENT> print ( - min_cost_flow_cost ( G ) ) <NEWLINE>
def bin_tree ( pri , li_pri , len_li ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> lo = 0 <NEWLINE> hi = len_li - 1 <NEWLINE> while hi - lo > 1 : <NEWLINE> <INDENT> mid = lo + ( hi - lo ) // 2 <NEWLINE> guess = li_pri [ mid ] <NEWLINE> if guess >= pri : <NEWLINE> <INDENT> hi = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lo = mid <NEWLINE> <DEDENT> <DEDENT> return lo <NEWLINE> <NL> <DEDENT> I = input ( ) . split ( ) <NEWLINE> N = int ( I [ 0 ] ) <NEWLINE> M = int ( I [ 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> while M > 0 : <NEWLINE> <INDENT> M -= 1 <NEWLINE> pri = A . pop ( N - 1 ) <NEWLINE> pri = pri // 2 <NEWLINE> if len ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif ( pri < A [ 0 ] ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = bin_tree ( pri , A , N - 1 ) + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> A [ ans : ans ] = [ pri ] <NEWLINE> <NL> <DEDENT> F_pri = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> F_pri += A [ i ] <NEWLINE> <DEDENT> print ( F_pri ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> arr [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * arr ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = len ( S ) <NEWLINE> <NL> ans = 1 <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> num += S [ i ] <NEWLINE> if num <= X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> lighted = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> u = lighted [ - 1 ] <NEWLINE> v = a [ u ] - 1 <NEWLINE> ans += 1 <NEWLINE> if v == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> lighted . append ( v ) <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> n , m = inm ( ) <NEWLINE> a = inl ( ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = inm ( ) <NEWLINE> g . append ( ( c , b ) ) <NEWLINE> <DEDENT> g . sort ( reverse = True ) <NEWLINE> h = [ ] <NEWLINE> for c , b in g : <NEWLINE> <INDENT> if len ( h ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> h . append ( c ) <NEWLINE> if len ( h ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> assert len ( h ) <= n <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> for x in h : <NEWLINE> <INDENT> if a [ 0 ] >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> heapq . heappush ( a , x ) <NEWLINE> heapq . heappop ( a ) <NEWLINE> <DEDENT> return sum ( a ) <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = list ( input ( ) ) <NEWLINE> b . sort ( ) <NEWLINE> b = str ( b ) <NEWLINE> s . append ( b ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( s ) <NEWLINE> <NL> for i in c . values ( ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> a += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> s = list ( set ( s ) ) <NEWLINE> s . sort ( ) <NEWLINE> if len ( s ) == 26 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if len ( s ) <= i : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> if s [ i ] != l [ i ] : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> after_a = max ( 0 , a - k ) <NEWLINE> after_b = b <NEWLINE> if after_a == 0 : <NEWLINE> <INDENT> k -= a <NEWLINE> after_b = max ( 0 , b - k ) <NEWLINE> <NL> <DEDENT> print ( after_a , after_b ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> one = S . count ( <STRING> ) <NEWLINE> zero = S . count ( <STRING> ) <NEWLINE> <NL> print ( 2 * min ( one , zero ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> dp = [ False for _ in range ( x + 1 ) ] <NEWLINE> dp [ 0 ] = True <NEWLINE> <NL> if 1 <= x < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> for i in range ( 100 , x + 1 ) : <NEWLINE> <INDENT> tmp = False <NEWLINE> for j in range ( 6 ) : <NEWLINE> <INDENT> if i - ( 100 + j ) >= 0 : <NEWLINE> <INDENT> tmp = ( tmp or dp [ i - ( 100 + j ) ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> if dp [ x ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , x = map ( float , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if x <= a * a * b / 2 : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( a * b * b / 2 / x ) ) ) <NEWLINE> <DEDENT> elif ( - x / a + a * b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( 2 / a / a * ( a * b - x / a ) ) ) ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 2 * min ( x , y ) < max ( x , y ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( 2 * x - y ) // 3 <NEWLINE> m = ( 2 * y - x ) // 3 <NEWLINE> <COMMENT> <NL> if n == 0 or m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> def ka ( x ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> while x != 1 : <NEWLINE> <INDENT> a *= x <NEWLINE> x -= 1 <NEWLINE> a %= mod <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = ( ka ( n + m ) * pow ( ka ( m ) , mod - 2 , mod ) % mod ) * ( pow ( ka ( n ) , mod - 2 , mod ) ) % mod <NEWLINE> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> t , I = 0 , [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> I . append ( t ) <NEWLINE> <DEDENT> for l in L : <NEWLINE> <INDENT> print ( I [ l [ 1 ] - 1 ] - I [ l [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> print ( math . factorial ( int ( input ( ) ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> WSV = list ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> WSV . sort ( key = lambda x : x [ 0 ] + x [ 1 ] ) <NEWLINE> U = 2 * 10 ** 4 + 100 <NEWLINE> dp = np . zeros ( U , dtype = np . int64 ) <NEWLINE> for w , s , v in WSV : <NEWLINE> <INDENT> dp [ w : w + s + 1 ] = np . maximum ( dp [ w : w + s + 1 ] , dp [ : s + 1 ] + v ) <NEWLINE> <DEDENT> print ( dp . max ( ) ) <NEWLINE>
from bisect import bisect_right , insort_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] [ : : - 1 ] <NEWLINE> res = [ A [ 0 ] ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> idx = bisect_right ( res , a ) <NEWLINE> if idx == len ( res ) : <NEWLINE> <INDENT> res . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if res [ idx ] == a : <NEWLINE> <INDENT> insort_right ( res , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ idx ] = a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( res ) ) <NEWLINE> <NL>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = N + 1 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> x = min ( x , i + N // i ) <NEWLINE> <DEDENT> <DEDENT> print ( x - 2 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> Sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <DEDENT> s = [ * range ( len ( a ) ) ] <NEWLINE> sort_s = sorted ( s , key = lambda i : a [ i ] ) <NEWLINE> sort_a = [ a [ i ] for i in sort_s ] <NEWLINE> sort_b = [ b [ i ] for i in sort_s ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Sum += sort_b [ i ] <NEWLINE> if Sum >= K : <NEWLINE> <INDENT> print ( sort_a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 ] * k <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num [ i % k ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> b = ( k - a ) % k <NEWLINE> c = ( k - a ) % k <NEWLINE> if ( ( b + c ) % k != 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += num [ a ] * num [ b ] * num [ c ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> def sympy ( num ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if ( i % 2 != 0 ) and ( i * j == num ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l = sympy ( i ) <NEWLINE> if ( i % 2 != 0 ) and ( len ( l ) == 8 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ b , c ] ) <NEWLINE> <DEDENT> L . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> idx = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( idx > len ( L ) - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( A [ i ] < L [ idx ] [ 1 ] ) : <NEWLINE> <INDENT> A [ i ] = L [ idx ] [ 1 ] <NEWLINE> L [ idx ] [ 0 ] -= 1 <NEWLINE> if ( L [ idx ] [ 0 ] != 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = deque ( maxlen = 2 * 10 ** 5 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans . append ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans . appendleft ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( str ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 ] * m <NEWLINE> S = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> P [ i ] , S [ i ] = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> WA = [ 0 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> AC = [ False ] * ( n + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p = int ( P [ i ] ) <NEWLINE> if AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> WA [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC [ p ] = True <NEWLINE> cnt += WA [ p ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ac = sum ( AC ) <NEWLINE> print ( ac , cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_0 = a - b <NEWLINE> ans_1 = b - a <NEWLINE> if abs ( ans_0 ) >= 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k % 2 != 0 : <NEWLINE> <INDENT> print ( ans_1 ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( ans_0 ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import groupby <NEWLINE> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> def fast_prime_factorization_many ( lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> from subprocess import Popen , PIPE <NEWLINE> res = Popen ( [ <STRING> ] + list ( map ( str , lst ) ) , stdout = PIPE ) . communicate ( ) [ 0 ] . split ( <STRING> ) [ : - 1 ] <NEWLINE> return [ Counter ( list ( map ( int , r . split ( ) [ 1 : ] ) ) ) for r in res ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> mod = int ( 1e9 + 7 ) <NEWLINE> Factors = fast_prime_factorization_many ( A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> lcm = 1 <NEWLINE> max_factor = [ 0 ] * ( 1000010 ) <NEWLINE> for f in Factors : <NEWLINE> <INDENT> for k , v in f . items ( ) : <NEWLINE> <INDENT> v_prev = max_factor [ k ] <NEWLINE> if v_prev < v : <NEWLINE> <INDENT> for i in range ( v - v_prev ) : <NEWLINE> <INDENT> lcm = lcm * k % mod <NEWLINE> <DEDENT> max_factor [ k ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> wk = lcm * pow ( a , mod - 2 , mod ) <NEWLINE> <COMMENT> <NL> ans += wk <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rui = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> rui . append ( rui [ - 1 ] + i ) <NEWLINE> <DEDENT> hantei = 0 <NEWLINE> for i in range ( 0 , len ( rui ) - k ) : <NEWLINE> <INDENT> if hantei <= rui [ i + k ] - rui [ i ] : <NEWLINE> <INDENT> hantei = rui [ i + k ] - rui [ i ] <NEWLINE> l = i <NEWLINE> r = i + k <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> ans += ( a [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = [ ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if n : n . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( * n , sep = <STRING> ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> return b if not a % b else gcd ( b , a % b ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> tmp = A [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = lcm ( tmp , A [ i ] ) <NEWLINE> <DEDENT> ans = m // tmp <NEWLINE> lis = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> r = i <NEWLINE> k = 0 <NEWLINE> while ( r % 2 == 0 ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> r //= 2 <NEWLINE> <DEDENT> lis . add ( k ) <NEWLINE> <DEDENT> if ( m // ( tmp ) * tmp + tmp // 2 <= m ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if ( len ( lis ) != 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> an = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> check = sorted ( an , reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if an [ i ] == check [ 0 ] : <NEWLINE> <INDENT> print ( check [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( check [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> count = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> count += a * ( N - c ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<NL> s = input ( ) <NEWLINE> i , ans , total = 0 , 0 , 0 <NEWLINE> <NL> while i < len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += total <NEWLINE> i += 2 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> total += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> TD = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> TD . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> TD . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> TD += [ ( TD [ - 1 ] [ 0 ] , 0 ) ] <NEWLINE> <NL> D = defaultdict ( list ) <NEWLINE> T = [ 0 ] * N <NEWLINE> H = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> t , d = TD [ i ] <NEWLINE> T [ t - 1 ] += 1 <NEWLINE> D [ t ] . append ( d ) <NEWLINE> ans += d <NEWLINE> <NL> <DEDENT> cnt = sum ( 1 for c in T if c >= 1 ) <NEWLINE> ans += cnt ** 2 <NEWLINE> <NL> for t in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if T [ t - 1 ] >= 2 : <NEWLINE> <INDENT> heappush ( H , ( D [ t ] . pop ( ) , t ) ) <NEWLINE> T [ t - 1 ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if H : <NEWLINE> <INDENT> t1 , d1 = TD [ i ] <NEWLINE> d2 , t2 = heappop ( H ) <NEWLINE> <COMMENT> <NL> if T [ t1 - 1 ] == 0 and d1 - d2 + 2 * cnt + 1 >= 0 : <NEWLINE> <INDENT> ans += d1 - d2 + 2 * cnt + 1 <NEWLINE> cnt += 1 <NEWLINE> T [ t1 - 1 ] += 1 <NEWLINE> if T [ t2 - 1 ] >= 2 : <NEWLINE> <INDENT> T [ t2 - 1 ] -= 1 <NEWLINE> <DEDENT> if T [ t2 - 1 ] >= 2 : <NEWLINE> <INDENT> heappush ( H , ( D [ t2 ] . pop ( ) , t2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> heappush ( H , ( d2 , t2 ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> T2 = [ 0 ] * N <NEWLINE> D2 = [ ] <NEWLINE> cnt2 = 0 <NEWLINE> <NL> for t , d in TD : <NEWLINE> <INDENT> if cnt2 < K : <NEWLINE> <INDENT> if T2 [ t - 1 ] : <NEWLINE> <INDENT> D2 . append ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T2 [ t - 1 ] = 1 <NEWLINE> ans2 += d <NEWLINE> cnt2 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans2 += sum ( D2 [ : K - cnt2 ] ) + sum ( T2 ) ** 2 <NEWLINE> <NL> print ( max ( ans , ans2 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def fill ( h , H , W , S , MAP , marker ) : <NEWLINE> <INDENT> if not <STRING> in S [ h ] : <NEWLINE> <INDENT> return MAP , marker <NEWLINE> <DEDENT> idxes = [ i for i , s in enumerate ( S [ h ] ) if s == <STRING> ] <NEWLINE> upper = h <NEWLINE> for hh in range ( h - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if MAP [ hh ] [ idxes [ 0 ] ] == 0 : <NEWLINE> <INDENT> upper = hh <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> down = h <NEWLINE> <NL> for hh in range ( h + 1 , H + 1 ) : <NEWLINE> <INDENT> if <STRING> in S [ hh ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> down = hh <NEWLINE> <DEDENT> <DEDENT> left = 1 <NEWLINE> for idx in idxes : <NEWLINE> <INDENT> MAP [ upper : down + 1 , left : idx + 1 ] = marker <NEWLINE> marker += 1 <NEWLINE> left = idx + 1 <NEWLINE> <DEDENT> MAP [ upper : down + 1 , left : W + 1 ] = marker - 1 <NEWLINE> return MAP , marker <NEWLINE> <NL> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> * ( W + 2 ) ] <NEWLINE> up = INF <NEWLINE> down = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> down = i <NEWLINE> if up == INF : <NEWLINE> <INDENT> up = i <NEWLINE> <NL> <DEDENT> <DEDENT> s = <STRING> + s + <STRING> <NEWLINE> S . append ( s ) <NEWLINE> <DEDENT> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> MAP = np . zeros ( ( H + 2 , W + 2 ) , dtype = np . int32 ) <NEWLINE> <NL> marker = 1 <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> MAP , marker = fill ( h , H , W , S , MAP , marker ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> ans = [ str ( s ) for s in MAP [ h , 1 : W + 1 ] ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N , K = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> h . sort ( ) <NEWLINE> <NL> print ( min ( h [ i + K - 1 ] - h [ i ] for i in range ( N - K + 1 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lenS = len ( S ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> T . append ( abs ( i - ( N + 1 - i ) ) ) <NEWLINE> <NL> <DEDENT> T . sort ( ) <NEWLINE> S . sort ( ) <NEWLINE> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] != S [ i ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> nagasa = lenS // 2 <NEWLINE> for i in range ( nagasa ) : <NEWLINE> <NL> <INDENT> ans = ( ans * 2 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys , os , io <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( start ) : <NEWLINE> <INDENT> stack = [ start ] <NEWLINE> parent = [ N ] * N <NEWLINE> parent [ start ] = - 1 <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack [ - 1 ] <NEWLINE> marker = 0 <NEWLINE> for u in edge [ v ] : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if parent [ u ] == N : <COMMENT> <NEWLINE> <INDENT> marker = 1 <NEWLINE> parent [ u ] = v <NEWLINE> stack . append ( u ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans [ v ] *= ans [ u ] + 1 <NEWLINE> ans [ v ] %= M <NEWLINE> <DEDENT> <DEDENT> if marker == 0 : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def dfs2 ( start ) : <NEWLINE> <INDENT> stack = [ start ] <NEWLINE> parent = [ N ] * N <NEWLINE> parent [ start ] = - 1 <NEWLINE> p_value = [ 0 ] * N <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> cum1 = [ 1 ] * ( len ( edge [ v ] ) + 1 ) <NEWLINE> cum2 = [ 1 ] * ( len ( edge [ v ] ) + 1 ) <NEWLINE> for i , u in enumerate ( edge [ v ] ) : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> cum1 [ i + 1 ] = cum1 [ i ] * ( p_value [ v ] + 1 ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum1 [ i + 1 ] = cum1 [ i ] * ( ans [ u ] + 1 ) % M <NEWLINE> <DEDENT> <DEDENT> for i , u in enumerate ( edge [ v ] [ : : - 1 ] ) : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> cum2 [ - i - 2 ] = cum2 [ - i - 1 ] * ( p_value [ v ] + 1 ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum2 [ - i - 2 ] = cum2 [ - i - 1 ] * ( ans [ u ] + 1 ) % M <NEWLINE> <DEDENT> <DEDENT> for i , u in enumerate ( edge [ v ] ) : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ u ] = v <NEWLINE> p_value [ u ] = cum1 [ i ] * cum2 [ i + 1 ] % M <NEWLINE> ans [ u ] *= ( p_value [ u ] + 1 ) <NEWLINE> ans [ u ] %= M <NEWLINE> stack . append ( u ) <NEWLINE> <DEDENT> ans [ v ] %= M <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> ans = [ 1 ] * N <NEWLINE> dfs ( 0 ) <NEWLINE> dfs2 ( 0 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> answer = 1000000000000 <NEWLINE> for i in range ( 1 , int ( N ** ( 0.5 ) ) + 2 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> j = N // i <NEWLINE> if i + j - 2 < answer : <NEWLINE> <INDENT> answer = i + j - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> a = list ( sys . stdin . read ( ) . split ( ) ) <NEWLINE> t = list ( zip ( * [ [ int ( n [ : - 1 ] or 0 ) , int ( n [ - 1 ] ) ] for n in a ] ) ) <NEWLINE> print ( ( sum ( t [ 0 ] ) + len ( ( u : = sorted ( filter ( lambda n : n > 0 , t [ 1 ] ) ) ) [ : 0 : - 1 ] ) ) * 10 + ( u and u [ 0 ] or 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = set ( int ( x ) for x in read ( ) . split ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( N + 2 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> now = dp [ i ] <NEWLINE> if i + 1 not in a : <NEWLINE> <INDENT> dp [ i + 1 ] += now <NEWLINE> <DEDENT> if i + 2 not in a : <NEWLINE> <INDENT> dp [ i + 2 ] += now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] % 1_000_000_007 ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) + 2 ) : <NEWLINE> <INDENT> if N % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> m = N // i - 1 <NEWLINE> if m <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if N // m == N % m : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> class DAG : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , parent , child ) : <NEWLINE> <INDENT> self . adj [ parent ] . append ( child ) <NEWLINE> <NL> <DEDENT> def dfsWithDp ( self , node , dp , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return dp [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> self . dfsWithDp ( child , dp , visited ) <NEWLINE> <DEDENT> dp [ node ] = max ( dp [ node ] , 1 + self . dfsWithDp ( child , dp , visited ) ) <NEWLINE> <DEDENT> return dp [ node ] <NEWLINE> <NL> <DEDENT> def findLongestPathWithDp ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> dp = [ 0 ] * self . n <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithDp ( i , dp , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dag = DAG ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> parent , child = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> dag . addEdge ( parent , child ) <NEWLINE> <DEDENT> print ( dag . findLongestPathWithDp ( ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sorted ( A , reverse = True ) <NEWLINE> w , h = 0 , 0 <NEWLINE> <NL> cnt = 0 <NEWLINE> tmp = S [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == tmp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == 2 : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> w = tmp <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = tmp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> tmp = S [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = w * h <NEWLINE> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = a [ 0 ] <NEWLINE> K = a [ 1 ] <NEWLINE> <NL> i = 2 <NEWLINE> x = ( N - K + 1 ) <NEWLINE> y = 1 <NEWLINE> z = ( x * y ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( z ) <NEWLINE> <NL> while K >= i : <NEWLINE> <INDENT> if ( N - K + 1 ) >= i : <NEWLINE> <INDENT> x = ( N - K + 2 - i ) * x // i <NEWLINE> y = ( K - i + 1 ) * y // ( i - 1 ) <NEWLINE> z = ( x * y ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def check ( a ) : <NEWLINE> <INDENT> if a < 400 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif a < 800 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < 1200 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif a < 1600 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif a < 2000 : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif a < 2400 : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif a < 2800 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 8 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ratings = [ <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> d = { r : 0 for r in ratings } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> d [ ratings [ check ( a ) ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> if k != <STRING> and v != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> top = d [ <STRING> ] <NEWLINE> if top == 0 : <NEWLINE> <INDENT> print ( ans , ans ) <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> print ( 1 , top ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , ans + top ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = Counter ( ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = Counter ( ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> for difficult , count in T . items ( ) : <NEWLINE> <INDENT> if difficult in D and D [ difficult ] >= count : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> L = [ 0 ] <NEWLINE> R = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> L . append ( cnt ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> s = s [ : : - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> R . append ( cnt ) <NEWLINE> <NL> <DEDENT> R = R [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans += max ( R [ i ] , L [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> W = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif N == W [ i ] : <NEWLINE> <INDENT> print ( W [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = None <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> ans = A [ : : 2 ] [ : : - 1 ] + A [ 1 : : 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 1 : : 2 ] [ : : - 1 ] + A [ : : 2 ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> D = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D = L [ i ] + D <NEWLINE> <COMMENT> <NL> if D > X : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = X_list . copy ( ) <NEWLINE> <NL> tmp . sort ( ) <NEWLINE> a = tmp [ int ( N / 2 ) - 1 ] <NEWLINE> b = tmp [ int ( N / 2 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( X_list [ i ] <= a ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> arr = make_divisors ( n ) <NEWLINE> total = 0 <NEWLINE> for m in arr : <NEWLINE> <INDENT> r = n // m <NEWLINE> <NL> if r < m - 1 : <NEWLINE> <INDENT> total += m - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = al [ i ] - 1 <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( [ a [ i ] , i + 1 ] ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> ans = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ans . append ( str ( l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> C = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> MAX_C = max ( C ) <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp2 = [ - 1 ] * ( MAX_C + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = C [ i ] <NEWLINE> if dp2 [ c ] >= 0 and dp2 [ c ] < i - 1 : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + dp [ dp2 [ c ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] %= mod <NEWLINE> dp2 [ c ] = i <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> def my_pow ( base , n , mod ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> x = base <NEWLINE> y = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y *= x <NEWLINE> n -= 1 <NEWLINE> <DEDENT> x %= mod <NEWLINE> y %= mod <NEWLINE> <DEDENT> return x * y % mod <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> pows = [ 1 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pows [ i ] = ( pows [ i - 1 ] * 2 ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> def dfs ( v , p ) : <NEWLINE> <INDENT> global ans <NEWLINE> subs = [ ] <NEWLINE> res = 1 <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> val = dfs ( u , v ) <NEWLINE> res += val <NEWLINE> subs . append ( val ) <NEWLINE> <COMMENT> <NL> <DEDENT> if p != - 1 : <NEWLINE> <INDENT> subs . append ( N - res ) <NEWLINE> <DEDENT> now = pows [ N - 1 ] - 1 <COMMENT> <NEWLINE> for sub in subs : <NEWLINE> <INDENT> now -= pows [ sub ] - 1 <NEWLINE> <DEDENT> ans += now <NEWLINE> ans %= MOD <NEWLINE> return res <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( ans * my_pow ( 2 ** N , MOD - 2 , MOD ) % MOD ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( t ) > len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = s [ : : - 1 ] <NEWLINE> t = t [ : : - 1 ] <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j == len ( t ) : <NEWLINE> <INDENT> ans = s [ : i ] + t + s [ i + len ( t ) : ] <NEWLINE> print ( ans [ : : - 1 ] . replace ( <STRING> , <STRING> , len ( ans ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if t [ j ] == s [ i + j ] or s [ i + j ] == <STRING> : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> bit = np . count_nonzero ( a & 1 ) <NEWLINE> s += bit * ( n - bit ) * ( 2 ** i ) <NEWLINE> a >>= 1 <NEWLINE> <DEDENT> print ( s % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> visit = [ False ] * n <NEWLINE> cnt = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <DEDENT> q = [ ( 0 , 0 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> v , a = q . pop ( ) <NEWLINE> visit [ v ] = True <NEWLINE> a += cnt [ v ] <NEWLINE> cnt [ v ] = a <NEWLINE> for i in ab [ v ] : <NEWLINE> <INDENT> if visit [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( ( i , a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( sorted ( input ( ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> flg = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ flg ] != a [ i ] : <NEWLINE> <INDENT> z = i - 1 - flg <NEWLINE> ans += ( 1 + z ) * z // 2 <NEWLINE> flg = i <NEWLINE> <DEDENT> <DEDENT> z = n - 1 - flg <NEWLINE> ans += ( 1 + z ) * z // 2 <NEWLINE> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> l = deque ( [ 1 ] ) <NEWLINE> s = set ( [ 1 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> check = True <NEWLINE> for nex in e [ l [ - 1 ] ] : <NEWLINE> <INDENT> if nex in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . append ( nex ) <NEWLINE> s . add ( nex ) <NEWLINE> check = False <NEWLINE> break <NEWLINE> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> check = True <NEWLINE> for nex in e [ l [ 0 ] ] : <NEWLINE> <INDENT> if nex in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . appendleft ( nex ) <NEWLINE> s . add ( nex ) <NEWLINE> check = False <NEWLINE> break <NEWLINE> <DEDENT> if check : <NEWLINE> <INDENT> print ( len ( l ) ) <NEWLINE> print ( * l ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> loop = [ 0 ] * n <NEWLINE> <NL> <NL> if ( 2 not in a ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> tar_index = 0 <NEWLINE> loop [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> tar_index = a [ tar_index ] - 1 <NEWLINE> <COMMENT> <NL> count += 1 <NEWLINE> <NL> if ( tar_index == 1 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if ( loop [ tar_index ] == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> loop [ tar_index ] = 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * L ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> Q = np . cumsum ( P ) <NEWLINE> <NL> R = np . pad ( Q , K , <STRING> , constant_values = 0 ) [ : N ] <NEWLINE> <NL> a = np . argmax ( Q - R ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += ( 1.00 + P [ a - i ] ) / 2.00 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
( h , n ) , * m = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> dp = [ 0 ] * 20001 <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in m ) <NEWLINE> <DEDENT> print ( dp [ h ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( a - b ) <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = list ( input ( ) ) , list ( input ( ) ) <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return gcd ( b , a ) <NEWLINE> <DEDENT> while a > 0 : <NEWLINE> <INDENT> a , b = b % a , a <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> l = lcm ( len ( s ) , len ( t ) ) <NEWLINE> x = { } <COMMENT> <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> x [ i * ( l // len ( s ) ) ] = s [ i ] <NEWLINE> <DEDENT> for i in range ( 0 , len ( t ) ) : <NEWLINE> <INDENT> if i * ( l // len ( t ) ) not in x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ i * ( l // len ( t ) ) ] != t [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n * a >= b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * a ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> def zs ( num ) : <NEWLINE> <INDENT> k = 6 - len ( str ( num ) ) <NEWLINE> return <STRING> * k + str ( num ) <NEWLINE> <DEDENT> lst = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> lst . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> slst = sorted ( lst ) <NEWLINE> dic = { } <NEWLINE> temp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if slst [ i ] [ 0 ] == slst [ i - 1 ] [ 0 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 1 <NEWLINE> <DEDENT> dic [ slst [ i ] ] = zs ( slst [ i ] [ 0 ] ) + zs ( temp ) <NEWLINE> <DEDENT> for i in lst : <NEWLINE> <INDENT> print ( dic [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N , Q = MI ( ) <NEWLINE> Edge = [ [ ] for _ in range ( N ) ] <NEWLINE> Point = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> Edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> Edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = MI ( ) <NEWLINE> Point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( now , pre = - 1 ) : <NEWLINE> <INDENT> for nxt in Edge [ now ] : <NEWLINE> <INDENT> if nxt == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Point [ nxt ] += Point [ now ] <NEWLINE> dfs ( nxt , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * Point ) <NEWLINE>
n , a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> fact = [ 1 , 1 ] <NEWLINE> finv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 5 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> inv . append ( ( inv [ mod % i ] * ( mod - mod // i ) ) % mod ) <NEWLINE> finv . append ( ( finv [ - 1 ] * inv [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> def nCr ( n , r , mod ) : <NEWLINE> <INDENT> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fact [ n ] * finv [ r ] * finv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def nPr ( n , r , mod ) : <NEWLINE> <INDENT> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fact [ n ] * finv [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i * a > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = k - i * a <NEWLINE> if d % b or d // b > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += nCr ( n , i , mod ) * nCr ( n , d // b , mod ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> paths = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> paths . setdefault ( u , { } ) <NEWLINE> paths [ u ] [ v ] = w <NEWLINE> paths . setdefault ( v , { } ) <NEWLINE> paths [ v ] [ u ] = w <NEWLINE> <NL> <DEDENT> node_colors = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def route ( last , now , dist ) : <NEWLINE> <INDENT> for next_node , next_distance in zip ( paths [ now ] . keys ( ) , paths [ now ] . values ( ) ) : <NEWLINE> <INDENT> node_colors [ next_node ] = ( dist + next_distance ) % 2 <NEWLINE> if next_node != last : <NEWLINE> <INDENT> route ( now , next_node , dist + next_distance ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> node_colors [ 1 ] = 0 <NEWLINE> <NL> route ( 0 , 1 , 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( node_colors [ i + 1 ] ) <NEWLINE> <DEDENT>
n , d , a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inp [ 1 ] = ( inp [ 1 ] - 1 ) // a + 1 <NEWLINE> e . append ( inp ) <NEWLINE> <DEDENT> e . sort ( ) <NEWLINE> sd = [ 0 for i in range ( n ) ] <NEWLINE> s = 0 <NEWLINE> mx = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> while e [ i ] [ 1 ] + s <= mx : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += sd [ i ] <NEWLINE> <DEDENT> while i < n and j < n and e [ j ] [ 0 ] <= e [ i ] [ 0 ] + 2 * d : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j < n : <NEWLINE> <INDENT> sd [ j ] += e [ i ] [ 1 ] + s - mx <NEWLINE> mx = e [ i ] [ 1 ] + s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mx = e [ i ] [ 1 ] + s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> eastNumber = S . count ( <STRING> ) <NEWLINE> westNumber = 0 <NEWLINE> minimum = N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> eastNumber -= 1 <NEWLINE> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> westNumber += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def prime_factorization ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 2 <NEWLINE> ans = [ ] <NEWLINE> k = int ( n ** 0.5 ) + 1 <NEWLINE> for j in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> if n == 1 : break <NEWLINE> if n % j == 0 : <NEWLINE> <INDENT> n //= j <NEWLINE> ans . append ( j ) <NEWLINE> while n % j == 0 : <NEWLINE> <INDENT> n //= j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> if n != 1 : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ 1 , n ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> A = prime_factorization ( a ) <NEWLINE> B = prime_factorization ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( len ( set ( A ) & set ( B ) ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> oE = S . count ( <STRING> ) <NEWLINE> Wo = 0 <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> oE -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> Wo += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> oE -= 1 <NEWLINE> <DEDENT> <DEDENT> L . append ( Wo + oE ) <NEWLINE> if Wo + oE == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min ( L ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( a [ 0 ] , a [ n - 1 ] + 1 ) : <NEWLINE> <INDENT> sum = c [ i - 1 ] + c [ i ] + c [ i + 1 ] <NEWLINE> if sum > counter : <NEWLINE> <INDENT> counter = sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <COMMENT> <NL> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> <NL> lcm = a [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> lcm = lcm // math . gcd ( lcm , i ) * i <NEWLINE> <DEDENT> lcm %= MOD <NEWLINE> <NL> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans += lcm * pow ( ai , MOD - 2 , MOD ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dic = { } <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a in dic : <NEWLINE> <INDENT> dic [ a ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> dic = sorted ( dic . items ( ) ) <NEWLINE> <NL> for i in range ( len ( dic ) ) : <NEWLINE> <INDENT> sum += dic [ i ] [ 1 ] <NEWLINE> if K <= sum : <NEWLINE> <INDENT> print ( dic [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xx = sorted ( x ) <NEWLINE> <NL> l = xx [ ( n - 1 ) // 2 ] <NEWLINE> r = xx [ n // 2 ] <NEWLINE> mid = ( l + r ) / 2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] >= mid : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( ( a ) * ( a - 1 ) // 2 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * X , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> i = bisect . bisect_left ( X , 0 ) <NEWLINE> L = max ( 0 , bisect . bisect_right ( X , 0 ) - K ) <NEWLINE> R = min ( N - 1 , bisect . bisect_left ( X , 0 ) + K - 1 ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( L , R - K + 2 ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> l = X [ i ] <NEWLINE> r = X [ i + K - 1 ] <NEWLINE> if r <= 0 : <NEWLINE> <INDENT> t = abs ( l ) <NEWLINE> <DEDENT> elif 0 <= l : <NEWLINE> <INDENT> t = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = min ( abs ( l ) , r ) * 2 + max ( abs ( l ) , r ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = min ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
b = input ( ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> A = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b = S [ i ] <NEWLINE> c , d = S [ j ] <NEWLINE> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> e , f , g = A [ k ] <NEWLINE> if e == a - c and f == b - d : <NEWLINE> <INDENT> A [ k ] = ( e , f , g + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A . append ( ( a - c , b - d , 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( N - max ( list ( x [ 2 ] for x in A ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for i in range ( 2 * 10 ** 5 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xi , yi = map ( int , input ( ) . split ( ) ) <NEWLINE> xi -= 1 <NEWLINE> yi = yi - 1 + 10 ** 5 <NEWLINE> edges [ xi ] . append ( yi ) <NEWLINE> edges [ yi ] . append ( xi ) <NEWLINE> <NL> <DEDENT> already = set ( [ ] ) <NEWLINE> def dfs ( x , y , node ) : <NEWLINE> <INDENT> if node in already : <NEWLINE> <INDENT> return x , y <NEWLINE> <DEDENT> if node < 10 ** 5 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> already . add ( node ) <NEWLINE> for next_node in edges [ node ] : <NEWLINE> <INDENT> x , y = dfs ( x , y , next_node ) <NEWLINE> <DEDENT> return x , y <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> x , y = dfs ( 0 , 0 , i ) <NEWLINE> num += x * y <NEWLINE> <DEDENT> print ( num - n ) <NEWLINE>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = H * W <NEWLINE> <NL> <COMMENT> <NL> wall = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w_idx , w in enumerate ( list ( input ( ) ) ) : <NEWLINE> <INDENT> if w == <STRING> : <NEWLINE> <INDENT> wall . append ( W * h + w_idx + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> path = [ _ for _ in range ( 1 , N + 1 ) if _ not in wall ] <NEWLINE> <NL> <COMMENT> <NL> ad = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> ad [ n + 1 ] = [ ] <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> if n not in wall : <NEWLINE> <INDENT> up = n - W <NEWLINE> if up > 0 and up not in wall : <NEWLINE> <INDENT> ad [ n ] . append ( up ) <NEWLINE> <NL> <DEDENT> down = n + W <NEWLINE> if down <= N and down not in wall : <NEWLINE> <INDENT> ad [ n ] . append ( down ) <NEWLINE> <NL> <DEDENT> left = n - 1 <NEWLINE> if n % W != 1 and left not in wall and left > 0 : <NEWLINE> <INDENT> ad [ n ] . append ( left ) <NEWLINE> <NL> <DEDENT> right = n + 1 <NEWLINE> if n % W != 0 and right not in wall : <NEWLINE> <INDENT> ad [ n ] . append ( right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> from collections import deque <NEWLINE> <NL> def BFS ( start ) : <NEWLINE> <INDENT> que = deque ( [ start ] ) <NEWLINE> visit = deque ( [ ] ) <NEWLINE> <NL> color = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> color [ n + 1 ] = - 1 <NEWLINE> <DEDENT> color [ start ] = 0 <NEWLINE> <NL> depth = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> depth [ n + 1 ] = - 1 <NEWLINE> <NL> <DEDENT> depth [ start ] = 0 <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> start = que [ 0 ] <NEWLINE> for v in ad [ start ] : <NEWLINE> <INDENT> if color [ v ] == - 1 : <NEWLINE> <INDENT> que . append ( v ) <NEWLINE> color [ v ] = 0 <NEWLINE> depth [ v ] = depth [ start ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> color [ start ] = 1 <NEWLINE> visit . append ( que . popleft ( ) ) <NEWLINE> <NL> <DEDENT> return depth [ start ] <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> for start in path : <NEWLINE> <INDENT> ans_ = BFS ( start ) <NEWLINE> if ans < BFS ( start ) : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> lis . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> mon = 0 <NEWLINE> i = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> while cnt < m : <NEWLINE> <INDENT> if lis [ i ] [ 1 ] + cnt < m : <NEWLINE> <INDENT> cnt += lis [ i ] [ 1 ] <NEWLINE> mon += lis [ i ] [ 0 ] * lis [ i ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( mon + ( m - cnt ) * lis [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m * lis [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> for i , v in enumerate ( s [ 0 : - 1 ] ) : <NEWLINE> <INDENT> if v == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def lucas ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return lucas ( n - 1 ) + lucas ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> print ( lucas ( N ) ) <NEWLINE>
<COMMENT> <NL> <NL> def getH ( x , cx , y , cy , h ) : <NEWLINE> <INDENT> return h + abs ( x - cx ) + abs ( y - cy ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> conditions = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if h > 0 : <NEWLINE> <INDENT> conditions . append ( [ x , y , h ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> num_cnd = len ( conditions ) <NEWLINE> if num_cnd == 1 : <NEWLINE> <INDENT> print ( conditions [ 0 ] [ 0 ] , conditions [ 0 ] [ 1 ] , conditions [ 0 ] [ 2 ] ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> h = 0 <NEWLINE> for i , cnd in enumerate ( conditions ) : <NEWLINE> <INDENT> h_tmp = getH ( cnd [ 0 ] , cx , cnd [ 1 ] , cy , cnd [ 2 ] ) <NEWLINE> if h_tmp >= 1 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> h = h_tmp <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif h == h_tmp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == num_cnd : <NEWLINE> <INDENT> print ( cx , cy , h ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
arr = input ( ) <NEWLINE> new = <STRING> <NEWLINE> for x in arr : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if new : <NEWLINE> <INDENT> new = new [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> new += x <NEWLINE> <DEDENT> <DEDENT> print ( new ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def dfs ( x ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> if int ( x ) > N : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if all ( x . count ( i ) > 0 for i in <STRING> ) : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> for i in <STRING> : <NEWLINE> <INDENT> ret += dfs ( x + i ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> print ( dfs ( <STRING> ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = ( l [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> lis = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis [ i + 1 ] = lis [ i ] + l [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> num = lis [ i + k ] - lis [ i ] <NEWLINE> ans = max ( num , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lucas_number = [ 0 ] * ( n + 1 ) <NEWLINE> lucas_number [ 0 ] = 2 <NEWLINE> lucas_number [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> lucas_number [ i ] = lucas_number [ i - 1 ] + lucas_number [ i - 2 ] <NEWLINE> <DEDENT> print ( lucas_number [ n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> e , w = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w [ i ] += w [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> e [ i ] += e [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> ans = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , w [ i ] + e [ - 1 ] - e [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> <NL> def encode ( i , j ) : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> return i * ( i - 1 ) // 2 + j + 1 <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v ) : <NEWLINE> <INDENT> if visited [ v ] == 2 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> visited [ v ] = 1 <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if visited [ nv ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dp [ v ] = max ( dp [ v ] , dfs ( nv ) + 1 ) <NEWLINE> <DEDENT> visited [ v ] = 2 <NEWLINE> return dp [ v ] <NEWLINE> <NL> <NL> <DEDENT> setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> GAMES_CNT = N * ( N - 1 ) // 2 <NEWLINE> g = [ [ ] for _ in range ( GAMES_CNT + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> orig = 0 <NEWLINE> for j in map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) : <NEWLINE> <INDENT> dest = encode ( i , j ) <NEWLINE> g [ orig ] . append ( dest ) <NEWLINE> orig = dest <NEWLINE> <DEDENT> <DEDENT> dp = [ 0 ] * ( GAMES_CNT + 1 ) <NEWLINE> visited = [ 0 ] * ( GAMES_CNT + 1 ) <NEWLINE> print ( dfs ( 0 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> def solve ( n , l , pos ) : <NEWLINE> <INDENT> if ( pos == n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ( pos == n - 1 ) : <NEWLINE> <INDENT> return abs ( l [ - 1 ] - l [ - 2 ] ) <NEWLINE> <DEDENT> if ( t [ pos ] != - 1 ) : <NEWLINE> <INDENT> return t [ pos ] <NEWLINE> <DEDENT> t [ pos ] = min ( abs ( l [ pos - 1 ] - l [ pos ] ) + solve ( n , l , pos + 1 ) , abs ( l [ pos - 1 ] - l [ pos + 1 ] ) + solve ( n , l , pos + 2 ) ) <NEWLINE> return t [ pos ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> global t <NEWLINE> t = [ - 1 ] * ( n + 1 ) <NEWLINE> print ( solve ( n , l , 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> s = 2 ** i <NEWLINE> if s <= N : <NEWLINE> <INDENT> list . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ( list ) ) <NEWLINE>
import itertools <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) [ 0 ] for _ in range ( n ) ] <NEWLINE> cnt = Counter ( s ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for x , y , z in itertools . combinations ( <STRING> , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += cnt [ x ] * cnt [ y ] * cnt [ z ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] = ( 1 + p [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N - K + 1 ) <NEWLINE> ans [ 0 ] = sum ( p [ : K ] ) <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] - p [ i - 1 ] + p [ i + K - 1 ] <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> curr = [ <STRING> , <STRING> ] <NEWLINE> idx = 0 <NEWLINE> cnt = 0 <NEWLINE> E = [ ] <NEWLINE> for i , ch in enumerate ( S ) : <NEWLINE> <INDENT> if ch != curr [ idx ] : <NEWLINE> <INDENT> E . append ( ( idx , cnt ) ) <NEWLINE> cnt = 1 <NEWLINE> idx = 1 - idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> E . append ( ( idx , cnt ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( 0 , len ( E ) , 2 ) : <NEWLINE> <INDENT> Rcnt = E [ i ] [ 1 ] <NEWLINE> Lcnt = E [ i + 1 ] [ 1 ] <NEWLINE> Rfill = Lfill = ( Rcnt + Lcnt ) // 2 <NEWLINE> <NL> if ( Rcnt + Lcnt ) % 2 == 1 : <NEWLINE> <INDENT> if Rcnt % 2 == 1 : <NEWLINE> <INDENT> Rfill += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Lfill += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Rcnt - 1 ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <DEDENT> ans . append ( Rfill ) <NEWLINE> ans . append ( Lfill ) <NEWLINE> <NL> for i in range ( Lcnt - 1 ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * ( max ( A ) + 2 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> ans [ a + 1 ] += 1 <NEWLINE> <DEDENT> if a != 0 : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> ans [ a ] += 1 <NEWLINE> ans [ a + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> ls1 = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ [ [ 0 for k in range ( 2600 ) ] for j in range ( 51 ) ] for i in range ( 51 ) ] <NEWLINE> for i in range ( 51 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> for s in range ( 2600 ) : <NEWLINE> <INDENT> if s < ls1 [ j ] : <NEWLINE> <INDENT> dp [ j ] [ k ] [ s ] = dp [ j - 1 ] [ k ] [ s ] <NEWLINE> <DEDENT> elif s >= ls1 [ j ] : <NEWLINE> <INDENT> dp [ j ] [ k ] [ s ] = dp [ j - 1 ] [ k - 1 ] [ s - ls1 [ j ] ] + dp [ j - 1 ] [ k ] [ s ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += dp [ N ] [ k ] [ k * A ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = <STRING> + input ( ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> _l , _r = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( _l ) <NEWLINE> r . append ( _r ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( N + 2 ) <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ - i ] == <STRING> and S [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> dp [ N - i ] = cnt <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> ans = dp [ l [ q ] ] - dp [ r [ q ] + 1 ] <NEWLINE> if r [ q ] < N : <NEWLINE> <INDENT> if S [ r [ q ] ] == <STRING> and S [ r [ q ] + 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import heapq <COMMENT> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> heapq . heapify ( A ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <COMMENT> <NEWLINE> a = - a // 2 <COMMENT> <NEWLINE> heapq . heappush ( A , - a ) <COMMENT> <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] + A + [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> L = [ A [ 1 ] ] <NEWLINE> tempL = A [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tempL = gcd ( tempL , A [ i + 1 ] ) <NEWLINE> L . append ( tempL ) <NEWLINE> <DEDENT> L = [ 0 ] + L <NEWLINE> <NL> <COMMENT> <NL> R = [ A [ - 2 ] ] <NEWLINE> tempR = A [ - 2 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tempR = gcd ( tempR , A [ - i - 2 ] ) <NEWLINE> R . append ( tempR ) <NEWLINE> <DEDENT> R = list ( reversed ( R ) ) + [ 0 ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result = gcd ( L [ i ] , R [ i + 1 ] ) <NEWLINE> ans . append ( result ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> c = [ [ <STRING> ] * W for i in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> countX = 0 <NEWLINE> nowX = s [ i ] [ 0 ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if nowX == s [ i ] [ j ] : <NEWLINE> <INDENT> countX += 1 <NEWLINE> if 1 < countX and nowX == <STRING> : <NEWLINE> <INDENT> c [ i ] [ j - 1 ] , c [ i ] [ j ] = <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> countX = 1 <NEWLINE> <DEDENT> nowX = s [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> countY = 0 <NEWLINE> nowY = s [ 0 ] [ i ] <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> if nowY == s [ j ] [ i ] : <NEWLINE> <INDENT> countY += 1 <NEWLINE> if 1 < countY and nowY == <STRING> : <NEWLINE> <INDENT> c [ j - 1 ] [ i ] , c [ j ] [ i ] = <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> countY = 1 <NEWLINE> <DEDENT> nowY = s [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if c == s else <STRING> ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> T = False <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> T = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = a [ i ] / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if T : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 9 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> i , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i - 1 ] . append ( k - 1 ) <NEWLINE> A [ k - 1 ] . append ( i - 1 ) <NEWLINE> <DEDENT> n_P = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> n_P [ k - 1 ] += n <NEWLINE> <DEDENT> ans = [ 0 ] * N <NEWLINE> visited = [ 0 ] * N <NEWLINE> def make ( num , p ) : <NEWLINE> <INDENT> ans [ num ] += n_P [ num ] <NEWLINE> ans [ num ] += p <NEWLINE> visited [ num ] = 1 <NEWLINE> for i in A [ num ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> make ( i , ans [ num ] ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT> make ( 0 , ans [ 0 ] ) <NEWLINE> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> a [ i ] += c <NEWLINE> x = a [ i ] % b [ i ] <NEWLINE> if x : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> c += b [ i ] - a [ i ] <NEWLINE> <DEDENT> elif a [ i ] > b [ i ] : <NEWLINE> <INDENT> c += b [ i ] - x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> d = range ( l , r + 1 ) <NEWLINE> print ( 0 if r - l > 671 else min ( i * j % 2019 for i in d for j in d if i < j ) ) <NEWLINE>
lst = input ( ) . split ( ) <NEWLINE> A = int ( lst [ 0 ] ) <NEWLINE> B = int ( lst [ 1 ] ) <NEWLINE> K = int ( lst [ 2 ] ) <NEWLINE> <NL> if ( B - A + 1 ) <= 2 * K : <NEWLINE> <INDENT> for n in list ( range ( A , B + 1 ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for n in list ( range ( A , A + K ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> for n in list ( range ( B - K + 1 , B + 1 ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 10 ) <NEWLINE> def memo ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : return dp [ v ] <NEWLINE> ans = 0 <NEWLINE> for next_v in g [ v ] : <NEWLINE> <INDENT> ans = max ( ans , memo ( next_v ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for v in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , memo ( v ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> d = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( d [ r - 1 ] - d [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( l ) <NEWLINE> s = set ( l ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> ans = max ( c [ i - 1 ] + c [ i ] + c [ i + 1 ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> d_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> d_c = collections . Counter ( d_list ) <NEWLINE> t_c = collections . Counter ( t_list ) <NEWLINE> <NL> for i in t_c : <NEWLINE> <INDENT> if t_c [ i ] <= d_c [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> s_odd = [ ] <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> s_odd . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( s_odd ) ) <NEWLINE>
ans = 0 <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import bellman_ford , NegativeCycleError <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for u in to [ s ] : <NEWLINE> <INDENT> if not toflag [ u ] : <NEWLINE> <INDENT> toflag [ u ] = True <NEWLINE> dfs ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def rdfs ( s ) : <NEWLINE> <INDENT> for u in ot [ s ] : <NEWLINE> <INDENT> if not otflag [ u ] : <NEWLINE> <INDENT> otflag [ u ] = True <NEWLINE> rdfs ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ i ] = [ a , b , - ( c + 1 - p ) ] <NEWLINE> to [ a ] . append ( b ) <NEWLINE> ot [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> toflag [ 0 ] = True <NEWLINE> otflag [ - 1 ] = True <NEWLINE> dfs ( 0 ) <NEWLINE> rdfs ( n - 1 ) <NEWLINE> <NL> dic = { } <NEWLINE> for a , b , c in edges : <NEWLINE> <INDENT> if toflag [ a ] and otflag [ b ] : <NEWLINE> <INDENT> if ( a , b ) in dic . keys ( ) : <NEWLINE> <INDENT> dic [ ( a , b ) ] = min ( dic [ ( a , b ) ] , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ( a , b ) ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> row = [ ] <NEWLINE> col = [ ] <NEWLINE> data = [ ] <NEWLINE> for ( a , b ) , c in dic . items ( ) : <NEWLINE> <INDENT> row . append ( a ) <NEWLINE> col . append ( b ) <NEWLINE> data . append ( c ) <NEWLINE> <DEDENT> g = csr_matrix ( ( data , ( row , col ) ) , shape = ( n , n ) ) <NEWLINE> try : <NEWLINE> <INDENT> d = bellman_ford ( g , indices = 0 ) . astype ( int ) <NEWLINE> print ( max ( 0 , - d [ - 1 ] ) ) <NEWLINE> <DEDENT> except NegativeCycleError : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( m ) ] <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> ot = [ [ ] for i in range ( n ) ] <NEWLINE> toflag = [ False ] * n <NEWLINE> otflag = [ False ] * n <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( a ) <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> tmp = abs ( 2 * b - t ) <NEWLINE> ans = tmp if i == 0 else min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> G [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> SD = [ 0 ] * N <NEWLINE> def DFS ( v , p , d ) : <NEWLINE> <INDENT> SD [ v ] = d <NEWLINE> for i , co in G [ v ] : <NEWLINE> <INDENT> if i == p : continue <NEWLINE> DFS ( i , v , d + co ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> DFS ( K - 1 , - 1 , 0 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = SD [ x - 1 ] + SD [ y - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> w = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> cnt = N + 1 <NEWLINE> tmp = w <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> cnt = min ( cnt , tmp ) <NEWLINE> <NL> <DEDENT> ans = min ( w , b , cnt ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def count ( val1 , val2 ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if val1 < ( val2 ** num ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> digit = num <NEWLINE> while True : <NEWLINE> <INDENT> if val1 >= val2 ** digit : <NEWLINE> <INDENT> val1 -= val2 ** digit <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> digit -= 1 <NEWLINE> <NL> <DEDENT> if digit == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return cnt , val1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = N <NEWLINE> <NL> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> n = i <NEWLINE> m = N - i <NEWLINE> res = 0 <NEWLINE> <NL> cnt , nn = count ( n , 9 ) <NEWLINE> n = nn <NEWLINE> res += cnt <NEWLINE> <NL> cnt , mm = count ( m , 6 ) <NEWLINE> m = mm <NEWLINE> res += cnt <NEWLINE> <NL> res += n + m <NEWLINE> ans = min ( ans , res ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def gcd ( num1 , num2 ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while r > 0 : <NEWLINE> <INDENT> r = num1 % num2 <NEWLINE> num1 = num2 <NEWLINE> num2 = r <NEWLINE> <DEDENT> return num1 <NEWLINE> <NL> <DEDENT> def lcm ( num1 , num2 ) : <NEWLINE> <INDENT> gcd1 = gcd ( num1 , num2 ) <NEWLINE> return num1 * num2 // gcd1 <NEWLINE> <NL> <DEDENT> lcm1 = a [ 0 ] // 2 <NEWLINE> lcm2 = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> lcm1 = lcm ( lcm1 , t // 2 ) <NEWLINE> lcm2 = lcm ( lcm2 , t ) <NEWLINE> ta = max ( t // 2 , lcm1 ) <NEWLINE> tb = min ( t // 2 , lcm1 ) <NEWLINE> if ta != tb and ta // tb % 2 == 0 : <NEWLINE> <INDENT> lcm1 = 0 <NEWLINE> lcm2 = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if lcm1 != 0 : <NEWLINE> <INDENT> ans1 = m // lcm1 <NEWLINE> ans2 = m // lcm2 <NEWLINE> ans = ans1 - ans2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> L . sort ( ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> count += k - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> A . sort ( ) <NEWLINE> overwrite = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> overwrite . append ( { <NEWLINE> <INDENT> <STRING> : B , <NEWLINE> <STRING> : C <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> overwrite . sort ( key = lambda o : - o [ <STRING> ] ) <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> flag = False <NEWLINE> while not flag and j < len ( A ) and k < len ( overwrite ) : <NEWLINE> <INDENT> o = overwrite [ k ] <NEWLINE> for m in range ( o [ <STRING> ] ) : <NEWLINE> <INDENT> if j < len ( A ) and A [ j ] <= o [ <STRING> ] : <NEWLINE> <INDENT> A [ j ] = o [ <STRING> ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> student = list ( range ( 0 , N ) ) <NEWLINE> <NL> student . sort ( key = lambda x : A [ x ] ) <NEWLINE> <NL> for s in student : <NEWLINE> <INDENT> print ( s + 1 , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> ab = 0 <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ab += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> for j in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> and s [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a != 0 and b != 0 : <NEWLINE> <INDENT> num += ab + 1 <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> num += min ( a , b ) <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> num += ab <NEWLINE> <DEDENT> elif b != 0 : <NEWLINE> <INDENT> num += ab <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += max ( 0 , ab - 1 ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> ACGT = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> tmp = 0 <NEWLINE> X = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] in ACGT : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X . append ( tmp ) <NEWLINE> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> X . append ( tmp ) <NEWLINE> print ( max ( X ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def isPrime_np ( n ) : <NEWLINE> <INDENT> maxp = int ( np . sqrt ( n ) ) <NEWLINE> searchlist = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> <NL> while searchlist [ 0 ] <= maxp : <NEWLINE> <INDENT> primeNum . append ( searchlist [ 0 ] ) <NEWLINE> tmp = searchlist [ 0 ] <NEWLINE> searchlist = [ i for i in searchlist if i % tmp != 0 ] <NEWLINE> <DEDENT> primeNum . extend ( searchlist ) <NEWLINE> <NL> return primeNum <NEWLINE> <NL> <DEDENT> MaxQ = 10 ** 5 + 1 <NEWLINE> Q = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> a = [ 0 ] * MaxQ <NEWLINE> s = [ 0 ] * MaxQ <NEWLINE> prime = isPrime_np ( MaxQ ) <NEWLINE> pset = set ( prime ) <NEWLINE> for p in prime : <NEWLINE> <INDENT> if ( p + 1 ) / 2 in pset : <NEWLINE> <INDENT> a [ p ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( MaxQ - 1 ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> ans . append ( s [ r + 1 ] - s [ l ] ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power = power % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( power ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> search_max = int ( N ** 0.5 ) <NEWLINE> <NL> min_number = 10 ** 12 <NEWLINE> for x in range ( 1 , search_max + 1 ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> y = N // x <NEWLINE> if x + y < min_number : <NEWLINE> <NL> <INDENT> min_number = x + y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min_number - 2 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> l , r = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if r - l + 1 >= 5000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = 2019 <NEWLINE> mn = [ ] <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> mn . append ( ( i * j ) % M ) <NEWLINE> <NL> <DEDENT> <DEDENT> mn . sort ( ) <NEWLINE> print ( mn [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> g = n * m // math . gcd ( n , m ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> for i in range ( math . gcd ( n , m ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ i * ( g // m ) ] != t [ i * ( g // n ) ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> s . insert ( 0 , <STRING> ) <NEWLINE> <DEDENT> if len ( s ) >= 5 : <NEWLINE> <INDENT> if s [ 4 ] != <STRING> : <NEWLINE> <INDENT> s . insert ( 4 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if len ( s ) >= 7 : <NEWLINE> <INDENT> if s [ 6 ] != <STRING> : <NEWLINE> <INDENT> s . insert ( 6 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s [ len ( s ) - 1 ] != <STRING> : <NEWLINE> <INDENT> s . append ( <STRING> ) <NEWLINE> <DEDENT> if <STRING> . join ( s ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def dijkstra ( s , g ) : <NEWLINE> <INDENT> import heapq <NEWLINE> <NL> n = len ( g ) <NEWLINE> heap = [ ( 0 , s ) ] <NEWLINE> heapq . heapify ( heap ) <NEWLINE> <NL> prev = [ - 1 ] * n <NEWLINE> cost = [ float ( <STRING> ) ] * n <NEWLINE> cost [ s ] = 0 <NEWLINE> <NL> while heap : <NEWLINE> <INDENT> c , v = heapq . heappop ( heap ) <NEWLINE> x = cost [ v ] <NEWLINE> if c > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for d , u in g [ v ] : <NEWLINE> <INDENT> path = d + x <NEWLINE> if path < cost [ u ] : <NEWLINE> <INDENT> cost [ u ] = path <NEWLINE> prev [ u ] = v <NEWLINE> heapq . heappush ( heap , ( path , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return prev <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> from collections import deque <NEWLINE> <NL> n , * uv = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i , j in zip ( * [ iter ( uv ) ] * 2 ) : <NEWLINE> <INDENT> g [ i ] . append ( [ 1 , j ] ) <NEWLINE> g [ j ] . append ( [ 1 , i ] ) <NEWLINE> <NL> <DEDENT> dk = dijkstra ( n , g ) <NEWLINE> <NL> vis = [ False ] * ( n + 1 ) <NEWLINE> <NL> def f ( now , c ) : <NEWLINE> <INDENT> if vis [ now ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> vis [ now ] = True <NEWLINE> cnt = 1 <NEWLINE> for _ , nxt in g [ now ] : <NEWLINE> <INDENT> cnt += f ( nxt , c ) <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> nw = dk [ 1 ] <NEWLINE> <NL> cnt = [ ] <NEWLINE> vis [ 1 ] = True <NEWLINE> vis [ n ] = True <NEWLINE> while nw != n : <NEWLINE> <INDENT> nx = dk [ nw ] <NEWLINE> vis [ nx ] = True <NEWLINE> tmp = f ( nw , 0 ) <NEWLINE> vis [ nx ] = False <NEWLINE> cnt . append ( tmp ) <NEWLINE> nw = nx <NEWLINE> <NL> <DEDENT> fn = 0 <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> vis [ 1 ] = False <NEWLINE> <NL> while q : <NEWLINE> <INDENT> i = q . popleft ( ) <NEWLINE> if vis [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> vis [ i ] = True <NEWLINE> fn += 1 <NEWLINE> for _ , j in g [ i ] : <NEWLINE> <INDENT> q . appendleft ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> * a , = accumulate ( cnt ) <NEWLINE> l = len ( a ) <NEWLINE> k = l // 2 - 1 if l % 2 == 0 else l // 2 <NEWLINE> fn += a [ k ] if l > 0 else 0 <NEWLINE> sn = n - fn <NEWLINE> <NL> print ( <STRING> if fn > sn else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , * f = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> A = f [ : N ] <NEWLINE> B = f [ N : ] <NEWLINE> for i in range ( N - M + 1 ) : <NEWLINE> <INDENT> for j in range ( N - M + 1 ) : <NEWLINE> <INDENT> if A [ i ] [ j : j + M ] == B [ 0 ] : <NEWLINE> <INDENT> for k in range ( 1 , M ) : <NEWLINE> <INDENT> if A [ i + k ] [ j : j + M ] != B [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( i + j ) <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <COMMENT> <NL> def combinations_mod ( n , r , mod = 1000000007 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = min ( r , n - r ) <NEWLINE> combs = 1 <NEWLINE> for i , j in zip ( range ( n - r + 1 , n + 1 ) , range ( 1 , r + 1 ) ) : <NEWLINE> <INDENT> combs *= ( i % mod ) * pow ( j , mod - 2 , mod ) <NEWLINE> combs %= mod <NEWLINE> <DEDENT> return combs <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = NMI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> fac = [ 1 ] * ( N + 1 ) <NEWLINE> inv = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = inv [ i - 1 ] * pow ( i , - 1 , MOD ) % MOD <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> max_num = 0 <NEWLINE> min_num = 0 <NEWLINE> if i >= K - 1 : <NEWLINE> <INDENT> max_num = fac [ i ] * inv [ K - 1 ] * inv [ i - K + 1 ] <NEWLINE> <DEDENT> if N - 1 - i >= K - 1 : <NEWLINE> <INDENT> min_num = fac [ N - 1 - i ] * inv [ K - 1 ] * inv [ N - K - i ] <NEWLINE> <DEDENT> ans += ( max_num - min_num ) * A [ i ] % MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> z = True <NEWLINE> j = 0 <NEWLINE> <NL> if 1 not in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if a [ k ] == count + 1 : <NEWLINE> <INDENT> j = k <NEWLINE> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - count ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> A , B , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> offset = 0 <NEWLINE> while offset < K and A + offset <= B : <NEWLINE> <INDENT> print ( A + offset ) <NEWLINE> offset += 1 <NEWLINE> <DEDENT> begin = A + offset <NEWLINE> r = max ( B - K + 1 , begin ) <NEWLINE> while r <= B : <NEWLINE> <INDENT> print ( r ) <NEWLINE> r += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if sum ( a ) >= h else <STRING> ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i1 in range ( min ( k + 1 , s + 1 ) ) : <NEWLINE> <INDENT> for i2 in range ( 0 , min ( k + 1 , s - i1 + 1 ) ) : <NEWLINE> <INDENT> if s - ( i1 + i2 ) <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = LI ( ) <NEWLINE> field = [ S ( ) for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> visited = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if visited [ i ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = collections . deque ( ) <NEWLINE> q . append ( ( i , j ) ) <NEWLINE> b = 0 <NEWLINE> wh = 0 <NEWLINE> while q : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> if visited [ y ] [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wh += 1 <NEWLINE> <DEDENT> visited [ y ] [ x ] = True <NEWLINE> for dy , dx in dd : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if not ( 0 <= ny < h and 0 <= nx < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ y ] [ x ] == field [ ny ] [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if visited [ ny ] [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> ans += b * wh <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> val1 , val2 = a [ 0 ] , a [ 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if val1 % val2 == 0 : <NEWLINE> <INDENT> ans = a [ 0 ] * a [ 1 ] // val2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = val2 <NEWLINE> val2 = val1 % val2 <NEWLINE> val1 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> val1 , val2 = ans , a [ i ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if val1 % val2 == 0 : <NEWLINE> <INDENT> ans *= a [ i ] // val2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = val2 <NEWLINE> val2 = val1 % val2 <NEWLINE> val1 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> f_ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> f_ans += ( ans - 1 ) % a [ i ] <NEWLINE> <DEDENT> print ( int ( f_ans ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> connect = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> connect [ a - 1 ] . add ( b - 1 ) <NEWLINE> connect [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> counter = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> def dfs ( me , parent , cum ) : <NEWLINE> <INDENT> cum += counter [ me ] <NEWLINE> ans [ me ] = cum <NEWLINE> for child in connect [ me ] : <NEWLINE> <INDENT> if child != parent : <NEWLINE> <INDENT> dfs ( child , me , cum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> N , M = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> Xs = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> if N < M : <NEWLINE> <INDENT> Xs . sort ( ) <NEWLINE> ds = [ Xs [ i ] - Xs [ i - 1 ] for i in range ( 1 , M ) ] <NEWLINE> ds . sort ( ) <NEWLINE> <COMMENT> <NL> print ( sum ( ds [ : M - N ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> Num = np . zeros ( ( 3 , 3 ) , dtype = int ) <NEWLINE> Flag = False <NEWLINE> for T in range ( 0 , 3 ) : <NEWLINE> <INDENT> Num [ T , : ] = np . array ( [ int ( X ) for X in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for T in range ( 0 , 3 ) : <NEWLINE> <INDENT> Num [ : , T ] -= Num [ 0 , T ] <NEWLINE> <DEDENT> for A2 in range ( min ( Num [ 1 , : ] ) , max ( Num [ 1 , : ] ) + 1 ) : <NEWLINE> <INDENT> AB2 = np . array ( [ A2 + Num [ 0 , 0 ] , A2 + Num [ 0 , 1 ] , A2 + Num [ 0 , 2 ] ] ) <NEWLINE> if np . all ( AB2 == Num [ 1 , : ] ) : <NEWLINE> <INDENT> for A3 in range ( min ( Num [ 2 , : ] ) , max ( Num [ 2 , : ] ) + 1 ) : <NEWLINE> <INDENT> AB3 = np . array ( [ A3 + Num [ 0 , 0 ] , A3 + Num [ 0 , 1 ] , A3 + Num [ 0 , 2 ] ] ) <NEWLINE> if np . all ( AB3 == Num [ 2 , : ] ) : <NEWLINE> <INDENT> Flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( 10 ** 5 + 1 ) ] <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ a ] . append ( - b ) <NEWLINE> <DEDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for b in AB [ i ] : <NEWLINE> <INDENT> heapq . heappush ( q , b ) <NEWLINE> <DEDENT> if len ( q ) > 0 : <NEWLINE> <INDENT> ans += - heapq . heappop ( q ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> from collections import Counter <NEWLINE> cx = Counter ( x ) <NEWLINE> cxmod = { } <NEWLINE> for k in cx : <NEWLINE> <INDENT> if k % m in cxmod : <NEWLINE> <INDENT> cxmod [ k % m ] += cx [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cxmod [ k % m ] = cx [ k ] <NEWLINE> <DEDENT> <DEDENT> keys = cxmod . keys ( ) <NEWLINE> ans1 , ans2 = 0 , 0 <COMMENT> <NEWLINE> for k in keys : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == m - k : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> elif m - k in keys : <NEWLINE> <INDENT> tmp = min ( cxmod [ k ] , cxmod [ m - k ] ) <NEWLINE> ans1 += tmp <NEWLINE> cxmod [ k ] -= tmp <NEWLINE> cxmod [ m - k ] -= tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in cx : <NEWLINE> <INDENT> v = cx [ k ] <NEWLINE> if v >= 2 and cxmod [ k % m ] >= 2 : <NEWLINE> <INDENT> tmp = min ( v // 2 , cxmod [ k % m ] // 2 ) <NEWLINE> ans2 += tmp <NEWLINE> cxmod [ k % m ] -= tmp * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans1 + ans2 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> y = x // 100 <NEWLINE> z = x % 100 <NEWLINE> if z <= y * 5 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , Y , Z , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> <NL> hq = [ ( - ( A [ 0 ] + B [ 0 ] + C [ 0 ] ) , 0 , 0 , 0 ) ] <NEWLINE> seen = set ( ) <NEWLINE> ans = [ ] <NEWLINE> while len ( ans ) < K : <NEWLINE> <INDENT> s , i , j , k = heappop ( hq ) <NEWLINE> ans . append ( - s ) <NEWLINE> if i < X - 1 and ( i + 1 , j , k ) not in seen : <NEWLINE> <INDENT> heappush ( hq , ( - ( A [ i + 1 ] + B [ j ] + C [ k ] ) , i + 1 , j , k ) ) <NEWLINE> seen . add ( ( i + 1 , j , k ) ) <NEWLINE> <DEDENT> if j < Y - 1 and ( i , j + 1 , k ) not in seen : <NEWLINE> <INDENT> heappush ( hq , ( - ( A [ i ] + B [ j + 1 ] + C [ k ] ) , i , j + 1 , k ) ) <NEWLINE> seen . add ( ( i , j + 1 , k ) ) <NEWLINE> <DEDENT> if k < Z - 1 and ( i , j , k + 1 ) not in seen : <NEWLINE> <INDENT> heappush ( hq , ( - ( A [ i ] + B [ j ] + C [ k + 1 ] ) , i , j , k + 1 ) ) <NEWLINE> seen . add ( ( i , j , k + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = 2 * C * min ( X , Y ) + 2 * C * ( max ( X , Y ) - min ( X , Y ) ) <NEWLINE> <NL> <COMMENT> <NL> if X > Y : <NEWLINE> <INDENT> b = 2 * C * Y + ( X - Y ) * A <NEWLINE> <DEDENT> elif Y > X : <NEWLINE> <INDENT> b = 2 * C * X + ( Y - X ) * B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = A * X + B * Y <NEWLINE> <NL> print ( min ( a , b , c ) ) <NEWLINE>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> total = copy . copy ( t ) <NEWLINE> total [ a - 1 ] = b <NEWLINE> print ( sum ( total ) ) <NEWLINE> <DEDENT>
s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , k ) : <NEWLINE> <INDENT> if s [ i ] != 1 : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> l = [ 1 ] + [ 0 for _ in range ( n + 5 ) ] <NEWLINE> if m == 0 : a = [ 200000 ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> if x < a [ 0 ] : <NEWLINE> <INDENT> l [ x + 1 ] += l [ x ] <NEWLINE> l [ x + 2 ] += l [ x ] <NEWLINE> <DEDENT> if x == a [ 0 ] : <NEWLINE> <INDENT> if len ( a ) >= 2 : a . pop ( 0 ) <NEWLINE> else : a [ 0 ] = 200000 <NEWLINE> <DEDENT> <DEDENT> print ( l [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if R - L >= 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_mod = 2019 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> tmp = ( i * j ) % 2019 <NEWLINE> if tmp < min_mod : <NEWLINE> <INDENT> min_mod = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min_mod ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> T = input ( ) . rstrip ( ) <NEWLINE> <NL> L = N * M // math . gcd ( N , M ) <NEWLINE> <NL> sn = L // M <NEWLINE> tm = L // N <NEWLINE> <NL> for i in range ( N // sn ) : <NEWLINE> <INDENT> if S [ i * sn ] == T [ i * tm ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = n - 1 <NEWLINE> x = int ( math . ceil ( math . sqrt ( n ) ) ) <NEWLINE> <NL> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans = int ( min ( ans , i + n / i - 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
INF = 10 ** 30 <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def bellman_ford ( s , t , g ) : <NEWLINE> <INDENT> d = [ INF for _ in range ( n ) ] <COMMENT> <NEWLINE> d [ s ] = 0 <COMMENT> <NEWLINE> val_at_t = INF <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for x , y , z in g : <NEWLINE> <INDENT> if d [ y ] > d [ x ] + z : <NEWLINE> <INDENT> d [ y ] = d [ x ] + z <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if i == n - 1 and val_at_t > d [ t ] : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> val_at_t = d [ t ] <COMMENT> <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> g = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> z *= - 1 <NEWLINE> g . append ( [ x , y , z ] ) <NEWLINE> <NL> <DEDENT> ans = bellman_ford ( 0 , n - 1 , g ) <NEWLINE> <COMMENT> <NL> print ( - ans [ n - 1 ] if ans else <STRING> ) <NEWLINE>
r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> MAX_N = 3 * 10 ** 6 <NEWLINE> <NL> fact = [ 1 ] <NEWLINE> fact_inv = [ 0 ] * ( MAX_N + 4 ) <NEWLINE> for i in range ( MAX_N + 3 ) : <NEWLINE> <INDENT> fact . append ( fact [ - 1 ] * ( i + 1 ) % mod ) <NEWLINE> <NL> <DEDENT> fact_inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( MAX_N + 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> fact_inv [ i ] = fact_inv [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> def comb ( n , k , mod ) : <NEWLINE> <INDENT> if n < k : return 0 <NEWLINE> return fact [ n ] * fact_inv [ k ] % mod * fact_inv [ n - k ] % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> ans += comb ( c1 + r1 , r1 , mod ) <NEWLINE> ans %= mod <NEWLINE> ans -= comb ( c1 + r2 + 1 , r2 + 1 , mod ) <NEWLINE> ans %= mod <NEWLINE> ans -= comb ( c2 + r1 + 1 , r1 , mod ) <NEWLINE> ans %= mod <NEWLINE> ans += comb ( c2 + r2 + 2 , r2 + 1 , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> n = 100 <NEWLINE> while True : <NEWLINE> <INDENT> if A % n == 0 and B % n == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if ans == K : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> n -= 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> g [ u ] . append ( v ) <NEWLINE> <DEDENT> mi = set ( range ( n ) ) <NEWLINE> flg = False <NEWLINE> def func ( path ) : <NEWLINE> <INDENT> chk = set ( path ) <NEWLINE> if len ( path ) != 2 : <NEWLINE> <INDENT> for i , v in enumerate ( path ) : <NEWLINE> <INDENT> nvs = [ nv for nv in g [ v ] if nv in chk ] <NEWLINE> if len ( nvs ) == 1 : continue <NEWLINE> for nv in nvs : <NEWLINE> <INDENT> if nv == path [ ( i + 1 ) % len ( path ) ] : continue <NEWLINE> ary = [ nv ] <NEWLINE> for j , vj in enumerate ( path ) : <NEWLINE> <INDENT> if vj == nv : break <NEWLINE> <DEDENT> if i > j : <NEWLINE> <INDENT> ary = path [ j : i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ary = path [ : i + 1 ] + path [ j : ] <NEWLINE> <COMMENT> <NL> <DEDENT> func ( ary ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( path ) ) <NEWLINE> for v in path : <NEWLINE> <INDENT> print ( v + 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> def dfs ( v , seen ) : <NEWLINE> <INDENT> mi . discard ( v ) <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if seen [ nv ] != - 1 : <COMMENT> <NEWLINE> <INDENT> seen [ nv ] = v <NEWLINE> path = [ v ] <NEWLINE> chk = { v } <NEWLINE> while seen [ v ] not in chk : <NEWLINE> <INDENT> v = seen [ v ] <NEWLINE> path . append ( v ) <NEWLINE> chk . add ( v ) <NEWLINE> <DEDENT> path . reverse ( ) <NEWLINE> func ( path ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seen [ nv ] = v <NEWLINE> dfs ( nv , seen ) <NEWLINE> seen [ nv ] = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while mi : <NEWLINE> <INDENT> v = mi . pop ( ) <NEWLINE> seen = [ - 1 ] * n <NEWLINE> dfs ( v , seen ) <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> judge = 0 <NEWLINE> dic = { } <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in dic : <NEWLINE> <INDENT> dic [ a [ i ] ] += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a [ i ] ] = b [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> dic = list ( dic . items ( ) ) <NEWLINE> dic . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> <NL> for i in range ( 10 ** 9 ) : <NEWLINE> <INDENT> if judge >= k : <NEWLINE> <INDENT> print ( dic [ i - 1 ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge += int ( dic [ i ] [ 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> m = p [ 0 ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if m >= p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> m = min ( m , p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> L = list ( S ) <NEWLINE> L = set ( L ) <NEWLINE> if N != 26 : <COMMENT> <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> temp = chr ( i + 97 ) <NEWLINE> if temp not in L : <NEWLINE> <INDENT> ans = S + temp <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> M = [ ] <NEWLINE> All = [ chr ( 97 + i ) for i in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> for i in range ( 25 ) : <NEWLINE> <INDENT> now = 25 - i <NEWLINE> M . append ( S [ now ] ) <NEWLINE> if S [ now ] > S [ now - 1 ] : <NEWLINE> <INDENT> M . sort ( ) <NEWLINE> for x in M : <NEWLINE> <INDENT> if x > S [ now - 1 ] : <NEWLINE> <INDENT> temp = x <NEWLINE> ans = S [ : now - 1 ] + temp <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N , M , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> R = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> dist = [ [ 10e8 for _ in range ( N ) ] for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : dist [ i ] [ i ] = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> dist [ a - 1 ] [ b - 1 ] = dist [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> del a , b , c , K <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> dist [ i ] [ j ] = dist [ j ] [ i ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mindist ( x , X ) : <NEWLINE> <INDENT> global dist <NEWLINE> Y = X . copy ( ) <NEWLINE> Y . remove ( x ) <NEWLINE> if len ( Y ) == 0 : return 0 <NEWLINE> return min ( [ dist [ x ] [ y ] + mindist ( y , Y ) for y in Y ] ) <NEWLINE> <NL> <DEDENT> ans = min ( [ mindist ( r , R ) for r in R ] ) <NEWLINE> print ( ans ) <NEWLINE>
N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> <COMMENT> <NL> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find_root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find_root ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union_merge ( self , x , y ) : <NEWLINE> <INDENT> x = self . find_root ( x ) <NEWLINE> y = self . find_root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def union_size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find_root ( x ) ] <NEWLINE> <NL> <DEDENT> def is_same_union ( self , x , y ) : <NEWLINE> <INDENT> return self . find_root ( x ) == self . find_root ( y ) <NEWLINE> <NL> <DEDENT> def same_union_members ( self , x ) : <NEWLINE> <INDENT> root = self . find_root ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find_root ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def union_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_unions ( self ) : <NEWLINE> <INDENT> return [ self . same_union_members ( r ) for r in self . roots ( ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> road = UnionFind ( N ) <NEWLINE> rail = UnionFind ( N ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p , k = map ( int , input ( ) . split ( ) ) <NEWLINE> road . union_merge ( p - 1 , k - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> r , s = map ( int , input ( ) . split ( ) ) <NEWLINE> rail . union_merge ( r - 1 , s - 1 ) <NEWLINE> <NL> <DEDENT> root_combinations = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> root_combinations . append ( ( road . find_root ( i ) , rail . find_root ( i ) ) ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> same_combinations = Counter ( root_combinations ) <NEWLINE> result = [ same_combinations [ root_combination ] for root_combination in root_combinations ] <NEWLINE> <NL> ans = <STRING> . join ( map ( str , result ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10010010 ) <NEWLINE> <NL> def abc146_d ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Q = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> deg = [ 0 ] * n <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> color = dict ( ) <NEWLINE> <NL> for a , b in Q : <NEWLINE> <INDENT> deg [ a ] += 1 <NEWLINE> deg [ b ] += 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( s , p ) : <NEWLINE> <INDENT> nouse = - 1 <NEWLINE> if p > - 1 : nouse = color [ ( min ( s , p ) , max ( s , p ) ) ] <NEWLINE> c = 1 <NEWLINE> for t in adj [ s ] : <NEWLINE> <INDENT> if t == p : continue <NEWLINE> if c == nouse : c += 1 <NEWLINE> color [ ( min ( s , t ) , max ( s , t ) ) ] = c <NEWLINE> dfs ( t , s ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , - 1 ) <NEWLINE> <NL> print ( max ( deg ) ) <NEWLINE> for a , b in Q : <NEWLINE> <INDENT> print ( color [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc146_d ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> x1 = sorted ( X ) [ N // 2 - 1 ] <NEWLINE> x2 = sorted ( X ) [ N // 2 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] >= x2 : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x2 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> TO_K = [ ] <NEWLINE> TREE = [ ] <NEWLINE> <NL> def dfs ( parent , distance ) : <NEWLINE> <INDENT> for i_node in TREE [ parent ] : <NEWLINE> <INDENT> child , dd = i_node <NEWLINE> if TO_K [ child ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> next_dt = distance + dd <NEWLINE> TO_K [ child ] = next_dt <NEWLINE> dfs ( child , next_dt ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> abc = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( n - 1 ) ] <NEWLINE> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( q ) ] <NEWLINE> <NL> global TO_K <NEWLINE> <COMMENT> <NL> TO_K = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> global TREE <NEWLINE> <COMMENT> <NL> TREE = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for a , b , c in abc : <NEWLINE> <INDENT> TREE [ a ] . append ( [ b , c ] ) <NEWLINE> TREE [ b ] . append ( [ a , c ] ) <NEWLINE> <NL> <DEDENT> TO_K [ k ] = 0 <NEWLINE> dfs ( k , 0 ) <NEWLINE> <NL> for x , y in xy : <NEWLINE> <INDENT> print ( TO_K [ x ] + TO_K [ y ] ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> N = I ( ) <NEWLINE> A1 = LI ( ) <NEWLINE> A2 = LI ( ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A1 [ 0 ] + A2 [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , sum ( A1 [ : i ] ) + sum ( A2 [ i - 1 : ] ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import queue <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = qb <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> def dq ( ) : <NEWLINE> <INDENT> return queue . deque ( ) <NEWLINE> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def bitArr ( n ) : <COMMENT> <NEWLINE> <INDENT> x = 1 <NEWLINE> zero = <STRING> * n <NEWLINE> ans = [ ] <NEWLINE> ans . append ( [ 0 ] * n ) <NEWLINE> for i in range ( 2 ** n - 1 ) : <NEWLINE> <INDENT> ans . append ( list ( map ( lambda x : int ( x ) , list ( ( zero + bin ( x ) [ 2 : ] ) [ - 1 * n : ] ) ) ) ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> return ans ; <NEWLINE> <DEDENT> def arrsSum ( a1 , a2 ) : <NEWLINE> <INDENT> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> a1 [ i ] += a2 [ i ] <NEWLINE> <DEDENT> return a1 <NEWLINE> <DEDENT> def maxValue ( a , b , v ) : <NEWLINE> <INDENT> v2 = v <NEWLINE> for i in range ( v2 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( v2 // a + 1 ) : <COMMENT> <NEWLINE> <INDENT> k = i - a * j <NEWLINE> if k % b == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> arr = readInts ( ) <NEWLINE> gu_num = arr [ 0 ] % 2 + arr [ 1 ] % 2 + arr [ 2 ] % 2 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if gu_num not in [ 0 , 3 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if gu_num == 1 : <NEWLINE> <INDENT> if arr [ 0 ] % 2 == 1 : <NEWLINE> <INDENT> arr [ 1 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> elif arr [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if arr [ 0 ] % 2 == 0 : <NEWLINE> <INDENT> arr [ 1 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> elif arr [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ 0 ] += 1 <NEWLINE> arr [ 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> while not ( arr [ 0 ] == arr [ 1 ] and arr [ 1 ] == arr [ 2 ] ) : <NEWLINE> <INDENT> arr [ arr . index ( min ( arr ) ) ] += 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = { } <NEWLINE> for val in A : <NEWLINE> <INDENT> if val in count : <NEWLINE> <INDENT> count [ val ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ val ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> diff = len ( set ( A ) ) - K <NEWLINE> if diff > 0 : <NEWLINE> <INDENT> count_sorted = sorted ( count . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> for k , v in count_sorted : <NEWLINE> <INDENT> ans += v <NEWLINE> diff -= 1 <NEWLINE> if diff == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> a = s . index ( i ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if j in s [ a + 1 : ] : <NEWLINE> <INDENT> b = [ x for x , y in enumerate ( s ) if x > a and y == j ] [ 0 ] <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> if k in s [ b + 1 : ] : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 or b == 0 or ( a < 0 and b > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( a - b ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <COMMENT> <NEWLINE> z = [ ] <COMMENT> <NEWLINE> an = 0 <NEWLINE> zn = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> zn += 1 <NEWLINE> z . append ( y ) <NEWLINE> <DEDENT> elif y == n : <NEWLINE> <INDENT> an += 1 <NEWLINE> a . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> a . sort ( ) <NEWLINE> z . sort ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i < an and j < zn : <NEWLINE> <INDENT> if a [ i ] == z [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] > z [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r_H = list ( reversed ( H ) ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if r_H [ i + 1 ] - r_H [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if r_H [ i + 1 ] - r_H [ i ] == 1 : <NEWLINE> <INDENT> r_H [ i + 1 ] = r_H [ i + 1 ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> <NL> ( n , ) , * p = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> d [ ( p [ i ] [ 0 ] - p [ j ] [ 0 ] , p [ i ] [ 1 ] - p [ j ] [ 1 ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n * ( n < 2 ) or n - max ( d . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> left = s [ : i ] <NEWLINE> right = s [ i : ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for j in set ( left ) : <NEWLINE> <INDENT> if j in set ( right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> lst . append ( cnt ) <NEWLINE> <NL> <DEDENT> if not lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( lst ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if 12 < int ( s [ : 2 ] ) or 0 == int ( s [ : 2 ] ) : <NEWLINE> <INDENT> if 12 >= int ( s [ 2 : ] ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif 1 <= int ( s [ : 2 ] ) <= 12 : <NEWLINE> <INDENT> if 12 >= int ( s [ 2 : ] ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( i + j ) <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> from_jump = max ( 0 , i - k ) <NEWLINE> dp [ i ] = min ( dp [ j ] + abs ( h_l [ i ] - h_l [ j ] ) for j in range ( from_jump , i ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> harry = np . array ( h ) <NEWLINE> ans = np . count_nonzero ( harry >= K ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> <NL> <NL> nf = math . factorial ( n ) % p <NEWLINE> mf = math . factorial ( m ) % p <NEWLINE> <NL> if abs ( n - m ) > 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif n == m : <NEWLINE> <INDENT> ans = nf * mf * 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = nf * mf <NEWLINE> <NL> <DEDENT> print ( ans % p ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> t = n - 1 <NEWLINE> while t >= 0 : <NEWLINE> <INDENT> if s [ t ] == <STRING> : <NEWLINE> <INDENT> if t < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> and s [ t - 5 ] == <STRING> : <NEWLINE> <INDENT> t -= 6 <NEWLINE> <DEDENT> elif t < 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> and s [ t - 5 ] == <STRING> and s [ t - 6 ] == <STRING> : <NEWLINE> <INDENT> t -= 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ t ] == <STRING> : <NEWLINE> <INDENT> if t < 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> : <NEWLINE> <INDENT> t -= 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ t ] == <STRING> : <NEWLINE> <INDENT> if t < 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> : <NEWLINE> <INDENT> t -= 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def DFS ( v , p_v ) : <NEWLINE> <INDENT> for next_v in tree [ v ] : <NEWLINE> <INDENT> if next_v == p_v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ next_v ] += cnt [ v ] <NEWLINE> DFS ( next_v , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 0 , - 1 ) <NEWLINE> print ( * cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == t [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if j == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> graph [ int ( input ( ) ) - 1 ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( x ) : <NEWLINE> <INDENT> arr = [ dfs ( y ) for y in graph [ x ] ] <NEWLINE> if not ( arr ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> arr . sort ( reverse = True ) <NEWLINE> return max ( i + a for i , a in enumerate ( arr , 1 ) ) <NEWLINE> <NL> <DEDENT> print ( dfs ( 0 ) ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> L = len ( S ) <NEWLINE> Slist = set ( ) <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> Slist . add ( ord ( S [ i ] ) ) <NEWLINE> <DEDENT> Slist = list ( Slist ) <NEWLINE> Slist . sort ( ) <NEWLINE> ans = <STRING> <NEWLINE> j = 0 <NEWLINE> L = len ( Slist ) <NEWLINE> for i in range ( 97 , 123 ) : <NEWLINE> <INDENT> if Slist [ j ] == i : <NEWLINE> <INDENT> j += 1 <NEWLINE> if j >= L and i + 1 < 123 : <NEWLINE> <INDENT> ans = chr ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> ans = chr ( i ) <NEWLINE> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> if a == i : <NEWLINE> <INDENT> if i != len ( A ) : <NEWLINE> <INDENT> x = A [ i - 1 ] <NEWLINE> y = A [ i ] <NEWLINE> A [ i - 1 ] = y <NEWLINE> A [ i ] = x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = A [ i - 2 ] <NEWLINE> y = A [ i - 1 ] <NEWLINE> A [ i - 2 ] = y <NEWLINE> A [ i - 1 ] = x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import copy <NEWLINE> li = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> ans += A [ j ] <NEWLINE> li . append ( copy . copy ( ans ) ) <NEWLINE> <NL> <DEDENT> li . sort ( ) <NEWLINE> ans = 0 <NEWLINE> temp = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <INDENT> if li [ i ] == li [ i + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> temp = 1 <NEWLINE> <DEDENT> <DEDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( input ( ) ) + int ( input ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> reb_a = a [ : : - 1 ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res = reb_a [ : : 2 ] + a [ : : 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = reb_a [ : : 2 ] + a [ 1 : : 2 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( res ) ) <NEWLINE>
<STRING> <NEWLINE> <NL> from numpy import ceil , array , sum <NEWLINE> import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def is_ok ( m ) : <NEWLINE> <INDENT> tmp = h - m * B <NEWLINE> tmp [ tmp < 0 ] = 0 <NEWLINE> <NL> if ceil ( tmp / ( A - B ) ) . sum ( ) > m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> h = array ( list ( int ( input ( ) ) for _ in range ( N ) ) ) <NEWLINE> <COMMENT> <NL> <NL> r = 10 ** 9 <NEWLINE> l = 0 <NEWLINE> <NL> while abs ( l - r ) > 1 : <NEWLINE> <NL> <INDENT> m = ( r + l ) // 2 <NEWLINE> <NL> if is_ok ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l1_cnt = Counter ( l1 ) <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> l2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l2_cnt = Counter ( l2 ) <NEWLINE> l2_set = set ( l2 ) <NEWLINE> <NL> for i in l2_set : <NEWLINE> <INDENT> if l2_cnt [ i ] <= l1_cnt [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> total2 = 0 <NEWLINE> i = 1 <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if b [ i + 1 ] <= b [ i ] : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if total2 <= total : <NEWLINE> <INDENT> total2 = total <NEWLINE> <DEDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( total2 , total ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> d = { } <NEWLINE> k1 = [ 0 for i in range ( 10 ) ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if k1 [ int ( S [ i ] ) ] != 0 : continue <NEWLINE> k1 [ int ( S [ i ] ) ] += 1 <NEWLINE> k2 = [ 0 for i in range ( 10 ) ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if k2 [ int ( S [ j ] ) ] != 0 : continue <NEWLINE> k2 [ int ( S [ j ] ) ] += 1 <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> st = <STRING> . join ( [ S [ i ] , S [ j ] , S [ k ] ] ) <NEWLINE> d [ st ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( d ) ) <NEWLINE>
S = set ( x for x in input ( ) ) <NEWLINE> if len ( S ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( S ) == 2 : <NEWLINE> <INDENT> if <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def main ( i ) : <NEWLINE> <INDENT> blue = math . factorial ( k - 1 ) // ( math . factorial ( i - 1 ) * math . factorial ( k - i ) ) <NEWLINE> red = math . factorial ( n - k + 1 ) // ( math . factorial ( n - k + 1 - i ) * math . factorial ( i ) ) <NEWLINE> print ( ( blue * red ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i > n - k + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect_right ( L , L [ a ] + L [ b ] - 1 ) - b - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> import numpy as np <NEWLINE> import scipy . sparse . csgraph as csg <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ST = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <COMMENT> <NL> A = np . array ( [ [ inf ] * N ] * N ) <NEWLINE> for a , b , c in ABC : <NEWLINE> <INDENT> A [ a - 1 ] [ b - 1 ] = c <NEWLINE> A [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> A = csg . floyd_warshall ( A ) <NEWLINE> <NL> <COMMENT> <NL> B = np . array ( [ [ inf ] * N ] * N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if A [ i ] [ j ] <= L : <NEWLINE> <INDENT> B [ i ] [ j ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> B = csg . floyd_warshall ( B ) <NEWLINE> <NL> for s , t in ST : <NEWLINE> <INDENT> if B [ s - 1 ] [ t - 1 ] == inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( B [ s - 1 ] [ t - 1 ] - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> counter . append ( cnt ) <NEWLINE> print ( max ( counter ) ) <NEWLINE>
S = input ( ) <NEWLINE> i_list = list ( S ) <NEWLINE> i_list = [ int ( i ) for i in i_list ] <NEWLINE> <NL> if i_list [ 0 ] == i_list [ 1 ] or i_list [ 1 ] == i_list [ 2 ] or i_list [ 2 ] == i_list [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // math . gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LCM = 1 <NEWLINE> ans = 0 <NEWLINE> MOD = 1000000007 <NEWLINE> for x in A : <NEWLINE> <INDENT> LCM = lcm ( LCM , x ) <NEWLINE> <DEDENT> for x in A : <NEWLINE> <INDENT> ans += LCM // x <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> chin = [ ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <NL> <INDENT> x = int ( input ( ) ) <NEWLINE> sum += x <NEWLINE> <NL> if x % 10 != 0 : <NEWLINE> <INDENT> chin . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> chin . sort ( ) <NEWLINE> i = 0 <NEWLINE> <NL> while chin != [ ] and i < len ( chin ) and sum % 10 == 0 : <NEWLINE> <INDENT> sum -= chin [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if sum % 10 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
<NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - i - j <NEWLINE> if 0 <= z <= k and i + j + z == s : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> tmp += A [ j ] * B [ j ] <NEWLINE> <DEDENT> if tmp + C > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , l <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> hist = [ 0 ] * 61 <NEWLINE> bs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> s = bin ( a [ i ] ) [ 2 : ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> hist [ len ( s ) - j - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = 1 <NEWLINE> for j in range ( 61 ) : <NEWLINE> <INDENT> sum = ( sum + ( hist [ j ] * ( n - hist [ j ] ) * b ) % MOD ) % MOD <NEWLINE> b *= 2 <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = readinput ( ) <NEWLINE> ans = main ( n , l ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> if ( S [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> if ( S [ i + 2 ] == <STRING> ) : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> pos = int ( input ( ) ) <NEWLINE> a [ pos ] = 1 <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> step = [ 0 ] * ( n + 1 ) <NEWLINE> step [ 0 ] = 1 <NEWLINE> step [ 1 ] = 1 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> step [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != 0 and i != 1 : <NEWLINE> <INDENT> step [ i ] = ( step [ i - 1 ] + step [ i - 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( step [ - 1 ] ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> Ans = 0 <NEWLINE> W_put_place = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> Ans += i - W_put_place <NEWLINE> W_put_place += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> INF = 10 ** 6 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ INF ] * ( 2 ** n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bit = [ <STRING> ] * n <NEWLINE> for x in set ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> bit [ x - 1 ] = <STRING> <NEWLINE> <DEDENT> bit = int ( <STRING> . join ( bit [ : : - 1 ] ) , 2 ) <NEWLINE> for j in range ( 2 ** n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j | bit ] = min ( dp [ j | bit ] , a + dp [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = [ x - 1 for x in a ] <NEWLINE> a2 = [ x + 1 for x in a ] <NEWLINE> b = a + a1 + a2 <NEWLINE> c = collections . Counter ( b ) <NEWLINE> <NL> print ( max ( c . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> answer = [ 0 for _ in range ( n ) ] <NEWLINE> for index in range ( n ) : <NEWLINE> <INDENT> answer [ an [ index ] - 1 ] = str ( index + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( answer ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> if k * 3 == s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = ( a * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> print ( b // x - a // x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b // x - a // x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ a [ i ] - ( i + 1 ) for i in range ( n ) ] <NEWLINE> <NL> b . sort ( ) <NEWLINE> <NL> m1 = b [ n // 2 ] <NEWLINE> s1 = sum ( [ abs ( b [ i ] - m1 ) for i in range ( n ) ] ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> m1 = b [ n // 2 ] <NEWLINE> s1 = sum ( [ abs ( b [ i ] - m1 ) for i in range ( n ) ] ) <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m1 = b [ n // 2 - 1 ] <NEWLINE> m2 = b [ n // 2 ] <NEWLINE> if ( m1 + m2 ) % 2 == 0 : <NEWLINE> <INDENT> l1 = ( m1 + m2 ) // 2 <NEWLINE> s1 = sum ( [ abs ( b [ i ] - l1 ) for i in range ( n ) ] ) <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = ( m1 + m2 ) // 2 <NEWLINE> l2 = l1 + 1 <NEWLINE> s1 = sum ( [ abs ( b [ i ] - l1 ) for i in range ( n ) ] ) <NEWLINE> s2 = sum ( [ abs ( b [ i ] - l2 ) for i in range ( n ) ] ) <NEWLINE> <NL> print ( min ( s1 , s2 ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def solve ( G , p , ans , st , fst , arr , x ) : <NEWLINE> <INDENT> arr [ p ] = x <NEWLINE> cnt_1 = 0 <NEWLINE> z = - 1 <NEWLINE> for nxt in G [ p ] : <NEWLINE> <INDENT> if nxt in st : <NEWLINE> <INDENT> cnt_1 += 1 <NEWLINE> z = nxt <NEWLINE> <DEDENT> <DEDENT> cnt_2 = 0 <NEWLINE> for v in st : <NEWLINE> <INDENT> if p in G [ v ] : <NEWLINE> <INDENT> cnt_2 += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt_1 > 1 or cnt_2 > 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif cnt_1 == 1 and cnt_2 == 1 : <NEWLINE> <INDENT> if fst in G [ p ] : <NEWLINE> <INDENT> for v in st : <NEWLINE> <INDENT> ans . append ( v ) <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = arr [ z ] <NEWLINE> for v in st : <NEWLINE> <INDENT> if arr [ v ] >= k : <NEWLINE> <INDENT> ans . append ( v ) <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT> for nxt in G [ p ] : <NEWLINE> <INDENT> st . add ( nxt ) <NEWLINE> if solve ( G , nxt , ans , st , fst , arr , x + 1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> st . remove ( nxt ) <NEWLINE> <DEDENT> arr [ p ] = 0 <NEWLINE> return False <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> f = False <NEWLINE> st = set ( ) <NEWLINE> arr = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> st . add ( i ) <NEWLINE> if solve ( G , i , ans , st , i , arr , 1 ) : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> st . remove ( i ) <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if R == 1 and G == 1 : <NEWLINE> <INDENT> for b in range ( N // B + 1 ) : <NEWLINE> <INDENT> ans += N - b * B + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> bB = N - r * R - g * G <NEWLINE> if bB >= 0 and bB % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = i * ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <COMMENT> <NEWLINE> <NL> def func ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <COMMENT> <NEWLINE> <DEDENT> if memo [ n ] != - 1 : <NEWLINE> <INDENT> return memo [ n ] <COMMENT> <NEWLINE> <NL> <DEDENT> res = n <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pow6 = 6 ** i <NEWLINE> if pow6 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = min ( res , func ( n - pow6 ) + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pow9 = 9 ** i <NEWLINE> if pow9 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = min ( res , func ( n - pow9 ) + 1 ) <NEWLINE> <NL> <DEDENT> memo [ n ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> max_n = 110000 <NEWLINE> memo = [ - 1 ] * max_n <NEWLINE> ans = func ( N ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> k = 0 <NEWLINE> <NL> if A . count ( 1 ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] == k + 1 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - k ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , z , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( abs ( A [ 0 ] - w ) ) ; exit ( ) <NEWLINE> <DEDENT> print ( max ( abs ( A [ - 1 ] - w ) , abs ( A [ - 2 ] - A [ - 1 ] ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from math import factorial <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10000000000 <NEWLINE> <NL> def binary_search_section ( list , min , max ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> upper = len ( list ) <NEWLINE> lower = - 1 <NEWLINE> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if guess >= min : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> lower = mid <NEWLINE> <DEDENT> <DEDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if guess > max : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> upper = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return [ lower , upper ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <COMMENT> <NEWLINE> aList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> bList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> cList = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> aListSorted = sorted ( aList ) <NEWLINE> bListSorted = sorted ( bList ) <NEWLINE> cListSorted = sorted ( cList ) <NEWLINE> <NL> result = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for b in bListSorted : <NEWLINE> <INDENT> sec = binary_search_section ( aListSorted , aListSorted [ 0 ] , b - 1 ) <NEWLINE> sec2 = binary_search_section ( cListSorted , b + 1 , cListSorted [ - 1 ] ) <NEWLINE> result += ( sec [ 1 ] - sec [ 0 ] - 1 ) * ( sec2 [ 1 ] - sec2 [ 0 ] - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( <STRING> . format ( result ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if N == 1 and M == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif N == 1 and M > 1 : <NEWLINE> <INDENT> ans = M - 2 <NEWLINE> <DEDENT> elif N > 1 and M == 1 : <NEWLINE> <INDENT> ans = N - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( N - 2 ) * ( M - 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> or c == <STRING> or c == <STRING> or c == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <COMMENT> <NL> <INDENT> current_digit = 0 <NEWLINE> pin = <STRING> <NEWLINE> <COMMENT> <NL> k = pin [ current_digit ] <NEWLINE> <NL> for num in s : <NEWLINE> <COMMENT> <NL> <INDENT> if num == k : <NEWLINE> <INDENT> current_digit += 1 <NEWLINE> <COMMENT> <NL> if current_digit <= 2 : <NEWLINE> <INDENT> k = pin [ current_digit ] <NEWLINE> <NL> <DEDENT> elif current_digit == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> if L [ 0 ] % M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> L [ i ] = L [ i ] % M <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> L [ i ] = ( L [ i - 1 ] + L [ i ] ) % M <NEWLINE> <NL> <DEDENT> L = sorted ( L ) <NEWLINE> <NL> alreadythere = [ ] <NEWLINE> import collections <NEWLINE> <NL> cnt = collections . Counter ( ) <NEWLINE> for number in L : <NEWLINE> <INDENT> cnt [ number ] += 1 <NEWLINE> <NL> <DEDENT> L = set ( L ) <NEWLINE> <NL> for i in L : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> K = cnt [ i ] <NEWLINE> count += ( int ( K * ( K - 1 ) / 2 ) + K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = cnt [ i ] <NEWLINE> count += int ( K * ( K - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def dfs ( u , cnt ) : <NEWLINE> <INDENT> cnt += point [ u ] <NEWLINE> counter [ u ] = cnt <NEWLINE> color [ u ] = GRAY <NEWLINE> for v in M [ u ] : <NEWLINE> <INDENT> if color [ v ] == WHITE : <NEWLINE> <INDENT> dfs ( v , cnt ) <NEWLINE> <DEDENT> <DEDENT> color [ u ] = BLACK <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for _ in range ( n ) ] <NEWLINE> point = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> M [ a - 1 ] . append ( b - 1 ) <NEWLINE> M [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> WHITE , GRAY , BLACK = 0 , 1 , 2 <NEWLINE> color = [ WHITE ] * n <NEWLINE> <NL> counter = [ 0 ] * n <NEWLINE> dfs ( 0 , 0 ) <NEWLINE> <NL> print ( * counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> c = b [ i ] * ( - ( - a [ i ] // b [ i ] ) ) - a [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> count += c <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> a [ i - 1 ] += count <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if arr [ i ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> arr [ i + 1 ] , arr [ i ] = arr [ i ] , arr [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> if arr [ n - 1 ] == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> maL = 0 <NEWLINE> miR = N <NEWLINE> for g in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> maL = max ( maL , L ) <NEWLINE> miR = min ( miR , R ) <NEWLINE> <DEDENT> if maL <= miR : <NEWLINE> <INDENT> print ( miR - maL + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> b = b // x + 1 <NEWLINE> a = ( a - 1 ) // x + 1 <NEWLINE> print ( b - a ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> p [ i ] += 1 <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> print ( sum ( p [ : n - k + 1 ] ) ) <NEWLINE>
A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> if B == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif B % A == 0 : <NEWLINE> <INDENT> ans = B // A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B // A + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> A . append ( b ) <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( A ) & set ( B ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> str = a [ 0 ] + b [ 0 ] + c [ 0 ] <NEWLINE> print ( str ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sorted ( d ) <NEWLINE> chuou1 = d [ N // 2 - 1 ] <NEWLINE> chuou2 = d [ ( N // 2 ) ] <NEWLINE> if ( chuou2 - chuou1 < 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( chuou2 - chuou1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( set ( A ) ) <NEWLINE> <NL> if len ( A ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = gcd ( A , B ) <NEWLINE> <COMMENT> <NL> <NL> num = int ( m ** 0.5 ) <COMMENT> <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 2 , num + 1 ) : <NEWLINE> <INDENT> if m % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> while not m % i : <NEWLINE> <INDENT> m /= i <NEWLINE> <NL> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( input ( ) ) for _ in range ( w ) ] <NEWLINE> q = [ int ( input ( ) ) for _ in range ( h ) ] <NEWLINE> p . sort ( reverse = True ) <NEWLINE> q . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> c , r = w + 1 , h + 1 <NEWLINE> while p or q : <NEWLINE> <INDENT> if q and ( not p or p [ - 1 ] > q [ - 1 ] ) : <NEWLINE> <INDENT> ans += q . pop ( ) * c <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += p . pop ( ) * r <NEWLINE> c -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> X = 1 << i <NEWLINE> n = len ( [ 1 for a in A if a & X ] ) <NEWLINE> ans += X * n * ( N - n ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 100 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( A % i == 0 ) and ( B % i == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def check ( start , end ) : <NEWLINE> <INDENT> for i in range ( start , end - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = <STRING> + s + <STRING> <NEWLINE> <NL> <COMMENT> <NL> if not check ( a , c ) or not check ( b , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if d < c : <NEWLINE> <INDENT> for i in range ( b , d + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> cost = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 0 <NEWLINE> ans = [ None ] * n <NEWLINE> <NL> <NL> def dfs ( v , parent ) : <NEWLINE> <INDENT> ans [ v ] = cost . pop ( ) <NEWLINE> if parent != - 1 : <NEWLINE> <INDENT> global m <NEWLINE> m += min ( ans [ v ] , ans [ parent ] ) <NEWLINE> <DEDENT> for v2 in edges [ v ] : <NEWLINE> <INDENT> if v2 == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( v2 , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( m ) <NEWLINE> print ( * ans ) <NEWLINE>
import itertools <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in itertools . product ( range ( K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> if 0 <= ( S - sum ( i ) ) <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S_ba = [ ] <NEWLINE> S_ab = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] < B [ i ] : S_ba . append ( B [ i ] - A [ i ] ) <NEWLINE> elif A [ i ] > B [ i ] : S_ab . append ( A [ i ] - B [ i ] ) <NEWLINE> <NL> <DEDENT> if sum ( S_ba ) > sum ( S_ab ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = len ( S_ba ) <NEWLINE> now = 0 <NEWLINE> rem = sum ( S_ba ) <NEWLINE> S_ab . sort ( reverse = True ) <NEWLINE> for i in range ( len ( S_ab ) ) : <NEWLINE> <INDENT> if rem <= now : break <NEWLINE> now += S_ab [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> counts = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counts . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> counts . append ( count ) <NEWLINE> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( counts [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( counts ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> ODD = defaultdict ( int ) <NEWLINE> EVEN = defaultdict ( int ) <NEWLINE> ALL = set ( [ ] ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ALL . add ( A [ i ] ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> EVEN [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ODD [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( ALL ) == 1 : <NEWLINE> <INDENT> ans = N // 2 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> modd = max ( ODD . values ( ) ) <NEWLINE> meven = max ( EVEN . values ( ) ) <NEWLINE> mlodd = [ ] ; mleven = [ ] <NEWLINE> dicodd = sorted ( ODD . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> diceven = sorted ( EVEN . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ans = N <NEWLINE> if len ( dicodd ) > 1 : <NEWLINE> <INDENT> X = [ dicodd [ 0 ] , dicodd [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = [ dicodd [ 0 ] ] <NEWLINE> <DEDENT> if len ( diceven ) > 1 : <NEWLINE> <INDENT> Y = [ diceven [ 0 ] , diceven [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = [ diceven [ 0 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for x , v in X : <NEWLINE> <INDENT> for y , w in Y : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> temp = N - ( v + w ) <NEWLINE> ans = min ( ans , temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ math . inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) ; print ( n * ( n - 1 ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> min_num = 10 ** 5 <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> min_num = min ( max ( len ( str ( i ) ) , len ( str ( N // i ) ) ) , min_num ) <NEWLINE> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B = NMI ( ) <NEWLINE> GCD = math . gcd ( A , B ) <NEWLINE> N = GCD <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> ls = [ ] <NEWLINE> <NL> for n in range ( 2 , int ( N ** 0.5 ) + 2 ) : <NEWLINE> <NL> <INDENT> if GCD % n == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> while GCD % n == 0 : <NEWLINE> <INDENT> GCD = GCD // n <NEWLINE> ls . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if GCD == 1 : <NEWLINE> <INDENT> print ( cnt + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt + 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xyh = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , h = LI ( ) <NEWLINE> xyh . append ( [ x , y , h ] ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> xyh = sorted ( xyh , key = lambda xyh : xyh [ 2 ] , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> ans = ( 0 , 0 , 0 ) <NEWLINE> for c_x in range ( 101 ) : <NEWLINE> <INDENT> for c_y in range ( 101 ) : <NEWLINE> <INDENT> H = 0 <NEWLINE> flag = True <NEWLINE> for i , ( x , y , h ) in enumerate ( xyh ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> H = h + abs ( x - c_x ) + abs ( y - c_y ) <NEWLINE> <DEDENT> if h != max ( H - abs ( x - c_x ) - abs ( y - c_y ) , 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = ( c_x , c_y , H ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> X , Y , H = ans <NEWLINE> print ( X , Y , H ) <NEWLINE> <NL>
LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N , X , D = LI ( ) <NEWLINE> <NL> <NL> def sumeq ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> if X == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a = i * X + sumeq ( i - 1 ) * D <NEWLINE> b = sumeq ( N - 1 ) - sumeq ( N - i - 1 ) - sumeq ( i - 1 ) <NEWLINE> v = ( a - a % D ) // D <NEWLINE> if a % D in d : <NEWLINE> <INDENT> d [ a % D ] . append ( ( v , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a % D ] = [ ( v , b ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for w in d . values ( ) : <NEWLINE> <INDENT> w . sort ( ) <NEWLINE> ans += w [ 0 ] [ 1 ] + 1 <NEWLINE> x = w [ 0 ] [ 0 ] + w [ 0 ] [ 1 ] <NEWLINE> n = len ( w ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> r = w [ i ] [ 0 ] + w [ i ] [ 1 ] <NEWLINE> if x < w [ i ] [ 0 ] : <NEWLINE> <INDENT> ans += w [ i ] [ 1 ] + 1 <NEWLINE> <DEDENT> elif x < r : <NEWLINE> <INDENT> ans += r - x <NEWLINE> <DEDENT> x = max ( x , r ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> S = set ( [ 1 ] ) <NEWLINE> for i in range ( 2 , X ) : <NEWLINE> <INDENT> b = 2 <NEWLINE> while ( i ** b <= X ) : <NEWLINE> <INDENT> S . add ( i ** b ) <NEWLINE> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( S ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( [ a + b , b - a ] [ b % a > 0 ] ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = sorted ( l ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> cnt += x - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> nyuryoku = [ int ( i ) - 1 for i in sys . stdin ] <NEWLINE> <NL> N = nyuryoku [ 0 ] + 1 <NEWLINE> a_list = nyuryoku [ 1 : ] <NEWLINE> <NL> <NL> cnt_push = 0 <NEWLINE> button_list = [ False ] * N <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> if button_list [ i ] == False : <NEWLINE> <INDENT> button_list [ i ] = True <NEWLINE> cnt_push += 1 <NEWLINE> if a_list [ i ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = a_list [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_push = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt_push ) <NEWLINE> <NL> <STRING> <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> d [ a ] += 1 <NEWLINE> <DEDENT> ans = sum ( [ v % 2 for v in d . values ( ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_sorted_lst = sorted ( x_lst ) <NEWLINE> <NL> median1 = x_sorted_lst [ n // 2 - 1 ] <NEWLINE> median2 = x_sorted_lst [ n // 2 ] <NEWLINE> <NL> if median1 == median2 : <NEWLINE> <INDENT> lst = [ median1 ] * n <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = x_lst [ i ] <NEWLINE> <NL> if x <= median1 : <NEWLINE> <INDENT> lst . append ( median2 ) <NEWLINE> <DEDENT> elif median2 <= x : <NEWLINE> <INDENT> lst . append ( median1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( lst [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> sc = - 1 <NEWLINE> sf = - 1 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> sc = i <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> sf = i <NEWLINE> <NL> <DEDENT> <DEDENT> if ( sc == - 1 ) or ( sf == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sc < sf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if all ( <STRING> . count ( c ) == 1 for c in S [ i : j + 1 ] ) : <NEWLINE> <INDENT> ans = max ( ans , j - i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from builtins import abs <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> num = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> num . append ( num [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num . append ( num [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( num [ r - 1 ] - num [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lists = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lists [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> for i in lists : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> o = [ a [ i ] for i in range ( 2 , n , 2 ) ] <NEWLINE> e = [ a [ h ] for h in range ( 1 , n , 2 ) ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> e . reverse ( ) <NEWLINE> l = e + [ a [ 0 ] ] + o <NEWLINE> print ( * l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o . reverse ( ) <NEWLINE> l = o + [ a [ 0 ] ] + e <NEWLINE> print ( * l ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> if 1 not in a : nums [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i not in a : nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> <DEDENT> print ( nums [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> input_weekday = input ( ) <NEWLINE> <NL> <COMMENT> <NL> result = 0 <NEWLINE> if input_weekday == <STRING> : <NEWLINE> <INDENT> result = 7 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 6 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 5 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 4 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 3 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 2 <NEWLINE> <DEDENT> elif input_weekday == <STRING> : <NEWLINE> <INDENT> result = 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> import math <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> A_cum = np . cumsum ( A ) <NEWLINE> counter = Counter ( A_cum ) <NEWLINE> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( r ) * math . factorial ( n - r ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key , value in counter . items ( ) : <NEWLINE> <INDENT> if value >= 2 : <NEWLINE> <INDENT> ans += cmb ( value , 2 ) <NEWLINE> <DEDENT> if key == 0 : <NEWLINE> <INDENT> ans += value <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( n , k , r , s , p , t ) : <NEWLINE> <INDENT> winHand = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> bestHandMemo = [ <STRING> ] * ( n + 1 ) <COMMENT> <NEWLINE> <NL> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> def calcPoint ( char ) : <NEWLINE> <INDENT> if char == <STRING> : <NEWLINE> <INDENT> return p <NEWLINE> <DEDENT> elif char == <STRING> : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> elif char == <STRING> : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT> def dp ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> elif i <= k : <NEWLINE> <INDENT> bestHandMemo [ i - 1 ] = winHand [ t [ i - 1 ] ] <COMMENT> <NEWLINE> return dp ( i - 1 ) + calcPoint ( t [ i - 1 ] ) <NEWLINE> <DEDENT> elif winHand [ t [ i - 1 ] ] == bestHandMemo [ i - k - 1 ] : <NEWLINE> <INDENT> bestHandMemo [ i - 1 ] = <STRING> <COMMENT> <NEWLINE> return dp ( i - 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> bestHandMemo [ i - 1 ] = winHand [ t [ i - 1 ] ] <NEWLINE> return dp ( i - 1 ) + calcPoint ( t [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> memo [ i ] = dp ( i ) <NEWLINE> <NL> <DEDENT> return memo [ n ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> R , S , P = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> print ( solve ( N , K , R , S , P , T ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> H [ i ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( H ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> num [ a - 1 ] . append ( b ) <NEWLINE> num [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> queue = deque ( ) <NEWLINE> queue . append ( 0 ) <NEWLINE> seen = [ False ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if len ( queue ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num1 = queue . popleft ( ) <NEWLINE> seen [ num1 ] = True <NEWLINE> num2 = num [ num1 ] <NEWLINE> for j in range ( len ( num2 ) ) : <NEWLINE> <INDENT> if seen [ num2 [ j ] - 1 ] == False : <NEWLINE> <INDENT> ans [ num2 [ j ] - 1 ] += ans [ num1 ] <NEWLINE> queue . append ( num2 [ j ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> _2K , _4K = 2 * K , 4 * K <NEWLINE> shape = ( _2K + 1 , _4K + 1 ) <COMMENT> <NEWLINE> Grd = np . zeros ( shape , dtype = <STRING> ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , c = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> x , y = x % _2K , y % _2K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = ( x + K ) % _2K , y % _2K <NEWLINE> <COMMENT> <NL> <DEDENT> if x >= K and y >= K : x -= K ; y -= K <NEWLINE> if x < K and y >= K : x += K ; y -= K <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> Grd [ y , x ] += 1 <NEWLINE> Grd [ y + K , x + K ] += 1 <NEWLINE> Grd [ y + K , x ] += - 1 <NEWLINE> Grd [ y , x + K ] += - 1 <NEWLINE> <DEDENT> del x , y , c <NEWLINE> <NL> <COMMENT> <NL> Grd = Grd . cumsum ( axis = 1 ) . cumsum ( axis = 0 ) <NEWLINE> <COMMENT> <NL> Grd = Grd [ : , : _2K ] + Grd [ : , _2K : _4K ] <NEWLINE> Grd = Grd [ : K , : ] + np . concatenate ( ( Grd [ K : _2K , K : _2K ] , Grd [ K : _2K , : K ] ) , axis = 1 ) <NEWLINE> <NL> ans = Grd . max ( ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( pow ( 10 , 6 ) ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def dfs ( nw , d ) : <NEWLINE> <INDENT> V [ nw ] = d <NEWLINE> for nx in G [ nw ] : <NEWLINE> <INDENT> if V [ nx [ 0 ] ] == - 1 : <NEWLINE> <INDENT> dfs ( nx [ 0 ] , d + nx [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( readline ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , readline ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> G [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> V = [ - 1 ] * n <NEWLINE> dfs ( k - 1 , 0 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> print ( V [ x ] + V [ y ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> soui = 0 <NEWLINE> moji = s [ 0 ] <NEWLINE> <NL> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] and soui == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> soui = 1 <NEWLINE> <DEDENT> elif soui == 1 : <NEWLINE> <INDENT> soui = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> while s [ 0 ] == s [ a ] and a != len ( s ) - 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> while s [ len ( s ) - 1 - b ] == s [ len ( s ) - 1 ] and b != len ( s ) - 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <NL> <DEDENT> if s [ 0 ] == s [ len ( s ) - 1 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if moji != s [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i == len ( s ) - 1 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( ( k * ans ) - ( ( k - 1 ) * ( ( a // 2 ) + ( b // 2 ) - ( ( a + b ) // 2 ) ) ) ) <NEWLINE> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> print ( ( k * len ( s ) ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k * ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1000 ) : <NEWLINE> <INDENT> X = list ( str ( x ) . zfill ( 3 ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> if X [ 0 ] in S [ : N - 2 ] : <NEWLINE> <INDENT> i = S . index ( X [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if X [ 1 ] in S [ i + 1 : N - 1 ] : <NEWLINE> <INDENT> j = S [ i + 1 : N - 1 ] . index ( X [ 1 ] ) + i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if X [ 2 ] in S [ j + 1 : N ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> F = S [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> F = math . gcd ( F , S [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( F ) <NEWLINE>
import copy <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ ] <NEWLINE> graph = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> edge . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> graph [ edge [ - 1 ] [ 0 ] ] . append ( edge [ - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> s , g = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> ans = [ [ INF , INF , INF ] for i in range ( n + 1 ) ] <NEWLINE> q = [ s ] <NEWLINE> d = 0 <NEWLINE> while q : <NEWLINE> <INDENT> nq = [ ] <NEWLINE> d += 1 <NEWLINE> p = d % 3 <NEWLINE> for cf in q : <NEWLINE> <INDENT> for ct in graph [ cf ] : <NEWLINE> <INDENT> if ans [ ct ] [ p ] == INF : <NEWLINE> <INDENT> ans [ ct ] [ p ] = d <NEWLINE> nq . append ( ct ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = copy . deepcopy ( nq ) <NEWLINE> <DEDENT> if ans [ g ] [ 0 ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ g ] [ 0 ] // 3 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = [ x for x in a if x % 2 != 0 ] <NEWLINE> <NL> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> import bisect <NEWLINE> import numpy as np <NEWLINE> amax = a [ - 1 ] <NEWLINE> cent = amax // 2 <NEWLINE> <NL> idx = bisect . bisect_left ( a , cent ) <NEWLINE> if idx == len ( a ) - 1 : <NEWLINE> <INDENT> print ( amax , a [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_idx = np . argmin ( [ abs ( a [ idx ] - cent ) , abs ( a [ idx - 1 ] - cent ) ] ) <NEWLINE> if max_idx : <NEWLINE> <INDENT> print ( amax , a [ idx - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( amax , a [ idx ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> l1 = sorted ( a ) [ - 1 ] <NEWLINE> l2 = sorted ( a ) [ - 2 ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == l1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> <DEDENT> if i != l1 : <NEWLINE> <INDENT> print ( l1 ) <NEWLINE> <DEDENT> <DEDENT>
num = ( int ) ( input ( ) ) <NEWLINE> n = num // 100 <NEWLINE> amari = num % 100 <NEWLINE> if num <= 99 or amari / n > 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x . strip ( ) ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> ans = str ( <STRING> ) <NEWLINE> for i in enumerate ( a ) : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> b . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> for i in b : <NEWLINE> <INDENT> print ( i [ 0 ] + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> to = [ False ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> to [ b - 1 ] = True <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> if lis [ v ] >= 0 : <NEWLINE> <INDENT> return lis [ v ] <NEWLINE> <DEDENT> if len ( edge [ v ] ) == 0 : <NEWLINE> <INDENT> lis [ v ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for u in edge [ v ] : <NEWLINE> <INDENT> ans = max ( ans , dfs ( u ) ) <NEWLINE> <DEDENT> lis [ v ] = ans + 1 <NEWLINE> return ans + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> lis = [ - 1 ] * N <NEWLINE> for r in range ( N ) : <NEWLINE> <INDENT> if to [ r ] == False : <NEWLINE> <INDENT> ans = max ( ans , dfs ( r ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_tmp = sum ( p [ 0 : k ] ) <NEWLINE> d_max = sum ( p [ 0 : k ] ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> d_tmp = d_tmp + p [ k + i ] - p [ i ] <NEWLINE> d_max = max ( d_max , d_tmp ) <NEWLINE> <NL> <DEDENT> ans = ( d_max + k ) / 2 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l = sorted ( l , reverse = True ) <NEWLINE> hissatu = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> hissatu += l [ i ] <NEWLINE> <DEDENT> total = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> total += j <NEWLINE> <DEDENT> print ( total - hissatu ) <NEWLINE>
<COMMENT> <NL> def soinsu_bunkai ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> <NL> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> pf [ m ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> def cmb ( n , r , p ) : <NEWLINE> <NL> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = mod <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = soinsu_bunkai ( M ) <NEWLINE> ans = 1 <NEWLINE> <NL> n = 10 ** 6 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> for i in a . values ( ) : <NEWLINE> <INDENT> x = cmb ( N + i - 1 , i , mod ) <NEWLINE> ans *= x <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import re <NEWLINE> <NL> S = input ( ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> S = re . sub ( <STRING> , <STRING> , S ) <NEWLINE> print ( <STRING> if len ( S ) == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import io <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> def solve ( n , k , a_lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> a_set = set ( a_lst ) <NEWLINE> ak = len ( a_set ) <NEWLINE> diff = ak - k <NEWLINE> if diff < 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a_lst . sort ( ) <NEWLINE> tmp = a_lst [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> cnt_lst = [ ] <NEWLINE> for i in range ( len ( a_lst ) ) : <NEWLINE> <INDENT> if tmp != a_lst [ i ] : <NEWLINE> <INDENT> tmp = a_lst [ i ] <NEWLINE> cnt_lst . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> cnt_lst . append ( cnt ) <NEWLINE> cnt_lst . sort ( ) <NEWLINE> return sum ( cnt_lst [ 0 : diff ] ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = str ( solve ( n , k , a_lst ) ) <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> _DEB = 0 <COMMENT> <NEWLINE> <NL> _INPUT = <STRING> <NEWLINE> _EXPECTED = <STRING> <NEWLINE> <NL> def logd ( str ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _DEB : print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if _DEB : <NEWLINE> <INDENT> sys . stdin = io . StringIO ( _INPUT ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> ans = main ( ) <NEWLINE> <NL> if _DEB : <NEWLINE> <INDENT> print ( ) <NEWLINE> if _EXPECTED . strip ( ) == ans . strip ( ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> L_max = 0 <NEWLINE> R_min = 100000 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if L_max < L : L_max = L <NEWLINE> if R < R_min : R_min = R <NEWLINE> <NL> <NL> <DEDENT> print ( max ( 0 , ( R_min - L_max + 1 ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( f // a // 100 + 1 ) : <NEWLINE> <INDENT> for j in range ( ( f - 100 * a * i ) // b // 100 + 1 ) : <NEWLINE> <INDENT> if a * i * 100 + b * j * 100 < f : <NEWLINE> <INDENT> ans . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ans [ 1 : ] <NEWLINE> D = 0 <NEWLINE> A = [ 0 , 0 ] <NEWLINE> for an in ans : <NEWLINE> <INDENT> m = a * 100 * an [ 0 ] + b * 100 * an [ 1 ] <NEWLINE> slv = e * m // 100 <NEWLINE> M = 0 <NEWLINE> for i in range ( min ( f - m , slv ) // c + 1 ) : <NEWLINE> <INDENT> for j in range ( ( min ( f - m , slv ) - c * i ) // d + 1 ) : <NEWLINE> <INDENT> if i * c + d * j <= min ( slv , f - m ) : <NEWLINE> <INDENT> if M < i * c + d * j : <NEWLINE> <INDENT> M = i * c + d * j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> den = M / ( m + M ) <NEWLINE> if den >= D : <NEWLINE> <INDENT> D = den <NEWLINE> A = [ m + M , M ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( a ) for a in A ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = [ * input ( ) ] ; print ( 2 * min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = A - B <NEWLINE> if abs ( ans ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif K % 2 == 1 : <NEWLINE> <INDENT> ans *= - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def pfact ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : pf [ m ] = 1 <NEWLINE> return pf <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i , j in pfact ( p ) . items ( ) : <NEWLINE> <INDENT> ans *= i ** ( j // n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
str_list = [ ] <NEWLINE> i = 1 <NEWLINE> n_number , l_length = map ( int , input ( ) . split ( ) ) <NEWLINE> while i <= n_number : <NEWLINE> <INDENT> w_1 = input ( ) <NEWLINE> str_list . append ( w_1 ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> str_list . sort ( ) <NEWLINE> print ( <STRING> . join ( str_list ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import copy <NEWLINE> <NL> def next_permutation ( a ) : <NEWLINE> <INDENT> for i in reversed ( range ( len ( a ) - 1 ) ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> j = next ( j for j in reversed ( range ( i + 1 , len ( a ) ) ) if a [ i ] < a [ j ] ) <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> a [ i + 1 : ] = reversed ( a [ i + 1 : ] ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> if len ( S ) == 26 : <NEWLINE> <INDENT> sl = list ( S ) <NEWLINE> if next_permutation ( sl ) : <NEWLINE> <INDENT> np = <STRING> . join ( sl ) <NEWLINE> for b in range ( 0 , 26 ) : <NEWLINE> <INDENT> if np [ b ] != S [ b ] : <NEWLINE> <INDENT> print ( np [ : b + 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> hist = set ( S ) <NEWLINE> for c in range ( 0 , 27 ) : <NEWLINE> <INDENT> cand = chr ( c + ord ( <STRING> ) ) <NEWLINE> if cand not in hist : <NEWLINE> <INDENT> print ( S + cand ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dic = { } <NEWLINE> isOK = False <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a in [ 1 , n ] : <NEWLINE> <INDENT> dic . setdefault ( b , 0 ) <NEWLINE> dic [ b ] += 1 <NEWLINE> if dic [ b ] == 2 : <NEWLINE> <INDENT> isOK = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif b in [ 1 , n ] : <NEWLINE> <INDENT> dic . setdefault ( a , 0 ) <NEWLINE> dic [ a ] += 1 <NEWLINE> if dic [ a ] == 2 : <NEWLINE> <INDENT> isOK = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if isOK : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p1 = n // 2 <NEWLINE> p2 = n // 2 - 1 <NEWLINE> ans = copy . copy ( l ) <NEWLINE> ans . sort ( ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if i >= ans [ p1 ] : <NEWLINE> <INDENT> print ( ans [ p2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ p1 ] ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin , setrecursionlimit <NEWLINE> input = stdin . readline <NEWLINE> <NL> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> neighborlist = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> neighborlist [ a ] . append ( b ) <NEWLINE> neighborlist [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> pointlist = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> pointlist [ p ] += x <NEWLINE> <NL> <DEDENT> def DFS ( v ) : <NEWLINE> <INDENT> if not checkedlist [ v ] : <NEWLINE> <INDENT> checkedlist [ v ] = True <NEWLINE> <NL> global point <NEWLINE> point += pointlist [ v ] <NEWLINE> for neighbor in neighborlist [ v ] : <NEWLINE> <INDENT> DFS ( neighbor ) <NEWLINE> <NL> <DEDENT> totallist [ v ] = point <NEWLINE> point -= pointlist [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> totallist = [ 0 ] * ( N + 1 ) <NEWLINE> checkedlist = [ False ] * ( N + 1 ) <NEWLINE> point = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if not checkedlist [ i ] : <NEWLINE> <INDENT> DFS ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * totallist [ 1 : ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <NL> <DEDENT> if cnt == 2 : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> b = A [ i ] <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <NL> if a * b != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a * b ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> <NL> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> B = collections . Counter ( A ) . most_common ( ) <NEWLINE> B . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> count = B [ i ] [ 1 ] <NEWLINE> if i + 1 < len ( B ) and B [ i + 1 ] [ 0 ] == B [ i ] [ 0 ] + 1 : <NEWLINE> <INDENT> count += B [ i + 1 ] [ 1 ] <NEWLINE> if i + 2 < len ( B ) and B [ i + 2 ] [ 0 ] == B [ i ] [ 0 ] + 2 : <NEWLINE> <INDENT> count += B [ i + 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while H != 1 : <NEWLINE> <INDENT> H //= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( count + 1 ) : <NEWLINE> <INDENT> ans += 2 ** i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( b // c + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( b // c - ( a - 1 ) // c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> mydict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = <STRING> . join ( sorted ( s [ i ] ) ) <NEWLINE> if tmp not in mydict : <NEWLINE> <INDENT> mydict [ tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += mydict [ tmp ] <NEWLINE> mydict [ tmp ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
b = input ( ) <NEWLINE> base = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> versus = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> print ( versus [ base . index ( b ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = set ( sq ) <NEWLINE> if len ( sq ) == len ( st ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200005 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> abL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> pxL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> to = [ [ ] for _ in range ( 200005 ) ] <NEWLINE> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> <NL> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> for u in to [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ u ] += ans [ v ] <NEWLINE> dfs ( u , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for a , b in abL : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for p , x in pxL : <NEWLINE> <INDENT> p -= 1 <NEWLINE> ans [ p ] += x <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> <NL> for a in ans [ : n ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> fb = b // x + 1 <NEWLINE> if a != 0 : <NEWLINE> <INDENT> fa = ( a - 1 ) // x + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fa = 0 <NEWLINE> <DEDENT> print ( fb - fa ) <NEWLINE>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = [ 0 ] * N <NEWLINE> cost = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ct [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ct [ i ] [ 1 ] <= T : <NEWLINE> <INDENT> cost . append ( ct [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if cost == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( cost ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> x = P [ 0 ] <NEWLINE> for p in P : <NEWLINE> <INDENT> if x > p : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = p <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> s . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> y = 0 <NEWLINE> x = [ i % 10 for i in a ] <NEWLINE> if max ( x ) > 0 : <NEWLINE> <INDENT> y = 10 - min ( filter ( lambda i : i != 0 , x ) ) <NEWLINE> <DEDENT> b = [ ( i + 9 ) // 10 * 10 for i in a ] <NEWLINE> print ( sum ( b ) - y ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> r = <STRING> <NEWLINE> for i , v in enumerate ( s ) : <NEWLINE> <INDENT> if v != <STRING> : <NEWLINE> <INDENT> r = v <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minint = 10 ** 9 <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( abs ( a [ 0 ] - a [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> s1 = s1 = sum ( a [ 0 : 1 ] ) <NEWLINE> s2 = sum ( a [ 1 : N ] ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> s1 += a [ i ] <NEWLINE> s2 -= a [ i ] <NEWLINE> <NL> minint = min ( minint , abs ( s1 - s2 ) ) <NEWLINE> <NL> <DEDENT> print ( minint ) <NEWLINE> <DEDENT>
import copy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> def dfs ( start , path ) : <NEWLINE> <INDENT> next_path = copy . copy ( path ) <NEWLINE> global ans <NEWLINE> next_path . append ( start ) <NEWLINE> if len ( next_path ) == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return <NEWLINE> <DEDENT> for i in edges [ start ] : <NEWLINE> <INDENT> if i not in next_path : <NEWLINE> <INDENT> dfs ( i , next_path ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , [ ] ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> i = 1 <NEWLINE> s0 = s [ 0 ] <NEWLINE> ct = 1 <NEWLINE> while i < len ( s ) - 1 : <NEWLINE> <INDENT> if s0 == s [ i ] : <NEWLINE> <INDENT> s0 = s [ i : i + 2 ] <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s0 = s [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> ct += 1 <NEWLINE> <DEDENT> if i >= len ( s ) : <NEWLINE> <INDENT> print ( ct ) <NEWLINE> <DEDENT> elif s0 == s [ i ] : <NEWLINE> <INDENT> print ( ct ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ct + 1 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> hs = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> step = 0 <NEWLINE> while ( True ) : <NEWLINE> <NL> <INDENT> if ( sum ( hs ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> start = None <NEWLINE> stop = None <NEWLINE> <NL> for i , h in enumerate ( hs ) : <NEWLINE> <NL> <INDENT> if ( h > 0 and start is None ) : <NEWLINE> <INDENT> start = i <NEWLINE> <DEDENT> if ( h == 0 and start is not None and stop is None ) : <NEWLINE> <INDENT> stop = i <NEWLINE> <NL> <DEDENT> <DEDENT> if ( start is not None and stop is None ) : <NEWLINE> <INDENT> stop = len ( hs ) <NEWLINE> <NL> <DEDENT> for i in range ( start , stop ) : <NEWLINE> <INDENT> hs [ i ] -= 1 <NEWLINE> <NL> <DEDENT> step += 1 <NEWLINE> <NL> <DEDENT> print ( step ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ k - q ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> b [ ai - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if b [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = 0 <NEWLINE> ca = [ tmp ] <NEWLINE> for x in a : <NEWLINE> <INDENT> tmp += x <NEWLINE> ca . append ( tmp ) <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> bidx = 0 <NEWLINE> cidx = 1 <NEWLINE> didx = 2 <NEWLINE> eidx = 3 <NEWLINE> <NL> for didx in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> p = ca [ cidx ] - ca [ bidx ] <NEWLINE> q = ca [ didx ] - ca [ cidx ] <NEWLINE> r = ca [ eidx ] - ca [ didx ] <NEWLINE> s = ca [ - 1 ] - ca [ eidx ] <NEWLINE> <NL> np = ca [ cidx + 1 ] - ca [ bidx ] <NEWLINE> nq = ca [ didx ] - ca [ cidx + 1 ] <NEWLINE> while cidx + 1 < didx and abs ( p - q ) > abs ( np - nq ) : <NEWLINE> <INDENT> cidx += 1 <NEWLINE> p , q = np , nq <NEWLINE> np = ca [ cidx + 1 ] - ca [ bidx ] <NEWLINE> nq = ca [ didx ] - ca [ cidx + 1 ] <NEWLINE> <NL> <DEDENT> nr = ca [ eidx + 1 ] - ca [ didx ] <NEWLINE> ns = ca [ - 1 ] - ca [ eidx + 1 ] <NEWLINE> while eidx + 1 < n and abs ( r - s ) > abs ( nr - ns ) : <NEWLINE> <INDENT> eidx += 1 <NEWLINE> r , s = nr , ns <NEWLINE> nr = ca [ eidx + 1 ] - ca [ didx ] <NEWLINE> ns = ca [ - 1 ] - ca [ eidx + 1 ] <NEWLINE> <NL> <DEDENT> ans = min ( ans , max ( p , q , r , s ) - min ( p , q , r , s ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l = set ( S [ : i ] ) <NEWLINE> r = set ( S [ i : ] ) <NEWLINE> ans . append ( len ( l & r ) ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from math import gcd <NEWLINE> cm = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cm = cm * a [ i ] // gcd ( cm , a [ i ] ) <NEWLINE> <DEDENT> ai = sum ( pow ( x , mod - 2 , mod ) for x in a ) <NEWLINE> print ( int ( ai * cm % mod ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> health = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s_health = sorted ( health ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( sum ( s_health [ : n - k ] ) ) <NEWLINE>
import math <NEWLINE> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 1 / N <NEWLINE> check = round ( P ** l ) <NEWLINE> while check > 1 : <NEWLINE> <INDENT> if P % ( check ** N ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> check -= 1 <NEWLINE> <DEDENT> print ( check ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , i = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( 1 <= N <= 100 and 1 <= i <= N ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( N - i + 1 ) <NEWLINE>
from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <COMMENT> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> p = X [ i ] [ 0 ] - X [ j ] [ 0 ] <NEWLINE> q = X [ i ] [ 1 ] - X [ j ] [ 1 ] <NEWLINE> if p < 0 : <NEWLINE> <INDENT> p = - p ; q = - q <NEWLINE> <DEDENT> if p == 0 and q < 0 : <NEWLINE> <INDENT> q = - q <NEWLINE> <DEDENT> dic [ ( p , q ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> path = max ( dic . values ( ) ) <NEWLINE> ans = N - path <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mx = sum ( p [ : K ] ) <NEWLINE> cur = mx <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> cur = cur - p [ i ] + p [ i + K ] <NEWLINE> mx = max ( mx , cur ) <NEWLINE> <NL> <DEDENT> ans = ( mx + K ) / 2 <NEWLINE> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> if ( <STRING> in s and <STRING> in s ) : <NEWLINE> <INDENT> if ( s . count ( <STRING> ) == 1 ) : <NEWLINE> <INDENT> if ( s . index ( <STRING> ) < s . index ( <STRING> ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( s . index ( <STRING> ) < s . index ( <STRING> , 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> b , c = [ ] , [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> c . reverse ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> c . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( c + b ) ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = make_divisors ( n ) <NEWLINE> <NL> if len ( x ) % 2 == 0 : <NEWLINE> <INDENT> print ( x [ len ( x ) // 2 ] + x [ ( len ( x ) // 2 ) - 1 ] - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( x [ ( len ( x ) // 2 ) ] * 2 ) - 2 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 , r2 = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , l2 ) <NEWLINE> r = min ( r , r2 ) <NEWLINE> <DEDENT> <DEDENT> if ( l > r ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - l + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <DEDENT> q = deque ( [ [ 0 , - 1 , cnt [ 0 ] ] ] ) <NEWLINE> d = [ - 1 ] * N <NEWLINE> while q : <NEWLINE> <INDENT> cur , fr , p = q . popleft ( ) <NEWLINE> d [ cur ] = p <NEWLINE> for nex in graph [ cur ] : <NEWLINE> <INDENT> if nex == fr : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( [ nex , cur , p + cnt [ nex ] ] ) <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( d [ i ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> func ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
mat = [ [ [ 0 , 0 ] ] * 10 for _ in range ( 10 ) ] <NEWLINE> def dsr ( i ) : <NEWLINE> <INDENT> x , cnt = 0 , 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> w = x + i <NEWLINE> if w > 9 : <NEWLINE> <INDENT> x = w - 9 <NEWLINE> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = w <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> mat [ i ] [ j ] = [ x , cnt - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> x0 = mat [ i ] [ 9 ] [ 1 ] - mat [ i ] [ 8 ] [ 1 ] <COMMENT> <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> mat [ i ] [ j ] [ 1 ] += x0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> dsr ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> cnt = 0 ; x0 = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> d , c = map ( int , input ( ) . split ( ) ) <NEWLINE> q , r = divmod ( c - 1 , 9 ) <NEWLINE> cnt += mat [ d ] [ 8 ] [ 1 ] * q + mat [ d ] [ r ] [ 1 ] - mat [ d ] [ 0 ] [ 1 ] <NEWLINE> x = mat [ d ] [ r ] [ 0 ] <NEWLINE> <COMMENT> <NL> w = x0 + x <NEWLINE> if w > 9 : <NEWLINE> <INDENT> x0 = w - 9 <NEWLINE> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x0 = w <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt - 1 ) <NEWLINE> <NL>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A >= 2 * K : <NEWLINE> <INDENT> for i in range ( A , A + K - 1 + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> valueA = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> valueA += i <NEWLINE> <NL> <DEDENT> <DEDENT> valueB = 0 <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> valueB += ( len ( S ) - 1 - i ) <NEWLINE> <NL> <DEDENT> print ( valueB - valueA ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 1 <NEWLINE> r = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , L ) <NEWLINE> r = min ( r , R ) <NEWLINE> <DEDENT> ans = r - l + 1 <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import networkx as nx <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> MAX = 10 ** 15 <NEWLINE> N , M , S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( range ( 1 , N + 1 ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( u , v , yen = a , snuuk = b ) <NEWLINE> <NL> <DEDENT> yen_path = nx . single_source_dijkstra_path_length ( G , S , weight = <STRING> ) <NEWLINE> snuuk_path = nx . single_source_dijkstra_path_length ( G , T , weight = <STRING> ) <NEWLINE> <NL> ans = [ MAX ] * ( N + 1 ) <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> ans [ i - 1 ] = min ( ans [ i ] , yen_path [ i ] + snuuk_path [ i ] ) <NEWLINE> <DEDENT> for x in ans [ : N ] : <NEWLINE> <INDENT> print ( MAX - x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ls = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s in ls : <NEWLINE> <INDENT> ans += ls [ s ] <NEWLINE> ls [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> md = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] in md : <NEWLINE> <INDENT> md [ s [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> vs = [ ] <NEWLINE> for v in md . values ( ) : <NEWLINE> <INDENT> vs . append ( v ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , 5 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , 5 ) : <NEWLINE> <INDENT> ans += vs [ i ] * vs [ j ] * vs [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> print ( S [ K - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = list ( [ int ( x ) * - 1 for x in input ( ) . split ( ) ] ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> target = heapq . heappop ( A ) * - 1 <NEWLINE> heapq . heappush ( A , ( target // 2 ) * - 1 ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) * - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> first_A_find = s . find ( <STRING> ) <NEWLINE> end_Z_find = s . rfind ( <STRING> ) + 1 <NEWLINE> <NL> print ( end_Z_find - first_A_find ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <DEDENT> print ( min ( R ) - max ( L ) + 1 if min ( R ) - max ( L ) + 1 > 0 else 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val = set ( ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i in val : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val . add ( i ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans . count ( ans [ - 1 ] ) >= 4 : <NEWLINE> <INDENT> print ( ans [ - 1 ] ** 2 ) <NEWLINE> <DEDENT> elif ans . count ( ans [ - 1 ] ) == 3 : <NEWLINE> <INDENT> print ( ans [ - 1 ] * ans [ - 4 ] ) <NEWLINE> <DEDENT> elif ans . count ( ans [ - 1 ] ) == 2 : <NEWLINE> <INDENT> print ( ans [ - 1 ] * ans [ - 3 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ - 1 ] * ans [ - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> st = [ ] <NEWLINE> for e in s : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> if len ( st ) != 0 : <NEWLINE> <INDENT> st . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> st . append ( int ( e ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , st ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ 0 ] * m , [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if max ( l ) <= min ( r ) : <NEWLINE> <INDENT> print ( min ( r ) - max ( l ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> cost = [ [ 0 for _ in range ( ( H * W ) // D + 1 ) ] for i in range ( D ) ] <NEWLINE> L = [ 0 ] * ( H * W ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> L1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> L [ L1 [ j ] - 1 ] = [ i , j ] <NEWLINE> if L1 [ j ] % D != 0 : <NEWLINE> <INDENT> cost [ L1 [ j ] % D ] [ L1 [ j ] // D ] = [ i , j , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost [ L1 [ j ] % D ] [ ( L1 [ j ] // D ) - 1 ] = [ i , j , 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> for j in range ( 1 , len ( cost [ i ] ) ) : <NEWLINE> <INDENT> if cost [ i ] [ j ] != 0 : <NEWLINE> <INDENT> cost [ i ] [ j ] [ 2 ] = cost [ i ] [ j - 1 ] [ 2 ] + abs ( cost [ i ] [ j ] [ 0 ] - cost [ i ] [ j - 1 ] [ 0 ] ) + abs ( cost [ i ] [ j ] [ 1 ] - cost [ i ] [ j - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> c = A % D <NEWLINE> a = A // D <NEWLINE> b = B // D <NEWLINE> if c == 0 : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> <DEDENT> print ( cost [ c ] [ b ] [ 2 ] - cost [ c ] [ a ] [ 2 ] ) <NEWLINE> <DEDENT>
R , G , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> x = N - R * r <NEWLINE> for g in range ( x // G + 1 ) : <NEWLINE> <INDENT> if ( x - G * g ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> h = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> <COMMENT> <NL> inf = 10 ** 9 <NEWLINE> dp = np . full ( N , inf , np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> <NL> for i , e in enumerate ( h [ 1 : ] , 1 ) : <NEWLINE> <INDENT> lb = max ( 0 , i - K ) <NEWLINE> dp [ i ] = np . min ( dp [ lb : i ] + np . abs ( h [ lb : i ] - e ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> key = int ( math . sqrt ( N ) ) <NEWLINE> <NL> ans = 10 ** 12 <NEWLINE> for i in reversed ( range ( 1 , key + 1 ) ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = i - 1 + N // i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = [ ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a += i <NEWLINE> <NL> <DEDENT> if a : <NEWLINE> <INDENT> if i == <STRING> and a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> if i == <STRING> and a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif i == <STRING> and len ( a ) == 0 : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> <DEDENT> print ( len ( a ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if abs ( ai ) >= m : <NEWLINE> <INDENT> m = abs ( ai ) <NEWLINE> mi = i <NEWLINE> <DEDENT> <DEDENT> ret = [ [ mi + 1 , i + 1 ] for i in range ( n ) ] <NEWLINE> if a [ mi ] >= 0 : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ret . append ( [ i + 1 , i + 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> ret . append ( [ i + 2 , i + 1 ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( 2 * n - 1 ) <NEWLINE> for x in ret : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 0 <NEWLINE> ret_M = [ ] <NEWLINE> memo_N = [ 0 ] * N <COMMENT> <NEWLINE> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> i_ = i + 1 <NEWLINE> q = N // i_ <NEWLINE> s = sum ( memo_N [ i_ * ( d + 1 ) - 1 ] for d in range ( 1 , q ) ) <NEWLINE> memo_N [ i ] = ( s % 2 ) ^ A [ i ] <NEWLINE> if memo_N [ i ] : <NEWLINE> <INDENT> M += 1 <NEWLINE> ret_M . append ( i_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE> if M : print ( <STRING> . join ( map ( str , ret_M [ : : - 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
S = input ( ) <NEWLINE> if len ( S ) == 26 : <NEWLINE> <INDENT> done = set ( ) <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> s = ord ( s ) <NEWLINE> if done : <NEWLINE> <INDENT> if max ( done ) < s : <NEWLINE> <INDENT> done . add ( s ) <NEWLINE> if i == 25 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif i != 25 : <NEWLINE> <INDENT> l = 30 <NEWLINE> for d in done : <NEWLINE> <INDENT> if l > abs ( d - s ) and s < d : <NEWLINE> <INDENT> x = d <NEWLINE> l = d - s <NEWLINE> <DEDENT> <DEDENT> print ( S [ : - ( i + 1 ) ] + chr ( x ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr ( ord ( S [ 0 ] ) + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> done . add ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> if not ( chr ( i ) in S ) : <NEWLINE> <INDENT> print ( S + chr ( i ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ input ( ) for _ in range ( n ) ] <NEWLINE> AS = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in AS : <NEWLINE> <INDENT> AS . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AS . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( AS ) ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ input ( ) for _ in range ( N ) ] <NEWLINE> B = [ input ( ) for _ in range ( M ) ] <NEWLINE> <NL> def check ( x , y ) : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if y + i >= N or x + j >= N : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if A [ y + i ] [ x + j ] != B [ i ] [ j ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if check ( i , j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> num = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> if A in num . keys ( ) : <NEWLINE> <INDENT> num [ A ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ A ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j in num . items ( ) : <NEWLINE> <INDENT> if j % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> DAY = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> print ( 7 - DAY . index ( S ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . par = [ - 1 for i in range ( n ) ] <NEWLINE> self . n = n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> <NL> <COMMENT> <NL> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . par [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . par ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def make_adjlist_nond ( n , edges ) : <NEWLINE> <INDENT> res = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> res [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> res [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = NMI ( ) <NEWLINE> edges = [ NLI ( ) for _ in range ( M ) ] <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> ans = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if i == M : <NEWLINE> <INDENT> ans [ i ] = N * ( N - 1 ) // 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> x , y = edges [ i ] [ 0 ] - 1 , edges [ i ] [ 1 ] - 1 <NEWLINE> if uf . is_same ( x , y ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i + 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> num = uf . size ( x ) * uf . size ( y ) <NEWLINE> uf . unite ( x , y ) <NEWLINE> ans [ i ] = ans [ i + 1 ] - num <NEWLINE> <NL> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_A = sum ( A ) <NEWLINE> count = N <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum_A -= A [ i ] <NEWLINE> if ( sum_A ) * 2 >= A [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count -= len ( A [ 0 : i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> a = list ( a ) <NEWLINE> a . reverse ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> <NL> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
n , s = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> f = lambda b , n : n if n < b else n % b + f ( b , n // b ) <NEWLINE> import math <NEWLINE> ans = math . inf <NEWLINE> if n == s : ans = n + 1 <NEWLINE> for b in range ( 2 , math . ceil ( math . sqrt ( n ) ) + 1 ) : <COMMENT> <NEWLINE> <INDENT> if f ( b , n ) == s : <NEWLINE> <INDENT> ans = b ; break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( 1 , math . ceil ( math . sqrt ( n ) ) ) : <COMMENT> <NEWLINE> <INDENT> b = ( n - s ) / p + 1 <NEWLINE> if b > 1 and b == int ( b ) and f ( b , n ) == s : <NEWLINE> <INDENT> ans = min ( ans , int ( b ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == math . inf : ans = - 1 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> n = inint ( ) <NEWLINE> A = inintl ( ) <NEWLINE> <NL> m = min ( A ) <NEWLINE> <NL> mod_min = 10 ** 9 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a % m == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> mod_min = min ( mod_min , a % m ) <NEWLINE> <NL> <DEDENT> if mod_min == 10 ** 9 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . gcd ( m , mod_min ) ) <NEWLINE> <DEDENT>
o = list ( input ( ) ) <NEWLINE> e = list ( input ( ) ) + [ <STRING> ] <NEWLINE> for s , t in zip ( o , e ) : <NEWLINE> <INDENT> print ( s + t , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> list_P = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> list_P [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if list_P [ i ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> x = max ( x , y ) <NEWLINE> <NL> <DEDENT> print ( x * 2 ) <NEWLINE>
import numpy as np <NEWLINE> import warnings <NEWLINE> warnings . filterwarnings ( <STRING> ) <NEWLINE> <NL> Mv = 10 ** 5 <NEWLINE> Mw = 10 ** 11 <NEWLINE> <NL> N , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> v = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w [ i + 1 ] , v [ i + 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> V = np . max ( v ) <NEWLINE> <NL> <COMMENT> <NL> dp = np . array ( [ [ Mw ] * ( Mv + 1 ) ] * ( N + 1 ) ) <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp_arr = np . full ( Mv + 1 , Mw , dtype = int ) <NEWLINE> tmp_arr [ v [ i ] : ] = dp [ i - 1 ] [ : - v [ i ] ] + w [ i ] <NEWLINE> dp [ i ] = np . minimum ( dp [ i - 1 ] , tmp_arr ) <NEWLINE> <NL> <DEDENT> print ( np . max ( np . where ( dp [ N ] <= W , dp [ N ] , 0 ) . nonzero ( ) ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> num = s . count ( <STRING> ) <NEWLINE> <NL> before = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <NL> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> before += i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> after = 0 <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> after += j <NEWLINE> <NL> <DEDENT> print ( before - after ) <NEWLINE>
<COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n - 1 == m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n < 2 * ( n - m - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( x , y ) <NEWLINE> <DEDENT> v = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ uf . find ( i ) ] . append ( ( a [ i ] , i ) ) <NEWLINE> <DEDENT> flag = set ( ) <NEWLINE> ans , cnt = 0 , 0 <NEWLINE> for t in v : <NEWLINE> <INDENT> if t : <NEWLINE> <INDENT> t . sort ( ) <NEWLINE> c , idx = t [ 0 ] <NEWLINE> flag . add ( idx ) <NEWLINE> cnt += 1 <NEWLINE> ans += c <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i ] , i ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt == 2 * ( n - m - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c , idx = a [ i ] <NEWLINE> if idx not in flag : <NEWLINE> <INDENT> ans += c <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mnm = 2 * 10 ** 5 <NEWLINE> ans = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= mnm : <NEWLINE> <INDENT> mnm = i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> Graph = [ [ ] for _ in range ( N + 10 ) ] <NEWLINE> dist = [ 10000000000000 ] * ( N + 10 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> Graph [ u ] . append ( ( v , w ) ) <NEWLINE> Graph [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> dist [ 0 ] = 0 <NEWLINE> <NL> def func ( fromE , now , length ) : <NEWLINE> <INDENT> if fromE != - 1 : <NEWLINE> <INDENT> dist [ now ] = dist [ fromE ] + length <NEWLINE> <DEDENT> for i in range ( len ( Graph [ now ] ) ) : <NEWLINE> <INDENT> target = Graph [ now ] [ i ] [ 0 ] <NEWLINE> lengt = Graph [ now ] [ i ] [ 1 ] <NEWLINE> <NL> if target == fromE : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> func ( now , target , lengt ) <NEWLINE> <NL> <DEDENT> <DEDENT> func ( - 1 , 0 , 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if dist [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import copy <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> grid [ i ] = list ( input ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for sy in range ( H ) : <NEWLINE> <INDENT> for sx in range ( W ) : <NEWLINE> <INDENT> if grid [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> now_grid = copy . deepcopy ( grid ) <NEWLINE> time_grid = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( [ sy , sx , 0 ] ) <NEWLINE> now_grid [ sy ] [ sx ] = <STRING> <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , t = queue . popleft ( ) <NEWLINE> for next_y , next_x in [ [ y + 1 , x ] , [ y , x + 1 ] , [ y - 1 , x ] , [ y , x - 1 ] ] : <NEWLINE> <INDENT> if 0 <= next_y < H and 0 <= next_x < W and now_grid [ next_y ] [ next_x ] != <STRING> : <NEWLINE> <INDENT> queue . append ( [ next_y , next_x , t + 1 ] ) <NEWLINE> time_grid [ next_y ] [ next_x ] = t + 1 <NEWLINE> now_grid [ next_y ] [ next_x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Max = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> Max = max ( Max , time_grid [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , Max ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = a [ i ] <NEWLINE> <NL> <DEDENT> sort_L = sorted ( L . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> for j in sort_L : <NEWLINE> <INDENT> print ( j [ 0 ] + 1 , end = <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> points = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> cnt [ ( 0 , 0 ) ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ ( points [ i ] [ 0 ] - points [ j ] [ 0 ] , points [ i ] [ 1 ] - points [ j ] [ 1 ] ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = n - max ( cnt . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> pn = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> mini = pn [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> mini = min ( mini , pn [ i ] ) <NEWLINE> if mini == pn [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <COMMENT> <NL> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> <NL> for X in range ( K + 1 ) : <NEWLINE> <INDENT> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( X + Y ) <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ ] <NEWLINE> check = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> check += dices [ i ] <NEWLINE> <DEDENT> list . append ( check ) <NEWLINE> for j in range ( N - K ) : <NEWLINE> <INDENT> check -= dices [ j ] <NEWLINE> check += dices [ j + K ] <NEWLINE> list . append ( check ) <NEWLINE> <DEDENT> print ( ( max ( list ) + K ) / 2 ) <NEWLINE>
B = [ False ] * 100005 <NEWLINE> C = [ 0 ] * 100005 <NEWLINE> for i in range ( 2 , 100001 ) : <NEWLINE> <INDENT> if not B [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , 100001 , i ) : <NEWLINE> <INDENT> B [ j ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 , 100001 , 2 ) : <NEWLINE> <INDENT> if not B [ i ] and not B [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 , 100001 ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( C [ b ] - C [ a - 1 ] ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> n = 10 ** 5 <NEWLINE> nums = [ False ] * 2 + [ True ] * ( n - 2 ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if nums [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , n , i ) : <NEWLINE> <INDENT> nums [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pre = 0 <NEWLINE> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if nums [ i ] and nums [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> ans [ i ] += pre + 1 <NEWLINE> pre = ans [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = pre <NEWLINE> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans [ r ] - ans [ max ( l - 2 , 1 ) ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sub_list = [ list ( input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> penalty_list = [ 0 ] * n <COMMENT> <NEWLINE> result_list = [ 0 ] * n <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if sub_list [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> result_list [ int ( sub_list [ i ] [ 0 ] ) - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if result_list [ int ( sub_list [ i ] [ 0 ] ) - 1 ] == 0 : <NEWLINE> <INDENT> penalty_list [ int ( sub_list [ i ] [ 0 ] ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ac_count = 0 <NEWLINE> wa_count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if result_list [ i ] == 1 : <NEWLINE> <INDENT> ac_count += 1 <NEWLINE> wa_count += penalty_list [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> st , sp = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> N_List = [ st , sp ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if st > N_List [ 0 ] : <NEWLINE> <INDENT> N_List [ 0 ] = st <NEWLINE> <DEDENT> if sp < N_List [ 1 ] : <NEWLINE> <INDENT> N_List [ 1 ] = sp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( list ( range ( N_List [ 0 ] , N_List [ 1 ] + 1 ) ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = ( p [ i ] + 1 ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> p = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p [ i ] = p [ i - 1 ] + s [ i - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , p [ i + k ] - p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> b = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def f ( tmp ) : <NEWLINE> <INDENT> tmp . sort ( reverse = True ) <NEWLINE> result = [ ] <NEWLINE> for i in tmp [ 1 : ] : <NEWLINE> <INDENT> if tmp [ 0 ] % i == 0 : <NEWLINE> <INDENT> tmp . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( tmp ) ) : <NEWLINE> <INDENT> result . append ( lcm ( tmp [ 0 ] , tmp [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if result : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> t . sort ( reverse = True ) <NEWLINE> if len ( t ) < 2 : <NEWLINE> <INDENT> print ( t [ 0 ] ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> tmp = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp . append ( lcm ( t [ 0 ] , t [ i ] ) ) <NEWLINE> <DEDENT> while len ( tmp ) > 1 : <NEWLINE> <INDENT> tmp = f ( tmp ) <NEWLINE> <DEDENT> if tmp [ 0 ] > 1000000000000000000 : <NEWLINE> <INDENT> print ( 1000000000000000000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tmp [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> colors = [ 0 for i in range ( 8 ) ] <NEWLINE> tyty = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> c = a // 400 <NEWLINE> if c >= 8 : <NEWLINE> <INDENT> tyty += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> colors [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cNum = 8 - colors . count ( 0 ) <NEWLINE> <NL> minC = max ( cNum , 1 ) <NEWLINE> maxC = cNum + tyty <NEWLINE> <NL> print ( minC , maxC ) <NEWLINE>
import heapq as hq <NEWLINE> n , m = input ( ) . split ( ) <NEWLINE> hq . heapify ( a : = [ - int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> for i in range ( int ( m ) ) : hq . heappush ( a , - ( v : = - hq . heappop ( a ) // 2 ) ) <NEWLINE> print ( - sum ( a ) ) <NEWLINE>
k , s = input ( ) . split ( ) <NEWLINE> k = int ( k ) <NEWLINE> s = int ( s ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from fractions import Fraction <NEWLINE> def S ( n ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while n : <NEWLINE> <INDENT> n , r = divmod ( n , 10 ) <NEWLINE> res += r <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> n = 1 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> n += 1 <NEWLINE> m = Fraction ( n , S ( n ) ) <NEWLINE> temp = n <NEWLINE> for d in range ( len ( str ( n ) ) + 1 ) : <NEWLINE> <INDENT> x = 10 ** ( d + 1 ) * ( n // ( 10 ** ( d + 1 ) ) + 1 ) - 1 <NEWLINE> if Fraction ( x , S ( x ) ) < m : <NEWLINE> <INDENT> m = Fraction ( x , S ( x ) ) <NEWLINE> temp = x <NEWLINE> <DEDENT> <DEDENT> n = temp <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> lsa = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> lsb = collections . deque ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> lsb . append ( lsa [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lsb . appendleft ( lsa [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> lsb . append ( lsa [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lsb . appendleft ( lsa [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( lsb ) ) <NEWLINE>
import math <NEWLINE> def better ( l , ans ) : <NEWLINE> <INDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> ans [ i ] = min ( ans [ i - 1 ] + abs ( l [ i ] - l [ i - 1 ] ) , ans [ i - 2 ] + abs ( l [ i ] - l [ i - 2 ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> ans [ 1 ] = abs ( l [ 1 ] - l [ 0 ] ) <NEWLINE> print ( better ( l , ans ) [ len ( ans ) - 1 ] ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> l = len ( n ) <NEWLINE> if int ( n ) > 9 : <NEWLINE> <INDENT> ans = [ 9 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = n [ l - 1 ] <NEWLINE> for i in range ( 2 , l + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if int ( tmp ) != 9 : <NEWLINE> <INDENT> tmp = int ( n [ l - i ] ) - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp = int ( n [ l - i ] ) <NEWLINE> <DEDENT> if i == l : <NEWLINE> <INDENT> ans . append ( int ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 9 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = deque ( [ ] ) <NEWLINE> t = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if t == 0 : ans . append ( i ) <NEWLINE> else : ans . appendleft ( i ) <NEWLINE> t = 1 - t <NEWLINE> <NL> <DEDENT> if t == 0 : print ( * ans ) <NEWLINE> else : print ( * reversed ( ans ) ) <NEWLINE>
S = input ( ) <NEWLINE> ls_S = list ( S ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while len ( ls_S ) != 0 : <NEWLINE> <INDENT> if <STRING> . join ( ls_S [ len ( ls_S ) - 5 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 5 ] <NEWLINE> <DEDENT> elif <STRING> . join ( ls_S [ len ( ls_S ) - 5 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 5 ] <NEWLINE> <DEDENT> elif <STRING> . join ( ls_S [ len ( ls_S ) - 7 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 7 ] <NEWLINE> <DEDENT> elif <STRING> . join ( ls_S [ len ( ls_S ) - 6 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 6 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> num = math . factorial ( n ) <NEWLINE> dic = { } <NEWLINE> i = 2 <NEWLINE> ans = 1 <NEWLINE> while num != 1 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while num % i == 0 : <NEWLINE> <INDENT> num = num // i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans = ans * cnt <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = collections . Counter ( a ) <NEWLINE> l = list ( l . values ( ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> print ( sum ( l [ k : ] ) ) <NEWLINE>
x = input ( ) <NEWLINE> n = len ( x ) <NEWLINE> <NL> t = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> elif t > 0 and x [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - 2 * cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> rep = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> i = 0 <NEWLINE> for b , c in rep : <NEWLINE> <INDENT> while i < n and b : <NEWLINE> <INDENT> if a [ i ] < c : <NEWLINE> <INDENT> a [ i ] = c <NEWLINE> i += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def calcTime ( x , n = 0 ) : <NEWLINE> <INDENT> if n * ( n + 1 ) // 2 >= x : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return calcTime ( x , n + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> print ( calcTime ( x ) ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> N , C = MAP ( ) <NEWLINE> <NL> n = [ [ ] for _ in range ( C ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , t , c = MAP ( ) <NEWLINE> n [ c - 1 ] . append ( ( s , t ) ) <NEWLINE> <NL> <DEDENT> m = [ [ ] for _ in range ( C ) ] <NEWLINE> <NL> for i in range ( C ) : <NEWLINE> <INDENT> if n [ i ] == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n [ i ] . sort ( key = lambda y : y [ 0 ] ) <NEWLINE> s = n [ i ] [ 0 ] [ 0 ] <NEWLINE> t = n [ i ] [ 0 ] [ 1 ] <NEWLINE> L = len ( n [ i ] ) <NEWLINE> n [ i ] . append ( ( 0 , 0 ) ) <NEWLINE> for j in range ( L ) : <NEWLINE> <INDENT> if j < L and n [ i ] [ j ] [ 1 ] == n [ i ] [ j + 1 ] [ 0 ] : <NEWLINE> <INDENT> t = n [ i ] [ j + 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ i ] . append ( ( s , t ) ) <NEWLINE> s = n [ i ] [ j + 1 ] [ 0 ] <NEWLINE> t = n [ i ] [ j + 1 ] [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for x in m : <NEWLINE> <INDENT> for s , t in x : <NEWLINE> <INDENT> cnt [ s - 1 ] += 1 <NEWLINE> cnt [ t ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cnt = list ( accumulate ( cnt ) ) <NEWLINE> <COMMENT> <NL> print ( max ( cnt ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = [ False ] * 8 <NEWLINE> t = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i < 400 : flag [ 0 ] = True <NEWLINE> elif i < 800 : flag [ 1 ] = True <NEWLINE> elif i < 1200 : flag [ 2 ] = True <NEWLINE> elif i < 1600 : flag [ 3 ] = True <NEWLINE> elif i < 2000 : flag [ 4 ] = True <NEWLINE> elif i < 2400 : flag [ 5 ] = True <NEWLINE> elif i < 2800 : flag [ 6 ] = True <NEWLINE> elif i < 3200 : flag [ 7 ] = True <NEWLINE> elif 3200 <= i : t += 1 <NEWLINE> <NL> <DEDENT> minNum = 0 <NEWLINE> p = flag . count ( True ) <NEWLINE> if p > 0 : minNum = p <NEWLINE> elif p == 0 and t > 0 : <NEWLINE> <INDENT> minNum = 1 <NEWLINE> <NL> <DEDENT> maxNum = p + t <NEWLINE> <NL> print ( minNum , maxNum ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = ( Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in A : <NEWLINE> <INDENT> A [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ C ] = B <NEWLINE> <DEDENT> <DEDENT> A = sorted ( A . items ( ) , reverse = True ) <NEWLINE> tmp = 0 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> while tmp < N : <NEWLINE> <INDENT> i , j = A [ cnt ] <NEWLINE> ans += min ( N - tmp , j ) * i <NEWLINE> cnt += 1 <NEWLINE> tmp += min ( N - tmp , j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> list1 = [ ] <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> or x == <STRING> or x == <STRING> or x == <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> list1 . append ( count ) <NEWLINE> if x != <STRING> and x != <STRING> and x != <STRING> and x != <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( list1 ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x + 1 ) : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z > x or z > y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y == z : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> count += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 2 : <NEWLINE> <INDENT> s = b // x <NEWLINE> t = ( a - 1 ) // x <NEWLINE> print ( s - t ) <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> print ( b // x ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( b // x + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> s = str ( int ( input ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( i ) - a for i in input ( ) . split ( ) ] <NEWLINE> <NL> dp = { 0 : 1 } <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> tmp = list ( dp . items ( ) ) <NEWLINE> for key , value in tmp : <NEWLINE> <INDENT> dp [ key + i ] = dp . get ( key + i , 0 ) + value <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] - 1 ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp_min = p [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= tmp_min : <NEWLINE> <INDENT> tmp_min = p [ i ] <COMMENT> <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> class nCr ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . fa = [ 1 ] * ( self . n + 1 ) <NEWLINE> self . fi = [ 1 ] * ( self . n + 1 ) <NEWLINE> for i in range ( 1 , self . n + 1 ) : <NEWLINE> <INDENT> self . fa [ i ] = self . fa [ i - 1 ] * i % mod <NEWLINE> self . fi [ i ] = pow ( self . fa [ i ] , mod - 2 , mod ) <NEWLINE> <DEDENT> <DEDENT> def comb ( self , n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return self . fa [ n ] * self . fi [ r ] % mod * self . fi [ n - r ] % mod <NEWLINE> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> c = nCr ( n * m ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += i * ( n - i ) * m * m <NEWLINE> ans %= mod <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ans += i * ( m - i ) * n * n <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans * c . comb ( n * m - 2 , k - 2 ) % mod ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( ( n - r * i ) // g + 1 ) : <NEWLINE> <INDENT> if ( n - r * i - g * j ) % b == 0 and ( n - r * i - g * j ) // b >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> l = sorted ( list ( set ( S ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if ord ( l [ i ] ) != 97 + i : <NEWLINE> <INDENT> ans = chr ( 97 + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == 25 and l [ i ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr ( ord ( l [ - 1 ] ) + 1 ) ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> n , m , * LR = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> L = LR [ : : 2 ] <NEWLINE> R = LR [ 1 : : 2 ] <NEWLINE> l = max ( L ) <NEWLINE> r = min ( R ) <NEWLINE> print ( max ( 0 , r - l + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
import statistics <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) - i - 1 for i , a in enumerate ( input ( ) . split ( ) , 1 ) ] <NEWLINE> b = statistics . median_low ( A ) <NEWLINE> c = statistics . median_high ( A ) <NEWLINE> d = sum ( map ( lambda x : abs ( x - b ) , A ) ) <NEWLINE> e = sum ( map ( lambda x : abs ( x - c ) , A ) ) <NEWLINE> print ( min ( d , e ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> s = <STRING> + input ( ) <NEWLINE> <NL> <NL> while s != <STRING> : <NEWLINE> <INDENT> next_s = s <NEWLINE> <NL> if s [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 5 ] <NEWLINE> <DEDENT> if s [ - 7 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 7 ] <NEWLINE> <DEDENT> if s [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 5 ] <NEWLINE> <DEDENT> if s [ - 6 : ] == <STRING> : <NEWLINE> <INDENT> next_s = s [ : - 6 ] <NEWLINE> <NL> <DEDENT> if s == next_s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = next_s <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> bit = [ 0 ] * 60 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> n1 = np . count_nonzero ( ( a >> i ) & 1 ) <NEWLINE> n0 = n - n1 <NEWLINE> ans += ( 2 ** i ) * n1 * n0 % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return len ( lower_divisors + upper_divisors [ : : - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if make_divisors ( i ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> if len ( s ) < 26 : <NEWLINE> <INDENT> for i in range ( 97 , 124 ) : <NEWLINE> <INDENT> if chr ( i ) not in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s + chr ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prep = [ s [ - 1 ] ] <NEWLINE> for i in s [ - 2 : : - 1 ] : <NEWLINE> <INDENT> if i > prep [ - 1 ] : <NEWLINE> <INDENT> prep . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( prep ) == 26 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : - len ( prep ) - 1 ] + min ( i for i in prep if i > s [ - len ( prep ) - 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> a , b = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> b . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return a + b [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 and i % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <NL> <DEDENT> b = make_divisors ( m ) <NEWLINE> <COMMENT> <NL> a = m // n <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i <= a : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> import bisect <NEWLINE> from itertools import product <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> d = defaultdict ( list ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ s [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> def canCreate ( x , y , z ) : <NEWLINE> <INDENT> pos = 0 <NEWLINE> for c in map ( str , [ x , y , z ] ) : <NEWLINE> <INDENT> pos = bisect . bisect_left ( d [ c ] , pos ) <NEWLINE> if pos == len ( d [ c ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> pos = d [ c ] [ pos ] + 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> ans = sum ( [ canCreate ( x , y , z ) for x , y , z in product ( range ( 10 ) , repeat = 3 ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> a_lst = ( [ i for i , x in enumerate ( S ) if x == <STRING> ] ) <NEWLINE> count = 0 <NEWLINE> for j in a_lst : <NEWLINE> <INDENT> if len ( S ) >= j + 3 : <NEWLINE> <INDENT> if S [ j + 1 ] == <STRING> and S [ j + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> S = input ( ) . rstrip ( <STRING> ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> print ( 2 * min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> r = range ( a , b + 1 ) <NEWLINE> for i in sorted ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) : print ( i ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for p in range ( 10 ) : <NEWLINE> <INDENT> s = S . find ( str ( p ) ) <NEWLINE> if s == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for q in range ( 10 ) : <NEWLINE> <INDENT> t = S . find ( str ( q ) , s + 1 ) <NEWLINE> if t == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> u = S . find ( str ( r ) , t + 1 ) <NEWLINE> if u != - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] [ : : - 1 ] <NEWLINE> <NL> color_num = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] >= color_num [ - 1 ] : <NEWLINE> <INDENT> color_num . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = bisect . bisect_right ( color_num , a [ i ] ) <NEWLINE> color_num [ temp ] = a [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( len ( color_num ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> action = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> action . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> memo = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> memo . append ( [ - 1 ] * 3 ) <NEWLINE> <NL> <DEDENT> def dp ( i , a ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return action [ 0 ] [ a ] <NEWLINE> <DEDENT> elif memo [ i ] [ a ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] [ a ] = max ( dp ( i - 1 , ( a + 1 ) % 3 ) , dp ( i - 1 , ( a + 2 ) % 3 ) ) + action [ i ] [ a ] <NEWLINE> return memo [ i ] [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( [ dp ( n - 1 , a ) for a in range ( 3 ) ] ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def dfs ( x , s ) : <NEWLINE> <INDENT> used = { s } <NEWLINE> search = deque ( [ s ] ) <NEWLINE> while search : <NEWLINE> <INDENT> ss = search . pop ( ) <NEWLINE> for sss in x [ ss ] : <NEWLINE> <INDENT> if sss in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( sss ) <NEWLINE> search . append ( sss ) <NEWLINE> <DEDENT> <DEDENT> return used <NEWLINE> <NL> <NL> <DEDENT> def bellmanford ( edges ) : <NEWLINE> <INDENT> coins = [ - float ( <STRING> ) ] * N <NEWLINE> coins [ 0 ] = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> f = True <NEWLINE> for u , v , c in edges : <NEWLINE> <INDENT> if coins [ u ] + c > coins [ v ] : <NEWLINE> <INDENT> coins [ v ] = coins [ u ] + c <NEWLINE> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> return max ( 0 , coins [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> N , M , P = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ ] <NEWLINE> Adake = [ [ ] for _ in range ( N ) ] <NEWLINE> Bdake = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC . append ( ( A - 1 , B - 1 , C - P ) ) <NEWLINE> Adake [ A - 1 ] . append ( B - 1 ) <NEWLINE> Bdake [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> U = dfs ( Adake , 0 ) & dfs ( Bdake , N - 1 ) <NEWLINE> ABC = [ ( a , b , c ) for ( a , b , c ) in ABC if a in U and b in U ] <NEWLINE> <NL> print ( bellmanford ( ABC ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( ( a , b ) ) <NEWLINE> <DEDENT> l2 = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> l2 . append ( ( l [ i ] [ 0 ] - l [ j ] [ 0 ] , l [ i ] [ 1 ] - l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> from collections import Counter <NEWLINE> l2 = max ( Counter ( l2 ) . values ( ) ) <NEWLINE> print ( N - l2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> maxcount = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( H [ i ] >= H [ i + 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> maxcount [ i ] = count <NEWLINE> <NL> <DEDENT> print ( max ( maxcount ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> <NL> m1 = Y [ N // 2 - 1 ] <NEWLINE> m2 = Y [ N // 2 ] <NEWLINE> <NL> medians = [ m2 if x < m2 else m1 for x in X ] <NEWLINE> print ( <STRING> . join ( map ( str , medians ) ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( y - 1 ) <NEWLINE> edge [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( c , p ) : <NEWLINE> <INDENT> for i in edge [ c ] : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] += ans [ c ] <NEWLINE> dfs ( i , c ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> x += 1 & j >> i <NEWLINE> <NL> <DEDENT> tmp = x * ( N - x ) % m <NEWLINE> tmp *= 2 ** i % m <NEWLINE> ans += tmp <NEWLINE> ans %= m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> S = input ( ) . strip ( ) <NEWLINE> c1 = S . count ( <STRING> ) <NEWLINE> c0 = S . count ( <STRING> ) <NEWLINE> print ( min ( c0 , c1 ) * 2 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> N , Q = MI ( ) <NEWLINE> graph = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> point = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = MI ( ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( now , pre = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <INDENT> if next == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> c_d = collections . Counter ( d ) <NEWLINE> c_t = collections . Counter ( t ) <NEWLINE> ans = <STRING> <NEWLINE> for e in c_t : <NEWLINE> <INDENT> if c_t [ e ] <= c_d [ e ] : <NEWLINE> <INDENT> next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> b = a . copy ( ) <NEWLINE> b = list ( set ( b ) ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> c = [ 0 ] * len ( b ) <NEWLINE> j = 0 <NEWLINE> c [ j ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i - 1 ] == a [ i ] : <NEWLINE> <INDENT> c [ j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> c [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if c [ i ] >= 4 : <NEWLINE> <NL> <INDENT> ans = b [ i ] * b [ i ] <NEWLINE> break <NEWLINE> <DEDENT> elif c [ i ] >= 2 : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( b ) ) : <NEWLINE> <INDENT> if c [ j ] >= 2 : <NEWLINE> <INDENT> ans = b [ i ] * b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> ( N , M ) = map ( int , input ( ) . split ( ) ) <NEWLINE> X = map ( int , input ( ) . split ( ) ) <NEWLINE> X = sorted ( X ) <NEWLINE> <NL> Y = [ ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> Y . append ( ( i , X [ i ] - X [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> Y = sorted ( Y , key = lambda x : ( x [ 1 ] ) ) <NEWLINE> Y . reverse ( ) <NEWLINE> <NL> I = list ( map ( lambda x : x [ 0 ] , Y [ 0 : min ( N - 1 , len ( Y ) ) ] ) ) <NEWLINE> I . sort ( ) <NEWLINE> <NL> Z = [ ] <NEWLINE> last = 0 <NEWLINE> for i in range ( 0 , min ( N - 1 , len ( Y ) ) ) : <NEWLINE> <INDENT> if last < I [ i ] : <NEWLINE> <INDENT> Z . append ( X [ last : I [ i ] ] ) <NEWLINE> last = I [ i ] <NEWLINE> <DEDENT> <DEDENT> Z . append ( X [ last : ] ) <NEWLINE> if len ( Z ) == 0 : <NEWLINE> <INDENT> Z . append ( X ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for array in Z : <NEWLINE> <INDENT> if len ( array ) > 0 : <NEWLINE> <INDENT> u = max ( array ) <NEWLINE> l = min ( array ) <NEWLINE> s += u - l <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> edges . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> cur = ( ( n - 1 ) * n ) // 2 <NEWLINE> par = { i : i for i in range ( 1 , n + 1 ) } <NEWLINE> size = { i : 1 for i in range ( 1 , n + 1 ) } <NEWLINE> rank = { i : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if x != par [ x ] : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> <DEDENT> return par [ x ] <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> px , py = find ( x ) , find ( y ) <NEWLINE> res = 0 <NEWLINE> if px != py : <NEWLINE> <INDENT> res = size [ px ] * size [ py ] <NEWLINE> if rank [ px ] < rank [ py ] : <NEWLINE> <INDENT> par [ px ] = py <NEWLINE> size [ py ] += size [ px ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ py ] = px <NEWLINE> size [ px ] += size [ py ] <NEWLINE> if rank [ px ] == rank [ py ] : <NEWLINE> <INDENT> rank [ px ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans . append ( cur ) <NEWLINE> x , y = edges [ i ] <NEWLINE> cur -= union ( x , y ) <NEWLINE> <DEDENT> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> if s == [ s [ 0 ] ] * n : <NEWLINE> <INDENT> print ( n * k // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ss = s * 2 <NEWLINE> ans1 = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> ans1 += 1 <NEWLINE> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> for i in range ( 1 , 2 * n ) : <NEWLINE> <INDENT> if ss [ i ] == ss [ i - 1 ] : <NEWLINE> <INDENT> ss [ i ] = <STRING> <NEWLINE> ans2 += 1 <NEWLINE> <DEDENT> <DEDENT> j = ans2 - ans1 <NEWLINE> print ( ans1 + j * ( k - 1 ) ) <NEWLINE> <DEDENT>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s = 1 <NEWLINE> res = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> s = List [ s - 1 ] <NEWLINE> res += 1 <NEWLINE> if s == 2 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> import numpy as np <NEWLINE> N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> D = np . ndarray ( ( C , C ) , dtype = int ) <NEWLINE> c = np . ndarray ( ( N , N ) , dtype = int ) <NEWLINE> for i in range ( C ) : <NEWLINE> <INDENT> D [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> c -= 1 <NEWLINE> acc = np . zeros ( ( 3 , C ) , dtype = int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> acc [ ( i + j ) % 3 ] += D [ c [ i ] [ j ] ] <NEWLINE> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i , j , k in permutations ( range ( C ) , r = 3 ) : <NEWLINE> <INDENT> ans = min ( ans , acc [ 0 ] [ i ] + acc [ 1 ] [ j ] + acc [ 2 ] [ k ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> nk = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = nk [ 0 ] <NEWLINE> k = nk [ 1 ] <NEWLINE> dp = [ 10 ** 9 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 ( i8 , i8 , i8 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( H , N , magics ) : <NEWLINE> <INDENT> dp = np . full ( ( H + 1 ) , 1 << 31 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = magics [ i ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> dp [ min ( h + A , H ) ] = min ( dp [ min ( h + A , H ) ] , dp [ h ] + B ) <NEWLINE> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> H , N , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> magics = np . array ( [ ( A , B ) for A , B in zip ( * [ iter ( AB ) ] * 2 ) ] , dtype = np . int64 ) <NEWLINE> print ( solve ( H , N , magics ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> result = <STRING> <NEWLINE> if a <= 0 <= b : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif b < 0 and ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> B = copy . copy ( A ) <NEWLINE> B . sort ( ) <NEWLINE> A_max = B [ - 1 ] <NEWLINE> A_max2 = B [ - 2 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] < A_max : <NEWLINE> <INDENT> print ( A_max ) <NEWLINE> <DEDENT> elif A [ i ] == A_max : <NEWLINE> <INDENT> print ( A_max2 ) <NEWLINE> <DEDENT> <DEDENT>
def pow_mod ( n , k , m ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if k & 1 : <NEWLINE> <INDENT> return ( pow_mod ( n , k - 1 , m ) * n % m ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( pow_mod ( n , k // 2 , m ) ** 2 ) % m <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> aaa . sort ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if aaa [ i ] != aaa [ i + 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow_mod ( 2 , ( n // 2 ) , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> if aaa [ i ] != aaa [ i + 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow_mod ( 2 , ( ( n - 1 ) // 2 ) , mod ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> k = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> k = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = 1 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> b = b * i <NEWLINE> if b > 1000000007 : <NEWLINE> <INDENT> b = b % 1000000007 <NEWLINE> <DEDENT> <DEDENT> if b < 1000000000 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b % 1000000007 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h1 = b - x / a / a <NEWLINE> h2 = 2 * x / ( a * b ) <NEWLINE> <NL> <NL> if x == a * a * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif b * a * a / 2 <= x : <NEWLINE> <INDENT> radians = math . atan ( a / 2 / h1 ) <NEWLINE> print ( 90 - math . degrees ( radians ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> radians = math . atan ( h2 / b ) <NEWLINE> print ( 90 - math . degrees ( radians ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = sorted ( [ int ( input ( ) ) for _ in range ( N ) ] ) <NEWLINE> if len ( D ) > 1 : <NEWLINE> <INDENT> i , prev = 0 , None <NEWLINE> while i < ( len ( D ) - 1 ) : <NEWLINE> <INDENT> if D [ i ] == D [ i + 1 ] : <NEWLINE> <INDENT> D . pop ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev = D [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( D ) ) <NEWLINE>
L , R = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> c = set ( ) <NEWLINE> <NL> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> t = i % 2019 <NEWLINE> if t in c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c . add ( t ) <NEWLINE> <NL> <NL> <DEDENT> m = float ( <STRING> ) <NEWLINE> l = list ( c ) <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( l ) ) : <NEWLINE> <INDENT> m = min ( m , l [ i ] * l [ j ] % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> for t in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> total = t * ( t + 1 ) / 2 <NEWLINE> if total >= X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> <NL> dic = { } <NEWLINE> for a in range ( len ( A ) ) : <NEWLINE> <INDENT> tmp = A [ a ] <NEWLINE> if not tmp in dic : <NEWLINE> <INDENT> dic [ tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> values = sorted ( dic . values ( ) ) <NEWLINE> ans = 0 <NEWLINE> if len ( values ) <= K : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = len ( values ) - K <NEWLINE> values = values [ : tmp ] <NEWLINE> ans = sum ( values ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> S = list ( str ( input ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> a = 0 <NEWLINE> ab = 0 <NEWLINE> abc = 0 <NEWLINE> pat = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> a = ( a + pat ) % MOD <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> ab = ( ab + a ) % MOD <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> abc = ( abc + ab ) % MOD <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> tmpa = a <NEWLINE> tmpab = ab <NEWLINE> a = ( 3 * a + pat ) % MOD <NEWLINE> ab = ( 3 * ab + tmpa ) % MOD <NEWLINE> abc = ( 3 * abc + tmpab ) % MOD <NEWLINE> pat = ( pat * 3 ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abc ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> copy_a = sorted ( a , reverse = True ) <NEWLINE> <NL> A_Max = copy_a [ 0 ] <NEWLINE> A_Second = copy_a [ 1 ] <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> if a [ x ] == A_Max : <NEWLINE> <INDENT> print ( A_Second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A_Max ) <NEWLINE> <DEDENT> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> MIN = 10000 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> p = i * j % 2019 <NEWLINE> if p < MIN : MIN = p <NEWLINE> <DEDENT> <DEDENT> print ( MIN ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> templ , tempr = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( templ ) <NEWLINE> r . append ( tempr ) <NEWLINE> <DEDENT> ans = min ( r ) - max ( l ) + 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> at = list ( str ( input ( ) ) ) <NEWLINE> a . append ( at ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j != w - 1 : <NEWLINE> <INDENT> if a [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> for k in range ( i + 1 , h ) : <NEWLINE> <INDENT> if a [ k ] [ j ] == <STRING> : <NEWLINE> <INDENT> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i != h - 1 : <NEWLINE> <INDENT> if a [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( j + 1 , w ) : <NEWLINE> <INDENT> if a [ i ] [ k ] == <STRING> : <NEWLINE> <INDENT> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == h - 1 and j == w - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> le = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> e = sum ( le [ : K ] ) <NEWLINE> ans = e <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> e -= le [ i ] <NEWLINE> e += le [ i + K ] <NEWLINE> ans = max ( ans , e ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = [ ] <NEWLINE> h . sort ( ) <NEWLINE> for i in range ( n + 1 - k ) : <NEWLINE> <INDENT> x = h [ i + k - 1 ] - h [ i ] <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> graph [ r ] . append ( ( l , r , - d ) ) <NEWLINE> graph [ l ] . append ( ( r , l , d ) ) <NEWLINE> <NL> <DEDENT> max_int = 10 ** 10 <NEWLINE> point = [ None for _ in range ( n ) ] <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> Q = deque ( ) <NEWLINE> if point [ v ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Q . extend ( graph [ v ] ) <NEWLINE> while Q : <NEWLINE> <INDENT> next_v , v , d = Q . popleft ( ) <NEWLINE> if point [ v ] is None : <NEWLINE> <INDENT> point [ v ] = 0 <NEWLINE> <DEDENT> if point [ next_v ] is not None : <NEWLINE> <INDENT> if point [ next_v ] != point [ v ] + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> point [ next_v ] = point [ v ] + d <NEWLINE> Q . extend ( graph [ next_v ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys , re <NEWLINE> from math import ceil , floor , sqrt , pi , factorial , gcd <NEWLINE> from copy import deepcopy <NEWLINE> from collections import Counter , deque <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , product , combinations , combinations_with_replacement <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from functools import reduce <NEWLINE> from decimal import Decimal , getcontext <NEWLINE> <COMMENT> <NL> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> def lcm ( a , b ) : return a * b // gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> num_list = [ ] <NEWLINE> str_list = [ ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = i_map ( ) <NEWLINE> str_list = s_row_list ( h ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if str_list [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i != 0 : <NEWLINE> <INDENT> if str_list [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if j != 0 : <NEWLINE> <INDENT> if str_list [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i != h - 1 : <NEWLINE> <INDENT> if str_list [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if j != w - 1 : <NEWLINE> <INDENT> if str_list [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> count = 0 <NEWLINE> b = len ( collections . Counter ( a ) ) <NEWLINE> c = collections . Counter ( a ) . most_common ( ) <NEWLINE> <COMMENT> <NL> for i in range ( min ( k , b ) ) : <NEWLINE> <INDENT> count += c [ i ] [ 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans = len ( a ) - count <NEWLINE> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = int ( input ( ) ) <NEWLINE> a . insert ( bisect . bisect_left ( a , inp ) , inp ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> bef = a [ 0 ] <NEWLINE> co = 0 <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> if i != bef : <NEWLINE> <INDENT> ans += ( co + 1 ) % 2 <NEWLINE> co = 0 <NEWLINE> bef = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> co += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( co + 1 ) % 2 <NEWLINE> print ( ans ) <NEWLINE>
import heapq <NEWLINE> import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> v_1 = v [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> res = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while ( i + j <= min ( n , k ) ) : <NEWLINE> <NL> <INDENT> q = [ ] <NEWLINE> tmp = 0 <NEWLINE> if ( i > 0 ) : <NEWLINE> <INDENT> for l in range ( i ) : <NEWLINE> <INDENT> if ( v [ l ] < 0 ) : <NEWLINE> <INDENT> heapq . heappush ( q , v [ l ] ) <NEWLINE> <DEDENT> tmp += v [ l ] <NEWLINE> <DEDENT> <DEDENT> if ( j > 0 ) : <NEWLINE> <INDENT> for l in range ( j ) : <NEWLINE> <INDENT> if ( v_1 [ l ] < 0 ) : <NEWLINE> <INDENT> heapq . heappush ( q , v_1 [ l ] ) <NEWLINE> <DEDENT> tmp += v_1 [ l ] <NEWLINE> <DEDENT> <DEDENT> for l in range ( k - ( i + j ) ) : <NEWLINE> <INDENT> if ( len ( q ) > 0 ) : <NEWLINE> <INDENT> z = heapq . heappop ( q ) <NEWLINE> tmp -= z <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> res = max ( res , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > 0 and b < 0 ) or ( a < 0 and b > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( ( a + b ) + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> G [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> used = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H = [ ] <NEWLINE> for b , c in G [ i ] : <NEWLINE> <INDENT> heapq . heappush ( H , ( c , i , b ) ) <NEWLINE> <DEDENT> D = [ 10 ** 10 ] * N <NEWLINE> D [ i ] = 0 <NEWLINE> while H : <NEWLINE> <INDENT> c , a , b = heapq . heappop ( H ) <NEWLINE> if D [ b ] < c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> D [ b ] = c <NEWLINE> if a < b : <NEWLINE> <INDENT> used . add ( ( a , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( ( b , a ) ) <NEWLINE> <DEDENT> for d , cc in G [ b ] : <NEWLINE> <INDENT> if D [ d ] > c + cc : <NEWLINE> <INDENT> D [ d ] = c + cc <NEWLINE> heapq . heappush ( H , ( c + cc , b , d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return M - len ( used ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l = [ - 1 ] <NEWLINE> i = 0 <NEWLINE> <NL> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l . append ( l [ i ] + 1 ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while s [ i + cnt ] == <STRING> : <NEWLINE> <INDENT> if i + cnt == len ( s ) - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> if l [ i ] < cnt : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( l [ i ] + 1 ) <NEWLINE> <DEDENT> i += cnt <NEWLINE> cnt -= 1 <NEWLINE> while cnt != - 1 : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( l [ i ] + 1 ) <NEWLINE> <DEDENT> del l [ 0 ] <NEWLINE> ans = sum ( l ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> m = max ( A ) <NEWLINE> mindex = A . index ( m ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i != mindex ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pop = A . pop ( i ) <NEWLINE> print ( max ( A ) ) <NEWLINE> A . insert ( i , pop ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> ab . append ( { a , b } ) <NEWLINE> <DEDENT> import itertools <NEWLINE> <NL> cnt = 0 <NEWLINE> for v in itertools . permutations ( range ( 1 , n ) ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> ok = True <NEWLINE> for v2 in v : <NEWLINE> <INDENT> if { l , v2 } not in ab : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> l = v2 <NEWLINE> <DEDENT> if ok : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> ACGT = { <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if set ( s [ i : j ] ) <= ACGT : <NEWLINE> <INDENT> ans = max ( ans , len ( s [ i : j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> goukei = sum ( S ) <NEWLINE> if goukei % 10 != 0 : <NEWLINE> <INDENT> print ( goukei ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = goukei - S [ i ] <NEWLINE> if temp % 10 == 0 : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> num = list ( range ( n - 1 , - ( n - 1 ) - 2 , - 2 ) ) <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] < 0 : <NEWLINE> <INDENT> num [ i ] = abs ( num [ i ] + 1 ) <NEWLINE> <DEDENT> print ( a [ num [ i ] ] , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XY = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> c = collections . Counter ( ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> xi , yi = XY [ i ] <NEWLINE> xj , yj = XY [ j ] <NEWLINE> c [ ( xi - xj , yi - yj ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - c . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> temp = { } <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> at , bt = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] = at <NEWLINE> temp [ at ] = temp . get ( at , 0 ) + bt <NEWLINE> <DEDENT> a = list ( set ( a ) ) <NEWLINE> a . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt = cnt + temp [ a [ i ] ] <NEWLINE> if cnt >= k : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> A = nl ( ) <NEWLINE> total = sum ( [ abs ( A [ i + 1 ] - A [ i ] ) for i in range ( n - 1 ) ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> start = abs ( A [ 1 ] ) <NEWLINE> end = abs ( A [ - 1 ] ) <NEWLINE> print ( total - abs ( A [ 1 ] - A [ 0 ] ) + start + end ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> start = abs ( A [ 0 ] ) <NEWLINE> end = abs ( A [ - 2 ] ) <NEWLINE> print ( total - abs ( A [ - 2 ] - A [ - 1 ] ) + start + end ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = abs ( A [ 0 ] ) <NEWLINE> end = abs ( A [ - 1 ] ) <NEWLINE> print ( total - abs ( A [ i - 1 ] - A [ i ] ) - <NEWLINE> <INDENT> abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i - 1 ] ) <NEWLINE> + start + end ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def mitsui2019d_lucky_pin ( ) : <NEWLINE> <INDENT> import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for t in itertools . product ( range ( 0 , 10 ) , repeat = 2 ) : <NEWLINE> <INDENT> si = <STRING> . join ( map ( str , t ) ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if si [ 0 ] != s [ i ] : continue <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if si [ 1 ] != s [ j ] : continue <NEWLINE> ss = set ( list ( s [ j + 1 : ] ) ) <NEWLINE> cnt += len ( ss ) <NEWLINE> break <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> mitsui2019d_lucky_pin ( ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import bellman_ford , connected_components <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = np . zeros ( ( n , n ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> c = p - c <NEWLINE> if c == 0 : <NEWLINE> <INDENT> c = 10 ** ( - 7.9 ) <NEWLINE> <DEDENT> if l [ a - 1 ] [ b - 1 ] == 0 : <NEWLINE> <INDENT> l [ a - 1 ] [ b - 1 ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a - 1 ] [ b - 1 ] = min ( l [ a - 1 ] [ b - 1 ] , c ) <NEWLINE> <DEDENT> <DEDENT> x = l [ - 1 , 0 ] <NEWLINE> l [ - 1 ] [ 0 ] = 10 ** ( - 7.9 ) <NEWLINE> n , labels = connected_components ( l , connection = <STRING> ) <NEWLINE> l = l [ labels == labels [ 0 ] ] [ : , labels == labels [ 0 ] ] <NEWLINE> l [ - 1 , 0 ] = x <NEWLINE> <NL> try : <NEWLINE> <INDENT> print ( max ( 0 , int ( round ( bellman_ford ( l , indices = 0 ) [ - 1 ] ) ) * ( - 1 ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 100 <NEWLINE> x = sum ( a ) <NEWLINE> b = 0 <NEWLINE> for i in a [ : - 1 ] : <NEWLINE> <INDENT> b += i <NEWLINE> x -= i <NEWLINE> ans = min ( ans , abs ( x - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ai , bi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a [ i ] += ans <NEWLINE> t = ( b [ i ] - a [ i ] ) % b [ i ] <NEWLINE> ans += t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def warshall_floyd ( d ) : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> d [ i ] [ j ] = min ( d [ i ] [ k ] + d [ k ] [ j ] , d [ i ] [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> d = [ [ float ( <STRING> ) ] * n for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> hen = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ x - 1 ] [ y - 1 ] = z <NEWLINE> d [ y - 1 ] [ x - 1 ] = z <NEWLINE> hen [ i ] = [ x - 1 , y - 1 , z ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] [ i ] = 0 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = warshall_floyd ( d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> answer = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> now = hen [ i ] <NEWLINE> if d [ now [ 0 ] ] [ now [ 1 ] ] != now [ 2 ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL>
n = int ( input ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; d = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in d : d [ i ] = 1 <NEWLINE> else : d [ i ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ j if i > j else j - i for i , j in d . items ( ) ] ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = mi ( ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edge [ u ] . append ( ( v , w ) ) <NEWLINE> edge [ v ] . append ( ( u , w ) ) <NEWLINE> <DEDENT> dist = [ 0 ] * n <NEWLINE> parent = [ - 1 ] * n <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . pop ( ) <NEWLINE> for nv , nx in edge [ v ] : <NEWLINE> <INDENT> if parent [ v ] == nv : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ nv ] = v <NEWLINE> dist [ nv ] = dist [ v ] + nx % 2 <NEWLINE> dist [ nv ] %= 2 <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> print ( * dist , sep = <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 == a [ a [ i ] - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if pow ( i , n , 10 ** 20 ) > p : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if p % pow ( i , n , 10 ** 20 ) == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alice = 0 <NEWLINE> bob = 0 <NEWLINE> <NL> nums . sort ( ) <NEWLINE> while nums : <NEWLINE> <INDENT> alice += nums . pop ( ) <NEWLINE> if nums : <NEWLINE> <INDENT> bob += nums . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ float ( <STRING> ) ] * n <NEWLINE> def dfs ( s , p , depth ) : <NEWLINE> <INDENT> if depth > 2 : return <NEWLINE> dist [ s ] = min ( dist [ s ] , depth ) <NEWLINE> for to in g [ s ] : <NEWLINE> <INDENT> if to == p : continue <NEWLINE> if dist [ to ] < dist [ s ] + 1 : continue <NEWLINE> dfs ( to , s , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> if dist [ n - 1 ] <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> from_one = [ ] <NEWLINE> to_n = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> from_one += [ b ] <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> from_one += [ a ] <NEWLINE> <DEDENT> elif a == N - 1 : <NEWLINE> <INDENT> to_n += [ b ] <NEWLINE> <DEDENT> elif b == N - 1 : <NEWLINE> <INDENT> to_n += [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> from_one = set ( from_one ) <NEWLINE> to_n = set ( to_n ) <NEWLINE> if len ( from_one & to_n ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> a = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> cnt = 1 <NEWLINE> later = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if <STRING> not in s [ i ] : continue <NEWLINE> later . append ( i ) <NEWLINE> fst = True <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if not fst and s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if fst and s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> fst = False <NEWLINE> <DEDENT> a [ i ] [ j ] = cnt <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> for i in later : <NEWLINE> <INDENT> if i >= h - 1 : continue <NEWLINE> if a [ i + 1 ] [ 0 ] != 0 : continue <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> k = i <NEWLINE> while k < h - 1 : <NEWLINE> <INDENT> if a [ k + 1 ] [ j ] == 0 : <NEWLINE> <INDENT> a [ k + 1 ] [ j ] = a [ k ] [ j ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if later [ 0 ] != 0 : <NEWLINE> <INDENT> for i in range ( later [ 0 ] , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> a [ i - 1 ] [ j ] = a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ans in a : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a // gcd ( a , b ) * b <NEWLINE> <DEDENT> t = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> while ( t != 0 ) : <NEWLINE> <INDENT> t -= 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = lcm ( ans , n ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import collections <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( Q ) ] <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> if ( K - Q ) > 0 : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = [ <STRING> ] * N <NEWLINE> for i , v in dict ( c ) . items ( ) : <NEWLINE> <INDENT> if v > ( Q - K ) : <NEWLINE> <INDENT> l [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for j in l : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> start = max ( 0 , i - k ) <NEWLINE> dp [ i ] = min ( dp [ j ] + abs ( l [ i ] - l [ j ] ) for j in range ( start , i ) ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> quantity , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( input ( ) ) <NEWLINE> yes = 0 <NEWLINE> abroad = 0 <NEWLINE> <NL> for i in range ( quantity ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> if yes < ( A + B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yes = yes + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> abroad = abroad + 1 <NEWLINE> if yes < ( A + B ) and abroad <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yes = yes + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> def isPrime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> m = math . floor ( n / 2 ) + 1 <NEWLINE> for p in range ( 3 , m , 2 ) : <COMMENT> <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( X , 10 ** 10 ) : <NEWLINE> <INDENT> if isPrime ( i ) : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> s = set ( N ) <NEWLINE> ans = <STRING> . join ( sorted ( s ) ) <NEWLINE> all = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] != all [ i ] : <NEWLINE> <INDENT> print ( all [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i == len ( ans ) - 1 : <NEWLINE> <INDENT> print ( all [ len ( ans ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A <= 2 * ( K - 1 ) : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def dfs ( upper , lower , left , right , cnt ) : <NEWLINE> <NL> <INDENT> if cnt == 1 : <NEWLINE> <INDENT> ans [ upper : lower , left : right ] = np . max ( ans [ upper : lower , left : right ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> elif cnt != max ( cntrow [ upper : lower ] ) : <NEWLINE> <INDENT> for i in range ( upper , lower ) : <NEWLINE> <INDENT> if cntrow [ i ] : <NEWLINE> <INDENT> ncnt = sum ( cntrow [ upper : i + 1 ] ) <NEWLINE> dfs ( upper , i + 1 , left , right , ncnt ) <NEWLINE> dfs ( i + 1 , lower , left , right , cnt - ncnt ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = cntrow [ upper : lower ] . index ( cnt ) + upper <NEWLINE> for j in range ( left , right ) : <NEWLINE> <INDENT> if g [ idx ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( upper , lower , left , j + 1 , 1 ) <NEWLINE> cntrow [ idx ] -= 1 <NEWLINE> dfs ( upper , lower , j + 1 , right , cnt - 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ <STRING> ] * h <NEWLINE> ans = np . zeros ( shape = ( h , w ) , dtype = int ) <NEWLINE> cnt = 1 <NEWLINE> cntrow = [ 0 ] * h <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> g [ i ] = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if g [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i , j ] = cnt <NEWLINE> cntrow [ i ] += 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , h , 0 , w , k ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( * ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> b = list ( s ) <NEWLINE> b . sort ( ) <NEWLINE> b = <STRING> . join ( b ) <NEWLINE> a . append ( b ) <NEWLINE> <DEDENT> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for e in c : <NEWLINE> <INDENT> ans += c [ e ] * ( c [ e ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> step = [ ] <NEWLINE> <NL> now = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> next = int ( input ( ) ) - 1 <NEWLINE> step . append ( next - now ) <NEWLINE> now = next + 2 <NEWLINE> <NL> <DEDENT> step . append ( n - now ) <NEWLINE> step . sort ( ) <NEWLINE> <NL> def fibo ( ) : <NEWLINE> <INDENT> s = [ ] <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> s . append ( a ) <NEWLINE> s . append ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = a + b <NEWLINE> a = b <NEWLINE> b = c <NEWLINE> s . append ( c ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> if step [ 0 ] < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> f = fibo ( ) <NEWLINE> for i in step : <NEWLINE> <INDENT> ans *= f [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ 0 for i in range ( 1 , n + 1 ) ] <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if lis [ p - 1 ] != - 1 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> wa += lis [ p - 1 ] <NEWLINE> ac += 1 <NEWLINE> lis [ p - 1 ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
with open ( 0 ) as f : <NEWLINE> <INDENT> N , * a = map ( int , f . read ( ) . split ( ) ) <NEWLINE> <DEDENT> F = [ x for x in a [ : N ] ] <COMMENT> <NEWLINE> C = [ x for x in a [ N : 2 * N ] ] <NEWLINE> B = [ - x for x in a [ 2 * N : ] ] <COMMENT> <NEWLINE> import heapq as hq <NEWLINE> <COMMENT> <NL> hq . heapify ( F ) <NEWLINE> hq . heapify ( B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from copy import deepcopy <NEWLINE> memoF = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> memoF [ 0 ] = sum ( F ) <NEWLINE> memoB = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> memoB [ N ] = sum ( B ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] > F [ 0 ] : <NEWLINE> <INDENT> memoF [ i + 1 ] = memoF [ i ] + C [ i ] - hq . heapreplace ( F , C [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memoF [ i + 1 ] = memoF [ i ] <NEWLINE> <NL> <DEDENT> if - C [ N - 1 - i ] > B [ 0 ] : <NEWLINE> <INDENT> memoB [ N - 1 - i ] = memoB [ N - i ] - C [ N - 1 - i ] - hq . heapreplace ( B , - C [ N - 1 - i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memoB [ N - 1 - i ] = memoB [ N - i ] <NEWLINE> <NL> <DEDENT> <DEDENT> Scores = [ memoF [ i ] + memoB [ i ] for i in range ( N + 1 ) ] <NEWLINE> ans = max ( Scores ) <NEWLINE> print ( ans ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> for x in range ( M ) : <NEWLINE> <INDENT> t = ( - 1 ) * heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , ( - 1 ) * ( t // 2 ) ) <NEWLINE> <DEDENT> print ( - 1 * sum ( A ) ) <NEWLINE>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> import statistics <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> n = get_int ( ) <NEWLINE> <NL> a_list = get_int_list ( ) <NEWLINE> b_list = get_int_list ( ) <NEWLINE> c_list = get_int_list ( ) <NEWLINE> <NL> a_list . sort ( ) <NEWLINE> b_list . sort ( ) <NEWLINE> c_list . sort ( ) <NEWLINE> <NL> a_count = [ ] <NEWLINE> b_count = [ ] <NEWLINE> b_count2 = [ ] <NEWLINE> <NL> idx = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> idx = bisect . bisect_right ( b_list , a , idx ) <NEWLINE> a_count . append ( idx ) <NEWLINE> <NL> <DEDENT> idx = 0 <NEWLINE> for b in b_list : <NEWLINE> <INDENT> idx = bisect . bisect_right ( c_list , b , idx ) <NEWLINE> b_count . append ( idx ) <NEWLINE> <NL> <DEDENT> ruikei = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ruikei += n - b_count [ i ] <NEWLINE> b_count2 . append ( ruikei ) <NEWLINE> <NL> <DEDENT> b_count2 . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in a_count : <NEWLINE> <INDENT> if a == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += b_count2 [ a ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt1 , cnt2 = 0 , 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if 0 <= a [ i ] < x : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> if x < a [ i ] <= a [ - 1 ] : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cnt1 , cnt2 ) ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 100 : <NEWLINE> <INDENT> N += 1 <NEWLINE> <NL> <DEDENT> print ( N * 100 ** D ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 <NEWLINE> ans += max ( 0 , x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def dist ( x1 , x2 , y1 , y2 ) : <NEWLINE> <INDENT> return ( y1 - y2 ) * ( y1 - y2 ) + ( x1 - x2 ) * ( x1 - x2 ) <NEWLINE> <NL> <NL> <DEDENT> def farthest ( x , y ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> point = ( - 1 , - 1 ) <NEWLINE> for u , v in X : <NEWLINE> <INDENT> d = dist ( x , u , y , v ) <NEWLINE> if d > ret : <NEWLINE> <INDENT> ret = d <NEWLINE> point = u , v <NEWLINE> <DEDENT> <DEDENT> return ret , point <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = [ ] <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> x = ( max ( x for x , y in X ) - min ( x for x , y in X ) ) / 2 <NEWLINE> y = ( max ( y for x , y in X ) - min ( y for x , y in X ) ) / 2 <NEWLINE> x = Decimal ( str ( x ) ) <NEWLINE> y = Decimal ( str ( y ) ) <NEWLINE> step = Decimal ( <STRING> ) <NEWLINE> o = 1 <NEWLINE> eps = Decimal ( <STRING> ) <NEWLINE> while o > eps : <NEWLINE> <INDENT> _ , ( u , v ) = farthest ( x , y ) <NEWLINE> x += ( u - x ) * step <NEWLINE> y += ( v - y ) * step <NEWLINE> step *= Decimal ( <STRING> ) <NEWLINE> o = ( abs ( u - x ) + abs ( x - y ) ) * step <NEWLINE> <NL> <DEDENT> ans , _ = farthest ( x , y ) <NEWLINE> ans **= Decimal ( <STRING> ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 10 ** 9 * N <NEWLINE> front = 0 <NEWLINE> back = sum ( a ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> front += a [ i ] <NEWLINE> back -= a [ i ] <NEWLINE> ans = min ( ans , abs ( front - back ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> sig = 0 <NEWLINE> S5 = S [ i : i + 5 ] <NEWLINE> if S5 == <STRING> : <NEWLINE> <INDENT> sig = 1 <NEWLINE> if S [ i + 5 : i + 7 ] == <STRING> and S [ i + 7 : i + 8 ] != <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> i += 5 <NEWLINE> <DEDENT> elif S5 == <STRING> : <NEWLINE> <INDENT> sig = 1 <NEWLINE> if S [ i + 5 : i + 6 ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> i += 5 <NEWLINE> <DEDENT> if sig == 0 : <NEWLINE> <INDENT> sig = 2 <NEWLINE> Answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if sig != 2 : <NEWLINE> <INDENT> Answer = <STRING> <NEWLINE> <DEDENT> print ( Answer ) <NEWLINE>
x = input ( ) <NEWLINE> n = len ( x ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> if ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( x [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ 0 ] + list ( accumulate ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> lnow = 1 <NEWLINE> rnow = 3 <NEWLINE> for center in range ( 2 , n - 1 ) : <NEWLINE> <NL> <INDENT> laim = l [ center ] // 2 <NEWLINE> while lnow + 1 < center and l [ lnow + 1 ] < laim : lnow += 1 <NEWLINE> if rnow <= center : rnow = center + 1 <NEWLINE> raim = ( l [ - 1 ] - l [ center ] ) // 2 <NEWLINE> while rnow + 1 < n and l [ rnow + 1 ] - l [ center ] < raim : rnow += 1 <NEWLINE> for i , j in ( ( 0 , 0 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) ) : <NEWLINE> <INDENT> if lnow + i < center and rnow + j < n : <NEWLINE> <INDENT> a = ( l [ lnow + i ] , l [ center ] - l [ lnow + i ] , l [ rnow + j ] - l [ center ] , l [ - 1 ] - l [ rnow + j ] ) <NEWLINE> ans = min ( ans , max ( a ) - min ( a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vo1 = v [ 1 : : 2 ] <NEWLINE> ve2 = v [ 0 : : 2 ] <NEWLINE> co1_k , co1_v = zip ( * Counter ( vo1 ) . most_common ( ) ) <NEWLINE> ce2_k , ce2_v = zip ( * Counter ( ve2 ) . most_common ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if vo1 == ve2 : <NEWLINE> <INDENT> if len ( ce2_k ) <= 2 : <NEWLINE> <INDENT> ans = sum ( ce2_v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( ce2_v ) + sum ( co1_v [ 2 : ] ) <NEWLINE> <DEDENT> <DEDENT> elif len ( co1_v ) == len ( ce2_v ) == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif co1_k [ 0 ] == ce2_k [ 0 ] : <NEWLINE> <INDENT> if len ( co1_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( ce2_v [ 1 : ] ) <NEWLINE> <DEDENT> elif len ( ce2_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( co1_v [ 1 : ] ) <NEWLINE> <DEDENT> elif len ( co1_v ) == len ( ce2_v ) == 2 : <NEWLINE> <INDENT> ans1 = co1_v [ 1 ] + ce2_v [ 0 ] <NEWLINE> ans2 = co1_v [ 0 ] + ce2_v [ 1 ] <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> elif len ( co1_v ) == 2 : <NEWLINE> <INDENT> ans1 = co1_v [ 1 ] + ce2_v [ 0 ] + sum ( ce2_v [ 2 : ] ) <NEWLINE> ans2 = co1_v [ 0 ] + sum ( ce2_v [ 1 : ] ) <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> elif len ( ce2_v ) == 2 : <NEWLINE> <INDENT> ans1 = ce2_v [ 1 ] + co1_v [ 0 ] + sum ( co1_v [ 2 : ] ) <NEWLINE> ans2 = ce2_v [ 0 ] + sum ( co1_v [ 1 : ] ) <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = sum ( co1_v [ 1 : ] ) + ce2_v [ 0 ] + sum ( ce2_v [ 2 : ] ) <NEWLINE> ans2 = sum ( ce2_v [ 1 : ] ) + co1_v [ 0 ] + sum ( co1_v [ 2 : ] ) <NEWLINE> ans = min ( ans1 , ans2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( co1_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( ce2_v [ 1 : ] ) <NEWLINE> <DEDENT> elif len ( ce2_v ) == 1 : <NEWLINE> <INDENT> ans = sum ( co1_v [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( co1_v [ 1 : ] ) + sum ( ce2_v [ 1 : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> val = list ( str ( i ) . zfill ( 3 ) ) <NEWLINE> k = val [ count ] <NEWLINE> for j in s : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count <= 2 : <NEWLINE> <INDENT> k = val [ count ] <NEWLINE> <DEDENT> elif count == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> for tmp in links [ x ] : <NEWLINE> <INDENT> if c [ tmp [ 0 ] ] < 0 : <NEWLINE> <INDENT> if tmp [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> c [ tmp [ 0 ] ] = c [ x ] + 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ tmp [ 0 ] ] = 1 - c [ x ] <NEWLINE> <DEDENT> f ( tmp [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> links [ u ] . append ( [ v , w ] ) <NEWLINE> links [ v ] . append ( [ u , w ] ) <NEWLINE> <NL> <DEDENT> c = [ - 1 ] * ( N + 1 ) <NEWLINE> c [ 1 ] = 0 <NEWLINE> f ( 1 ) <NEWLINE> <NL> print ( * c [ 1 : ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for b in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while b % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> b /= 2 <NEWLINE> <DEDENT> a . append ( count ) <NEWLINE> <NL> <DEDENT> print ( a . index ( max ( a ) ) + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . insert ( 0 , 0 ) <NEWLINE> A . append ( 0 ) <NEWLINE> _A = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> _A . append ( abs ( A [ i ] - A [ i - 1 ] ) ) <NEWLINE> <DEDENT> _A . append ( abs ( 0 - A [ N ] ) ) <NEWLINE> S = sum ( _A ) <NEWLINE> <NL> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> allS = S <NEWLINE> allS -= ( _A [ i ] + _A [ i + 1 ] - abs ( A [ i + 2 ] - A [ i ] ) ) <NEWLINE> print ( allS ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> from collections import Counter as co <NEWLINE> D = co ( A ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if D [ A [ - 1 - i ] ] > 0 : <NEWLINE> <INDENT> D [ A [ - 1 - i ] ] -= 1 <NEWLINE> d = A [ - 1 - i ] <NEWLINE> f = len ( bin ( d ) ) - 2 <NEWLINE> e = 2 ** f - d <NEWLINE> if D [ e ] > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> D [ e ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = math . factorial ( N ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def I ( ) : return int ( input ( ) ) <NEWLINE> N = I ( ) <NEWLINE> ans = 0 <NEWLINE> if N >= 105 : <NEWLINE> <INDENT> for i in range ( 105 , N + 1 , 2 ) : <NEWLINE> <INDENT> count_yakusuu = 0 <NEWLINE> for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count_yakusuu += 2 <NEWLINE> <DEDENT> <DEDENT> if count_yakusuu == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 10 <NEWLINE> DP = [ INF ] * N <NEWLINE> DP [ 0 ] = 0 <NEWLINE> DP [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> DP [ i ] = min ( DP [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( K , i ) + 1 ) ) <NEWLINE> <DEDENT> print ( DP [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = [ p for p in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> min_p = P [ 0 ] <NEWLINE> <NL> for p in P : <NEWLINE> <INDENT> if min_p >= p : <NEWLINE> <INDENT> min_p = p <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import io <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> def solve ( ac_lst , l , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if l == 1 : <NEWLINE> <INDENT> return ac_lst [ r - 2 ] <NEWLINE> <DEDENT> return ac_lst [ r - 2 ] - ac_lst [ l - 2 ] <NEWLINE> <NL> <NL> <DEDENT> def make_ac_lst ( s ) : <NEWLINE> <INDENT> ac_lst = [ 0 ] * len ( s ) <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> ac_lst [ i ] += ac_lst [ i - 1 ] <NEWLINE> <DEDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ac_lst [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ac_lst [ - 1 ] = ac_lst [ - 2 ] <NEWLINE> <NL> if _DEB : logd ( <STRING> ) <NEWLINE> return ac_lst <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> ac_lst = make_ac_lst ( s ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += str ( solve ( ac_lst , l , r ) ) + <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> _DEB = 0 <COMMENT> <NEWLINE> <NL> _INPUT = <STRING> <NEWLINE> _EXPECTED = <STRING> <NEWLINE> <NL> def logd ( str ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _DEB : print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if _DEB : <NEWLINE> <INDENT> sys . stdin = io . StringIO ( _INPUT ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> ans = main ( ) <NEWLINE> <NL> if _DEB : <NEWLINE> <INDENT> print ( ) <NEWLINE> if _EXPECTED . strip ( ) == ans . strip ( ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = sorted ( x for x in input ( ) ) <NEWLINE> t = sorted ( [ x for x in input ( ) ] , reverse = True ) <NEWLINE> print ( <STRING> if s < t else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> ans = <STRING> <NEWLINE> list_1 = [ ] <NEWLINE> list_n = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ab [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> list_1 . append ( ab [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif ab [ i ] [ 1 ] == n : <NEWLINE> <INDENT> list_n . append ( ab [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( list_1 ) & set ( list_n ) ) > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> def calculate ( n , k , s ) : <NEWLINE> <INDENT> s = list ( s ) <NEWLINE> <NL> result = [ { <STRING> : 0 , <STRING> : 0 } ] <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> previous = s [ i - 1 ] <NEWLINE> current = s [ i ] <NEWLINE> <NL> if i == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> result . append ( { <STRING> : 0 } ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( current == <STRING> ) and ( previous == <STRING> ) : <NEWLINE> <INDENT> res = result [ - 1 ] <NEWLINE> res . __setitem__ ( <STRING> , i ) <NEWLINE> result [ - 1 ] = res <NEWLINE> <NL> <DEDENT> if ( current == <STRING> ) and ( previous == <STRING> ) : <NEWLINE> <INDENT> result . append ( { <STRING> : i } ) <NEWLINE> <NL> <DEDENT> <DEDENT> if i == n - 1 and s [ i ] == <STRING> : <NEWLINE> <INDENT> res = result [ - 1 ] <NEWLINE> res . __setitem__ ( <STRING> , i + 1 ) <NEWLINE> result [ - 1 ] = res <NEWLINE> <NL> <DEDENT> <DEDENT> result . append ( { <STRING> : n , <STRING> : n } ) <NEWLINE> <NL> <NL> <COMMENT> <NL> maxValue = 0 <NEWLINE> if len ( result ) > k : <NEWLINE> <INDENT> for i in range ( len ( result ) - k ) : <NEWLINE> <INDENT> val = result [ i + k ] [ <STRING> ] - result [ i ] [ <STRING> ] <NEWLINE> maxValue = max ( val , maxValue ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> maxValue = max ( maxValue , result [ - 1 ] [ <STRING> ] - result [ 0 ] [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( maxValue ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , K , S ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k * 2 >= ( b - a + 1 ) : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : print ( i ) <NEWLINE> for i in range ( b - k + 1 , b + 1 ) : print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> if 2 in a : <NEWLINE> <INDENT> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> t = a [ k - 1 ] <NEWLINE> a [ k - 1 ] = - 1 <NEWLINE> k = t <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if k == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a . count ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ans = [ s [ 0 ] ] <NEWLINE> cnt = 1 <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] , end = <STRING> ) <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> ans . append ( s [ i + 1 ] ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if s [ - 1 ] == s [ - 2 ] : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> ans2 = [ 0 ] * len ( s ) <NEWLINE> sm = 0 <NEWLINE> for i in range ( len ( ans ) // 2 ) : <NEWLINE> <INDENT> sm += ans [ 2 * i + 1 ] <NEWLINE> if ans [ i * 2 ] == <STRING> : <NEWLINE> <INDENT> if ans [ 2 * i + 1 ] % 2 == 1 : <NEWLINE> <INDENT> ans2 [ sm - ans [ i * 2 + 1 ] ] += ( ans [ 2 * i + 1 ] + 1 ) // 2 <NEWLINE> ans2 [ sm - ans [ i * 2 + 1 ] - 1 ] += ( ans [ 2 * i + 1 ] - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 [ sm - ans [ i * 2 + 1 ] ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> ans2 [ sm - ans [ i * 2 + 1 ] - 1 ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans [ 2 * i + 1 ] % 2 == 1 : <NEWLINE> <INDENT> ans2 [ sm - 1 ] += ( ans [ 2 * i + 1 ] + 1 ) // 2 <NEWLINE> ans2 [ sm ] += ( ans [ 2 * i + 1 ] - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 [ sm ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> ans2 [ sm - 1 ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans2 : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ x [ i ] for i in range ( n ) if x [ i ] < 0 ] <NEWLINE> b = [ x [ i ] for i in range ( n ) if x [ i ] >= 0 ] <NEWLINE> na = len ( a ) <NEWLINE> nb = len ( b ) <NEWLINE> if 0 in x : <NEWLINE> <INDENT> k -= 1 <NEWLINE> b = [ x [ i ] for i in range ( n ) if x [ i ] > 0 ] <NEWLINE> nb = nb - 1 <NEWLINE> <NL> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 10 ** 10 <NEWLINE> if na >= k : <NEWLINE> <INDENT> ans = - a [ - k ] <NEWLINE> <NL> <DEDENT> if nb >= k : <NEWLINE> <INDENT> ans = min ( ans , b [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> if nb == 0 : <NEWLINE> <INDENT> print ( - a [ - k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if na == 0 : <NEWLINE> <INDENT> print ( b [ k - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , nb + 1 ) : <NEWLINE> <INDENT> m = k - i <NEWLINE> if m > na or m < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif 0 < m <= na : <NEWLINE> <INDENT> ans = min ( ans , min ( b [ i - 1 ] - 2 * a [ - m ] , 2 * b [ i - 1 ] - a [ - m ] ) ) <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> ans = min ( ans , b [ k - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if k != 0 else 0 ) <NEWLINE>
x = input ( ) <NEWLINE> if len ( x ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> k = int ( x [ 0 : - 2 ] ) <NEWLINE> x = int ( x [ - 2 : ] ) <NEWLINE> <NL> k -= x / 5 <NEWLINE> if x % 5 == 0 and k >= 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif k > 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> c = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> ans += c - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pp = list ( map ( lambda x : ( x + 1 ) / 2 , p ) ) <NEWLINE> <NL> p_rui = [ pp [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p_rui . append ( p_rui [ i - 1 ] + pp [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> walist = [ p_rui [ k - 1 ] ] <NEWLINE> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> walist += [ p_rui [ k + i ] - p_rui [ i ] ] <NEWLINE> <NL> <DEDENT> print ( max ( walist ) ) <NEWLINE> <NL> <NL>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> num = math . gcd ( n , m ) <NEWLINE> ans = ( n * m ) // num <NEWLINE> numn = n // num <NEWLINE> numm = m // num <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if s [ i * numn ] != t [ i * numm ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in reversed ( range ( 1 , min ( a , b ) + 1 ) ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> k = k - 1 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * ( 4 * 10 ** 4 ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> li = [ ans [ i - j [ 0 ] ] + j [ 1 ] for j in ab ] <NEWLINE> ans [ i ] = min ( li ) <NEWLINE> <DEDENT> print ( ans [ h ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> P = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 15 <NEWLINE> <NL> <NL> def F ( i , n , GetPoint ) : <NEWLINE> <INDENT> if i == D : <NEWLINE> <INDENT> if GetPoint >= G : <NEWLINE> <INDENT> return n , GetPoint <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return INF , INF <NEWLINE> <NL> <DEDENT> <DEDENT> PerPoint = ( i + 1 ) * 100 <NEWLINE> <NL> if GetPoint < G : <NEWLINE> <INDENT> ANS = INF , INF <NEWLINE> <COMMENT> <NL> N , GP = F ( i + 1 , n + P [ i ] , GetPoint + PerPoint * P [ i ] + C [ i ] ) <NEWLINE> if N < ANS [ 0 ] : <NEWLINE> <INDENT> ANS = N , GP <NEWLINE> <COMMENT> <NL> <DEDENT> N , GP = F ( i + 1 , n , GetPoint ) <NEWLINE> if N < ANS [ 0 ] : <NEWLINE> <INDENT> ANS = N , GP <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> PupperAll = sum ( [ ( j + 1 ) * 100 * P [ j ] + C [ j ] for j in range ( i + 1 , D ) ] ) <NEWLINE> rN = math . ceil ( ( G - GetPoint - PupperAll ) / PerPoint ) <NEWLINE> if 0 < rN < P [ i ] : <NEWLINE> <INDENT> GP = GetPoint + PerPoint * rN + PupperAll <NEWLINE> N = n + rN + sum ( P [ i + 1 : ] ) <NEWLINE> if N < ANS [ 0 ] : <NEWLINE> <INDENT> ANS = N , GP <NEWLINE> <NL> <DEDENT> <DEDENT> return ANS <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n , GetPoint <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( F ( 0 , 0 , 0 ) [ 0 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lst = [ ] <NEWLINE> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> lst . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst [ - K ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a + 1 <= k * 2 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( ( b - k + 1 ) , ( b + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> _ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( _ ) <NEWLINE> <DEDENT> a = sorted ( a , key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> check = False <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> while b < n : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> h = abs ( i - a [ b ] [ 0 ] ) + abs ( j - a [ b ] [ 1 ] ) + a [ b ] [ 2 ] <NEWLINE> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> de = max ( h - abs ( i - a [ b ] [ 0 ] ) - abs ( j - a [ b ] [ 1 ] ) , 0 ) <NEWLINE> if de == a [ b ] [ 2 ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b == n : <NEWLINE> <INDENT> ans = str ( i ) + <STRING> + str ( j ) + <STRING> + str ( h ) <NEWLINE> check = True <NEWLINE> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> a = collections . Counter ( s ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in a . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
