a , b = input ( ) . split ( <STRING> ) <NEWLINE> if int ( a ) >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif int ( a ) in range ( 6 , 13 ) : <NEWLINE> <INDENT> print ( int ( b ) // 2 ) <NEWLINE> <DEDENT> elif int ( a ) <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( B == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( B > N + 1 ) : <NEWLINE> <INDENT> x = N <NEWLINE> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N - N % ( B - 1 ) <NEWLINE> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> <NL> for i in range ( 1 , M + 1 , 1 ) : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> List = list ( itertools . combinations_with_replacement ( L , N ) ) <NEWLINE> ans = 0 <NEWLINE> for l in List : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> if ( l [ B [ q ] - 1 ] - l [ A [ q ] - 1 ] ) == C [ q ] : <NEWLINE> <INDENT> temp = temp + D [ q ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def goes_to_zero ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while ( n > 0 ) : <NEWLINE> <INDENT> n %= bin ( n ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> XC = X . count ( <STRING> ) <NEWLINE> XI = int ( X , 2 ) <NEWLINE> XCP = XC + 1 <NEWLINE> XCM = XC - 1 <NEWLINE> XTP = XI % XCP <NEWLINE> XTM = XI % XCM if XCM != 0 else 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( goes_to_zero ( ( XTP + pow ( 2 , N - 1 - i , XCP ) ) % XCP ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if XCM == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( goes_to_zero ( ( XTM - pow ( 2 , N - 1 - i , XCM ) ) % XCM ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total , large = 0 , 0 <NEWLINE> <NL> for i in A : <NEWLINE> <NL> <INDENT> if large > i : <NEWLINE> <INDENT> total += ( large - i ) <NEWLINE> <NL> <DEDENT> if i > large : large = i <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> N = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> N [ i ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , x in enumerate ( N ) : <NEWLINE> <INDENT> if x != 0 : <NEWLINE> <INDENT> ans += i * x <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> for b , c in bc : <NEWLINE> <INDENT> ans += ( c - b ) * N [ b ] <NEWLINE> N [ c ] += N [ b ] <NEWLINE> N [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> ans = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . appendleft ( c [ 7 : ] ) <NEWLINE> <DEDENT> elif c [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans . remove ( c [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif c [ 6 ] == <STRING> : <NEWLINE> <INDENT> ans . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lsl = [ ] <NEWLINE> lsr = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lsl . append ( l ) <NEWLINE> lsr . append ( r ) <NEWLINE> <DEDENT> lmax = max ( lsl ) <NEWLINE> rmin = min ( lsr ) <NEWLINE> <NL> if lmax > rmin : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = set ( range ( 1 , n + 1 ) ) <NEWLINE> ans2 = set ( range ( lmax , rmin + 1 ) ) <NEWLINE> ans = ans1 & ans2 <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> d = [ 0 ] * N <NEWLINE> total = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> B = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for j in B : <NEWLINE> <INDENT> d [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if d [ j ] == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
num = int ( input ( <STRING> ) ) <NEWLINE> val = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val_sum = sum ( val ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> val_sum = val_sum - val [ i ] <NEWLINE> ans = val [ i ] * val_sum + ans <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> pos = 0 <NEWLINE> count = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pos += l [ i ] <NEWLINE> if pos > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <NL> <DEDENT> return print ( x ) <NEWLINE> <NL> <DEDENT> x_y = input ( ) <NEWLINE> tmp = list ( map ( int , x_y . split ( ) ) ) <NEWLINE> x = tmp [ 0 ] <NEWLINE> y = tmp [ 1 ] <NEWLINE> gcd ( x , y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mul = 1 <NEWLINE> if a . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if a . count ( 0 ) == 0 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> mul = mul * a [ i ] <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> if mul <= 10 ** 18 : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> a = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> s = Counter ( l ) <NEWLINE> initial_sum = sum ( l ) <NEWLINE> <NL> for _ in range ( b ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> k = s [ x ] <NEWLINE> s [ x ] = 0 <NEWLINE> s [ y ] += k <NEWLINE> initial_sum += ( y - x ) * k <NEWLINE> print ( initial_sum ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <DEDENT> y = 0 <NEWLINE> z = len ( a ) <NEWLINE> for y in range ( 0 , z ) : <NEWLINE> <INDENT> w = y + 1 <NEWLINE> print ( <STRING> , str ( w ) + <STRING> , a [ y ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> if x <= 1000000000000000000 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> x = Counter ( a ) <NEWLINE> print ( sum ( list ( map ( lambda n : n % 2 , list ( x . values ( ) ) ) ) ) ) <NEWLINE>
import sys , fractions <NEWLINE> [ [ print ( <STRING> . format ( int ( fractions . gcd ( t [ 0 ] , t [ 1 ] ) ) , int ( t [ 0 ] * t [ 1 ] / fractions . gcd ( t [ 0 ] , t [ 1 ] ) ) ) ) for t in [ [ int ( y ) for y in x . split ( ) ] ] ] for x in sys . stdin ] <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ai in edge : <NEWLINE> <INDENT> edge [ ai ] . append ( bi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ ai ] = [ bi , ] <NEWLINE> <DEDENT> if bi in edge : <NEWLINE> <INDENT> edge [ bi ] . append ( ai ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ bi ] = [ ai , ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> is_visited = np . zeros ( ( n + 1 , ) , dtype = np . bool ) <NEWLINE> parent = np . zeros ( ( n + 1 , ) , dtype = np . int ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> is_visited [ 1 ] = True <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> for child in edge [ node ] : <NEWLINE> <INDENT> if not is_visited [ child ] : <NEWLINE> <INDENT> is_visited [ child ] = True <NEWLINE> parent [ child ] = node <NEWLINE> q . append ( child ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , list ( parent [ 2 : ] ) ) ) ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> C = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> memo = { } <NEWLINE> def dfs ( i , j ) : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if j == M : <NEWLINE> <INDENT> return 10 ** 9 <NEWLINE> <DEDENT> if ( i , j ) in memo : <NEWLINE> <INDENT> return memo [ i , j ] <NEWLINE> <DEDENT> memo [ i , j ] = res = min ( dfs ( i + 1 , j + 1 ) + D [ i ] * C [ j ] , dfs ( i , j + 1 ) ) <NEWLINE> return res <NEWLINE> <DEDENT> print ( dfs ( 0 , 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> M = max ( A ) + 1 <NEWLINE> table = [ 0 for _ in range ( M ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 and A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> table [ A [ i ] ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> table [ A [ i ] ] = 1 <NEWLINE> for n in range ( 2 , M ) : <NEWLINE> <INDENT> if A [ i ] * n >= M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> table [ A [ i ] * n ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( table ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * N <NEWLINE> for s in A : <NEWLINE> <INDENT> x [ s - 1 ] += 1 <NEWLINE> <DEDENT> for s in x : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> r , g , b = [ 0 for _ in range ( N + 1 ) ] , [ 0 for _ in range ( N + 1 ) ] , [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r [ i + 1 ] , g [ i + 1 ] , b [ i + 1 ] = r [ i ] , g [ i ] , b [ i ] <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r [ i + 1 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g [ i + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += g [ i ] * ( b [ N ] - b [ i + 1 ] ) + b [ i ] * ( g [ N ] - g [ i + 1 ] ) <NEWLINE> for j in range ( 1 , min ( i , N - i - 1 ) + 1 ) : <NEWLINE> <INDENT> if { S [ i - j ] , S [ i + j ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += r [ i ] * ( b [ N ] - b [ i + 1 ] ) + b [ i ] * ( r [ N ] - r [ i + 1 ] ) <NEWLINE> for j in range ( 1 , min ( i , N - i - 1 ) + 1 ) : <NEWLINE> <INDENT> if { S [ i - j ] , S [ i + j ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += g [ i ] * ( r [ N ] - r [ i + 1 ] ) + r [ i ] * ( g [ N ] - g [ i + 1 ] ) <NEWLINE> for j in range ( 1 , min ( i , N - i - 1 ) + 1 ) : <NEWLINE> <INDENT> if { S [ i - j ] , S [ i + j ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if l [ i ] > l [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
from collections import deque <NEWLINE> <NL> <NL> def solve ( a ) : <NEWLINE> <INDENT> ans = deque ( ) <NEWLINE> <NL> for i , aa in enumerate ( a ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans . append ( str ( aa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( str ( aa ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( a ) % 2 == 1 : <NEWLINE> <INDENT> ans . reverse ( ) <NEWLINE> <NL> <DEDENT> return list ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( solve ( a ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lis [ a - 1 ] . append ( b - 1 ) <NEWLINE> lis [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> from collections import deque <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> a = q . popleft ( ) <NEWLINE> for i in lis [ a ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = a <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
n , a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> fact = [ 1 , 1 ] <NEWLINE> finv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 5 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> inv . append ( ( inv [ mod % i ] * ( mod - mod // i ) ) % mod ) <NEWLINE> finv . append ( ( finv [ - 1 ] * inv [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> def nCr ( n , r , mod ) : <NEWLINE> <INDENT> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fact [ n ] * finv [ r ] * finv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def nPr ( n , r , mod ) : <NEWLINE> <INDENT> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fact [ n ] * finv [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i * a > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = k - i * a <NEWLINE> if d % b or d // b > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += nCr ( n , i , mod ) * nCr ( n , d // b , mod ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def Fibonacci ( n , a1 , a2 ) : <NEWLINE> <INDENT> if n < 1 : return a1 <NEWLINE> return Fibonacci ( n - 1 , a1 + a2 , a1 ) <NEWLINE> <NL> <DEDENT> print ( Fibonacci ( int ( input ( ) ) , 1 , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> <NL> if 0 not in a : <NEWLINE> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> res = res * a [ i ] <NEWLINE> <NL> if res > 1000000000000000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> boss = input ( ) . split ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> l [ int ( boss [ i ] ) - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( l [ j ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> rcs = [ 0 ] * N <NEWLINE> gcs = [ 0 ] * N <NEWLINE> bcs = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> rcs [ i ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> gcs [ i ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> bcs [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> rcs [ i ] += rcs [ i - 1 ] <NEWLINE> gcs [ i ] += gcs [ i - 1 ] <NEWLINE> bcs [ i ] += bcs [ i - 1 ] <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> result += bcs [ N - 1 ] - bcs [ j ] <NEWLINE> t = 2 * j - i <NEWLINE> if t < N and S [ t ] == <STRING> : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> result += gcs [ N - 1 ] - gcs [ j ] <NEWLINE> t = 2 * j - i <NEWLINE> if t < N and S [ t ] == <STRING> : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> result += bcs [ N - 1 ] - bcs [ j ] <NEWLINE> t = 2 * j - i <NEWLINE> if t < N and S [ t ] == <STRING> : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> result += rcs [ N - 1 ] - rcs [ j ] <NEWLINE> t = 2 * j - i <NEWLINE> if t < N and S [ t ] == <STRING> : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> result += gcs [ N - 1 ] - gcs [ j ] <NEWLINE> t = 2 * j - i <NEWLINE> if t < N and S [ t ] == <STRING> : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ j ] == <STRING> : <NEWLINE> <INDENT> result += rcs [ N - 1 ] - rcs [ j ] <NEWLINE> t = 2 * j - i <NEWLINE> if t < N and S [ t ] == <STRING> : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 0 <NEWLINE> res = [ A [ 0 ] ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res . append ( res [ i ] + A [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans + ( A [ i ] * res [ i - 1 ] ) % mod <NEWLINE> <DEDENT> ans = ans % mod <NEWLINE> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B == N : <NEWLINE> <INDENT> C = B - 1 <NEWLINE> <DEDENT> elif B < N : <NEWLINE> <INDENT> C = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = N <NEWLINE> <DEDENT> x = int ( A * C / B ) <NEWLINE> y = int ( C / B ) <NEWLINE> z = x - A * y <NEWLINE> print ( z ) <NEWLINE>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> z = zip ( a , b ) <NEWLINE> lis = [ 0 ] * n <NEWLINE> <NL> for i , j in z : <NEWLINE> <NL> <INDENT> if h [ i - 1 ] > h [ j - 1 ] : <NEWLINE> <INDENT> lis [ j - 1 ] = 1 <NEWLINE> <DEDENT> elif h [ i - 1 ] < h [ j - 1 ] : <NEWLINE> <INDENT> lis [ i - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ i - 1 ] = 1 <NEWLINE> lis [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( collections . Counter ( lis ) [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> chin = [ ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <NL> <INDENT> x = int ( input ( ) ) <NEWLINE> sum += x <NEWLINE> <NL> if x % 10 != 0 : <NEWLINE> <INDENT> chin . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> chin . sort ( ) <NEWLINE> i = 0 <NEWLINE> <NL> while chin != [ ] and i < len ( chin ) and sum % 10 == 0 : <NEWLINE> <INDENT> sum -= chin [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if sum % 10 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . longlong ) <NEWLINE> mod = 7 + 10 ** 9 <NEWLINE> cs = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cs += a <NEWLINE> cs %= mod <NEWLINE> <DEDENT> cumsum = np . mod ( np . cumsum ( A ) , mod ) <NEWLINE> rev = - 1 * ( cumsum - cs ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += rev [ i ] * A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( H == 0 ) and ( W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( 0 , H ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for m in range ( 0 , W ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> num = 0 <NEWLINE> nm = [ 1 , 0 , - 1 ] <NEWLINE> c = n [ 3 ] <NEWLINE> cu = 0 <NEWLINE> <NL> <NL> for i in n : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i > c : <NEWLINE> <INDENT> sum += nm [ num ] * c <NEWLINE> break <NEWLINE> <DEDENT> if i <= c : <NEWLINE> <INDENT> sum += nm [ num ] * i <NEWLINE> c -= i <NEWLINE> num += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * pi * r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> Lis = [ [ ] for _ in range ( 3 ) ] <NEWLINE> RGB = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> idx = RGB . index ( S [ i ] ) <NEWLINE> Lis [ idx ] . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> if len ( Lis [ 0 ] ) == 0 or len ( Lis [ 1 ] ) == 0 or len ( Lis [ 2 ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> Ng = len ( Lis [ 2 ] ) <NEWLINE> ans = 0 <NEWLINE> for r in Lis [ 0 ] : <NEWLINE> <INDENT> for g in Lis [ 1 ] : <NEWLINE> <INDENT> n1 = 2 * r - g <NEWLINE> n2 = 2 * g - r <NEWLINE> n3 = ( r + g ) // 2 <NEWLINE> Su = Ng <NEWLINE> if N >= n1 > 0 : <NEWLINE> <INDENT> if S [ n1 - 1 ] == <STRING> : <NEWLINE> <INDENT> Su -= 1 <NEWLINE> <DEDENT> <DEDENT> if N >= n2 > 0 : <NEWLINE> <INDENT> if S [ n2 - 1 ] == <STRING> : <NEWLINE> <INDENT> Su -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( g - r ) % 2 == 0 : <NEWLINE> <INDENT> if S [ n3 - 1 ] == <STRING> : <NEWLINE> <INDENT> Su -= 1 <NEWLINE> <DEDENT> <DEDENT> ans += Su <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> k = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k += m [ i ] <NEWLINE> if m [ i ] in d : <NEWLINE> <INDENT> d [ m [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ m [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> for x in range ( int ( input ( ) ) ) : <NEWLINE> <NL> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> if b in d : <NEWLINE> <INDENT> k += d [ b ] * ( c - b ) <NEWLINE> if c in d : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> <DEDENT> del d [ b ] <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> def doit ( n , a ) : <NEWLINE> <INDENT> m = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = m * int ( a [ i ] ) <NEWLINE> if m > 1000000000000000000 : <NEWLINE> <INDENT> for y in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ y ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <DEDENT> print ( doit ( n , a ) ) <NEWLINE>
<NL> flag = True <NEWLINE> count = 0 <NEWLINE> l = [ ] <NEWLINE> <NL> for s in input ( ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> l . append ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> count = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( l ) ) <NEWLINE>
maxv = - 2 * 10 ** 9 <NEWLINE> minv = 2 * 10 ** 9 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> maxv = max ( x - minv , maxv ) <NEWLINE> minv = min ( x , minv ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( count , n ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( num , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if 10000 * i + 5000 * j + 1000 * ( N - i - j ) == Y : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) + <STRING> + str ( N - i - j ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> distance = abs ( B - A ) <NEWLINE> if V == W : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = distance / ( V - W ) <NEWLINE> if 0 < t <= T : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ [ 0 ] for i in range ( n + 1 ) ] <NEWLINE> num = { 0 : 0 , 1 : 1 } <NEWLINE> e = deque ( [ ] ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> r [ a ] . append ( b ) <NEWLINE> r [ b ] . append ( a ) <NEWLINE> <DEDENT> e . append ( 1 ) <NEWLINE> while len ( e ) > 0 : <NEWLINE> <INDENT> x = e . popleft ( ) <NEWLINE> for y in r [ x ] : <NEWLINE> <INDENT> if y not in num : <NEWLINE> <INDENT> num [ y ] = x <NEWLINE> e . append ( y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( num [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> K = int ( read ( ) ) <NEWLINE> <NL> x = np . arange ( 1 , K + 1 ) <NEWLINE> nums = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE> print ( nums . sum ( ) ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def intersection ( a1 , a2 , b1 , b2 ) : <NEWLINE> <INDENT> x1 , y1 = a1 <NEWLINE> x2 , y2 = a2 <NEWLINE> x3 , y3 = b1 <NEWLINE> x4 , y4 = b2 <NEWLINE> <NL> ksi = ( y4 - y3 ) * ( x4 - x1 ) - ( x4 - x3 ) * ( y4 - y1 ) <NEWLINE> eta = ( x2 - x1 ) * ( y4 - y1 ) - ( y2 - y1 ) * ( x4 - x1 ) <NEWLINE> delta = ( x2 - x1 ) * ( y4 - y3 ) - ( y2 - y1 ) * ( x4 - x3 ) <NEWLINE> if delta == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> ramda = ksi / delta ; <NEWLINE> mu = eta / delta ; <NEWLINE> if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1 : <NEWLINE> <INDENT> return ( x1 + ramda * ( x2 - x1 ) , y1 + ramda * ( y2 - y1 ) ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> n = I ( ) <NEWLINE> ni = 0 <NEWLINE> <NL> while ni < n : <NEWLINE> <INDENT> ni += 1 <NEWLINE> xa , ya , xb , yb = LI ( ) <NEWLINE> a1 = ( xa , ya ) <NEWLINE> a2 = ( xb , yb ) <NEWLINE> m = I ( ) <NEWLINE> a = [ LI ( ) for _ in range ( m ) ] <NEWLINE> t = [ ] <NEWLINE> for xs , ys , xt , yt , o , l in a : <NEWLINE> <INDENT> k = intersection ( a1 , a2 , ( xs , ys ) , ( xt , yt ) ) <NEWLINE> if k is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t . append ( ( k , o ^ l ) ) <NEWLINE> <DEDENT> if len ( t ) == 0 : <NEWLINE> <INDENT> rr . append ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> t . sort ( ) <NEWLINE> c = t [ 0 ] [ 1 ] <NEWLINE> r = 0 <NEWLINE> for _ , tc in t : <NEWLINE> <INDENT> if tc != c : <NEWLINE> <INDENT> r += 1 <NEWLINE> c = tc <NEWLINE> <NL> <DEDENT> <DEDENT> rr . append ( r ) <NEWLINE> <NL> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> <NL> def getInts ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> def f ( A , B ) : <NEWLINE> <INDENT> return A ** 5 - B ** 5 <NEWLINE> <NL> <DEDENT> [ X ] = getInts ( ) <NEWLINE> Q = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> V = set ( ) <NEWLINE> A , B = 0 , 0 <NEWLINE> r = [ ] <NEWLINE> while not r : <NEWLINE> <INDENT> ( A , B ) = Q . pop ( ) <NEWLINE> l = [ ( A + 1 , B ) , ( A , B + 1 ) , ( A + 1 , B + 1 ) ] <NEWLINE> l = filter ( lambda x : x not in V , l ) <NEWLINE> for each in l : <NEWLINE> <INDENT> V . add ( each ) <NEWLINE> Q . appendleft ( each ) <NEWLINE> <NL> <DEDENT> r = list ( filter ( lambda x : f ( * x ) == X , [ ( A , B ) , ( A , - B ) , ( - A , B ) , ( - A , - B ) ] ) ) <NEWLINE> <NL> <DEDENT> print ( r [ 0 ] [ 0 ] , r [ 0 ] [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( N // i ) * ( i + ( i * ( N // i ) ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> que = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> que . appendleft ( command [ 7 : ] ) <NEWLINE> <DEDENT> elif command [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> que . remove ( command [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 6 ] == <STRING> : <NEWLINE> <INDENT> que . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * que ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> print ( len ( set ( s ) ) ) <NEWLINE>
print ( <STRING> . join ( map ( str , sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> S_list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S_list . append ( s ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( S_list ) <NEWLINE> c_max = c . most_common ( ) <NEWLINE> max_num = c . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> ans_list = [ ] <NEWLINE> ans_list . append ( c . most_common ( ) [ 0 ] [ 0 ] ) <NEWLINE> <NL> for i in range ( 1 , len ( c_max ) ) : <NEWLINE> <INDENT> if c_max [ i ] [ 1 ] != max_num : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( c_max [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * sorted ( ans_list ) , sep = <STRING> ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( a + b + 1 ) : <NEWLINE> <INDENT> if i == a : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if int ( s [ i ] ) < 0 or 9 < int ( s [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import decimal <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> decimal . getcontext ( ) . prec = len ( str ( a ) ) <NEWLINE> print ( int ( decimal . Decimal ( a ) / decimal . Decimal ( b ) ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> cNum = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> if cNum [ 0 ] != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for n in cNum . keys ( ) : <NEWLINE> <INDENT> ans *= n ** cNum [ n ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acou = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( acou [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> XL = [ NLI ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> arm_range = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> arm_range . append ( [ XL [ n ] [ 0 ] - XL [ n ] [ 1 ] , XL [ n ] [ 0 ] + XL [ n ] [ 1 ] ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> sorted_arm_range = sorted ( arm_range , key = lambda x : x [ 1 ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> arm_end = sorted_arm_range [ 0 ] [ 1 ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if sorted_arm_range [ n + 1 ] [ 0 ] >= arm_end : <NEWLINE> <INDENT> arm_end = sorted_arm_range [ n + 1 ] [ 1 ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> if ai in d : <NEWLINE> <INDENT> d [ ai ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ai ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = sum ( [ value * ( value - 1 ) // 2 for value in d . values ( ) ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> val = d [ a [ i ] ] <NEWLINE> res = cnt - val * ( val - 1 ) // 2 <NEWLINE> <NL> if val >= 3 : <NEWLINE> <INDENT> res += ( val - 1 ) * ( val - 2 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , a <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> maxa = 10 ** 6 <NEWLINE> isprime = [ True ] * ( maxa + 1 ) <NEWLINE> sa = sorted ( a ) <NEWLINE> <NL> prevx = 0 <NEWLINE> for x in sa : <NEWLINE> <INDENT> if isprime [ x ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if prevx == x : <NEWLINE> <INDENT> isprime [ x ] = False <NEWLINE> continue <NEWLINE> <NL> <DEDENT> i = x * 2 <NEWLINE> while ( i <= maxa ) : <NEWLINE> <INDENT> isprime [ i ] = False <NEWLINE> i += x <NEWLINE> <DEDENT> prevx = x <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for x in sa : <NEWLINE> <INDENT> if isprime [ x ] == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , a = readinput ( ) <NEWLINE> ans = main ( n , a ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> M = max ( A ) <NEWLINE> <NL> count = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> check = [ True ] * ( M + 1 ) <NEWLINE> for a in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if count [ a ] > 0 and check [ a ] == True : <NEWLINE> <INDENT> for k in range ( 2 , M // a + 1 ) : <NEWLINE> <INDENT> check [ a * k ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if count [ A [ i ] ] == 1 and check [ A [ i ] ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if k < a : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> elif k < a + b : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif k <= a + b + c : <NEWLINE> <INDENT> ans = ans + a - ( k - a - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> import copy <NEWLINE> INF = 10000 <NEWLINE> <NL> <COMMENT> <NL> N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> medichine = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> dp = { } <NEWLINE> <COMMENT> <NL> dp = collections . defaultdict ( lambda : INF ) <NEWLINE> dp [ 0 , 0 ] = 0 <NEWLINE> <NL> for a , b , c in medichine : <NEWLINE> <INDENT> dp_ = copy . copy ( dp ) <NEWLINE> for ca , cb in dp . keys ( ) : <NEWLINE> <INDENT> dp_ [ ca + a , cb + b ] = min ( dp_ [ ca + a , cb + b ] , dp [ ca , cb ] + c ) <NEWLINE> <DEDENT> dp = dp_ <NEWLINE> <NL> <DEDENT> ans = INF <NEWLINE> for ca , cb in dp . keys ( ) : <NEWLINE> <INDENT> if ca == cb == 0 : continue <NEWLINE> if ca * Mb == cb * Ma : <NEWLINE> <INDENT> ans = min ( ans , dp [ ca , cb ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if ans == INF else ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> S = <STRING> ; <NEWLINE> <NL> arr = list ( map ( int , S . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> mx = max ( A ) <NEWLINE> x = [ 0 ] * ( mx + 1 ) <COMMENT> <NEWLINE> for i in A : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , mx + 1 ) : <NEWLINE> <INDENT> if x [ i ] != 0 : <NEWLINE> <INDENT> for j in range ( 2 * i , mx + 1 , i ) : <NEWLINE> <INDENT> x [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> if x [ i ] > 1 : <NEWLINE> <INDENT> x [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( x ) ) <NEWLINE>
M = 10 ** 9 + 7 <NEWLINE> n , k , * a = map ( int , open ( y : = 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> x = s = 1 <NEWLINE> r = k <NEWLINE> while r > 1 : <NEWLINE> <INDENT> if ( t : = a [ y ] * a [ y + 1 ] ) > a [ - x ] * a [ ~ x ] : s = s * t % M ; y += 2 ; r -= 2 <NEWLINE> else : s = s * a [ - x ] % M ; x += 1 ; r -= 1 <NEWLINE> <DEDENT> if r : s *= a [ - x ] <NEWLINE> if a [ - 1 ] < 0 < k % 2 : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in a [ - k : ] : s = s * i % M <NEWLINE> <DEDENT> print ( s % M ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> goodTowerFlag = [ True ] * N <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> goodTowerFlag [ a - 1 ] = False <NEWLINE> <DEDENT> if H [ b - 1 ] <= H [ a - 1 ] : <NEWLINE> <INDENT> goodTowerFlag [ b - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( goodTowerFlag . count ( True ) ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = A . copy ( ) <NEWLINE> B_sum = B . copy ( ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A_sum [ i ] = A_sum [ i - 1 ] + A [ i ] <NEWLINE> <NL> <DEDENT> A_sum = [ 0 ] + A_sum <NEWLINE> <NL> for i in range ( 1 , M ) : <NEWLINE> <INDENT> B_sum [ i ] = B_sum [ i - 1 ] + B [ i ] <NEWLINE> <NL> <NL> <DEDENT> max_ = 0 <NEWLINE> for i , n in enumerate ( A_sum ) : <NEWLINE> <INDENT> if n > K : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> target = K - n <NEWLINE> v = bisect . bisect_left ( B_sum , target ) <NEWLINE> <NL> if v != M and B_sum [ v ] == target : <NEWLINE> <INDENT> v += 1 <NEWLINE> <NL> <DEDENT> max_ = max ( max_ , i + v ) <NEWLINE> <NL> <DEDENT> print ( max_ ) <NEWLINE>
n = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> nums . sort ( ) <NEWLINE> result = 1 <NEWLINE> for i in nums : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if result == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> E = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> Node_len = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> AS = [ 0 for i in range ( N + 1 ) ] <NEWLINE> def dfs ( node , parent = - 1 ) : <NEWLINE> <INDENT> for child in E [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> AS [ child ] += AS [ node ] <NEWLINE> dfs ( child , node ) <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> AS [ p ] += x <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> print ( * AS [ 1 : ] ) <NEWLINE> <NL> <NL>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = min ( b - 1 , n ) <NEWLINE> print ( int ( a * tmp / b ) - a * int ( tmp / b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( sep = <STRING> ) ) ) <NEWLINE> Acounter = [ ] <NEWLINE> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> Acounter . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( 0 , N - 1 , 1 ) : <NEWLINE> <INDENT> Acounter [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> print ( Acounter [ i ] ) <NEWLINE> <DEDENT>
def fibonacci ( f , n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> f [ n ] = 1 <NEWLINE> return f [ n ] <NEWLINE> <DEDENT> if f [ n ] : <NEWLINE> <INDENT> return f [ n ] <NEWLINE> <DEDENT> f [ n ] = fibonacci ( f , n - 2 ) + fibonacci ( f , n - 1 ) <NEWLINE> return f [ n ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> f = [ None for i in range ( n + 1 ) ] <NEWLINE> print ( fibonacci ( f , n ) ) <NEWLINE>
n , m , k = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> b = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> total_max = 0 <NEWLINE> <NL> while i < n : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k -= a [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while j < m : <NEWLINE> <INDENT> if b [ j ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k -= b [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> total_max = i + j <NEWLINE> <NL> while i > 0 and j < m : <NEWLINE> <INDENT> k += a [ i - 1 ] <NEWLINE> i -= 1 <NEWLINE> while j < m : <NEWLINE> <INDENT> if b [ j ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k -= b [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> if total_max < i + j : <NEWLINE> <INDENT> total_max = i + j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total_max ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> def fun ( x ) : <NEWLINE> <NL> <INDENT> res = [ ] <NEWLINE> <NL> for a in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> mult = a ** 5 - b ** 5 <NEWLINE> if mult == x : <NEWLINE> <INDENT> res = a , b <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res [ 0 ] , res [ 1 ] ) <NEWLINE> <NL> <DEDENT> fun ( x ) <NEWLINE>
<COMMENT> <NL> N , M , Q = [ eval ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> a_list , b_list , c_list , d_list = [ ] , [ ] , [ ] , [ ] <NEWLINE> <NL> for k in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = [ eval ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> a_list . append ( a ) <NEWLINE> b_list . append ( b ) <NEWLINE> c_list . append ( c ) <NEWLINE> d_list . append ( d ) <NEWLINE> <NL> <DEDENT> max_value = 0 <NEWLINE> <NL> def calc_score ( complete_A ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if complete_A [ b_list [ i ] ] - complete_A [ a_list [ i ] ] == c_list [ i ] : <NEWLINE> <INDENT> score += d_list [ i ] <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def search ( A , M , depth , a_list , b_list , c_list , d_list , max_value , count ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if depth > 0 : <NEWLINE> <INDENT> last_A = A [ - 1 ] <NEWLINE> for k in range ( last_A , M + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> next_A = A + [ k ] <NEWLINE> max_value = search ( next_A , M , depth - 1 , a_list , b_list , c_list , d_list , max_value , count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> value = calc_score ( A [ 1 : ] ) <NEWLINE> if value > max_value : <NEWLINE> <INDENT> max_value = value <NEWLINE> <DEDENT> <DEDENT> return max_value <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> A = [ 1 ] <NEWLINE> print ( search ( A , M , N + 1 , a_list , b_list , c_list , d_list , max_value , count ) ) <NEWLINE>
from collections import deque <NEWLINE> printn = lambda x : print ( x , end = <STRING> ) <NEWLINE> inn = lambda : int ( input ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ins = lambda : input ( ) . strip ( ) <NEWLINE> DBG = True <COMMENT> <NEWLINE> BIG = 10 ** 18 <NEWLINE> R = 10 ** 9 + 7 <NEWLINE> <NL> def ddprint ( x ) : <NEWLINE> <INDENT> if DBG : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = inn ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dst = [ { } for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = inm ( ) <NEWLINE> dst [ u ] [ v ] = dst [ v ] [ u ] = 1 <NEWLINE> <DEDENT> s = 1 <NEWLINE> d1 = [ - 1 ] * ( n + 1 ) <NEWLINE> d1 [ s ] = 0 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> d = d1 [ x ] <NEWLINE> for u in dst [ x ] : <NEWLINE> <INDENT> if d1 [ u ] < 0 : <NEWLINE> <INDENT> d1 [ u ] = d + 1 <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mx = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if d1 [ i ] > mx : <NEWLINE> <INDENT> mx = d1 [ i ] <NEWLINE> mxi = i <NEWLINE> <NL> <DEDENT> <DEDENT> s = mxi <NEWLINE> d1 = [ - 1 ] * ( n + 1 ) <NEWLINE> d1 [ s ] = 0 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> d = d1 [ x ] <NEWLINE> for u in dst [ x ] : <NEWLINE> <INDENT> if d1 [ u ] < 0 : <NEWLINE> <INDENT> d1 [ u ] = d + 1 <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if max ( d1 ) % 3 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ - 1 ] * n <NEWLINE> <NL> def find_root ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = find_root ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find_root ( x ) <NEWLINE> y = find_root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = find_root ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> max_size = max ( map ( size , range ( n ) ) ) <NEWLINE> <NL> print ( max_size ) <NEWLINE>
import sys <NEWLINE> import functools <NEWLINE> import collections <NEWLINE> import operator <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> n = int ( next ( in_ ) ) <NEWLINE> s = next ( in_ ) . strip ( ) <NEWLINE> <NL> c = collections . Counter ( ) <NEWLINE> c [ <STRING> [ 0 ] ] = 0 <NEWLINE> c [ <STRING> [ 0 ] ] = 0 <NEWLINE> c [ <STRING> [ 0 ] ] = 0 <NEWLINE> c . update ( s ) <NEWLINE> ans = functools . reduce ( operator . mul , c . values ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k - 1 >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> si = s [ i - 1 ] <NEWLINE> sj = s [ j - 1 ] <NEWLINE> sk = s [ k - 1 ] <NEWLINE> if si != sj and sj != sk and sk != si : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * L , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> from bisect import * <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += bisect_left ( L , L [ i ] + L [ j ] ) - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] <NEWLINE> m = a [ - 1 ] + 1 <NEWLINE> def f ( S ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> while 2 * x * - ~ x < m : <NEWLINE> <INDENT> if ( S - x ) % ( 2 * x + 1 ) == 0 : return 0 <NEWLINE> x += 1 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> print ( sum ( f ( S ) for S in a ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in A : <NEWLINE> <INDENT> if j >> i & 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> ans += pow ( 2 , i , mod ) * c * ( N - c ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> dic = set ( ) <NEWLINE> L = sys . stdin . readlines ( ) <NEWLINE> <NL> for Ins in L [ 1 : ] : <NEWLINE> <INDENT> ins , op = Ins . split ( ) <NEWLINE> if ins == <STRING> : <NEWLINE> <INDENT> dic . add ( op ) <NEWLINE> <DEDENT> if ins == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if op in dic else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lst = [ ] <NEWLINE> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> lst . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst [ - K ] ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> n_list = [ ] <NEWLINE> m_list = [ ] <NEWLINE> c = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n_list . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> m_list . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] += n_list [ i ] [ k ] * m_list [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( i ) for i in c [ i ] ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> point = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k > i : <NEWLINE> <INDENT> point += a [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> now = point <NEWLINE> now -= a [ i - k ] <NEWLINE> now += a [ i ] <NEWLINE> if now > point : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> point = now <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * A , = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> <NL> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> la = a [ left : mid ] + [ float ( <STRING> ) ] <NEWLINE> ra = a [ mid : right ] + [ float ( <STRING> ) ] <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if la [ i ] <= ra [ j ] : <NEWLINE> <INDENT> a [ k ] = la [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = ra [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> merge_sort ( A , 0 , N ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE> <NL>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X > 0 : <NEWLINE> <INDENT> if X // D >= K : <NEWLINE> <INDENT> ans = X - D * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= X // D <NEWLINE> X = X % D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( X - D ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if X < 0 : <NEWLINE> <INDENT> if - 1 * X // D >= K : <NEWLINE> <INDENT> ans = abs ( X + D * K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= ( - 1 * X ) // D <NEWLINE> X = ( - 1 * X ) % D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( X - D ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if X == 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = D <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> mod = 2019 <NEWLINE> <NL> X = [ 0 ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> X . append ( ( X [ - 1 ] + int ( s ) * pow ( 10 , i , mod ) ) % mod ) <NEWLINE> <NL> <DEDENT> C = Counter ( X ) <NEWLINE> ans = 0 <NEWLINE> for v in C . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> result = [ ] <NEWLINE> def check ( x , y , remnant ) : <NEWLINE> <INDENT> return x % y == remnant <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if check ( x , 3 , 0 ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( len ( str ( x ) ) ) : <NEWLINE> <INDENT> if check ( x , 10 , 3 ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( map ( str , result ) ) ) <NEWLINE>
<NL> import numpy as np <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = np . zeros ( [ H , W ] ) <NEWLINE> <NL> black_count = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> C = list ( input ( ) ) <NEWLINE> for j in range ( len ( C ) ) : <NEWLINE> <INDENT> if ( C [ j ] == <STRING> ) : <NEWLINE> <INDENT> D [ i ] [ j ] = 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> h = format ( i , <STRING> ) <NEWLINE> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> w = format ( j , <STRING> ) <NEWLINE> d = D . copy ( ) <NEWLINE> <NL> for hi in range ( H ) : <NEWLINE> <INDENT> if ( h [ 5 - hi ] == <STRING> ) : <NEWLINE> <INDENT> d [ hi , : ] = 0 <NEWLINE> <DEDENT> <DEDENT> for wi in range ( W ) : <NEWLINE> <INDENT> if ( w [ 5 - wi ] == <STRING> ) : <NEWLINE> <INDENT> d [ : , wi ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( d . sum ( ) == K ) : <NEWLINE> <INDENT> black_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( black_count ) <NEWLINE>
N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> text = <STRING> <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> text += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> text += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( text ) ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = tuple ( a ) <NEWLINE> a . sort ( ) <NEWLINE> for i in b : <NEWLINE> <INDENT> if i == a [ n - 1 ] : <NEWLINE> <INDENT> print ( a [ n - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ n - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> N = 26 <NEWLINE> L = [ 0 ] * N <NEWLINE> now = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> nx = 0 <NEWLINE> mx = - INF <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> res = now <NEWLINE> prevL = L [ i ] <NEWLINE> L [ i ] = d <NEWLINE> <NL> res += S [ d ] [ i ] <NEWLINE> for l , c in zip ( L , C ) : <NEWLINE> <INDENT> res -= c * ( d - l ) <NEWLINE> <NL> <DEDENT> L [ i ] = prevL <NEWLINE> if mx < res : <NEWLINE> <INDENT> mx = res <NEWLINE> nx = i <NEWLINE> <DEDENT> <DEDENT> now = res <NEWLINE> print ( nx + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in D : <NEWLINE> <INDENT> D [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in D : <NEWLINE> <INDENT> D [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ C ] = B <NEWLINE> <NL> <DEDENT> <DEDENT> K = sorted ( D . keys ( ) , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> cnt = N <NEWLINE> for k in K : <NEWLINE> <INDENT> a = min ( D [ k ] , cnt ) <NEWLINE> ans += k * a <NEWLINE> cnt -= a <NEWLINE> if cnt == 0 : break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> <NL> def block ( board , w , h , direction , color ) : <NEWLINE> <COMMENT> <NL> <INDENT> if direction == 0 : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> board [ h + i ] [ w + j ] = color <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> elif direction == 1 : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> board [ h + j ] [ w + i ] = color <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def print_board ( board ) : <NEWLINE> <INDENT> for i in range ( len ( board ) ) : <NEWLINE> <INDENT> print ( board [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def go_maze ( board , s_w , s_h , g_w , g_h ) : <NEWLINE> <INDENT> place = board [ s_h ] [ s_w ] <NEWLINE> if place == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> w , h = s_w , s_h <NEWLINE> stack = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> board [ h ] [ w ] = place + 1 <NEWLINE> if h + 1 < len ( board ) and board [ h + 1 ] [ w ] == place : <NEWLINE> <INDENT> h += 1 <NEWLINE> stack . append ( ( w , h ) ) <NEWLINE> <DEDENT> elif w + 1 < len ( board [ h ] ) and board [ h ] [ w + 1 ] == place : <NEWLINE> <INDENT> w += 1 <NEWLINE> stack . append ( ( w , h ) ) <NEWLINE> <DEDENT> elif h - 1 > 0 and board [ h - 1 ] [ w ] == place : <NEWLINE> <INDENT> h -= 1 <NEWLINE> stack . append ( ( w , h ) ) <NEWLINE> <DEDENT> elif w - 1 > 0 and board [ h ] [ w - 1 ] == place : <NEWLINE> <INDENT> w -= 1 <NEWLINE> stack . append ( ( w , h ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( stack ) == 0 and board [ h + 1 ] [ w ] != place and board [ h ] [ w + 1 ] != place and board [ h - 1 ] [ w ] != place and board [ h ] [ w - 1 ] != place : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> ( w , h ) = stack . pop ( ) <NEWLINE> <NL> <DEDENT> if w == g_w and h == g_h : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> board = [ [ 0 for _ in range ( 110 ) ] for _ in range ( 110 ) ] <NEWLINE> s_w , s_h = map ( int , input ( ) . split ( ) ) <NEWLINE> g_w , g_h = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> color , direction , w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> block ( board , w , h , direction , color ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( go_maze ( board , s_w , s_h , g_w , g_h ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> x_1 = x . count ( <STRING> ) <NEWLINE> flag = 0 <NEWLINE> if ( x_1 == 0 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if ( x_1 == 1 ) : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <NL> <DEDENT> data = [ 0 for i in range ( n + 1 ) ] <NEWLINE> data [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> i_str = format ( i , <STRING> ) <NEWLINE> ne = i % ( i_str . count ( <STRING> ) ) <NEWLINE> data [ i ] = data [ ne ] + 1 <NEWLINE> <NL> <DEDENT> up = [ 0 for i in range ( n ) ] <NEWLINE> do = [ 0 for i in range ( n ) ] <NEWLINE> <NL> d = 1 <NEWLINE> upp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> up [ i ] = d <NEWLINE> if ( x [ n - i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> upp += d <NEWLINE> upp %= ( x_1 + 1 ) <NEWLINE> <DEDENT> d *= 2 <NEWLINE> d %= ( x_1 + 1 ) <NEWLINE> <DEDENT> d = 1 <NEWLINE> dow = 0 <NEWLINE> if ( flag == 0 ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> do [ i ] = d <NEWLINE> if ( x [ n - i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> dow += d <NEWLINE> dow %= ( x_1 - 1 ) <NEWLINE> <DEDENT> d *= 2 <NEWLINE> d %= ( x_1 - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( x [ i ] == <STRING> ) : <NEWLINE> <INDENT> sam = upp + up [ n - i - 1 ] <NEWLINE> sam %= ( x_1 + 1 ) <NEWLINE> print ( data [ sam ] + 1 ) <NEWLINE> <DEDENT> elif ( flag == 0 ) : <NEWLINE> <INDENT> sam = dow - do [ n - i - 1 ] <NEWLINE> sam %= ( x_1 - 1 ) <NEWLINE> print ( data [ sam ] + 1 ) <NEWLINE> <DEDENT> elif ( flag == 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> res *= x <NEWLINE> if ( res > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def sol ( K ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res += math . gcd ( k , t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( sol ( K ) ) <NEWLINE>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> if len ( s ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect <NEWLINE> import random <NEWLINE> <NL> <NL> def binary_search ( L , n , i , j ) : <NEWLINE> <COMMENT> <NL> <INDENT> low = i <NEWLINE> high = j <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = L [ mid ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if guess > n : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i , j = 0 , 0 <NEWLINE> <NL> A_ind = [ ] <NEWLINE> B_cum = [ 0 ] <NEWLINE> <NL> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> i = bisect ( B , a ) <NEWLINE> A_ind . append ( i ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for b in B : <NEWLINE> <COMMENT> <NL> <INDENT> j = i = bisect ( C , b ) <NEWLINE> s += N - j <NEWLINE> B_cum . append ( s ) <NEWLINE> <NL> <DEDENT> for a in A_ind : <NEWLINE> <INDENT> ans += B_cum [ - 1 ] - B_cum [ a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> friend = [ 0 ] * n <NEWLINE> block = [ 0 ] * n <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> uf . union ( a - 1 , b - 1 ) <NEWLINE> friend [ a - 1 ] += 1 <NEWLINE> friend [ b - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( d - 1 , c - 1 ) : <NEWLINE> <INDENT> block [ c - 1 ] += 1 <NEWLINE> block [ d - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( uf . size ( i ) - friend [ i ] - block [ i ] - 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> max = a [ - 1 ] <NEWLINE> dp = [ False for _ in range ( max + 1 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if dp [ i ] == False : <NEWLINE> <INDENT> j = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> if i * j > max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i * j ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> dp [ a [ i ] ] = True <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if dp [ i ] == False : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> X = 1 << i <NEWLINE> n = len ( [ 1 for a in A if a & X ] ) <NEWLINE> ans += X * n * ( N - n ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> N = math . floor ( X ** ( 2 / 5 ) ) + 1 <NEWLINE> <NL> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( - N , N ) : <NEWLINE> <INDENT> x = a ** 5 <NEWLINE> y = b ** 5 <NEWLINE> T = 0 <NEWLINE> if x - y == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> T = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if T == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a_max = a [ - 1 ] <NEWLINE> count = 0 <NEWLINE> b = Counter ( a ) <NEWLINE> count_list = [ 0 ] * ( a_max ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if b [ i ] == 1 : <NEWLINE> <INDENT> if count_list [ i - 1 ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> j = 1 <NEWLINE> while i * j <= a_max : <NEWLINE> <INDENT> count_list [ i * j - 1 ] += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j = 2 <NEWLINE> while i * j <= a_max : <NEWLINE> <INDENT> count_list [ i * j - 1 ] += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , copy , functools <NEWLINE> import time , random , resource <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> def pe ( s ) : return print ( str ( s ) , file = sys . stderr ) <NEWLINE> def JA ( a , sep ) : return sep . join ( map ( str , a ) ) <NEWLINE> def JAA ( a , s , t ) : return s . join ( t . join ( map ( str , b ) ) for b in a ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = I ( ) <NEWLINE> <NL> g = math . gcd ( x , 360 ) <NEWLINE> <NL> return 360 // g <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
a , b , c , d , e , f = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> max_a = f // ( 100 * a ) <NEWLINE> max_b = f // ( 100 * b ) <NEWLINE> max_c = f // c <NEWLINE> max_d = f // d <NEWLINE> <NL> <COMMENT> <NL> x_list = [ ] <NEWLINE> for i in range ( max_a + 1 ) : <NEWLINE> <INDENT> for j in range ( max_b + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 100 * a * i + 100 * b * j <NEWLINE> if 0 < x <= f and x not in x_list : <NEWLINE> <INDENT> x_list . append ( x ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> y_list = [ ] <NEWLINE> for i in range ( max_c + 1 ) : <NEWLINE> <INDENT> for j in range ( max_d + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> y = c * i + d * j <NEWLINE> if 0 <= y < f and y not in y_list : <NEWLINE> <INDENT> y_list . append ( y ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> concentration_list = [ ] <NEWLINE> sugar_water_list = [ ] <NEWLINE> sugar_list = [ ] <NEWLINE> <NL> for i in x_list : <NEWLINE> <INDENT> for j in y_list : <NEWLINE> <INDENT> if i + j <= f and j / i <= e / 100 : <NEWLINE> <INDENT> concentration = 100 * j / ( i + j ) <NEWLINE> concentration_list . append ( concentration ) <NEWLINE> sugar_water_list . append ( i + j ) <NEWLINE> sugar_list . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sugar_index = concentration_list . index ( max ( concentration_list ) ) <NEWLINE> print ( sugar_water_list [ sugar_index ] , sugar_list [ sugar_index ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N_list = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> num_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for j in range ( len ( num_list ) ) : <NEWLINE> <INDENT> N_list [ num_list [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N_list . count ( 0 ) ) <NEWLINE>
Masu = [ ] <NEWLINE> def access ( x , y ) : <NEWLINE> <INDENT> if x < 0 or y < 0 or x > 9 or y > 9 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> Masu [ y ] [ x ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> Masu . append ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) <NEWLINE> <DEDENT> kosu = 0 <NEWLINE> komax = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <NL> <INDENT> x , y , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if s == 1 : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> access ( y + 1 - j , x ) <NEWLINE> <DEDENT> access ( y , x - 1 ) <NEWLINE> access ( y , x + 1 ) <NEWLINE> <NL> <DEDENT> elif s == 2 : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> for l in range ( 3 ) : <NEWLINE> <INDENT> access ( y + 1 - k , x + 1 - l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == 3 : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> for l in range ( 3 ) : <NEWLINE> <INDENT> access ( y + 1 - k , x + 1 - l ) <NEWLINE> <DEDENT> <DEDENT> access ( y - 2 , x ) <NEWLINE> access ( y + 2 , x ) <NEWLINE> access ( y , x + 2 ) <NEWLINE> access ( y , x - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> except ( EOFError , ValueError ) : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> kosu += Masu [ i ] . count ( 0 ) <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> if komax < max ( Masu [ j ] ) : <NEWLINE> <INDENT> komax = max ( Masu [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( kosu ) <NEWLINE> print ( komax ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> <NL> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> sa = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sa [ i + 1 ] = sa [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> sb = [ 0 ] * ( m + 1 ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> sb [ j + 1 ] = sb [ j ] + b [ j ] <NEWLINE> <NL> <DEDENT> anses = [ 0 ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if sa [ i ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> anses . append ( i + bisect . bisect ( sb , k - sa [ i ] ) - 1 ) <NEWLINE> <NL> <DEDENT> print ( max ( anses ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> a = ( n * m ) // math . gcd ( n , m ) <NEWLINE> b0 = [ i * ( a // n ) + 1 for i in range ( n ) ] <NEWLINE> b1 = [ i * ( a // m ) + 1 for i in range ( m ) ] <NEWLINE> b2 = set ( b0 ) <NEWLINE> b3 = set ( b1 ) <NEWLINE> <NL> for j , i in enumerate ( b0 ) : <NEWLINE> <INDENT> if i in b3 : <NEWLINE> <INDENT> if s [ j ] != t [ b1 . index ( i ) ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for j , i in enumerate ( b1 ) : <NEWLINE> <INDENT> if i in b2 : <NEWLINE> <INDENT> if s [ b0 . index ( i ) ] != t [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce , lru_cache <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MAP1 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> def LIST1 ( ) : return list ( MAP1 ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> a = LIST ( ) <NEWLINE> <NL> c = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for x in a : <NEWLINE> <INDENT> c [ x ] += 1 <NEWLINE> <NL> <DEDENT> k = max ( sum ( c [ i : : i ] ) for i in range ( 2 , 10 ** 6 + 1 ) ) <NEWLINE> <NL> if k <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k < n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a * x + b * y , c * 2 * x + b * max ( 0 , y - x ) , c * 2 * y + a * max ( 0 , x - y ) ) ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> ans = lt <NEWLINE> <NL> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if S [ j + i ] != T [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> hights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * N <NEWLINE> <NL> for i in range ( 0 , M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if hights [ a - 1 ] > hights [ b - 1 ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif hights [ a - 1 ] < hights [ b - 1 ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> ans [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <NL> <NL>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> Ymax = 0 <NEWLINE> if A * N < B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N < B : <NEWLINE> <INDENT> Ymax = A * N // B <NEWLINE> print ( Ymax ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> Ymax = A * x // B - A * ( x // B ) <NEWLINE> print ( Ymax ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> highest = int ( math . sqrt ( n ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> cal = 0 <NEWLINE> <NL> for x in range ( 1 , highest + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , highest + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , highest + 1 ) : <NEWLINE> <INDENT> cal = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if cal > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ cal - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> def popcount ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> <NL> <COMMENT> <NL> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> <NL> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <COMMENT> <NEWLINE> x = x + ( x >> 8 ) <COMMENT> <NEWLINE> x = x + ( x >> 16 ) <COMMENT> <NEWLINE> x = x + ( x >> 32 ) <COMMENT> <NEWLINE> return x & 0x0000007f <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> d = { } <NEWLINE> dd = { } <NEWLINE> x1 = X . count ( <STRING> ) <NEWLINE> xn = int ( X , 2 ) <NEWLINE> def hoge ( i ) : <NEWLINE> <INDENT> if i in dd : <NEWLINE> <INDENT> return dd [ i ] <NEWLINE> <DEDENT> if i not in d : <NEWLINE> <INDENT> j = popcount ( i ) <NEWLINE> d [ i ] = i % j <NEWLINE> if d [ i ] == 0 : <NEWLINE> <INDENT> dd [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dd [ i ] = 1 + hoge ( d [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return dd [ i ] <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if X == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return 1 <NEWLINE> <DEDENT> <DEDENT> if x1 == 1 : <NEWLINE> <INDENT> xn1 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xn1 = xn % ( x1 - 1 ) <NEWLINE> <DEDENT> xn2 = xn % ( x1 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> t = xn1 <NEWLINE> if x1 - 1 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> t -= pow ( 2 , N - 1 - i , x1 - 1 ) <NEWLINE> t %= ( x1 - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = xn2 <NEWLINE> t += pow ( 2 , N - 1 - i , x1 + 1 ) <NEWLINE> t %= ( x1 + 1 ) <NEWLINE> <DEDENT> if t == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 + hoge ( t ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s1 = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s2 = input ( ) <NEWLINE> BASE = 27 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def rolling_hash ( s ) : <NEWLINE> <INDENT> h_lst = [ 0 ] <NEWLINE> for c in s : <NEWLINE> <INDENT> h_lst . append ( ( h_lst [ - 1 ] * BASE + ord ( c ) ) % MOD ) <NEWLINE> <DEDENT> return h_lst <NEWLINE> <NL> <NL> <DEDENT> h_lst1 = rolling_hash ( s1 ) <NEWLINE> h_lst2 = rolling_hash ( s2 ) <NEWLINE> length1 = len ( s1 ) <NEWLINE> length2 = len ( s2 ) <NEWLINE> <NL> pow_mem = [ pow ( BASE , i , MOD ) for i in range ( min ( length1 , length2 ) + 1 ) ] <NEWLINE> <NL> <NL> def check ( center ) : <NEWLINE> <INDENT> hash_set = { ( h_lst1 [ i + center ] - h_lst1 [ i ] * pow_mem [ center ] ) % MOD for i in range ( length1 - center + 1 ) } <NEWLINE> for i in range ( length2 - center + 1 ) : <NEWLINE> <INDENT> h2 = ( h_lst2 [ i + center ] - h_lst2 [ i ] * pow_mem [ center ] ) % MOD <NEWLINE> if h2 in hash_set : return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> left = 0 <NEWLINE> right = min ( length1 , length2 ) <NEWLINE> while right > left + 1 : <NEWLINE> <INDENT> center = ( left + right ) // 2 <NEWLINE> if check ( center ) : <NEWLINE> <INDENT> left = center <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = center <NEWLINE> <DEDENT> <DEDENT> print ( right if check ( right ) else left ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> result = [ ] <NEWLINE> def calc ( a , b , c , i ) : <NEWLINE> <INDENT> if a < 0 or b < 0 or c < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if i >= N : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> command = s [ i ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> if calc ( a + 1 , b - 1 , c , i + 1 ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if calc ( a - 1 , b + 1 , c , i + 1 ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> if calc ( a + 1 , b , c - 1 , i + 1 ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if calc ( a - 1 , b , c + 1 , i + 1 ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> if calc ( a , b - 1 , c + 1 , i + 1 ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if calc ( a , b + 1 , c - 1 , i + 1 ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global N , s <NEWLINE> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( N ) ] <NEWLINE> if calc ( A , B , C , 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for c in result [ : : - 1 ] : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max = 0 <NEWLINE> if N > B : <NEWLINE> <INDENT> N = B - 1 <NEWLINE> y = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> print ( int ( y ) ) <NEWLINE> <DEDENT> elif N == B : <NEWLINE> <INDENT> N = B - 1 <NEWLINE> y = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> print ( int ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> print ( int ( y ) ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 1 ] <NEWLINE> go = [ 0 ] * N <NEWLINE> hop = 0 <NEWLINE> ans = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> nc = A [ B [ n ] - 1 ] <NEWLINE> if go [ nc - 1 ] == 1 : <NEWLINE> <INDENT> idx = B . index ( nc ) <NEWLINE> loop = B [ idx : ] <NEWLINE> break <NEWLINE> <DEDENT> B . append ( nc ) <NEWLINE> K -= 1 <NEWLINE> go [ nc - 1 ] = 1 <NEWLINE> ans = nc <NEWLINE> if K < 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K > 0 : <NEWLINE> <INDENT> L = len ( loop ) <NEWLINE> K = K % L <NEWLINE> K -= 1 <NEWLINE> ans = loop [ K ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> a = 7 % K <NEWLINE> i = 1 <NEWLINE> Kset = set ( ) <NEWLINE> Kset . add ( a ) <NEWLINE> while a != 0 : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> if a in Kset : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> Kset . add ( a ) <NEWLINE> <DEDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = S [ i ] <NEWLINE> for j in range ( i + 2 , N , 2 ) : <NEWLINE> <INDENT> b = S [ j ] <NEWLINE> k = ( i + j ) // 2 <NEWLINE> if sorted ( [ a , S [ k ] , b ] ) == [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> lst = input ( ) . split ( ) <NEWLINE> command = lst [ 0 ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> v = int ( lst [ 1 ] ) <NEWLINE> q . appendleft ( v ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> v = int ( lst [ 1 ] ) <NEWLINE> if v in q : <NEWLINE> <INDENT> q . remove ( v ) <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * list ( q ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 1 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> r = r * l [ x ] <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
bounds = [ sum ( [ 26 ** i for i in range ( n ) ] ) for n in range ( 1 , 12 ) ] <NEWLINE> lis = <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> for b in reversed ( bounds ) : <NEWLINE> <INDENT> if b <= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> N -= b <NEWLINE> length = bounds . index ( b ) + 1 <NEWLINE> s = <STRING> <NEWLINE> for i in range ( length - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> idx , N = divmod ( N , 26 ** i ) <NEWLINE> s = s + lis [ idx ] <NEWLINE> <DEDENT> print ( s + lis [ N ] ) <NEWLINE>
N = int ( input ( ) ) <COMMENT> <NEWLINE> S = input ( ) <COMMENT> <NEWLINE> L = { <NEWLINE> <INDENT> <STRING> : tuple ( i for i , v in enumerate ( S ) if v == <STRING> ) , <NEWLINE> <STRING> : tuple ( i for i , v in enumerate ( S ) if v == <STRING> ) , <NEWLINE> <STRING> : tuple ( i for i , v in enumerate ( S ) if v == <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE> R_length = len ( L [ <STRING> ] ) <NEWLINE> G_length = len ( L [ <STRING> ] ) <NEWLINE> B_length = len ( L [ <STRING> ] ) <NEWLINE> <NL> ans = R_length * G_length * B_length <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
from collections import defaultdict <NEWLINE> <NL> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> dd = defaultdict ( int ) <NEWLINE> <NL> d = [ 0 for i in range ( 2019 ) ] <NEWLINE> d [ 0 ] = 1 <NEWLINE> tmp = 0 <NEWLINE> _10 = 1 <NEWLINE> <COMMENT> <NL> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> tmp += ( int ( s [ i ] ) * _10 ) % 2019 <NEWLINE> _10 *= 10 <NEWLINE> _10 %= 2019 <NEWLINE> <COMMENT> <NL> d [ tmp % 2019 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> print ( sum ( v * ( v - 1 ) // 2 for v in d ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> input = sys . stdin . readline <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return sys . stdin . read ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , s = MI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> li = [ 0 ] * ( 3010 ) <NEWLINE> li = np . array ( li ) <NEWLINE> li [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> for i in A : <NEWLINE> <INDENT> tmp = li . copy ( ) <NEWLINE> li *= 2 <NEWLINE> li [ i : ] += tmp [ : 3010 - i ] <NEWLINE> li %= 998244353 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( li [ s ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if K >= N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> H . sort ( reverse = True ) <NEWLINE> del H [ 0 : K ] <NEWLINE> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> ans += H [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , * x = map ( int , input ( ) . split ( ) ) <NEWLINE> k = <STRING> <NEWLINE> ans = [ ] <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> for p in range ( n ) : <NEWLINE> <INDENT> sp = s [ p ] <NEWLINE> if sp == <STRING> : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = 1 <NEWLINE> <DEDENT> elif sp == <STRING> : <NEWLINE> <INDENT> i = 1 <NEWLINE> j = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = 2 <NEWLINE> <DEDENT> if x [ i ] == x [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if x [ i ] == x [ j ] and p < n - 1 : <NEWLINE> <INDENT> sp1 = s [ p + 1 ] <NEWLINE> if k [ i ] in sp1 : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> x [ j ] -= 1 <NEWLINE> ans . append ( k [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i ] -= 1 <NEWLINE> x [ j ] += 1 <NEWLINE> ans . append ( k [ j ] ) <NEWLINE> <DEDENT> <DEDENT> elif x [ i ] < x [ j ] : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> x [ j ] -= 1 <NEWLINE> ans . append ( k [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i ] -= 1 <NEWLINE> x [ j ] += 1 <NEWLINE> ans . append ( k [ j ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> dx = x1 - x2 <NEWLINE> dy = y1 - y2 <NEWLINE> <NL> d = math . hypot ( dx , dy ) <NEWLINE> <NL> print ( d ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( x , 1000000 ) : <NEWLINE> <INDENT> for j in range ( 2 , i + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if j == i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> if i % j == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from bisect import * <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> alp = list ( <STRING> ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> b = bisect_left ( alp , S [ i ] ) <NEWLINE> <NL> if i == len ( S ) - 1 : <NEWLINE> <INDENT> S [ i ] = alp [ ( b + K ) % 26 ] <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif 26 - b <= K : <NEWLINE> <INDENT> K -= ( 26 - b ) <NEWLINE> S [ i ] = <STRING> <NEWLINE> <DEDENT> if K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge_list = [ [ ] for i in range ( n ) ] <NEWLINE> prev_list = [ 1 ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge_list [ a - 1 ] . append ( b ) <NEWLINE> edge_list [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> while len ( prev_list ) > 0 : <NEWLINE> <INDENT> next = [ ] <NEWLINE> for prev in prev_list : <NEWLINE> <INDENT> for edge in edge_list [ prev - 1 ] : <NEWLINE> <INDENT> if ans [ edge - 1 ] == 0 : <NEWLINE> <INDENT> next . append ( edge ) <NEWLINE> ans [ edge - 1 ] = prev <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prev_list = next <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> from decimal import Decimal <NEWLINE> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> A , B = map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> if B [ 0 ] == <STRING> : <NEWLINE> <INDENT> B = int ( B [ 2 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = int ( B . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> print ( A * B // 100 ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> N = 10 ** 5 * 2 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> fact_inv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def comb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * fact_inv [ r ] * fact_inv [ n - r ] % mod <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def perm ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fact [ n ] * fact_inv [ n - r ] % mod <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> inv . append ( ( - inv [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> fact_inv . append ( ( fact_inv [ - 1 ] * inv [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += comb ( n - 1 , i , mod ) * m * pow ( m - 1 , n - i - 1 , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> L = int ( 9 * K / 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> X = 0 <NEWLINE> kekka = 1 <NEWLINE> total = - 1 <NEWLINE> if L % 2 == 1 : <NEWLINE> <INDENT> if L % 5 != 0 : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> kekka = kekka * 10 % L <NEWLINE> if kekka == 1 : <NEWLINE> <INDENT> total = i + 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> digits = dict ( ) <NEWLINE> for d in range ( 30 ) : <NEWLINE> <INDENT> digits [ d ] = 0 <NEWLINE> for a in As : <NEWLINE> <INDENT> digits [ d ] += a >> d & 1 <NEWLINE> <NL> <DEDENT> <DEDENT> oore = 0 <NEWLINE> for k , v in digits . items ( ) : <NEWLINE> <INDENT> oore += ( v % 2 ) << k <NEWLINE> <NL> <DEDENT> nums = [ 0 ] * N <NEWLINE> <NL> for i , a in enumerate ( As ) : <NEWLINE> <INDENT> nums [ i ] = a ^ oore <NEWLINE> <NL> <DEDENT> return nums <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print ( * solve ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = 0 <NEWLINE> S = sum ( A ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> P += A [ i ] * S <NEWLINE> <NL> <DEDENT> ans = P % m <NEWLINE> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def friends ( N , As ) : <NEWLINE> <INDENT> uf = UnionFind ( N ) <NEWLINE> setAs = list ( set ( As ) ) <NEWLINE> for val in setAs : <NEWLINE> <INDENT> uf . union ( val [ 0 ] - 1 , val [ 1 ] - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp = uf . size ( i ) <NEWLINE> if ans < temp : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> nm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( nm [ 1 ] ) ] <NEWLINE> print ( friends ( nm [ 0 ] , As ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( f . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k = [ int ( ki ) for ki in f . readline ( ) . split ( ) ] <NEWLINE> k = [ ki for ki in k if 0 < ki ] <NEWLINE> print ( <STRING> if len ( k ) == 0 or max ( k ) < 2 else len ( k ) + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> C = Counter ( A ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if C [ i ] + k - q <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( A_list [ i ] < A_list [ K + i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> M = 100002 <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Num = np . zeros ( ( M ) ) <NEWLINE> Sum = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Num [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( Num [ B ] == 0 ) : <NEWLINE> <INDENT> print ( int ( Sum ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sum = Sum + ( C - B ) * Num [ B ] <NEWLINE> Num [ C ] += Num [ B ] <NEWLINE> Num [ B ] = 0 <NEWLINE> print ( int ( Sum ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> aS = math . ceil ( a / 0.08 ) <NEWLINE> al = math . floor ( ( a + 1 ) / 0.08 ) <NEWLINE> bs = math . ceil ( b / 0.10 ) <NEWLINE> bl = math . floor ( ( b + 1 ) / 0.10 ) <NEWLINE> <NL> flag = True <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> if aS <= i < al and bs <= i < bl : <NEWLINE> <INDENT> print ( i ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from decimal import * <NEWLINE> import re <NEWLINE> def solve2 ( m , n ) : <NEWLINE> <INDENT> maxlen = 160 <NEWLINE> PREC = 200 <NEWLINE> getcontext ( ) . prec = PREC <NEWLINE> x = Decimal ( m ) / Decimal ( n ) <NEWLINE> s = x . to_eng_string ( ) <NEWLINE> if len ( s ) < PREC : <NEWLINE> <INDENT> return ( s [ 2 : ] , <STRING> ) <NEWLINE> <DEDENT> rep = 1 <NEWLINE> while True : <NEWLINE> <INDENT> r = <STRING> % ( rep , int ( maxlen / rep ) - 1 ) <COMMENT> <NEWLINE> a = re . search ( r , s ) <NEWLINE> if a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rep += 1 <NEWLINE> if rep > maxlen : <NEWLINE> <INDENT> raise ValueError ( <STRING> % rep ) <NEWLINE> <NL> <DEDENT> <DEDENT> u = s [ 2 : a . start ( ) + len ( a . group ( 1 ) ) ] <NEWLINE> v = ( <STRING> * PREC + <STRING> * len ( a . group ( 1 ) ) ) [ - len ( u ) : ] <NEWLINE> return ( u , v ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> s , t = solve2 ( m , n ) <NEWLINE> print ( s ) <NEWLINE> if t != <STRING> : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> answ = [ ] <NEWLINE> ansh = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if not all ( [ a == <STRING> for a in A [ i ] ] ) : <NEWLINE> <INDENT> answ . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not all ( [ A [ i ] [ j ] == <STRING> for i in range ( h ) ] ) : <NEWLINE> <INDENT> ansh . append ( j ) <NEWLINE> <DEDENT> <DEDENT> for i in answ : <NEWLINE> <INDENT> for j in ansh : <NEWLINE> <INDENT> print ( A [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Word_list = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Gift = input ( ) <NEWLINE> Word_list . append ( Gift ) <NEWLINE> <DEDENT> Word_list . sort ( ) <NEWLINE> <NL> Before_Word = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if Word_list [ i ] != Before_Word : <NEWLINE> <INDENT> ans += 1 <NEWLINE> Before_Word = Word_list [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
from heapq import ( <NEWLINE> <INDENT> heapify , <COMMENT> <NEWLINE> heappop , <NEWLINE> heappush , <NEWLINE> heappushpop , <NEWLINE> heapreplace <NEWLINE> ) <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> A = [ - i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> s = - heappop ( A ) <NEWLINE> s //= 2 <NEWLINE> heappush ( A , - s ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> my_sum = [ 0 ] <NEWLINE> <COMMENT> <NL> <NL> tmp = 0 <NEWLINE> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> my_sum . append ( my_sum [ c ] + i ) <NEWLINE> c += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> my_sum2 = 0 <NEWLINE> length = len ( my_sum ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> my_sum2 += i * ( my_sum [ length - 1 ] - my_sum [ c + 1 ] ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> print ( my_sum2 % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> m = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> m = math . gcd ( a , b ) <NEWLINE> ans += 6 * math . gcd ( m , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += 3 * math . gcd ( a , c ) <NEWLINE> <DEDENT> <DEDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for a in range ( c + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += 3 * math . gcd ( a , c ) <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> np . set_printoptions ( linewidth = 200 ) <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> v_max = 10 ** 3 * 100 * 10 <NEWLINE> w_max = 10 ** 9 * v_max <NEWLINE> <NL> <COMMENT> <NL> dp = np . full ( v_max , w_max , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> dp [ 0 ] = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> w , v = lst [ n ] <NEWLINE> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , w in enumerate ( dp ) : <NEWLINE> <INDENT> if w <= W : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def sort ( num ) : <NEWLINE> <INDENT> l = len ( num ) <NEWLINE> for i in range ( 0 , l ) : <NEWLINE> <INDENT> for j in range ( 0 , l - i - 1 ) : <NEWLINE> <INDENT> if num [ j ] < num [ j + 1 ] : <NEWLINE> <INDENT> temp = num [ j ] <NEWLINE> num [ j ] = num [ j + 1 ] <NEWLINE> num [ j + 1 ] = temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , len ( num ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , num [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , num [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ ] <NEWLINE> num . append ( a ) <NEWLINE> num . append ( b ) <NEWLINE> num . append ( c ) <NEWLINE> num . append ( d ) <NEWLINE> num . append ( e ) <NEWLINE> sort ( num ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kouho = set ( [ i + 1 for i in range ( N ) ] ) <NEWLINE> hazure = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Ha = H [ a ] <NEWLINE> Hb = H [ b ] <NEWLINE> if Ha >= Hb : <NEWLINE> <INDENT> hazure . add ( b ) <NEWLINE> <DEDENT> if Ha <= Hb : <NEWLINE> <INDENT> hazure . add ( a ) <NEWLINE> <DEDENT> <DEDENT> ans = kouho - hazure <NEWLINE> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> s . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <NL> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = A [ 1 ] <NEWLINE> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> print ( [ <STRING> , <STRING> ] [ p < A [ i ] ] ) <NEWLINE> p = A [ i - K + 1 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> small = 0 <NEWLINE> dp = [ ] <NEWLINE> <NL> for idx , data in enumerate ( numbers ) : <NEWLINE> <INDENT> if idx == 0 : <NEWLINE> <INDENT> small = data <NEWLINE> dp . append ( data ) <NEWLINE> <DEDENT> elif data < small : <NEWLINE> <INDENT> small = data <NEWLINE> dp . append ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( len ( dp ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( A ) <NEWLINE> l = [ 0 for _ in range ( m ) ] <NEWLINE> fp = True <NEWLINE> for a in A : <NEWLINE> <INDENT> l [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( 2 , m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i - 1 , m , i ) : <NEWLINE> <INDENT> cnt += l [ j ] <NEWLINE> if cnt > 1 : <NEWLINE> <INDENT> fp = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> g = 0 <NEWLINE> fs = False <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , a ) <NEWLINE> <DEDENT> if g == 1 : <NEWLINE> <INDENT> fs = True <NEWLINE> <NL> <DEDENT> if fp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif fs : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> if b [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> b [ j ] += 100 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> cnt_height_plus_ind = { } <NEWLINE> cnt_height_minus_ind = { } <NEWLINE> cnt_ind_minus_height = { } <NEWLINE> cnt_minus_height_minus_ind = { } <NEWLINE> <NL> for ind in range ( N ) : <NEWLINE> <INDENT> height = heights [ ind ] <NEWLINE> <NL> if ind - height not in cnt_ind_minus_height : <NEWLINE> <INDENT> cnt_ind_minus_height [ ind - height ] = 0 <NEWLINE> <DEDENT> cnt_ind_minus_height [ ind - height ] += 1 <NEWLINE> <NL> if ind + height not in cnt_height_plus_ind : <NEWLINE> <INDENT> cnt_height_plus_ind [ ind + height ] = 0 <NEWLINE> <DEDENT> cnt_height_plus_ind [ ind + height ] += 1 <NEWLINE> <NL> if height - ind not in cnt_height_minus_ind : <NEWLINE> <INDENT> cnt_height_minus_ind [ height - ind ] = 0 <NEWLINE> <DEDENT> cnt_height_minus_ind [ height - ind ] += 1 <NEWLINE> <NL> if - ind - height not in cnt_minus_height_minus_ind : <NEWLINE> <INDENT> cnt_minus_height_minus_ind [ - ind - height ] = 0 <NEWLINE> <DEDENT> cnt_minus_height_minus_ind [ - ind - height ] += 1 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for val in cnt_height_minus_ind : <NEWLINE> <INDENT> if val in cnt_minus_height_minus_ind : <NEWLINE> <INDENT> ans += cnt_height_minus_ind [ val ] * cnt_minus_height_minus_ind [ val ] <NEWLINE> <NL> <DEDENT> <DEDENT> for val in cnt_height_plus_ind : <NEWLINE> <INDENT> if val in cnt_ind_minus_height : <NEWLINE> <INDENT> ans += cnt_height_plus_ind [ val ] * cnt_ind_minus_height [ val ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> counter = Counter ( a ) <NEWLINE> sum_res = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> before , after = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_res -= before * counter [ before ] <NEWLINE> sum_res += after * counter [ before ] <NEWLINE> counter [ after ] += counter [ before ] <NEWLINE> counter [ before ] = 0 <NEWLINE> print ( sum_res ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 500 , 500 ) : <NEWLINE> <INDENT> for j in range ( - 500 , 500 ) : <NEWLINE> <INDENT> if ( i ** 5 ) - ( j ** 5 ) == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_lis = [ 0 ] * ( h + 1 ) <NEWLINE> w_lis = [ 0 ] * ( w + 1 ) <NEWLINE> bombs = set ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] ) <NEWLINE> for hh , ww in bombs : <NEWLINE> <INDENT> h_lis [ hh ] += 1 <NEWLINE> w_lis [ ww ] += 1 <NEWLINE> <DEDENT> max_h = max ( h_lis ) <NEWLINE> max_w = max ( w_lis ) <NEWLINE> h_max_index = [ i for i , h in enumerate ( h_lis ) if h == max_h ] <NEWLINE> w_max_index = [ i for i , w in enumerate ( w_lis ) if w == max_w ] <NEWLINE> for h_i in h_max_index : <NEWLINE> <INDENT> for w_i in w_max_index : <NEWLINE> <INDENT> if not ( h_i , w_i ) in bombs : <NEWLINE> <INDENT> print ( h_lis [ h_i ] + w_lis [ w_i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( h_lis [ h_i ] + w_lis [ w_i ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> X , Y = LI ( ) <NEWLINE> a = 10 ** 18 // X <NEWLINE> if X == Y : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif X % Y == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> if X * i % Y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = X * i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
SENTINEL = 1000000001 <NEWLINE> <NL> def merge ( A , l , m , r ) : <NEWLINE> <INDENT> L = A [ l : m ] + [ SENTINEL ] <NEWLINE> R = A [ m : r ] + [ SENTINEL ] <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> cnt = 0 <NEWLINE> for k in range ( l , r ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += len ( L ) - 1 - i <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def merge_sort ( A , l , r ) : <NEWLINE> <INDENT> if l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> cnt = 0 <NEWLINE> cnt += merge_sort ( A , l , m ) <NEWLINE> cnt += merge_sort ( A , m , r ) <NEWLINE> cnt += merge ( A , l , m , r ) <NEWLINE> return cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( merge_sort ( A , 0 , n ) ) <NEWLINE>
N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> XH = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> XH . sort ( ) <NEWLINE> from math import ceil <NEWLINE> times = ceil ( XH [ 0 ] [ 1 ] / A ) <NEWLINE> ans = times <NEWLINE> damege = [ times * A ] <NEWLINE> coor = [ XH [ 0 ] [ 0 ] + 2 * D ] <NEWLINE> start = 0 <NEWLINE> end = 1 <NEWLINE> dam = sum ( damege [ start : end ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> st = start <NEWLINE> while start < end and coor [ start ] < XH [ i ] [ 0 ] : <NEWLINE> <INDENT> start += 1 <NEWLINE> <DEDENT> dam -= sum ( damege [ st : start ] ) <NEWLINE> H = XH [ i ] [ 1 ] - dam <NEWLINE> if H > 0 : <NEWLINE> <INDENT> times = ceil ( H / A ) <NEWLINE> ans += times <NEWLINE> damege . append ( times * A ) <NEWLINE> dam += times * A <NEWLINE> coor . append ( XH [ i ] [ 0 ] + 2 * D ) <NEWLINE> end += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> Sum = 0 <NEWLINE> def mygcd ( x , y ) : <NEWLINE> <INDENT> a = min ( x , y ) <COMMENT> <NEWLINE> b = max ( x , y ) <COMMENT> <NEWLINE> r = 2 <COMMENT> <NEWLINE> while r != 0 : <NEWLINE> <INDENT> r = b % a <NEWLINE> b = a <NEWLINE> a = r <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> for A in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for B in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> AB = mygcd ( A , B ) <NEWLINE> if AB == 1 : <NEWLINE> <INDENT> Sum = Sum + K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for C in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> Sum = Sum + mygcd ( AB , C ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if p [ i ] - 1 == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> <DEDENT> <DEDENT> if p [ n - 1 ] - 1 == n - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> m = N // i <NEWLINE> ans += m * ( m + 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def tax ( p , x ) : <NEWLINE> <INDENT> return int ( p * ( 100 + x ) / 100 ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x , y , s = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if x == 0 and y == 0 and s == 0 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> maximum = 0 <NEWLINE> p = int ( 100 * s / ( 100 + x ) ) <NEWLINE> for i in range ( 1 , s ) : <NEWLINE> <INDENT> for j in range ( p - i - 3 , p - i + 3 ) : <NEWLINE> <INDENT> if tax ( i , x ) + tax ( j , x ) == s and j > 0 : <NEWLINE> <INDENT> maximum = max ( tax ( i , y ) + tax ( j , y ) , maximum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( maximum ) <NEWLINE> <DEDENT>
import math <NEWLINE> def combination ( p , q ) : <NEWLINE> <INDENT> if q < 0 or p < q : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return math . factorial ( p ) // math . factorial ( q ) // math . factorial ( p - q ) <NEWLINE> <DEDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> c -= a * b <NEWLINE> print ( combination ( c + a - 1 , c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> f = 0 <NEWLINE> i = 0 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> if f == 0 : <NEWLINE> <INDENT> ans = ans * int ( a [ i ] ) <NEWLINE> <DEDENT> if f == 0 and ans > 1000000000000000000 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if int ( a [ i ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> T = [ 0 ] * ( len_s + 1 ) <NEWLINE> T [ - 1 ] , T [ - 2 ] = 0 , int ( s [ - 1 ] ) <NEWLINE> mod = 2019 <NEWLINE> for i in range ( len_s - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> T [ i ] = ( T [ i + 1 ] + int ( s [ i ] ) * pow ( 10 , len_s - i - 1 , mod ) ) % mod <NEWLINE> <DEDENT> tc = list ( Counter ( T ) . values ( ) ) <NEWLINE> ans = 0 <NEWLINE> for tcc in tc : <NEWLINE> <INDENT> ans += tcc * ( tcc - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for _ in <STRING> * k : <NEWLINE> <INDENT> b = [ 0 ] * ( n ) <NEWLINE> <NL> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> if i > v : <NEWLINE> <COMMENT> <NL> <INDENT> b [ i - v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ 0 ] += 1 <NEWLINE> <DEDENT> j = i - ~ v <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if j < n : <NEWLINE> <INDENT> b [ j ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> A = [ * accumulate ( b ) ] <NEWLINE> <NL> if min ( A ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> ans = 0 <NEWLINE> d = min ( n , b ) <NEWLINE> e = b - 1 <NEWLINE> if b > d : <NEWLINE> <INDENT> print ( math . floor ( a * d / b ) - a * math . floor ( d / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * e / b ) - a * math . floor ( e / b ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> d = dict ( ) <NEWLINE> zeros = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if not any ( ( a , b ) ) : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if all ( ( a , b ) ) : <NEWLINE> <INDENT> g = gcd ( a , b ) * ( a // abs ( a ) ) <NEWLINE> <DEDENT> elif a : <NEWLINE> <INDENT> g = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = b <NEWLINE> <NL> <DEDENT> p = a // g , b // g <NEWLINE> d [ p ] = d . get ( p , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> done = set ( ) <NEWLINE> for ( a , b ) , v in d . items ( ) : <NEWLINE> <INDENT> if ( - b , a ) in done or ( b , - a ) in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> done . add ( ( a , b ) ) <NEWLINE> w = d . get ( ( - b , a ) , 0 ) + d . get ( ( b , - a ) , 0 ) <NEWLINE> ans *= ( pow ( 2 , v , mod ) + pow ( 2 , w , mod ) - 1 ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ( ans + zeros - 1 + mod ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> LIM = 10 ** 18 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > LIM : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = 1 <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> k = k * i <NEWLINE> if k > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if k > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans1 = [ 1 ] <NEWLINE> temp = 0 <NEWLINE> visit = [ 0 ] * ( n + 1 ) <NEWLINE> visit [ 1 ] = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> ans1 += [ a [ temp ] ] <NEWLINE> <NL> if visit [ a [ temp ] ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> visit [ a [ temp ] ] = 1 <NEWLINE> temp = a [ temp ] - 1 <NEWLINE> <NL> <NL> if len ( ans1 ) == m + 1 : <NEWLINE> <INDENT> print ( ans1 [ len ( ans1 ) - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> num1 = ans1 . index ( a [ temp ] ) <NEWLINE> ans2 = ans1 [ num1 : len ( ans1 ) - 1 ] <NEWLINE> <NL> num = len ( ans2 ) <NEWLINE> <NL> print ( ans2 [ ( m - num1 ) % num ] ) <NEWLINE>
li = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 1 ] <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if li . index ( a ) == li . index ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif li . index ( a ) > li . index ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for _ in range ( h ) : <NEWLINE> <INDENT> for _ in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> As = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> prod = 1 <NEWLINE> overflow_flag = False <NEWLINE> <NL> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in As : <NEWLINE> <INDENT> prod *= a <NEWLINE> <NL> if prod > 10 ** 18 : <NEWLINE> <INDENT> overflow_flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if overflow_flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) <NEWLINE> write = lambda x : sys . stdout . write ( x + <STRING> ) <NEWLINE> <NL> <NL> from collections import defaultdict <NEWLINE> n , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ns = defaultdict ( list ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> ns [ u - 1 ] . append ( v - 1 ) <NEWLINE> ns [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> bs = { } <NEWLINE> cump0 = defaultdict ( list ) <NEWLINE> cump1 = defaultdict ( list ) <NEWLINE> def sub ( u , p ) : <NEWLINE> <INDENT> if ( p , u ) in bs : <NEWLINE> <INDENT> return bs [ p , u ] <NEWLINE> <DEDENT> b = 1 <NEWLINE> ps = [ ] <NEWLINE> for v in ns [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> bb = sub ( v , u ) <NEWLINE> b *= ( 1 + bb ) <NEWLINE> b %= M <NEWLINE> ps . append ( bb ) <NEWLINE> <DEDENT> v0 = 1 <NEWLINE> v1 = 1 <NEWLINE> l = len ( ps ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> cump0 [ u ] . append ( v0 ) <NEWLINE> cump1 [ u ] . append ( v1 ) <NEWLINE> v0 *= ps [ i ] + 1 <NEWLINE> v1 *= ps [ l - 1 - i ] + 1 <NEWLINE> v0 %= M ; v1 %= M <NEWLINE> <DEDENT> cump0 [ u ] . append ( v0 ) <NEWLINE> cump1 [ u ] . append ( v1 ) <NEWLINE> <NL> bs [ p , u ] = b % M <NEWLINE> return b <NEWLINE> <NL> <DEDENT> ans = [ None ] * n <NEWLINE> def sub2 ( u , p ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for v in ns [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b1 = bs [ p , u ] <NEWLINE> b2 = bs [ u , v ] <NEWLINE> b3 = bs [ u , p ] <NEWLINE> if p >= 0 : <NEWLINE> <INDENT> bb = ( cump0 [ u ] [ i ] * cump1 [ u ] [ - ( i + 2 ) ] * ( 1 + b3 ) ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb = ( cump0 [ u ] [ i ] * cump1 [ u ] [ - ( i + 2 ) ] ) % M <NEWLINE> <DEDENT> bs [ v , u ] = bb <NEWLINE> ans [ v ] = bs [ u , v ] * ( 1 + bb ) % M <NEWLINE> sub2 ( v , u ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sub ( 0 , - 1 ) <NEWLINE> bs [ 0 , - 1 ] = 1 <NEWLINE> ans [ 0 ] = bs [ - 1 , 0 ] <NEWLINE> sub2 ( 0 , - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> write ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> core = [ ] <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if c != <STRING> : <NEWLINE> <INDENT> core . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if core == [ ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = len ( core ) - 1 <NEWLINE> <NL> while l <= r : <NEWLINE> <INDENT> if core [ l ] != core [ r ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> <NL> while l <= r : <NEWLINE> <INDENT> lx = 0 <NEWLINE> rx = 0 <NEWLINE> while s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> lx += 1 <NEWLINE> <DEDENT> while s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> rx += 1 <NEWLINE> <DEDENT> ans += abs ( lx - rx ) <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dp = [ [ float ( <STRING> ) for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> <NL> def bfs ( x , y ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> que . append ( ( x , y ) ) <NEWLINE> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> dp [ y ] [ x ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ y ] [ x ] = 1 <NEWLINE> <DEDENT> while que . __len__ ( ) : <NEWLINE> <INDENT> x , y = que . popleft ( ) <NEWLINE> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) ) : <NEWLINE> <INDENT> sx = x + dx <NEWLINE> sy = y + dy <NEWLINE> if sx == W or sy == H : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ y ] [ x ] == <STRING> and S [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> dp [ sy ] [ sx ] = min ( dp [ y ] [ x ] + tmp , dp [ sy ] [ sx ] ) <NEWLINE> if ( sx , sy ) not in que : <NEWLINE> <INDENT> que . append ( ( sx , sy ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( 0 , 0 ) <NEWLINE> print ( dp [ H - 1 ] [ W - 1 ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> from collections import deque <NEWLINE> <NL> room_num , path_num = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> graph = [ [ ] for _ in range ( room_num ) ] <NEWLINE> dis = [ - 1 ] * room_num <NEWLINE> count = [ 0 ] * room_num <NEWLINE> count [ 0 ] = 1 <NEWLINE> for _ in range ( path_num ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> dis [ 0 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> while q : <NEWLINE> <INDENT> pop = q . popleft ( ) <NEWLINE> for n in graph [ pop ] : <NEWLINE> <INDENT> if count [ n ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ n ] = 1 <NEWLINE> dis [ n ] = pop + 1 <NEWLINE> q . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if sum ( dis ) == room_num : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del dis [ 0 ] <NEWLINE> print ( <STRING> ) <NEWLINE> for s in dis : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> X = self . find ( x ) <NEWLINE> Y = self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> if X == Y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if self . parents [ X ] > self . parents [ Y ] : <NEWLINE> <INDENT> X , Y = Y , X <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> self . parents [ X ] += self . parents [ Y ] <NEWLINE> <COMMENT> <NL> self . parents [ Y ] = X <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> info = [ tuple ( map ( int , s . split ( ) ) ) for s in sys . stdin . readlines ( ) ] <NEWLINE> <NL> <COMMENT> <NL> uf = UnionFind ( N ) <NEWLINE> for a , b in info : <NEWLINE> <COMMENT> <NL> <INDENT> a -= 1 ; b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = min ( uf . parents ) <NEWLINE> <NL> print ( - ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> total = 0 <NEWLINE> sum_sqr = 0 <NEWLINE> sqr_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_sqr = ( sum_sqr + a [ i ] ) <NEWLINE> <DEDENT> sum_sqr = ( sum_sqr * sum_sqr ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sqr_sum = ( sqr_sum + ( ( a [ i ] * a [ i ] ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> total = ( sum_sqr - sqr_sum ) // 2 <NEWLINE> print ( total % mod ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> <NL> def dfs ( remains , elapsed , hx , hy , prev ) : <NEWLINE> <INDENT> global crystals , dc <NEWLINE> <NL> if not remains : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> remains_c = set ( ) <NEWLINE> for i in remains : <NEWLINE> <INDENT> cx , cy , dfd = crystals [ i ] <NEWLINE> new_elapsed = elapsed + dc [ prev ] [ i ] <NEWLINE> if dfd <= new_elapsed : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> remains_c . add ( ( i , cx , cy , new_elapsed ) ) <NEWLINE> <NL> <DEDENT> for i , cx , cy , new_elapsed in remains_c : <NEWLINE> <INDENT> remains . remove ( i ) <NEWLINE> if dfs ( remains , new_elapsed , cx , cy , i ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> remains . add ( i ) <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , hx , hy , dx , dy = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> crystals_in = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> crystals = [ ( cx , cy , sqrt ( ( cx - dx ) ** 2 + ( cy - dy ) ** 2 ) ) for cx , cy in crystals_in ] <NEWLINE> crystals_in += [ ( hx , hy ) ] <NEWLINE> dc = [ [ sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) for x2 , y2 in crystals_in ] for x1 , y1 in crystals_in ] <NEWLINE> <NL> print ( <STRING> if dfs ( set ( range ( n ) ) , 0 , hx , hy , n ) else <STRING> ) <NEWLINE> <DEDENT>
from itertools import * <NEWLINE> * x , = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> c = combinations_with_replacement ( range ( 3 ) , K ) <NEWLINE> a = x . copy ( ) <NEWLINE> ans = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> a = x . copy ( ) <NEWLINE> for j in i : <NEWLINE> <INDENT> a [ j ] = a [ j ] * 2 <NEWLINE> if a [ 0 ] < a [ 1 ] and a [ 1 ] < a [ 2 ] : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import OrderedDict <NEWLINE> <NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> res = [ ] <NEWLINE> <NL> if K > B - A : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> res_unique = list ( set ( res ) ) <NEWLINE> res_unique . sort ( ) <NEWLINE> <NL> for i in res_unique : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> med_idx = int ( n / 2 ) <NEWLINE> print ( d [ med_idx ] - d [ med_idx - 1 ] ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> xy . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> rxy = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rxy . append ( ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] , xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> cr = collections . Counter ( rxy ) <NEWLINE> print ( N - max ( cr . values ( ) ) ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> a [ k ] //= 2 <NEWLINE> <NL> <DEDENT> foo = 1 <NEWLINE> while a [ 0 ] % 2 == 0 : <NEWLINE> <INDENT> foo *= 2 <NEWLINE> a [ 0 ] //= 2 <NEWLINE> <DEDENT> for k in range ( 1 , N ) : <NEWLINE> <INDENT> if a [ k ] % foo == 0 and a [ k ] % ( 2 * foo ) != 0 : <NEWLINE> <INDENT> a [ k ] //= foo <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> import math <NEWLINE> lcm = a . pop ( ) <NEWLINE> for k in range ( 1 , N ) : <NEWLINE> <INDENT> b = a . pop ( ) <NEWLINE> lcm = lcm * b // math . gcd ( lcm , b ) <NEWLINE> if lcm * foo > M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> lcm *= foo <NEWLINE> ans = int ( ( M / lcm - 1 ) // 2 + 1 ) <NEWLINE> print ( ans ) <NEWLINE>
from copy import copy , deepcopy <NEWLINE> from collections import Counter <NEWLINE> from math import sqrt , floor , factorial <NEWLINE> from itertools import permutations , combinations , combinations_with_replacement <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> import bisect <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ A [ i ] - 1 for i in range ( len ( A ) ) ] <NEWLINE> <NL> mem = [ 0 ] * N <NEWLINE> mem2 = [ 0 ] * N <NEWLINE> <NL> idx = 0 <NEWLINE> count1 = 0 <NEWLINE> while True : <NEWLINE> <INDENT> mem [ idx ] += 1 <NEWLINE> if mem [ idx ] == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count1 += 1 <NEWLINE> idx = A [ idx ] <NEWLINE> <NL> <NL> <DEDENT> idx2 = idx <NEWLINE> count2 = 0 <NEWLINE> <NL> count2 += 1 <NEWLINE> idx2 = A [ idx2 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if idx2 == idx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count2 += 1 <NEWLINE> idx2 = A [ idx2 ] <NEWLINE> <NL> <DEDENT> tmp = count1 - count2 <NEWLINE> <NL> if tmp >= K : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> e = ( K - tmp ) % count2 + tmp <NEWLINE> ans = 0 <NEWLINE> for _ in range ( e ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ 0 ] * N <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] = [ 0 ] * 3 <NEWLINE> p [ i ] [ 0 ] = [ ] <NEWLINE> p [ i ] [ 1 ] = [ ] <NEWLINE> p [ i ] [ 2 ] = - 1 <NEWLINE> <DEDENT> g = [ ] <COMMENT> <NEWLINE> stack = [ ] <NEWLINE> groupNum = 0 <NEWLINE> fcs = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p [ a - 1 ] [ 0 ] . append ( b - 1 ) <NEWLINE> p [ b - 1 ] [ 0 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def groupmake ( person , group ) : <NEWLINE> <INDENT> groupSize = 0 <NEWLINE> stack . append ( person ) <NEWLINE> p [ person ] [ 2 ] = group <NEWLINE> while True : <NEWLINE> <INDENT> num = stack . pop ( ) <NEWLINE> groupSize += 1 <NEWLINE> for i in p [ num ] [ 0 ] : <NEWLINE> <INDENT> if p [ i ] [ 2 ] == - 1 : <NEWLINE> <INDENT> stack . append ( i ) <NEWLINE> p [ i ] [ 2 ] = group <NEWLINE> <DEDENT> <DEDENT> if len ( stack ) == 0 : <NEWLINE> <INDENT> return groupSize <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] [ 2 ] == - 1 : <NEWLINE> <INDENT> g . append ( groupmake ( i , groupNum ) ) <NEWLINE> groupNum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for person in p : <NEWLINE> <INDENT> fcs . append ( g [ person [ 2 ] ] - len ( person [ 0 ] ) - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if p [ c - 1 ] [ 2 ] == p [ d - 1 ] [ 2 ] : <NEWLINE> <INDENT> fcs [ c - 1 ] -= 1 <NEWLINE> fcs [ d - 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , fcs ) ) ) <NEWLINE>
ROLL_MASTER = ( <NEWLINE> <INDENT> ( 0 , 1 , 2 , 3 , 4 , 5 ) , ( 1 , 0 , 3 , 2 , 5 , 4 ) , ( 2 , 0 , 1 , 4 , 5 , 3 ) , <NEWLINE> ( 3 , 0 , 4 , 1 , 5 , 2 ) , ( 4 , 0 , 2 , 3 , 5 , 1 ) , ( 5 , 1 , 3 , 2 , 4 , 0 ) ) <NEWLINE> <DEDENT> TWIST_MASTER = ( 0 , 2 , 4 , 1 , 3 , 5 ) <NEWLINE> <NL> <NL> def roll ( dice , top ) : <NEWLINE> <INDENT> return tuple ( dice [ i ] for i in ROLL_MASTER [ top ] ) <NEWLINE> <NL> <NL> <DEDENT> def twist ( dice ) : <NEWLINE> <INDENT> return tuple ( dice [ i ] for i in TWIST_MASTER ) <NEWLINE> <NL> <NL> <DEDENT> def twist_check ( d1 , d2 ) : <NEWLINE> <INDENT> if d1 [ 0 ] != d2 [ 0 ] or d1 [ 5 ] != d2 [ 5 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> if d1 == d2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> d2 = twist ( d2 ) <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def equal_check ( d1 , d2 ) : <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> <INDENT> if twist_check ( d1 , roll ( d2 , i ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def differs_all ( ) : <NEWLINE> <INDENT> n , d1 , dset = int ( input ( ) ) , tuple ( map ( int , input ( ) . split ( ) ) ) , set ( ) <NEWLINE> dset . add ( d1 ) <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> d2 = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d1 in dset : <NEWLINE> <INDENT> if equal_check ( d1 , d2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> dset . add ( d2 ) <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> if differs_all ( ) else <STRING> ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n_P = [ ] <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> n_P . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n_P . append ( 0 ) <NEWLINE> n_P . append ( 101 ) <NEWLINE> <NL> n_P . sort ( ) <NEWLINE> INF = 10 ** 9 <NEWLINE> diff = INF <NEWLINE> ans = INF <NEWLINE> <NL> for p in n_P : <NEWLINE> <INDENT> if abs ( X - p ) < diff : <NEWLINE> <INDENT> diff = abs ( X - p ) <NEWLINE> ans = p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def searchstar ( i , j ) : <NEWLINE> <INDENT> global vector <NEWLINE> global star <NEWLINE> global n <NEWLINE> flag = False <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if star [ i ] [ 0 ] + vector [ j ] [ 0 ] == star [ k ] [ 0 ] and star [ i ] [ 1 ] + vector [ j ] [ 1 ] == star [ k ] [ 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> <NL> vector = [ ] <NEWLINE> <NL> x1 , y1 = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> vector . append ( [ x2 - x1 , y2 - y1 ] ) <NEWLINE> <NL> <DEDENT> star = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> star . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( m - 1 ) : <NEWLINE> <INDENT> if not searchstar ( i , j ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( star [ i ] [ 0 ] - x1 , star [ i ] [ 1 ] - y1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> list . reverse ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( str ( list [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( str ( list [ n - 1 ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def t ( S ) : <NEWLINE> <NL> <INDENT> N = len ( S ) <NEWLINE> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> d = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a [ i + 1 ] += a [ i ] <NEWLINE> d [ i + 1 ] += d [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> S = in_s ( ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> ans = 0 <NEWLINE> for ts in S . split ( ) : <NEWLINE> <INDENT> ans += t ( ts ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> last = 9 <NEWLINE> time = 0 <NEWLINE> cou = 0 <NEWLINE> check = 0 <NEWLINE> <COMMENT> <NL> l = [ A , B , C , D , E ] <NEWLINE> for i in l : <NEWLINE> <INDENT> if i % 10 != 0 : <NEWLINE> <INDENT> if last % 10 >= i % 10 : <NEWLINE> <INDENT> last = i <NEWLINE> check += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if check != 0 : <NEWLINE> <INDENT> l . remove ( last ) <NEWLINE> l . append ( last ) <NEWLINE> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> time += l [ i ] <NEWLINE> if i == 4 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while time % 10 != 0 : <NEWLINE> <INDENT> time += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( time ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = [ ] <NEWLINE> if n >= m or m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n < m : <NEWLINE> <INDENT> for i in range ( m - 1 ) : <NEWLINE> <INDENT> d . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <DEDENT> print ( sum ( sorted ( d ) [ : m - n ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self , init_field ) : <NEWLINE> <INDENT> self . root = init_field <NEWLINE> <NL> <DEDENT> def search ( self , field_id , field ) : <NEWLINE> <INDENT> global final_queen_pos <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> q_r = rest_row [ field_id - n ] <NEWLINE> if final_queen_pos : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for q_c , cell in enumerate ( field . state [ q_r ] ) : <NEWLINE> <INDENT> if cell == 0 : <NEWLINE> <INDENT> if final_queen_pos : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if field_id == 7 : <NEWLINE> <INDENT> field . queen_pos . append ( [ q_r , q_c ] ) <NEWLINE> final_queen_pos = field . queen_pos <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_field = Field ( field_id + 1 , field ) <NEWLINE> field . children . append ( next_field ) <NEWLINE> next_field . update ( q_r , q_c ) <NEWLINE> self . search ( field_id + 1 , next_field ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class Field ( ) : <NEWLINE> <INDENT> def __init__ ( self , field_id , parent = None ) : <NEWLINE> <INDENT> self . id = field_id <NEWLINE> self . parent = parent <NEWLINE> self . children = [ ] <NEWLINE> <NL> if field_id == 0 : <NEWLINE> <INDENT> self . state = [ [ 0 for _ in range ( W ) ] for H in range ( H ) ] <NEWLINE> self . queen_pos = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . state = [ ] <NEWLINE> self . queen_pos = [ ] <NEWLINE> for row in self . parent . state : <NEWLINE> <INDENT> x = row . copy ( ) <NEWLINE> self . state . append ( x ) <NEWLINE> <DEDENT> for parent_queen_pos in self . parent . queen_pos : <NEWLINE> <INDENT> self . queen_pos . append ( parent_queen_pos ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def update ( self , q_r , q_c ) : <NEWLINE> <INDENT> self . queen_pos . append ( [ q_r , q_c ] ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> self . state [ q_r ] [ i ] = 1 <NEWLINE> self . state [ i ] [ q_c ] = 1 <NEWLINE> <DEDENT> summ = q_c + q_r <NEWLINE> diff = q_c - q_r <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if ( 0 <= i + diff < 8 ) : <NEWLINE> <INDENT> self . state [ i ] [ i + diff ] = 1 <NEWLINE> <DEDENT> if ( 0 <= summ - i < 8 ) : <NEWLINE> <INDENT> self . state [ i ] [ summ - i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def print_field ( self ) : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> , self . queen_pos ) <NEWLINE> for row in self . state : <NEWLINE> <INDENT> print ( * row ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> H , W = 8 , 8 <NEWLINE> n = int ( input ( ) ) <NEWLINE> init_field = Field ( 0 ) <NEWLINE> tree = Tree ( init_field ) <NEWLINE> field_list = [ init_field ] <NEWLINE> rest_row = [ i for i in range ( 8 ) ] <NEWLINE> queen_pos = [ ] <NEWLINE> final_queen_pos = None <NEWLINE> final_result = [ [ <STRING> for _ in range ( 8 ) ] for _ in range ( 8 ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> queen_pos . append ( [ r , c ] ) <NEWLINE> rest_row . remove ( r ) <NEWLINE> <NL> <DEDENT> if n < 8 : <NEWLINE> <INDENT> i = 0 <NEWLINE> prev_field = init_field <NEWLINE> for q_r , q_c in queen_pos : <NEWLINE> <INDENT> i += 1 <NEWLINE> field = Field ( i , prev_field ) <NEWLINE> field . update ( q_r , q_c ) <NEWLINE> field_list . append ( field ) <NEWLINE> prev_field . children = [ field ] <NEWLINE> prev_field = field <NEWLINE> <NL> <DEDENT> tree . search ( i , field ) <NEWLINE> <NL> for q_r , q_c in final_queen_pos : <NEWLINE> <INDENT> final_result [ q_r ] [ q_c ] = <STRING> <NEWLINE> <NL> <DEDENT> for row in final_result : <NEWLINE> <INDENT> print ( <STRING> . join ( row ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for q_r , q_c in queen_pos : <NEWLINE> <INDENT> final_result [ q_r ] [ q_c ] = <STRING> <NEWLINE> <NL> <DEDENT> for row in final_result : <NEWLINE> <INDENT> print ( <STRING> . join ( row ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
inp = input ( ) <NEWLINE> inp = inp . split ( ) <NEWLINE> N = int ( inp [ 0 ] ) <NEWLINE> M = int ( inp [ 1 ] ) <NEWLINE> BigM = N + 2 <NEWLINE> <NL> E = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> abinp = input ( ) <NEWLINE> abinp = abinp . split ( ) <NEWLINE> a = int ( abinp [ 0 ] ) <NEWLINE> b = int ( abinp [ 1 ] ) <NEWLINE> E . append ( [ a , b ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Edict = [ [ ] for n in range ( N + 1 ) ] <NEWLINE> for e in E : <NEWLINE> <INDENT> Edict [ e [ 0 ] ] . append ( e [ 1 ] ) <NEWLINE> Edict [ e [ 1 ] ] . append ( e [ 0 ] ) <NEWLINE> <NL> <DEDENT> output = [ 0 ] + [ 0 ] + [ BigM ] * ( N - 1 ) <NEWLINE> prev = [ 0 for n in range ( N + 1 ) ] <NEWLINE> prev_cnt = 0 <NEWLINE> now = [ 1 ] <NEWLINE> <NL> prev [ 1 ] = 1 <NEWLINE> while len ( now ) > 0 : <NEWLINE> <INDENT> n = now . pop ( 0 ) <NEWLINE> prev_cnt += 1 <NEWLINE> for next in Edict [ n ] : <NEWLINE> <INDENT> if prev [ next ] == 0 : <NEWLINE> <INDENT> output [ next ] = n <NEWLINE> now . append ( next ) <NEWLINE> prev [ next ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if prev_cnt == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for n in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( output [ n ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
o = list ( input ( ) ) <NEWLINE> e = list ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> if len ( o ) != len ( e ) : <NEWLINE> <INDENT> e += [ <STRING> ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( o ) ) : <NEWLINE> <INDENT> ans += [ o [ i ] , e [ i ] ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> <NL> dp = { 0 : 1 , 1 : 1 } <NEWLINE> def fibonacci ( n ) : <NEWLINE> <INDENT> if not n in dp : <NEWLINE> <INDENT> dp [ n ] = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) <NEWLINE> <DEDENT> return dp [ n ] <NEWLINE> <NL> <DEDENT> print ( fibonacci ( num ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> if <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = 1 ) <NEWLINE> <NL> ans = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a [ i ] > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> x = x2 - x1 <NEWLINE> y = y2 - y1 <NEWLINE> <NL> result = x ** 2 + y ** 2 <NEWLINE> print ( math . sqrt ( result ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> l = ai + i + 1 <NEWLINE> if l in d : <NEWLINE> <INDENT> d [ l ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ l ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> p = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> r = i + 1 - ai <NEWLINE> p += d . get ( r , 0 ) <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = sum ( ( N - 1 ) // i for i in range ( 1 , N ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> r , s , p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> dic = { <STRING> : s , <STRING> : r , <STRING> : p } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += dic [ t [ i ] ] <NEWLINE> <DEDENT> dic_ls = [ ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if t [ i ] != t [ i - k ] : <NEWLINE> <INDENT> ans += dic [ t [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> aa = [ a [ i ] * a [ i ] for i in range ( n ) ] <NEWLINE> s2 = sum ( aa ) <NEWLINE> <NL> print ( ( s ** 2 - s2 ) // 2 % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b_sum = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b_sum += B [ i ] <NEWLINE> if b_sum > K : <NEWLINE> <INDENT> b_sum -= B [ i ] <NEWLINE> j = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j = M - 1 <NEWLINE> <DEDENT> result = j + 1 <NEWLINE> <NL> a_sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_sum += A [ i ] <NEWLINE> if a_sum > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a_sum + b_sum > K : <NEWLINE> <INDENT> b_sum -= B [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> result = max ( result , ( i + 1 ) + ( j + 1 ) ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> m = r ** 2 * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> print ( <STRING> . format ( m , l ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> <NL> c = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> q = [ 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> p = m [ p ] <NEWLINE> if ( c [ p ] == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c [ p ] += 1 <NEWLINE> q . append ( p ) <NEWLINE> <DEDENT> i = q . index ( p ) <NEWLINE> q1 = q [ : i ] <NEWLINE> q2 = q [ i : ] <NEWLINE> if len ( q1 ) > 0 and k < len ( q1 ) : <NEWLINE> <INDENT> print ( q1 [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q2 [ ( k - len ( q ) ) % len ( q2 ) ] ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ac = list ( accumulate ( A ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * ( Ac [ - 1 ] - Ac [ i ] ) <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X > K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = X // D <NEWLINE> X -= s * D <NEWLINE> K -= s <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> for tmp in links [ x ] : <NEWLINE> <INDENT> if c [ tmp [ 0 ] ] < 0 : <NEWLINE> <INDENT> if tmp [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> c [ tmp [ 0 ] ] = c [ x ] + 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ tmp [ 0 ] ] = 1 - c [ x ] <NEWLINE> <DEDENT> f ( tmp [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> links [ u ] . append ( [ v , w ] ) <NEWLINE> links [ v ] . append ( [ u , w ] ) <NEWLINE> <NL> <DEDENT> c = [ - 1 ] * ( N + 1 ) <NEWLINE> c [ 1 ] = 0 <NEWLINE> f ( 1 ) <NEWLINE> <NL> print ( * c [ 1 : ] , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> X , n = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> p = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> nai = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( - 200 , 301 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> nai . append ( i ) <NEWLINE> <DEDENT> <DEDENT> nai . append ( X ) <NEWLINE> nai . sort ( ) <NEWLINE> <NL> ind = nai . index ( X ) <NEWLINE> <NL> if abs ( nai [ ind - 1 ] - X ) <= abs ( nai [ ind + 1 ] - X ) : <NEWLINE> <INDENT> print ( nai [ ind - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nai [ ind + 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
__author__ = <STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> class Graph : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . vertices = 0 <NEWLINE> self . outgoing = { } <NEWLINE> self . root_cnt = 0 <NEWLINE> <COMMENT> <NL> self . result = set ( ) <NEWLINE> <NL> <DEDENT> def insert_vertice ( self ) : <NEWLINE> <INDENT> self . vertices += 1 <NEWLINE> self . outgoing [ self . vertices - 1 ] = [ ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def insert_edge ( self , s , d ) : <NEWLINE> <INDENT> if s >= self . vertices or d >= self . vertices : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . outgoing [ s ] . append ( d ) <NEWLINE> self . outgoing [ d ] . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_input ( self ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> V , E = int ( s . split ( ) [ 0 ] ) , int ( s . split ( ) [ 1 ] ) <NEWLINE> self . discovery = [ None for i in range ( V ) ] <NEWLINE> self . clock = 0 <NEWLINE> self . explored = [ False for i in range ( V ) ] <NEWLINE> self . father = [ None for i in range ( V ) ] <NEWLINE> self . backing = [ None for i in range ( V ) ] <NEWLINE> self . sub_have_backing = [ None for i in range ( V ) ] <NEWLINE> self . is_leaf = [ None for i in range ( V ) ] <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> self . insert_vertice ( ) <NEWLINE> <DEDENT> for i in range ( E ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> self . insert_edge ( int ( s . split ( ) [ 0 ] ) , int ( s . split ( ) [ 1 ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def read_input ( self , filename ) : <NEWLINE> <INDENT> f = open ( filename , <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for line in f : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> V , E = int ( line . split ( ) [ 0 ] ) , int ( line . split ( ) [ 1 ] ) <NEWLINE> <NL> self . discovery = [ None for i in range ( V ) ] <NEWLINE> self . clock = 0 <NEWLINE> self . explored = [ False for i in range ( V ) ] <NEWLINE> self . father = [ None for i in range ( V ) ] <NEWLINE> self . backing = [ None for i in range ( V ) ] <NEWLINE> self . sub_have_backing = [ False for i in range ( V ) ] <NEWLINE> self . is_leaf = [ None for i in range ( V ) ] <NEWLINE> <NL> for i in range ( V ) : <NEWLINE> <INDENT> self . insert_vertice ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . insert_edge ( int ( line . split ( ) [ 0 ] ) , int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def DFS ( self , root ) : <NEWLINE> <INDENT> self . explored [ root ] = True <NEWLINE> self . discovery [ root ] = self . clock <NEWLINE> self . backing [ root ] = self . clock <NEWLINE> self . clock += 1 <NEWLINE> self . is_leaf [ root ] = True <NEWLINE> for ver in self . outgoing [ root ] : <NEWLINE> <INDENT> if not self . explored [ ver ] : <NEWLINE> <INDENT> self . is_leaf [ root ] = False <NEWLINE> self . DFS ( ver ) <NEWLINE> self . backing [ root ] = min ( self . backing [ root ] , self . backing [ ver ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . backing [ root ] = min ( self . backing [ root ] , self . discovery [ ver ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def _critical_points ( self , root ) : <NEWLINE> <INDENT> self . explored [ root ] = True <NEWLINE> self . discovery [ root ] = self . clock <NEWLINE> self . clock += 1 <NEWLINE> for ver in self . outgoing [ root ] : <NEWLINE> <INDENT> if not self . explored [ ver ] : <NEWLINE> <INDENT> if root == 0 : <NEWLINE> <INDENT> self . root_cnt += 1 <NEWLINE> <DEDENT> if self . backing [ ver ] >= self . discovery [ root ] and root != 0 and not self . is_leaf [ root ] : <NEWLINE> <INDENT> self . result . add ( root ) <NEWLINE> <DEDENT> self . _critical_points ( ver ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> g = Graph ( ) <NEWLINE> g . get_input ( ) <NEWLINE> <COMMENT> <NL> g . DFS ( 0 ) <NEWLINE> g . clock = 0 <NEWLINE> g . discovery = [ None for i in range ( g . vertices ) ] <NEWLINE> g . explored = [ False for i in range ( g . vertices ) ] <NEWLINE> g . _critical_points ( 0 ) <NEWLINE> if g . root_cnt >= 2 : <NEWLINE> <INDENT> g . result . add ( 0 ) <NEWLINE> <DEDENT> l = sorted ( g . result ) <NEWLINE> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> k = i + a <NEWLINE> if k not in L : <NEWLINE> <INDENT> L [ k ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ k ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for j , a in enumerate ( A ) : <NEWLINE> <INDENT> k = j - a <NEWLINE> if k in L : <NEWLINE> <INDENT> count += L [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> t [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = list ( range ( - 1 , 102 ) ) <NEWLINE> s = [ ] <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> l . remove ( i ) <NEWLINE> <NL> <DEDENT> for j in l : <NEWLINE> <INDENT> s . append ( abs ( X - j ) ) <NEWLINE> <NL> <DEDENT> ans = min ( s ) <NEWLINE> <NL> if l . count ( X + ans ) == 1 and l . count ( X - ans ) == 1 : <NEWLINE> <INDENT> print ( X - ans ) <NEWLINE> <NL> <DEDENT> elif l . count ( X + ans ) == 1 and l . count ( X - ans ) != 1 : <NEWLINE> <INDENT> print ( X + ans ) <NEWLINE> <NL> <DEDENT> elif l . count ( X + ans ) != 1 and l . count ( X - ans ) == 1 : <NEWLINE> <INDENT> print ( X - ans ) <NEWLINE> <NL> <DEDENT>
<NL> def resolve ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> return print ( - 1 ) <NEWLINE> <NL> <DEDENT> seven = 7 <NEWLINE> for i in range ( 1 , K + 10 ) : <NEWLINE> <INDENT> if seven % K == 0 : <NEWLINE> <INDENT> return print ( i ) <NEWLINE> <DEDENT> seven = ( seven * 10 + 7 ) % K <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 0 ] * n <COMMENT> <NEWLINE> for __ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if s [ a - 1 ] >= s [ b - 1 ] : <NEWLINE> <INDENT> t [ b - 1 ] += 1 <NEWLINE> <DEDENT> if s [ a - 1 ] <= s [ b - 1 ] : <NEWLINE> <INDENT> t [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t . count ( 0 ) ) <NEWLINE>
l = input ( ) . split ( ) <NEWLINE> l = list ( map ( int , l ) ) <NEWLINE> <NL> if l [ 0 ] < l [ 1 ] and l [ 1 ] < l [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ProNum = int ( input ( ) ) <NEWLINE> time = input ( ) <NEWLINE> time = ( time . split ( ) ) <NEWLINE> TotalTime = 0 <NEWLINE> <NL> for t in time : <NEWLINE> <INDENT> TotalTime += int ( t ) <NEWLINE> <NL> <DEDENT> DrinkNum = int ( input ( ) ) <NEWLINE> <NL> for d in range ( DrinkNum ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> line = line . split ( ) <NEWLINE> diff = int ( line [ 1 ] ) - int ( time [ int ( line [ 0 ] ) - 1 ] ) <NEWLINE> print ( TotalTime + diff ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , bisect <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappush , heappop <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path , floyd_warshall , dijkstra , bellman_ford , johnson <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> N , C = na ( ) <NEWLINE> D = [ na ( ) for _ in range ( C ) ] <NEWLINE> c = [ na ( ) for _ in range ( N ) ] <NEWLINE> <NL> z = { } <NEWLINE> o = { } <NEWLINE> t = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> q = ( i + j ) % 3 <NEWLINE> now = c [ i - 1 ] [ j - 1 ] - 1 <NEWLINE> if q == 0 : <NEWLINE> <INDENT> if now not in z . keys ( ) : <NEWLINE> <INDENT> z [ now ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z [ now ] += 1 <NEWLINE> <DEDENT> <DEDENT> if q == 1 : <NEWLINE> <INDENT> if now not in o . keys ( ) : <NEWLINE> <INDENT> o [ now ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o [ now ] += 1 <NEWLINE> <DEDENT> <DEDENT> if q == 2 : <NEWLINE> <INDENT> if now not in t . keys ( ) : <NEWLINE> <INDENT> t [ now ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ now ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = inf <NEWLINE> for i , j , l in itertools . permutations ( range ( C ) , 3 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k , v in z . items ( ) : <NEWLINE> <INDENT> tmp += v * D [ k ] [ i ] <NEWLINE> <DEDENT> for k , v in o . items ( ) : <NEWLINE> <INDENT> tmp += v * D [ k ] [ j ] <NEWLINE> <DEDENT> for k , v in t . items ( ) : <NEWLINE> <INDENT> tmp += v * D [ k ] [ l ] <NEWLINE> <DEDENT> ans = min ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> * I , = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N , A , B , C = map ( int , I [ : 4 ] ) <NEWLINE> S = I [ 4 : ] <NEWLINE> <NL> Cnt = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> <NL> ans = [ <STRING> ] * N <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> for L , R in ( S [ i ] , reversed ( S [ i ] ) ) : <NEWLINE> <INDENT> if Cnt [ R ] > 0 : <NEWLINE> <INDENT> Cnt [ L ] += 1 <NEWLINE> Cnt [ R ] -= 1 <NEWLINE> <NL> ans [ i ] = L <NEWLINE> dfs ( i + 1 ) <NEWLINE> <NL> Cnt [ L ] -= 1 <NEWLINE> Cnt [ R ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE>
from math import sqrt <NEWLINE> I_list = [ ] <NEWLINE> prime_list = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> I_list . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> I_max = max ( I_list ) <NEWLINE> search_set = { x for x in range ( 2 , I_max + 1 ) } <NEWLINE> <NL> <NL> p = - 1 <NEWLINE> while p <= sqrt ( I_max ) : <NEWLINE> <INDENT> p = min ( search_set ) <NEWLINE> prime_list . append ( p ) <NEWLINE> search_set = { x for x in search_set if x % p != 0 } <NEWLINE> <NL> <DEDENT> search_list = sorted ( list ( search_set ) ) <NEWLINE> prime_list += search_list <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> for i in I_list : <NEWLINE> <INDENT> lower_set = { j for j in prime_list if j <= i } <NEWLINE> <COMMENT> <NL> print ( len ( lower_set ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) + 1 <NEWLINE> <NL> a = [ - 1 ] * n <NEWLINE> tmp = 0 <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a [ 0 ] = 0 <NEWLINE> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a [ - 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> i = i * ( - 1 ) - 1 <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i - 1 ] = max ( tmp , a [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> def calc ( arr ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if arr [ b - 1 ] - arr [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def dfs ( arr , i ) : <NEWLINE> <INDENT> global ans <NEWLINE> if len ( arr ) == n : <NEWLINE> <INDENT> ans = max ( ans , calc ( arr ) ) <NEWLINE> return <NEWLINE> <DEDENT> for j in range ( i , m + 1 ) : <NEWLINE> <INDENT> arr . append ( j ) <NEWLINE> dfs ( arr , j ) <NEWLINE> arr . pop ( ) <NEWLINE> <DEDENT> <DEDENT> dfs ( [ ] , 1 ) <NEWLINE> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for k in range ( K , n + 2 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += n * k - k ** 2 + k + 1 <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * P , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mi = P [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < mi : mi = P [ i ] <NEWLINE> if P [ i ] <= mi : cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> tmp = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = str ( i ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sum ( list ( map ( int , str ( n ) ) ) ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n , x , m = map ( int , args [ 0 ] . split ( ) ) <NEWLINE> <NL> a = x <NEWLINE> ret = 0 <NEWLINE> D = [ - 1 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if 0 <= D [ a ] : <NEWLINE> <INDENT> j = a <NEWLINE> L = [ ] <NEWLINE> while D [ j ] != a : <NEWLINE> <INDENT> L . append ( j ) <NEWLINE> j = D [ j ] <NEWLINE> <DEDENT> L . append ( j ) <NEWLINE> d , r = divmod ( n - i - 1 , len ( L ) ) <NEWLINE> ret += d * sum ( L ) + sum ( L [ : r + 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> ret += a <NEWLINE> p = a <NEWLINE> a = pow ( a , 2 , m ) <NEWLINE> D [ p ] = a <NEWLINE> <NL> <DEDENT> return str ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> X , N = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ps = input ( ) <NEWLINE> if len ( ps ) != 0 : <NEWLINE> <INDENT> ps = list ( map ( int , ps . split ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> ps_sort = list ( sorted ( ps ) ) <NEWLINE> not_in_ps = np . array ( [ [ abs ( i - X ) , i ] for i in range ( - 1 , 102 ) if i not in ps_sort ] ) <NEWLINE> print ( not_in_ps [ np . argmin ( not_in_ps [ : , 0 ] , 0 ) , 1 ] ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K >= A : <NEWLINE> <INDENT> ans += A <NEWLINE> K -= A <NEWLINE> A = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = K * 1 <NEWLINE> K = 0 <NEWLINE> <DEDENT> if K >= B : <NEWLINE> <INDENT> K -= B <NEWLINE> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = 0 <NEWLINE> <DEDENT> if K >= C : <NEWLINE> <INDENT> ans -= C <NEWLINE> K -= C <NEWLINE> C = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + K * ( - 1 ) <NEWLINE> C = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> l = list ( ) <NEWLINE> dp = [ list ( ) for _ in range ( N ) ] <NEWLINE> id = [ - 1 for _ in range ( N ) ] <COMMENT> <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> l . append ( ( a , b ) ) <NEWLINE> dp [ a - 1 ] . append ( b ) <NEWLINE> dp [ b - 1 ] . append ( a ) <NEWLINE> id [ a - 1 ] = 0 <NEWLINE> id [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> c = [ ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if id [ n - 1 ] == 0 : <NEWLINE> <INDENT> q = deque ( [ n ] ) <NEWLINE> while q : <NEWLINE> <INDENT> tmp = q . popleft ( ) <NEWLINE> cnt += 1 <NEWLINE> id [ tmp - 1 ] = i <NEWLINE> for e in dp [ tmp - 1 ] : <NEWLINE> <INDENT> if id [ e - 1 ] == 0 : <NEWLINE> <INDENT> id [ e - 1 ] = i <NEWLINE> q . append ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> c . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> print ( max ( c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> now = now * a <NEWLINE> if now > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ k + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> d = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d += math . gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> if r > 0 and r < 10000 : <NEWLINE> <INDENT> circle_length = ( r * 2 ) * math . pi <NEWLINE> circle_area = r * r * math . pi <NEWLINE> <NL> print ( <STRING> . format ( circle_area , circle_length ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a1 , a2 = [ ] , [ ] <NEWLINE> for idx , ai in enumerate ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> a1 . append ( ai + idx ) <NEWLINE> a2 . append ( idx - ai ) <NEWLINE> <DEDENT> cnt = Counter ( a2 ) <NEWLINE> res = 0 <NEWLINE> for idx , i in enumerate ( a1 ) : <NEWLINE> <INDENT> cnt [ a2 [ idx ] ] -= 1 <NEWLINE> res += cnt [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , x + 100 ) : <NEWLINE> <INDENT> for j in [ - 1 , 1 ] : <NEWLINE> <INDENT> temp = x + ( i * j ) <NEWLINE> if ps . count ( temp ) == 0 : <NEWLINE> <INDENT> ans = temp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if k > a : <NEWLINE> <INDENT> ans += a <NEWLINE> k -= a <NEWLINE> if k > b : <NEWLINE> <INDENT> k -= b <NEWLINE> if k > c : <NEWLINE> <INDENT> ans -= c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heapify , heappush , heappop <NEWLINE> from collections import Counter , defaultdict , deque , OrderedDict <NEWLINE> from sys import setrecursionlimit as setreclim <NEWLINE> from sys import maxsize <NEWLINE> from bisect import bisect_left , bisect , insort_left , insort <NEWLINE> from math import ceil , log , factorial , hypot , pi <NEWLINE> from fractions import gcd <NEWLINE> from copy import deepcopy <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> from itertools import product , permutations , combinations , accumulate , cycle <NEWLINE> from string import ascii_uppercase , ascii_lowercase , ascii_letters , digits , hexdigits , octdigits <NEWLINE> <NL> prod = lambda l : reduce ( mul , l ) <NEWLINE> prodmod = lambda l , mod : reduce ( lambda x , y : mul ( x , y ) % mod , l ) <NEWLINE> <NL> class Dijkstra : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , V , E , start , INF = 10 ** 9 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . V = V <NEWLINE> self . E = E <NEWLINE> self . dijkstra ( start , INF ) <NEWLINE> <NL> <DEDENT> def dijkstra ( self , start , INF ) : <NEWLINE> <INDENT> que = list ( ) <NEWLINE> self . distance = [ INF ] * self . V <COMMENT> <NEWLINE> self . prev = [ - 1 ] * self . V <COMMENT> <NEWLINE> self . distance [ start ] = 0 <NEWLINE> heappush ( que , ( 0 , start ) ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> dist , v = heappop ( que ) <NEWLINE> if self . distance [ v ] < dist : continue <NEWLINE> for to , cost in self . E [ v ] : <NEWLINE> <INDENT> if self . distance [ v ] + cost < self . distance [ to ] : <NEWLINE> <INDENT> self . distance [ to ] = self . distance [ v ] + cost <NEWLINE> heappush ( que , ( self . distance [ to ] , to ) ) <NEWLINE> self . prev [ to ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getPath ( self , end ) : <NEWLINE> <INDENT> path = [ end ] <NEWLINE> while self . prev [ end ] != - 1 : <NEWLINE> <INDENT> end = self . prev [ end ] <NEWLINE> <DEDENT> return path [ : : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 10 <NEWLINE> edge = [ [ ] for _ in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ s ] . append ( ( t , cost ) ) <NEWLINE> <DEDENT> sp = Dijkstra ( V , edge , r , INF ) <NEWLINE> for d in sp . distance : <NEWLINE> <INDENT> print ( d if d != INF else <STRING> ) <NEWLINE> <DEDENT>
with open ( 0 ) as f : <NEWLINE> <INDENT> N , * xy = map ( int , f . read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> from collections import namedtuple <NEWLINE> v = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> X = sorted ( [ v ( x , i ) for x , i in zip ( xy [ : : 2 ] , range ( N ) ) ] ) <NEWLINE> Y = sorted ( [ v ( y , i ) for y , i in zip ( xy [ 1 : : 2 ] , range ( N ) ) ] ) <NEWLINE> <NL> diffiter = lambda X : zip ( X [ : len ( X ) - 1 ] , X [ 1 : ] ) <COMMENT> <NEWLINE> cost = lambda u , v : abs ( u . coordinate - v . coordinate ) <NEWLINE> from itertools import chain <NEWLINE> Edge = sorted ( [ ( cost ( u , v ) , u . num , v . num ) for u , v in chain ( diffiter ( X ) , diffiter ( Y ) ) ] ) <NEWLINE> <NL> root = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <COMMENT> <NEWLINE> Root = [ root ( i , 0 ) for i in range ( N ) ] <NEWLINE> <NL> def fr ( i ) : <COMMENT> <NEWLINE> <INDENT> if i == Root [ i ] . num : <NEWLINE> <INDENT> return Root [ i ] <NEWLINE> <DEDENT> Root [ i ] = fr ( Root [ i ] . num ) <NEWLINE> return Root [ i ] <NEWLINE> <NL> <NL> <DEDENT> def unionT ( i , j ) : <COMMENT> <NEWLINE> <INDENT> p , q = fr ( i ) , fr ( j ) <NEWLINE> if p . rank < q . rank : <NEWLINE> <INDENT> Root [ p . num ] = q <NEWLINE> <DEDENT> elif p . rank > q . rank : <NEWLINE> <INDENT> Root [ q . num ] = p <NEWLINE> <DEDENT> elif p . rank == q . rank : <NEWLINE> <INDENT> r , s = min ( p , q ) , max ( p , q ) <NEWLINE> Root [ r . num ] = Root [ s . num ] = root ( r . num , r . rank + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for w , i , j in Edge : <NEWLINE> <INDENT> if fr ( i ) . num == fr ( j ) . num : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unionT ( i , j ) <NEWLINE> ans += w <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> s1 = set ( ) <NEWLINE> s2 = set ( ) <NEWLINE> s3 = set ( ) <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> for ss2 in s2 : <NEWLINE> <INDENT> s3 . add ( ss2 + s ) <NEWLINE> <DEDENT> for ss1 in s1 : <NEWLINE> <INDENT> s2 . add ( ss1 + s ) <NEWLINE> <DEDENT> s1 . add ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( s3 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> res = <STRING> <NEWLINE> <NL> while N : <NEWLINE> <INDENT> N -= 1 <NEWLINE> res += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <NL> <DEDENT> print ( res [ : : - 1 ] ) <COMMENT> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> and S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AP = [ 0 ] * N <NEWLINE> AM = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> AP [ i ] = i + A [ i ] <NEWLINE> AM [ i ] = i - A [ i ] <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> QC = Counter ( AP ) <NEWLINE> for m in AM : <NEWLINE> <INDENT> cnt += QC [ m ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , M , K = input ( ) . split ( ) <NEWLINE> <NL> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> A = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( c ) for c in A ] <NEWLINE> <NL> Sum_A = [ 0 ] <NEWLINE> ele_A = 0 <NEWLINE> a = 0 <NEWLINE> <NL> while Sum_A [ - 1 ] + A [ a ] <= K : <NEWLINE> <INDENT> ele_A += A [ a ] <NEWLINE> a += 1 <NEWLINE> Sum_A . append ( ele_A ) <NEWLINE> if a == len ( A ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> B = list ( input ( ) . split ( ) ) <NEWLINE> B = [ int ( c ) for c in B ] <NEWLINE> <NL> Sum_B = [ 0 ] <NEWLINE> ele_B = 0 <NEWLINE> b = 0 <NEWLINE> <NL> while Sum_B [ - 1 ] + B [ b ] <= K : <NEWLINE> <INDENT> ele_B += B [ b ] <NEWLINE> b += 1 <NEWLINE> Sum_B . append ( ele_B ) <NEWLINE> if b == len ( B ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> h = len ( Sum_A ) - 1 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> while h >= 0 : <NEWLINE> <INDENT> while Sum_A [ h ] + Sum_B [ i ] <= K : <NEWLINE> <INDENT> j = max ( j , h + i ) <NEWLINE> if i == len ( Sum_B ) - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h -= 1 <NEWLINE> <NL> <DEDENT> print ( j ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = dict ( collections . Counter ( [ i + A [ i ] for i in range ( N ) ] ) ) <NEWLINE> ans = sum ( [ d . get ( j - A [ j ] , 0 ) for j in range ( N ) ] ) <COMMENT> <NEWLINE> <NL> print ( ans ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> if h == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> h = int ( h / 2 ) <NEWLINE> if h == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( 2 ** cnt - 1 ) <NEWLINE>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = 1 <NEWLINE> if 0 not in A : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> r *= a <NEWLINE> if r > 10e17 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L = i + A [ i ] <NEWLINE> if L not in X : <NEWLINE> <INDENT> X [ L ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ L ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> R = i - A [ i ] <NEWLINE> if R in X : <NEWLINE> <INDENT> ans += X [ R ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
splited = input ( ) . split ( <STRING> ) <NEWLINE> <NL> k = int ( splited [ 0 ] ) <NEWLINE> s = int ( splited [ 1 ] ) <NEWLINE> <NL> result = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> result = result + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> <NL> y = copy . copy ( x ) <NEWLINE> x . sort ( ) <NEWLINE> num1 = x [ n // 2 - 1 ] <NEWLINE> num2 = x [ n // 2 ] <NEWLINE> <NL> for i in y : <NEWLINE> <INDENT> if i <= num1 : <NEWLINE> <INDENT> print ( num2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num1 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> L = len ( s ) <NEWLINE> l = len ( t ) <NEWLINE> X = [ ] <NEWLINE> for i in range ( L - l + 1 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> X . append ( x ) <NEWLINE> <DEDENT> print ( min ( X ) ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( abs ( xlist [ 0 ] - x ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ylist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ylist . append ( abs ( xlist [ i ] - x ) ) <NEWLINE> <DEDENT> from functools import reduce <NEWLINE> from math import gcd <NEWLINE> print ( reduce ( gcd , ylist ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> answer *= A [ i + 1 ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i <= j <= l : <NEWLINE> <INDENT> if i == j == l : <NEWLINE> <INDENT> a = a + i <NEWLINE> <DEDENT> elif i == j and j != l : <NEWLINE> <INDENT> a = a + 3 * math . gcd ( i , l ) <NEWLINE> <DEDENT> elif i != j and j == l : <NEWLINE> <INDENT> a = a + 3 * math . gcd ( i , l ) <NEWLINE> <DEDENT> elif i != j and j != l : <NEWLINE> <INDENT> a = a + 6 * math . gcd ( i , math . gcd ( j , l ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = a + 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> stop = False <NEWLINE> for A in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 129 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> stop = True <NEWLINE> <DEDENT> <DEDENT> if stop : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def find ( id , V , d , dist ) : <NEWLINE> <INDENT> i = id - 1 <NEWLINE> dist [ i ] = d <NEWLINE> for v in V [ i ] : <NEWLINE> <INDENT> if dist [ v - 1 ] == - 1 or dist [ v - 1 ] > d + 1 : <NEWLINE> <INDENT> find ( v , V , d + 1 , dist ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = [ [ False , 0 , 0 ] for i in range ( n ) ] <NEWLINE> U = [ ] <NEWLINE> V = [ ] <NEWLINE> dist = [ - 1 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U . append ( l [ 0 ] ) <NEWLINE> V . append ( l [ 2 : ] ) <NEWLINE> <NL> <DEDENT> find ( 1 , V , 0 , dist ) <NEWLINE> <NL> for u in U : <NEWLINE> <INDENT> print ( u , dist [ u - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def Ii ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = Ii ( ) <NEWLINE> a = Li ( ) <NEWLINE> x = [ 0 ] * n <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] + i < n : <NEWLINE> <INDENT> x [ a [ i ] + i ] += 1 <NEWLINE> <DEDENT> if i - a [ i ] >= 0 : <NEWLINE> <INDENT> ans += x [ i - a [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acum1 = [ 0 ] <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> acum1 . append ( acum1 [ - 1 ] + arr1 [ i ] ) <NEWLINE> <DEDENT> acum2 = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> acum2 . append ( acum2 [ - 1 ] + arr2 [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum1 [ i ] > k : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> B = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> B [ max ( j - A [ j ] , 0 ) ] += 1 <NEWLINE> <COMMENT> <NL> B [ min ( j + A [ j ] + 1 , N ) ] -= 1 <NEWLINE> <NL> <DEDENT> A = np . cumsum ( B ) [ : - 1 ] <NEWLINE> <NL> if np . all ( A == N ) : <NEWLINE> <INDENT> return A <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return A <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> A = solve ( N , K , A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != ( N - 1 ) : <NEWLINE> <INDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> s = sum ( a ) <NEWLINE> <NL> for i in range ( 1 , len ( a ) + 1 ) : <NEWLINE> <INDENT> ans += a [ i - 1 ] * ( s - a [ i - 1 ] ) <NEWLINE> s = s - a [ i - 1 ] <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> c = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if A [ n ] == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c != 0 : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ n ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> c = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if math . ceil ( c / b ) <= math . ceil ( a / d ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> box = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> box [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> x = list ( map ( lambda x : x * ( x - 1 ) // 2 , box ) ) <NEWLINE> ans = sum ( x ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> print ( ans - ( box [ A [ j ] ] - 1 ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> l = A [ i ] - 1 <NEWLINE> ans [ l ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif N < K : <NEWLINE> <INDENT> lis1 = [ N , abs ( N - K ) ] <NEWLINE> print ( min ( lis1 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> lis2 = [ N % K , abs ( N % K - K ) ] <NEWLINE> print ( min ( lis2 ) ) <NEWLINE> <NL> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ta = ( C - 1 ) // B + 1 <NEWLINE> tb = ( A - 1 ) // D + 1 <NEWLINE> if ta <= tb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> num [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , num [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> cnt = len ( s ) <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 1 : ] == <STRING> * ( cnt - 1 ) : <NEWLINE> <INDENT> print ( 9 * cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 8 + 9 * ( cnt - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ 1 : ] == <STRING> * ( cnt - 1 ) : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) + 9 * ( cnt - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( s [ 0 ] ) - 1 ) + 9 * ( cnt - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = l [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> prevans = l [ i - k ] <NEWLINE> ans = l [ i ] <NEWLINE> if ans > prevans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> def board ( dp , i ) : <NEWLINE> <INDENT> m = 1 <NEWLINE> while i * m <= len ( dp ) - 1 : <NEWLINE> <INDENT> dp [ i * m ] = False <NEWLINE> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = sorted ( b ) <NEWLINE> d = Counter ( b ) <NEWLINE> dp = [ True ] * ( b [ - 1 ] + 1 ) <NEWLINE> c = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if dp [ i ] and d [ i ] < 2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> board ( dp , i ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
abc = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> ans = [ ] <NEWLINE> def rec ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> n -= 1 <NEWLINE> ans . append ( abc [ n % 26 ] ) <NEWLINE> <COMMENT> <NL> if n >= 26 : <NEWLINE> <COMMENT> <NL> <INDENT> return rec ( int ( n / 26 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> rec ( N ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( len ( ans ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> maze = [ ] <NEWLINE> inf = 9999999 <NEWLINE> dist = [ inf ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> queue = [ ] <NEWLINE> answer = [ 0 ] * n <NEWLINE> <NL> goto = [ [ ] * 1 for i in range ( n ) ] <NEWLINE> for i in range ( len ( ab ) ) : <NEWLINE> <INDENT> goto [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> goto [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> queue . extend ( [ 0 ] ) <NEWLINE> <NL> while queue != [ ] : <NEWLINE> <INDENT> go = queue . pop ( 0 ) <NEWLINE> for h in goto [ go ] : <NEWLINE> <INDENT> if dist [ h ] == inf : <NEWLINE> <INDENT> queue . append ( h ) <NEWLINE> dist [ h ] = dist [ go ] + 1 <NEWLINE> answer [ h ] = go + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in answer [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ k - q ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> c [ int ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if c [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> A . sort ( ) <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> i , j = 0 , 0 <NEWLINE> <NL> while i < n and j < m : <NEWLINE> <INDENT> if A [ i ] >= bc [ j ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A [ i ] = bc [ j ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> bc [ j ] [ 0 ] -= 1 <NEWLINE> if bc [ j ] [ 0 ] == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 998244353 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> class combination_mod : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , N , m ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . m = m <NEWLINE> self . N_factorials = [ 1 for _ in range ( N ) ] <COMMENT> <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> self . N_factorials [ n ] = ( self . N_factorials [ n - 1 ] * ( n + 1 ) ) % m <NEWLINE> <DEDENT> N_factorial_inv = pow ( self . N_factorials [ N - 1 ] , m - 2 , m ) <COMMENT> <NEWLINE> self . N_factorials_inv = [ 1 for _ in range ( N ) ] <COMMENT> <NEWLINE> self . N_factorials_inv [ 0 ] = N_factorial_inv <NEWLINE> for n in range ( 1 , N ) : <COMMENT> <NEWLINE> <INDENT> self . N_factorials_inv [ n ] = ( self . N_factorials_inv [ n - 1 ] * ( N - n + 1 ) ) % m <NEWLINE> <DEDENT> <DEDENT> def calc ( self , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 0 or n == self . N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( self . N_factorials [ self . N - 1 ] * self . N_factorials_inv [ self . N - n ] ) % self . m <COMMENT> <NEWLINE> c = ( c * self . N_factorials_inv [ n ] ) % self . m <COMMENT> <NEWLINE> return c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( M % m ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif M == 1 : <NEWLINE> <INDENT> if N > K + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func = combination_mod ( N - 1 , m ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans_temp = M <NEWLINE> ans_temp = ( ans_temp * func . calc ( k ) ) % m <NEWLINE> ans_temp = ( ans_temp * pow ( M - 1 , N - 1 - k , m ) ) % m <NEWLINE> ans += ans_temp <NEWLINE> ans = ans % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> d = defaultdict ( lambda : 0 ) <NEWLINE> d2 = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> for i , j in d . items ( ) : <NEWLINE> <INDENT> x = j * ( j - 1 ) // 2 <NEWLINE> d2 [ i ] = x <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans = sum ( d2 . values ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans - d [ a [ i ] ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 998244353 <NEWLINE> import numpy as np <NEWLINE> dp = np . zeros ( ( n + 1 , 3001 ) , int ) <NEWLINE> <COMMENT> <NL> dp [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 ] += dp [ i ] * 2 <NEWLINE> dp [ i + 1 , a [ i ] : ] += dp [ i , : - a [ i ] ] <NEWLINE> dp [ i + 1 ] %= mod <NEWLINE> <DEDENT> print ( dp [ n ] [ s ] ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s in d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( d ) ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> R = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R [ i ] = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> mx = R [ 1 ] - R [ 0 ] <NEWLINE> mn = min ( R [ : 2 ] ) <NEWLINE> <NL> for r in R [ 2 : ] : <NEWLINE> <INDENT> if mx < r - mn : <NEWLINE> <INDENT> mx = r - mn <NEWLINE> <DEDENT> elif mn > r : <NEWLINE> <INDENT> mn = r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> z = int ( input ( ) ) <NEWLINE> if z == 1 : <NEWLINE> <INDENT> x [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> x [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x . count ( 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List2 = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> List2 [ List [ i - 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in List2 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> a = mp [ i ] + i <NEWLINE> if ( a <= n ) : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <DEDENT> b = j - mp [ j ] <NEWLINE> if ( b < 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += cnt [ b ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools as it <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> book = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( N ) ] <NEWLINE> <NL> combs = it . product ( [ 0 , 1 ] , repeat = N ) <NEWLINE> prices = [ ] <NEWLINE> for comb in combs : <NEWLINE> <INDENT> bag = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if comb [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( M + 1 ) : <NEWLINE> <INDENT> bag [ j ] += book [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( bag [ 1 : ] ) < X : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prices . append ( bag [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( prices ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( prices ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import defaultdict <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bom_H = defaultdict ( int ) <NEWLINE> bom_W = defaultdict ( int ) <NEWLINE> posision = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bom_H [ h ] += 1 <NEWLINE> bom_W [ w ] += 1 <NEWLINE> posision . add ( ( h , w ) ) <NEWLINE> <DEDENT> temp_H = max ( bom_H . values ( ) ) <NEWLINE> temp_W = max ( bom_W . values ( ) ) <NEWLINE> indx_H = [ k for k , v in bom_H . items ( ) if v == temp_H ] <NEWLINE> indx_W = [ k for k , v in bom_W . items ( ) if v == temp_W ] <NEWLINE> set_max_H = set ( indx_H ) <NEWLINE> set_max_W = set ( indx_W ) <NEWLINE> <NL> <NL> flag = False <NEWLINE> for h in set_max_H : <NEWLINE> <INDENT> for w in set_max_W : <NEWLINE> <INDENT> if ( h , w ) not in posision : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( temp_H + temp_W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( temp_H + temp_W - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> count = 0 <NEWLINE> for a in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if n % a != 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = n // a - 1 <NEWLINE> <DEDENT> if a <= b : <NEWLINE> <INDENT> count = ( count + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = ( count + b ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( count + 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> now = 0 <NEWLINE> history = [ 0 ] <NEWLINE> isVisited = [ False for i in range ( N ) ] <NEWLINE> i = 0 <NEWLINE> while i < K : <NEWLINE> <COMMENT> <NL> <INDENT> now = A [ now ] - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if isVisited [ now ] == False : <NEWLINE> <INDENT> history . append ( now ) <NEWLINE> isVisited [ now ] = True <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> start = history . index ( now ) <NEWLINE> r = start + ( K - 1 - i ) % ( len ( history ) - start ) <NEWLINE> now = history [ r ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( now + 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = sum ( A ) <NEWLINE> <NL> dic = Counter ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in dic . keys ( ) : <NEWLINE> <INDENT> sumA += ( ( c - b ) * dic [ b ] ) <NEWLINE> <NL> <COMMENT> <NL> if c in dic . keys ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dic [ c ] += dic [ b ] <NEWLINE> del dic [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = dic [ b ] <NEWLINE> del dic [ b ] <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sumA ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M , K = il ( ) <NEWLINE> A = list ( itertools . accumulate ( [ 0 ] + il ( ) ) ) <NEWLINE> B = list ( itertools . accumulate ( ( [ 0 ] + il ( ) ) ) ) <NEWLINE> <NL> ret , m = 0 , M <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ n ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while B [ m ] > K - A [ n ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ret = max ( ret , n + m ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> X = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> X . append ( S ) <NEWLINE> <DEDENT> Y = collections . Counter ( X ) <NEWLINE> print ( len ( Y ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> <NL> s = s [ : : - 1 ] <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> prev = 0 <NEWLINE> ans = 0 <NEWLINE> mul = 1 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> now = ( int ( s [ i ] ) * mul ) % 2019 <NEWLINE> ans += l [ ( prev + now ) % 2019 ] <NEWLINE> l [ ( prev + now ) % 2019 ] += 1 <NEWLINE> prev = ( prev + now ) % 2019 <NEWLINE> mul = ( mul * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def biser ( lst , func ) : <NEWLINE> <INDENT> n = len ( lst ) <NEWLINE> nh = n // 2 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if func ( lst [ 0 ] ) : <NEWLINE> <INDENT> return lst [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> if func ( lst [ nh ] ) : <NEWLINE> <INDENT> return biser ( lst [ nh : ] , func ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return biser ( lst [ : nh ] , func ) <NEWLINE> <NL> <DEDENT> <DEDENT> def mkns ( a , s , m ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( ( s + 1 ) << a ) | s ) & m <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ss = [ 0 ] * ( N + 1 ) <NEWLINE> pm = ( 1 << K ) - 1 <NEWLINE> mask = lambda c : ( 1 << K ) - ( 1 << c ) <NEWLINE> nn = 0 <NEWLINE> def isunnec ( i ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if a [ j ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i ] = ( ( ( ss [ i ] + 1 ) << a [ j ] ) | ss [ i ] ) & pm <NEWLINE> <COMMENT> <NL> <DEDENT> if ss [ i ] & mask ( K - a [ i ] ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i + 1 ] = ( ( ( ss [ i ] + 1 ) << a [ i ] ) | ss [ i ] ) & pm <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> nn = biser ( list ( range ( N ) ) , isunnec ) + 1 <NEWLINE> <COMMENT> <NL> print ( nn ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <NL> for j in range ( N ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( S [ i ] != S [ j ] ) and ( S [ i ] != S [ k ] ) and ( S [ j ] != S [ k ] ) : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> data = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> data [ i ] += 1 <NEWLINE> <DEDENT> res = sum ( a ) <NEWLINE> <NL> for j in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> res += ( c - b ) * data [ b ] <NEWLINE> data [ c ] += data [ b ] <NEWLINE> data [ b ] = 0 <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> result = sum ( list ( map ( int , str ( N ) ) ) ) <NEWLINE> if result % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 0 , int ( n / 2 ) + 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if x - j not in p : <NEWLINE> <INDENT> print ( x - j ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x + j not in p : <NEWLINE> <INDENT> print ( x + j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import itertools as it <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = input ( ) . split ( ) <NEWLINE> ans = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> A = list ( map ( int , A ) ) <NEWLINE> M = list ( map ( int , M ) ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> Ac = list ( it . combinations ( A , i + 1 ) ) <NEWLINE> for j in Ac : <NEWLINE> <INDENT> ans . append ( sum ( j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in M : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in ans : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> X = sum ( A ) <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> Y = A [ i ] <NEWLINE> X -= Y <NEWLINE> ans += ( Y * X ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> P [ a ] . append ( b ) <NEWLINE> P [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> con = set ( ) <NEWLINE> now = [ 1 ] <NEWLINE> while now != [ ] : <NEWLINE> <INDENT> _now = [ ] <NEWLINE> for n in now : <NEWLINE> <INDENT> for p in P [ n ] : <NEWLINE> <INDENT> if p in con : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ p - 1 ] = n <NEWLINE> _now . append ( p ) <NEWLINE> con . add ( p ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> now = _now <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> c = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = a [ i ] - i <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] = a [ i ] + i <NEWLINE> <DEDENT> cb = Counter ( b ) <NEWLINE> cc = Counter ( c ) <NEWLINE> k = cb . keys ( ) <NEWLINE> ans = 0 <NEWLINE> for i in k : <NEWLINE> <INDENT> ans += cb [ i ] * cc [ i * ( - 1 ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sm = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> sm += A [ i ] <NEWLINE> <NL> <DEDENT> before = sm <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> sm -= A [ i - K ] <NEWLINE> sm += A [ i ] <NEWLINE> if sm > before : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> before = sm <NEWLINE> <DEDENT>
inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = line [ 1 ] <NEWLINE> c = [ inf ] * n <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = line [ 2 + 2 * j ] <NEWLINE> c [ v ] = line [ 3 + 2 * j ] <NEWLINE> <DEDENT> g . append ( c ) <NEWLINE> <NL> <DEDENT> distance = [ inf ] * n <NEWLINE> distance [ 0 ] = 0 <NEWLINE> visited = [ False ] * n <NEWLINE> current = 0 <NEWLINE> <NL> while not all ( visited ) : <NEWLINE> <INDENT> visited [ current ] = True <NEWLINE> min_i = 0 <NEWLINE> min_d = inf <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> if distance [ current ] + g [ current ] [ i ] < distance [ i ] : <NEWLINE> <INDENT> distance [ i ] = distance [ current ] + g [ current ] [ i ] <NEWLINE> <DEDENT> if distance [ i ] < min_d : <NEWLINE> <INDENT> min_i = i <NEWLINE> min_d = distance [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> current = min_i <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , distance [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r ** 2 * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> print ( s , l ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 0 <NEWLINE> count = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> p += i <NEWLINE> count += 1 <NEWLINE> if p > X : <NEWLINE> <INDENT> count -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
arr = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> arr [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if k == 9 : <NEWLINE> <INDENT> print ( arr [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( arr [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def func ( A , B , N ) : <NEWLINE> <INDENT> if N > B - 1 : <NEWLINE> <INDENT> return math . floor ( A * ( B - 1 ) / B ) - A * math . floor ( ( B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( func ( A , B , N ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> S = S [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> mod = 2019 <NEWLINE> m = 0 <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = int ( S [ i ] ) * ( pow ( 10 , i , mod ) ) <NEWLINE> s %= mod <NEWLINE> m += s <NEWLINE> m %= mod <NEWLINE> cnt [ m ] += 1 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> pl = 1 <NEWLINE> while i + pl * 2 < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + pl ] and s [ i + pl ] != s [ i + pl * 2 ] and s [ i ] != s [ i + pl * 2 ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> pl += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * min ( n , b - 1 ) // b - a * ( min ( b - 1 , n ) // b ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> r = len ( s ) - len ( t ) <NEWLINE> l = [ ] <NEWLINE> if r != 0 : <NEWLINE> <INDENT> for start in range ( r ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == s [ start + i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( count ) <NEWLINE> <DEDENT> ans = len ( t ) - max ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == s [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> ans = len ( t ) - count <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def int_mtx ( N ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def str_mtx ( N ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def int_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def print_space ( l ) : <NEWLINE> <INDENT> return print ( <STRING> . join ( [ str ( x ) for x in l ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import numpy as np <NEWLINE> import statistics <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> <COMMENT> <NL> H , W , M = int_map ( ) <NEWLINE> hw = int_mtx ( M ) <NEWLINE> <NL> h = [ ] <NEWLINE> w = [ ] <NEWLINE> for hhww in hw : <NEWLINE> <INDENT> h . append ( hhww [ 0 ] ) <NEWLINE> w . append ( hhww [ 1 ] ) <NEWLINE> <NL> <DEDENT> ch = collections . Counter ( h ) <NEWLINE> cw = collections . Counter ( w ) <NEWLINE> a = ch . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = cw . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <NL> if a == M or b == M : <NEWLINE> <INDENT> print ( M ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if a < b : <NEWLINE> <INDENT> bb = cw . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> hw1 = [ i for i in hw if not i [ 1 ] == bb ] <NEWLINE> <NL> h1 = [ ] <NEWLINE> for hhww in hw1 : <NEWLINE> <INDENT> h1 . append ( hhww [ 0 ] ) <NEWLINE> <NL> <DEDENT> ch1 = collections . Counter ( h1 ) <NEWLINE> a1 = ch1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <NL> print ( b + a1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = ch . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> hw1 = [ i for i in hw if not i [ 0 ] == aa ] <NEWLINE> <NL> w1 = [ ] <NEWLINE> for hhww in hw1 : <NEWLINE> <INDENT> w1 . append ( hhww [ 1 ] ) <NEWLINE> <NL> <DEDENT> cw1 = collections . Counter ( w1 ) <NEWLINE> b1 = cw1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <NL> print ( a + b1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> fac = [ 1 ] * n <NEWLINE> finv = [ 1 ] * n <NEWLINE> inv = [ 1 ] * n <NEWLINE> MOD = 998244353 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += comb ( n - 1 , i ) * m * pow ( m - 1 , n - i - 1 , MOD ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> for _ in range ( 1 ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> x , k , d = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> x = abs ( x ) <NEWLINE> des = x % d <NEWLINE> op = x // d <NEWLINE> <COMMENT> <NL> a = [ des , des - d ] <NEWLINE> if k < op : <COMMENT> <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( a [ ( k - op ) % 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def add_to_graph ( A , B ) : <NEWLINE> <INDENT> global graph <NEWLINE> <NL> graph . setdefault ( A , [ ] ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> <NL> <NL> <DEDENT> def add_to_group ( p ) : <NEWLINE> <INDENT> global que <NEWLINE> global group <NEWLINE> global is_finished <NEWLINE> <NL> que . append ( p ) <NEWLINE> group . add ( p ) <NEWLINE> is_finished [ p ] = True <NEWLINE> <NL> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = dict ( ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> add_to_graph ( A , B ) <NEWLINE> add_to_graph ( B , A ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> is_finished = [ False ] * ( N + 1 ) <NEWLINE> groups = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> group = set ( ) <NEWLINE> <NL> if not is_finished [ i ] : <NEWLINE> <INDENT> add_to_group ( i ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> <NL> if p in graph . keys ( ) : <NEWLINE> <INDENT> for v in graph [ p ] : <NEWLINE> <INDENT> if not is_finished [ v ] : <NEWLINE> <INDENT> add_to_group ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> groups . append ( group ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for g in groups : <NEWLINE> <INDENT> ans = max ( ans , len ( g ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> rl = [ ] <NEWLINE> ll = [ ] <NEWLINE> c = 0 <NEWLINE> b = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == b : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> rl . append ( c ) <NEWLINE> b = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll . append ( c ) <NEWLINE> b = <STRING> <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> ll . append ( c ) <NEWLINE> ans = [ ] <NEWLINE> for i , j in zip ( rl , ll ) : <NEWLINE> <INDENT> ans += [ 0 ] * ( i - 1 ) + [ i - i // 2 + j // 2 ] + [ i // 2 + j - j // 2 ] + [ 0 ] * ( j - 1 ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist = [ ] <NEWLINE> cnt = 0 <NEWLINE> i = 1 <NEWLINE> blist = [ 0 ] * ( n + 1 ) <NEWLINE> while blist [ a [ i - 1 ] ] == 0 : <NEWLINE> <INDENT> i = a [ i - 1 ] <NEWLINE> alist . append ( i ) <NEWLINE> blist [ i ] = 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> loop1 = alist . index ( a [ i - 1 ] ) <NEWLINE> if k < loop1 + 1 : <NEWLINE> <INDENT> print ( alist [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( alist [ ( ( k - loop1 - 1 ) % ( cnt - loop1 ) ) + loop1 ] ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <NL> <DEDENT> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = 10 % L <NEWLINE> if X == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> X = X * 10 % L <NEWLINE> if X == 1 : <NEWLINE> <INDENT> print ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import defaultdict , deque <NEWLINE> <NL> G = defaultdict ( set ) <NEWLINE> <NL> <NL> results = [ - 1 ] * N <NEWLINE> flags = [ False ] * N <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ A - 1 ] . add ( B - 1 ) <NEWLINE> G [ B - 1 ] . add ( A - 1 ) <NEWLINE> <NL> <DEDENT> seen = [ False ] * N <NEWLINE> partner = [ 0 ] * N <NEWLINE> <NL> q = deque ( [ 0 ] ) <NEWLINE> seen [ 0 ] = True <NEWLINE> <NL> <NL> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for i in G [ now ] : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ i ] = True <NEWLINE> partner [ i ] = now <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( seen ) != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in partner [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> sub = 0 <NEWLINE> for i in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> if 2 * i == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if S [ sub ] != S [ sub + i ] and S [ sub + i ] != S [ sub + 2 * i ] and S [ sub + 2 * i ] != S [ sub ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if sub + 2 * i + 1 < N : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sub = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , X = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> vals = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> vals . append ( v ) <NEWLINE> <NL> <DEDENT> vals = np . array ( vals ) <NEWLINE> <NL> import itertools <NEWLINE> <NL> prod = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> v = list ( itertools . combinations ( range ( N ) , i ) ) <NEWLINE> prod . extend ( v ) <NEWLINE> <NL> <DEDENT> money = 1e10 <NEWLINE> <NL> for p in prod : <NEWLINE> <INDENT> ans = np . zeros ( M + 1 ) <NEWLINE> <NL> for p_ in p : <NEWLINE> <INDENT> ans += vals [ p_ ] <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if ans [ 1 + j ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> if money > ans [ 0 ] : <NEWLINE> <INDENT> money = ans [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if money >= 1e10 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( money ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while H > 0 : <NEWLINE> <INDENT> i = W <NEWLINE> while i > 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> H -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( N , A_list ) : <NEWLINE> <INDENT> total_list = [ ] <NEWLINE> total = 0 <NEWLINE> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> total += A_list [ i ] <NEWLINE> total_list . append ( total ) <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> for i in range ( len ( A_list ) - 1 ) : <NEWLINE> <INDENT> num += A_list [ i ] * ( total_list [ len ( A_list ) - 1 ] - total_list [ i ] ) <NEWLINE> <NL> <DEDENT> val = num % ( ( 10 ** 9 ) + 7 ) <NEWLINE> print ( val ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( N , A_list ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> from collections import defaultdict , deque , Counter , OrderedDict <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from functools import reduce , lru_cache <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> <NL> import itertools <NEWLINE> import math , fractions <NEWLINE> import sys , copy <NEWLINE> <NL> def L ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def SL ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI1 ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def R ( n ) : return [ sys . stdin . readline ( ) . strip ( ) for _ in range ( n ) ] <NEWLINE> def LR ( n ) : return [ L ( ) for _ in range ( n ) ] <NEWLINE> def IR ( n ) : return [ I ( ) for _ in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def LIR1 ( n ) : return [ LI1 ( ) for _ in range ( n ) ] <NEWLINE> def SLR ( n ) : return [ SL ( ) for _ in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> <NL> def perm ( n , r ) : return math . factorial ( n ) // math . factorial ( r ) <NEWLINE> def comb ( n , r ) : return math . factorial ( n ) // ( math . factorial ( r ) * math . factorial ( n - r ) ) <NEWLINE> <NL> def make_list ( n , * args , default = 0 ) : return [ make_list ( * args , default = default ) for _ in range ( n ) ] if args else [ default for _ in range ( n ) ] <NEWLINE> <NL> dire = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> dire8 = [ [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] ] <NEWLINE> alphabets = <STRING> <NEWLINE> ALPHABETS = <STRING> <NEWLINE> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class MaxFlowGraph : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . graph = [ [ ] for _ in range ( N ) ] <NEWLINE> self . paths = [ ] <NEWLINE> self . capacities = [ dict ( ) for _ in range ( N ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , v , w , cap = 1 ) : <NEWLINE> <INDENT> self . graph [ v ] . append ( w ) <NEWLINE> self . graph [ w ] . append ( v ) <NEWLINE> self . capacities [ v ] [ w ] = cap <NEWLINE> self . capacities [ w ] [ v ] = 0 <NEWLINE> <NL> <DEDENT> def dinic_bfs ( self , s , t ) : <NEWLINE> <INDENT> self . level = [ - 1 ] * self . N <NEWLINE> q = deque ( [ s ] ) <NEWLINE> self . level [ s ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w , cap in self . capacities [ v ] . items ( ) : <NEWLINE> <INDENT> if cap and self . level [ w ] == - 1 : <NEWLINE> <INDENT> self . level [ w ] = self . level [ v ] + 1 <NEWLINE> if w == t : return True <NEWLINE> q . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def dinic_dfs ( self , s , t , limit ) : <NEWLINE> <INDENT> st = [ t ] <NEWLINE> while st : <NEWLINE> <INDENT> v = st [ - 1 ] <NEWLINE> if v == s : break <NEWLINE> <COMMENT> <NL> while self . it [ v ] < len ( self . graph [ v ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> w = self . graph [ v ] [ self . it [ v ] ] <NEWLINE> cap = self . capacities [ w ] [ v ] <NEWLINE> if cap and self . level [ w ] != - 1 and self . level [ v ] > self . level [ w ] : <NEWLINE> <INDENT> st . append ( w ) <NEWLINE> break <NEWLINE> <DEDENT> self . it [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . pop ( ) <NEWLINE> self . level [ v ] = self . N <NEWLINE> <DEDENT> <DEDENT> else : return 0 <NEWLINE> <NL> flow = min ( limit , min ( self . capacities [ st [ i + 1 ] ] [ st [ i ] ] for i in range ( len ( st ) - 2 ) ) ) <NEWLINE> for i in range ( len ( st ) - 1 ) : <NEWLINE> <INDENT> self . capacities [ st [ i ] ] [ st [ i + 1 ] ] += flow <NEWLINE> self . capacities [ st [ i + 1 ] ] [ st [ i ] ] -= flow <NEWLINE> <DEDENT> self . paths . append ( st ) <NEWLINE> return flow <NEWLINE> <NL> <DEDENT> def dinic_flow ( self , s , t , flow_limit = 18446744073709551615 ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while flow < flow_limit and self . dinic_bfs ( s , t ) : <NEWLINE> <INDENT> self . it = [ 0 ] * self . N <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> f = self . dinic_dfs ( s , t , flow_limit - flow ) <NEWLINE> if not f : break <NEWLINE> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> def min_cut ( self , s ) : <NEWLINE> <INDENT> visited = [ False ] * self . N <NEWLINE> q = [ s ] <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> visited [ v ] = True <NEWLINE> for w , cap in self . capacities [ v ] . items ( ) : <NEWLINE> <INDENT> if cap and not visited [ w ] : <NEWLINE> <INDENT> q . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> S = SLR ( N ) <NEWLINE> g = MaxFlowGraph ( N * M + 2 ) <NEWLINE> <NL> s = N * M <NEWLINE> t = N * M + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( y + x ) % 2 == 0 : <NEWLINE> <INDENT> g . add_edge ( s , M * y + x ) <NEWLINE> for dy , dx in [ [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < N and 0 <= nx < M and S [ y ] [ x ] == <STRING> and S [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( M * y + x , M * ny + nx ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> g . add_edge ( M * y + x , t ) <NEWLINE> for dy , dx in [ [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < N and 0 <= nx < M and S [ y ] [ x ] == <STRING> and S [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( M * ny + nx , M * y + x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( g . dinic_flow ( s , t ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> for u in range ( N * M + 2 ) : <NEWLINE> <INDENT> uy , ux = divmod ( u , M ) <NEWLINE> if ( uy + ux ) % 2 == 1 : continue <NEWLINE> <NL> for v , cap in g . capacities [ u ] . items ( ) : <NEWLINE> <INDENT> if cap != 0 : continue <NEWLINE> vy , vx = divmod ( v , M ) <NEWLINE> if u != s and u != t and v != s and v != t : <NEWLINE> <INDENT> if uy - 1 == vy : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif uy + 1 == vy : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif ux + 1 == vx : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif ux - 1 == vx : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in S : <NEWLINE> <INDENT> print ( <STRING> . join ( p ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> x = int ( input ( ) . strip ( ) ) <NEWLINE> abs_x = abs ( x ) <NEWLINE> <NL> def X ( a , b ) : <NEWLINE> <INDENT> return a ** 5 - b ** 5 <NEWLINE> <NL> <DEDENT> def X_plus ( a , b ) : <NEWLINE> <INDENT> return a ** 5 + b ** 5 <NEWLINE> <NL> <DEDENT> a = - 118 <NEWLINE> b = - 119 <NEWLINE> <NL> <NL> for a in range ( - 118 , 119 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for b in range ( - 119 , 118 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if X ( a , b ) == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( n , ) , * a = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> d = { } <NEWLINE> for i , j in a : <NEWLINE> <INDENT> for x , y in a : <NEWLINE> <INDENT> if i != x or j != y : <NEWLINE> <INDENT> d [ ( i - x , j - y ) ] = d . get ( ( i - x , j - y ) , 0 ) + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - max ( list ( d . values ( ) ) + [ 0 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = False ) <NEWLINE> cnt = 1 <NEWLINE> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt *= A [ i ] <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> <NL> A = int ( s [ 0 ] ) <NEWLINE> B = int ( s [ 1 ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> m = A * B <NEWLINE> <NL> if m >= 100 : <NEWLINE> <INDENT> result = int ( str ( m ) [ : - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 0 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( a ) <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> tmp = abs ( 2 * b - t ) <NEWLINE> ans = tmp if i == 0 else min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> P = 10 ** 9 + 7 <NEWLINE> Q = 13 <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> dp = [ [ 0 ] * Q for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D = S [ i ] <NEWLINE> if D == - 1 : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( Q ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ ( 10 * j + d ) % Q ] += dp [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = int ( D ) <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ ( 10 * j + d ) % Q ] += dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] %= P <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ N ] [ 5 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . rstrip ( ) <NEWLINE> <NL> S = np . array ( [ int ( s ) if s != <STRING> else - 1 for s in S ] , dtype = np . int64 ) <NEWLINE> ans = solve ( S ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> int_n = int ( input ( ) ) <NEWLINE> list_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> int_sum = 0 <NEWLINE> int_divide = ( 10 ** 9 ) + 7 <NEWLINE> int_sum_tmp = sum ( list_tmp ) <NEWLINE> <NL> for i in range ( 0 , len ( list_tmp ) - 1 ) : <NEWLINE> <INDENT> int_sum_tmp = int_sum_tmp - list_tmp [ i ] <NEWLINE> int_sum = int_sum + ( int_sum_tmp * list_tmp [ i ] ) <NEWLINE> <DEDENT> print ( int_sum % int_divide ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
import os <NEWLINE> <NL> n , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> par = [ - 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = ( int ( x ) - 1 for x in input ( ) . split ( ) ) <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans = max ( [ ans , size ( i ) ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <COMMENT> <NEWLINE> <NL> dp = [ 50001 for i in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ j - i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ ] <NEWLINE> amax = 10 ** 5 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ab . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> amax = max ( a for a , b in ab ) <NEWLINE> p = [ 0 ] * ( h + amax + 1 ) <NEWLINE> for i in range ( 1 , h + amax ) : <NEWLINE> <INDENT> p [ i ] = min ( p [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( p [ h ] ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> if n < 6 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <DEDENT> y = int ( math . sqrt ( n - 3 ) ) <NEWLINE> if n <= 5 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , y ) : <NEWLINE> <INDENT> for j in range ( 1 , y ) : <NEWLINE> <INDENT> for k in range ( 1 , y ) : <NEWLINE> <INDENT> x = i ** 2 + j ** 2 + k ** 2 + i * j + i * k + j * k <NEWLINE> if x % 1 == 0 and x <= n : <NEWLINE> <INDENT> l [ x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lower_a = list ( map ( lambda x : x - 1 , a ) ) <NEWLINE> upper_a = list ( map ( lambda x : x + 1 , a ) ) <NEWLINE> extended_a = collections . Counter ( a + lower_a + upper_a ) <NEWLINE> <NL> print ( extended_a . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> if A [ i ] + A [ i + 1 ] <= X : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = A [ i ] + A [ i + 1 ] - X <NEWLINE> if A [ i + 1 ] < temp : <NEWLINE> <INDENT> A [ i + 1 ] = 0 <NEWLINE> cnt += A [ i + 1 ] <NEWLINE> temp -= A [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i + 1 ] -= temp <NEWLINE> cnt += temp <NEWLINE> temp -= A [ i + 1 ] <NEWLINE> <NL> <DEDENT> if A [ i ] + A [ i + 1 ] > X : <NEWLINE> <INDENT> A [ i ] -= temp <NEWLINE> cnt += temp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k , q , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> points = np . full ( n , k ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> points -= 1 <NEWLINE> points [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> [ points [ i ] > 0 : : 2 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> import math <NEWLINE> def yakusu ( n ) : <NEWLINE> <INDENT> ans_local = set ( ) <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans_local = ans_local | set ( [ i , n // i ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return list ( ans_local ) <COMMENT> <NEWLINE> <NL> <DEDENT> yaku = sorted ( yakusu ( s ) , reverse = 1 ) <NEWLINE> <COMMENT> <NL> for mod in yaku : <NEWLINE> <INDENT> B = [ i % mod for i in A if i % mod != 0 ] <NEWLINE> if B == [ ] : print ( mod ) ; exit ( ) <NEWLINE> if len ( B ) == 1 : <NEWLINE> <INDENT> q = B [ 0 ] <NEWLINE> if 0 <= q <= k or mod - k <= q : print ( mod ) ; exit ( ) <NEWLINE> else : continue <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> r = [ B [ 0 ] ] * len ( B ) <NEWLINE> for i in range ( len ( B ) - 1 ) : <NEWLINE> <INDENT> r [ i + 1 ] = r [ i ] + B [ i + 1 ] <NEWLINE> <DEDENT> now = float ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( B ) ) : <COMMENT> <NEWLINE> <INDENT> if r [ i - 1 ] == mod * ( len ( B ) - i ) - ( r [ - 1 ] - r [ i - 1 ] ) and r [ i - 1 ] <= k : <NEWLINE> <INDENT> print ( mod ) ; exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> <NL> c = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <NL> <NL> <INDENT> while i < 3 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( max ( c ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> product = 1 <NEWLINE> for i in listA : <NEWLINE> <INDENT> if product < 10 ** 18 + 1 : <NEWLINE> <INDENT> product = product * i <NEWLINE> <NL> <DEDENT> <DEDENT> if listA . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif product < 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <NL> <DEDENT> elif product >= 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c_0 = 0 <NEWLINE> m = min ( n , b - 1 ) <NEWLINE> x = int ( a * m / b ) <NEWLINE> print ( x ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sumval = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sumval += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sumval ) <NEWLINE>
import itertools <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from itertools import accumulate <NEWLINE> import bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> import math <NEWLINE> from copy import deepcopy <NEWLINE> import queue <NEWLINE> <COMMENT> <NL> Mod = 1000000007 <NEWLINE> <NL> def sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> prime = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if prime [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , n + 1 ) : <NEWLINE> <INDENT> if j % i == 0 : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = [ ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if prime [ i ] == 1 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> <DEDENT> def findroot ( self , x ) : <NEWLINE> <INDENT> if x == self . parent [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . parent [ x ] <NEWLINE> y = self . findroot ( self . parent [ x ] ) <NEWLINE> return y <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> px = self . findroot ( x ) <NEWLINE> py = self . findroot ( y ) <NEWLINE> if px < py : <NEWLINE> <INDENT> self . parent [ y ] = px <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ px ] = py <NEWLINE> <NL> <DEDENT> <DEDENT> def same_group_or_no ( self , x , y ) : <NEWLINE> <INDENT> return self . findroot ( x ) == self . findroot ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <COMMENT> <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <COMMENT> <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Math ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return Math . gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // Math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def divisor ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> i = 1 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def round_up ( a , b ) : <NEWLINE> <INDENT> return - ( - a // b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> d = int ( n ** 0.5 ) + 1 <NEWLINE> for i in range ( 3 , d + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def fact ( N ) : <NEWLINE> <INDENT> res = { } <NEWLINE> tmp = N <NEWLINE> for i in range ( 2 , int ( N ** 0.5 + 1 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> res [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> res [ tmp ] = 1 <NEWLINE> <DEDENT> if res == { } : <NEWLINE> <INDENT> res [ N ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> MOD = int ( 1e09 ) + 7 <NEWLINE> INF = int ( 1e15 ) <NEWLINE> <NL> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , to_ , id_ ) : <NEWLINE> <INDENT> self . to = to_ <NEWLINE> self . id = id_ <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = None <NEWLINE> G = None <NEWLINE> K = None <NEWLINE> <NL> <NL> def dfs ( to , c ) : <NEWLINE> <INDENT> global G <NEWLINE> global ans <NEWLINE> nc = c % K + 1 <NEWLINE> for g in G [ to ] : <NEWLINE> <INDENT> if ans [ g . id ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ g . id ] = nc <NEWLINE> dfs ( g . to , nc ) <NEWLINE> nc = nc % K + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> global G <NEWLINE> global ans <NEWLINE> global K <NEWLINE> N = Scanner . int ( ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = Scanner . map_int ( ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> G [ x ] . append ( Edge ( y , i ) ) <NEWLINE> G [ y ] . append ( Edge ( x , i ) ) <NEWLINE> <NL> <DEDENT> K = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> K = max ( K , len ( G [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 for _ in range ( N - 1 ) ] <NEWLINE> dfs ( 0 , 0 ) <NEWLINE> print ( K ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sum ( a ) <NEWLINE> y = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> y += a [ i ] ** 2 <NEWLINE> <NL> <DEDENT> ans = ( x ** 2 - y ) // 2 <NEWLINE> <NL> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> n = [ int ( i ) for i in n ] <NEWLINE> count = 0 <NEWLINE> <NL> a = n [ 0 ] * 1 <NEWLINE> b = n [ 1 ] <NEWLINE> c = n [ 2 ] * - 1 <NEWLINE> while n [ - 1 ] > 0 : <NEWLINE> <INDENT> if n [ 0 ] >= n [ - 1 ] and n [ 0 ] != 0 : <NEWLINE> <INDENT> count = n [ - 1 ] * 1 <NEWLINE> n [ - 1 ] = 0 <NEWLINE> <DEDENT> elif n [ 0 ] < n [ - 1 ] and n [ 0 ] != 0 : <NEWLINE> <INDENT> count += n [ 0 ] <NEWLINE> tmp = n [ 0 ] + n [ 1 ] <NEWLINE> n [ - 1 ] -= tmp <NEWLINE> n [ 0 ] = 0 <NEWLINE> <DEDENT> elif n [ 2 ] >= n [ - 1 ] : <NEWLINE> <INDENT> count += n [ - 1 ] * - 1 <NEWLINE> n [ - 1 ] = 0 <NEWLINE> <DEDENT> elif n [ 2 ] < n [ - 1 ] : <NEWLINE> <INDENT> count += c <NEWLINE> n [ - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> R = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> R [ i ] = set ( ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R [ A [ i ] - 1 ] . add ( B [ i ] - 1 ) <NEWLINE> R [ B [ i ] - 1 ] . add ( A [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> stack = set ( ) <NEWLINE> visited = set ( ) <NEWLINE> max_groups = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if not i in visited : <NEWLINE> <INDENT> stack . add ( i ) <NEWLINE> groups = 0 <NEWLINE> while True : <NEWLINE> <INDENT> current = stack . pop ( ) <NEWLINE> visited . add ( current ) <NEWLINE> groups += 1 <NEWLINE> stack |= ( R [ current ] - visited ) <NEWLINE> if not stack : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> max_groups = max ( max_groups , groups ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_groups ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> max_size = max ( map ( size , range ( n ) ) ) <NEWLINE> <NL> print ( max_size ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> i = 0 <NEWLINE> while i < a and i < len ( b ) : <NEWLINE> <INDENT> print ( end = str ( b [ i ] ) ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> if len ( b ) > a : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<NL> from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> linked_list = deque ( [ ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> cmd = line [ 0 ] <NEWLINE> <NL> if len ( line ) == 2 : <NEWLINE> <INDENT> value = line [ 1 ] <NEWLINE> <NL> <DEDENT> if cmd == <STRING> : <NEWLINE> <INDENT> linked_list . appendleft ( value ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if value in linked_list : <NEWLINE> <INDENT> linked_list . remove ( value ) <NEWLINE> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> linked_list . popleft ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> linked_list . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * linked_list ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 500 , 500 ) : <NEWLINE> <INDENT> for b in range ( - 500 , 500 ) : <NEWLINE> <INDENT> Y = a ** 5 - b ** 5 <NEWLINE> if Y == X : <NEWLINE> <INDENT> A = a <NEWLINE> B = b <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
M = 2019 <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> s_size = len ( S ) <NEWLINE> <NL> S . reverse ( ) <NEWLINE> x = 1 <NEWLINE> tot = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> cnt_list = [ 0 for i in range ( M ) ] <NEWLINE> <NL> for i in range ( s_size ) : <NEWLINE> <INDENT> cnt_list [ tot ] += 1 <NEWLINE> tot += ( ord ( S [ i ] ) - ord ( <STRING> ) ) * x <NEWLINE> tot %= M <NEWLINE> ans += cnt_list [ tot ] <NEWLINE> x = x * 10 % M <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> b . append ( B ) <NEWLINE> <NL> <DEDENT> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> graph [ a [ i ] ] . append ( b [ i ] ) <NEWLINE> graph [ b [ i ] ] . append ( a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> signposts = [ 0 ] * ( N + 1 ) <NEWLINE> signposts [ 1 ] = 1 <NEWLINE> while queue : <COMMENT> <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> if not signposts [ v ] : <NEWLINE> <INDENT> signposts [ v ] = u <NEWLINE> queue . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if all ( signposts [ 2 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , signposts [ 2 : ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = b . replace ( <STRING> , <STRING> ) <NEWLINE> if len ( b ) == 2 : <NEWLINE> <INDENT> b = b + <STRING> <NEWLINE> <DEDENT> b = int ( b ) <NEWLINE> ans = a * b <NEWLINE> if len ( str ( ans ) ) <= 2 : <NEWLINE> <INDENT> print ( math . floor ( ans / 100 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( str ( ans ) [ : - 2 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> string = input ( ) <NEWLINE> <NL> left = string [ : 0 ] <NEWLINE> right = string [ 0 : ] <NEWLINE> w , r = left . count ( <STRING> ) , right . count ( <STRING> ) <NEWLINE> count = max ( w , r ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> next_str = string [ i - 1 ] <NEWLINE> if next_str == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> tmp = max ( w , r ) <NEWLINE> if tmp < count : <NEWLINE> <INDENT> count = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def func ( amat , bmat , nm ) : <NEWLINE> <INDENT> for i in range ( nm [ 0 ] ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( nm [ 1 ] ) : <NEWLINE> <INDENT> ans += amat [ i ] [ j ] * bmat [ j ] [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> nm = input ( ) . split ( <STRING> ) <NEWLINE> nm = [ int ( i ) for i in nm ] <NEWLINE> amat = [ [ 0 for i in range ( nm [ 1 ] ) ] for j in range ( nm [ 0 ] ) ] <NEWLINE> bmat = [ [ 0 ] for i in range ( nm [ 1 ] ) ] <NEWLINE> <NL> for i in range ( nm [ 0 ] ) : <NEWLINE> <INDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> for j in range ( nm [ 1 ] ) : <NEWLINE> <INDENT> amat [ i ] [ j ] = int ( a [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( nm [ 1 ] ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> bmat [ i ] [ 0 ] = b <NEWLINE> <NL> <DEDENT> func ( amat , bmat , nm ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import collections <NEWLINE> import math <NEWLINE> <NL> import bisect <NEWLINE> <NL> class Vector2 ( collections . namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) ) : <NEWLINE> <NL> <INDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return Vector2 ( self . x + other . x , self . y + other . y ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return Vector2 ( self . x - other . x , self . y - other . y ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , scalar ) : <NEWLINE> <INDENT> return Vector2 ( self . x * scalar , self . y * scalar ) <NEWLINE> <NL> <DEDENT> def __neg__ ( self ) : <NEWLINE> <INDENT> return Vector2 ( - self . x , - self . y ) <NEWLINE> <NL> <DEDENT> def __pos__ ( self ) : <NEWLINE> <INDENT> return Vector2 ( + self . x , + self . y ) <NEWLINE> <NL> <DEDENT> def __abs__ ( self ) : <COMMENT> <NEWLINE> <INDENT> return math . sqrt ( float ( self . x * self . x + self . y * self . y ) ) <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , scalar ) : <NEWLINE> <INDENT> return Vector2 ( self . x / scalar , self . y / scalar ) <NEWLINE> <NL> <DEDENT> def abs2 ( self ) : <NEWLINE> <INDENT> return float ( self . x * self . x + self . y * self . y ) <NEWLINE> <NL> <DEDENT> def dot ( self , other ) : <COMMENT> <NEWLINE> <INDENT> return self . x * other . x + self . y * other . y <NEWLINE> <NL> <DEDENT> def cross ( self , other ) : <COMMENT> <NEWLINE> <INDENT> return self . x * other . y - self . y * other . x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getDistanceSP ( segment , point ) : <NEWLINE> <INDENT> p = point <NEWLINE> p1 , p2 = segment <NEWLINE> if ( p2 - p1 ) . dot ( p - p1 ) < 0 : <NEWLINE> <INDENT> return abs ( p - p1 ) <NEWLINE> <DEDENT> if ( p1 - p2 ) . dot ( p - p2 ) < 0 : <NEWLINE> <INDENT> return abs ( p - p2 ) <NEWLINE> <DEDENT> return abs ( ( p2 - p1 ) . cross ( p - p1 ) ) / abs ( p2 - p1 ) <NEWLINE> <NL> <NL> <DEDENT> def getDistance ( s1 , s2 ) : <NEWLINE> <INDENT> a , b = s1 <NEWLINE> c , d = s2 <NEWLINE> if intersect ( s1 , s2 ) : <COMMENT> <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return min ( getDistanceSP ( s1 , c ) , getDistanceSP ( s1 , d ) , getDistanceSP ( s2 , a ) , getDistanceSP ( s2 , b ) ) <NEWLINE> <NL> <NL> <DEDENT> def ccw ( p0 , p1 , p2 ) : <NEWLINE> <INDENT> a = p1 - p0 <NEWLINE> b = p2 - p0 <NEWLINE> if a . cross ( b ) > 0 : <NEWLINE> <INDENT> return 1 <COMMENT> <NEWLINE> <DEDENT> elif a . cross ( b ) < 0 : <NEWLINE> <INDENT> return - 1 <COMMENT> <NEWLINE> <DEDENT> elif a . dot ( b ) < 0 : <NEWLINE> <INDENT> return 2 <COMMENT> <NEWLINE> <DEDENT> elif abs ( a ) < abs ( b ) : <NEWLINE> <INDENT> return - 2 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def intersect ( s1 , s2 ) : <NEWLINE> <INDENT> a , b = s1 <NEWLINE> c , d = s2 <NEWLINE> return ccw ( a , b , c ) * ccw ( a , b , d ) <= 0 and ccw ( c , d , a ) * ccw ( c , d , b ) <= 0 <NEWLINE> <NL> <NL> <DEDENT> def project ( l , p ) : <NEWLINE> <INDENT> p1 , p2 = l <NEWLINE> base = p2 - p1 <NEWLINE> hypo = p - p1 <NEWLINE> return p1 + base * ( hypo . dot ( base ) / abs ( base ) ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> class Circle ( ) : <NEWLINE> <INDENT> def __init__ ( self , c , r ) : <NEWLINE> <INDENT> self . c = c <NEWLINE> self . r = r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getCrossPoints ( c , l ) : <NEWLINE> <INDENT> pr = project ( l , c . c ) <NEWLINE> p1 , p2 = l <NEWLINE> e = ( p2 - p1 ) / abs ( p2 - p1 ) <NEWLINE> base = math . sqrt ( c . r * c . r - ( pr - c . c ) . abs2 ( ) ) <NEWLINE> return [ pr + e * base , pr - e * base ] <NEWLINE> <NL> <NL> <DEDENT> def polar ( r , a ) : <NEWLINE> <INDENT> return Vector2 ( r * math . cos ( a ) , r * math . sin ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> def getCrossPointsCircle ( c1 , c2 ) : <NEWLINE> <INDENT> base = c2 . c - c1 . c <NEWLINE> d = abs ( base ) <NEWLINE> a = math . acos ( ( c1 . r ** 2 + d ** 2 - c2 . r ** 2 ) / ( 2 * c1 . r * d ) ) <NEWLINE> t = math . atan2 ( base . y , base . x ) <NEWLINE> return [ c1 . c + polar ( c1 . r , t + a ) , c1 . c + polar ( c1 . r , t - a ) ] <NEWLINE> <NL> <NL> <DEDENT> def contains ( g , p ) : <NEWLINE> <INDENT> n = len ( g ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = g [ i ] - p <NEWLINE> b = g [ ( i + 1 ) % n ] - p <NEWLINE> if a . cross ( b ) == 0 and a . dot ( b ) <= 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if a . y > b . y : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if a . y <= 0 and b . y > 0 and a . cross ( b ) > 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if x % 2 == 1 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def andrewScan ( s ) : <NEWLINE> <INDENT> u = [ ] <NEWLINE> l = [ ] <NEWLINE> s = sorted ( s , key = lambda x : ( x . x , x . y ) ) <NEWLINE> if len ( s ) < 3 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> u . append ( s [ 0 ] ) <NEWLINE> u . append ( s [ 1 ] ) <NEWLINE> l . append ( s [ - 1 ] ) <NEWLINE> l . append ( s [ - 2 ] ) <NEWLINE> <NL> for i in range ( 2 , len ( s ) ) : <NEWLINE> <INDENT> for n in range ( len ( u ) , 1 , - 1 ) : <NEWLINE> <INDENT> if ccw ( u [ n - 2 ] , u [ n - 1 ] , s [ i ] ) != 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u . pop ( ) <NEWLINE> <DEDENT> <DEDENT> u . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) - 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> for n in range ( len ( l ) , 1 , - 1 ) : <NEWLINE> <INDENT> if ccw ( l [ n - 2 ] , l [ n - 1 ] , s [ i ] ) != 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> l . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> ans = l + u [ 1 : - 1 ] <NEWLINE> ans . reverse ( ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> class EndPoint ( ) : <NEWLINE> <INDENT> def __init__ ( self , p , seg , st ) : <NEWLINE> <INDENT> self . p = p <NEWLINE> self . seg = seg <NEWLINE> self . st = st <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> EP = [ ] <NEWLINE> S = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == c : <COMMENT> <NEWLINE> <INDENT> EP . append ( EndPoint ( Vector2 ( a , min ( b , d ) ) , i , 0 ) ) <COMMENT> <NEWLINE> EP . append ( EndPoint ( Vector2 ( a , max ( b , d ) ) , i , 3 ) ) <COMMENT> <NEWLINE> S . append ( [ Vector2 ( a , max ( b , d ) ) , Vector2 ( a , min ( b , d ) ) ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> EP . append ( EndPoint ( Vector2 ( min ( a , c ) , b ) , i , 1 ) ) <COMMENT> <NEWLINE> EP . append ( EndPoint ( Vector2 ( max ( a , c ) , b ) , i , 2 ) ) <COMMENT> <NEWLINE> S . append ( [ Vector2 ( min ( a , c ) , b ) , Vector2 ( max ( a , c ) , b ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> EP = sorted ( EP , key = lambda x : ( x . p . y , x . st ) ) <NEWLINE> BT = [ ] <NEWLINE> cnt = 0 <NEWLINE> for e in EP : <NEWLINE> <INDENT> if e . st == 3 : <COMMENT> <NEWLINE> <INDENT> indx = bisect . bisect_left ( BT , e . p . x ) <NEWLINE> BT . pop ( indx ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif e . st == 0 : <COMMENT> <NEWLINE> <INDENT> bisect . insort_left ( BT , e . p . x ) <NEWLINE> <DEDENT> elif e . st == 1 : <COMMENT> <NEWLINE> <INDENT> l = bisect . bisect_left ( BT , S [ e . seg ] [ 0 ] . x ) <NEWLINE> r = bisect . bisect_right ( BT , S [ e . seg ] [ 1 ] . x ) <NEWLINE> cnt += r - l <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) - 1 for _ in range ( N ) ] <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = a [ x ] <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> if ans > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
import time <NEWLINE> <NL> s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mo = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> su = li [ 0 ] <NEWLINE> for i in range ( 1 , len ( li ) ) : <NEWLINE> <INDENT> ans += li [ i ] * su <NEWLINE> su += li [ i ] <NEWLINE> <DEDENT> print ( ans % mo ) <NEWLINE>
m , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dp = [ [ int ( 1e4 ) for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> i = n - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> for j in range ( m + 1 ) : <NEWLINE> <INDENT> if j == c [ i ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = 1 <NEWLINE> <DEDENT> elif j < c [ i ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i + 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - c [ i ] ] + 1 , dp [ i ] [ j - c [ i ] ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> i -= 1 <NEWLINE> <DEDENT> print ( dp [ 0 ] [ m ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> multi = 1 <NEWLINE> if ( <STRING> in A ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> multi *= int ( A [ i ] ) <NEWLINE> if multi > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( multi ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * X , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> i = bisect . bisect_left ( X , 0 ) <NEWLINE> L = max ( 0 , bisect . bisect_right ( X , 0 ) - K ) <NEWLINE> R = min ( N - 1 , bisect . bisect_left ( X , 0 ) + K - 1 ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( L , R - K + 2 ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> l = X [ i ] <NEWLINE> r = X [ i + K - 1 ] <NEWLINE> if r <= 0 : <NEWLINE> <INDENT> t = abs ( l ) <NEWLINE> <DEDENT> elif 0 <= l : <NEWLINE> <INDENT> t = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = min ( abs ( l ) , r ) * 2 + max ( abs ( l ) , r ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = min ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def Maximum_Profit ( n , A ) : <NEWLINE> <INDENT> Max = A [ 1 ] - A [ 0 ] <NEWLINE> Min = A [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> Max = max ( Max , A [ j ] - Min ) <NEWLINE> Min = min ( Min , A [ j ] ) <NEWLINE> <DEDENT> return Max <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> Max = Maximum_Profit ( n , A ) <NEWLINE> print ( Max ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> zero = 0 <NEWLINE> over = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> zero = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if over : break <NEWLINE> ans *= a [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> over = 1 <NEWLINE> <DEDENT> <DEDENT> if zero : print ( 0 ) <NEWLINE> elif over : print ( - 1 ) <NEWLINE> else : print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> an = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> total += ( an - A [ i ] ) * A [ i ] <NEWLINE> <DEDENT> s = total // 2 <NEWLINE> print ( s % mod ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ways = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> ways [ a ] . append ( b ) <NEWLINE> ways [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dq = deque ( [ 1 ] ) <NEWLINE> sign = [ None ] * ( N + 1 ) <NEWLINE> sign [ 0 ] = 0 <NEWLINE> sign [ 1 ] = 0 <NEWLINE> <NL> while ( dq ) : <NEWLINE> <INDENT> now = dq . popleft ( ) <NEWLINE> for w in ways [ now ] : <NEWLINE> <INDENT> if not sign [ w ] : <NEWLINE> <INDENT> sign [ w ] = now <NEWLINE> dq . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if None in sign : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( sign [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> copy_X = X . copy ( ) <NEWLINE> X . sort ( ) <NEWLINE> for i in copy_X : <NEWLINE> <INDENT> if ( i < X [ N // 2 ] ) : <NEWLINE> <INDENT> print ( X [ N // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X [ ( N // 2 ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A - K >= 0 : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( 0 , B + A - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> self . all_group_member = defaultdict ( list ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> self . all_group_member [ self . find ( i ) ] . append ( i ) <NEWLINE> <DEDENT> return self . all_group_member <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i != h - 1 : <NEWLINE> <INDENT> if s [ i ] [ j ] != s [ i + 1 ] [ j ] : <NEWLINE> <INDENT> uf . union ( ( i * w ) + j , ( i * w ) + j + w ) <NEWLINE> <DEDENT> <DEDENT> if j != w - 1 : <NEWLINE> <INDENT> if s [ i ] [ j ] != s [ i ] [ j + 1 ] : <NEWLINE> <INDENT> uf . union ( ( i * w ) + j , ( i * w ) + j + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for item in uf . all_group_members ( ) . values ( ) : <NEWLINE> <INDENT> A = 0 <NEWLINE> B = 0 <NEWLINE> for grid in item : <NEWLINE> <INDENT> i , j = divmod ( grid , w ) <NEWLINE> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> ans += A * B <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> sum_ = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum_ += gcd ( i , gcd ( j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa = str ( input ( ) ) <NEWLINE> if aa in a : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ aa ] = i <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import numpy as np <NEWLINE> INF = 10 ** 18 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def calc ( A ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ans = A . pop ( ) <NEWLINE> for a in A : <NEWLINE> <NL> <NL> <INDENT> ans *= a <NEWLINE> if ans > INF : <NEWLINE> <COMMENT> <NL> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( calc ( A ) ) <NEWLINE>
class dice : <NEWLINE> <INDENT> def __init__ ( self , label ) : <NEWLINE> <INDENT> self . spots = label <NEWLINE> <NL> <DEDENT> def roll ( self , way ) : <NEWLINE> <INDENT> if way == <STRING> : <NEWLINE> <INDENT> self . spots = [ self . spots [ 1 ] , self . spots [ 5 ] , self . spots [ 2 ] , self . spots [ 3 ] , self . spots [ 0 ] , self . spots [ 4 ] ] <NEWLINE> <DEDENT> if way == <STRING> : <NEWLINE> <INDENT> self . spots = [ self . spots [ 3 ] , self . spots [ 1 ] , self . spots [ 0 ] , self . spots [ 5 ] , self . spots [ 4 ] , self . spots [ 2 ] ] <NEWLINE> <DEDENT> if way == <STRING> : <NEWLINE> <INDENT> self . spots = [ self . spots [ 2 ] , self . spots [ 1 ] , self . spots [ 5 ] , self . spots [ 0 ] , self . spots [ 4 ] , self . spots [ 3 ] ] <NEWLINE> <DEDENT> if way == <STRING> : <NEWLINE> <INDENT> self . spots = [ self . spots [ 4 ] , self . spots [ 0 ] , self . spots [ 2 ] , self . spots [ 3 ] , self . spots [ 5 ] , self . spots [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> return self . spots <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dice_1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> label = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice_2 = [ ] <NEWLINE> <NL> rotation = dice ( label ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> dice_2 . append ( rotation . output ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> rotation . roll ( <STRING> ) <NEWLINE> dice_2 . append ( rotation . output ( ) ) <NEWLINE> <DEDENT> rotation . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> rotation . roll ( <STRING> ) <NEWLINE> rotation . roll ( <STRING> ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> dice_2 . append ( rotation . output ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> rotation . roll ( <STRING> ) <NEWLINE> dice_2 . append ( rotation . output ( ) ) <NEWLINE> <DEDENT> rotation . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> if dice_1 in dice_2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> R , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ 0 , 0 ] <NEWLINE> <NL> mv = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> MAP = [ ] <NEWLINE> flg = 0 <NEWLINE> block = 0 <NEWLINE> for _ in range ( R ) : <NEWLINE> <INDENT> t = list ( input ( ) ) <NEWLINE> block += t . count ( <STRING> ) <NEWLINE> MAP . append ( t ) <NEWLINE> <DEDENT> stack = deque ( [ S ] ) <NEWLINE> MAP_c = [ [ None ] * C for _ in range ( R ) ] <NEWLINE> MAP_c [ 0 ] [ 0 ] = 1 <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . popleft ( ) <NEWLINE> for m in mv : <NEWLINE> <INDENT> u = [ v [ 0 ] + m [ 0 ] , v [ 1 ] + m [ 1 ] ] <NEWLINE> if u [ 0 ] >= 0 and u [ 0 ] < R and u [ 1 ] >= 0 and u [ 1 ] < C and MAP [ u [ 0 ] ] [ u [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> MAP [ u [ 0 ] ] [ u [ 1 ] ] = <STRING> <NEWLINE> MAP_c [ u [ 0 ] ] [ u [ 1 ] ] = MAP_c [ v [ 0 ] ] [ v [ 1 ] ] + 1 <NEWLINE> stack . append ( u ) <NEWLINE> if u == [ R - 1 , C - 1 ] : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> a = MAP_c [ R - 1 ] [ C - 1 ] <NEWLINE> print ( R * C - a - block ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if W == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif H == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = W * ( H // 2 ) <NEWLINE> if H % 2 == 1 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> ans += W // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += W // 2 + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> A [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> p = [ K - Q ] * N <NEWLINE> <NL> for a , b in zip ( A , p ) : <NEWLINE> <INDENT> print ( <STRING> if 0 < a + b else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> K = input ( ) <NEWLINE> if int ( K ) % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> S = int ( <STRING> * ( len ( K ) ) ) <NEWLINE> ans = len ( K ) <NEWLINE> K = int ( K ) <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if S % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = ( S * 10 ) % K + 7 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<NL> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lInfo = defaultdict ( int ) <NEWLINE> rInfo = defaultdict ( int ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lInfo [ a [ i ] + i ] += 1 <NEWLINE> rInfo [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for k in lInfo . keys ( ) : <NEWLINE> <INDENT> cnt += lInfo [ k ] * rInfo [ k ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> a = a . replace ( <STRING> , <STRING> ) <NEWLINE> a = a . replace ( <STRING> , <STRING> ) <NEWLINE> a = a . replace ( <STRING> , <STRING> ) <NEWLINE> a = tuple ( map ( int , list ( a ) ) ) <NEWLINE> b = collections . Counter ( a ) <NEWLINE> ans = b [ 3 ] * b [ 1 ] * b [ 2 ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ i ] == a [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = j * 2 - i <NEWLINE> if c < n : <NEWLINE> <INDENT> if a [ i ] + a [ j ] + a [ c ] == 6 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> all_sum = ( sum ( a ) ** 2 ) <NEWLINE> diff = [ ( a [ i ] ** 2 ) for i in range ( n ) ] <NEWLINE> <NL> ans = ( all_sum - sum ( diff ) ) // 2 <NEWLINE> <NL> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ int ( l ) for l in input ( ) . split ( ) ] <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( ls ) <NEWLINE> <NL> Ls = list ( set ( ls ) ) <NEWLINE> Ls . sort ( ) <NEWLINE> <NL> if len ( Ls ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> LsR = sorted ( Ls ) <NEWLINE> while len ( LsR ) >= 3 : <NEWLINE> <INDENT> L1 = LsR [ 0 ] <NEWLINE> Ls1 = LsR [ 1 : ] <NEWLINE> while len ( Ls1 ) >= 2 : <NEWLINE> <INDENT> L2 = Ls1 [ 0 ] <NEWLINE> Ls2 = Ls1 [ 1 : ] <NEWLINE> for L3 in Ls2 : <NEWLINE> <INDENT> if L3 < L1 + L2 and L3 > abs ( L1 - L2 ) : <NEWLINE> <INDENT> ans += c [ L1 ] * c [ L2 ] * c [ L3 ] <NEWLINE> <DEDENT> <DEDENT> Ls1 = Ls1 [ 1 : ] <NEWLINE> <DEDENT> LsR = LsR [ 1 : ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from sys import stdin <NEWLINE> n = int ( input ( ) ) <NEWLINE> ddl = deque ( ) <NEWLINE> for i in stdin : <NEWLINE> <INDENT> inp = i . split ( ) <NEWLINE> if len ( inp ) == 2 : <NEWLINE> <INDENT> op , data = inp <NEWLINE> data = int ( data ) <NEWLINE> <DEDENT> else : op , data = inp [ 0 ] , None <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> ddl . appendleft ( data , ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ddl . remove ( data ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ddl . popleft ( ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ddl . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( item ) for item in ddl ] ) ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> n , m , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ u ] . append ( ( v , a , b ) ) <NEWLINE> e [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <DEDENT> S = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> S [ s ] = 0 <NEWLINE> h = [ ] <NEWLINE> heappush ( h , [ 0 , s ] ) <NEWLINE> while h : <NEWLINE> <INDENT> d , now = heappop ( h ) <NEWLINE> for nex , a , b in e [ now ] : <NEWLINE> <INDENT> if d + a < S [ nex ] : <NEWLINE> <INDENT> S [ nex ] = d + a <NEWLINE> heappush ( h , [ d + a , nex ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> T = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> T [ t ] = 0 <NEWLINE> h = [ ] <NEWLINE> heappush ( h , [ 0 , t ] ) <NEWLINE> while h : <NEWLINE> <INDENT> d , now = heappop ( h ) <NEWLINE> for nex , a , b in e [ now ] : <NEWLINE> <INDENT> if d + b < T [ nex ] : <NEWLINE> <INDENT> T [ nex ] = d + b <NEWLINE> heappush ( h , [ d + b , nex ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> cost = 10 ** 15 <NEWLINE> now = 0 <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> now = max ( now , cost - S [ i ] - T [ i ] ) <NEWLINE> ans [ i ] = now <NEWLINE> <DEDENT> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> SUM = 0 <NEWLINE> map = [ 0 ] * 100001 <NEWLINE> for i in [ int ( i ) for i in input ( ) . split ( ) ] : <NEWLINE> <INDENT> SUM += i <NEWLINE> map [ i ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> [ b , c ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> SUM += ( c - b ) * map [ b ] <NEWLINE> print ( SUM ) <NEWLINE> map [ c ] += map [ b ] <NEWLINE> map [ b ] = 0 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = input ( ) . split ( ) <NEWLINE> <NL> root = [ 1 ] <NEWLINE> <NL> record = [ - 1 ] * N <NEWLINE> break_flag = 0 <NEWLINE> for n in range ( K ) : <NEWLINE> <INDENT> new = int ( A_list [ int ( root [ n ] ) - 1 ] ) <NEWLINE> if record [ new - 1 ] < 0 : <NEWLINE> <INDENT> record [ new - 1 ] = 1 <NEWLINE> root . append ( new ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = root . index ( new ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( new ) <NEWLINE> break_flag = 1 <NEWLINE> <NL> <DEDENT> if break_flag == 0 : <NEWLINE> <INDENT> pre = len ( root [ : ind ] ) <NEWLINE> roop = len ( root ) - pre <NEWLINE> <NL> print ( root [ ind : ] [ ( K - pre ) % roop ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 10 ** 9 <NEWLINE> for i in range ( 2 , S ) : <NEWLINE> <INDENT> if S % i != 0 : <NEWLINE> <INDENT> x = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> res = [ S ] * K + [ x ] * ( N - K ) <NEWLINE> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import copy <NEWLINE> <NL> def dfs ( now , group , groups , edges ) : <NEWLINE> <INDENT> if groups [ now ] != - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> groups [ now ] = group <NEWLINE> cnt = 1 <NEWLINE> for to in edges [ now ] : <NEWLINE> <INDENT> cnt += dfs ( to , group , groups , edges ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ list ( ) for i in range ( n ) ] <NEWLINE> ngs = [ list ( ) for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c , d = c - 1 , d - 1 <NEWLINE> ngs [ c ] . append ( d ) <NEWLINE> ngs [ d ] . append ( c ) <NEWLINE> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> groups = [ - 1 for i in range ( n ) ] <NEWLINE> nodes_cnt = list ( ) <NEWLINE> <NL> ans = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if groups [ i ] == - 1 : <NEWLINE> <INDENT> nodes_cnt . append ( dfs ( i , cnt , groups , edges ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans [ i ] = nodes_cnt [ groups [ i ] ] - len ( edges [ i ] ) - 1 <NEWLINE> for ng in ngs [ i ] : <NEWLINE> <INDENT> if groups [ i ] == groups [ ng ] : <NEWLINE> <INDENT> ans [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> check = 1 <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> ans [ li [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> length = len ( s ) <NEWLINE> a = [ 0 ] * length <NEWLINE> d = [ 0 ] * length <NEWLINE> ans = [ 0 ] * 2019 <NEWLINE> x = 10 <NEWLINE> <NL> a [ 0 ] = int ( s [ 0 ] ) <NEWLINE> d [ 0 ] = a [ 0 ] <NEWLINE> ans [ d [ 0 ] ] += 1 <NEWLINE> <NL> for i in range ( 1 , length ) : <NEWLINE> <INDENT> a [ i ] = int ( s [ i ] ) * x % 2019 <NEWLINE> d [ i ] = ( d [ i - 1 ] + a [ i ] ) % 2019 <NEWLINE> ans [ d [ i ] ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans_c = [ i for i in ans if i != 0 ] <NEWLINE> <NL> print ( int ( sum ( [ ans_c [ i ] * ( ans_c [ i ] - 1 ) for i in range ( len ( ans_c ) ) ] ) / 2 ) + ans [ 0 ] ) <NEWLINE>
count = 0 <NEWLINE> list1 = [ ] <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( list1 ) ) : <NEWLINE> <INDENT> for n in range ( len ( list1 ) - i - 1 ) : <NEWLINE> <INDENT> if ( list1 [ n ] > list1 [ n + 1 ] ) : <NEWLINE> <INDENT> tmp = list1 [ n ] <NEWLINE> list1 [ n ] = list1 [ n + 1 ] <NEWLINE> list1 [ n + 1 ] = tmp <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( str ( x ) for x in list1 ) ) <NEWLINE> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ input ( ) . rstrip ( ) for _ in range ( H ) ] <NEWLINE> cut = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> cnt = 0 <NEWLINE> for ih in range ( H ) : <NEWLINE> <INDENT> if s [ ih ] . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> if s [ ih ] [ iw ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cut [ ih ] [ iw ] = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W - 1 ) : <NEWLINE> <INDENT> if cut [ ih ] [ iw + 1 ] == 0 : <NEWLINE> <INDENT> cut [ ih ] [ iw + 1 ] = cut [ ih ] [ iw ] <NEWLINE> <DEDENT> <DEDENT> for iw in range ( W - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if cut [ ih ] [ iw - 1 ] == 0 : <NEWLINE> <INDENT> cut [ ih ] [ iw - 1 ] = cut [ ih ] [ iw ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H - 1 ) : <NEWLINE> <INDENT> if cut [ ih + 1 ] [ 0 ] == 0 : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> cut [ ih + 1 ] [ iw ] = cut [ ih ] [ iw ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if cut [ ih - 1 ] [ 0 ] == 0 : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> cut [ ih - 1 ] [ iw ] = cut [ ih ] [ iw ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( * cut [ i ] ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd3 ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans *= 6 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd3 ( i , i , i ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd3 ( i , i , j ) <NEWLINE> ans += gcd3 ( i , i , j ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd3 ( i , j , j ) <NEWLINE> ans += gcd3 ( i , j , j ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd3 ( i , j , i ) <NEWLINE> ans += gcd3 ( i , j , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Current_Sum = 0 <NEWLINE> if K <= A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif K <= ( A + B ) : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= ( A + B ) <NEWLINE> ans = A - K <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
from math import gcd <NEWLINE> <NL> <NL> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> temp = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp . append ( gcd ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> import collections <NEWLINE> c = collections . Counter ( temp ) <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in c . keys ( ) : <NEWLINE> <INDENT> ans += gcd ( i , j ) * c [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def CountingSort ( A , B , num ) : <NEWLINE> <NL> <INDENT> k = max ( A ) <NEWLINE> C = [ 0 for _ in range ( k + 1 ) ] <NEWLINE> <COMMENT> <NL> for i in A : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> C [ j ] += C [ j - 1 ] <NEWLINE> <DEDENT> for h in range ( num - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ h ] ] - 1 ] = A [ h ] <NEWLINE> C [ A [ h ] ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> B = [ 0 for _ in range ( num + 1 ) ] <NEWLINE> CountingSort ( A , B , num ) <NEWLINE> <NL> B . pop ( ) <NEWLINE> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE> <NL> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l_r = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> memo = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> memo [ i + 1 ] = memo [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i + 1 ] = memo [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for l , r in l_r : <NEWLINE> <INDENT> print ( memo [ r - 1 ] - memo [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ 26 ** x for x in range ( 1 , 12 ) ] <NEWLINE> <NL> d = 0 <NEWLINE> r = 0 <NEWLINE> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> if n <= d + data [ i ] : <NEWLINE> <INDENT> r = i + 1 <NEWLINE> n -= ( d + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> d += data [ i ] <NEWLINE> <NL> <DEDENT> kurai = [ 26 ** x for x in range ( r ) ] [ : : - 1 ] <NEWLINE> ans = [ 0 ] * r <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> ans [ i ] = min ( n // kurai [ i ] , 25 ) <NEWLINE> n -= kurai [ i ] * ans [ i ] <NEWLINE> <NL> <DEDENT> alpha = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> ans = [ alpha [ a ] for a in ans ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> f = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if f <= n : <NEWLINE> <INDENT> ans [ f ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def calc_cusum ( n ) : <NEWLINE> <INDENT> cusum = [ 0 ] * ( n + 1 ) <NEWLINE> arr = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cusum [ i + 1 ] = cusum [ i ] + int ( arr [ i ] ) <NEWLINE> <NL> <DEDENT> return cusum <NEWLINE> <NL> <NL> <DEDENT> def identify_position ( i , j ) : <NEWLINE> <INDENT> global a <NEWLINE> global b <NEWLINE> global k <NEWLINE> global m <NEWLINE> <NL> if a [ i ] + b [ j ] > k : <NEWLINE> <INDENT> while j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while j < m and a [ i ] + b [ j + 1 ] <= k : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return j <NEWLINE> <NL> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = calc_cusum ( n ) <NEWLINE> b = calc_cusum ( m ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> j = identify_position ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> As . sort ( ) <NEWLINE> <NL> setA = set ( As ) <NEWLINE> setDel = set ( ) <NEWLINE> <NL> cands = [ ] <NEWLINE> <NL> for a in As : <NEWLINE> <INDENT> if a in setDel : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while a * i <= As [ - 1 ] : <NEWLINE> <INDENT> if a * i in setA : <NEWLINE> <INDENT> setDel . add ( a * i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> cands . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dic = { } <NEWLINE> for a in As : <NEWLINE> <INDENT> if not a in dic : <NEWLINE> <INDENT> dic [ a ] = 0 <NEWLINE> <DEDENT> dic [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in cands : <NEWLINE> <INDENT> if dic [ x ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> check = [ 0 ] * N <NEWLINE> tele_lis = [ ] <NEWLINE> start = [ ] <NEWLINE> def tele ( x ) : <NEWLINE> <INDENT> check [ x - 1 ] = 1 <NEWLINE> tele_lis . append ( x ) <NEWLINE> if check [ A [ x - 1 ] - 1 ] == 0 : <NEWLINE> <INDENT> tele ( A [ x - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start . append ( A [ x - 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> tele ( 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if start [ 0 ] == tele_lis [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i >= K : <NEWLINE> <INDENT> print ( tele_lis [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tele_lis [ i : : ] [ ( K - i ) % ( sum ( check ) - i ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_ans = sum ( Ai ) <NEWLINE> ans = 0 <NEWLINE> mod = 1000000007 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_ans -= Ai [ i ] <NEWLINE> ans += sum_ans * Ai [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> <NL> def solve ( N , L , edges , queries ) : <NEWLINE> <NL> <INDENT> graph = np . zeros ( ( N , N ) , dtype = int ) <NEWLINE> for a , b , c in edges : <NEWLINE> <INDENT> graph [ a - 1 , b - 1 ] = c <NEWLINE> graph [ b - 1 , a - 1 ] = c <NEWLINE> <NL> <DEDENT> dist = floyd_warshall ( graph , directed = False ) <NEWLINE> dist = ( dist <= L ) <NEWLINE> dist = floyd_warshall ( dist , directed = False ) <NEWLINE> res = [ ] <NEWLINE> for a , b in queries : <NEWLINE> <INDENT> d = dist [ a - 1 , b - 1 ] <NEWLINE> res . append ( int ( d - 1 ) if d != float ( <STRING> ) else - 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> t = read ( ) . split ( ) <NEWLINE> <NL> N , M , L = map ( int , t [ : 3 ] ) <NEWLINE> <NL> m = map ( int , t [ 3 : M * 3 + 3 ] ) <NEWLINE> edges = zip ( m , m , m ) <NEWLINE> <NL> Q = int ( t [ M * 3 + 3 ] ) <NEWLINE> m = map ( int , t [ M * 3 + 4 : ] ) <NEWLINE> queries = zip ( m , m ) <NEWLINE> <NL> print ( * solve ( N , L , edges , queries ) , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = 10 ** 18 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > a : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> o = 0 <NEWLINE> g = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> g . append ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> g . sort ( ) <NEWLINE> for i in range ( len ( g ) - 1 ) : <NEWLINE> <INDENT> if g [ i ] == g [ i + 1 ] : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( g ) + o ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> score = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> print ( <STRING> if score [ i - K ] < score [ i ] else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= c [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> left = <STRING> <NEWLINE> right = <STRING> <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> qq = [ x for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if qq [ 0 ] == <STRING> : <NEWLINE> <INDENT> t = int ( qq [ 0 ] ) <NEWLINE> f = int ( qq [ 1 ] ) <NEWLINE> c = qq [ 2 ] <NEWLINE> <NL> if cnt % 2 == 1 and f == 1 : <NEWLINE> <INDENT> right = right + c <NEWLINE> <NL> <DEDENT> elif cnt % 2 == 1 and f == 2 : <NEWLINE> <NL> <INDENT> left = c + left <NEWLINE> <DEDENT> elif cnt % 2 == 0 and f == 2 : <NEWLINE> <NL> <INDENT> right = right + c <NEWLINE> <DEDENT> elif cnt % 2 == 0 and f == 1 : <NEWLINE> <NL> <INDENT> left = c + left <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = left + s + right <NEWLINE> if cnt % 2 == 1 : <NEWLINE> <INDENT> print ( s [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list [ 0 ] <NEWLINE> B = list [ 1 ] <NEWLINE> C = list [ 2 ] <NEWLINE> K = list [ 3 ] <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K - A <= B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
def bfs ( G , s ) : <NEWLINE> <INDENT> d = { key : - 1 for key in G . keys ( ) } <NEWLINE> d [ s ] = 0 <NEWLINE> Q = [ s ] <NEWLINE> while len ( Q ) > 0 : <NEWLINE> <INDENT> u = Q . pop ( 0 ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if d [ v ] < 0 : <NEWLINE> <INDENT> d [ v ] = d [ u ] + 1 <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> G = { } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = tmp . pop ( 0 ) <NEWLINE> k = tmp . pop ( 0 ) <NEWLINE> G [ u ] = tmp <NEWLINE> <DEDENT> d = bfs ( G , 1 ) <NEWLINE> for node in G : <NEWLINE> <INDENT> print ( <STRING> . format ( node , d [ node ] ) ) <NEWLINE> <DEDENT> <DEDENT>
data = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> count = int ( input ( ) ) <NEWLINE> <NL> for c in range ( count ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) if b < 4 - 1 else print ( end = <STRING> ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> print ( ( a * n ) // b ) <NEWLINE> <DEDENT> elif b <= n : <NEWLINE> <INDENT> print ( ( a * ( b - 1 ) ) // b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> def caesar_decrypt ( N , cipher ) : <NEWLINE> <INDENT> text = <STRING> <NEWLINE> for char in cipher : <NEWLINE> <INDENT> if <STRING> <= char <= <STRING> : <NEWLINE> <INDENT> k = ( ord ( char ) - 97 - N ) % 26 <NEWLINE> text += chr ( 97 + k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> text += char <NEWLINE> <DEDENT> <DEDENT> return text <NEWLINE> <NL> <NL> <DEDENT> for cipher in sys . stdin : <NEWLINE> <INDENT> cipher = cipher . strip ( ) <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> decrypted = caesar_decrypt ( k , cipher ) <NEWLINE> if <STRING> in decrypted or <STRING> in decrypted or <STRING> in decrypted : <NEWLINE> <INDENT> print ( decrypted ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> d_list = [ ] <NEWLINE> sum_d = 0 <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> A = [ 1 for i in range ( N ) ] <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ abcd [ i ] [ 1 ] - 1 ] - A [ abcd [ i ] [ 0 ] - 1 ] == abcd [ i ] [ 2 ] : <NEWLINE> <INDENT> d_list . append ( abcd [ i ] [ 3 ] ) <NEWLINE> <DEDENT> <DEDENT> if sum_d <= sum ( d_list ) : <NEWLINE> <INDENT> sum_d = sum ( d_list ) <NEWLINE> <DEDENT> d_list . clear ( ) <NEWLINE> <DEDENT> print ( sum_d ) <NEWLINE>
n , * s = map ( str , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> mydict = { } <NEWLINE> for i in set ( s ) : <NEWLINE> <INDENT> mydict [ i ] = 1 <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> mydict [ i ] += 1 <NEWLINE> <STRING> <NEWLINE> <DEDENT> v_max = max ( mydict . values ( ) ) <NEWLINE> for i in sorted ( [ kv [ 0 ] for kv in mydict . items ( ) if kv [ 1 ] == v_max ] ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def cuml ( li ) : <NEWLINE> <INDENT> rlis = [ 0 ] <NEWLINE> <NL> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> rlis . append ( rlis [ - 1 ] + li [ i ] ) <NEWLINE> <NL> <DEDENT> return rlis <NEWLINE> <NL> <NL> <DEDENT> A_cuml = cuml ( A ) <NEWLINE> B_cuml = cuml ( B ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for a in range ( len ( A_cuml ) ) : <NEWLINE> <INDENT> rest = K - A_cuml [ a ] <NEWLINE> if rest < 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> b = bisect . bisect_right ( B_cuml , K - A_cuml [ a ] ) <NEWLINE> <NL> res = max ( res , a + b - 1 ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <DEDENT> p = set ( p ) <NEWLINE> pp = set ( [ item for item in range ( 0 , 105 ) if item not in p ] ) <NEWLINE> v = 3000 <NEWLINE> ans = - 1 <NEWLINE> for item in pp : <NEWLINE> <INDENT> if v > abs ( x - item ) : <NEWLINE> <INDENT> v = abs ( x - item ) <NEWLINE> ans = item <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = sum ( a [ 0 : k ] ) <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> nxt = ans - a [ i - 1 ] + a [ i + k - 1 ] <NEWLINE> if ans < nxt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ans = nxt <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = collections . Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( L [ i + 1 ] ) <NEWLINE> <DEDENT>
print ( int ( input ( ) ) ** 3 ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( pi * r ** 2 , 2 * pi * r ) ) <NEWLINE>
A , B , K = input ( ) . split ( <STRING> ) <NEWLINE> A , B , K = int ( A ) , int ( B ) , int ( K ) <NEWLINE> <NL> res = [ ] <NEWLINE> <NL> for i in range ( A , 0 , - 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res [ K - 1 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <NL> def query_value ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> pos = s . find ( <STRING> ) <NEWLINE> if ( pos == - 1 ) : <NEWLINE> <INDENT> return int ( s ) * 10 ** 9 <NEWLINE> <DEDENT> ans = int ( s [ : pos ] ) <NEWLINE> <COMMENT> <NL> for i in range ( pos + 1 , pos + 10 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if i >= len ( s ) : <NEWLINE> <INDENT> ans *= 10 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans = ans * 10 + ord ( s [ i ] ) - ord ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = 18 <NEWLINE> A = [ ] <NEWLINE> for i in range ( 2 * n ) : <NEWLINE> <INDENT> A . append ( [ 0 ] * ( 2 * n ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = query_value ( input ( ) ) <NEWLINE> <COMMENT> <NL> p2 = 0 <NEWLINE> p5 = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> p2 += 1 <NEWLINE> a /= 2 <NEWLINE> <DEDENT> while a % 5 == 0 : <NEWLINE> <INDENT> p5 += 1 <NEWLINE> a /= 5 <NEWLINE> <DEDENT> A [ p2 ] [ p5 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for x1 in range ( 2 * n ) : <NEWLINE> <INDENT> for y1 in range ( 2 * n ) : <NEWLINE> <INDENT> for x2 in range ( 2 * n ) : <NEWLINE> <INDENT> for y2 in range ( 2 * n ) : <NEWLINE> <INDENT> if x1 == x2 and y1 == y2 : <NEWLINE> <INDENT> if A [ x1 ] [ y1 ] > 0 and x1 + x2 >= n and y1 + y2 >= n : <NEWLINE> <COMMENT> <NL> <INDENT> ans += A [ x1 ] [ y1 ] * ( A [ x2 ] [ y2 ] - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A [ x1 ] [ y1 ] > 0 and A [ x2 ] [ y2 ] > 0 and x1 + x2 >= n and y1 + y2 >= n : <NEWLINE> <COMMENT> <NL> <INDENT> ans += A [ x1 ] [ y1 ] * A [ x2 ] [ y2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE> <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
string = list ( input ( ) ) <NEWLINE> times = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( times ) : <NEWLINE> <INDENT> order = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> replace_string = order [ 3 ] <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> for j in range ( int ( order [ 1 ] ) , int ( order [ 2 ] ) + 1 ) : <NEWLINE> <INDENT> string [ j ] = replace_string [ count ] <NEWLINE> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> reverse_string = string [ int ( order [ 1 ] ) : int ( order [ 2 ] ) + 1 ] <NEWLINE> reverse_string . reverse ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> string = string [ : int ( order [ 1 ] ) ] + reverse_string + string [ int ( order [ 2 ] ) + 1 : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> . join ( string [ int ( order [ 1 ] ) : int ( order [ 2 ] ) + 1 ] ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( s ) / n <NEWLINE> z = sum ( [ ( float ( s [ i ] ) - m ) ** 2 for i in range ( n ) ] ) <NEWLINE> b = z / n <NEWLINE> print ( <STRING> . format ( math . sqrt ( b ) ) ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> if n == 1 and x == a [ 0 ] : <NEWLINE> <INDENT> print ( max ( x , 10 ** 9 - x ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( abs ( a [ i ] - x ) ) <NEWLINE> <DEDENT> import math <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = math . gcd ( c , b [ i ] ) <NEWLINE> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> y = [ 0 for _ in range ( 10 ** 4 + 1 ) ] <NEWLINE> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> for u in range ( 1 , 100 ) : <NEWLINE> <INDENT> a = j * j + k * k + u * u + j * k + k * u + u * j <NEWLINE> if a <= 10 ** 4 : <NEWLINE> <INDENT> y [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for o in range ( n ) : <NEWLINE> <INDENT> print ( y [ o ] ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> l . append ( gcd ( a [ i ] , l [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> ans = l [ n - 2 ] <NEWLINE> r = a [ n - 1 ] <NEWLINE> for i in range ( n - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> r = gcd ( r , a [ i + 1 ] ) <NEWLINE> ans = max ( ans , gcd ( l [ i - 1 ] , r ) ) <NEWLINE> <DEDENT> ans = max ( ans , gcd ( r , a [ 1 ] ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = int ( 1 ) <NEWLINE> ans = int ( 0 ) <NEWLINE> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> ans == 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D *= A [ i ] <NEWLINE> if D > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = D <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> t_l = len ( t ) <NEWLINE> diff_min = 999999999 <NEWLINE> <NL> def diff_str ( s1 , s2 ) : <NEWLINE> <INDENT> diff_c = 0 <NEWLINE> for j in range ( len ( s1 ) ) : <NEWLINE> <INDENT> if s1 [ j ] != s2 [ j ] : <NEWLINE> <INDENT> diff_c += 1 <NEWLINE> <DEDENT> <DEDENT> return diff_c <NEWLINE> <NL> <DEDENT> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> diff_min = diff_str ( s , t ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) - t_l ) : <NEWLINE> <INDENT> seq = s [ i : i + t_l ] <NEWLINE> diff_c = diff_str ( seq , t ) <NEWLINE> if diff_c < diff_min : <NEWLINE> <INDENT> diff_min = diff_c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( diff_min ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> S . append ( A ) <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10010010 ) <NEWLINE> <NL> def abc106_d ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> table [ l ] [ r ] += 1 <NEWLINE> <DEDENT> query = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> dp = [ [ - 1 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> <NL> def calc ( l , r ) : <NEWLINE> <INDENT> nonlocal dp <NEWLINE> if l == 0 or r == 0 : return 0 <NEWLINE> if dp [ l ] [ r ] != - 1 : return dp [ l ] [ r ] <NEWLINE> res = calc ( l - 1 , r ) + calc ( l , r - 1 ) - calc ( l - 1 , r - 1 ) + table [ l ] [ r ] <NEWLINE> dp [ l ] [ r ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for p , q in query : <NEWLINE> <INDENT> ans = calc ( q , q ) - calc ( q , p - 1 ) - calc ( p - 1 , q ) + calc ( p - 1 , p - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc106_d ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> seen = set ( ) <NEWLINE> loop_list = [ ] <NEWLINE> for start in range ( n ) : <NEWLINE> <INDENT> v = start <NEWLINE> loop = [ ] <NEWLINE> while v not in seen : <NEWLINE> <INDENT> seen . add ( v ) <NEWLINE> loop . append ( c [ v ] ) <NEWLINE> v = p [ v ] <NEWLINE> <DEDENT> seen . add ( v ) <NEWLINE> if loop : <NEWLINE> <INDENT> loop_list . append ( np . array ( loop ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = min ( c ) <NEWLINE> for loop in loop_list : <NEWLINE> <INDENT> loop_len = len ( loop ) <NEWLINE> loop_num = k // loop_len <NEWLINE> loop_mod = k % loop_len <NEWLINE> loop_sum = sum ( loop ) <NEWLINE> table = np . zeros ( ( loop_len , loop_len ) , dtype = int ) <NEWLINE> table [ 0 ] = loop . cumsum ( ) <NEWLINE> table [ : , - 1 ] = loop_sum <NEWLINE> for i in range ( loop_len - 1 ) : <NEWLINE> <INDENT> table [ i + 1 , : - 1 ] = ( table [ i ] - loop [ i ] ) [ 1 : ] <NEWLINE> <DEDENT> ans = max ( table [ : , : min ( loop_len , k ) ] . max ( ) , ans ) <NEWLINE> if loop_num > 0 : <NEWLINE> <INDENT> ans = max ( loop_sum * ( loop_num - 1 ) + table [ : , : loop_len ] . max ( ) , ans ) <NEWLINE> if loop_mod > 0 : <NEWLINE> <INDENT> ans = max ( loop_sum * loop_num + table [ : , : loop_mod ] . max ( ) , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> H_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> road_list = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> road_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> flg_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> flg_list . append ( 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <STRING> <NEWLINE> for road in road_list : <NEWLINE> <INDENT> if H_list [ road [ 0 ] - 1 ] < H_list [ road [ 1 ] - 1 ] : <NEWLINE> <INDENT> flg_list [ road [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H_list [ road [ 1 ] - 1 ] < H_list [ road [ 0 ] - 1 ] : <NEWLINE> <INDENT> flg_list [ road [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg_list [ road [ 0 ] - 1 ] = 0 <NEWLINE> flg_list [ road [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if flg_list [ i ] == 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> C = collections . Counter ( A ) <NEWLINE> ans = sum ( A ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += c * C [ b ] - b * C [ b ] <NEWLINE> C [ c ] += C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 1 ] * ( n - k + 1 ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ k + i ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> S = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> reverse = False <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> reverse = not reverse <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> if reverse : <NEWLINE> <INDENT> S . append ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( query [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if reverse : <NEWLINE> <INDENT> S . appendleft ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if reverse : <NEWLINE> <INDENT> while S : <NEWLINE> <INDENT> print ( S . pop ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while S : <NEWLINE> <INDENT> print ( S . popleft ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> array = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> array [ i + 1 ] = ( array [ i ] + pow ( 10 , i , mod ) * int ( s [ len ( s ) - ( i + 1 ) ] ) ) % mod <NEWLINE> <NL> <NL> <NL> <DEDENT> array . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> w = 1 <NEWLINE> <NL> for i in range ( 0 , len ( array ) - 1 ) : <NEWLINE> <INDENT> if array [ i ] == array [ i + 1 ] : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if w >= 2 : <NEWLINE> <INDENT> cnt += w * ( w - 1 ) / 2 <NEWLINE> w = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if w != 1 : <NEWLINE> <INDENT> cnt += w * ( w - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( cnt ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( readline ( ) ) <NEWLINE> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if arr [ j ] & x != 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( c * ( n - c ) ) * x <NEWLINE> ans %= mod <NEWLINE> x = x * 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for d in range ( 60 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( a >> d ) & 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> ans += x * ( n - x ) * 2 ** d <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> l = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for x in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> if x ** 2 > n : continue <NEWLINE> for y in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 > n : continue <NEWLINE> for z in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 > n : continue <NEWLINE> l . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = collections . Counter ( l ) <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ x ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> s = [ [ a % 10 , a // 10 * 10 + 10 , a ] , [ b % 10 , b // 10 * 10 + 10 , b ] , [ c % 10 , c // 10 * 10 + 10 , c ] , [ d % 10 , d // 10 * 10 + 10 , d ] , [ e % 10 , e // 10 * 10 + 10 , e ] ] <NEWLINE> s . sort ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == 0 : <NEWLINE> <INDENT> s [ 0 ] [ 1 ] -= 10 <NEWLINE> s . append ( s . pop ( 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s = np . array ( s ) <NEWLINE> ans = s [ 0 ] [ 2 ] + sum ( s [ 1 : , 1 ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] <NEWLINE> rs = 1 <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] == 0 : <NEWLINE> <INDENT> rs = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( 10 ** 18 // rs < l [ i ] ) : <NEWLINE> <INDENT> rs = - 1 <NEWLINE> break <NEWLINE> <DEDENT> rs = l [ i ] * rs <NEWLINE> <DEDENT> <DEDENT> print ( rs ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> <NL> for x in combinations_with_replacement ( <STRING> , X ) : <NEWLINE> <INDENT> a = np . array ( list ( map ( int , x ) ) ) <NEWLINE> if a . sum ( ) == Y : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def saiki ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = 0 <NEWLINE> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp = int ( n / 2 ) <NEWLINE> return saiki ( tmp ) * 2 + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> h = int ( input ( ) ) <NEWLINE> print ( saiki ( h ) ) <NEWLINE>
def power ( m , n ) : <NEWLINE> <INDENT> if n : return power ( m * m % 1000000007 , n // 2 ) * ( m if n % 2 else 1 ) % 1000000007 <NEWLINE> return 1 <NEWLINE> <NL> <NL> <DEDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> m , n = map ( int , readline ( ) . split ( ) ) <NEWLINE> print ( power ( m , n ) ) <NEWLINE>
import sys , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ s . rstrip ( ) for s in sys . stdin . readlines ( ) ] <NEWLINE> count = 0 <NEWLINE> <NL> memo = sorted ( S ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if memo [ i ] == memo [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> for x in range ( H ) : <NEWLINE> <INDENT> dp [ x ] [ 0 ] = 1 if c [ x ] [ 0 ] == 0 else 0 <NEWLINE> <DEDENT> for y in range ( W ) : <NEWLINE> <INDENT> dp [ 0 ] [ y ] = 1 if c [ 0 ] [ y ] == 0 else 0 <NEWLINE> <NL> <DEDENT> for x in range ( H - 1 ) : <NEWLINE> <INDENT> for y in range ( W - 1 ) : <NEWLINE> <INDENT> if c [ x + 1 ] [ y + 1 ] == 0 : <NEWLINE> <INDENT> dp [ x + 1 ] [ y + 1 ] = min ( [ dp [ x ] [ y ] , dp [ x ] [ y + 1 ] , dp [ x + 1 ] [ y ] ] ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ max ( item ) for item in dp ] ) ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> <NL> ans , cnt = 0 , deque ( [ a [ 0 ] ] ) <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> ans += cnt . popleft ( ) <NEWLINE> cnt . append ( i ) <NEWLINE> cnt . append ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if K >= A : <NEWLINE> <INDENT> ans += A <NEWLINE> K -= A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += K <NEWLINE> K = 0 <NEWLINE> <NL> <DEDENT> if K > 0 and B > 0 : <NEWLINE> <INDENT> if K >= B : <NEWLINE> <INDENT> K -= B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if K > 0 and C > 0 : <NEWLINE> <INDENT> if K >= C : <NEWLINE> <INDENT> K -= C <NEWLINE> ans -= C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= K <NEWLINE> K = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Hs = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good = [ True ] * N <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H_A , H_B = Hs [ A - 1 ] , Hs [ B - 1 ] <NEWLINE> if H_A < H_B : <NEWLINE> <INDENT> good [ A - 1 ] = False <NEWLINE> <DEDENT> elif H_B < H_A : <NEWLINE> <INDENT> good [ B - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ A - 1 ] = good [ B - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ v == True for v in good ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
import numpy as np <NEWLINE> N , X , Y = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> X -= 1 <NEWLINE> Y -= 1 <NEWLINE> cnt = np . zeros ( N , dtype = int ) <NEWLINE> for i in range ( 0 , ( X + Y ) // 2 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> tmin = abs ( i - X ) + 1 <NEWLINE> tmax = 0 - - ( abs ( i - X ) + 1 + Y + i ) // 2 <NEWLINE> cnt [ 1 : tmax - i ] += 1 <NEWLINE> cnt [ tmin : tmin + Y - tmax + 1 ] += 1 <NEWLINE> cnt [ tmin + 1 : tmin + N - Y ] += 1 <NEWLINE> <DEDENT> for i in range ( ( X + Y ) // 2 , N ) : <NEWLINE> <INDENT> cnt [ 1 : N - i ] += 1 <NEWLINE> <DEDENT> print ( * cnt [ 1 : ] , sep = <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pas = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> pas [ a ] . append ( b ) <NEWLINE> pas [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> seen = [ False for i in range ( n ) ] <NEWLINE> que = deque ( ) <NEWLINE> def bfn ( i , j ) : <NEWLINE> <INDENT> for x in pas [ i ] : <NEWLINE> <INDENT> if seen [ x - 1 ] != False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ x - 1 ] = i <NEWLINE> que . append ( [ x , i ] ) <NEWLINE> <DEDENT> if que : <NEWLINE> <INDENT> now , pre = que . popleft ( ) <NEWLINE> bfn ( now , pre ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> bfn ( 1 , 1 ) <NEWLINE> <NL> if False in seen : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( seen [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> <NL> t = dict ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t [ i ] = set ( ) <NEWLINE> <NL> <NL> <DEDENT> for a , b in ab : <NEWLINE> <INDENT> t [ a ] . add ( b ) <NEWLINE> t [ b ] . add ( a ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( graph , start ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> stack = [ start ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> vertex = stack . pop ( ) <NEWLINE> if vertex not in visited : <NEWLINE> <INDENT> visited . add ( vertex ) <NEWLINE> <NL> stack . extend ( graph [ vertex ] - visited ) <NEWLINE> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> seen = set ( ) <NEWLINE> length = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in seen : <NEWLINE> <INDENT> ans = dfs ( t , i ) <NEWLINE> for num in ans : <NEWLINE> <INDENT> seen . add ( num ) <NEWLINE> <NL> <DEDENT> if len ( ans ) > length : <NEWLINE> <INDENT> length = len ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( length ) <NEWLINE>
A = [ ] <NEWLINE> i = 0 <NEWLINE> for l in range ( 3 ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> B = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> for C in B : <NEWLINE> <INDENT> for a in range ( 3 ) : <NEWLINE> <INDENT> for b in range ( 3 ) : <NEWLINE> <INDENT> if C == A [ a ] [ b ] : <NEWLINE> <INDENT> A [ a ] [ b ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in range ( 3 ) : <NEWLINE> <INDENT> for b in range ( 3 ) : <NEWLINE> <INDENT> if A [ 0 ] [ b ] == A [ 1 ] [ b ] == A [ 2 ] [ b ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> i = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ a ] [ 0 ] == A [ a ] [ 1 ] == A [ a ] [ 2 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> i = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ 1 ] [ 1 ] == A [ 2 ] [ 2 ] == A [ 0 ] [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> i = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ 0 ] [ 2 ] == A [ 1 ] [ 1 ] == A [ 2 ] [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> i = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_1 , b_1 = input ( ) . split ( ) <NEWLINE> a . append ( int ( a_1 ) ) <NEWLINE> b . append ( int ( b_1 ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> is_odds = n % 2 == 0 <NEWLINE> a_med = a [ ( n + 1 ) // 2 - 1 ] if not is_odds else ( a [ n // 2 - 1 ] + a [ n // 2 ] ) / 2 <NEWLINE> b_med = b [ ( n + 1 ) // 2 - 1 ] if not is_odds else ( b [ n // 2 - 1 ] + b [ n // 2 ] ) / 2 <NEWLINE> from_a = a_med if not is_odds else int ( a_med * 2 ) <NEWLINE> to_b = b_med if not is_odds else int ( b_med * 2 ) <NEWLINE> print ( to_b - from_a + 1 ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> <NL> bc = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * bc ) ] <NEWLINE> <NL> dic = { } <NEWLINE> for aa in a : <NEWLINE> <INDENT> dic [ aa ] = dic . get ( aa , 0 ) + 1 <NEWLINE> <NL> <DEDENT> s = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if b [ i ] not in dic : <NEWLINE> <INDENT> print ( str ( s ) ) <NEWLINE> continue <NEWLINE> <DEDENT> s += ( c [ i ] - b [ i ] ) * dic [ b [ i ] ] <NEWLINE> dic [ c [ i ] ] = dic . get ( c [ i ] , 0 ) + dic [ b [ i ] ] <NEWLINE> del dic [ b [ i ] ] <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> m = l [ - 1 ] <NEWLINE> work = [ 0 ] * ( m + 1 ) <NEWLINE> for i in l : <NEWLINE> <INDENT> if work [ i ] <= 1 : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> work [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sm = 0 <NEWLINE> for s in l : <NEWLINE> <INDENT> if work [ s ] == 1 : sm += 1 <NEWLINE> <DEDENT> print ( sm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for _ in range ( m ) ] <NEWLINE> b = [ 0 for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> to = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> to [ a [ i ] ] . append ( b [ i ] ) <NEWLINE> to [ b [ i ] ] . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> inf = 200200 <NEWLINE> dist = [ inf for _ in range ( n + 1 ) ] <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> dist [ 1 ] = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for u in to [ v ] : <NEWLINE> <INDENT> if dist [ u ] == inf : <NEWLINE> <INDENT> dist [ u ] = dist [ v ] + 1 <NEWLINE> q . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if dist [ n ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def calc ( a , b , c , k ) : <NEWLINE> <INDENT> if k < a : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a - ( k - a - b ) <NEWLINE> <DEDENT> <DEDENT> print ( calc ( a , b , c , k ) ) <NEWLINE>
from sys import stdin <NEWLINE> from sys import setrecursionlimit <NEWLINE> from numba import jit <NEWLINE> <NL> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m , k = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> wariate = 1 <NEWLINE> point = 0 <NEWLINE> <NL> @ jit <NEWLINE> def prepare ( n , MOD = mod ) : <NEWLINE> <INDENT> facts = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> facts [ i ] = facts [ i - 1 ] * i % MOD <NEWLINE> <DEDENT> invs = [ 1 ] * ( n + 1 ) <NEWLINE> invs [ n ] = pow ( facts [ n ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( 0 , n ) [ : : - 1 ] : <NEWLINE> <INDENT> invs [ i ] = invs [ i + 1 ] * ( i + 1 ) % MOD <NEWLINE> <DEDENT> return facts , invs <NEWLINE> <NL> <DEDENT> facts , invs = prepare ( n , mod ) <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = m <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> wariate *= m - 1 <NEWLINE> wariate %= mod <NEWLINE> <DEDENT> now *= wariate % mod <NEWLINE> now *= facts [ n - 1 ] * invs [ n - 1 - i ] * invs [ i ] % mod <NEWLINE> if i <= k : <NEWLINE> <INDENT> point += now % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( point % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> J = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> res = { } <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res [ n ] = True <NEWLINE> <NL> <DEDENT> for j in J : <NEWLINE> <INDENT> n1 = j [ 0 ] <NEWLINE> n2 = j [ 1 ] <NEWLINE> h1 = H [ n1 - 1 ] <NEWLINE> h2 = H [ n2 - 1 ] <NEWLINE> if h1 < h2 : <NEWLINE> <INDENT> if res [ n1 ] : <NEWLINE> <INDENT> res [ n1 ] = False <NEWLINE> <DEDENT> <DEDENT> elif h2 < h1 : <NEWLINE> <INDENT> if res [ n2 ] : <NEWLINE> <INDENT> res [ n2 ] = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if res [ n1 ] : <NEWLINE> <INDENT> res [ n1 ] = False <NEWLINE> <DEDENT> if res [ n2 ] : <NEWLINE> <INDENT> res [ n2 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = 0 <NEWLINE> for v in res . values ( ) : <NEWLINE> <INDENT> if v : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> x = ab [ 0 ] [ 0 ] <NEWLINE> y = ab [ 0 ] [ 1 ] <NEWLINE> j = 1 <NEWLINE> flg = True <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> xx = ab [ i ] [ 0 ] <NEWLINE> yy = ab [ i ] [ 1 ] <NEWLINE> j = max ( x // xx , y // yy ) <NEWLINE> while flg : <NEWLINE> <INDENT> if x > j * xx or y > j * yy : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = xx * j <NEWLINE> y = yy * j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x + y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> word_list = [ input ( ) for i in range ( n ) ] <NEWLINE> l = len ( set ( word_list ) ) <NEWLINE> <NL> print ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sz = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> ans = sum ( sz ) * sum ( sz ) <NEWLINE> <NL> for i in sz : <NEWLINE> <INDENT> ans -= i * i <NEWLINE> <NL> <DEDENT> ans //= 2 <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> B , C = [ list ( i ) for i in zip ( * BC ) ] <NEWLINE> <COMMENT> <NL> <NL> dic = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> dic [ a ] = dic . get ( a , 0 ) + 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> ans = ans + ( C [ q ] - B [ q ] ) * dic . get ( B [ q ] , 0 ) <NEWLINE> dic [ C [ q ] ] = dic . get ( B [ q ] , 0 ) + dic . get ( C [ q ] , 0 ) <NEWLINE> dic [ B [ q ] ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
r = range ( 1 , int ( input ( ) ) + 1 ) <NEWLINE> from math import gcd <NEWLINE> print ( sum ( gcd ( gcd ( a , b ) , c ) for a in r for b in r for c in r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for x in arr : <NEWLINE> <INDENT> sum = sum + x <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> newarr = [ 0 ] * 10 ** 6 <NEWLINE> for x in arr : <NEWLINE> <INDENT> newarr [ x ] = newarr [ x ] + 1 <NEWLINE> <DEDENT> for t in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = sum - b * newarr [ b ] <NEWLINE> sum = sum + c * newarr [ b ] <NEWLINE> newarr [ c ] = newarr [ c ] + newarr [ b ] <NEWLINE> newarr [ b ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
K , S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return - self . par [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> UF = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = UF . size ( i ) <NEWLINE> if s > 0 : <NEWLINE> <INDENT> result = max ( result , s ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> gcds = [ math . gcd ( a + 1 , b + 1 ) for a in range ( K ) for b in range ( K ) ] <NEWLINE> res = sum ( [ math . gcd ( ab , c + 1 ) for ab in gcds for c in range ( K ) ] ) <NEWLINE> print ( res ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> x = i <NEWLINE> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = int ( x / 10 ) <NEWLINE> if x < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> MM = input ( ) . split ( ) <NEWLINE> total = 1 <NEWLINE> for i in MM : <NEWLINE> <INDENT> total = total * int ( i ) <NEWLINE> <NL> if total > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in MM : <NEWLINE> <INDENT> if int ( i ) == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = x * A [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> dq = deque ( ) <NEWLINE> num = int ( sys . stdin . readline ( ) ) <NEWLINE> line = sys . stdin . readlines ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <NL> <INDENT> order = line [ i ] . split ( ) <NEWLINE> <NL> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( order [ 1 ] ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in dq : <NEWLINE> <INDENT> dq . remove ( order [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> total = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> total *= a [ i ] <NEWLINE> if 10 ** 18 < total : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import copy <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ht = [ x for x in input ( ) . split ( ) ] <NEWLINE> hl = { x + 1 : int ( ht [ x ] ) for x in range ( len ( ht ) ) } <NEWLINE> mx = { h : 0 for h in hl } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> mx [ l ] = max ( mx [ l ] , hl [ r ] ) <NEWLINE> mx [ r ] = max ( mx [ r ] , hl [ l ] ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for h in hl : <NEWLINE> <INDENT> if mx [ h ] < hl [ h ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ret -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
N = int ( input ( ) ) - 1 <NEWLINE> S = str ( input ( ) ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> rgb = str ( ) <NEWLINE> d = 0 <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> rgb = str ( S [ n ] ) <NEWLINE> if rgb == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if rgb == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if rgb == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> rang = int ( ( N - n - 2 ) / 2 ) <NEWLINE> for j in range ( rang , - 1 , - 1 ) : <NEWLINE> <INDENT> if S [ n + j + 1 ] != rgb and n + 2 * j + 2 <= N : <NEWLINE> <NL> <INDENT> if S [ n + 2 * j + 2 ] != rgb : <NEWLINE> <INDENT> if S [ n + 2 * j + 2 ] != S [ n + j + 1 ] : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> Answer = r * g * b + d <NEWLINE> <NL> print ( Answer ) <NEWLINE> <NL>
t = input ( ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> <NL> while i <= n : <NEWLINE> <NL> <INDENT> x = i <NEWLINE> <NL> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( x / 10 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , math . gcd ( j , k ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> ans = sum ( a ) <NEWLINE> number = [ 0 ] * 100001 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> number [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if number [ b [ i ] ] > 0 : <NEWLINE> <INDENT> ans += ( c [ i ] - b [ i ] ) * number [ b [ i ] ] <NEWLINE> number [ c [ i ] ] += number [ b [ i ] ] <NEWLINE> number [ b [ i ] ] = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
integer = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> sort = sorted ( integer ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if i == 3 - 1 : <NEWLINE> <INDENT> print ( sort [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sort [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> A , B , C , K = LI ( ) <NEWLINE> ans = min ( A , K ) <NEWLINE> if A + B < K : <NEWLINE> <INDENT> ans -= K - ( A + B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ss = list ( input ( ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> cum_sum_w = [ 0 ] * ( n + 1 ) <NEWLINE> cum_sum_e = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ss [ i ] == <STRING> : <NEWLINE> <INDENT> add = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = 0 <NEWLINE> <DEDENT> cum_sum_w [ i + 1 ] = cum_sum_w [ i ] + add <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ss [ i ] == <STRING> : <NEWLINE> <INDENT> add = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = 0 <NEWLINE> <DEDENT> cum_sum_e [ i + 1 ] = cum_sum_e [ i ] + add <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = cum_sum_w [ i ] + ( cum_sum_e [ n ] - cum_sum_e [ i + 1 ] ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> result = 1 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> result = result * int ( s [ i ] ) <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == N - 1 and result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> to = int ( ( N ) ** ( 1 / 2 ) ) + 2 <NEWLINE> for x in range ( 1 , to ) : <NEWLINE> <INDENT> for y in range ( 1 , to ) : <NEWLINE> <INDENT> for z in range ( 1 , to ) : <NEWLINE> <INDENT> temp = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if temp <= N : <NEWLINE> <INDENT> ans [ temp ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = np . zeros ( n , dtype = int ) <NEWLINE> for number in l : <NEWLINE> <INDENT> answer [ number - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> c = round ( answer [ j ] ) <NEWLINE> print ( c ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 3 * 10 ** 8 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a = x [ i ] <NEWLINE> b = x [ i + k - 1 ] <NEWLINE> t = min ( abs ( a ) + abs ( b - a ) , abs ( b ) + abs ( b - a ) ) <NEWLINE> if m > t : <NEWLINE> <INDENT> m = t <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> count = collections . Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> values = list ( count ( S ) . values ( ) ) <NEWLINE> if len ( values ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = values [ 0 ] * values [ 1 ] * values [ 2 ] <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( int ( N / 2 ) * ( N - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( N - 1 ) / 2 ) * N ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> flag = True <NEWLINE> while flag == True : <NEWLINE> <INDENT> if len ( S ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( S ) >= 5 : <NEWLINE> <INDENT> if S [ - 5 : ] == list ( <STRING> ) : del S [ - 5 : ] <NEWLINE> elif S [ - 5 : ] == list ( <STRING> ) : del S [ - 5 : ] <NEWLINE> elif len ( S ) >= 6 and S [ - 6 : ] == list ( <STRING> ) : del S [ - 6 : ] <NEWLINE> elif len ( S ) >= 7 and S [ - 7 : ] == list ( <STRING> ) : del S [ - 7 : ] <NEWLINE> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * 2 + 1 <NEWLINE> h //= 2 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> s = input ( ) <NEWLINE> blen = 0 <NEWLINE> glen = 0 <NEWLINE> rlen = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> rlen += 1 <NEWLINE> <DEDENT> elif ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> glen += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> blen += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> minus = 0 <NEWLINE> t = 0 <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> mn = min ( i , j ) <NEWLINE> mx = max ( i , j ) <NEWLINE> <NL> mid2 = mx + ( mx - mn ) <NEWLINE> mid3 = mn - ( mx - mn ) <NEWLINE> <NL> if ( ( mx - mn ) % 2 == 0 ) : <NEWLINE> <INDENT> mid1 = mn + ( mx - mn ) // 2 <NEWLINE> if ( mid1 >= 0 and mid1 < n ) : <NEWLINE> <INDENT> if ( s [ mid1 ] == <STRING> ) : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( mid2 >= 0 and mid2 < n ) : <NEWLINE> <INDENT> if ( s [ mid2 ] == <STRING> ) : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> if ( mid3 >= 0 and mid3 < n ) : <NEWLINE> <INDENT> if ( s [ mid3 ] == <STRING> ) : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> t += blen <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = rlen * glen * blen <NEWLINE> ans -= minus <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> As = sorted ( As , reverse = True ) <NEWLINE> ans = 1 <NEWLINE> break_flag = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> ans *= As [ n ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break_flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if break_flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count += int ( ( N - 1 ) / i ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> height , width = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if height == width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( height - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * width ) <NEWLINE> <DEDENT> print ( <STRING> * width + <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import math <NEWLINE> import random <NEWLINE> import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict , deque , namedtuple , UserDict <NEWLINE> from functools import cmp_to_key , lru_cache , reduce <NEWLINE> from itertools import ( chain , combinations , combinations_with_replacement , <NEWLINE> <INDENT> permutations , product ) <NEWLINE> <DEDENT> import numpy as np <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 + 1 ) <NEWLINE> write = sys . stdout . write <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = sorted ( enumerate ( map ( int , input ( ) . split ( ) ) , 1 ) , <NEWLINE> <INDENT> key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <DEDENT> dp = np . zeros ( n + 1 , dtype = np . int ) <NEWLINE> <NL> for k , ( i , a ) in enumerate ( arr , 1 ) : <NEWLINE> <INDENT> ndp = dp . copy ( ) <NEWLINE> <NL> add_left = np . abs ( np . arange ( 1 , k + 1 ) - i ) * a <NEWLINE> ndp [ 1 : k + 1 ] = np . maximum ( ndp [ 1 : k + 1 ] , dp [ : k ] + add_left ) <NEWLINE> <NL> add_right = np . abs ( np . arange ( n - k + 1 , n + 1 ) - i ) * a <NEWLINE> ndp [ : k ] = np . maximum ( ndp [ : k ] , dp [ : k ] + add_right ) <NEWLINE> <NL> dp = ndp <NEWLINE> <NL> <DEDENT> print ( dp . max ( ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> r = float ( input ( ) ) <NEWLINE> s = math . pi * r ** 2 <NEWLINE> l = r * 2 * math . pi <NEWLINE> print ( format ( s , <STRING> ) , format ( l , <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a % 3600 <NEWLINE> c = a // 3600 <NEWLINE> d = b % 60 <NEWLINE> e = b // 60 <NEWLINE> print ( str ( c ) + <STRING> + str ( e ) + <STRING> + str ( d ) ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> rem = [ 0 ] * 2019 <NEWLINE> <NL> n = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> n = n % 2019 + ( int ( s ) * d ) % 2019 <NEWLINE> tmp = n % 2019 <NEWLINE> rem [ tmp ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in rem : <NEWLINE> <INDENT> ans += ( ( i * ( i - 1 ) ) // 2 ) <NEWLINE> <NL> <DEDENT> print ( ans + rem [ 0 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ls = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 1001 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ls [ h ] [ p ] = 1 <NEWLINE> <DEDENT> ls . reverse ( ) <NEWLINE> for t in ls : <NEWLINE> <INDENT> if t [ a ] == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif t [ a - 1 ] == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> g = gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> sum += gcd ( g , c + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> idx = 0 <NEWLINE> cnt = 1 <NEWLINE> for a in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ idx ] <NEWLINE> cnt += 1 <NEWLINE> if cnt == 2 : <NEWLINE> <INDENT> idx += 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> l = sorted ( list ( set ( S ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if ord ( l [ i ] ) != 97 + i : <NEWLINE> <INDENT> ans = chr ( 97 + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == 25 and l [ i ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr ( ord ( l [ - 1 ] ) + 1 ) ) <NEWLINE> <DEDENT>
import random <NEWLINE> import time <NEWLINE> import copy <NEWLINE> import math <NEWLINE> start = time . time ( ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cli = [ ] <NEWLINE> for i in range ( d + 1 ) : <NEWLINE> <INDENT> ch = [ ] <NEWLINE> for j in c : <NEWLINE> <INDENT> ch . append ( i * j ) <NEWLINE> <DEDENT> cli . append ( ch ) <NEWLINE> <DEDENT> s = [ ] <NEWLINE> solution = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> sco = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for day in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> man = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> man . append ( s [ day - 1 ] [ i ] + last [ i ] * c [ i ] ) <NEWLINE> <DEDENT> con = man . index ( max ( man ) ) <NEWLINE> sco += s [ day - 1 ] [ con ] <NEWLINE> last [ con ] = day <NEWLINE> for ( i , j ) in zip ( last , range ( 26 ) ) : <NEWLINE> <INDENT> sco -= cli [ i ] [ j ] <NEWLINE> <DEDENT> solution . append ( con ) <NEWLINE> <NL> <DEDENT> stemp = 1000000 <NEWLINE> etemp = 10000 <NEWLINE> def tem ( ) : <NEWLINE> <INDENT> return stemp - ( ( stemp - etemp ) * ( time . time ( ) - start ) / 1.9 ) <NEWLINE> <DEDENT> while time . time ( ) - start < 1.9 : <NEWLINE> <INDENT> sc = 0 <NEWLINE> sol = copy . deepcopy ( solution ) <NEWLINE> for x in [ random . randrange ( d ) for i in range ( 3 ) ] : <NEWLINE> <INDENT> sol [ x ] = random . randrange ( 26 ) <NEWLINE> <DEDENT> last = [ 0 ] * 26 <NEWLINE> for ( day , i ) in zip ( range ( 1 , d + 1 ) , sol ) : <NEWLINE> <INDENT> sc += s [ day - 1 ] [ i ] <NEWLINE> last [ i ] = day <NEWLINE> for ( i , j ) in zip ( last , range ( 26 ) ) : <NEWLINE> <INDENT> sc -= cli [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> prob = math . exp ( ( sc - sco ) / tem ( ) ) <NEWLINE> <COMMENT> <NL> if prob > random . random ( ) : <NEWLINE> <INDENT> solution = copy . deepcopy ( sol ) <NEWLINE> sco = sc <NEWLINE> <DEDENT> <DEDENT> for i in solution : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
def len_LCS ( X , Y ) : <NEWLINE> <INDENT> x_l = len ( X ) <NEWLINE> y_l = len ( Y ) <NEWLINE> lcs_row = [ 0 for _ in range ( x_l + 1 ) ] <NEWLINE> for j in range ( y_l ) : <NEWLINE> <INDENT> y_j = Y [ j ] <NEWLINE> lcs_row_p = lcs_row [ : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( x_l ) : <NEWLINE> <INDENT> if X [ i ] == y_j : <NEWLINE> <INDENT> lcs_row [ i + 1 ] = lcs_row_p [ i ] + 1 <NEWLINE> <DEDENT> elif lcs_row [ i ] > lcs_row_p [ i + 1 ] : <NEWLINE> <INDENT> lcs_row [ i + 1 ] = lcs_row [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return lcs_row [ - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( len_LCS ( X , Y ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> a = b = ans = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( a , b ) <NEWLINE> for c in C : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> ans = min ( ans , max ( a , b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> B = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> C = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> def isok_A ( index , key , arr ) : <NEWLINE> <INDENT> if arr [ index ] >= key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def Binary_search_A ( key , arr ) : <NEWLINE> <NL> <INDENT> ng = - 1 <NEWLINE> ok = len ( arr ) <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isok_A ( mid , key , arr ) is True : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ng , ok <NEWLINE> <NL> <DEDENT> def isok_B ( index , key , arr ) : <NEWLINE> <INDENT> if arr [ index ] > key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def Binary_search_B ( key , arr ) : <NEWLINE> <NL> <INDENT> ng = - 1 <NEWLINE> ok = len ( arr ) <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isok_B ( mid , key , arr ) is True : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ng , ok <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> ng_a , ok_b = Binary_search_A ( i , A ) <NEWLINE> ng_c , ok_c = Binary_search_B ( i , C ) <NEWLINE> cnt += ( ng_a + 1 ) * ( N - ok_c ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in [ 0 ] * N ] <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> if A == B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif A == B == 1 : <NEWLINE> <INDENT> if S [ ( i + 1 ) % N ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> B += 1 <NEWLINE> A -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> A += 1 <NEWLINE> B -= 1 <NEWLINE> <DEDENT> <DEDENT> elif A >= B : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> A -= 1 <NEWLINE> B += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> A += 1 <NEWLINE> B -= 1 <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if B == C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif B == C == 1 : <NEWLINE> <INDENT> if S [ ( i + 1 ) % N ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> C += 1 <NEWLINE> B -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> B += 1 <NEWLINE> C -= 1 <NEWLINE> <DEDENT> <DEDENT> elif B >= C : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> B -= 1 <NEWLINE> C += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> B += 1 <NEWLINE> C -= 1 <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if A == C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif A == C == 1 : <NEWLINE> <INDENT> if S [ ( i + 1 ) % N ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> C += 1 <NEWLINE> A -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> A += 1 <NEWLINE> C -= 1 <NEWLINE> <DEDENT> <DEDENT> elif A >= C : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> A -= 1 <NEWLINE> C += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> A += 1 <NEWLINE> C -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for out in ans : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT> <DEDENT>
def pop_count ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( n % pop_count ( n ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) ) ) <NEWLINE> X_m = 0 <NEWLINE> X_p = 0 <NEWLINE> pop_X = X . count ( 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> X_p += pow ( 2 , N - i - 1 , pop_X + 1 ) <NEWLINE> X_p %= pop_X + 1 <NEWLINE> if pop_X > 1 : <NEWLINE> <INDENT> X_m += pow ( 2 , N - i - 1 , pop_X - 1 ) <NEWLINE> X_m %= pop_X - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if X [ i ] == 0 : <NEWLINE> <INDENT> ans += f ( ( X_p + pow ( 2 , N - i - 1 , pop_X + 1 ) ) % ( pop_X + 1 ) ) <NEWLINE> <DEDENT> elif pop_X > 1 : <NEWLINE> <INDENT> ans += f ( ( X_m - pow ( 2 , N - i - 1 , pop_X - 1 ) ) % ( pop_X - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> def x ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> count = ( 10 * count + 7 ) % K <COMMENT> <NEWLINE> if count == 0 : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> print ( x ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = { } <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> ans [ s ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE>
def reachable ( graph , init ) : <NEWLINE> <INDENT> if init not in graph or graph [ init ] is None : <NEWLINE> <INDENT> return set ( ) <NEWLINE> <NL> <DEDENT> tmp , graph [ init ] = graph [ init ] , None <NEWLINE> <NL> return tmp . union ( * [ reachable ( graph , i ) for i in tmp ] ) <NEWLINE> <NL> <DEDENT> def sugoroku ( m , d ) : <NEWLINE> <INDENT> d = [ 0 ] + d + [ 0 ] <NEWLINE> start , goal = 0 , len ( d ) - 1 <NEWLINE> <NL> graph_to = { goal : { goal } } <NEWLINE> graph_from = { start : { start } } <NEWLINE> <NL> for init in range ( len ( d ) - 1 ) : <NEWLINE> <INDENT> for xi in range ( 1 , 1 + m ) : <NEWLINE> <INDENT> pos = min ( init + xi , goal ) <NEWLINE> to = max ( start , min ( pos + d [ pos ] , goal ) ) <NEWLINE> try : <NEWLINE> <INDENT> graph_to [ to ] . add ( init ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> graph_to [ to ] = { init } <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> graph_from [ init ] . add ( to ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> graph_from [ init ] = { to } <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> unreachable_node = reachable ( graph_from , start ) . difference ( reachable ( graph_to , goal ) ) <NEWLINE> <NL> return 0 == len ( unreachable_node ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> m = int ( f . readline ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = [ int ( f . readline ( ) ) for _ in range ( int ( f . readline ( ) ) ) ] <NEWLINE> print ( <STRING> if sugoroku ( m , d ) else <STRING> ) <NEWLINE> <DEDENT>
def counting_sort ( array , maxval ) : <NEWLINE> <INDENT> m = maxval + 1000 <NEWLINE> count = [ 0 ] * ( m ) <NEWLINE> for a in array : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> for a in range ( m ) : <NEWLINE> <INDENT> for c in range ( count [ a ] ) : <NEWLINE> <INDENT> array [ i ] = a <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> return array <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> li = counting_sort ( l , N ) <NEWLINE> for a in range ( N - 1 ) : <NEWLINE> <INDENT> print ( li [ a ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( li [ N - 1 ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> x = 7 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if x % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n , m , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> board = [ [ <STRING> ] * m for _ in range ( n ) ] <NEWLINE> if n * m < 2 * ( a + b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n == 1 or m == 1 : <NEWLINE> <INDENT> if n == 1 and m == 1 : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> if b >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m // 2 < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( 0 , m // 2 ) : <NEWLINE> <INDENT> board [ 0 ] [ 2 * x ] = <STRING> <NEWLINE> board [ 0 ] [ 2 * x + 1 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> if a >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n // 2 < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in range ( 0 , n // 2 ) : <NEWLINE> <INDENT> board [ 2 * y ] [ 0 ] = <STRING> <NEWLINE> board [ 2 * y + 1 ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( n * m ) % 2 != 1 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( m // 2 , a ) <NEWLINE> a -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ n - 1 ] [ 2 * i ] = <STRING> <NEWLINE> board [ n - 1 ] [ 2 * i + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if m % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( n // 2 , b ) <NEWLINE> b -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ 2 * i ] [ m - 1 ] = <STRING> <NEWLINE> board [ 2 * i + 1 ] [ m - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for y in range ( 0 , n - ( n % 2 ) , 2 ) : <NEWLINE> <INDENT> for x in range ( 0 , m - ( m % 2 ) , 2 ) : <NEWLINE> <INDENT> if a >= 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b >= 2 : <NEWLINE> <INDENT> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a != 0 or b != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( m // 2 - 1 , a ) <NEWLINE> a -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ n - 1 ] [ 2 * i ] = <STRING> <NEWLINE> board [ n - 1 ] [ 2 * i + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if m % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( n // 2 - 1 , b ) <NEWLINE> b -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ 2 * i ] [ m - 1 ] = <STRING> <NEWLINE> board [ 2 * i + 1 ] [ m - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for y in range ( 0 , n - 2 , 2 ) : <NEWLINE> <INDENT> for x in range ( 0 , m - 2 , 2 ) : <NEWLINE> <INDENT> if y == n - 3 and x == m - 3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a >= b : <NEWLINE> <INDENT> if a >= 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b >= 2 : <NEWLINE> <INDENT> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a >= 4 or b >= 4 or a + b >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = m - 3 <NEWLINE> y = n - 3 <NEWLINE> if a == 2 and b == 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y ] [ x + 2 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 2 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 2 ] [ x ] = <STRING> <NEWLINE> board [ y + 2 ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 2 ] [ x + 2 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a != 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y + 2 ] [ x ] = <STRING> <NEWLINE> board [ y + 2 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> if b != 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x + 2 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 2 ] = <STRING> <NEWLINE> <DEDENT> if a >= 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b >= 2 : <NEWLINE> <INDENT> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , * p = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> min_p = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> min_p = min ( min_p , p [ i ] ) <NEWLINE> if p [ i ] <= min_p : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import re <NEWLINE> <NL> def revPolish ( f ) : <NEWLINE> <INDENT> f = re . sub ( <STRING> , <NEWLINE> <INDENT> lambda m : str ( eval ( m . group ( 1 ) + m . group ( 3 ) + m . group ( 2 ) ) ) , <NEWLINE> f ) <NEWLINE> <DEDENT> if f [ - 1 ] in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> return revPolish ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f <NEWLINE> <NL> <DEDENT> <DEDENT> print ( revPolish ( input ( ) ) ) <NEWLINE>
def is_float_str ( num_str , default = 0 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return { <STRING> : True , <STRING> : float ( num_str ) } <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return { <STRING> : False , <STRING> : default } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def compute ( operand , val1 , val2 ) : <NEWLINE> <INDENT> if operand == <STRING> : <NEWLINE> <INDENT> return val2 + val1 <NEWLINE> <DEDENT> elif operand == <STRING> : <NEWLINE> <INDENT> return val2 - val1 <NEWLINE> <DEDENT> elif operand == <STRING> : <NEWLINE> <INDENT> return val2 * val1 <NEWLINE> <DEDENT> elif operand == <STRING> : <NEWLINE> <INDENT> return val2 / val1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_input ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> formulas = list ( get_input ( ) ) <NEWLINE> for ( i , formula ) in enumerate ( formulas , 0 ) : <NEWLINE> <INDENT> formulas [ i ] = formula . split ( <STRING> ) <NEWLINE> <DEDENT> stack = [ ] <NEWLINE> <NL> for formula in formulas : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> for elm in formula : <NEWLINE> <INDENT> if is_float_str ( elm ) [ <STRING> ] : <NEWLINE> <INDENT> stack . append ( is_float_str ( elm ) [ <STRING> ] ) <NEWLINE> <DEDENT> elif elm in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> stack . append ( compute ( elm , stack . pop ( ) , stack . pop ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( stack ) == 1 : <NEWLINE> <INDENT> print ( format ( stack [ 0 ] , <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = N % K <NEWLINE> y = abs ( N % K - K ) <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> d = [ 0 ] * 2019 <NEWLINE> dp = 0 <NEWLINE> d [ 0 ] += 1 <NEWLINE> l = len ( s ) <NEWLINE> r = 1 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> dp += int ( s [ l - 1 - i ] ) * r <NEWLINE> dp %= 2019 <NEWLINE> r *= 10 <NEWLINE> r %= 2019 <NEWLINE> d [ dp ] += 1 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> for a in d : <NEWLINE> <INDENT> res += a * ( a - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 1000000007 <NEWLINE> sql = ( sum ( l ) ) ** 2 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += i * i <NEWLINE> <DEDENT> print ( ( sql - ans ) // 2 % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> line = input ( ) <NEWLINE> print ( line [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while x != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> , i , <STRING> , x , sep = <STRING> ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <DEDENT>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> theta_M = M * 6 <NEWLINE> theta_H = H * 30 + M * 0.5 <NEWLINE> <NL> theta = abs ( theta_M - theta_H ) <NEWLINE> if theta > 180 : <NEWLINE> <INDENT> theta = 360 - theta <NEWLINE> <NL> <DEDENT> import math <NEWLINE> x = A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( theta ) ) <NEWLINE> x = math . sqrt ( x ) <NEWLINE> print ( x ) <NEWLINE>
x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> <NL> if x not in num : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = num . index ( x ) <NEWLINE> if y == ( n - 1 ) : <NEWLINE> <INDENT> if num [ y - 1 ] == x - 1 : <NEWLINE> <INDENT> print ( x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> print ( x - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> y = x - i <NEWLINE> if y not in num : <NEWLINE> <INDENT> under = y <NEWLINE> count_under = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> y = x + j <NEWLINE> if y not in num : <NEWLINE> <INDENT> upper = y <NEWLINE> count_upper = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if count_under <= count_upper : <NEWLINE> <INDENT> print ( under ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( upper ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( a ) for a in A ] <NEWLINE> S = [ 1 ] <NEWLINE> a = 1 <NEWLINE> number = 0 <NEWLINE> numbers = [ - 1 for _ in range ( N ) ] <NEWLINE> for _ in range ( N + 1 ) : <NEWLINE> <INDENT> b = A [ a - 1 ] <NEWLINE> if numbers [ b - 1 ] != - 1 : <NEWLINE> <INDENT> c = numbers [ b - 1 ] <COMMENT> <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> numbers [ b - 1 ] = number <NEWLINE> number += 1 <NEWLINE> S . append ( b ) <NEWLINE> a = b <NEWLINE> <DEDENT> T = S [ c + 1 : number + 1 ] <NEWLINE> if K <= number : <NEWLINE> <INDENT> print ( S [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = K - c - 1 <NEWLINE> y = z % ( number - c ) <NEWLINE> <COMMENT> <NL> print ( T [ y ] ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( r ** 2 * pi , 2 * r * pi ) <NEWLINE>
import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , 20 ) : <NEWLINE> <INDENT> p += a - 1 <NEWLINE> ans += 1 <NEWLINE> if p >= b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import itertools <NEWLINE> import functools <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> from itertools import combinations <NEWLINE> import re <NEWLINE> <NL> def main_chk ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> chk = N - 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> p = chk <NEWLINE> chk = i <NEWLINE> for x in range ( N - i ) : <NEWLINE> <INDENT> if C [ p - x ] == <STRING> : <NEWLINE> <INDENT> chk = p - x <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if chk <= i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> chk = chk - 1 <NEWLINE> if chk <= i + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main_chk ( ) <NEWLINE>
nb = int ( input ( ) ) <NEWLINE> liste = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> liste2 = [ 0 ] * ( ( 10 ** 5 ) + 1 ) <NEWLINE> for loop in range ( len ( liste ) ) : <NEWLINE> <INDENT> liste2 [ liste [ loop ] ] += 1 <NEWLINE> <DEDENT> nba = int ( input ( ) ) <NEWLINE> somme = sum ( liste ) <NEWLINE> for loop in range ( nba ) : <NEWLINE> <INDENT> n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> roger = liste2 [ n ] <NEWLINE> diff = r - n <NEWLINE> somme += diff * roger <NEWLINE> liste2 [ r ] += liste2 [ n ] <NEWLINE> liste2 [ n ] = 0 <NEWLINE> print ( somme ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> memo = [ ] <NEWLINE> memolist = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> memo . append ( memolist ) <NEWLINE> <DEDENT> memolist = [ ] <NEWLINE> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> memolist . append ( gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> memo . append ( memolist ) <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( memo [ i - 1 ] [ j - 1 ] , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> idx = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if idx < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a [ i ] + b [ idx ] > k : <NEWLINE> <INDENT> idx -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = max ( i + idx , c ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> cur = 7 <NEWLINE> flg = False <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> mod = cur % K <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = mod * 10 + 7 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def main0 ( n , g , xyuv ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> depth = [ 0 ] * n <NEWLINE> tour = [ ] <NEWLINE> hatsu = [ 0 ] * n <NEWLINE> dist = [ 0 ] * n <NEWLINE> tmp = 0 <NEWLINE> def et ( p , v , tour , tmp , pc , pd ) : <NEWLINE> <INDENT> hatsu [ v ] = len ( tour ) - 1 <NEWLINE> for nv , c , d in g [ v ] : <NEWLINE> <INDENT> if nv == p : continue <NEWLINE> depth [ nv ] = depth [ v ] + 1 <NEWLINE> tmp += d <NEWLINE> dist [ nv ] = tmp <NEWLINE> tour . append ( ( nv , c , d ) ) <NEWLINE> tour = et ( v , nv , tour , tmp , c , d ) <NEWLINE> tmp -= d <NEWLINE> tour . append ( ( v , c , - d ) ) <NEWLINE> <DEDENT> return tour <NEWLINE> <DEDENT> tour . append ( ( 0 , 0 , 0 ) ) <NEWLINE> tour = et ( - 1 , 0 , tour , 0 , 0 , 0 ) <NEWLINE> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , size , f = lambda x , y : x + y , default = 0 ) : <NEWLINE> <INDENT> self . size = pow ( 2 , ( size - 1 ) . bit_length ( ) ) <NEWLINE> self . f = f <NEWLINE> self . default = default <NEWLINE> self . data = [ default ] * ( self . size * 2 ) <NEWLINE> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += self . size <NEWLINE> self . data [ i ] = x <NEWLINE> while i : <NEWLINE> <INDENT> i >>= 1 <NEWLINE> self . data [ i ] = self . f ( self . data [ i * 2 ] , self . data [ i * 2 + 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def query ( self , l , r ) : <NEWLINE> <INDENT> l , r = l + self . size , r + self . size <NEWLINE> lret , rret = self . default , self . default <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> lret = self . f ( self . data [ l ] , lret ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> rret = self . f ( self . data [ r ] , rret ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return self . f ( lret , rret ) <NEWLINE> <NL> <DEDENT> <DEDENT> def func ( x , y ) : <NEWLINE> <INDENT> if x [ 0 ] < y [ 0 ] : return x <NEWLINE> return y <NEWLINE> <DEDENT> st = SegmentTree ( len ( tour ) , func , ( n + 1 , 0 ) ) <NEWLINE> for i , x in enumerate ( tour ) : <NEWLINE> <INDENT> v = x [ 0 ] <NEWLINE> st . update ( i , ( depth [ v ] , v ) ) <NEWLINE> <DEDENT> def lca ( u , v ) : <NEWLINE> <INDENT> x , y = hatsu [ u ] , hatsu [ v ] <NEWLINE> if x < y : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> y += 1 <NEWLINE> <DEDENT> return st . query ( x , y ) [ 1 ] <NEWLINE> <DEDENT> dc = { } <NEWLINE> dcary = { } <NEWLINE> for i , ( v , c , d ) in enumerate ( tour ) : <NEWLINE> <INDENT> if c in dc : <NEWLINE> <INDENT> ci = 1 if d > 0 else - 1 <NEWLINE> dc [ c ] . append ( ( dc [ c ] [ - 1 ] [ 0 ] + ci , dc [ c ] [ - 1 ] [ 1 ] + d ) ) <NEWLINE> dcary [ c ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dc [ c ] = [ ( 0 , 0 ) , ( 1 , d ) ] <NEWLINE> dcary [ c ] = [ 0 , i ] <NEWLINE> <DEDENT> <DEDENT> ret = [ ] <NEWLINE> from bisect import bisect_right as bl <NEWLINE> for x , y , u , v in xyuv : <NEWLINE> <INDENT> u , v = u - 1 , v - 1 <NEWLINE> w = lca ( u , v ) <NEWLINE> uvlen = dist [ u ] + dist [ v ] - dist [ w ] * 2 <NEWLINE> if x not in dc : <NEWLINE> <INDENT> ret . append ( uvlen ) <NEWLINE> continue <NEWLINE> <DEDENT> widx = bl ( dcary [ x ] , hatsu [ w ] ) - 1 <NEWLINE> wnum , wsum = dc [ x ] [ widx ] <NEWLINE> uidx = bl ( dcary [ x ] , hatsu [ u ] ) - 1 <NEWLINE> vidx = bl ( dcary [ x ] , hatsu [ v ] ) - 1 <NEWLINE> unum , usum = dc [ x ] [ uidx ] <NEWLINE> vnum , vsum = dc [ x ] [ vidx ] <NEWLINE> uvsum = usum + vsum - wsum * 2 <NEWLINE> uvnum = unum + vnum - wnum * 2 <NEWLINE> <COMMENT> <NL> ret . append ( uvlen - uvsum + uvnum * y ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> xyuv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> g [ a ] . append ( ( b , c , d ) ) <NEWLINE> g [ b ] . append ( ( a , c , d ) ) <NEWLINE> <DEDENT> ary0 = main0 ( n , g , xyuv ) <NEWLINE> print ( * ary0 , sep = <STRING> ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> loadmap = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> loadmap [ A ] . append ( B ) <NEWLINE> loadmap [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> dbrmap = [ [ float ( <STRING> ) , - 1 , 0 ] for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> rooms = deque ( ) <NEWLINE> rooms . append ( [ 0 , 1 , 0 ] ) <NEWLINE> dbrmap [ 1 ] [ 2 ] = 1 <NEWLINE> while rooms : <NEWLINE> <COMMENT> <NL> <INDENT> br , r , d = rooms . popleft ( ) <NEWLINE> if d <= dbrmap [ r ] [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> dbrmap [ r ] [ 0 ] = d <NEWLINE> dbrmap [ r ] [ 1 ] = br <NEWLINE> <COMMENT> <NL> for load in loadmap [ r ] : <NEWLINE> <COMMENT> <NL> <INDENT> if dbrmap [ load ] [ 2 ] == 0 : <NEWLINE> <INDENT> rooms . append ( [ r , load , d + 1 ] ) <NEWLINE> dbrmap [ load ] [ 2 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if min ( [ db [ 1 ] for db in dbrmap [ 1 : ] ] ) <= - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for db in dbrmap [ 2 : ] : <NEWLINE> <INDENT> print ( db [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> nd = input ( ) . split ( ) <NEWLINE> nd = [ int ( x ) for x in nd ] <NEWLINE> n = nd [ 0 ] <NEWLINE> d = nd [ 1 ] <NEWLINE> <NL> x_list = [ ] <NEWLINE> y_list = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> def count ( x_list , y_list , d , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if math . sqrt ( x_list [ i ] ** 2 + y_list [ i ] ** 2 ) <= d : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> xy = input ( ) . split ( ) <NEWLINE> xy = [ int ( k ) for k in xy ] <NEWLINE> x_list . append ( xy [ 0 ] ) <NEWLINE> y_list . append ( xy [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( count ( x_list , y_list , d , n ) ) <NEWLINE>
odd = list ( map ( str , input ( ) ) ) <NEWLINE> even = list ( map ( str , input ( ) ) ) <NEWLINE> if len ( odd ) == len ( even ) : <NEWLINE> <INDENT> L = len ( odd ) * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = len ( odd ) + len ( even ) <NEWLINE> <DEDENT> li = [ ] <NEWLINE> <NL> for i in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> li . append ( odd [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( odd [ i // 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> li . append ( even [ i // 2 - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( li ) ) <NEWLINE>
N = 104743 <NEWLINE> p = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 4 , N + 1 , 2 ) : p [ i ] = 0 <NEWLINE> a = [ 2 ] <NEWLINE> for i in range ( 3 , N + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> a . append ( a [ - 1 ] + i ) <NEWLINE> for j in range ( 3 * i , N + 1 , 2 * i ) : p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( a [ n - 1 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> if abs ( b - a ) <= ( v - w ) * t else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> r [ i + 1 + t [ i ] ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> r [ i + 1 + t [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if ( ( i + 1 - t [ i ] ) >= 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans += r [ i + 1 - t [ i ] ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = sorted ( A , reverse = True ) <NEWLINE> def mul ( A ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> m = 1 <NEWLINE> for na in A : <NEWLINE> <INDENT> m *= na <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <DEDENT> print ( mul ( A ) ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ k - q ] * n <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> winner_id = int ( input ( ) ) - 1 <NEWLINE> arr [ winner_id ] += 1 <NEWLINE> <NL> <DEDENT> for ele in arr : <NEWLINE> <INDENT> if ele > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj_list = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> adj_list [ i ] = ( A [ i ] ) <NEWLINE> <DEDENT> k = 0 <NEWLINE> node = 1 <NEWLINE> c = [ 0 ] * N <NEWLINE> count = 1 <NEWLINE> flag = 0 <NEWLINE> ROOP = [ ] <NEWLINE> roopstart = 0 <NEWLINE> while k < K : <NEWLINE> <INDENT> k += 1 <NEWLINE> c [ node - 1 ] += 1 <NEWLINE> node = adj_list [ node - 1 ] <NEWLINE> if c [ node - 1 ] == 1 : <NEWLINE> <INDENT> if flag == 0 : <NEWLINE> <INDENT> roopstart = k <NEWLINE> flag = 1 <NEWLINE> <DEDENT> ROOP . append ( node ) <NEWLINE> <DEDENT> if c [ node - 1 ] == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> l = len ( ROOP ) <NEWLINE> if l != 0 : <NEWLINE> <INDENT> num = ( K - l - roopstart ) % ( l ) <NEWLINE> print ( ROOP [ num ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( node ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = [ ] <NEWLINE> if len ( S ) == len ( T ) : <NEWLINE> <INDENT> kazu = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> kazu += 1 <NEWLINE> <DEDENT> <DEDENT> cnt . append ( kazu ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( S ) - len ( T ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> kari = S [ i : i + len ( T ) ] <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if kari [ j ] != T [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> cnt . append ( count ) <NEWLINE> <DEDENT> print ( min ( cnt ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from functools import lru_cache <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 2000 ) <NEWLINE> <NL> s = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> if n <= 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> count += dfs ( n - i ) <NEWLINE> count %= mod <NEWLINE> <NL> <DEDENT> return count % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = dfs ( s ) <NEWLINE> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> costA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> costB = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> costA = [ 0 ] + costA <NEWLINE> costB = [ 0 ] + costB <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> costA [ i + 1 ] += costA [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> costB [ i + 1 ] += costB [ i ] <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> def upper_bound ( list1 , K ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list1 ) <COMMENT> <NEWLINE> while high - low != 1 : <NEWLINE> <INDENT> mid = ( high + low ) // 2 <NEWLINE> if list1 [ mid ] > K : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> <DEDENT> return low <COMMENT> <NEWLINE> <NL> <DEDENT> number = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N + 1 ) : <COMMENT> <NEWLINE> <INDENT> time = K - costA [ i ] <NEWLINE> if time < 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> number . append ( i + upper_bound ( costB , time ) ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> print ( max ( number ) ) <NEWLINE> <NL> <NL> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> answer = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> answer = answer * A [ i ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> avant = <STRING> <NEWLINE> compte = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] != avant : <NEWLINE> <INDENT> compte += 1 <NEWLINE> avant = l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( compte ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> import numpy as np <NEWLINE> import scipy <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import permutations , combinations <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplt ( n ) : return [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> A = inpl ( ) <NEWLINE> <NL> sss = list ( itertools . accumulate ( A ) ) <NEWLINE> ss = sum ( A ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> s = ( s + ( ( ss - sss [ i ] ) * A [ i ] ) ) % mod <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> head = <STRING> <COMMENT> <NEWLINE> end = <STRING> <COMMENT> <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> que = [ i for i in input ( ) . split ( ) ] <NEWLINE> if que [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag ^= True <COMMENT> <NEWLINE> <DEDENT> elif que [ 0 ] == <STRING> and flag is True : <NEWLINE> <INDENT> if que [ 1 ] == <STRING> : <NEWLINE> <INDENT> head = que [ 2 ] + head <NEWLINE> <DEDENT> elif que [ 1 ] == <STRING> : <NEWLINE> <INDENT> end = end + que [ 2 ] <NEWLINE> <DEDENT> <DEDENT> elif que [ 0 ] == <STRING> and flag is False : <NEWLINE> <INDENT> if que [ 1 ] == <STRING> : <NEWLINE> <INDENT> end = end + que [ 2 ] <NEWLINE> <DEDENT> elif que [ 1 ] == <STRING> : <NEWLINE> <INDENT> head = que [ 2 ] + head <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = head + s + end <NEWLINE> if flag is False : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H . sort ( ) <NEWLINE> if ( N < K ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> H [ N - i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( H ) ) <NEWLINE>
tukawan = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for number in A : <NEWLINE> <INDENT> result = result * number <NEWLINE> <NL> if result > 1000000000000000000 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> As , Bs = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = As , Bs <NEWLINE> while True : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> gcd = b <NEWLINE> break <NEWLINE> <DEDENT> a , b = b , a % b <NEWLINE> <DEDENT> print ( gcd , int ( As * Bs / gcd ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin , stdout <NEWLINE> from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def dfs1 ( src ) : <NEWLINE> <INDENT> global steps <NEWLINE> if steps == rem : return src <NEWLINE> steps += 1 <NEWLINE> return dfs1 ( g [ src ] [ 0 ] ) <NEWLINE> <DEDENT> def dfs ( src ) : <NEWLINE> <INDENT> global steps , done , boc , nic <NEWLINE> vis [ src ] = 1 <NEWLINE> steps += 1 <NEWLINE> if steps - 1 == k : <NEWLINE> <INDENT> print ( src ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> dfn [ src ] = steps <NEWLINE> for neigh in g [ src ] : <NEWLINE> <INDENT> if not vis [ neigh ] : dfs ( neigh ) <NEWLINE> else : <NEWLINE> <INDENT> boc , done , nic = [ neigh , steps , steps - dfn [ neigh ] + 1 ] <NEWLINE> <COMMENT> <NL> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , k = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> done , boc , nic = 0 , 0 , 0 <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g [ i ] += [ a [ i - 1 ] ] <NEWLINE> <DEDENT> vis = [ 0 ] * ( n + 1 ) <NEWLINE> dfn = [ 0 ] * ( 1 + n ) <NEWLINE> steps = 0 <NEWLINE> dfs ( 1 ) <NEWLINE> <COMMENT> <NL> left = k - done <NEWLINE> rem = ( left % nic ) <NEWLINE> if rem == 0 : rem = nic <NEWLINE> steps = 1 <NEWLINE> print ( dfs1 ( g [ boc ] [ 0 ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i - 1 ] < A [ i + K - 1 ] else <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for k in ans : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> def solve ( A : int , B : int , N : int ) : <NEWLINE> <INDENT> x = min ( B - 1 , N ) <NEWLINE> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> A = int ( next ( tokens ) ) <COMMENT> <NEWLINE> B = int ( next ( tokens ) ) <COMMENT> <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( A , B , N ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> l = [ int ( i ) for i in range ( - 200 , 201 ) ] <NEWLINE> ll = [ ] <NEWLINE> for idx in l : <NEWLINE> <INDENT> if idx not in p : <NEWLINE> <INDENT> ll . append ( idx ) <NEWLINE> <DEDENT> <DEDENT> mn = 1000 <NEWLINE> if len ( ll ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mn = 1000 <NEWLINE> for i in range ( len ( ll ) ) : <NEWLINE> <INDENT> if abs ( ll [ i ] - x ) < mn : <NEWLINE> <INDENT> mn = abs ( ll [ i ] - x ) <NEWLINE> ans = ll [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for ai in range ( N // 4 , 3500 ) : <NEWLINE> <INDENT> for bi in range ( N // 4 , 3500 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ci = N * ai * bi / ( 4 * ai * bi - N * ai - N * bi ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ci == int ( ci ) and ci > 0 : <NEWLINE> <INDENT> print ( ai , bi , int ( ci ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 ; <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= a [ i ] <NEWLINE> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> s = 1 <NEWLINE> M = [ 0 ] <NEWLINE> B = [ 0 ] * ( n + 1 ) <NEWLINE> while cnt < n : <NEWLINE> <INDENT> s = A [ s - 1 ] <NEWLINE> if B [ s - 1 ] == 0 : <NEWLINE> <INDENT> B [ s - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> imp = s - 1 <NEWLINE> break <NEWLINE> <DEDENT> M . append ( s - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> x = M . index ( imp ) <NEWLINE> y = len ( M ) - x <NEWLINE> <NL> if k <= x : <NEWLINE> <INDENT> print ( M [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = M [ x : ] <NEWLINE> print ( N [ ( k - x ) % y ] + 1 ) <NEWLINE> <DEDENT>
import copy <NEWLINE> import math <NEWLINE> import time <NEWLINE> import statistics <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> <COMMENT> <NL> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_list ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_int_multi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def get_string_char_list ( ) : <NEWLINE> <INDENT> return list ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> n = get_int ( ) <NEWLINE> <NL> a_list = get_int_list ( ) <NEWLINE> b_list = get_int_list ( ) <NEWLINE> c_list = get_int_list ( ) <NEWLINE> <NL> a_list . sort ( ) <NEWLINE> b_list . sort ( ) <NEWLINE> c_list . sort ( ) <NEWLINE> <NL> a_count = [ ] <NEWLINE> b_count = [ ] <NEWLINE> b_count2 = [ ] <NEWLINE> <NL> idx = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> idx = bisect . bisect_right ( b_list , a , idx ) <NEWLINE> a_count . append ( idx ) <NEWLINE> <NL> <DEDENT> idx = 0 <NEWLINE> for b in b_list : <NEWLINE> <INDENT> idx = bisect . bisect_right ( c_list , b , idx ) <NEWLINE> b_count . append ( idx ) <NEWLINE> <NL> <DEDENT> ruikei = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ruikei += n - b_count [ i ] <NEWLINE> b_count2 . append ( ruikei ) <NEWLINE> <NL> <DEDENT> b_count2 . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in a_count : <NEWLINE> <INDENT> if a == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += b_count2 [ a ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
import string <NEWLINE> abc = string . ascii_lowercase <NEWLINE> s = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> index = 0 <NEWLINE> while K > 0 : <NEWLINE> <INDENT> if index == len ( s ) - 1 : <NEWLINE> <INDENT> s [ index ] = abc [ ( abc . index ( s [ index ] ) + K ) % 26 ] <NEWLINE> break <NEWLINE> <DEDENT> tmp = 26 - abc . index ( s [ index ] ) <NEWLINE> if tmp == 26 : <NEWLINE> <INDENT> index += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if K >= tmp : <NEWLINE> <INDENT> s [ index ] = <STRING> <NEWLINE> index += 1 <NEWLINE> K -= tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
l = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( l [ int ( input ( ) ) - 1 ] ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b - 1 : <NEWLINE> <INDENT> ans = ( a * ( n % b ) ) // b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( a * ( ( b - 1 ) % b ) ) // b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] != S [ k ] != S [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> leg = [ 0 ] * n <NEWLINE> leg [ 0 ] = 0 <NEWLINE> <NL> p = 0 <NEWLINE> city_old = 1 <NEWLINE> for x in range ( k ) : <NEWLINE> <INDENT> city_new = a [ city_old - 1 ] <NEWLINE> if leg [ city_new - 1 ] == 0 and city_new != 1 : <NEWLINE> <INDENT> leg [ city_new - 1 ] = x + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = x + 1 - leg [ city_new - 1 ] <NEWLINE> modk = ( k - ( x + 1 ) ) % loop <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> city_old = city_new <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> if p == k : <NEWLINE> <INDENT> print ( city_old ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> city_old = city_new <NEWLINE> for x in range ( modk ) : <NEWLINE> <INDENT> city_new = a [ city_old - 1 ] <NEWLINE> city_old = city_new <NEWLINE> <NL> <DEDENT> print ( city_old ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> pro = 1 <NEWLINE> for num in l : <NEWLINE> <INDENT> pro = pro * num <NEWLINE> if pro > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( pro ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> l = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a = AB [ i ] [ 0 ] <NEWLINE> b = AB [ i ] [ 1 ] <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> point = [ 0 ] * ( N + 1 ) <NEWLINE> search = [ 0 ] * ( N + 1 ) <NEWLINE> search [ 1 ] = 1 <NEWLINE> <NL> que = [ ] <NEWLINE> que . append ( 1 ) <NEWLINE> p = 0 <NEWLINE> <NL> while len ( que ) != N : <NEWLINE> <INDENT> now = que [ p ] <NEWLINE> for i in range ( len ( l [ now ] ) ) : <NEWLINE> <INDENT> n = l [ now ] [ i ] <NEWLINE> if search [ n ] == 0 : <NEWLINE> <INDENT> search [ n ] = 1 <NEWLINE> que . append ( n ) <NEWLINE> point [ n ] = now <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( point [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> cnt = [ 0 ] * 10001 <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> x = i * i + j * j + k * k + i * j + j * k + i * k <NEWLINE> if ( x <= 10000 ) : <NEWLINE> <INDENT> cnt [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> R = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> <NL> countL = collections . Counter ( L ) <NEWLINE> countR = collections . Counter ( R ) <NEWLINE> <NL> print ( sum ( [ countL [ n ] * countR [ n ] for n in countL . keys ( ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> string = input ( ) <NEWLINE> S . append ( string ) <NEWLINE> <DEDENT> S = sorted ( S ) <NEWLINE> count = N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> h = np . array ( [ - 1 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> dp = np . array ( [ - 1 for _ in range ( N + 1 ) ] , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> <NL> dp [ 1 ] = 0 <NEWLINE> for k in range ( 2 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> <STRING> <NEWLINE> start_index = max ( 1 , k - K ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> candidate = dp [ start_index : k ] + np . abs ( h [ k ] - h [ start_index : k ] ) <NEWLINE> dp [ k ] = np . min ( candidate ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> PX = defaultdict ( int ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> PX [ p ] += x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> visited = set ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def dfs ( now , sum_ ) : <NEWLINE> <INDENT> visited . add ( now ) <NEWLINE> for next_ in G [ now ] : <NEWLINE> <INDENT> if next_ not in visited : <NEWLINE> <INDENT> sum_ += PX [ next_ ] <NEWLINE> sum_ = dfs ( next_ , sum_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ now ] = sum_ <NEWLINE> sum_ -= PX [ now ] <NEWLINE> return sum_ <NEWLINE> <NL> <DEDENT> dfs ( 1 , PX [ 1 ] ) <NEWLINE> <NL> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> H , W = 10 , 37 <NEWLINE> ARR = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> ARR . append ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def calculate ( h , w , arr ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> <NL> q . append ( ( 0 , 0 ) ) <NEWLINE> <NL> dx = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dy = [ - 1 , 0 , 1 , 0 ] <NEWLINE> <NL> distance = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> distance [ 0 ] [ 0 ] = 1 <NEWLINE> while q . __len__ ( ) > 0 : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> my = y + dy [ i ] <NEWLINE> mx = x + dx [ i ] <NEWLINE> if ( my >= 0 ) and ( mx >= 0 ) and ( my <= ( h - 1 ) ) and ( mx <= ( w - 1 ) ) and ( distance [ my ] [ mx ] == 0 ) and ( <NEWLINE> <INDENT> arr [ my ] [ mx ] == <STRING> ) : <NEWLINE> distance [ my ] [ mx ] = distance [ y ] [ x ] + 1 <NEWLINE> q . append ( ( my , mx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> mmk = 0 <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> mmk += arr [ j ] . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> if distance [ h - 1 ] [ w - 1 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h * w - distance [ h - 1 ] [ w - 1 ] - mmk ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> calculate ( H , W , ARR ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> d = list ( c ) <NEWLINE> <NL> i = 0 <NEWLINE> j = N - 1 <NEWLINE> result = 0 <NEWLINE> while True : <NEWLINE> <INDENT> while i < N and d [ i ] != <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while j > 0 and d [ j ] != <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i == N or j == - 1 or i >= j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d [ i ] = <STRING> <NEWLINE> d [ j ] = <STRING> <NEWLINE> result += 1 <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def pfact ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : pf [ m ] = 1 <NEWLINE> return pf <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i , j in pfact ( p ) . items ( ) : <NEWLINE> <INDENT> ans *= i ** ( j // n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( l ) [ : : - 1 ] <NEWLINE> print ( l [ K - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> now = len ( s ) <NEWLINE> while 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> if 7 <= now : <NEWLINE> <INDENT> if s [ now - 7 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 7 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if 6 <= now : <NEWLINE> <INDENT> if s [ now - 6 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 6 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if 5 <= now : <NEWLINE> <INDENT> if s [ now - 5 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 5 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> if s [ now - 5 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 5 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if now == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif now < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lose = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if heights [ x - 1 ] > heights [ y - 1 ] : <NEWLINE> <INDENT> lose . append ( y ) <NEWLINE> <DEDENT> elif heights [ x - 1 ] < heights [ y - 1 ] : <NEWLINE> <INDENT> lose . append ( x ) <NEWLINE> <DEDENT> elif heights [ x - 1 ] == heights [ y - 1 ] : <NEWLINE> <INDENT> lose . append ( y ) <NEWLINE> lose . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( list ( set ( lose ) ) ) ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> res = [ math . gcd ( a , math . gcd ( b , c ) ) for a in range ( 1 , K + 1 ) for b in range ( 1 , K + 1 ) for c in range ( 1 , K + 1 ) ] <NEWLINE> <NL> <NL> <NL> print ( sum ( res ) ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> Sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <DEDENT> s = [ * range ( len ( a ) ) ] <NEWLINE> sort_s = sorted ( s , key = lambda i : a [ i ] ) <NEWLINE> sort_a = [ a [ i ] for i in sort_s ] <NEWLINE> sort_b = [ b [ i ] for i in sort_s ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Sum += sort_b [ i ] <NEWLINE> if Sum >= K : <NEWLINE> <INDENT> print ( sort_a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> class Room : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . roots = [ ] <NEWLINE> self . kyori = - 1 <NEWLINE> self . near = 0 <NEWLINE> <NL> <DEDENT> def add_root ( self , to ) : <NEWLINE> <INDENT> self . roots . append ( to ) <NEWLINE> <DEDENT> def set_kyori ( self , num , kyori ) : <NEWLINE> <INDENT> self . kyori = kyori <NEWLINE> self . near = num <NEWLINE> <NL> <DEDENT> <DEDENT> r_list = sorted ( np . unique ( np . array ( list ( itertools . chain . from_iterable ( root ) ) ) ) ) <NEWLINE> rooms = { i : Room ( i ) for i in r_list } <NEWLINE> <NL> for r in root : <NEWLINE> <INDENT> a , b = rooms [ r [ 0 ] ] , rooms [ r [ 1 ] ] <NEWLINE> a . add_root ( b ) <NEWLINE> b . add_root ( a ) <NEWLINE> <NL> <DEDENT> kyori = 0 <NEWLINE> near = 0 <NEWLINE> rooms [ 1 ] . set_kyori ( near , kyori ) <NEWLINE> rooms [ 1 ] . near = near <NEWLINE> q = deque ( ) <NEWLINE> q . append ( rooms [ 1 ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> kyori += 1 <NEWLINE> for r in node . roots : <NEWLINE> <INDENT> if r . kyori != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> r . set_kyori ( node . num , kyori ) <NEWLINE> q . append ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> rooms [ 1 ] . set_kyori ( 0 , 0 ) <NEWLINE> for r in rooms . values ( ) : <NEWLINE> <INDENT> if r . kyori == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for r in list ( rooms . values ( ) ) [ 1 : ] : <NEWLINE> <INDENT> print ( r . near ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> ans = A [ 0 ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] != 1 : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( str , input ( ) . rstrip ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> arr = sum ( arr , [ ] ) <NEWLINE> <NL> c = Counter ( arr ) <NEWLINE> c = list ( c . values ( ) ) <NEWLINE> <NL> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> ans = all ( [ x % 4 == 0 for x in c ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> elif h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> even = ( h + w ) // 2 - 1 <COMMENT> <NEWLINE> odd_cnt = len ( [ x for x in c if x % 2 == 1 ] ) <NEWLINE> if odd_cnt != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> odd = sum ( [ x for x in c if x % 2 == 1 ] ) <NEWLINE> if odd % 4 == 3 : <NEWLINE> <INDENT> even -= 1 <NEWLINE> <DEDENT> c . remove ( odd ) <NEWLINE> <COMMENT> <NL> ans = True if sum ( [ x % 4 == 2 for x in c ] ) <= even else False <NEWLINE> ans &= all ( [ x % 4 == 0 for x in c if x % 4 != 2 ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> even = h // 2 if h % 2 == 0 else w // 2 <COMMENT> <NEWLINE> <COMMENT> <NL> ans = True if sum ( [ x % 4 == 2 for x in c ] ) <= even else False <NEWLINE> ans &= all ( [ x % 4 == 0 for x in c if x % 4 != 2 ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = [ ] <NEWLINE> price_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price_list . append ( tmp . pop ( 0 ) ) <NEWLINE> a_list . append ( tmp ) <NEWLINE> <NL> <DEDENT> all_list = [ x for x in range ( len ( a_list ) ) ] <NEWLINE> prices = [ ] <NEWLINE> for i in range ( 1 , len ( a_list ) + 1 ) : <NEWLINE> <INDENT> for y in combinations ( all_list , i ) : <NEWLINE> <INDENT> tmp = np . zeros ( m ) <NEWLINE> price = 0 <NEWLINE> for ch in y : <NEWLINE> <INDENT> tmp += np . array ( a_list [ ch ] ) <NEWLINE> price += price_list [ ch ] <NEWLINE> <DEDENT> if np . all ( tmp >= x ) : <NEWLINE> <INDENT> prices . append ( price ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if prices != [ ] : <NEWLINE> <INDENT> print ( min ( prices ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i <= b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if b - a + 1 >= 2 * k : <NEWLINE> <INDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( a + k , b + 1 ) : <NEWLINE> <INDENT> if j <= b : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . ps = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . ps [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . ps [ x ] = self . find ( self . ps [ x ] ) <NEWLINE> return self . ps [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . ps [ x ] > self . ps [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . ps [ x ] += self . ps [ y ] <NEWLINE> self . ps [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> return - self . ps [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> friends = [ 0 ] * ( N + 1 ) <NEWLINE> chain = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> friends [ A ] += 1 <NEWLINE> friends [ B ] += 1 <NEWLINE> uf . union ( A , B ) <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( C , D ) : <NEWLINE> <INDENT> friends [ C ] += 1 <NEWLINE> friends [ D ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans . append ( uf . size ( i ) - friends [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in P : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> P . sort ( reverse = True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans *= P [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ 0 ] + list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> point = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in p [ i : ] : <NEWLINE> <INDENT> a = p [ i ] + j <NEWLINE> if a < m : <NEWLINE> <INDENT> point . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> point . sort ( ) <NEWLINE> <NL> print ( max ( i + point [ bisect . bisect_left ( point , m - i ) - 1 ] for i in point ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count_a = collections . Counter ( a_list ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( count_a [ i ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( 150 ) : <NEWLINE> <INDENT> for b in range ( - 150 , 150 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> b = [ a [ i ] for i in range ( n + 1 ) ] <NEWLINE> for i in reversed ( range ( 0 , n ) ) : <NEWLINE> <INDENT> b [ i ] += b [ i + 1 ] <NEWLINE> <DEDENT> pow2 = [ 1 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pow2 [ i ] = 2 * pow2 [ i - 1 ] <NEWLINE> <DEDENT> result = a [ n ] <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = 2 * d + a [ i ] <NEWLINE> if pow2 [ i ] - d < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> result += min ( pow2 [ i ] - d , b [ i + 1 ] ) + a [ i ] <NEWLINE> <DEDENT> d = 2 * d + a [ n ] <NEWLINE> if pow2 [ n ] - d < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = int ( x / 10 ) <NEWLINE> <DEDENT> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> Ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if X - d not in Ps : <NEWLINE> <INDENT> print ( X - d ) <NEWLINE> break <NEWLINE> <DEDENT> elif X + d not in Ps : <NEWLINE> <INDENT> print ( X + d ) <NEWLINE> break <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 10 ** n - 9 ** n - 9 ** n + 8 ** n <NEWLINE> print ( count % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l1 = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> l2 = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> def nibutan ( a , k ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( a ) <NEWLINE> while r > l : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if a [ m ] == k : <NEWLINE> <INDENT> return m <NEWLINE> <DEDENT> elif k < a [ m ] : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in l2 : <NEWLINE> <INDENT> if nibutan ( l1 , i ) != - 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> sumnation = 0 <NEWLINE> gcdlist = [ ] <NEWLINE> for A in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for B in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcdlist . append ( math . gcd ( A , B ) ) <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , 1 + K ) : <NEWLINE> <INDENT> for b in range ( 1 , 1 + K ) : <NEWLINE> <INDENT> gcd_a_b = gcdlist [ ( a - 1 ) * K + b - 1 ] <NEWLINE> for c in range ( 1 , 1 + K ) : <NEWLINE> <INDENT> sumnation += gcdlist [ ( gcd_a_b - 1 ) * K + c - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sumnation ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a , reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> if b [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from bisect import bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> shop = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> shop . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt += shop [ i ] [ 1 ] <NEWLINE> if M <= cnt : <NEWLINE> <INDENT> dif = cnt - M <NEWLINE> ans += shop [ i ] [ 0 ] * shop [ i ] [ 1 ] - dif * shop [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += shop [ i ] [ 0 ] * shop [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> tmp = 0 <NEWLINE> asm = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += A [ i ] <NEWLINE> asm += [ tmp ] <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if asm [ - i ] * 2 >= A [ - i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
s = int ( input ( ) ) <NEWLINE> print ( s // 3600 , <STRING> , ( s % 3600 ) // 60 , <STRING> , s % 60 , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for x in range ( 1 , int ( ( N - 1 ) / 2 ) ) : <NEWLINE> <INDENT> for y in range ( x , int ( ( N - 1 ) / 2 ) ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + 1 ** 2 + x * y + y * 1 + 1 * x > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( y , int ( ( N - 1 ) / 2 ) ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= N : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 ] += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 ] += 6 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( ans [ n ] ) <NEWLINE> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> path = [ 1 ] <NEWLINE> checked = [ False ] * N <NEWLINE> detect_loop = False <NEWLINE> <NL> current_pos = 1 <NEWLINE> while not detect_loop : <NEWLINE> <INDENT> current_pos = A [ current_pos - 1 ] <NEWLINE> <NL> if checked [ current_pos - 1 ] : <NEWLINE> <INDENT> detect_loop = True <NEWLINE> <NL> <DEDENT> path . append ( current_pos ) <NEWLINE> checked [ current_pos - 1 ] = True <NEWLINE> <NL> <DEDENT> loop = path [ ( idx : = path . index ( current_pos ) ) : - 1 ] <NEWLINE> straight = path [ : idx ] <NEWLINE> <NL> if K < len ( straight ) : <NEWLINE> <INDENT> print ( straight [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( K - len ( straight ) ) % len ( loop ) ] ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> hanten = False <NEWLINE> mae = <STRING> <NEWLINE> usiro = <STRING> <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if len ( tmp ) == 1 : <NEWLINE> <INDENT> hanten = not ( hanten ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if hanten == False : <NEWLINE> <INDENT> if tmp [ 2 ] == <STRING> : <NEWLINE> <INDENT> mae = tmp [ 4 ] + mae <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> usiro = usiro + tmp [ 4 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if tmp [ 2 ] == <STRING> : <NEWLINE> <INDENT> usiro = usiro + tmp [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mae = tmp [ 4 ] + mae <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = mae + s + usiro <NEWLINE> if hanten == False : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> roads = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> roads [ x - 1 ] . append ( y - 1 ) <NEWLINE> roads [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> bestcount = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> best = 1 <COMMENT> <NEWLINE> for j in roads [ i ] : <NEWLINE> <INDENT> if ( height [ j ] >= height [ i ] ) : <NEWLINE> <INDENT> best = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( best == 1 ) : <NEWLINE> <INDENT> bestcount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( bestcount ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( a ) for a in A ] <NEWLINE> S = [ 1 ] <NEWLINE> a = 1 <NEWLINE> number = 0 <NEWLINE> numbers = [ - 1 for _ in range ( N ) ] <NEWLINE> for _ in range ( N + 1 ) : <NEWLINE> <INDENT> b = A [ a - 1 ] <NEWLINE> if numbers [ b - 1 ] != - 1 : <NEWLINE> <INDENT> c = numbers [ b - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> numbers [ b - 1 ] = number <NEWLINE> number += 1 <NEWLINE> S . append ( b ) <NEWLINE> a = b <NEWLINE> <DEDENT> T = S [ c + 1 : number + 1 ] <NEWLINE> if K <= number : <NEWLINE> <INDENT> print ( S [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = K - c - 1 <NEWLINE> y = z % ( number - c ) <NEWLINE> print ( T [ y ] ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . root = key <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id , key ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def set_status ( self , id , key ) : <NEWLINE> <INDENT> global node_list <NEWLINE> parent_id = math . floor ( id / 2 ) <NEWLINE> odd = id % 2 <NEWLINE> self . parent = node_list [ parent_id ] <NEWLINE> if odd == 0 : <NEWLINE> <INDENT> self . parent . left = self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent . right = self <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def print_nodes ( ) : <NEWLINE> <INDENT> global node_list <NEWLINE> node_list . pop ( 0 ) <NEWLINE> for node in node_list : <NEWLINE> <INDENT> print ( <STRING> . format ( node . id , node . key ) , end = <STRING> ) <NEWLINE> if node . parent : <NEWLINE> <INDENT> print ( <STRING> . format ( node . parent . key ) , end = <STRING> ) <NEWLINE> <DEDENT> if node . left : <NEWLINE> <INDENT> print ( <STRING> . format ( node . left . key ) , end = <STRING> ) <NEWLINE> <DEDENT> if node . right : <NEWLINE> <INDENT> print ( <STRING> . format ( node . right . key ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> input_num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> node_list = [ None ] <NEWLINE> <NL> for i , num in enumerate ( input_num ) : <NEWLINE> <INDENT> i = i + 1 <COMMENT> <NEWLINE> node = Node ( i , num ) <NEWLINE> node_list . append ( node ) <NEWLINE> <NL> if i == 1 : <NEWLINE> <INDENT> tree = Tree ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . set_status ( i , num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print_nodes ( ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if S - i - j <= K and 0 <= S - i - j : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> def XYZTriplets ( ) : <NEWLINE> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> <NL> list_num = [ ] <NEWLINE> <NL> count = [ 0 ] * num <NEWLINE> <NL> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> list_num . append ( i ) <NEWLINE> <NL> <DEDENT> for x in range ( 1 , int ( math . sqrt ( num ) ) ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( num ) ) ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( num ) ) ) : <NEWLINE> <NL> <INDENT> function = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> <NL> if function <= num and function > 0 : <NEWLINE> <INDENT> count [ function - 1 ] = count [ function - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , num ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> XYZTriplets ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in number : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= number [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> ba = [ ] <NEWLINE> for i , j in ab : <NEWLINE> <INDENT> ba . append ( [ j , i ] ) <NEWLINE> <NL> <DEDENT> ab . sort ( ) <NEWLINE> ba . sort ( reverse = True ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> n = ( N + 1 ) // 2 - 1 <NEWLINE> ans = ba [ n ] [ 0 ] - ab [ n ] [ 0 ] + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n = N // 2 - 1 <NEWLINE> ans = ( ba [ n ] [ 0 ] + ba [ n + 1 ] [ 0 ] ) - ( ab [ n ] [ 0 ] + ab [ n + 1 ] [ 0 ] ) + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a_angle = ( h / 12 + m / ( 60 * 12 ) ) * 360 <NEWLINE> b_angle = m / 60 * 360 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> line = 0 <NEWLINE> <NL> if a_angle > b_angle : <NEWLINE> <INDENT> angle = a_angle - b_angle <NEWLINE> <DEDENT> elif a_angle < b_angle : <NEWLINE> <INDENT> angle = b_angle - a_angle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> angle = 0 <NEWLINE> <NL> <NL> <NL> <DEDENT> if angle >= 180 : <NEWLINE> <INDENT> angle = 360 - angle <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> c2 = pow ( a , 2 ) + pow ( b , 2 ) - 2 * a * b * math . cos ( math . radians ( angle ) ) <NEWLINE> <NL> c = pow ( c2 , 1 / 2 ) <NEWLINE> print ( c ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( 1 , int ( m ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> ls . append ( i ) <NEWLINE> ls . append ( m // i ) <NEWLINE> <DEDENT> <DEDENT> ls = sorted ( list ( set ( ls ) ) , reverse = True ) <NEWLINE> for j in ls : <NEWLINE> <INDENT> if j * n <= m : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from decimal import Decimal , ROUND_HALF_UP , ROUND_HALF_EVEN <NEWLINE> from collections import deque <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LI2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def LS2 ( N ) : return [ sys . stdin . readline ( ) . split ( ) for i in range ( N ) ] <NEWLINE> def FILL ( i , h ) : return [ i for j in range ( h ) ] <NEWLINE> def FILL2 ( i , h , w ) : return [ FILL ( i , w ) for j in range ( h ) ] <NEWLINE> def FILL3 ( i , h , w , d ) : return [ FILL2 ( i , w , d ) for j in range ( h ) ] <NEWLINE> def FILL4 ( i , h , w , d , d2 ) : return [ FILL3 ( i , w , d , d2 ) for j in range ( h ) ] <NEWLINE> def sisha ( num , digit ) : return Decimal ( str ( num ) ) . quantize ( Decimal ( digit ) , rounding = ROUND_HALF_UP ) <NEWLINE> <COMMENT> <NL> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 + 10 ) <NEWLINE> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> def dfs ( i , before ) : <NEWLINE> <INDENT> global seq <NEWLINE> global ans <NEWLINE> added = 0 <NEWLINE> <NL> <COMMENT> <NL> pos = bisect_left ( seq , a [ i - 1 ] ) <NEWLINE> old = seq [ pos ] <NEWLINE> seq [ pos ] = a [ i - 1 ] <NEWLINE> ans [ i - 1 ] = bisect_left ( seq , INF ) <NEWLINE> <NL> <COMMENT> <NL> for u in to [ i ] : <NEWLINE> <INDENT> if u == before : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( u , i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> seq [ pos ] = old <NEWLINE> <NL> <NL> <DEDENT> N = I ( ) <NEWLINE> a = LI ( ) <NEWLINE> to = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> to [ 0 ] += [ 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = MI ( ) <NEWLINE> to [ u ] . append ( v ) <NEWLINE> to [ v ] . append ( u ) <NEWLINE> <DEDENT> seq = [ INF ] * N <NEWLINE> ans = [ - 1 ] * N <NEWLINE> <NL> dfs ( 1 , - 1 ) <NEWLINE> [ print ( i ) for i in ans ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sinput = input ( ) . split ( ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( sinput [ i ] ) ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> tinput = input ( ) . split ( ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> t . append ( int ( tinput [ i ] ) ) <NEWLINE> <DEDENT> answer = 0 <NEWLINE> <NL> import math <NEWLINE> for tn in t : <NEWLINE> <INDENT> smin = 0 <NEWLINE> smax = n - 1 <NEWLINE> c = math . floor ( ( n - 1 ) / 2 ) <NEWLINE> while ( smax - smin > 1 ) : <NEWLINE> <INDENT> if ( tn == s [ c ] ) : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ( tn > s [ c ] ) : <NEWLINE> <INDENT> if ( tn == s [ smax ] ) : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> break <NEWLINE> <DEDENT> smin = c <NEWLINE> c = math . floor ( ( smin + smax ) / 2 ) <NEWLINE> <DEDENT> elif ( tn < s [ c ] ) : <NEWLINE> <INDENT> if ( tn == s [ smin ] ) : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> break <NEWLINE> <DEDENT> smax = c <NEWLINE> c = math . floor ( ( smin + smax ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> amari = 1000000007 <NEWLINE> ans = ( ( sum ( A ) ) * ( sum ( A ) ) - sum ( a ** 2 for a in A ) ) <NEWLINE> print ( ans // 2 % amari ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> class QueueNode ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data , next = None , prev = None ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . next = next <NEWLINE> self . prev = prev <NEWLINE> <NL> <DEDENT> <DEDENT> class LinkList ( object ) : <NEWLINE> <INDENT> def __init__ ( self , head = None ) : <NEWLINE> <INDENT> self . head = head <NEWLINE> self . tail = head <NEWLINE> self . cur = head <NEWLINE> <NL> <DEDENT> def insert_q ( self , data ) : <NEWLINE> <INDENT> node = QueueNode ( data ) <NEWLINE> <NL> if self . cur is None : <NEWLINE> <INDENT> self . head = node <NEWLINE> self . tail = node <NEWLINE> self . cur = node <NEWLINE> return <NEWLINE> <NL> <DEDENT> currentNode = self . cur <NEWLINE> preNode = currentNode . prev <NEWLINE> <NL> if currentNode . prev is None : <NEWLINE> <INDENT> currentNode . prev = node <NEWLINE> node . next = currentNode <NEWLINE> self . head = self . cur = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . tail is not None : <NEWLINE> <INDENT> currentNode . prev = node <NEWLINE> node . prev = preNode <NEWLINE> node . next = currentNode <NEWLINE> preNode . next = node <NEWLINE> self . cur = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> currentNode . next = node <NEWLINE> node . prev = currentNode <NEWLINE> node . next = None <NEWLINE> self . cur = node <NEWLINE> self . tail = node <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def move_q ( self , mv ) : <NEWLINE> <INDENT> currentNode = self . cur <NEWLINE> cnt = mv <NEWLINE> while cnt != 0 : <NEWLINE> <INDENT> if mv < 0 : <COMMENT> <NEWLINE> <INDENT> if currentNode . prev is None : <NEWLINE> <INDENT> self . head = self . cur = currentNode <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> currentNode = currentNode . prev <NEWLINE> self . cur = currentNode <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if currentNode . next is None : <NEWLINE> <INDENT> self . cur = currentNode <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> currentNode = currentNode . next <NEWLINE> self . cur = currentNode <NEWLINE> cnt -= 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def delete_q ( self ) : <NEWLINE> <INDENT> currentNode = self . cur <NEWLINE> nexNode = currentNode . next <NEWLINE> preNode = currentNode . prev <NEWLINE> <NL> <COMMENT> <NL> if preNode is None : <NEWLINE> <INDENT> nexNode . prev = None <NEWLINE> self . head = nexNode <NEWLINE> self . cur = nexNode <NEWLINE> <COMMENT> <NL> <DEDENT> elif nexNode is None : <NEWLINE> <INDENT> preNode . next = None <NEWLINE> self . tail = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> preNode . next = currentNode . next <NEWLINE> nexNode . prev = currentNode . prev <NEWLINE> self . cur = currentNode . next <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def print_q ( self ) : <NEWLINE> <INDENT> if self . head is not None : <NEWLINE> <INDENT> print ( self . head . data ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def print_all ( self ) : <NEWLINE> <INDENT> if self . head is not None : <NEWLINE> <INDENT> currentNode = self . head <NEWLINE> while currentNode . next is not None : <NEWLINE> <INDENT> print ( currentNode . data ) <NEWLINE> currentNode = currentNode . next <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> loopnum = int ( input ( ) ) <NEWLINE> <NL> ll = LinkList ( ) <NEWLINE> ll . insert_q ( <STRING> ) <NEWLINE> for i in range ( loopnum ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> t = int ( cmd [ 1 ] ) <NEWLINE> ll . insert_q ( t ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> t = int ( cmd [ 1 ] ) <NEWLINE> ll . move_q ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll . delete_q ( ) <NEWLINE> <DEDENT> <DEDENT> ll . print_all ( ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> def bfs ( graph , visited , ss ) : <NEWLINE> <INDENT> queue = deque ( [ ss ] ) <NEWLINE> visited [ ss ] = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> while queue : <NEWLINE> <INDENT> s = queue . popleft ( ) <NEWLINE> for new_s in graph [ s ] : <NEWLINE> <INDENT> if visited [ new_s ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> visited [ new_s ] = visited [ s ] + 1 <NEWLINE> queue . append ( new_s ) <NEWLINE> ans [ new_s ] = s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> visited = [ - 1 ] * n <NEWLINE> ans = bfs ( graph , visited , 0 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> area = r * r * math . pi <NEWLINE> length = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> . format ( area ) , end = <STRING> ) <NEWLINE> print ( <STRING> . format ( length ) ) <NEWLINE>
import sys <NEWLINE> <NL> K = int ( sys . stdin . readline ( ) ) <NEWLINE> S = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> N_MAX = 10 ** 6 <COMMENT> <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N_MAX + 2 ) : <NEWLINE> <INDENT> inv . append ( ( - inv [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> ln = len ( S ) <NEWLINE> <NL> p1 = 1 <NEWLINE> p2 = 1 <NEWLINE> s2 = pow ( 26 , K , MOD ) <NEWLINE> <NL> for i in range ( 1 , K + 2 ) : <NEWLINE> <NL> <INDENT> ans += ( p1 * p2 * s2 ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> p1 = ( p1 * ( ln + i - 1 ) * inv [ i ] ) % MOD <NEWLINE> p2 = ( p2 * 25 ) % MOD <NEWLINE> <NL> <COMMENT> <NL> s2 = ( s2 * inv [ 26 ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> k = int ( readline ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> acc = 7 % k <NEWLINE> for n in range ( 1 , k + 10 ) : <NEWLINE> <INDENT> if acc == 0 : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <DEDENT> acc = ( 10 * acc + 7 ) % k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> sums = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( k , l ) <NEWLINE> for p in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sums += math . gcd ( a , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sums ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def s2nn ( s ) : return [ int ( c ) for c in s . split ( <STRING> ) ] <NEWLINE> def ss2nn ( ss ) : return [ int ( s ) for s in list ( ss ) ] <NEWLINE> def ss2nnn ( ss ) : return [ s2nn ( s ) for s in list ( ss ) ] <NEWLINE> def i2s ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def i2n ( ) : return int ( i2s ( ) ) <NEWLINE> def i2nn ( ) : return s2nn ( i2s ( ) ) <NEWLINE> def ii2ss ( n ) : return [ i2s ( ) for _ in range ( n ) ] <NEWLINE> def ii2nn ( n ) : return ss2nn ( ii2ss ( n ) ) <NEWLINE> def ii2nnn ( n ) : return ss2nnn ( ii2ss ( n ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , K , D = i2nn ( ) <NEWLINE> absX = abs ( X ) <NEWLINE> if absX >= K * D : <NEWLINE> <INDENT> print ( abs ( absX - K * D ) ) <NEWLINE> return <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> a , c = divmod ( absX , D ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( X ) <NEWLINE> return <NEWLINE> <DEDENT> b = K - a <NEWLINE> if b % 2 : <NEWLINE> <INDENT> print ( abs ( c - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( c ) ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in b : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = input ( ) <NEWLINE> A = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s != <STRING> : A . append ( i ) <NEWLINE> <DEDENT> if not A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( A ) // 2 ) : <NEWLINE> <INDENT> if S [ A [ i ] ] != S [ A [ - i - 1 ] ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = abs ( ( len ( S ) - 1 - A [ - 1 ] ) - A [ 0 ] ) <NEWLINE> for i in range ( len ( A ) // 2 ) : <NEWLINE> <INDENT> cnt = abs ( A [ i + 1 ] - A [ i ] - ( A [ - 1 - i ] - A [ - 2 - i ] ) ) <NEWLINE> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def solve ( G , a , lis , pre , p , ans ) : <NEWLINE> <INDENT> target = a [ p ] <NEWLINE> idx = bisect_left ( lis , target ) <NEWLINE> frm = lis [ idx ] <NEWLINE> to = target <NEWLINE> lis [ idx ] = to <NEWLINE> ans [ p ] = bisect_left ( lis , float ( <STRING> ) ) <NEWLINE> for v in G [ p ] : <NEWLINE> <INDENT> if v == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> solve ( G , a , lis , p , v , ans ) <NEWLINE> <DEDENT> lis [ idx ] = frm <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> G [ u ] . append ( v ) <NEWLINE> G [ v ] . append ( u ) <NEWLINE> <DEDENT> lis = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> ans = [ None ] * n <NEWLINE> solve ( G , a , lis , - 1 , 0 , ans ) <NEWLINE> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> out = r * g * b <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> w = 1 <NEWLINE> while i + w * 2 < N : <NEWLINE> <INDENT> if S [ i ] != S [ i + w ] and S [ i ] != S [ i + 2 * w ] and S [ i + w ] != S [ i + 2 * w ] : <NEWLINE> <INDENT> out = out - 1 <NEWLINE> <DEDENT> w = w + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 1 <NEWLINE> <NL> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> m = m * a <NEWLINE> <NL> if m > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> <NL> if H == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> import math as m <NEWLINE> n = m . floor ( m . log2 ( H ) ) + 1 <NEWLINE> ans = ( 2 ** n ) - 1 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> X = [ 0 ] * N <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> X [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * X , sep = <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cA = Counter ( A ) <NEWLINE> <NL> allS = 0 <NEWLINE> for key in cA : <NEWLINE> <INDENT> allS += cA [ key ] * ( cA [ key ] - 1 ) / 2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in cA . keys ( ) : <NEWLINE> <INDENT> print ( int ( allS - ( cA [ A [ i ] ] - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( allS ) ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> j = ( N - 1 ) // i <NEWLINE> cnt += j <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<STRING> <NEWLINE> <COMMENT> <NL> inputData = input ( ) <NEWLINE> <NL> for i in range ( len ( inputData ) ) : <NEWLINE> <INDENT> if <STRING> <= inputData [ i ] <= <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( inputData [ i ] . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> <= inputData [ i ] <= <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( inputData [ i ] . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( inputData [ i ] , end = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> temp = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = data [ temp - 1 ] <NEWLINE> count += 1 <NEWLINE> if temp == 2 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i + a [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += d [ i - a [ i ] ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> import math <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for m in a : <NEWLINE> <INDENT> d [ m ] += 1 <NEWLINE> <DEDENT> sm = 0 <NEWLINE> for m in d : <NEWLINE> <INDENT> if d [ m ] > 1 : <NEWLINE> <INDENT> sm += d [ m ] * ( d [ m ] - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> for m in a : <NEWLINE> <INDENT> if d [ m ] > 2 : <NEWLINE> <INDENT> print ( sm - d [ m ] + 1 ) <NEWLINE> <DEDENT> elif d [ m ] == 2 : <NEWLINE> <INDENT> print ( sm - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sm ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> A_max = A [ - 1 ] <NEWLINE> table = [ 0 ] * ( A_max + 1 ) <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> table [ x ] += 1 <NEWLINE> for y in range ( x * 2 , A_max + 1 , x ) : <NEWLINE> <INDENT> table [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result = sum ( [ 1 for x in A if table [ x ] == 1 ] ) <NEWLINE> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> F = [ 0 ] * len ( H ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( H [ A - 1 ] < H [ B - 1 ] ) : <NEWLINE> <INDENT> F [ A - 1 ] = 1 <NEWLINE> <DEDENT> elif ( H [ A - 1 ] > H [ B - 1 ] ) : <NEWLINE> <INDENT> F [ B - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F [ B - 1 ] = 1 <NEWLINE> F [ A - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( F . count ( 0 ) ) <NEWLINE>
from collections import deque <NEWLINE> import math ; floor , ceil = math . floor , math . ceil <NEWLINE> import sys ; input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> aint = lambda : int ( input ( ) ) ; ints = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Yes = lambda boolean : print ( <STRING> ) if boolean else print ( <STRING> ) <NEWLINE> YES = lambda boolean : print ( <STRING> ) if boolean else print ( <STRING> ) <NEWLINE> is_even = lambda x : True if x % 2 == 0 else False <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = aint ( ) <NEWLINE> a = ints ( ) ; d = deque ( a ) <NEWLINE> buka = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> buka [ d . popleft ( ) - 1 ] += 1 <NEWLINE> <DEDENT> for num in buka : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( str ( B [ i ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt2 = [ 0 ] * ( n ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cnt2 [ i ] = cnt2 [ i - 1 ] + cnt [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cnt2 [ r - 1 ] - cnt2 [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> if n % 3 != 0 : <NEWLINE> <INDENT> if all ( ( a [ i ] == 0 for i in range ( n ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a1 = a [ : n // 3 ] <NEWLINE> a2 = a [ n // 3 : n * 2 // 3 ] <NEWLINE> a3 = a [ n * 2 // 3 : ] <NEWLINE> if all ( ( a1 [ i ] == 0 for i in range ( n // 3 ) ) ) and all ( ( a2 [ i ] == a2 [ 0 ] for i in range ( n // 3 ) ) ) and all ( ( a3 [ i ] == a3 [ 0 ] for i in range ( n // 3 ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif all ( ( a1 [ i ] == a1 [ 0 ] for i in range ( n // 3 ) ) ) and all ( ( a2 [ i ] == a2 [ 0 ] for i in range ( n // 3 ) ) ) and all ( ( a3 [ i ] == a3 [ 0 ] for i in range ( n // 3 ) ) ) and a1 [ 0 ] ^ a2 [ 0 ] ^ a3 [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> m = list ( ) <NEWLINE> res = - 100 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m . append ( n ) <NEWLINE> <DEDENT> l = [ x for x in range ( 1 , M + 1 ) ] <NEWLINE> p = itertools . combinations_with_replacement ( l , N ) <NEWLINE> for p in p : <NEWLINE> <INDENT> total = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = m [ i ] [ 0 ] <NEWLINE> b = m [ i ] [ 1 ] <NEWLINE> A = p [ a - 1 ] <NEWLINE> B = p [ b - 1 ] <NEWLINE> C = B - A <NEWLINE> if m [ i ] [ 2 ] == C : <NEWLINE> <INDENT> total = total + m [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if res < total : <NEWLINE> <INDENT> res = total <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b > k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sum_a -= A [ i ] <NEWLINE> ans = ( ans + ( A [ i ] * sum_a ) % 1000000007 ) % 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , max_size ) : <NEWLINE> <INDENT> self . max_size = max_size <NEWLINE> self . dat = [ i for i in range ( self . max_size ) ] <NEWLINE> <NL> <DEDENT> def find ( self , vertex ) : <NEWLINE> <INDENT> if self . dat [ vertex ] is vertex : return vertex <NEWLINE> self . dat [ vertex ] = self . find ( self . dat [ vertex ] ) <NEWLINE> <COMMENT> <NL> return self . dat [ vertex ] <NEWLINE> <NL> <DEDENT> def merge ( self , child , parent ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . dat [ self . find ( child ) ] = self . dat [ self . find ( parent ) ] <NEWLINE> <NL> <DEDENT> def is_same ( self , v , w ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . find ( v ) == self . find ( w ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> uni = UnionFind ( n ) <NEWLINE> sys . setrecursionlimit ( 114514 ) <NEWLINE> while q > 0 : <NEWLINE> <INDENT> q -= 1 <NEWLINE> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com is 0 : <NEWLINE> <INDENT> uni . merge ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if uni . is_same ( x , y ) else 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> L = make_divisors ( N ) <NEWLINE> l = len ( L ) <NEWLINE> if l % 2 == 0 : <NEWLINE> <INDENT> a1 = str ( L [ l // 2 ] - 1 ) <NEWLINE> a2 = str ( L [ l // 2 ] ) <NEWLINE> print ( max ( len ( a1 ) , len ( a2 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1 = str ( L [ l // 2 - 1 ] ) <NEWLINE> a2 = str ( L [ l // 2 ] ) <NEWLINE> a3 = str ( L [ l // 2 + 1 ] ) <NEWLINE> d1 = max ( len ( a1 ) , len ( a2 ) ) <NEWLINE> d2 = max ( len ( a2 ) , len ( a3 ) ) <NEWLINE> print ( min ( d1 , d2 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def can_or_cannot ( A , K , x ) : <NEWLINE> <INDENT> kaisuu_sum = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] % x == 0 : <NEWLINE> <INDENT> temp = ( A [ i ] // x ) - 1 <NEWLINE> kaisuu_sum += temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = A [ i ] // x <NEWLINE> kaisuu_sum += temp <NEWLINE> <NL> <DEDENT> if kaisuu_sum > K : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <COMMENT> <NL> left = 0 <NEWLINE> right = A [ N - 1 ] <NEWLINE> <NL> if right == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> mid = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if right == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> <COMMENT> <NL> judge = can_or_cannot ( A , K , mid ) <NEWLINE> <COMMENT> <NL> if judge == <STRING> : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> elif judge == <STRING> : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> if left == right : <NEWLINE> <COMMENT> <NL> <INDENT> return right <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n , x , y = readInts ( ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> d [ min ( abs ( i - j ) , abs ( i - x ) + 1 + abs ( y - j ) , abs ( i - y ) + 1 + abs ( j - x ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ b , c ] ) <NEWLINE> <DEDENT> L . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> idx = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( idx > len ( L ) - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( A [ i ] < L [ idx ] [ 1 ] ) : <NEWLINE> <INDENT> A [ i ] = L [ idx ] [ 1 ] <NEWLINE> L [ idx ] [ 0 ] -= 1 <NEWLINE> if ( L [ idx ] [ 0 ] != 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
from functools import * <NEWLINE> @ lru_cache ( None ) <NEWLINE> def solve ( n , m ) : <NEWLINE> <INDENT> if not n : return 1 <NEWLINE> n %= m <NEWLINE> return - ~ solve ( n , bin ( n ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = int ( s , 2 ) <NEWLINE> * x , = map ( int , s ) <NEWLINE> h = sum ( x ) <NEWLINE> try : a , b = a % ( h - 1 ) , a % ( h + 1 ) <NEWLINE> except : b = a % ( h + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] : <NEWLINE> <INDENT> if not h - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> x [ i ] = 0 <NEWLINE> t = ( a - pow ( 2 , ~ i + n , h - 1 ) ) % ( h - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ i ] = 1 <NEWLINE> t = ( b + pow ( 2 , ~ i + n , h + 1 ) ) % ( h + 1 ) <NEWLINE> <DEDENT> r = solve ( t , bin ( t ) . count ( <STRING> ) ) <NEWLINE> x [ i ] ^= 1 <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
def solve_L ( ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> <NL> a = len ( X ) <NEWLINE> b = len ( Y ) <NEWLINE> c1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = X [ i ] <NEWLINE> c2 = c1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == Y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = solve_L ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in ls : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> goukei = 1 <NEWLINE> for i in ls : <NEWLINE> <INDENT> goukei *= i <NEWLINE> <NL> if goukei > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( goukei ) ) <NEWLINE>
from math import floor , ceil <NEWLINE> N = int ( input ( ) ) <NEWLINE> WHITE = 0 <NEWLINE> RED = 1 <NEWLINE> str = list ( map ( str , list ( input ( ) ) ) ) <NEWLINE> r = [ ] <NEWLINE> w = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w . append ( i ) if str [ i ] == <STRING> else r . append ( i ) <NEWLINE> str [ i ] = WHITE if str [ i ] == <STRING> else RED <NEWLINE> <DEDENT> r . reverse ( ) <NEWLINE> max_count = min ( len ( r ) , len ( w ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( max_count ) : <NEWLINE> <INDENT> if r [ i ] - w [ i ] > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt_h = [ 0 ] * h <COMMENT> <NEWLINE> cnt_w = [ 0 ] * w <COMMENT> <NEWLINE> dic = defaultdict ( int ) <COMMENT> <NEWLINE> <NL> for _ in range ( m ) : <COMMENT> <NEWLINE> <INDENT> h_m , w_m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> cnt_h [ h_m - 1 ] += 1 <COMMENT> <NEWLINE> cnt_w [ w_m - 1 ] += 1 <COMMENT> <NEWLINE> dic [ ( h_m - 1 , w_m - 1 ) ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> max_h = max ( cnt_h ) <NEWLINE> max_w = max ( cnt_w ) <NEWLINE> <NL> mh = [ ] <NEWLINE> mw = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if max_h == cnt_h [ i ] : <NEWLINE> <INDENT> mh . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if max_w == cnt_w [ j ] : <NEWLINE> <INDENT> mw . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in mh : <NEWLINE> <INDENT> for j in mw : <NEWLINE> <INDENT> if dic [ ( i , j ) ] == 0 : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_h + max_w - 1 ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> kai = x // d <NEWLINE> if kai == k : <NEWLINE> <INDENT> print ( x % d ) <NEWLINE> <DEDENT> elif kai > k : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = x % d <NEWLINE> left = abs ( x % d - d ) <NEWLINE> <NL> if ( kai + k ) % 2 == 0 : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <DEDENT> <DEDENT>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , parent , left , right ) : <NEWLINE> <INDENT> self . parent = parent <COMMENT> <NEWLINE> self . left = left <COMMENT> <NEWLINE> self . right = right <COMMENT> <NEWLINE> <NL> <DEDENT> def get_depth ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> depth = 1 <NEWLINE> t = Nodes [ self . parent ] <NEWLINE> while t . parent != - 1 : <NEWLINE> <INDENT> t = Nodes [ t . parent ] <NEWLINE> depth += 1 <NEWLINE> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> <DEDENT> def get_type ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif self . left == None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def decode_node_data ( n ) : <NEWLINE> <INDENT> global Nodes <NEWLINE> num_of_elem = len ( n ) <NEWLINE> if num_of_elem < 2 : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> elif num_of_elem == 2 : <COMMENT> <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> id , num_of_children = int ( n [ 0 ] ) , int ( n [ 1 ] ) <NEWLINE> children = n [ 2 : ] <NEWLINE> Nodes [ id ] . left = int ( children [ 0 ] ) <NEWLINE> prev_child = None <NEWLINE> for c in children : <NEWLINE> <INDENT> Nodes [ int ( c ) ] . parent = id <NEWLINE> if prev_child != None : <NEWLINE> <INDENT> Nodes [ prev_child ] . right = int ( c ) <NEWLINE> <DEDENT> prev_child = int ( c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> MAX_NODES = 100001 <NEWLINE> Nodes = [ Node ( - 1 , None , None ) for _ in range ( MAX_NODES ) ] <NEWLINE> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_nodes = int ( input ( ) ) <NEWLINE> node_data = [ ] <NEWLINE> for _ in range ( num_of_nodes ) : <NEWLINE> <INDENT> node_data . append ( input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for n in node_data : <NEWLINE> <INDENT> decode_node_data ( n ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> for node_id in range ( num_of_nodes ) : <NEWLINE> <INDENT> type = Nodes [ node_id ] . get_type ( ) <NEWLINE> children = [ ] <NEWLINE> if type != <STRING> : <NEWLINE> <INDENT> if Nodes [ node_id ] . left != None : <NEWLINE> <INDENT> c = Nodes [ node_id ] . left <NEWLINE> children . append ( c ) <NEWLINE> while Nodes [ c ] . right != None : <NEWLINE> <INDENT> c = Nodes [ c ] . right <NEWLINE> children . append ( c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( node_id , Nodes [ node_id ] . parent , Nodes [ node_id ] . get_depth ( ) , type , <NEWLINE> <INDENT> <STRING> . join ( map ( str , children ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> t = int ( N ** 0.5 + 1 ) <NEWLINE> for x in range ( 1 , t ) : <NEWLINE> <INDENT> for y in range ( 1 , t ) : <NEWLINE> <INDENT> for z in range ( 1 , t ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v <= N : ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> last = [ 0 ] * 26 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> ans = ans + s [ i ] [ t [ i ] ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if t [ i ] != j : <NEWLINE> <INDENT> last [ j ] += 1 <NEWLINE> ans = ans - ( c [ j ] * last [ j ] ) <NEWLINE> <DEDENT> elif t [ i ] == j : <NEWLINE> <INDENT> last [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , m , h , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : break <NEWLINE> s_lst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> i_lst = [ i for i in range ( n ) ] <NEWLINE> b_lst = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> b_lst = sorted ( b_lst , key = lambda x : x [ 1 ] ) <NEWLINE> pare_lst = [ ] <NEWLINE> for bar in b_lst : <NEWLINE> <INDENT> ind = bar [ 0 ] <NEWLINE> temp = i_lst [ ind ] <NEWLINE> i_lst [ ind ] = i_lst [ ind - 1 ] <NEWLINE> i_lst [ ind - 1 ] = temp <NEWLINE> pare_lst . append ( ( i_lst [ ind ] , i_lst [ ind - 1 ] ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> new_s_lst = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> new_s_lst [ i_lst [ i ] ] = s_lst [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans = sum ( new_s_lst [ : k ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> max_dec = 0 <NEWLINE> for pare in pare_lst : <NEWLINE> <INDENT> a = pare [ 0 ] <NEWLINE> b = pare [ 1 ] <NEWLINE> <COMMENT> <NL> if a < k and b >= k and new_s_lst [ a ] - new_s_lst [ b ] > max_dec : <NEWLINE> <INDENT> max_dec = new_s_lst [ a ] - new_s_lst [ b ] <NEWLINE> <DEDENT> if b < k and a >= k and new_s_lst [ b ] - new_s_lst [ a ] > max_dec : <NEWLINE> <INDENT> max_dec = new_s_lst [ b ] - new_s_lst [ a ] <NEWLINE> <DEDENT> <DEDENT> print ( ans - max_dec ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 ] * 1000001 <NEWLINE> A [ 0 ] = 7 % K <NEWLINE> ans = - 1 <NEWLINE> <NL> for i in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> A [ i ] = ( A [ i - 1 ] * 10 + 7 ) % K <NEWLINE> <NL> <DEDENT> for i in range ( 1000001 ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = - A [ i ] <NEWLINE> <DEDENT> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = - heapq . heappop ( A ) <NEWLINE> a = ( a // 2 ) * - 1 <NEWLINE> heapq . heappush ( A , a ) <NEWLINE> <DEDENT> print ( sum ( A ) * - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] = ( 1 + p [ i ] ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> S = [ 0 ] * N <NEWLINE> S [ 0 ] = p [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] + p [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = S [ K - 1 ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans = max ( ans , S [ i + K ] - S [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ - 1 , - 10 ** 11 ] , [ - 1 , 10 ** 11 ] ] <NEWLINE> aa = [ - 10 ** 11 , 10 ** 11 ] <NEWLINE> bb = [ - 10 ** 11 , 10 ** 11 ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ab . append ( [ 0 , x ] ) <NEWLINE> aa . append ( x ) <NEWLINE> <NL> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ab . append ( [ 1 , x ] ) <NEWLINE> bb . append ( x ) <NEWLINE> <DEDENT> ab = sorted ( ab , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) <NEWLINE> aa . sort ( ) <NEWLINE> bb . sort ( ) <NEWLINE> <NL> ab_arr = np . array ( ab ) <NEWLINE> ab_arr = ab_arr . T [ 1 ] <NEWLINE> <NL> a_arr = np . array ( aa ) <NEWLINE> b_arr = np . array ( bb ) <NEWLINE> <NL> for cq in range ( q ) : <NEWLINE> <INDENT> ans = 10 ** 12 <NEWLINE> s = int ( input ( ) ) <NEWLINE> ci = np . searchsorted ( ab_arr , s ) <NEWLINE> for cj in [ ci , ci - 1 ] : <NEWLINE> <INDENT> d = abs ( ab_arr [ cj ] - s ) <NEWLINE> flg = ab [ cj ] [ 0 ] <NEWLINE> if flg : <NEWLINE> <INDENT> na = np . searchsorted ( a_arr , ab_arr [ cj ] ) <NEWLINE> d2 = min ( abs ( a_arr [ na ] - ab_arr [ cj ] ) , abs ( a_arr [ na - 1 ] - ab_arr [ cj ] ) ) <NEWLINE> d += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nb = np . searchsorted ( b_arr , ab_arr [ cj ] ) <NEWLINE> d2 = min ( abs ( b_arr [ nb ] - ab_arr [ cj ] ) , abs ( b_arr [ nb - 1 ] - ab_arr [ cj ] ) ) <NEWLINE> d += d2 <NEWLINE> <DEDENT> ans = min ( ans , d ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
def move ( y , x ) : <NEWLINE> <INDENT> p [ 2 ] , p [ 3 ] = y , x <NEWLINE> if a [ p [ 0 ] + y ] [ p [ 1 ] + x ] == <STRING> : p [ 0 ] += y ; p [ 1 ] += x <NEWLINE> <NL> <DEDENT> def shoot ( ) : <NEWLINE> <INDENT> th = p [ 0 ] + p [ 2 ] <NEWLINE> tw = p [ 1 ] + p [ 3 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if a [ th ] [ tw ] == <STRING> : a [ th ] [ tw ] = <STRING> ; break <NEWLINE> elif a [ th ] [ tw ] == <STRING> : break <NEWLINE> else : th += p [ 2 ] ; tw += p [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for u in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if u > 0 : print ( ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ <STRING> ] * ( w + 2 ) ] + [ [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] for _ in range ( h ) ] + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : p = [ i , j , 0 , 1 ] ; a [ i ] [ j ] = <STRING> ; break <NEWLINE> elif a [ i ] [ j ] == <STRING> : p = [ i , j , - 1 , 0 ] ; a [ i ] [ j ] = <STRING> ; break <NEWLINE> elif a [ i ] [ j ] == <STRING> : p = [ i , j , 0 , - 1 ] ; a [ i ] [ j ] = <STRING> ; break <NEWLINE> elif a [ i ] [ j ] == <STRING> : p = [ i , j , 1 , 0 ] ; a [ i ] [ j ] = <STRING> ; break <NEWLINE> <DEDENT> <DEDENT> n , c = int ( input ( ) ) , input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : move ( - 1 , 0 ) <NEWLINE> elif c [ i ] == <STRING> : move ( 0 , 1 ) <NEWLINE> elif c [ i ] == <STRING> : move ( 0 , - 1 ) <NEWLINE> elif c [ i ] == <STRING> : move ( 1 , 0 ) <NEWLINE> else : shoot ( ) <NEWLINE> <DEDENT> if ( p [ 2 ] , p [ 3 ] ) == ( 0 , 1 ) : a [ p [ 0 ] ] [ p [ 1 ] ] = <STRING> <NEWLINE> elif ( p [ 2 ] , p [ 3 ] ) == ( - 1 , 0 ) : a [ p [ 0 ] ] [ p [ 1 ] ] = <STRING> <NEWLINE> elif ( p [ 2 ] , p [ 3 ] ) == ( 0 , - 1 ) : a [ p [ 0 ] ] [ p [ 1 ] ] = <STRING> <NEWLINE> else : a [ p [ 0 ] ] [ p [ 1 ] ] = <STRING> <NEWLINE> for i in a [ 1 : - 1 ] : print ( <STRING> . join ( i [ 1 : - 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import pprint <NEWLINE> import bisect <NEWLINE> from functools import reduce <NEWLINE> from copy import deepcopy <NEWLINE> from collections import deque <NEWLINE> from decimal import * <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> import math <NEWLINE> <NL> def rootCheck ( checkList ) : <NEWLINE> <INDENT> nextList = [ ] <NEWLINE> for i in checkList : <NEWLINE> <INDENT> for j in root [ i ] : <NEWLINE> <INDENT> if hint [ j ] == - 1 : <NEWLINE> <INDENT> hint [ j ] = i <NEWLINE> nextList . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( nextList ) > 0 : <NEWLINE> <INDENT> rootCheck ( nextList ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 in root : <NEWLINE> <INDENT> root [ b - 1 ] . append ( c - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ b - 1 ] = [ c - 1 ] <NEWLINE> <DEDENT> if c - 1 in root : <NEWLINE> <INDENT> root [ c - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ c - 1 ] = [ b - 1 ] <NEWLINE> <DEDENT> <DEDENT> hint = [ - 1 ] * n <NEWLINE> <NL> for i in root [ 0 ] : <NEWLINE> <INDENT> if hint [ i ] == - 1 : <NEWLINE> <INDENT> hint [ i ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> rootCheck ( root [ 0 ] ) <NEWLINE> <NL> if - 1 in hint : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in hint [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> nocontest = [ 1 for i in range ( 26 ) ] <NEWLINE> count_nocontest = [ 1 for i in range ( 26 ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> contest = [ 0 for j in range ( 26 ) ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> contest [ j ] = c [ j ] * nocontest [ j ] * s [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> max_contest = max ( contest ) <NEWLINE> ans = contest . index ( max_contest ) <NEWLINE> print ( ans + 1 ) <NEWLINE> <NL> for j in range ( 26 ) : <NEWLINE> <INDENT> if j == ans : <NEWLINE> <INDENT> nocontest [ j ] = 1 <NEWLINE> count_nocontest [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nocontest [ j ] += count_nocontest [ j ] <NEWLINE> count_nocontest [ j ] += 1 <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( list ( set ( x ) ) ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ll = np . ones ( 1 ) * ( - 1 ) <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> ll = np . append ( ll , int ( i ) ) <NEWLINE> <NL> <DEDENT> for j in p : <NEWLINE> <INDENT> ll = ll [ ~ ( ll == j ) ] <NEWLINE> <NL> <DEDENT> if len ( ll ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> a = np . zeros ( len ( ll ) ) <NEWLINE> for i in range ( len ( ll ) ) : <NEWLINE> <INDENT> a [ i ] = abs ( x - ll [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( int ( ll [ np . argmin ( a ) ] ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tkhs = math . ceil ( c / b ) <NEWLINE> aok = math . ceil ( a / d ) <NEWLINE> <NL> if tkhs <= aok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num_limit = int ( input ( ) ) <NEWLINE> num_list = [ 0 ] * num_limit <NEWLINE> j_limit = int ( num_limit ** 0.5 ) <NEWLINE> for j in range ( 1 , j_limit + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if num_limit >= j ** 2 + k ** 2 + l ** 2 + j * k + k * l + l * j : <NEWLINE> <INDENT> if j > k : <NEWLINE> <INDENT> if k > l : <NEWLINE> <INDENT> num_list [ j ** 2 + k ** 2 + l ** 2 + j * k + k * l + l * j - 1 ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_list [ j ** 2 + k ** 2 + l ** 2 + j * k + k * l + l * j - 1 ] += 3 <NEWLINE> <DEDENT> <DEDENT> elif k > l : <NEWLINE> <INDENT> num_list [ j ** 2 + k ** 2 + l ** 2 + j * k + k * l + l * j - 1 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_list [ j ** 2 + k ** 2 + l ** 2 + j * k + k * l + l * j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in num_list : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dict = { } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a in dict . keys ( ) : <NEWLINE> <INDENT> dict [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> dict [ N ] = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in dict . keys ( ) : <NEWLINE> <INDENT> print ( dict [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if L [ i ] == n : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - n + 1 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> horigin , worigin , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dich = { } <NEWLINE> dicw = { } <NEWLINE> <NL> havew = { } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h in dich : <NEWLINE> <INDENT> dich [ h ] += 1 <NEWLINE> havew [ h ] . append ( w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dich [ h ] = 1 <NEWLINE> havew [ h ] = [ w ] <NEWLINE> <DEDENT> if w in dicw : <NEWLINE> <INDENT> dicw [ w ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicw [ w ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dichi = list ( dich . items ( ) ) <NEWLINE> dichi . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> dicwi = list ( dicw . items ( ) ) <NEWLINE> dicwi . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> hmax = dichi [ 0 ] [ 1 ] <NEWLINE> wmax = dicwi [ 0 ] [ 1 ] <NEWLINE> <NL> for hs in dichi : <NEWLINE> <INDENT> if hs [ 1 ] != hmax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> wlis = sorted ( havew [ hs [ 0 ] ] ) <NEWLINE> for ws in dicwi : <NEWLINE> <INDENT> if ws [ 1 ] != wmax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> idx = bisect . bisect_left ( wlis , ws [ 0 ] ) <NEWLINE> if idx >= len ( wlis ) : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ws [ 0 ] != wlis [ idx ] : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hmax + wmax - 1 ) <NEWLINE> <NL>
s = [ input ( ) for i in range ( 3 ) ] <NEWLINE> l = [ len ( s [ i ] ) for i in range ( 3 ) ] <NEWLINE> abc = [ 0 , 0 , 0 ] <NEWLINE> now = 0 <NEWLINE> while abc [ now ] != l [ now ] : <NEWLINE> <INDENT> s_sub = s [ now ] [ abc [ now ] ] <NEWLINE> abc [ now ] += 1 <NEWLINE> now = ( 0 if s_sub == <STRING> else 1 if s_sub == <STRING> else 2 ) <NEWLINE> <DEDENT> print ( <STRING> if now == 0 else <STRING> if now == 1 else <STRING> ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> bl = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> aa , bb = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa . append ( aa [ i ] + al [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bb . append ( bb [ i ] + bl [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while bb [ j ] > k - aa [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a_dict = defaultdict ( int ) <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> a_dict [ int ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a_dict [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> MOD = 2019 <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> count = [ 1 ] + [ 0 ] * MOD <NEWLINE> r , tmp = 0 , 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> r += int ( i ) * tmp <NEWLINE> r %= MOD <NEWLINE> tmp *= 10 <NEWLINE> tmp %= MOD <NEWLINE> count [ r ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in count ] ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import networkx as nx <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> g = nx . Graph ( ) <COMMENT> <NEWLINE> g . add_edges_from ( s ) <COMMENT> <NEWLINE> di = nx . predecessor ( g , source = 1 ) <COMMENT> <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( di [ x ] [ 0 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 100 <NEWLINE> dp = [ INF ] * 500000 <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in c : <NEWLINE> <INDENT> dp [ i + j ] = min ( dp [ i + j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( s // 3600 , s // 60 % 60 , s % 60 , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from array import array <NEWLINE> import sys <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> MAXV = 1000 * 10 ** 5 + 1 <NEWLINE> <NL> def __init__ ( self , n ) : <NEWLINE> <INDENT> size = 1 <NEWLINE> while size < n : <NEWLINE> <INDENT> size *= 2 <NEWLINE> <DEDENT> self . size = 2 * size - 1 <NEWLINE> self . data = array ( <STRING> , [ 0 ] * self . size ) <NEWLINE> self . lazy = array ( <STRING> , [ 0 ] * self . size ) <NEWLINE> <NL> <DEDENT> def add ( self , lo , hi , v ) : <NEWLINE> <INDENT> def _add ( r , i , j , lz ) : <NEWLINE> <INDENT> left , right = r * 2 + 1 , r * 2 + 2 <NEWLINE> if lazy [ r ] : <NEWLINE> <INDENT> lz += lazy [ r ] <NEWLINE> lazy [ r ] = 0 <NEWLINE> <NL> <DEDENT> if lo <= i and j <= hi : <NEWLINE> <INDENT> lz += v <NEWLINE> if lz : <NEWLINE> <INDENT> data [ r ] += lz <NEWLINE> if i < j : <NEWLINE> <INDENT> lazy [ left ] += lz <NEWLINE> lazy [ right ] += lz <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mid = ( i + j ) // 2 <NEWLINE> if mid >= lo : <NEWLINE> <INDENT> lv = _add ( left , i , mid , lz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lazy [ left ] += lz <NEWLINE> lv = data [ left ] + lazy [ left ] <NEWLINE> <NL> <DEDENT> if mid < hi : <NEWLINE> <INDENT> rv = _add ( right , mid + 1 , j , lz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lazy [ right ] += lz <NEWLINE> rv = data [ right ] + lazy [ right ] <NEWLINE> <NL> <DEDENT> if lv < rv : <NEWLINE> <INDENT> data [ r ] = lv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ r ] = rv <NEWLINE> <NL> <DEDENT> <DEDENT> return data [ r ] <NEWLINE> <NL> <DEDENT> lazy = self . lazy <NEWLINE> data = self . data <NEWLINE> _add ( 0 , 0 , self . size // 2 , 0 ) <NEWLINE> <NL> <DEDENT> def min ( self , lo , hi ) : <NEWLINE> <INDENT> def _min ( r , i , j , lz ) : <NEWLINE> <INDENT> left , right = r * 2 + 1 , r * 2 + 2 <NEWLINE> if lazy [ r ] : <NEWLINE> <INDENT> lz += lazy [ r ] <NEWLINE> lazy [ r ] = 0 <NEWLINE> <DEDENT> if lz : <NEWLINE> <INDENT> data [ r ] += lz <NEWLINE> <NL> <DEDENT> if lo <= i and j <= hi : <NEWLINE> <INDENT> if lz and i < j : <NEWLINE> <INDENT> lazy [ left ] += lz <NEWLINE> lazy [ right ] += lz <NEWLINE> <DEDENT> return data [ r ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = ( i + j ) // 2 <NEWLINE> if mid >= lo : <NEWLINE> <INDENT> lv = _min ( left , i , mid , lz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lazy [ left ] += lz <NEWLINE> lv = self . MAXV <NEWLINE> <NL> <DEDENT> if mid < hi : <NEWLINE> <INDENT> rv = _min ( right , mid + 1 , j , lz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lazy [ right ] += lz <NEWLINE> rv = self . MAXV <NEWLINE> <NL> <DEDENT> if lv < rv : <NEWLINE> <INDENT> return lv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return rv <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> lazy = self . lazy <NEWLINE> data = self . data <NEWLINE> return _min ( 0 , 0 , self . size // 2 , 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n , q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> tree = SegmentTree ( n ) <NEWLINE> <NL> ret = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> com , * args = line . split ( ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> s , t , x = map ( int , args ) <NEWLINE> tree . add ( s , t , x ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> s , t = map ( int , args ) <NEWLINE> ret . append ( tree . min ( s , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> . join ( [ str ( i ) for i in ret ] ) ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b_c = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> summ = sum ( a ) <NEWLINE> cc = collections . Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b = b_c [ i ] [ 0 ] <NEWLINE> c = b_c [ i ] [ 1 ] <NEWLINE> if b in cc : <NEWLINE> <INDENT> buf = cc [ b ] <NEWLINE> cc [ b ] = 0 <NEWLINE> if c in cc : <NEWLINE> <INDENT> cc [ c ] = cc [ c ] + buf <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cc [ c ] = buf <NEWLINE> <DEDENT> summ = summ - b * buf + c * buf <NEWLINE> print ( summ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( summ ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = [ ] <NEWLINE> ans = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <NL> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( A ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for l in list ( combinations ( a , i ) ) : <NEWLINE> <INDENT> s = np . zeros ( M + 1 ) <NEWLINE> for k in l : <NEWLINE> <INDENT> k = np . array ( k ) <NEWLINE> s = s + k <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if min ( s [ 1 : ] ) >= X : <NEWLINE> <INDENT> ans . append ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( min ( ans ) ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> answer . append ( sum ( [ a [ i ] [ k ] * b [ k ] [ j ] for k in range ( m ) ] ) ) <NEWLINE> <DEDENT> print ( * answer ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> sum_val = sum ( A [ 1 : N ] ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> total += A [ i ] * sum_val <NEWLINE> total %= ( 10 ** 9 + 7 ) <NEWLINE> sum_val -= A [ i + 1 ] <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxp = - 100001 <NEWLINE> maxcont = - 100001 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> maxcont = max ( a [ i ] , maxcont + a [ i ] ) <NEWLINE> maxp = max ( maxp , maxcont ) <NEWLINE> <NL> <DEDENT> print ( maxp ) <NEWLINE> <DEDENT>
def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = a [ left : left + n1 ] + [ SENTINEL ] <NEWLINE> R = a [ mid : mid + n2 ] + [ SENTINEL ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> a [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <DEDENT> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> SENTINEL = 1000000001 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( a , 0 , len ( a ) ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ 1 + ( i - 1 ) // 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = [ 0 ] * s [ 0 ] <NEWLINE> for k in range ( 0 , s [ 1 ] , 1 ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> for i in range ( 0 , d , 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> n [ a [ i ] - 1 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <NL> for k in range ( 0 , s [ 0 ] , 1 ) : <NEWLINE> <INDENT> if ( n [ k ] == 0 ) : sum = sum + 1 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ 0 ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> a_s = 0 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = make_divisors ( x ) <NEWLINE> for a in range ( a_s , x + 1 ) : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for b_a in l : <NEWLINE> <INDENT> if b_a <= a : <NEWLINE> <INDENT> b = a - b_a <NEWLINE> if a ** 5 - b ** 5 == x or a ** 5 + b ** 5 == x : <NEWLINE> <INDENT> flag += 1 <NEWLINE> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if b_a > a : <NEWLINE> <INDENT> b = b_a - a <NEWLINE> if a ** 5 + b ** 5 == x : <NEWLINE> <INDENT> flag += 1 <NEWLINE> print ( a , - b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n , m , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . append ( l ) <NEWLINE> <NL> <NL> <DEDENT> min = - 1 <NEWLINE> for nnn in range ( 2 ** n ) : <NEWLINE> <INDENT> index = [ ] <NEWLINE> a = nnn <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> index . append ( a % 2 ) <NEWLINE> a //= 2 <NEWLINE> <NL> <DEDENT> money = 0 <NEWLINE> xs = np . zeros ( m ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if index [ i ] == 1 : <NEWLINE> <INDENT> money += lis [ i ] [ 0 ] <NEWLINE> xs += np . array ( lis [ i ] [ 1 : ] ) <NEWLINE> <DEDENT> <DEDENT> if np . amin ( xs ) >= x : <NEWLINE> <INDENT> if min == - 1 : <NEWLINE> <INDENT> min = money <NEWLINE> <DEDENT> elif min > money : <NEWLINE> <INDENT> min = money <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
<STRING> <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Li = defaultdict ( int ) <NEWLINE> Ri = defaultdict ( int ) <NEWLINE> for i , a in enumerate ( A , start = 1 ) : <NEWLINE> <INDENT> Li [ i + a ] += 1 <NEWLINE> Ri [ i - a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in Li . items ( ) : <NEWLINE> <INDENT> if k in Ri : <NEWLINE> <INDENT> ans += Li [ k ] * Ri [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> u -= 1 <NEWLINE> v -= 1 <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> INF = 1 << 30 <NEWLINE> t = [ INF ] * n <NEWLINE> a = [ INF ] * n <NEWLINE> <NL> t [ u ] = 0 <NEWLINE> a [ v ] = 0 <NEWLINE> <NL> <NL> def dfs ( v , p , d ) : <NEWLINE> <INDENT> for nv in g [ v ] : <NEWLINE> <INDENT> if nv == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ nv ] == INF : <NEWLINE> <INDENT> d [ nv ] = d [ v ] + 1 <NEWLINE> dfs ( nv , v , d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( u , - 1 , t ) <NEWLINE> dfs ( v , - 1 , a ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] < a [ i ] : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A , reverse = True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == B [ 0 ] : <NEWLINE> <INDENT> print ( B [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if nums . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for i in nums : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> s = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ a , b , c , d ] ) <NEWLINE> <NL> <DEDENT> ps = list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n - 1 ) ) <NEWLINE> n_p = len ( ps ) <NEWLINE> <NL> for i in range ( n_p ) : <NEWLINE> <INDENT> ns = [ 1 ] + list ( ps [ i ] ) <NEWLINE> ss = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> k = l [ j ] <NEWLINE> if ns [ k [ 1 ] - 1 ] - ns [ k [ 0 ] - 1 ] == k [ 2 ] : <NEWLINE> <INDENT> ss += k [ 3 ] <NEWLINE> <DEDENT> <DEDENT> s . append ( ss ) <NEWLINE> <NL> <DEDENT> print ( max ( s ) ) <NEWLINE> <NL>
import math <NEWLINE> <NL> def isPrime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> print ( sum ( [ isPrime ( n ) for n in nums ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ input ( ) ] = 1 <NEWLINE> <DEDENT> print ( len ( d ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> N = 10 ** 3 <NEWLINE> i = - 1000 <NEWLINE> res = [ ] <NEWLINE> <NL> while ( i < N ) : <NEWLINE> <INDENT> j = - 1000 <NEWLINE> while ( j < N ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 == X ) : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> res . append ( j ) <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if ( 1 < len ( res ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( str ( res [ 0 ] ) + <STRING> + str ( res [ 1 ] ) ) <NEWLINE>
t = input ( ) <NEWLINE> t = t . replace ( <STRING> , <STRING> ) <NEWLINE> print ( t ) <NEWLINE> <NL>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> input = sys . stdin . readline <COMMENT> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) [ : - 1 ] . split ( <STRING> ) ) ) <NEWLINE> <NL> MOD_VALUE = 10 ** 9 + 7 <NEWLINE> result = 0 <NEWLINE> <NL> a_sum = sum ( a ) <NEWLINE> <NL> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> result += v * ( a_sum - v ) <NEWLINE> a_sum -= v <NEWLINE> <NL> <DEDENT> if result < MOD_VALUE : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result % MOD_VALUE ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ - 1 ] * N <NEWLINE> <NL> def parent ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> root [ x ] = parent ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x_parent = parent ( x ) <NEWLINE> y_parent = parent ( y ) <NEWLINE> if x_parent == y_parent : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x_parent ] += root [ y_parent ] <NEWLINE> root [ y_parent ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - root [ x ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> union ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> max_size = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> max_size = max ( size ( i ) , max_size ) <NEWLINE> <NL> <DEDENT> print ( max_size ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import bisect <NEWLINE> <NL> <NL> class Edge : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . w = w <NEWLINE> <NL> <DEDENT> def either ( self ) : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <DEDENT> def other ( self , v ) : <NEWLINE> <INDENT> if v == self . v : <NEWLINE> <INDENT> return self . w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class WeightedEdge ( Edge ) : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w , weight ) : <NEWLINE> <INDENT> super ( ) . __init__ ( v , w ) <NEWLINE> self . weight = weight <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . _edges = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> <DEDENT> def add ( self , e ) : <NEWLINE> <INDENT> self . _edges [ e . v ] . append ( e ) <NEWLINE> self . _edges [ e . w ] . append ( e ) <NEWLINE> <NL> <DEDENT> def adj ( self , v ) : <NEWLINE> <INDENT> return self . _edges [ v ] <NEWLINE> <NL> <DEDENT> def edges ( self ) : <NEWLINE> <INDENT> for es in self . _edges : <NEWLINE> <INDENT> for e in es : <NEWLINE> <INDENT> yield e <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def heights ( graph ) : <NEWLINE> <INDENT> def select_root ( ) : <NEWLINE> <INDENT> leaves = [ v for v in range ( graph . v ) if len ( graph . adj ( v ) ) < 2 ] <NEWLINE> visited = [ False ] * graph . v <NEWLINE> while len ( leaves ) > 2 : <NEWLINE> <INDENT> v , * leaves = leaves <NEWLINE> if not visited [ v ] : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if not visited [ w ] : <NEWLINE> <INDENT> visited [ w ] = True <NEWLINE> leaves . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return leaves . pop ( ) <NEWLINE> <NL> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> visited = [ False ] * graph . v <NEWLINE> stack = [ s ] <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if not visited [ v ] : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> stack . append ( v ) <NEWLINE> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if not visited [ w ] : <NEWLINE> <INDENT> edge_to [ w ] = e <NEWLINE> stack . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> e = edge_to [ v ] <NEWLINE> if e is not None : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> bisect . insort ( dists [ w ] , ( dists [ v ] [ - 1 ] [ 0 ] + e . weight , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def _heights ( s ) : <NEWLINE> <INDENT> hs = [ 0 ] * graph . v <NEWLINE> visited = [ False ] * graph . v <NEWLINE> stack = [ s ] <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if not visited [ v ] : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> hs [ v ] = dists [ v ] [ - 1 ] [ 0 ] <NEWLINE> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if not visited [ w ] : <NEWLINE> <INDENT> for x , xv in reversed ( dists [ v ] ) : <NEWLINE> <INDENT> if xv != w : <NEWLINE> <INDENT> bisect . insort ( dists [ w ] , ( x + e . weight , v ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> stack . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return hs <NEWLINE> <NL> <DEDENT> root = select_root ( ) <NEWLINE> edge_to = [ None ] * graph . v <NEWLINE> dists = [ [ ( 0 , i ) ] for i in range ( graph . v ) ] <NEWLINE> dfs ( root ) <NEWLINE> return _heights ( root ) <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> g = Graph ( n ) <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , t , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> g . add ( WeightedEdge ( s , t , w ) ) <NEWLINE> <NL> <DEDENT> for w in heights ( g ) : <NEWLINE> <INDENT> print ( w ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> k = N // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( N + 1 ) // 2 <NEWLINE> <NL> <DEDENT> cmb = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cmb . append ( [ i , N - i ] ) <NEWLINE> <NL> <DEDENT> def digitSum ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = str ( n ) <NEWLINE> <COMMENT> <NL> array = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> return sum ( array ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> X = digitSum ( cmb [ i ] [ 0 ] ) <NEWLINE> Y = digitSum ( cmb [ i ] [ 1 ] ) <NEWLINE> ans . append ( X + Y ) <NEWLINE> <NL> <NL> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
l = [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 <NEWLINE> ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( l [ n - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = list ( map ( int , input ( ) ) ) <NEWLINE> MOD = 2019 <NEWLINE> cnt = 0 <NEWLINE> M = len ( N ) <NEWLINE> ans = 0 <NEWLINE> mod_list = [ 0 ] <NEWLINE> ten = 1 <NEWLINE> <NL> for n in N [ : : - 1 ] : <NEWLINE> <INDENT> ans += ten * n <NEWLINE> mod_list . append ( ans % MOD ) <NEWLINE> ten *= 10 <NEWLINE> ten %= MOD <NEWLINE> <NL> <DEDENT> SUM = 0 <NEWLINE> for k , v in Counter ( mod_list ) . items ( ) : <NEWLINE> <INDENT> SUM += v * ( v - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( SUM ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> def count_balls ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> comb_count = N // ( A + B ) <NEWLINE> remainder = N % ( A + B ) <NEWLINE> <COMMENT> <NL> if remainder <= A : <NEWLINE> <INDENT> return A * comb_count + remainder <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return A * comb_count + A <NEWLINE> <NL> <DEDENT> <DEDENT> result = count_balls ( ) <NEWLINE> print ( result ) <NEWLINE>
import itertools <NEWLINE> n , m , q = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a_ , b_ , c_ , d_ = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> a . append ( a_ - 1 ) <NEWLINE> b . append ( b_ - 1 ) <NEWLINE> c . append ( c_ ) <NEWLINE> d . append ( d_ ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for A in itertools . combinations_with_replacement ( range ( m ) , n ) : <NEWLINE> <INDENT> ans_ = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] ] - A [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> ans_ += d [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans_ > ans : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> n , s = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> answer = 0 <NEWLINE> combi = combinations ( range ( 0 , 10 ) , n ) <NEWLINE> for c in combi : <NEWLINE> <INDENT> if sum ( c ) == s : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if t % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> t = ( t * 10 + 7 ) % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( a , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> MICHI = [ ] <NEWLINE> <NL> <COMMENT> <NL> for m in range ( M ) : <NEWLINE> <INDENT> MICHI . append ( tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> setsuzokumap_d = { } <NEWLINE> setsuzokumap_me = [ [ ] for j in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> for m in MICHI : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> setsuzokumap_me [ m [ 0 ] - 1 ] . append ( m [ 1 ] - 1 ) <NEWLINE> setsuzokumap_me [ m [ 1 ] - 1 ] . append ( m [ 0 ] - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> good_tenboudai = [ None ] * N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for n in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if good_tenboudai [ n ] is None : <NEWLINE> <COMMENT> <NL> <INDENT> if setsuzokumap_me [ n ] : <NEWLINE> <COMMENT> <NL> <INDENT> for setsuzokusaki in setsuzokumap_me [ n ] : <NEWLINE> <NL> <INDENT> m = setsuzokusaki <NEWLINE> <NL> <COMMENT> <NL> if good_tenboudai [ m ] == 1 : <NEWLINE> <INDENT> good_tenboudai [ n ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if H [ m ] <= H [ n ] : <NEWLINE> <INDENT> good_tenboudai [ m ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if H [ n ] <= H [ m ] : <NEWLINE> <INDENT> good_tenboudai [ n ] = 0 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if good_tenboudai [ n ] is None : <NEWLINE> <INDENT> good_tenboudai [ n ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sum ( good_tenboudai ) ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d [ data [ 0 ] ] . append ( data [ 1 ] ) <NEWLINE> d [ data [ 1 ] ] . append ( data [ 0 ] ) <NEWLINE> <NL> <DEDENT> mindist = defaultdict ( lambda : 1000000 ) <NEWLINE> mindist [ 1 ] = 0 <NEWLINE> sign = defaultdict ( int ) <NEWLINE> <NL> dq = deque ( ) <NEWLINE> dq . append ( [ 1 , 0 ] ) <NEWLINE> while len ( dq ) > 0 : <NEWLINE> <INDENT> room , dist = dq . popleft ( ) <NEWLINE> for nroom in d [ room ] : <NEWLINE> <INDENT> if dist + 1 < mindist [ nroom ] : <NEWLINE> <INDENT> mindist [ nroom ] = dist + 1 <NEWLINE> sign [ nroom ] = room <NEWLINE> dq . append ( [ nroom , dist + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( sign [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> if 1000 * i - n >= 0 : <NEWLINE> <INDENT> ans . append ( 1000 * i - n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
X , K , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> co , ans = divmod ( abs ( X ) , D ) <NEWLINE> if ( K - co ) > 0 : <NEWLINE> <INDENT> if ( K - co ) % 2 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( ans ) - D <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( X ) - K * D <NEWLINE> <NL> <DEDENT> print ( abs ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> se = 1 <NEWLINE> c = True <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> se *= A [ n ] <NEWLINE> if se > 10 ** 18 : <NEWLINE> <INDENT> c = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if A [ n ] == 0 : <NEWLINE> <INDENT> se = 0 <NEWLINE> c = True <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> print ( se ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a . insert ( 0 , 0 ) <NEWLINE> c = dict ( ) <NEWLINE> c [ 1 + a [ 1 ] ] = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if x - a [ x ] in c . keys ( ) : <NEWLINE> <INDENT> cnt += c [ x - a [ x ] ] <NEWLINE> <NL> <DEDENT> if x + a [ x ] < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if x + a [ x ] in c . keys ( ) : <NEWLINE> <INDENT> c [ x + a [ x ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ x + a [ x ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> a = [ 0 ] + a <NEWLINE> b = [ 0 ] + b <NEWLINE> <NL> ans = 0 <NEWLINE> ALL = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while k - a [ i ] < b [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if i > 0 and i < a - 1 and j > 0 and j < b - 1 and a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> level = pow ( 10 , 18 ) <NEWLINE> product = 1 <NEWLINE> <NL> if <STRING> in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in range ( n ) : <NEWLINE> <INDENT> product *= int ( a [ num ] ) <NEWLINE> if product > level : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if product <= level : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> allcnt = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> rem = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> rem += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( allcnt - rem ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 if i == 0 else pow ( K // i , N , mod ) for i in range ( K + 1 ) ] <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , K // i + 1 ) : <NEWLINE> <INDENT> dp [ i ] -= dp [ i * j ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in [ ( n ) * i % mod for n , i in enumerate ( dp ) ] : <NEWLINE> <INDENT> ans += i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ab . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> t = 0 <NEWLINE> for x in ab : <NEWLINE> <INDENT> if t + x [ 0 ] <= x [ 1 ] : <NEWLINE> <INDENT> t += x [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> la = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = [ 0 ] * 9 <NEWLINE> for a in la : <NEWLINE> <INDENT> if a > 3200 : <NEWLINE> <INDENT> a = 3200 <NEWLINE> <DEDENT> cnt [ a // 400 ] += 1 <NEWLINE> <NL> <DEDENT> mi = len ( [ _ for _ in cnt [ : 8 ] if _ > 0 ] ) <NEWLINE> ma = mi + cnt [ 8 ] <NEWLINE> <NL> if mi == 0 : <NEWLINE> <INDENT> mi = 1 <NEWLINE> <NL> <DEDENT> print ( mi , ma ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . append ( 0 ) <NEWLINE> s = sum ( p [ : k ] ) <NEWLINE> t = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> t = max ( t , ( k + s ) / 2 ) <NEWLINE> s -= p [ i - k + 1 ] <NEWLINE> s += p [ i + 1 ] <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE>
print ( input ( ) . swapcase ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> res = 1 <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> res *= i <NEWLINE> <NL> if ( res > 1000000000000000000 ) : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if res == - 1 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> res = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> def _p ( * _a ) : <NEWLINE> <COMMENT> <NL> <INDENT> _s = <STRING> . join ( map ( str , _a ) ) <NEWLINE> <COMMENT> <NL> sys . stderr . write ( _s + <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> def _pa ( _aa ) : <NEWLINE> <COMMENT> <NL> <INDENT> for _a in _aa : _p ( _a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> HH , WW , MM = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = [ 0 ] * HH <NEWLINE> W = [ 0 ] * WW <NEWLINE> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( MM ) : <NEWLINE> <INDENT> nh , nw = map ( int , input ( ) . split ( ) ) <NEWLINE> h = nh - 1 <NEWLINE> w = nw - 1 <NEWLINE> d [ h * 1000000 + w ] = 1 <NEWLINE> H [ h ] += 1 <NEWLINE> W [ w ] += 1 <NEWLINE> <NL> <DEDENT> hm = max ( H ) <NEWLINE> wm = max ( W ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> HI = [ i for i , x in enumerate ( H ) if x == hm ] <NEWLINE> WI = [ i for i , x in enumerate ( W ) if x == wm ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = hm + wm <NEWLINE> for h in HI : <NEWLINE> <INDENT> for w in WI : <NEWLINE> <INDENT> if d [ h * 1000000 + w ] == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ai = defaultdict ( int ) <NEWLINE> aj = defaultdict ( int ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ai [ i + 1 + a ] += 1 <NEWLINE> aj [ i + 1 - a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in ai . items ( ) : <NEWLINE> <INDENT> ans += v * aj [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> not_good = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <COMMENT> <NEWLINE> <INDENT> not_good . append ( b ) <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> not_good . append ( a ) <NEWLINE> not_good . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> not_good . append ( a ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> not_good = list ( set ( not_good ) ) <NEWLINE> not_good . sort ( ) <NEWLINE> <COMMENT> <NL> idx = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i < not_good [ idx ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif i == not_good [ idx ] : <NEWLINE> <INDENT> idx += 1 <NEWLINE> if idx == len ( not_good ) : <NEWLINE> <INDENT> ans += n - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def num_divisors_table ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return table <NEWLINE> <DEDENT> print ( sum ( num_divisors_table ( N - 1 ) ) ) <NEWLINE>
from bisect import bisect_right <NEWLINE> from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( accumulate ( [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> B = list ( accumulate ( [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> <NL> m = 0 <NEWLINE> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if K < A [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = max ( m , i + bisect_right ( B , K - A [ i ] ) - 1 ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = list ( range ( n ) ) <NEWLINE> cnt = n - 1 <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if data [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ x ] = find ( data [ x ] ) <NEWLINE> return data [ x ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = find ( a - 1 ) <NEWLINE> b = find ( b - 1 ) <NEWLINE> if a != b : <NEWLINE> <INDENT> data [ a ] = b <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class weightRtree : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . weight = [ 0 ] * ( num + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , v , w ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> while v <= self . num : <NEWLINE> <INDENT> self . weight [ v ] += w <NEWLINE> v += ( - v ) & v <NEWLINE> <NL> <DEDENT> <DEDENT> def getSum ( self , u ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> while u > 0 : <NEWLINE> <INDENT> temp += self . weight [ u ] <NEWLINE> u -= ( - u ) & u <NEWLINE> <DEDENT> return temp <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> left = [ 0 ] * N <NEWLINE> right = [ 0 ] * N <NEWLINE> Tree = [ set ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) for i in range ( N ) ] <NEWLINE> <NL> def DFS ( count , source ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> left [ source ] = count <NEWLINE> for item in Tree [ source ] : <NEWLINE> <INDENT> count = DFS ( count , item ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> right [ source ] = count <NEWLINE> return count <NEWLINE> <NL> <DEDENT> Object = weightRtree ( DFS ( 1 , 0 ) ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if not alist [ 0 ] : <NEWLINE> <INDENT> Object . add ( left [ alist [ 1 ] ] , alist [ 2 ] ) <NEWLINE> Object . add ( right [ alist [ 1 ] ] , - alist [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Object . getSum ( right [ alist [ 1 ] ] - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> bc = b // c <NEWLINE> bd = b // d <NEWLINE> bcd = b // ( c * d // math . gcd ( c , d ) ) <NEWLINE> <NL> ac = ( a - 1 ) // c <NEWLINE> ad = ( a - 1 ) // d <NEWLINE> acd = ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) <NEWLINE> <NL> ans = ( b - bc - bd + bcd ) - ( ( a - 1 ) - ac - ad + acd ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> T = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> while <STRING> in s : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> T . append ( s ) <NEWLINE> <NL> <DEDENT> l1 = [ ] <NEWLINE> l2 = [ ] <NEWLINE> for t in T : <NEWLINE> <INDENT> op = t . find ( <STRING> ) <NEWLINE> if op < 0 : <NEWLINE> <INDENT> op = len ( t ) <NEWLINE> <DEDENT> cl = len ( t ) - op <NEWLINE> <NL> if cl + op != 0 : <NEWLINE> <INDENT> if cl <= op : <NEWLINE> <INDENT> l1 . append ( ( cl , op ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 . append ( ( op , cl ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l1 . sort ( ) <NEWLINE> l2 . sort ( reverse = True ) <NEWLINE> <NL> result = False <NEWLINE> x = 0 <NEWLINE> if len ( l1 ) + len ( l2 ) == 0 : <NEWLINE> <INDENT> result = True <NEWLINE> <DEDENT> elif len ( l1 ) > 0 and len ( l2 ) > 0 and l1 [ 0 ] [ 0 ] + l2 [ - 1 ] [ 0 ] == 0 : <NEWLINE> <INDENT> for cl , op in l1 : <NEWLINE> <INDENT> x -= cl <NEWLINE> if x < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x += op <NEWLINE> <NL> <DEDENT> if x >= 0 : <NEWLINE> <INDENT> for op , cl in l2 : <NEWLINE> <INDENT> x -= cl <NEWLINE> if x < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x += op <NEWLINE> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> result = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if result else <STRING> ) <NEWLINE>
drc = [ ( 0 , 1 ) , ( 1 , 0 ) ] <NEWLINE> <NL> <NL> def dfs ( r , c ) : <NEWLINE> <INDENT> if ( r , c ) in memo : <NEWLINE> <INDENT> return memo [ r , c ] <NEWLINE> <DEDENT> ret = <STRING> <NEWLINE> for dr , dc in drc : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if nr < H and nc < W and board [ nr ] [ nc ] . isdigit ( ) : <NEWLINE> <INDENT> cand = dfs ( nr , nc ) <NEWLINE> if len ( cand ) > len ( ret ) or ( len ( cand ) == len ( ret ) and cand > ret ) : <NEWLINE> <INDENT> ret = cand <NEWLINE> <DEDENT> <DEDENT> <DEDENT> memo [ r , c ] = board [ r ] [ c ] + <STRING> . join ( ret ) <NEWLINE> return board [ r ] [ c ] + ret <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> W , H = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( W | H ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> board = [ input ( ) for _ in range ( H ) ] <NEWLINE> memo = dict ( ) <NEWLINE> ans = <STRING> <NEWLINE> for r in range ( H ) : <NEWLINE> <INDENT> for c in range ( W ) : <NEWLINE> <INDENT> if board [ r ] [ c ] . isdigit ( ) and board [ r ] [ c ] != <STRING> : <NEWLINE> <INDENT> cand = dfs ( r , c ) <NEWLINE> if len ( cand ) > len ( ans ) or ( len ( cand ) == len ( ans ) and cand > ans ) : <NEWLINE> <INDENT> ans = cand <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> mod = 2019 <NEWLINE> N = len ( S ) <NEWLINE> D = defaultdict ( int ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> T = 0 <NEWLINE> D [ 0 ] += 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = int ( S [ i ] ) * pow ( 10 , i , mod ) <NEWLINE> T = ( T + s ) % mod <NEWLINE> ans += D [ T ] <NEWLINE> D [ T ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
dishes = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> <NL> d = [ abs ( d % 10 - 10 ) for d in dishes if d % 10 != 0 ] <COMMENT> <NEWLINE> if d : d . remove ( max ( d ) ) <NEWLINE> print ( sum ( dishes ) + sum ( d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> many = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> many [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> B , C = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> many [ C ] += many [ B ] <NEWLINE> ans += many [ B ] * ( C - B ) <NEWLINE> many [ B ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a = [ i for i in input ( ) ] <NEWLINE> for i in reversed ( range ( 1 , len ( a ) ) ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ 0 ] ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> m = max ( A ) <NEWLINE> mindex = A . index ( m ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i != mindex ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pop = A . pop ( i ) <NEWLINE> print ( max ( A ) ) <NEWLINE> A . insert ( i , pop ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> total += ( N - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( 0 in l ) : print ( 0 ) <NEWLINE> else : <NEWLINE> <NL> <INDENT> mul = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> mul *= i <NEWLINE> if ( mul >= 10 ** 18 ) : break <NEWLINE> <NL> <DEDENT> if ( mul > 10 ** 18 ) : print ( - 1 ) <NEWLINE> else : print ( mul ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g = g + 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ii = s [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> jj = s [ j ] <NEWLINE> if ii == jj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( 2 * j - i ) <= ( n - 1 ) : <NEWLINE> <INDENT> if ii != s [ 2 * j - i ] and jj != s [ 2 * j - i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) [ 0 ] <NEWLINE> <NL> length = len ( S ) <NEWLINE> <NL> W_count = S . count ( <STRING> ) <NEWLINE> R_count = S . count ( <STRING> ) <NEWLINE> <NL> c = 0 <NEWLINE> if R_count < W_count : <NEWLINE> <NL> <INDENT> for i in range ( R_count ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if s != <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( W_count ) : <NEWLINE> <INDENT> s = S [ - 1 - i ] <NEWLINE> if s != <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def form ( x , e = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x ) , end = e ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rows = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for row in rows : <NEWLINE> <INDENT> for r in row : <NEWLINE> <INDENT> form ( r ) <NEWLINE> <DEDENT> form ( sum ( row ) , <STRING> ) <NEWLINE> <DEDENT> columns = list ( zip ( * rows ) ) <NEWLINE> for column in columns : <NEWLINE> <INDENT> form ( sum ( column ) ) <NEWLINE> <DEDENT> form ( sum ( sum ( row ) for row in rows ) , <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H [ A - 1 ] > H [ B - 1 ] ) : <NEWLINE> <INDENT> List [ B - 1 ] = 1 <NEWLINE> <DEDENT> elif ( H [ A - 1 ] < H [ B - 1 ] ) : <NEWLINE> <INDENT> List [ A - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> List [ A - 1 ] = 1 <NEWLINE> List [ B - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( List . count ( 0 ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> class DTeleporter : <NEWLINE> <INDENT> def solve ( self , tc = 0 ) : <NEWLINE> <INDENT> n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> a = [ int ( _ ) - 1 for _ in input ( ) . split ( ) ] <NEWLINE> done = dict ( ) <NEWLINE> cur = 0 <NEWLINE> steps = 0 <NEWLINE> while cur not in done and steps < k : <NEWLINE> <INDENT> done [ cur ] = steps <NEWLINE> cur = a [ cur ] <NEWLINE> steps += 1 <NEWLINE> <NL> <DEDENT> if steps == k : <NEWLINE> <INDENT> print ( cur + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> d = steps - done [ cur ] <NEWLINE> steps = steps + ( ( k - steps ) // d ) * d <NEWLINE> <NL> while steps < k : <NEWLINE> <INDENT> cur = a [ cur ] <NEWLINE> steps += 1 <NEWLINE> <NL> <DEDENT> print ( cur + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solver = DTeleporter ( ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> solver . solve ( ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> R = 3000 <NEWLINE> go = [ i ** 5 for i in range ( R ) ] <NEWLINE> <NL> <NL> def foo ( ) : <NEWLINE> <INDENT> for i in range ( R ) : <NEWLINE> <INDENT> for j in range ( R ) : <NEWLINE> <INDENT> if go [ i ] - go [ j ] == X : <NEWLINE> <INDENT> return i , j <NEWLINE> <DEDENT> <DEDENT> for j in range ( i , R ) : <NEWLINE> <INDENT> if go [ i ] + go [ j ] == X : <NEWLINE> <INDENT> return i , - j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return 0 , 0 <NEWLINE> <NL> <NL> <DEDENT> A , B = foo ( ) <NEWLINE> print ( A , B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * n <NEWLINE> r = [ 0 ] * n <NEWLINE> <NL> l = [ i + a [ i ] for i in range ( n ) ] <NEWLINE> r = [ i - a [ i ] for i in range ( n ) ] <NEWLINE> ld = { } <NEWLINE> rd = { } <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] in ld : <NEWLINE> <INDENT> ld [ l [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ld [ l [ i ] ] = 1 <NEWLINE> <DEDENT> if r [ i ] in rd : <NEWLINE> <INDENT> rd [ r [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rd [ r [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ld . keys ( ) : <NEWLINE> <INDENT> if i in rd : <NEWLINE> <INDENT> c += ld [ i ] * rd [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = 1 <NEWLINE> i = 0 <NEWLINE> B = 0 <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> A = A * li [ i ] <NEWLINE> if ( A > 10 ** 18 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if B == N : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dp = [ 0 ] * N <NEWLINE> seen = [ 0 ] * N <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> if seen [ v ] : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> seen [ v ] = 1 <NEWLINE> res = 0 <NEWLINE> for nv in to [ v ] : <NEWLINE> <INDENT> res = max ( res , dfs ( nv ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> X_arr = list ( X ) <NEWLINE> N , X = int ( N ) , int ( X , 2 ) <NEWLINE> MAX_N = 2 * 10 ** 5 <NEWLINE> <NL> <NL> def popcount ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( x . bit_length ( ) ) : <NEWLINE> <INDENT> if x & 1 << i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> memo = [ 0 ] * ( MAX_N + 1 ) <NEWLINE> for i , n in enumerate ( range ( 1 , MAX_N + 1 ) , start = 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n : <NEWLINE> <INDENT> p = popcount ( n ) <NEWLINE> n = n % p <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> memo [ i ] = cnt <NEWLINE> <NL> <NL> <DEDENT> x_popcount = popcount ( X ) <NEWLINE> p_upper , p_downer = x_popcount + 1 , x_popcount - 1 <NEWLINE> y_upper = X % p_upper <NEWLINE> y_downer = X % p_downer if p_downer else None <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X_arr [ i ] == <STRING> : <NEWLINE> <INDENT> z = ( y_upper + pow ( 2 , ( N - i - 1 ) , p_upper ) ) % p_upper <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not p_downer : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> z = ( y_downer - pow ( 2 , ( N - i - 1 ) , p_downer ) ) % p_downer <NEWLINE> <NL> <DEDENT> print ( memo [ z ] + 1 ) <NEWLINE> <DEDENT>
<NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while h != 0 : <NEWLINE> <INDENT> s1 = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( s1 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s2 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( s2 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s1 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mu = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fl = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mu = mu * a [ i ] <NEWLINE> if mu > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> fl = 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if fl == 0 : <NEWLINE> <INDENT> print ( mu ) <NEWLINE> <DEDENT> <DEDENT>
F = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> F [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for x in range ( 0 , 4 ) : <NEWLINE> <INDENT> for y in range ( 0 , 3 ) : <NEWLINE> <INDENT> for z in range ( 0 , 10 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( F [ x ] [ y ] [ z ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if x != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> return math . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> <DEDENT> elif n >= b : <NEWLINE> <INDENT> return math . floor ( a * ( b - 1 ) / b ) - a * math . floor ( ( b - 1 ) / b ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> M = 1000 * 1000 * 1000 + 7 <NEWLINE> S = [ 0 ] * N <NEWLINE> <NL> SS = 0 <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> S [ i - 1 ] = A [ i ] + S [ i ] <NEWLINE> SS += A [ i - 1 ] * S [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( SS % M ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * 1000000 <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> sums = sum ( l ) <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> diff = ( b - a ) * cnt [ a ] <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> <NL> cnt [ b ] += cnt [ a ] <NEWLINE> cnt [ a ] = 0 <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( n , b - 1 ) <NEWLINE> ans = a * x // b - a * ( x // b ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> def right_triangle ( edge ) : <NEWLINE> <COMMENT> <NL> <INDENT> return ( edge [ 0 ] ** 2 + edge [ 1 ] ** 2 == edge [ 2 ] ** 2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> edge = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> if right_triangle ( edge ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> S = readline ( ) . rstrip ( ) <NEWLINE> gx , gy = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> C = [ ] <NEWLINE> <NL> import itertools <NEWLINE> for key , g in itertools . groupby ( S ) : <NEWLINE> <INDENT> C . append ( [ key , len ( list ( g ) ) ] ) <NEWLINE> <NL> <DEDENT> x , y = 0 , 0 <NEWLINE> ind = 0 <NEWLINE> if C [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> x += C [ 0 ] [ 1 ] <NEWLINE> ind = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dirX = True <NEWLINE> now_x = { x } <NEWLINE> now_y = { y } <NEWLINE> for i in range ( ind , len ( C ) ) : <NEWLINE> <INDENT> if C [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> step = C [ i ] [ 1 ] <NEWLINE> if dirX : <NEWLINE> <INDENT> nex_x = set ( ) <NEWLINE> for n in now_x : <NEWLINE> <INDENT> nex_x . add ( n + step ) <NEWLINE> nex_x . add ( n - step ) <NEWLINE> <DEDENT> now_x = nex_x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex_y = set ( ) <NEWLINE> for n in now_y : <NEWLINE> <INDENT> nex_y . add ( n + step ) <NEWLINE> nex_y . add ( n - step ) <NEWLINE> <DEDENT> now_y = nex_y <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C [ i ] [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> dirX ^= True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if gx in now_x and gy in now_y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( a == 1 ) : <NEWLINE> <INDENT> ans += K * K <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> if ( t == 1 ) : <NEWLINE> <INDENT> ans += K <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> def is_leap ( year ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if year % 400 == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif year % 100 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif year % 4 == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> is_first__dataset = True <NEWLINE> leap_years = [ ] <COMMENT> <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> start_year , end_year = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> if start_year == 0 and end_year == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> leap_years = [ ] <NEWLINE> for year in range ( start_year , end_year + 1 ) : <NEWLINE> <INDENT> if is_leap ( year ) : <NEWLINE> <INDENT> leap_years . append ( year ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if is_first__dataset == True : <NEWLINE> <INDENT> is_first__dataset = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <NL> <DEDENT> if len ( leap_years ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> . join ( map ( str , leap_years ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
( m , n ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bi = str ( format ( n , <STRING> ) ) <NEWLINE> bi = bi [ : : - 1 ] <NEWLINE> <NL> c = 1 <NEWLINE> d = 1000000007 <NEWLINE> <NL> for i in bi : <NEWLINE> <INDENT> if ( i == <STRING> ) : <NEWLINE> <INDENT> c = ( c * m ) % d <NEWLINE> <DEDENT> m = ( m * m ) % d <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL> <NL>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p . sort ( ) <NEWLINE> tmp = [ i for i in range ( - 111 , 111 ) ] <NEWLINE> for i in p : <NEWLINE> <INDENT> tmp . remove ( i ) <NEWLINE> <NL> <DEDENT> ans_num = float ( <STRING> ) <NEWLINE> ans_i = 0 <NEWLINE> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> if abs ( X - tmp [ i ] ) < ans_num : <NEWLINE> <INDENT> ans_num = abs ( X - tmp [ i ] ) <NEWLINE> ans_i = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( tmp [ ans_i ] ) <NEWLINE>
from collections import Counter <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> is_prime = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> is_prime [ 0 ] = False <NEWLINE> <NL> maxA = max ( a ) <NEWLINE> <NL> for i in set ( a ) : <NEWLINE> <INDENT> for j in range ( 2 * i , maxA + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> c = Counter ( a ) <NEWLINE> <NL> for e in set ( a ) : <NEWLINE> <INDENT> if is_prime [ e ] and c [ e ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> s *= A [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if s <= 10 ** 18 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> x = 2 * j - i <NEWLINE> if x < N and S [ i ] != S [ x ] and S [ x ] != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( D ) <NEWLINE> flag = True <NEWLINE> for t in T : <NEWLINE> <INDENT> if c [ t ] > 0 : <NEWLINE> <INDENT> c [ t ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = AB [ i ] <NEWLINE> <NL> A = A - 1 <NEWLINE> B = B - 1 <NEWLINE> <NL> UF . union ( A , B ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , UF . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m = 1000000007 <NEWLINE> <NL> factorials = [ 1 ] <NEWLINE> <NL> for i in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> factorials . append ( ( factorials [ - 1 ] * i ) % m ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = pow ( 10 , n , m ) - ( 2 * pow ( 9 , n , m ) - pow ( 8 , n , m ) ) <NEWLINE> print ( temp % m ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> lis [ ( A [ i ] - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( lis [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> ans = math . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( a - 1 ) // b - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> print ( <STRING> if a [ i ] > a [ i - k ] else <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum = sum * L [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> B = sorted ( [ a - i for i , a in enumerate ( A , start = 1 ) ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> b = B [ N // 2 ] <NEWLINE> ans . append ( sum ( [ abs ( x - b ) for x in B ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_left = ( B [ N // 2 - 1 ] + B [ N // 2 ] ) // 2 <NEWLINE> b_right = math . ceil ( ( B [ N // 2 - 1 ] + B [ N // 2 ] ) / 2 ) <NEWLINE> ans . append ( sum ( [ abs ( x - b_left ) for x in B ] ) ) <NEWLINE> ans . append ( sum ( [ abs ( x - b_right ) for x in B ] ) ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in h : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 0 , len ( h ) ) : <NEWLINE> <INDENT> c *= h [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> over_num = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > over_num : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 ] * k <NEWLINE> A = [ [ 0 ] * n ] * k <NEWLINE> l = set ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> l = l . union ( A [ i ] ) <NEWLINE> <DEDENT> if set ( range ( 1 , n + 1 ) ) == l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( set ( range ( 1 , n + 1 ) ) - l ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ ] <NEWLINE> a = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( a ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> <DEDENT> list . append ( a ) <NEWLINE> list = sorted ( list ) <NEWLINE> print ( list [ - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> <NL> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> <NL> for i in graph [ v ] : <NEWLINE> <INDENT> if not dist [ i ] : <NEWLINE> <INDENT> dist [ i ] = v <NEWLINE> d . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = dist [ 2 : ] <NEWLINE> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> def gcd2 ( a , b , c ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( c , d ) <NEWLINE> return e <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> s1 = 0 <NEWLINE> s2 = 0 <NEWLINE> s3 = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s1 += i <NEWLINE> for i2 in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> s2 += math . gcd ( i , i2 ) <NEWLINE> for i3 in range ( i2 + 1 , n + 1 ) : <NEWLINE> <INDENT> s3 += gcd2 ( i , i2 , i3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = s1 + 6 * s2 + 6 * s3 <NEWLINE> <NL> print ( s ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n * ( n - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ int ( str ( i ) * 3 ) for i in range ( 10 ) ] <NEWLINE> import bisect <NEWLINE> x = bisect . bisect_left ( li , n ) <NEWLINE> print ( li [ x ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ 0 ] < a [ i ] : <NEWLINE> <INDENT> up = True <NEWLINE> nin = a [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> elif a [ 0 ] > a [ i ] : <NEWLINE> <INDENT> up = False <NEWLINE> nin = a [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> total = 1000 <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if up : <NEWLINE> <INDENT> if a [ i - 1 ] <= a [ i ] and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> total += ( total // nin ) * ( a [ i ] - nin ) <NEWLINE> up = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ i - 1 ] >= a [ i ] and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> nin = a [ i ] <NEWLINE> up = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if nin < a [ n - 1 ] : <NEWLINE> <INDENT> total += ( total // nin ) * ( a [ n - 1 ] - nin ) <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> c = [ 0 ] * 2019 <NEWLINE> c [ 0 ] += 1 <NEWLINE> t = 0 <NEWLINE> digit = 1 <NEWLINE> for ss in s [ : : - 1 ] : <NEWLINE> <INDENT> t = ( t + int ( ss ) * digit ) % 2019 <NEWLINE> digit = ( digit * 10 ) % 2019 <NEWLINE> c [ t ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans = sum ( cc * ( cc - 1 ) // 2 for cc in c ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for c in range ( N ) ] <NEWLINE> B = sorted ( copy . deepcopy ( A ) , reverse = True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == B [ 0 ] : <NEWLINE> <INDENT> print ( B [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = set ( [ input ( ) for n in range ( N ) ] ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> mul = 1 <NEWLINE> for e in a : <NEWLINE> <INDENT> mul *= e <NEWLINE> if mul > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> explored = { 0 } <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> parent = 0 <NEWLINE> for k in graph [ 0 ] : <NEWLINE> <INDENT> ans [ k ] = 0 <NEWLINE> q . append ( k ) <NEWLINE> explored . add ( k ) <NEWLINE> <DEDENT> ans [ 0 ] = 0 <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> parent = now <NEWLINE> for node in graph [ now ] : <NEWLINE> <INDENT> if node not in explored : <NEWLINE> <INDENT> q . append ( node ) <NEWLINE> ans [ node ] = parent <NEWLINE> explored . add ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = np . zeros ( N , dtype = int ) <NEWLINE> A = np . zeros ( [ N , M ] , dtype = int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] = T [ 0 ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> A [ i , j ] = T [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> a = np . zeros ( N , dtype = int ) <NEWLINE> ans = - 1 <NEWLINE> while a . all ( ) != 1 : <NEWLINE> <INDENT> if ( ( a @ A ) >= X ) . all ( ) : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = a @ ( C . T ) <NEWLINE> <DEDENT> elif a @ ( C . T ) < ans : <NEWLINE> <INDENT> ans = a @ ( C . T ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ N - i - 1 ] == 0 : <NEWLINE> <INDENT> a [ N - i - 1 ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ N - i - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( ( a @ A ) >= X ) . all ( ) : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = a @ ( C . T ) <NEWLINE> <DEDENT> elif a @ ( C . T ) < ans : <NEWLINE> <INDENT> ans = a @ ( C . T ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) ; print ( int ( a ) * int ( b [ 0 ] + b [ - 2 : ] ) // 100 ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> n = II ( ) <NEWLINE> s = SI ( ) <NEWLINE> p = s . count ( <STRING> ) <NEWLINE> p0 = p - 1 <NEWLINE> p1 = p + 1 <NEWLINE> pw0 = [ ] <NEWLINE> pw1 = [ ] <NEWLINE> two0 = two1 = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> pw0 . append ( two0 ) <NEWLINE> pw1 . append ( two1 ) <NEWLINE> if p0 > 0 : two0 = two0 * 2 % p0 <NEWLINE> two1 = two1 * 2 % p1 <NEWLINE> <NL> <DEDENT> t0 = 0 <NEWLINE> t1 = 0 <NEWLINE> for i , c in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> if p0 > 0 : t0 = ( t0 + pw0 [ i ] ) % p0 <NEWLINE> t1 = ( t1 + pw1 [ i ] ) % p1 <NEWLINE> <NL> <DEDENT> <DEDENT> def popcnt ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> dp0 = [ - 1 ] * n <NEWLINE> def f0 ( x ) : <NEWLINE> <INDENT> if x == 0 : return 1 <NEWLINE> if dp0 [ x ] == - 1 : dp0 [ x ] = f0 ( x % popcnt ( x ) ) + 1 <NEWLINE> return dp0 [ x ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i , c in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> if p0 == 0 and c == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> cur = ( t0 - pw0 [ i ] ) % p0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = ( t1 + pw1 [ i ] ) % p1 <NEWLINE> <DEDENT> ans . append ( f0 ( cur ) ) <NEWLINE> <NL> <DEDENT> for a in ans [ : : - 1 ] : print ( a ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import math <NEWLINE> <NL> kMod = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> key2count = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g = math . gcd ( a , b ) <NEWLINE> if a < 0 or a == 0 and b < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if g > 0 : <NEWLINE> <INDENT> a , b = a // g , b // g <NEWLINE> <DEDENT> idx = 0 <NEWLINE> if b <= 0 : <NEWLINE> <INDENT> idx = 1 <NEWLINE> a , b = - b , a <NEWLINE> <DEDENT> key2count [ ( a , b ) ] [ idx ] += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for key , val in key2count . items ( ) : <NEWLINE> <INDENT> if key == ( 0 , 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> plus , minus = val <NEWLINE> ans *= ( pow ( 2 , plus , kMod ) + pow ( 2 , minus , kMod ) - 1 ) <NEWLINE> ans %= kMod <NEWLINE> <NL> <DEDENT> ans += sum ( key2count [ ( 0 , 0 ) ] ) <NEWLINE> <NL> print ( ( ans + kMod - 1 ) % kMod ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ 0 ] * len ( s ) <NEWLINE> r , l = 0 , 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i - 1 ] += r // 2 <NEWLINE> a [ i ] += ( r + 1 ) // 2 <NEWLINE> r = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> l += 1 <NEWLINE> if s [ j ] == <STRING> : <NEWLINE> <INDENT> a [ j + 1 ] += l // 2 <NEWLINE> a [ j ] += ( l + 1 ) // 2 <NEWLINE> l = 0 <NEWLINE> <DEDENT> a [ j ] -= 1 <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ) ) < 1e-10 else <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> class P ( object ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> def width ( self , p ) : <NEWLINE> <INDENT> return math . sqrt ( ( self . x - p . x ) ** 2 + ( self . y - p . y ) ** 2 ) <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . x , self . y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_cos ( a , b , c ) : <NEWLINE> <INDENT> return ( b ** 2 + c ** 2 - a ** 2 ) / ( 2 * b * c ) <NEWLINE> <NL> <DEDENT> def calc_sin ( c ) : <NEWLINE> <INDENT> return math . sqrt ( 1 - c ** 2 ) <NEWLINE> <NL> <DEDENT> def calc_2sin ( s , c ) : <NEWLINE> <INDENT> return 2 * s * c <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> p1 , p2 , p3 = P ( x1 , y1 ) , P ( x2 , y2 ) , P ( x3 , y3 ) <NEWLINE> a , b , c = p1 . width ( p2 ) , p2 . width ( p3 ) , p3 . width ( p1 ) <NEWLINE> cosA , cosB , cosC = calc_cos ( a , b , c ) , calc_cos ( b , c , a ) , calc_cos ( c , a , b ) <NEWLINE> sinA , sinB , sinC = calc_sin ( cosA ) , calc_sin ( cosB ) , calc_sin ( cosC ) <NEWLINE> sin2A , sin2B , sin2C = calc_2sin ( sinA , cosA ) , calc_2sin ( sinB , cosB ) , calc_2sin ( sinC , cosC ) <NEWLINE> <NL> r = a / sinA / 2 <NEWLINE> <NL> x = ( p1 . x * sin2B + p2 . x * sin2C + p3 . x * sin2A ) / ( sin2A + sin2B + sin2C ) <NEWLINE> y = ( p1 . y * sin2B + p2 . y * sin2C + p3 . y * sin2A ) / ( sin2A + sin2B + sin2C ) <NEWLINE> <NL> print ( <STRING> . format ( x , y , r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <NL> <DEDENT>
T = input ( ) <NEWLINE> <NL> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for s in range ( 1 , N ) : <NEWLINE> <INDENT> if s in c : <NEWLINE> <INDENT> print ( c [ s ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> result = result * i <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> class UnionFind ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> self . root = [ - 1 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> self . rnk = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def Find_Root ( self , x ) : <NEWLINE> <INDENT> if ( self . root [ x ] < 0 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . root [ x ] = self . Find_Root ( self . root [ x ] ) <NEWLINE> return self . root [ x ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def Unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . Find_Root ( x ) <NEWLINE> y = self . Find_Root ( y ) <NEWLINE> <COMMENT> <NL> if ( x == y ) : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( self . rnk [ x ] > self . rnk [ y ] ) : <NEWLINE> <INDENT> self . root [ x ] += self . root [ y ] <NEWLINE> self . root [ y ] = x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . root [ y ] += self . root [ x ] <NEWLINE> self . root [ x ] = y <NEWLINE> <COMMENT> <NL> if ( self . rnk [ x ] == self . rnk [ y ] ) : <NEWLINE> <INDENT> self . rnk [ y ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def isSameGroup ( self , x , y ) : <NEWLINE> <INDENT> return self . Find_Root ( x ) == self . Find_Root ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def Count ( self , x ) : <NEWLINE> <INDENT> return - self . root [ self . Find_Root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> UF = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . Unite ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , UF . Count ( i + 1 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> n = len ( C ) <NEWLINE> m = - 1 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> A = [ 0 for i in range ( M + 1 ) ] <NEWLINE> total = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> A = [ a + b for a , b in zip ( A , C [ j ] ) ] <NEWLINE> B = [ k for k in range ( 1 , M + 1 ) if A [ k ] < X ] <NEWLINE> if len ( B ) == 0 : <NEWLINE> <INDENT> if m == - 1 : <NEWLINE> <INDENT> m = A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = min ( m , A [ 0 ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL>
S = int ( input ( ) ) <NEWLINE> h = int ( S // 3600 ) <NEWLINE> m = int ( ( S - h * 3600 ) // 60 ) <NEWLINE> s = int ( S - ( h * 3600 + m * 60 ) ) <NEWLINE> <NL> print ( h , m , s , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> r = float ( input ( ) ) <NEWLINE> <COMMENT> <NL> pi = 3.141592653589793 <NEWLINE> A = [ pi * r ** 2 , 2 * pi * r ] <NEWLINE> print ( <STRING> . format ( A [ 0 ] , A [ 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> a = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> S -= x <NEWLINE> a += S * x <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> print ( int ( a % MOD ) ) <NEWLINE> <NL> <NL>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * r * pi ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from sys import argv <NEWLINE> import time <NEWLINE> np . random . seed ( 1 ) <NEWLINE> <NL> <NL> def input_from_file ( ) : <NEWLINE> <INDENT> with open ( argv [ 1 ] , <STRING> ) as f : <NEWLINE> <INDENT> D = int ( f . readline ( ) ) <NEWLINE> C = np . array ( f . readline ( ) . split ( ) , dtype = int ) <NEWLINE> S = tuple ( tuple ( map ( int , f . readline ( ) . split ( ) ) ) for _ in range ( D ) ) <NEWLINE> <DEDENT> return D , C , S <NEWLINE> <NL> <NL> <DEDENT> def input_from_console ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> C = np . array ( input ( ) . split ( ) , dtype = int ) <NEWLINE> S = tuple ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ) <NEWLINE> return D , C , S <NEWLINE> <NL> <NL> <DEDENT> def greed ( D , C , S ) : <NEWLINE> <INDENT> last = np . ones ( 26 , dtype = int ) <NEWLINE> ans = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> s = np . array ( s ) <NEWLINE> tmp = s + C * last <NEWLINE> i = np . argmax ( tmp ) <NEWLINE> last [ i ] = 0 <NEWLINE> last += 1 <NEWLINE> ans . append ( i + 1 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def calc_score ( D , C , S , T ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> last = np . ones ( 26 , dtype = int ) <NEWLINE> for d , t in enumerate ( T ) : <NEWLINE> <INDENT> t -= 1 <NEWLINE> last [ t ] = 0 <NEWLINE> score = S [ d ] [ t ] <NEWLINE> score -= ( C * last ) . sum ( ) <NEWLINE> res += score <NEWLINE> last += 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def output_to_file ( ans ) : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> , newline = <STRING> ) as f : <NEWLINE> <INDENT> for a in ans : <NEWLINE> <INDENT> f . write ( <STRING> . format ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> lim = 1.500 <NEWLINE> D , C , S = input_from_console ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sol = greed ( D , C , S ) <NEWLINE> score = calc_score ( D , C , S , sol ) <NEWLINE> while True : <NEWLINE> <INDENT> d = np . random . randint ( 0 , D ) <NEWLINE> q = np . random . randint ( 1 , 27 ) <NEWLINE> old = sol [ d ] <NEWLINE> sol [ d ] = q <NEWLINE> new_score = calc_score ( D , C , S , sol ) <NEWLINE> if new_score > score : <NEWLINE> <INDENT> score = new_score <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sol [ d ] = old <NEWLINE> <DEDENT> if time . time ( ) - start >= lim : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * sol , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 for i in range ( 110000 ) ] <NEWLINE> sum_ = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ c ] += count [ b ] <NEWLINE> sum_ += ( c - b ) * count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> print ( sum_ ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> S = sum ( A ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> for i in A : <NEWLINE> <INDENT> S -= i <NEWLINE> ans += i * S % M <NEWLINE> ans %= M <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hlis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if hlis [ a - 1 ] > hlis [ b - 1 ] : <NEWLINE> <INDENT> lis [ b - 1 ] = - 1 <NEWLINE> <DEDENT> elif hlis [ a - 1 ] < hlis [ b - 1 ] : <NEWLINE> <INDENT> lis [ a - 1 ] = - 1 <NEWLINE> <DEDENT> elif hlis [ a - 1 ] == hlis [ b - 1 ] : <NEWLINE> <INDENT> lis [ a - 1 ] = - 1 <NEWLINE> lis [ b - 1 ] = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( lis . count ( 1 ) ) <NEWLINE>
class DisjointSet : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ x for x in range ( n ) ] <NEWLINE> self . rank = [ 0 for x in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find_set ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] != x : <NEWLINE> <INDENT> self . p [ x ] = self . find_set ( self . p [ x ] ) <NEWLINE> <DEDENT> return self . p [ x ] <NEWLINE> <NL> <DEDENT> def link ( self , x , y ) : <NEWLINE> <INDENT> if self . rank [ y ] < self . rank [ x ] : <NEWLINE> <INDENT> self . p [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> self . link ( self . find_set ( x ) , self . find_set ( y ) ) <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return ( self . find_set ( x ) == self . find_set ( y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = DisjointSet ( n ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> S . union ( x , y ) <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> if S . same ( x , y ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for l in range ( n ) ] <NEWLINE> npa = np . array ( a , dtype = int ) <NEWLINE> <NL> hon = - 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> base = list ( itertools . combinations ( range ( 0 , n ) , i ) ) <NEWLINE> <COMMENT> <NL> <NL> for j in base : <NEWLINE> <INDENT> totalv = np . sum ( npa [ j , ] , axis = 0 ) <NEWLINE> <COMMENT> <NL> <NL> if ( min ( totalv [ 1 : m + 1 ] ) >= x ) : <NEWLINE> <INDENT> if ( hon == - 1 ) : hon = totalv [ 0 ] <NEWLINE> if ( hon >= totalv [ 0 ] ) : hon = totalv [ 0 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( hon ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a in dic : <NEWLINE> <INDENT> dic [ a ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = b <NEWLINE> <DEDENT> <DEDENT> List = sorted ( dic ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while M > 0 : <NEWLINE> <INDENT> M -= dic [ List [ i ] ] <NEWLINE> ans = List [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * r ** 2 , math . pi * 2 * r ) ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> s = [ 0 ] <NEWLINE> for i , x in enumerate ( S ) : <NEWLINE> <INDENT> s . append ( int ( S [ i ] ) * pow ( 10 , n - i - 1 , 2019 ) % 2019 ) <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> t = [ ] <NEWLINE> for x in s : <NEWLINE> <INDENT> tmp = ( tmp + x ) % 2019 <NEWLINE> t . append ( tmp ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in Counter ( t ) . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import random <NEWLINE> <NL> def calc_score ( D , C , S , T ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> t = T [ d ] - 1 <NEWLINE> score += S [ d ] [ t ] <NEWLINE> last [ t ] = d + 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> score -= C [ i ] * ( d + 1 - last [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> last = [ 0 ] * 26 <NEWLINE> ans = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> score = - 100 * 365 * 365 <NEWLINE> t = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> tmp = S [ d ] [ i ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> tmp -= C [ j ] * ( d + 1 - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp > score : <NEWLINE> <INDENT> score = tmp <NEWLINE> t = i + 1 <NEWLINE> <DEDENT> <DEDENT> last [ t - 1 ] = d + 1 <NEWLINE> ans . append ( t ) <NEWLINE> <DEDENT> score = calc_score ( D , C , S , ans ) <NEWLINE> for i in range ( 10 ** 3 ) : <NEWLINE> <INDENT> d = random . randint ( 0 , D - 1 ) <NEWLINE> t = random . randint ( 1 , 26 ) <NEWLINE> org_t = ans [ d ] <NEWLINE> ans [ d ] = t <NEWLINE> s = calc_score ( D , C , S , ans ) <NEWLINE> if s <= score : <NEWLINE> <INDENT> ans [ d ] = org_t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = s <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = input ( ) . split ( ) <NEWLINE> b [ 1 ] = int ( b [ 1 ] ) <NEWLINE> a . append ( b ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> time = 0 <NEWLINE> while len ( a ) != 0 : <NEWLINE> <INDENT> x = a . pop ( 0 ) <NEWLINE> if x [ 1 ] <= q : <NEWLINE> <INDENT> time += x [ 1 ] <NEWLINE> ans . append ( [ x [ 0 ] , time ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ 1 ] -= q <NEWLINE> time += q <NEWLINE> a . append ( x ) <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , i ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import string <NEWLINE> import sys <NEWLINE> <NL> <NL> def check_exists ( word_set , rotate_dict , search ) : <NEWLINE> <INDENT> for word in word_set : <NEWLINE> <INDENT> rotated_word = <STRING> . join ( rotate_dict [ s ] for s in word ) <NEWLINE> if rotated_word == search : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> alphabets = string . ascii_lowercase <NEWLINE> frequency = [ t [ 1 ] for t in sorted ( [ ( line . count ( s ) , ord ( s ) ) for s in alphabets ] , reverse = True ) ] <NEWLINE> freq_chr_offset = ( 4 , 0 , 19 , 8 , 14 ) <NEWLINE> ss = list ( map ( lambda word : word . strip ( <STRING> ) , line . split ( ) ) ) <NEWLINE> sl3 , sl4 = set ( s for s in ss if len ( s ) == 3 ) , set ( s for s in ss if len ( s ) == 4 ) <NEWLINE> <NL> i , rotate_dict = 0 , None <NEWLINE> for order in frequency : <NEWLINE> <INDENT> for offset in freq_chr_offset : <NEWLINE> <INDENT> i = 97 + offset - order <NEWLINE> rotate_dict = { a : b for a , b in zip ( alphabets , alphabets [ i : ] + alphabets [ : i ] ) } <NEWLINE> if ( check_exists ( sl3 , rotate_dict , <STRING> ) <NEWLINE> <INDENT> + check_exists ( sl4 , rotate_dict , <STRING> ) <NEWLINE> + check_exists ( sl4 , rotate_dict , <STRING> ) ) > 0 : <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( rotate_dict [ s ] if s . isalpha ( ) else s for s in line ) , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> vals = list ( map ( lambda v : int ( v ) , input ( ) . split ( ) ) ) <NEWLINE> vals . sort ( reverse = True ) <NEWLINE> i = 0 <NEWLINE> sum = 1 <NEWLINE> <NL> if ( 0 in vals ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while ( i < len ( vals ) ) : <NEWLINE> <INDENT> sum = sum * vals [ i ] <NEWLINE> if ( sum > 10e17 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> i = int ( input ( ) ) <NEWLINE> <NL> s , f = math . modf ( i / 1000 ) <NEWLINE> if s != 0.0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> v = int ( ( f ) * 1000 ) - i <NEWLINE> if v >= 1000 : <NEWLINE> <INDENT> print ( 2000 - v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cntD = collections . Counter ( D ) <NEWLINE> cntT = collections . Counter ( T ) <NEWLINE> <NL> result = <STRING> <NEWLINE> for t in cntT . keys ( ) : <NEWLINE> <INDENT> if not ( t in cntD ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if cntT [ t ] > cntD [ t ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in aa : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in aa : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 if ans > 10 ** 18 else ans ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> <NL> L = [ True ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> L [ 0 ] , L [ 1 ] = False , False <NEWLINE> <NL> for i in range ( 2 , int ( ( 10 ** 5 ) ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not L [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 2 <NEWLINE> while i * j <= 10 ** 5 : <NEWLINE> <INDENT> L [ i * j ] = False <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> A = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if L [ i ] and L [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l == r : <NEWLINE> <INDENT> if L [ l ] and L [ ( l + 1 ) // 2 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if L [ l ] and L [ ( l + 1 ) // 2 ] : <NEWLINE> <INDENT> print ( A [ r ] - A [ l - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ r ] - A [ l ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( h ) for h in input ( ) . split ( ) ] <NEWLINE> cnt = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> cnt [ b - 1 ] += 1 <NEWLINE> <DEDENT> elif H [ a - 1 ] == H [ b - 1 ] : <NEWLINE> <INDENT> cnt [ a - 1 ] += 1 <NEWLINE> cnt [ b - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt . count ( 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = A [ - 1 ] <NEWLINE> print ( B , min ( A , key = lambda x : abs ( B - 2 * x ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> r = range ( a , b + 1 ) <NEWLINE> r = list ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) <NEWLINE> r . sort ( ) <NEWLINE> <NL> for _r in r : <NEWLINE> <INDENT> print ( _r ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> if n > b - 1 : <NEWLINE> <INDENT> n = b - 1 <NEWLINE> <NL> <DEDENT> ans = math . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> * ( W + 2 ) ] + [ <STRING> + input ( ) + <STRING> for h in range ( H ) ] + [ <STRING> * ( W + 2 ) ] <NEWLINE> <NL> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> and S [ h - 1 ] [ w ] == <STRING> and S [ h + 1 ] [ w ] == <STRING> and S [ h ] [ w - 1 ] == <STRING> and S [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
visited = { 0 : - 1 } <NEWLINE> height = 0 <NEWLINE> pools = [ ] <NEWLINE> for i , c in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> height -= 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> height += 1 <NEWLINE> if height in visited : <NEWLINE> <INDENT> width = i - visited [ height ] <NEWLINE> sm = 0 <NEWLINE> while pools and pools [ - 1 ] [ 0 ] > visited [ height ] : <NEWLINE> <INDENT> x , l = pools . pop ( ) <NEWLINE> sm += l <NEWLINE> <DEDENT> pools . append ( ( i , sm + width - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> visited [ height ] = i <NEWLINE> <NL> <DEDENT> print ( sum ( l for x , l in pools ) ) <NEWLINE> if pools : <NEWLINE> <INDENT> print ( len ( pools ) , <STRING> . join ( str ( l ) for x , l in pools ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> bc = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> i = 0 <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> if i < n and a [ i ] < c : <NEWLINE> <INDENT> a [ i ] = c <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = ( d * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> items = set ( ) <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> items . add ( str ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( len ( items ) ) <COMMENT> <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def ans120 ( A : int , B : int , K : int ) : <NEWLINE> <INDENT> l = sorted ( [ A , B ] ) <NEWLINE> ans_list = [ ] <NEWLINE> for i in range ( 1 , l [ 1 ] + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> ans_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans_list [ - K ] <NEWLINE> <NL> <DEDENT> print ( ans120 ( A , B , K ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> result = deque ( ) <NEWLINE> func = { <STRING> : result . appendleft , <STRING> : result . remove , <STRING> : result . popleft , <STRING> : result . pop } <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> c = line . split ( ) <NEWLINE> if len ( c ) > 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> func [ c [ 0 ] ] ( int ( c [ 1 ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> func [ c [ 0 ] ] ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * result ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> ans = 1 <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> if t % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( t * 10 + 7 ) % K <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> G = [ [ ] for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> G [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> printed = [ False ] * m <NEWLINE> <NL> while printed . count ( False ) > 1 : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> for i , node in enumerate ( G ) : <NEWLINE> <INDENT> if not printed [ i ] and len ( node ) == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> printed [ i ] = True <NEWLINE> <NL> <COMMENT> <NL> for node in G : <NEWLINE> <INDENT> if i in node : <NEWLINE> <INDENT> node . remove ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if False in printed : <NEWLINE> <INDENT> i = printed . index ( False ) <NEWLINE> print ( i + 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = x // 3600 <NEWLINE> b = x // 60 % 60 <NEWLINE> c = x % 60 <NEWLINE> <NL> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> c = str ( c ) <NEWLINE> print ( <STRING> . join ( [ a , b , c ] ) ) <NEWLINE>
class Stack : <NEWLINE> <INDENT> data_list = [ ] <NEWLINE> def push ( self , a ) : <NEWLINE> <INDENT> self . data_list . append ( a ) <NEWLINE> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> return self . data_list . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> data = input ( ) <NEWLINE> lines = data . strip ( ) . split ( ) <NEWLINE> stack = Stack ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> num = int ( stack . pop ( ) ) + int ( stack . pop ( ) ) <NEWLINE> stack . push ( num ) <NEWLINE> <DEDENT> elif line == <STRING> : <NEWLINE> <INDENT> num = int ( stack . pop ( ) ) - int ( stack . pop ( ) ) <NEWLINE> stack . push ( - 1 * num ) <NEWLINE> <DEDENT> elif line == <STRING> : <NEWLINE> <INDENT> num = int ( stack . pop ( ) ) * int ( stack . pop ( ) ) <NEWLINE> stack . push ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . push ( line ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack . pop ( ) ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> bt = [ None ] + [ 0 ] * n <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> bt [ ai ] += 1 <NEWLINE> <NL> <DEDENT> for a in bt [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> import bisect <NEWLINE> <NL> ra = [ 0 ] + list ( np . cumsum ( a ) ) <NEWLINE> rb = [ 0 ] + list ( np . cumsum ( b ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> capa = k - ra [ i ] <NEWLINE> if capa < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect . bisect_right ( rb , capa ) <NEWLINE> <NL> <NL> ans = max ( ans , i - 1 + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> z = Node ( key ) <NEWLINE> y = None <COMMENT> <NEWLINE> <COMMENT> <NL> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <COMMENT> <NL> if y is None : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * list ( map ( str , self . root . inwalk ( ) ) ) ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * list ( map ( str , self . root . prewalk ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = self . left = self . right = None <NEWLINE> <NL> <DEDENT> def prewalk ( self ) : <NEWLINE> <INDENT> nodeList = [ self . key ] <NEWLINE> if self . left : <NEWLINE> <INDENT> nodeList += self . left . prewalk ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> nodeList += self . right . prewalk ( ) <NEWLINE> <DEDENT> return nodeList <NEWLINE> <NL> <DEDENT> def inwalk ( self ) : <NEWLINE> <INDENT> nodeList = [ ] <NEWLINE> if self . left : <NEWLINE> <INDENT> nodeList += self . left . inwalk ( ) <NEWLINE> <DEDENT> nodeList += [ self . key ] <NEWLINE> if self . right : <NEWLINE> <INDENT> nodeList += self . right . inwalk ( ) <NEWLINE> <DEDENT> return nodeList <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> P = [ ] <NEWLINE> I = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = list ( input ( ) . split ( ) ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( cmd [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . show ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> count = [ 0 ] * ( maxA + 1 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> count [ x ] += 1 <NEWLINE> <DEDENT> maxc = 0 <NEWLINE> for i in range ( 2 , maxA + 1 ) : <NEWLINE> <INDENT> maxc = max ( maxc , sum ( count [ i : : i ] ) ) <NEWLINE> <NL> <DEDENT> if maxc == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif maxc <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( K < A ) : <NEWLINE> <INDENT> score = K <NEWLINE> <DEDENT> elif ( K >= A and K <= A + B ) : <NEWLINE> <INDENT> score = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = A - ( K - A - B ) <NEWLINE> <NL> <DEDENT> print ( score ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs_h = [ 0 ] * H <NEWLINE> bombs_w = [ 0 ] * W <NEWLINE> B = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> B . append ( ( h , w ) ) <NEWLINE> bombs_h [ h ] += 1 <NEWLINE> bombs_w [ w ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( bombs_h ) <NEWLINE> max_w = max ( bombs_w ) <NEWLINE> hs = [ i for i , x in enumerate ( bombs_h ) if x == max_h ] <NEWLINE> ws = [ i for i , x in enumerate ( bombs_w ) if x == max_w ] <NEWLINE> k = len ( hs ) * len ( ws ) <NEWLINE> cnt = 0 <NEWLINE> for h , w in B : <NEWLINE> <INDENT> if bombs_h [ h ] == max_h and bombs_w [ w ] == max_w : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max_w + max_h - ( cnt == k ) <NEWLINE> print ( ans ) <NEWLINE>
depth = int ( input ( ) ) <NEWLINE> leaves = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> limited = [ ] <NEWLINE> limited_a = [ ] <NEWLINE> <NL> def solve ( depth ) : <NEWLINE> <INDENT> cur = 1 <NEWLINE> i = 0 <NEWLINE> while i <= depth : <NEWLINE> <INDENT> limited_a . append ( cur ) <NEWLINE> if cur <= 0 and leaves [ i ] != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> cur = ( cur - leaves [ i ] ) * 2 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> _min = _max = 0 <NEWLINE> i = depth <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> if i == depth : <NEWLINE> <INDENT> if leaves [ i ] > limited_a [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> limited . append ( leaves [ i ] ) <NEWLINE> _max = leaves [ i ] <NEWLINE> _min = ( leaves [ i ] + 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _max = min ( limited_a [ i ] , _max + leaves [ i ] ) <NEWLINE> _min = ( _min + leaves [ i ] + 1 ) // 2 <NEWLINE> if _max < _min : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> limited . append ( _max ) <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if solve ( depth ) : <NEWLINE> <INDENT> print ( sum ( limited ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> if A [ M - 1 ] < 1 / ( 4 * M ) * sum ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> if 2 in a : <NEWLINE> <INDENT> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> t = a [ k - 1 ] <NEWLINE> a [ k - 1 ] = - 1 <NEWLINE> k = t <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if k == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a . count ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> S = r * r * math . pi <NEWLINE> C = r * 2 * math . pi <NEWLINE> print ( <STRING> . format ( S ) , end = <STRING> ) <NEWLINE> print ( <STRING> . format ( C ) ) <NEWLINE>
n = int ( input ( ) ) - 1 <NEWLINE> <NL> ans = [ ] <NEWLINE> while n >= 0 : <NEWLINE> <INDENT> n , y = divmod ( n , 26 ) <NEWLINE> ans . append ( y ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> ans . reverse ( ) <NEWLINE> <NL> <NL> def to_alpha ( x ) : <NEWLINE> <INDENT> return chr ( x + ord ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( map ( to_alpha , ans ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> now = 0 <NEWLINE> i = 0 <NEWLINE> count = 0 <NEWLINE> c = [ 0 ] * N <NEWLINE> r = [ 0 ] <NEWLINE> c [ 0 ] = 1 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> count += 1 <NEWLINE> if count == K : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> elif c [ now ] == 1 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> c [ now ] = 1 <NEWLINE> r . append ( now ) <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o = [ i for i , x in enumerate ( r ) if x == now ] <NEWLINE> print ( r [ ( K - o [ 0 ] ) % ( o [ 1 ] - o [ 0 ] ) + o [ 0 ] ] + 1 ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> b_cnt = m <NEWLINE> for a_cnt in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ a_cnt ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while a [ a_cnt ] + b [ b_cnt ] > k : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a_cnt + b_cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> if x + y >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + y ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) ; s = [ * input ( ) ] ; count = 0 <NEWLINE> count = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> Q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> Q . appendleft ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> Q . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> Q . pop ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> Q . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( Q ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = x * a [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> G = [ 1 ] <NEWLINE> for i in range ( 99 ) : <NEWLINE> <INDENT> if n < 1 + 3 * G [ - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( 1 + 3 * G [ - 1 ] ) <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> G . reverse ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX_N = 2 * 10 ** 5 <NEWLINE> b = [ 1 ] <NEWLINE> visited = [ - 1 ] * ( n + 10 ) <NEWLINE> for i in range ( 1 , 2 * MAX_N + 1 ) : <NEWLINE> <INDENT> nxt = a [ b [ - 1 ] ] <NEWLINE> b . append ( nxt ) <NEWLINE> <NL> <DEDENT> if k <= n : <NEWLINE> <INDENT> print ( b [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i , bi in enumerate ( b ) : <NEWLINE> <INDENT> if visited [ bi ] == - 1 : <NEWLINE> <INDENT> visited [ bi ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = i - visited [ bi ] <NEWLINE> l = visited [ bi ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> k = k % m <NEWLINE> <NL> while k < n : <NEWLINE> <INDENT> k += m <NEWLINE> <DEDENT> print ( b [ k ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ 0 for i in range ( n ) ] <NEWLINE> y = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = x [ j ] - x [ i ] , y [ j ] - y [ i ] <NEWLINE> if v not in a : <NEWLINE> <INDENT> a [ v ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = n <NEWLINE> <COMMENT> <NL> if len ( a . values ( ) ) > 0 : <NEWLINE> <INDENT> ans -= max ( a . values ( ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kazu = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> if j > 10 ** 6 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if kazu [ i ] >= 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> kazu [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if kazu [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum , Bsum = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Asum . append ( A [ i ] + Asum [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> Bsum . append ( B [ i ] + Bsum [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if Asum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while Bsum [ j ] > K - Asum [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> <NL> s = sys . stdin <NEWLINE> <NL> cnt = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if int ( i ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( cnt , i ) , end = <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> counter_a = Counter ( A ) <NEWLINE> choice_total = sum ( [ ( count * ( count - 1 ) // 2 ) for count in counter_a . values ( ) if count > 1 ] ) <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> sub_num = A [ i ] <NEWLINE> count_sub_num = counter_a [ sub_num ] <NEWLINE> print ( choice_total - ( ( count_sub_num * ( count_sub_num - 1 ) - ( count_sub_num - 1 ) * ( count_sub_num - 2 ) ) // 2 ) ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> c = floor ( a * n / b ) - a * floor ( n / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = floor ( a * ( b - 1 ) / b ) - a * floor ( ( b - 1 ) / b ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> S = min ( A ) <NEWLINE> L = max ( A ) <NEWLINE> <NL> c = 0 <NEWLINE> B = [ ] <NEWLINE> <NL> if S == L : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> elif S >= 0 and L > 0 : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] >= A [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i + 1 ] += A [ i ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( i + 1 , i + 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif L <= 0 and S < 0 : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ - i - 2 ] <= A [ - i - 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ - i - 2 ] += A [ - i - 1 ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( N - i , N - i - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if L >= - S : <NEWLINE> <INDENT> l = A . index ( L ) <NEWLINE> if A [ 0 ] < 0 : <NEWLINE> <INDENT> A [ 0 ] += L <NEWLINE> c += 1 <NEWLINE> B . append ( ( l + 1 , 1 ) ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] >= A [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ i + 1 ] < 0 : <NEWLINE> <INDENT> A [ i + 1 ] += L <NEWLINE> c += 1 <NEWLINE> B . append ( ( l + 1 , i + 2 ) ) <NEWLINE> <DEDENT> A [ i + 1 ] += A [ i ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( i + 1 , i + 2 ) ) <NEWLINE> if i + 1 == l : <NEWLINE> <INDENT> L = A [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = A . index ( S ) <NEWLINE> if A [ - 1 ] > 0 : <NEWLINE> <INDENT> A [ - 1 ] += S <NEWLINE> c += 1 <NEWLINE> B . append ( ( s + 1 , N ) ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ - i - 2 ] <= A [ - i - 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ - i - 2 ] > 0 : <NEWLINE> <INDENT> A [ - i - 2 ] += S <NEWLINE> c += 1 <NEWLINE> B . append ( ( s + 1 , N - i - 1 ) ) <NEWLINE> <DEDENT> A [ - i - 2 ] += A [ - i - 1 ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( N - i , N - i - 1 ) ) <NEWLINE> if - i - 2 == s : <NEWLINE> <INDENT> S = A [ s ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> print ( B [ i ] [ 0 ] , B [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> max = - 1e10 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( i , len ( a ) ) : <NEWLINE> <INDENT> sum += a [ j ] <NEWLINE> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> m = n // i - 1 <NEWLINE> if m > 0 and n % i == 0 and n // m == n % m : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> move = [ ] <NEWLINE> first = [ ] <NEWLINE> second = [ ] <NEWLINE> third = [ ] <NEWLINE> forth = [ ] <NEWLINE> <NL> for p in range ( 3 ) : <NEWLINE> <INDENT> first . append ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) <NEWLINE> <NL> <DEDENT> for q in range ( 3 ) : <NEWLINE> <INDENT> second . append ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) <NEWLINE> <NL> <DEDENT> for r in range ( 3 ) : <NEWLINE> <INDENT> third . append ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) <NEWLINE> <NL> <DEDENT> for s in range ( 3 ) : <NEWLINE> <INDENT> forth . append ( [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> move . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for j in move : <NEWLINE> <INDENT> f = j [ 1 ] - 1 <NEWLINE> r = j [ 2 ] - 1 <NEWLINE> if j [ 0 ] == 1 : <NEWLINE> <INDENT> first [ f ] [ r ] += j [ 3 ] <NEWLINE> <DEDENT> elif j [ 0 ] == 2 : <NEWLINE> <INDENT> second [ f ] [ r ] += j [ 3 ] <NEWLINE> <DEDENT> elif j [ 0 ] == 3 : <NEWLINE> <INDENT> third [ f ] [ r ] += j [ 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> forth [ f ] [ r ] += j [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , first [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , second [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , third [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , forth [ i ] ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( R ) * len ( G ) * len ( B ) <NEWLINE> for i in range ( 1 , ( N + 1 ) // 2 ) : <NEWLINE> <INDENT> for j in range ( i , N - i ) : <NEWLINE> <INDENT> if S [ j ] != S [ j - i ] and S [ j ] != S [ j + i ] and S [ j - i ] != S [ j + i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if flag : ans = 0 ; break <NEWLINE> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ai = 0 <NEWLINE> Bi = 0 <NEWLINE> t = 0 <NEWLINE> result = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if Ai >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif t + A [ Ai ] <= K : <NEWLINE> <INDENT> t += A [ Ai ] <NEWLINE> Ai += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> result = Ai <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if Bi >= M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t + B [ Bi ] <= K : <NEWLINE> <INDENT> t += B [ Bi ] <NEWLINE> Bi += 1 <NEWLINE> if Ai + Bi > result : <NEWLINE> <INDENT> result = Ai + Bi <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Ai < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t -= A [ Ai - 1 ] <NEWLINE> Ai -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> A , B , N = LI ( ) <NEWLINE> if N < B : <NEWLINE> <INDENT> ans = math . floor ( A * N / B ) <NEWLINE> <DEDENT> elif N >= B : <NEWLINE> <INDENT> ans = math . floor ( A * ( B - 1 ) / B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = [ [ <STRING> ] * w for _ in range ( h ) ] <NEWLINE> <NL> if h == 1 and w == 1 : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif h == 1 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ 0 ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] [ j ] = s [ 0 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif w == 1 : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = s [ i + 1 ] [ 0 ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = s [ i - 1 ] [ 0 ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = s [ i - 1 ] [ 0 ] . count ( <STRING> ) + s [ i + 1 ] [ 0 ] . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = s [ i ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) + s [ i + 1 ] [ <NEWLINE> <INDENT> max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = s [ i - 1 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) + s [ i ] [ max ( 0 , j - 1 ) : min ( w + 1 , <NEWLINE> <INDENT> j + 2 ) ] . count ( <NEWLINE> <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = s [ i - 1 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) + s [ i ] [ max ( 0 , j - 1 ) : min ( w + 1 , <NEWLINE> <INDENT> j + 2 ) ] . count ( <NEWLINE> <STRING> ) + s [ i + 1 ] [ max ( 0 , j - 1 ) : min ( w + 1 , j + 2 ) ] . count ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> [ print ( * k , sep = <STRING> ) for k in ans ] <NEWLINE>
from math import ceil <NEWLINE> time = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> mod = [ i % 10 for i in time ] <NEWLINE> a = 124 <NEWLINE> res = 0 <NEWLINE> for i in range ( len ( mod ) ) : <NEWLINE> <INDENT> if mod [ i ] != 0 : <NEWLINE> <INDENT> a = min ( a , mod [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if a == 124 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == mod . index ( a ) : <NEWLINE> <INDENT> res += time [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += ceil ( time [ i ] / 10 ) * 10 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from math import sqrt <NEWLINE> a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( sqrt ( ( c - a ) ** 2 + ( d - b ) ** 2 ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , 2 * math . pi * r ) ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> zero = 0 <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> elif a [ i ] > 0 : <NEWLINE> <INDENT> plus . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> P , M = len ( plus ) , len ( minus ) <NEWLINE> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> elif P + M < k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif P == 0 : <NEWLINE> <INDENT> if zero and k % 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 : <NEWLINE> <INDENT> minus . reverse ( ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans *= minus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> q = 0 <NEWLINE> if k % 2 : <NEWLINE> <INDENT> ans *= plus [ 0 ] <NEWLINE> ans %= mod <NEWLINE> q = 1 <NEWLINE> <DEDENT> judge = [ ] <NEWLINE> for i in range ( ( len ( plus ) - q ) // 2 ) : <NEWLINE> <INDENT> judge . append ( plus [ 2 * i + q ] * plus [ 2 * i + q + 1 ] ) <NEWLINE> <DEDENT> for i in range ( len ( minus ) // 2 ) : <NEWLINE> <INDENT> judge . append ( minus [ 2 * i ] * minus [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> judge . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> ans *= ( judge [ i ] % mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> gcd_0 = math . gcd ( i + 1 , j + 1 ) <NEWLINE> if gcd_0 == 1 : <NEWLINE> <INDENT> ans += gcd_0 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> ans += math . gcd ( gcd_0 , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
行数 , 列数 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> 行列 = [ [ 0 for _ in range ( 列数 ) ] for __ in range ( 行数 ) ] <NEWLINE> <NL> <COMMENT> <NL> for 現在行 in range ( 行数 ) : <NEWLINE> <INDENT> 行データ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for 現在列 in range ( 列数 ) : <NEWLINE> <INDENT> 行列 [ 現在行 ] [ 現在列 ] = 行データ [ 現在列 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ベクトル = [ 0 for _ in range ( 列数 ) ] <NEWLINE> for 現在行 in range ( 列数 ) : <NEWLINE> <INDENT> ベクトル [ 現在行 ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> 答え = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( 行数 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( 列数 ) : <NEWLINE> <INDENT> c += 行列 [ i ] [ j ] * ベクトル [ j ] <NEWLINE> <NL> <DEDENT> 答え . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( len ( 答え ) ) : <NEWLINE> <INDENT> print ( 答え [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def cal_xor ( xor_list ) : <NEWLINE> <INDENT> ans = None <NEWLINE> for xi in xor_list : <NEWLINE> <INDENT> if ans is not None : <NEWLINE> <INDENT> ans = ans ^ xi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = xi <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_str = <STRING> <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ 1 ] , a [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> xors = [ ] <NEWLINE> for i in range ( N // 2 ) : <NEWLINE> <INDENT> xors . append ( a [ 2 * i ] ^ a [ 2 * i + 1 ] ) <NEWLINE> <NL> <DEDENT> sum_xor = cal_xor ( xors ) <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> tmp_xor = sum_xor ^ xors [ i // 2 ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> ind = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = i - 1 <NEWLINE> <NL> <DEDENT> ans = tmp_xor ^ a [ ind ] <NEWLINE> ans_str += str ( ans ) + <STRING> <NEWLINE> <DEDENT> print ( ans_str [ : - 1 ] ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> order = [ - 1 for i in range ( m ) ] <COMMENT> <NEWLINE> index = 0 <COMMENT> <NEWLINE> a = [ ] <COMMENT> <NEWLINE> while order [ x ] == - 1 : <COMMENT> <NEWLINE> <INDENT> order [ x ] = index <COMMENT> <NEWLINE> a . append ( x ) <NEWLINE> x = ( x ** 2 ) % m <NEWLINE> index += 1 <NEWLINE> <DEDENT> tmp = sum ( a [ order [ x ] : index ] ) <COMMENT> <NEWLINE> t = index - order [ x ] <COMMENT> <NEWLINE> if n - 1 < order [ x ] : <COMMENT> <NEWLINE> <INDENT> print ( sum ( a [ : n ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum1 = sum ( a [ : order [ x ] ] ) <COMMENT> <NEWLINE> x1 = n - order [ x ] <COMMENT> <NEWLINE> n1 = x1 // t <COMMENT> <NEWLINE> n2 = x1 % t <NEWLINE> print ( sum1 + n1 * tmp + sum ( a [ order [ x ] : order [ x ] + n2 ] ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( input ( ) for x in range ( N ) ) <NEWLINE> c = collections . Counter ( h ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
<NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> check = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> check . append ( 0 ) <NEWLINE> for j , tt in enumerate ( T ) : <NEWLINE> <INDENT> if tt == S [ i + j ] : <NEWLINE> <INDENT> check [ i ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> check . append ( 0 ) <NEWLINE> <COMMENT> <NL> print ( len ( T ) - max ( check ) ) <NEWLINE>
N , K = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> frog_lst = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> frog_jump_lst = [ ] <NEWLINE> <NL> def frog_jump ( frog_jump_lst = [ ] , index = 0 ) : <NEWLINE> <INDENT> if not frog_jump_lst : <NEWLINE> <INDENT> frog_jump_lst . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_pos = frog_lst [ index ] <NEWLINE> k = min ( K , len ( frog_jump_lst ) ) <NEWLINE> pattern = [ abs ( now_pos - frog_lst [ index - i ] ) + frog_jump_lst [ - i ] for i in range ( 1 , k + 1 ) ] <NEWLINE> frog_jump_lst . append ( min ( pattern ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> frog_jump ( frog_jump_lst , j ) <NEWLINE> <DEDENT> print ( frog_jump_lst [ - 1 ] ) <NEWLINE>
N = input ( ) <NEWLINE> if int ( N ) < 1001 : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> elif int ( N [ - 3 ] + N [ - 2 ] + N [ - 1 ] ) == 0 : <NEWLINE> <INDENT> x = 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N [ - 3 ] + N [ - 2 ] + N [ - 1 ] <NEWLINE> <DEDENT> print ( 1000 - int ( x ) ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> H_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> edge = [ [ ] for i in range ( N ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> is_peak = True <NEWLINE> for neighbor in edge [ i ] : <NEWLINE> <INDENT> if H_ls [ i ] <= H_ls [ neighbor ] : <NEWLINE> <INDENT> is_peak = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_peak : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> Q = set ( [ i for i in range ( 0 , 101 + 1 ) ] ) <NEWLINE> for p in P : <NEWLINE> <INDENT> Q . remove ( p ) <NEWLINE> <DEDENT> Q = sorted ( Q ) <NEWLINE> <COMMENT> <NL> D = [ abs ( q - X ) for q in Q ] <NEWLINE> <COMMENT> <NL> minD = min ( D ) <NEWLINE> for d , q in zip ( D , Q ) : <NEWLINE> <INDENT> if d == minD : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( q ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( 2 * ( 10 ** 5 ) + 10 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] + i >= 2 * ( 10 ** 5 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ A [ i ] + i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) [ 1 : ] : <NEWLINE> <INDENT> if A [ i ] - i >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += cnt [ abs ( A [ i ] - i ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 10 ** 18 <NEWLINE> flag = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i in flag : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cur = i <NEWLINE> accum = [ ] <NEWLINE> flag [ cur ] = 0 <NEWLINE> s = 0 <NEWLINE> while flag [ cur ] < 2 : <NEWLINE> <INDENT> cur = p [ cur ] - 1 <NEWLINE> s += c [ cur ] <NEWLINE> accum . append ( s ) <NEWLINE> if cur not in flag : <NEWLINE> <INDENT> flag [ cur ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ cur ] += 1 <NEWLINE> <DEDENT> <DEDENT> l = len ( accum ) // 2 <NEWLINE> loop = accum [ l - 1 ] <NEWLINE> accum = [ 0 ] + accum <NEWLINE> for x in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> if loop <= 0 or k // l < 1 : <NEWLINE> <INDENT> ans = max ( ans , max ( accum [ x : x + min ( k , l ) ] ) - accum [ x - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = max ( accum [ x : x + l - 1 ] ) - accum [ x - 1 ] <NEWLINE> d = accum [ x + l - 1 ] - accum [ x - 1 ] <NEWLINE> if k % l != 0 : <NEWLINE> <INDENT> b = max ( accum [ x : x + k % l ] ) - accum [ x - 1 ] <NEWLINE> ans = max ( ans , max ( k // l * d , k // l * d + b , ( k // l - 1 ) * d + a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = max ( accum [ x : x + l - 1 ] ) - accum [ x - 1 ] <NEWLINE> ans = max ( ans , max ( k // l * d , ( k // l - 1 ) * d + a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> take = [ [ - 1 ] for i in range ( M ) ] <NEWLINE> for x in range ( M ) : <NEWLINE> <INDENT> B , C = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> take [ x ] = B , C <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A . sort ( ) <NEWLINE> take . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> take = [ ( 0 , 0 ) ] + take <NEWLINE> ind = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 1 , M + 1 ) : <COMMENT> <NEWLINE> <INDENT> ind [ i ] = ind [ i - 1 ] + take [ i ] [ 0 ] <NEWLINE> if ind [ i - 1 ] >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif A [ ind [ i - 1 ] ] >= take [ i ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ind [ i ] < N and A [ ind [ i ] ] < take [ i ] [ 1 ] : <COMMENT> <NEWLINE> <INDENT> A [ ind [ i - 1 ] : ind [ i ] ] = [ take [ i ] [ 1 ] ] * ( take [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( ind [ i - 1 ] , ind [ i ] ) : <COMMENT> <NEWLINE> <INDENT> if N <= j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ j ] < take [ i ] [ 1 ] : <NEWLINE> <INDENT> A [ j ] = take [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = N // ( A + B ) <NEWLINE> b = N % ( A + B ) <NEWLINE> <NL> if A <= b : <NEWLINE> <INDENT> print ( a * A + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * A + b ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> sum_A = np . sum ( A ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for item in P : <NEWLINE> <INDENT> if item [ 0 ] in c . keys ( ) : <NEWLINE> <INDENT> sum_A += ( ( item [ 1 ] - item [ 0 ] ) * c [ item [ 0 ] ] ) <NEWLINE> if item [ 1 ] in c . keys ( ) : <NEWLINE> <INDENT> c [ item [ 1 ] ] += c [ item [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ item [ 1 ] ] = c [ item [ 0 ] ] <NEWLINE> <DEDENT> c . pop ( item [ 0 ] ) <NEWLINE> <DEDENT> print ( sum_A ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> slash = [ ] <NEWLINE> area = 0 <NEWLINE> <NL> slash_2 = [ ] <NEWLINE> area_2 = [ ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> slash . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> j = slash . pop ( ) <NEWLINE> area = area + i - j <NEWLINE> a = i - j <NEWLINE> while len ( area_2 ) > 0 and slash_2 [ len ( slash_2 ) - 1 ] > j : <NEWLINE> <INDENT> a = a + area_2 [ len ( slash_2 ) - 1 ] <NEWLINE> area_2 . pop ( ) <NEWLINE> slash_2 . pop ( ) <NEWLINE> <DEDENT> slash_2 . append ( j ) <NEWLINE> area_2 . append ( a ) <NEWLINE> <DEDENT> except : pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if area == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area ) <NEWLINE> print ( str ( len ( area_2 ) ) + <STRING> + <STRING> . join ( map ( str , area_2 ) ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for ai in range ( a + 1 ) : <NEWLINE> <INDENT> for bi in range ( b + 1 ) : <NEWLINE> <INDENT> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> y = 500 * ai + 100 * bi + 50 * ci <NEWLINE> if x == y : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if y > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ 0 ] * w for _ in range ( h ) ] <COMMENT> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> g [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> INF = 10 ** 9 <NEWLINE> dp = [ [ INF ] * w for _ in range ( h ) ] <NEWLINE> if g [ 0 ] [ 0 ] == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) ) : <NEWLINE> <INDENT> nx = j + dx <NEWLINE> ny = i + dy <NEWLINE> if ny >= h or nx >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> add = 0 <NEWLINE> if g [ ny ] [ nx ] == 0 and g [ i ] [ j ] == 1 : <NEWLINE> <INDENT> add = 1 <NEWLINE> <DEDENT> dp [ ny ] [ nx ] = min ( dp [ ny ] [ nx ] , dp [ i ] [ j ] + add ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ h - 1 ] [ w - 1 ] ) <NEWLINE> <NL> <NL>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if ( x % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( x ) : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from itertools import product <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> inp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> C , A = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C . append ( inp [ i ] [ 0 ] ) <NEWLINE> A . append ( inp [ i ] [ 1 : ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> z_A = list ( zip ( * A ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if sum ( z_A [ i ] ) < X : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( C ) <NEWLINE> <NL> for buy_bit in product ( range ( 2 ) , repeat = N ) : <NEWLINE> <INDENT> buy = 0 <NEWLINE> tmp = 0 <NEWLINE> skill = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if buy_bit [ i ] : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> skill [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> buy += C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> f = True <NEWLINE> for s in skill : <NEWLINE> <INDENT> if s < X : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ans = min ( ans , buy ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> b = sorted ( b ) <NEWLINE> for I in b : <NEWLINE> <INDENT> ans = ans * I <NEWLINE> if b [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans >= 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> sH = np . array ( sorted ( H ) , dtype = np . int64 ) <NEWLINE> shift = sH [ K - 1 : ] <NEWLINE> diff = shift - sH [ : len ( shift ) ] <NEWLINE> ans = min ( diff ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> mp = { } <NEWLINE> for f in range ( 2 , 1000000 ) : <NEWLINE> <INDENT> while n % f == 0 : <NEWLINE> <INDENT> mp [ f ] = 1 if f not in mp else mp [ f ] + 1 <NEWLINE> n //= f <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> mp [ n ] = 1 <NEWLINE> <NL> <DEDENT> def fn ( x ) : <NEWLINE> <INDENT> for i in range ( 2 , 100 ) : <NEWLINE> <INDENT> sm = i * ( i + 1 ) // 2 <NEWLINE> if x < sm : <NEWLINE> <INDENT> return i - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( fn ( mp [ p ] ) for p in mp ) ) <NEWLINE>
[ a , b ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( readline ( ) . rstrip ( ) ) <NEWLINE> sumS = 0 <NEWLINE> m = s . count ( <STRING> ) <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> sumS += ( len ( s ) - m ) - i <NEWLINE> m -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( sumS ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> from collections import deque <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> G [ x ] . append ( y ) <NEWLINE> G [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * N <NEWLINE> ans = [ 0 ] * N <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> while q : <NEWLINE> <INDENT> fm = q . popleft ( ) <NEWLINE> for to in G [ fm ] : <NEWLINE> <INDENT> if dist [ to ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ to ] += 1 <NEWLINE> ans [ to ] = fm <NEWLINE> q . append ( to ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> An . sort ( reverse = True ) <NEWLINE> ans = An [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if An [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if An [ i ] > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> if ans > 0 : <NEWLINE> <INDENT> ans = An [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if An [ i ] > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> ans *= An [ i ] <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> S = SS ( ) <NEWLINE> K = I ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> S_k = S [ K - 1 ] <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == S_k : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> e = [ list ( map ( int , e . split ( ) ) ) for e in sys . stdin ] <NEWLINE> n = e [ 0 ] [ 0 ] + 1 <NEWLINE> for c in e [ 1 : n ] : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> for l in zip ( * e [ n : ] ) : t += <STRING> <NEWLINE> print ( t [ : - 1 ] ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = A - B <NEWLINE> if abs ( ans ) > 10 ** 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 != 0 : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def get_longest_count ( X , Y ) : <NEWLINE> <INDENT> offsets = [ 0 ] <NEWLINE> for y in Y : <NEWLINE> <INDENT> tmp = offsets [ : ] <NEWLINE> for i , o in enumerate ( offsets ) : <NEWLINE> <INDENT> j = X . find ( y , o ) <NEWLINE> if j < 0 : break <NEWLINE> if i < len ( offsets ) - 1 : <NEWLINE> <INDENT> tmp [ i + 1 ] = min ( offsets [ i + 1 ] , j + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . append ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> offsets = tmp <NEWLINE> <DEDENT> return len ( offsets ) - 1 <NEWLINE> <NL> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( get_longest_count ( X , Y ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> def get_sum ( dic ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <NL> for k , v in dic . items ( ) : <NEWLINE> <INDENT> sum += k * v <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = dict ( ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> dic . setdefault ( ai , 0 ) <NEWLINE> dic [ ai ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = dic . pop ( b , 0 ) <NEWLINE> <NL> if count > 0 : <NEWLINE> <INDENT> dic . setdefault ( c , 0 ) <NEWLINE> dic [ c ] += count <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> sum = get_sum ( dic ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += ( c - b ) * count <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> amari_reserve = 7 % K <NEWLINE> amari = amari_reserve <NEWLINE> if amari_reserve == 0 : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> while ( ans <= K ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> amari = ( 10 * amari + 7 ) % K <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> if amari == amari_reserve : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = LI ( ) <NEWLINE> field = [ S ( ) for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> visited = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if visited [ i ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = collections . deque ( ) <NEWLINE> q . append ( ( i , j ) ) <NEWLINE> b = 0 <NEWLINE> wh = 0 <NEWLINE> while q : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> if visited [ y ] [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wh += 1 <NEWLINE> <DEDENT> visited [ y ] [ x ] = True <NEWLINE> for dy , dx in dd : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if not ( 0 <= ny < h and 0 <= nx < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ y ] [ x ] == field [ ny ] [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if visited [ ny ] [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> ans += b * wh <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = 1 <NEWLINE> b = n - k + 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = a * b % mod <NEWLINE> print ( ans ) <NEWLINE> a = a * ( k - 1 - i ) // ( i + 1 ) <NEWLINE> b = b * ( n - k - i ) // ( i + 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> <NL> if sum ( s ) % 10 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( s ) - s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( sum ( s ) ) <NEWLINE>
import bisect <NEWLINE> l = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 , 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 , 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 , 13513 , 13523 , 13537 , 13553 , 13567 , 13577 , 13591 , 13597 , 13613 , 13619 , 13627 , 13633 , 13649 , 13669 , 13679 , 13681 , 13687 , 13691 , 13693 , 13697 , 13709 , 13711 , 13721 , 13723 , 13729 , 13751 , 13757 , 13759 , 13763 , 13781 , 13789 , 13799 , 13807 , 13829 , 13831 , 13841 , 13859 , 13873 , 13877 , 13879 , 13883 , 13901 , 13903 , 13907 , 13913 , 13921 , 13931 , 13933 , 13963 , 13967 , 13997 , 13999 , 14009 , 14011 , 14029 , 14033 , 14051 , 14057 , 14071 , 14081 , 14083 , 14087 , 14107 , 14143 , 14149 , 14153 , 14159 , 14173 , 14177 , 14197 , 14207 , 14221 , 14243 , 14249 , 14251 , 14281 , 14293 , 14303 , 14321 , 14323 , 14327 , 14341 , 14347 , 14369 , 14387 , 14389 , 14401 , 14407 , 14411 , 14419 , 14423 , 14431 , 14437 , 14447 , 14449 , 14461 , 14479 , 14489 , 14503 , 14519 , 14533 , 14537 , 14543 , 14549 , 14551 , 14557 , 14561 , 14563 , 14591 , 14593 , 14621 , 14627 , 14629 , 14633 , 14639 , 14653 , 14657 , 14669 , 14683 , 14699 , 14713 , 14717 , 14723 , 14731 , 14737 , 14741 , 14747 , 14753 , 14759 , 14767 , 14771 , 14779 , 14783 , 14797 , 14813 , 14821 , 14827 , 14831 , 14843 , 14851 , 14867 , 14869 , 14879 , 14887 , 14891 , 14897 , 14923 , 14929 , 14939 , 14947 , 14951 , 14957 , 14969 , 14983 , 15013 , 15017 , 15031 , 15053 , 15061 , 15073 , 15077 , 15083 , 15091 , 15101 , 15107 , 15121 , 15131 , 15137 , 15139 , 15149 , 15161 , 15173 , 15187 , 15193 , 15199 , 15217 , 15227 , 15233 , 15241 , 15259 , 15263 , 15269 , 15271 , 15277 , 15287 , 15289 , 15299 , 15307 , 15313 , 15319 , 15329 , 15331 , 15349 , 15359 , 15361 , 15373 , 15377 , 15383 , 15391 , 15401 , 15413 , 15427 , 15439 , 15443 , 15451 , 15461 , 15467 , 15473 , 15493 , 15497 , 15511 , 15527 , 15541 , 15551 , 15559 , 15569 , 15581 , 15583 , 15601 , 15607 , 15619 , 15629 , 15641 , 15643 , 15647 , 15649 , 15661 , 15667 , 15671 , 15679 , 15683 , 15727 , 15731 , 15733 , 15737 , 15739 , 15749 , 15761 , 15767 , 15773 , 15787 , 15791 , 15797 , 15803 , 15809 , 15817 , 15823 , 15859 , 15877 , 15881 , 15887 , 15889 , 15901 , 15907 , 15913 , 15919 , 15923 , 15937 , 15959 , 15971 , 15973 , 15991 , 16001 , 16007 , 16033 , 16057 , 16061 , 16063 , 16067 , 16069 , 16073 , 16087 , 16091 , 16097 , 16103 , 16111 , 16127 , 16139 , 16141 , 16183 , 16187 , 16189 , 16193 , 16217 , 16223 , 16229 , 16231 , 16249 , 16253 , 16267 , 16273 , 16301 , 16319 , 16333 , 16339 , 16349 , 16361 , 16363 , 16369 , 16381 , 16411 , 16417 , 16421 , 16427 , 16433 , 16447 , 16451 , 16453 , 16477 , 16481 , 16487 , 16493 , 16519 , 16529 , 16547 , 16553 , 16561 , 16567 , 16573 , 16603 , 16607 , 16619 , 16631 , 16633 , 16649 , 16651 , 16657 , 16661 , 16673 , 16691 , 16693 , 16699 , 16703 , 16729 , 16741 , 16747 , 16759 , 16763 , 16787 , 16811 , 16823 , 16829 , 16831 , 16843 , 16871 , 16879 , 16883 , 16889 , 16901 , 16903 , 16921 , 16927 , 16931 , 16937 , 16943 , 16963 , 16979 , 16981 , 16987 , 16993 , 17011 , 17021 , 17027 , 17029 , 17033 , 17041 , 17047 , 17053 , 17077 , 17093 , 17099 , 17107 , 17117 , 17123 , 17137 , 17159 , 17167 , 17183 , 17189 , 17191 , 17203 , 17207 , 17209 , 17231 , 17239 , 17257 , 17291 , 17293 , 17299 , 17317 , 17321 , 17327 , 17333 , 17341 , 17351 , 17359 , 17377 , 17383 , 17387 , 17389 , 17393 , 17401 , 17417 , 17419 , 17431 , 17443 , 17449 , 17467 , 17471 , 17477 , 17483 , 17489 , 17491 , 17497 , 17509 , 17519 , 17539 , 17551 , 17569 , 17573 , 17579 , 17581 , 17597 , 17599 , 17609 , 17623 , 17627 , 17657 , 17659 , 17669 , 17681 , 17683 , 17707 , 17713 , 17729 , 17737 , 17747 , 17749 , 17761 , 17783 , 17789 , 17791 , 17807 , 17827 , 17837 , 17839 , 17851 , 17863 , 17881 , 17891 , 17903 , 17909 , 17911 , 17921 , 17923 , 17929 , 17939 , 17957 , 17959 , 17971 , 17977 , 17981 , 17987 , 17989 , 18013 , 18041 , 18043 , 18047 , 18049 , 18059 , 18061 , 18077 , 18089 , 18097 , 18119 , 18121 , 18127 , 18131 , 18133 , 18143 , 18149 , 18169 , 18181 , 18191 , 18199 , 18211 , 18217 , 18223 , 18229 , 18233 , 18251 , 18253 , 18257 , 18269 , 18287 , 18289 , 18301 , 18307 , 18311 , 18313 , 18329 , 18341 , 18353 , 18367 , 18371 , 18379 , 18397 , 18401 , 18413 , 18427 , 18433 , 18439 , 18443 , 18451 , 18457 , 18461 , 18481 , 18493 , 18503 , 18517 , 18521 , 18523 , 18539 , 18541 , 18553 , 18583 , 18587 , 18593 , 18617 , 18637 , 18661 , 18671 , 18679 , 18691 , 18701 , 18713 , 18719 , 18731 , 18743 , 18749 , 18757 , 18773 , 18787 , 18793 , 18797 , 18803 , 18839 , 18859 , 18869 , 18899 , 18911 , 18913 , 18917 , 18919 , 18947 , 18959 , 18973 , 18979 , 19001 , 19009 , 19013 , 19031 , 19037 , 19051 , 19069 , 19073 , 19079 , 19081 , 19087 , 19121 , 19139 , 19141 , 19157 , 19163 , 19181 , 19183 , 19207 , 19211 , 19213 , 19219 , 19231 , 19237 , 19249 , 19259 , 19267 , 19273 , 19289 , 19301 , 19309 , 19319 , 19333 , 19373 , 19379 , 19381 , 19387 , 19391 , 19403 , 19417 , 19421 , 19423 , 19427 , 19429 , 19433 , 19441 , 19447 , 19457 , 19463 , 19469 , 19471 , 19477 , 19483 , 19489 , 19501 , 19507 , 19531 , 19541 , 19543 , 19553 , 19559 , 19571 , 19577 , 19583 , 19597 , 19603 , 19609 , 19661 , 19681 , 19687 , 19697 , 19699 , 19709 , 19717 , 19727 , 19739 , 19751 , 19753 , 19759 , 19763 , 19777 , 19793 , 19801 , 19813 , 19819 , 19841 , 19843 , 19853 , 19861 , 19867 , 19889 , 19891 , 19913 , 19919 , 19927 , 19937 , 19949 , 19961 , 19963 , 19973 , 19979 , 19991 , 19993 , 19997 , 20011 , 20021 , 20023 , 20029 , 20047 , 20051 , 20063 , 20071 , 20089 , 20101 , 20107 , 20113 , 20117 , 20123 , 20129 , 20143 , 20147 , 20149 , 20161 , 20173 , 20177 , 20183 , 20201 , 20219 , 20231 , 20233 , 20249 , 20261 , 20269 , 20287 , 20297 , 20323 , 20327 , 20333 , 20341 , 20347 , 20353 , 20357 , 20359 , 20369 , 20389 , 20393 , 20399 , 20407 , 20411 , 20431 , 20441 , 20443 , 20477 , 20479 , 20483 , 20507 , 20509 , 20521 , 20533 , 20543 , 20549 , 20551 , 20563 , 20593 , 20599 , 20611 , 20627 , 20639 , 20641 , 20663 , 20681 , 20693 , 20707 , 20717 , 20719 , 20731 , 20743 , 20747 , 20749 , 20753 , 20759 , 20771 , 20773 , 20789 , 20807 , 20809 , 20849 , 20857 , 20873 , 20879 , 20887 , 20897 , 20899 , 20903 , 20921 , 20929 , 20939 , 20947 , 20959 , 20963 , 20981 , 20983 , 21001 , 21011 , 21013 , 21017 , 21019 , 21023 , 21031 , 21059 , 21061 , 21067 , 21089 , 21101 , 21107 , 21121 , 21139 , 21143 , 21149 , 21157 , 21163 , 21169 , 21179 , 21187 , 21191 , 21193 , 21211 , 21221 , 21227 , 21247 , 21269 , 21277 , 21283 , 21313 , 21317 , 21319 , 21323 , 21341 , 21347 , 21377 , 21379 , 21383 , 21391 , 21397 , 21401 , 21407 , 21419 , 21433 , 21467 , 21481 , 21487 , 21491 , 21493 , 21499 , 21503 , 21517 , 21521 , 21523 , 21529 , 21557 , 21559 , 21563 , 21569 , 21577 , 21587 , 21589 , 21599 , 21601 , 21611 , 21613 , 21617 , 21647 , 21649 , 21661 , 21673 , 21683 , 21701 , 21713 , 21727 , 21737 , 21739 , 21751 , 21757 , 21767 , 21773 , 21787 , 21799 , 21803 , 21817 , 21821 , 21839 , 21841 , 21851 , 21859 , 21863 , 21871 , 21881 , 21893 , 21911 , 21929 , 21937 , 21943 , 21961 , 21977 , 21991 , 21997 , 22003 , 22013 , 22027 , 22031 , 22037 , 22039 , 22051 , 22063 , 22067 , 22073 , 22079 , 22091 , 22093 , 22109 , 22111 , 22123 , 22129 , 22133 , 22147 , 22153 , 22157 , 22159 , 22171 , 22189 , 22193 , 22229 , 22247 , 22259 , 22271 , 22273 , 22277 , 22279 , 22283 , 22291 , 22303 , 22307 , 22343 , 22349 , 22367 , 22369 , 22381 , 22391 , 22397 , 22409 , 22433 , 22441 , 22447 , 22453 , 22469 , 22481 , 22483 , 22501 , 22511 , 22531 , 22541 , 22543 , 22549 , 22567 , 22571 , 22573 , 22613 , 22619 , 22621 , 22637 , 22639 , 22643 , 22651 , 22669 , 22679 , 22691 , 22697 , 22699 , 22709 , 22717 , 22721 , 22727 , 22739 , 22741 , 22751 , 22769 , 22777 , 22783 , 22787 , 22807 , 22811 , 22817 , 22853 , 22859 , 22861 , 22871 , 22877 , 22901 , 22907 , 22921 , 22937 , 22943 , 22961 , 22963 , 22973 , 22993 , 23003 , 23011 , 23017 , 23021 , 23027 , 23029 , 23039 , 23041 , 23053 , 23057 , 23059 , 23063 , 23071 , 23081 , 23087 , 23099 , 23117 , 23131 , 23143 , 23159 , 23167 , 23173 , 23189 , 23197 , 23201 , 23203 , 23209 , 23227 , 23251 , 23269 , 23279 , 23291 , 23293 , 23297 , 23311 , 23321 , 23327 , 23333 , 23339 , 23357 , 23369 , 23371 , 23399 , 23417 , 23431 , 23447 , 23459 , 23473 , 23497 , 23509 , 23531 , 23537 , 23539 , 23549 , 23557 , 23561 , 23563 , 23567 , 23581 , 23593 , 23599 , 23603 , 23609 , 23623 , 23627 , 23629 , 23633 , 23663 , 23669 , 23671 , 23677 , 23687 , 23689 , 23719 , 23741 , 23743 , 23747 , 23753 , 23761 , 23767 , 23773 , 23789 , 23801 , 23813 , 23819 , 23827 , 23831 , 23833 , 23857 , 23869 , 23873 , 23879 , 23887 , 23893 , 23899 , 23909 , 23911 , 23917 , 23929 , 23957 , 23971 , 23977 , 23981 , 23993 , 24001 , 24007 , 24019 , 24023 , 24029 , 24043 , 24049 , 24061 , 24071 , 24077 , 24083 , 24091 , 24097 , 24103 , 24107 , 24109 , 24113 , 24121 , 24133 , 24137 , 24151 , 24169 , 24179 , 24181 , 24197 , 24203 , 24223 , 24229 , 24239 , 24247 , 24251 , 24281 , 24317 , 24329 , 24337 , 24359 , 24371 , 24373 , 24379 , 24391 , 24407 , 24413 , 24419 , 24421 , 24439 , 24443 , 24469 , 24473 , 24481 , 24499 , 24509 , 24517 , 24527 , 24533 , 24547 , 24551 , 24571 , 24593 , 24611 , 24623 , 24631 , 24659 , 24671 , 24677 , 24683 , 24691 , 24697 , 24709 , 24733 , 24749 , 24763 , 24767 , 24781 , 24793 , 24799 , 24809 , 24821 , 24841 , 24847 , 24851 , 24859 , 24877 , 24889 , 24907 , 24917 , 24919 , 24923 , 24943 , 24953 , 24967 , 24971 , 24977 , 24979 , 24989 , 25013 , 25031 , 25033 , 25037 , 25057 , 25073 , 25087 , 25097 , 25111 , 25117 , 25121 , 25127 , 25147 , 25153 , 25163 , 25169 , 25171 , 25183 , 25189 , 25219 , 25229 , 25237 , 25243 , 25247 , 25253 , 25261 , 25301 , 25303 , 25307 , 25309 , 25321 , 25339 , 25343 , 25349 , 25357 , 25367 , 25373 , 25391 , 25409 , 25411 , 25423 , 25439 , 25447 , 25453 , 25457 , 25463 , 25469 , 25471 , 25523 , 25537 , 25541 , 25561 , 25577 , 25579 , 25583 , 25589 , 25601 , 25603 , 25609 , 25621 , 25633 , 25639 , 25643 , 25657 , 25667 , 25673 , 25679 , 25693 , 25703 , 25717 , 25733 , 25741 , 25747 , 25759 , 25763 , 25771 , 25793 , 25799 , 25801 , 25819 , 25841 , 25847 , 25849 , 25867 , 25873 , 25889 , 25903 , 25913 , 25919 , 25931 , 25933 , 25939 , 25943 , 25951 , 25969 , 25981 , 25997 , 25999 , 26003 , 26017 , 26021 , 26029 , 26041 , 26053 , 26083 , 26099 , 26107 , 26111 , 26113 , 26119 , 26141 , 26153 , 26161 , 26171 , 26177 , 26183 , 26189 , 26203 , 26209 , 26227 , 26237 , 26249 , 26251 , 26261 , 26263 , 26267 , 26293 , 26297 , 26309 , 26317 , 26321 , 26339 , 26347 , 26357 , 26371 , 26387 , 26393 , 26399 , 26407 , 26417 , 26423 , 26431 , 26437 , 26449 , 26459 , 26479 , 26489 , 26497 , 26501 , 26513 , 26539 , 26557 , 26561 , 26573 , 26591 , 26597 , 26627 , 26633 , 26641 , 26647 , 26669 , 26681 , 26683 , 26687 , 26693 , 26699 , 26701 , 26711 , 26713 , 26717 , 26723 , 26729 , 26731 , 26737 , 26759 , 26777 , 26783 , 26801 , 26813 , 26821 , 26833 , 26839 , 26849 , 26861 , 26863 , 26879 , 26881 , 26891 , 26893 , 26903 , 26921 , 26927 , 26947 , 26951 , 26953 , 26959 , 26981 , 26987 , 26993 , 27011 , 27017 , 27031 , 27043 , 27059 , 27061 , 27067 , 27073 , 27077 , 27091 , 27103 , 27107 , 27109 , 27127 , 27143 , 27179 , 27191 , 27197 , 27211 , 27239 , 27241 , 27253 , 27259 , 27271 , 27277 , 27281 , 27283 , 27299 , 27329 , 27337 , 27361 , 27367 , 27397 , 27407 , 27409 , 27427 , 27431 , 27437 , 27449 , 27457 , 27479 , 27481 , 27487 , 27509 , 27527 , 27529 , 27539 , 27541 , 27551 , 27581 , 27583 , 27611 , 27617 , 27631 , 27647 , 27653 , 27673 , 27689 , 27691 , 27697 , 27701 , 27733 , 27737 , 27739 , 27743 , 27749 , 27751 , 27763 , 27767 , 27773 , 27779 , 27791 , 27793 , 27799 , 27803 , 27809 , 27817 , 27823 , 27827 , 27847 , 27851 , 27883 , 27893 , 27901 , 27917 , 27919 , 27941 , 27943 , 27947 , 27953 , 27961 , 27967 , 27983 , 27997 , 28001 , 28019 , 28027 , 28031 , 28051 , 28057 , 28069 , 28081 , 28087 , 28097 , 28099 , 28109 , 28111 , 28123 , 28151 , 28163 , 28181 , 28183 , 28201 , 28211 , 28219 , 28229 , 28277 , 28279 , 28283 , 28289 , 28297 , 28307 , 28309 , 28319 , 28349 , 28351 , 28387 , 28393 , 28403 , 28409 , 28411 , 28429 , 28433 , 28439 , 28447 , 28463 , 28477 , 28493 , 28499 , 28513 , 28517 , 28537 , 28541 , 28547 , 28549 , 28559 , 28571 , 28573 , 28579 , 28591 , 28597 , 28603 , 28607 , 28619 , 28621 , 28627 , 28631 , 28643 , 28649 , 28657 , 28661 , 28663 , 28669 , 28687 , 28697 , 28703 , 28711 , 28723 , 28729 , 28751 , 28753 , 28759 , 28771 , 28789 , 28793 , 28807 , 28813 , 28817 , 28837 , 28843 , 28859 , 28867 , 28871 , 28879 , 28901 , 28909 , 28921 , 28927 , 28933 , 28949 , 28961 , 28979 , 29009 , 29017 , 29021 , 29023 , 29027 , 29033 , 29059 , 29063 , 29077 , 29101 , 29123 , 29129 , 29131 , 29137 , 29147 , 29153 , 29167 , 29173 , 29179 , 29191 , 29201 , 29207 , 29209 , 29221 , 29231 , 29243 , 29251 , 29269 , 29287 , 29297 , 29303 , 29311 , 29327 , 29333 , 29339 , 29347 , 29363 , 29383 , 29387 , 29389 , 29399 , 29401 , 29411 , 29423 , 29429 , 29437 , 29443 , 29453 , 29473 , 29483 , 29501 , 29527 , 29531 , 29537 , 29567 , 29569 , 29573 , 29581 , 29587 , 29599 , 29611 , 29629 , 29633 , 29641 , 29663 , 29669 , 29671 , 29683 , 29717 , 29723 , 29741 , 29753 , 29759 , 29761 , 29789 , 29803 , 29819 , 29833 , 29837 , 29851 , 29863 , 29867 , 29873 , 29879 , 29881 , 29917 , 29921 , 29927 , 29947 , 29959 , 29983 , 29989 , 30011 , 30013 , 30029 , 30047 , 30059 , 30071 , 30089 , 30091 , 30097 , 30103 , 30109 , 30113 , 30119 , 30133 , 30137 , 30139 , 30161 , 30169 , 30181 , 30187 , 30197 , 30203 , 30211 , 30223 , 30241 , 30253 , 30259 , 30269 , 30271 , 30293 , 30307 , 30313 , 30319 , 30323 , 30341 , 30347 , 30367 , 30389 , 30391 , 30403 , 30427 , 30431 , 30449 , 30467 , 30469 , 30491 , 30493 , 30497 , 30509 , 30517 , 30529 , 30539 , 30553 , 30557 , 30559 , 30577 , 30593 , 30631 , 30637 , 30643 , 30649 , 30661 , 30671 , 30677 , 30689 , 30697 , 30703 , 30707 , 30713 , 30727 , 30757 , 30763 , 30773 , 30781 , 30803 , 30809 , 30817 , 30829 , 30839 , 30841 , 30851 , 30853 , 30859 , 30869 , 30871 , 30881 , 30893 , 30911 , 30931 , 30937 , 30941 , 30949 , 30971 , 30977 , 30983 , 31013 , 31019 , 31033 , 31039 , 31051 , 31063 , 31069 , 31079 , 31081 , 31091 , 31121 , 31123 , 31139 , 31147 , 31151 , 31153 , 31159 , 31177 , 31181 , 31183 , 31189 , 31193 , 31219 , 31223 , 31231 , 31237 , 31247 , 31249 , 31253 , 31259 , 31267 , 31271 , 31277 , 31307 , 31319 , 31321 , 31327 , 31333 , 31337 , 31357 , 31379 , 31387 , 31391 , 31393 , 31397 , 31469 , 31477 , 31481 , 31489 , 31511 , 31513 , 31517 , 31531 , 31541 , 31543 , 31547 , 31567 , 31573 , 31583 , 31601 , 31607 , 31627 , 31643 , 31649 , 31657 , 31663 , 31667 , 31687 , 31699 , 31721 , 31723 , 31727 , 31729 , 31741 , 31751 , 31769 , 31771 , 31793 , 31799 , 31817 , 31847 , 31849 , 31859 , 31873 , 31883 , 31891 , 31907 , 31957 , 31963 , 31973 , 31981 , 31991 , 32003 , 32009 , 32027 , 32029 , 32051 , 32057 , 32059 , 32063 , 32069 , 32077 , 32083 , 32089 , 32099 , 32117 , 32119 , 32141 , 32143 , 32159 , 32173 , 32183 , 32189 , 32191 , 32203 , 32213 , 32233 , 32237 , 32251 , 32257 , 32261 , 32297 , 32299 , 32303 , 32309 , 32321 , 32323 , 32327 , 32341 , 32353 , 32359 , 32363 , 32369 , 32371 , 32377 , 32381 , 32401 , 32411 , 32413 , 32423 , 32429 , 32441 , 32443 , 32467 , 32479 , 32491 , 32497 , 32503 , 32507 , 32531 , 32533 , 32537 , 32561 , 32563 , 32569 , 32573 , 32579 , 32587 , 32603 , 32609 , 32611 , 32621 , 32633 , 32647 , 32653 , 32687 , 32693 , 32707 , 32713 , 32717 , 32719 , 32749 , 32771 , 32779 , 32783 , 32789 , 32797 , 32801 , 32803 , 32831 , 32833 , 32839 , 32843 , 32869 , 32887 , 32909 , 32911 , 32917 , 32933 , 32939 , 32941 , 32957 , 32969 , 32971 , 32983 , 32987 , 32993 , 32999 , 33013 , 33023 , 33029 , 33037 , 33049 , 33053 , 33071 , 33073 , 33083 , 33091 , 33107 , 33113 , 33119 , 33149 , 33151 , 33161 , 33179 , 33181 , 33191 , 33199 , 33203 , 33211 , 33223 , 33247 , 33287 , 33289 , 33301 , 33311 , 33317 , 33329 , 33331 , 33343 , 33347 , 33349 , 33353 , 33359 , 33377 , 33391 , 33403 , 33409 , 33413 , 33427 , 33457 , 33461 , 33469 , 33479 , 33487 , 33493 , 33503 , 33521 , 33529 , 33533 , 33547 , 33563 , 33569 , 33577 , 33581 , 33587 , 33589 , 33599 , 33601 , 33613 , 33617 , 33619 , 33623 , 33629 , 33637 , 33641 , 33647 , 33679 , 33703 , 33713 , 33721 , 33739 , 33749 , 33751 , 33757 , 33767 , 33769 , 33773 , 33791 , 33797 , 33809 , 33811 , 33827 , 33829 , 33851 , 33857 , 33863 , 33871 , 33889 , 33893 , 33911 , 33923 , 33931 , 33937 , 33941 , 33961 , 33967 , 33997 , 34019 , 34031 , 34033 , 34039 , 34057 , 34061 , 34123 , 34127 , 34129 , 34141 , 34147 , 34157 , 34159 , 34171 , 34183 , 34211 , 34213 , 34217 , 34231 , 34253 , 34259 , 34261 , 34267 , 34273 , 34283 , 34297 , 34301 , 34303 , 34313 , 34319 , 34327 , 34337 , 34351 , 34361 , 34367 , 34369 , 34381 , 34403 , 34421 , 34429 , 34439 , 34457 , 34469 , 34471 , 34483 , 34487 , 34499 , 34501 , 34511 , 34513 , 34519 , 34537 , 34543 , 34549 , 34583 , 34589 , 34591 , 34603 , 34607 , 34613 , 34631 , 34649 , 34651 , 34667 , 34673 , 34679 , 34687 , 34693 , 34703 , 34721 , 34729 , 34739 , 34747 , 34757 , 34759 , 34763 , 34781 , 34807 , 34819 , 34841 , 34843 , 34847 , 34849 , 34871 , 34877 , 34883 , 34897 , 34913 , 34919 , 34939 , 34949 , 34961 , 34963 , 34981 , 35023 , 35027 , 35051 , 35053 , 35059 , 35069 , 35081 , 35083 , 35089 , 35099 , 35107 , 35111 , 35117 , 35129 , 35141 , 35149 , 35153 , 35159 , 35171 , 35201 , 35221 , 35227 , 35251 , 35257 , 35267 , 35279 , 35281 , 35291 , 35311 , 35317 , 35323 , 35327 , 35339 , 35353 , 35363 , 35381 , 35393 , 35401 , 35407 , 35419 , 35423 , 35437 , 35447 , 35449 , 35461 , 35491 , 35507 , 35509 , 35521 , 35527 , 35531 , 35533 , 35537 , 35543 , 35569 , 35573 , 35591 , 35593 , 35597 , 35603 , 35617 , 35671 , 35677 , 35729 , 35731 , 35747 , 35753 , 35759 , 35771 , 35797 , 35801 , 35803 , 35809 , 35831 , 35837 , 35839 , 35851 , 35863 , 35869 , 35879 , 35897 , 35899 , 35911 , 35923 , 35933 , 35951 , 35963 , 35969 , 35977 , 35983 , 35993 , 35999 , 36007 , 36011 , 36013 , 36017 , 36037 , 36061 , 36067 , 36073 , 36083 , 36097 , 36107 , 36109 , 36131 , 36137 , 36151 , 36161 , 36187 , 36191 , 36209 , 36217 , 36229 , 36241 , 36251 , 36263 , 36269 , 36277 , 36293 , 36299 , 36307 , 36313 , 36319 , 36341 , 36343 , 36353 , 36373 , 36383 , 36389 , 36433 , 36451 , 36457 , 36467 , 36469 , 36473 , 36479 , 36493 , 36497 , 36523 , 36527 , 36529 , 36541 , 36551 , 36559 , 36563 , 36571 , 36583 , 36587 , 36599 , 36607 , 36629 , 36637 , 36643 , 36653 , 36671 , 36677 , 36683 , 36691 , 36697 , 36709 , 36713 , 36721 , 36739 , 36749 , 36761 , 36767 , 36779 , 36781 , 36787 , 36791 , 36793 , 36809 , 36821 , 36833 , 36847 , 36857 , 36871 , 36877 , 36887 , 36899 , 36901 , 36913 , 36919 , 36923 , 36929 , 36931 , 36943 , 36947 , 36973 , 36979 , 36997 , 37003 , 37013 , 37019 , 37021 , 37039 , 37049 , 37057 , 37061 , 37087 , 37097 , 37117 , 37123 , 37139 , 37159 , 37171 , 37181 , 37189 , 37199 , 37201 , 37217 , 37223 , 37243 , 37253 , 37273 , 37277 , 37307 , 37309 , 37313 , 37321 , 37337 , 37339 , 37357 , 37361 , 37363 , 37369 , 37379 , 37397 , 37409 , 37423 , 37441 , 37447 , 37463 , 37483 , 37489 , 37493 , 37501 , 37507 , 37511 , 37517 , 37529 , 37537 , 37547 , 37549 , 37561 , 37567 , 37571 , 37573 , 37579 , 37589 , 37591 , 37607 , 37619 , 37633 , 37643 , 37649 , 37657 , 37663 , 37691 , 37693 , 37699 , 37717 , 37747 , 37781 , 37783 , 37799 , 37811 , 37813 , 37831 , 37847 , 37853 , 37861 , 37871 , 37879 , 37889 , 37897 , 37907 , 37951 , 37957 , 37963 , 37967 , 37987 , 37991 , 37993 , 37997 , 38011 , 38039 , 38047 , 38053 , 38069 , 38083 , 38113 , 38119 , 38149 , 38153 , 38167 , 38177 , 38183 , 38189 , 38197 , 38201 , 38219 , 38231 , 38237 , 38239 , 38261 , 38273 , 38281 , 38287 , 38299 , 38303 , 38317 , 38321 , 38327 , 38329 , 38333 , 38351 , 38371 , 38377 , 38393 , 38431 , 38447 , 38449 , 38453 , 38459 , 38461 , 38501 , 38543 , 38557 , 38561 , 38567 , 38569 , 38593 , 38603 , 38609 , 38611 , 38629 , 38639 , 38651 , 38653 , 38669 , 38671 , 38677 , 38693 , 38699 , 38707 , 38711 , 38713 , 38723 , 38729 , 38737 , 38747 , 38749 , 38767 , 38783 , 38791 , 38803 , 38821 , 38833 , 38839 , 38851 , 38861 , 38867 , 38873 , 38891 , 38903 , 38917 , 38921 , 38923 , 38933 , 38953 , 38959 , 38971 , 38977 , 38993 , 39019 , 39023 , 39041 , 39043 , 39047 , 39079 , 39089 , 39097 , 39103 , 39107 , 39113 , 39119 , 39133 , 39139 , 39157 , 39161 , 39163 , 39181 , 39191 , 39199 , 39209 , 39217 , 39227 , 39229 , 39233 , 39239 , 39241 , 39251 , 39293 , 39301 , 39313 , 39317 , 39323 , 39341 , 39343 , 39359 , 39367 , 39371 , 39373 , 39383 , 39397 , 39409 , 39419 , 39439 , 39443 , 39451 , 39461 , 39499 , 39503 , 39509 , 39511 , 39521 , 39541 , 39551 , 39563 , 39569 , 39581 , 39607 , 39619 , 39623 , 39631 , 39659 , 39667 , 39671 , 39679 , 39703 , 39709 , 39719 , 39727 , 39733 , 39749 , 39761 , 39769 , 39779 , 39791 , 39799 , 39821 , 39827 , 39829 , 39839 , 39841 , 39847 , 39857 , 39863 , 39869 , 39877 , 39883 , 39887 , 39901 , 39929 , 39937 , 39953 , 39971 , 39979 , 39983 , 39989 , 40009 , 40013 , 40031 , 40037 , 40039 , 40063 , 40087 , 40093 , 40099 , 40111 , 40123 , 40127 , 40129 , 40151 , 40153 , 40163 , 40169 , 40177 , 40189 , 40193 , 40213 , 40231 , 40237 , 40241 , 40253 , 40277 , 40283 , 40289 , 40343 , 40351 , 40357 , 40361 , 40387 , 40423 , 40427 , 40429 , 40433 , 40459 , 40471 , 40483 , 40487 , 40493 , 40499 , 40507 , 40519 , 40529 , 40531 , 40543 , 40559 , 40577 , 40583 , 40591 , 40597 , 40609 , 40627 , 40637 , 40639 , 40693 , 40697 , 40699 , 40709 , 40739 , 40751 , 40759 , 40763 , 40771 , 40787 , 40801 , 40813 , 40819 , 40823 , 40829 , 40841 , 40847 , 40849 , 40853 , 40867 , 40879 , 40883 , 40897 , 40903 , 40927 , 40933 , 40939 , 40949 , 40961 , 40973 , 40993 , 41011 , 41017 , 41023 , 41039 , 41047 , 41051 , 41057 , 41077 , 41081 , 41113 , 41117 , 41131 , 41141 , 41143 , 41149 , 41161 , 41177 , 41179 , 41183 , 41189 , 41201 , 41203 , 41213 , 41221 , 41227 , 41231 , 41233 , 41243 , 41257 , 41263 , 41269 , 41281 , 41299 , 41333 , 41341 , 41351 , 41357 , 41381 , 41387 , 41389 , 41399 , 41411 , 41413 , 41443 , 41453 , 41467 , 41479 , 41491 , 41507 , 41513 , 41519 , 41521 , 41539 , 41543 , 41549 , 41579 , 41593 , 41597 , 41603 , 41609 , 41611 , 41617 , 41621 , 41627 , 41641 , 41647 , 41651 , 41659 , 41669 , 41681 , 41687 , 41719 , 41729 , 41737 , 41759 , 41761 , 41771 , 41777 , 41801 , 41809 , 41813 , 41843 , 41849 , 41851 , 41863 , 41879 , 41887 , 41893 , 41897 , 41903 , 41911 , 41927 , 41941 , 41947 , 41953 , 41957 , 41959 , 41969 , 41981 , 41983 , 41999 , 42013 , 42017 , 42019 , 42023 , 42043 , 42061 , 42071 , 42073 , 42083 , 42089 , 42101 , 42131 , 42139 , 42157 , 42169 , 42179 , 42181 , 42187 , 42193 , 42197 , 42209 , 42221 , 42223 , 42227 , 42239 , 42257 , 42281 , 42283 , 42293 , 42299 , 42307 , 42323 , 42331 , 42337 , 42349 , 42359 , 42373 , 42379 , 42391 , 42397 , 42403 , 42407 , 42409 , 42433 , 42437 , 42443 , 42451 , 42457 , 42461 , 42463 , 42467 , 42473 , 42487 , 42491 , 42499 , 42509 , 42533 , 42557 , 42569 , 42571 , 42577 , 42589 , 42611 , 42641 , 42643 , 42649 , 42667 , 42677 , 42683 , 42689 , 42697 , 42701 , 42703 , 42709 , 42719 , 42727 , 42737 , 42743 , 42751 , 42767 , 42773 , 42787 , 42793 , 42797 , 42821 , 42829 , 42839 , 42841 , 42853 , 42859 , 42863 , 42899 , 42901 , 42923 , 42929 , 42937 , 42943 , 42953 , 42961 , 42967 , 42979 , 42989 , 43003 , 43013 , 43019 , 43037 , 43049 , 43051 , 43063 , 43067 , 43093 , 43103 , 43117 , 43133 , 43151 , 43159 , 43177 , 43189 , 43201 , 43207 , 43223 , 43237 , 43261 , 43271 , 43283 , 43291 , 43313 , 43319 , 43321 , 43331 , 43391 , 43397 , 43399 , 43403 , 43411 , 43427 , 43441 , 43451 , 43457 , 43481 , 43487 , 43499 , 43517 , 43541 , 43543 , 43573 , 43577 , 43579 , 43591 , 43597 , 43607 , 43609 , 43613 , 43627 , 43633 , 43649 , 43651 , 43661 , 43669 , 43691 , 43711 , 43717 , 43721 , 43753 , 43759 , 43777 , 43781 , 43783 , 43787 , 43789 , 43793 , 43801 , 43853 , 43867 , 43889 , 43891 , 43913 , 43933 , 43943 , 43951 , 43961 , 43963 , 43969 , 43973 , 43987 , 43991 , 43997 , 44017 , 44021 , 44027 , 44029 , 44041 , 44053 , 44059 , 44071 , 44087 , 44089 , 44101 , 44111 , 44119 , 44123 , 44129 , 44131 , 44159 , 44171 , 44179 , 44189 , 44201 , 44203 , 44207 , 44221 , 44249 , 44257 , 44263 , 44267 , 44269 , 44273 , 44279 , 44281 , 44293 , 44351 , 44357 , 44371 , 44381 , 44383 , 44389 , 44417 , 44449 , 44453 , 44483 , 44491 , 44497 , 44501 , 44507 , 44519 , 44531 , 44533 , 44537 , 44543 , 44549 , 44563 , 44579 , 44587 , 44617 , 44621 , 44623 , 44633 , 44641 , 44647 , 44651 , 44657 , 44683 , 44687 , 44699 , 44701 , 44711 , 44729 , 44741 , 44753 , 44771 , 44773 , 44777 , 44789 , 44797 , 44809 , 44819 , 44839 , 44843 , 44851 , 44867 , 44879 , 44887 , 44893 , 44909 , 44917 , 44927 , 44939 , 44953 , 44959 , 44963 , 44971 , 44983 , 44987 , 45007 , 45013 , 45053 , 45061 , 45077 , 45083 , 45119 , 45121 , 45127 , 45131 , 45137 , 45139 , 45161 , 45179 , 45181 , 45191 , 45197 , 45233 , 45247 , 45259 , 45263 , 45281 , 45289 , 45293 , 45307 , 45317 , 45319 , 45329 , 45337 , 45341 , 45343 , 45361 , 45377 , 45389 , 45403 , 45413 , 45427 , 45433 , 45439 , 45481 , 45491 , 45497 , 45503 , 45523 , 45533 , 45541 , 45553 , 45557 , 45569 , 45587 , 45589 , 45599 , 45613 , 45631 , 45641 , 45659 , 45667 , 45673 , 45677 , 45691 , 45697 , 45707 , 45737 , 45751 , 45757 , 45763 , 45767 , 45779 , 45817 , 45821 , 45823 , 45827 , 45833 , 45841 , 45853 , 45863 , 45869 , 45887 , 45893 , 45943 , 45949 , 45953 , 45959 , 45971 , 45979 , 45989 , 46021 , 46027 , 46049 , 46051 , 46061 , 46073 , 46091 , 46093 , 46099 , 46103 , 46133 , 46141 , 46147 , 46153 , 46171 , 46181 , 46183 , 46187 , 46199 , 46219 , 46229 , 46237 , 46261 , 46271 , 46273 , 46279 , 46301 , 46307 , 46309 , 46327 , 46337 , 46349 , 46351 , 46381 , 46399 , 46411 , 46439 , 46441 , 46447 , 46451 , 46457 , 46471 , 46477 , 46489 , 46499 , 46507 , 46511 , 46523 , 46549 , 46559 , 46567 , 46573 , 46589 , 46591 , 46601 , 46619 , 46633 , 46639 , 46643 , 46649 , 46663 , 46679 , 46681 , 46687 , 46691 , 46703 , 46723 , 46727 , 46747 , 46751 , 46757 , 46769 , 46771 , 46807 , 46811 , 46817 , 46819 , 46829 , 46831 , 46853 , 46861 , 46867 , 46877 , 46889 , 46901 , 46919 , 46933 , 46957 , 46993 , 46997 , 47017 , 47041 , 47051 , 47057 , 47059 , 47087 , 47093 , 47111 , 47119 , 47123 , 47129 , 47137 , 47143 , 47147 , 47149 , 47161 , 47189 , 47207 , 47221 , 47237 , 47251 , 47269 , 47279 , 47287 , 47293 , 47297 , 47303 , 47309 , 47317 , 47339 , 47351 , 47353 , 47363 , 47381 , 47387 , 47389 , 47407 , 47417 , 47419 , 47431 , 47441 , 47459 , 47491 , 47497 , 47501 , 47507 , 47513 , 47521 , 47527 , 47533 , 47543 , 47563 , 47569 , 47581 , 47591 , 47599 , 47609 , 47623 , 47629 , 47639 , 47653 , 47657 , 47659 , 47681 , 47699 , 47701 , 47711 , 47713 , 47717 , 47737 , 47741 , 47743 , 47777 , 47779 , 47791 , 47797 , 47807 , 47809 , 47819 , 47837 , 47843 , 47857 , 47869 , 47881 , 47903 , 47911 , 47917 , 47933 , 47939 , 47947 , 47951 , 47963 , 47969 , 47977 , 47981 , 48017 , 48023 , 48029 , 48049 , 48073 , 48079 , 48091 , 48109 , 48119 , 48121 , 48131 , 48157 , 48163 , 48179 , 48187 , 48193 , 48197 , 48221 , 48239 , 48247 , 48259 , 48271 , 48281 , 48299 , 48311 , 48313 , 48337 , 48341 , 48353 , 48371 , 48383 , 48397 , 48407 , 48409 , 48413 , 48437 , 48449 , 48463 , 48473 , 48479 , 48481 , 48487 , 48491 , 48497 , 48523 , 48527 , 48533 , 48539 , 48541 , 48563 , 48571 , 48589 , 48593 , 48611 , 48619 , 48623 , 48647 , 48649 , 48661 , 48673 , 48677 , 48679 , 48731 , 48733 , 48751 , 48757 , 48761 , 48767 , 48779 , 48781 , 48787 , 48799 , 48809 , 48817 , 48821 , 48823 , 48847 , 48857 , 48859 , 48869 , 48871 , 48883 , 48889 , 48907 , 48947 , 48953 , 48973 , 48989 , 48991 , 49003 , 49009 , 49019 , 49031 , 49033 , 49037 , 49043 , 49057 , 49069 , 49081 , 49103 , 49109 , 49117 , 49121 , 49123 , 49139 , 49157 , 49169 , 49171 , 49177 , 49193 , 49199 , 49201 , 49207 , 49211 , 49223 , 49253 , 49261 , 49277 , 49279 , 49297 , 49307 , 49331 , 49333 , 49339 , 49363 , 49367 , 49369 , 49391 , 49393 , 49409 , 49411 , 49417 , 49429 , 49433 , 49451 , 49459 , 49463 , 49477 , 49481 , 49499 , 49523 , 49529 , 49531 , 49537 , 49547 , 49549 , 49559 , 49597 , 49603 , 49613 , 49627 , 49633 , 49639 , 49663 , 49667 , 49669 , 49681 , 49697 , 49711 , 49727 , 49739 , 49741 , 49747 , 49757 , 49783 , 49787 , 49789 , 49801 , 49807 , 49811 , 49823 , 49831 , 49843 , 49853 , 49871 , 49877 , 49891 , 49919 , 49921 , 49927 , 49937 , 49939 , 49943 , 49957 , 49991 , 49993 , 49999 , 50021 , 50023 , 50033 , 50047 , 50051 , 50053 , 50069 , 50077 , 50087 , 50093 , 50101 , 50111 , 50119 , 50123 , 50129 , 50131 , 50147 , 50153 , 50159 , 50177 , 50207 , 50221 , 50227 , 50231 , 50261 , 50263 , 50273 , 50287 , 50291 , 50311 , 50321 , 50329 , 50333 , 50341 , 50359 , 50363 , 50377 , 50383 , 50387 , 50411 , 50417 , 50423 , 50441 , 50459 , 50461 , 50497 , 50503 , 50513 , 50527 , 50539 , 50543 , 50549 , 50551 , 50581 , 50587 , 50591 , 50593 , 50599 , 50627 , 50647 , 50651 , 50671 , 50683 , 50707 , 50723 , 50741 , 50753 , 50767 , 50773 , 50777 , 50789 , 50821 , 50833 , 50839 , 50849 , 50857 , 50867 , 50873 , 50891 , 50893 , 50909 , 50923 , 50929 , 50951 , 50957 , 50969 , 50971 , 50989 , 50993 , 51001 , 51031 , 51043 , 51047 , 51059 , 51061 , 51071 , 51109 , 51131 , 51133 , 51137 , 51151 , 51157 , 51169 , 51193 , 51197 , 51199 , 51203 , 51217 , 51229 , 51239 , 51241 , 51257 , 51263 , 51283 , 51287 , 51307 , 51329 , 51341 , 51343 , 51347 , 51349 , 51361 , 51383 , 51407 , 51413 , 51419 , 51421 , 51427 , 51431 , 51437 , 51439 , 51449 , 51461 , 51473 , 51479 , 51481 , 51487 , 51503 , 51511 , 51517 , 51521 , 51539 , 51551 , 51563 , 51577 , 51581 , 51593 , 51599 , 51607 , 51613 , 51631 , 51637 , 51647 , 51659 , 51673 , 51679 , 51683 , 51691 , 51713 , 51719 , 51721 , 51749 , 51767 , 51769 , 51787 , 51797 , 51803 , 51817 , 51827 , 51829 , 51839 , 51853 , 51859 , 51869 , 51871 , 51893 , 51899 , 51907 , 51913 , 51929 , 51941 , 51949 , 51971 , 51973 , 51977 , 51991 , 52009 , 52021 , 52027 , 52051 , 52057 , 52067 , 52069 , 52081 , 52103 , 52121 , 52127 , 52147 , 52153 , 52163 , 52177 , 52181 , 52183 , 52189 , 52201 , 52223 , 52237 , 52249 , 52253 , 52259 , 52267 , 52289 , 52291 , 52301 , 52313 , 52321 , 52361 , 52363 , 52369 , 52379 , 52387 , 52391 , 52433 , 52453 , 52457 , 52489 , 52501 , 52511 , 52517 , 52529 , 52541 , 52543 , 52553 , 52561 , 52567 , 52571 , 52579 , 52583 , 52609 , 52627 , 52631 , 52639 , 52667 , 52673 , 52691 , 52697 , 52709 , 52711 , 52721 , 52727 , 52733 , 52747 , 52757 , 52769 , 52783 , 52807 , 52813 , 52817 , 52837 , 52859 , 52861 , 52879 , 52883 , 52889 , 52901 , 52903 , 52919 , 52937 , 52951 , 52957 , 52963 , 52967 , 52973 , 52981 , 52999 , 53003 , 53017 , 53047 , 53051 , 53069 , 53077 , 53087 , 53089 , 53093 , 53101 , 53113 , 53117 , 53129 , 53147 , 53149 , 53161 , 53171 , 53173 , 53189 , 53197 , 53201 , 53231 , 53233 , 53239 , 53267 , 53269 , 53279 , 53281 , 53299 , 53309 , 53323 , 53327 , 53353 , 53359 , 53377 , 53381 , 53401 , 53407 , 53411 , 53419 , 53437 , 53441 , 53453 , 53479 , 53503 , 53507 , 53527 , 53549 , 53551 , 53569 , 53591 , 53593 , 53597 , 53609 , 53611 , 53617 , 53623 , 53629 , 53633 , 53639 , 53653 , 53657 , 53681 , 53693 , 53699 , 53717 , 53719 , 53731 , 53759 , 53773 , 53777 , 53783 , 53791 , 53813 , 53819 , 53831 , 53849 , 53857 , 53861 , 53881 , 53887 , 53891 , 53897 , 53899 , 53917 , 53923 , 53927 , 53939 , 53951 , 53959 , 53987 , 53993 , 54001 , 54011 , 54013 , 54037 , 54049 , 54059 , 54083 , 54091 , 54101 , 54121 , 54133 , 54139 , 54151 , 54163 , 54167 , 54181 , 54193 , 54217 , 54251 , 54269 , 54277 , 54287 , 54293 , 54311 , 54319 , 54323 , 54331 , 54347 , 54361 , 54367 , 54371 , 54377 , 54401 , 54403 , 54409 , 54413 , 54419 , 54421 , 54437 , 54443 , 54449 , 54469 , 54493 , 54497 , 54499 , 54503 , 54517 , 54521 , 54539 , 54541 , 54547 , 54559 , 54563 , 54577 , 54581 , 54583 , 54601 , 54617 , 54623 , 54629 , 54631 , 54647 , 54667 , 54673 , 54679 , 54709 , 54713 , 54721 , 54727 , 54751 , 54767 , 54773 , 54779 , 54787 , 54799 , 54829 , 54833 , 54851 , 54869 , 54877 , 54881 , 54907 , 54917 , 54919 , 54941 , 54949 , 54959 , 54973 , 54979 , 54983 , 55001 , 55009 , 55021 , 55049 , 55051 , 55057 , 55061 , 55073 , 55079 , 55103 , 55109 , 55117 , 55127 , 55147 , 55163 , 55171 , 55201 , 55207 , 55213 , 55217 , 55219 , 55229 , 55243 , 55249 , 55259 , 55291 , 55313 , 55331 , 55333 , 55337 , 55339 , 55343 , 55351 , 55373 , 55381 , 55399 , 55411 , 55439 , 55441 , 55457 , 55469 , 55487 , 55501 , 55511 , 55529 , 55541 , 55547 , 55579 , 55589 , 55603 , 55609 , 55619 , 55621 , 55631 , 55633 , 55639 , 55661 , 55663 , 55667 , 55673 , 55681 , 55691 , 55697 , 55711 , 55717 , 55721 , 55733 , 55763 , 55787 , 55793 , 55799 , 55807 , 55813 , 55817 , 55819 , 55823 , 55829 , 55837 , 55843 , 55849 , 55871 , 55889 , 55897 , 55901 , 55903 , 55921 , 55927 , 55931 , 55933 , 55949 , 55967 , 55987 , 55997 , 56003 , 56009 , 56039 , 56041 , 56053 , 56081 , 56087 , 56093 , 56099 , 56101 , 56113 , 56123 , 56131 , 56149 , 56167 , 56171 , 56179 , 56197 , 56207 , 56209 , 56237 , 56239 , 56249 , 56263 , 56267 , 56269 , 56299 , 56311 , 56333 , 56359 , 56369 , 56377 , 56383 , 56393 , 56401 , 56417 , 56431 , 56437 , 56443 , 56453 , 56467 , 56473 , 56477 , 56479 , 56489 , 56501 , 56503 , 56509 , 56519 , 56527 , 56531 , 56533 , 56543 , 56569 , 56591 , 56597 , 56599 , 56611 , 56629 , 56633 , 56659 , 56663 , 56671 , 56681 , 56687 , 56701 , 56711 , 56713 , 56731 , 56737 , 56747 , 56767 , 56773 , 56779 , 56783 , 56807 , 56809 , 56813 , 56821 , 56827 , 56843 , 56857 , 56873 , 56891 , 56893 , 56897 , 56909 , 56911 , 56921 , 56923 , 56929 , 56941 , 56951 , 56957 , 56963 , 56983 , 56989 , 56993 , 56999 , 57037 , 57041 , 57047 , 57059 , 57073 , 57077 , 57089 , 57097 , 57107 , 57119 , 57131 , 57139 , 57143 , 57149 , 57163 , 57173 , 57179 , 57191 , 57193 , 57203 , 57221 , 57223 , 57241 , 57251 , 57259 , 57269 , 57271 , 57283 , 57287 , 57301 , 57329 , 57331 , 57347 , 57349 , 57367 , 57373 , 57383 , 57389 , 57397 , 57413 , 57427 , 57457 , 57467 , 57487 , 57493 , 57503 , 57527 , 57529 , 57557 , 57559 , 57571 , 57587 , 57593 , 57601 , 57637 , 57641 , 57649 , 57653 , 57667 , 57679 , 57689 , 57697 , 57709 , 57713 , 57719 , 57727 , 57731 , 57737 , 57751 , 57773 , 57781 , 57787 , 57791 , 57793 , 57803 , 57809 , 57829 , 57839 , 57847 , 57853 , 57859 , 57881 , 57899 , 57901 , 57917 , 57923 , 57943 , 57947 , 57973 , 57977 , 57991 , 58013 , 58027 , 58031 , 58043 , 58049 , 58057 , 58061 , 58067 , 58073 , 58099 , 58109 , 58111 , 58129 , 58147 , 58151 , 58153 , 58169 , 58171 , 58189 , 58193 , 58199 , 58207 , 58211 , 58217 , 58229 , 58231 , 58237 , 58243 , 58271 , 58309 , 58313 , 58321 , 58337 , 58363 , 58367 , 58369 , 58379 , 58391 , 58393 , 58403 , 58411 , 58417 , 58427 , 58439 , 58441 , 58451 , 58453 , 58477 , 58481 , 58511 , 58537 , 58543 , 58549 , 58567 , 58573 , 58579 , 58601 , 58603 , 58613 , 58631 , 58657 , 58661 , 58679 , 58687 , 58693 , 58699 , 58711 , 58727 , 58733 , 58741 , 58757 , 58763 , 58771 , 58787 , 58789 , 58831 , 58889 , 58897 , 58901 , 58907 , 58909 , 58913 , 58921 , 58937 , 58943 , 58963 , 58967 , 58979 , 58991 , 58997 , 59009 , 59011 , 59021 , 59023 , 59029 , 59051 , 59053 , 59063 , 59069 , 59077 , 59083 , 59093 , 59107 , 59113 , 59119 , 59123 , 59141 , 59149 , 59159 , 59167 , 59183 , 59197 , 59207 , 59209 , 59219 , 59221 , 59233 , 59239 , 59243 , 59263 , 59273 , 59281 , 59333 , 59341 , 59351 , 59357 , 59359 , 59369 , 59377 , 59387 , 59393 , 59399 , 59407 , 59417 , 59419 , 59441 , 59443 , 59447 , 59453 , 59467 , 59471 , 59473 , 59497 , 59509 , 59513 , 59539 , 59557 , 59561 , 59567 , 59581 , 59611 , 59617 , 59621 , 59627 , 59629 , 59651 , 59659 , 59663 , 59669 , 59671 , 59693 , 59699 , 59707 , 59723 , 59729 , 59743 , 59747 , 59753 , 59771 , 59779 , 59791 , 59797 , 59809 , 59833 , 59863 , 59879 , 59887 , 59921 , 59929 , 59951 , 59957 , 59971 , 59981 , 59999 , 60013 , 60017 , 60029 , 60037 , 60041 , 60077 , 60083 , 60089 , 60091 , 60101 , 60103 , 60107 , 60127 , 60133 , 60139 , 60149 , 60161 , 60167 , 60169 , 60209 , 60217 , 60223 , 60251 , 60257 , 60259 , 60271 , 60289 , 60293 , 60317 , 60331 , 60337 , 60343 , 60353 , 60373 , 60383 , 60397 , 60413 , 60427 , 60443 , 60449 , 60457 , 60493 , 60497 , 60509 , 60521 , 60527 , 60539 , 60589 , 60601 , 60607 , 60611 , 60617 , 60623 , 60631 , 60637 , 60647 , 60649 , 60659 , 60661 , 60679 , 60689 , 60703 , 60719 , 60727 , 60733 , 60737 , 60757 , 60761 , 60763 , 60773 , 60779 , 60793 , 60811 , 60821 , 60859 , 60869 , 60887 , 60889 , 60899 , 60901 , 60913 , 60917 , 60919 , 60923 , 60937 , 60943 , 60953 , 60961 , 61001 , 61007 , 61027 , 61031 , 61043 , 61051 , 61057 , 61091 , 61099 , 61121 , 61129 , 61141 , 61151 , 61153 , 61169 , 61211 , 61223 , 61231 , 61253 , 61261 , 61283 , 61291 , 61297 , 61331 , 61333 , 61339 , 61343 , 61357 , 61363 , 61379 , 61381 , 61403 , 61409 , 61417 , 61441 , 61463 , 61469 , 61471 , 61483 , 61487 , 61493 , 61507 , 61511 , 61519 , 61543 , 61547 , 61553 , 61559 , 61561 , 61583 , 61603 , 61609 , 61613 , 61627 , 61631 , 61637 , 61643 , 61651 , 61657 , 61667 , 61673 , 61681 , 61687 , 61703 , 61717 , 61723 , 61729 , 61751 , 61757 , 61781 , 61813 , 61819 , 61837 , 61843 , 61861 , 61871 , 61879 , 61909 , 61927 , 61933 , 61949 , 61961 , 61967 , 61979 , 61981 , 61987 , 61991 , 62003 , 62011 , 62017 , 62039 , 62047 , 62053 , 62057 , 62071 , 62081 , 62099 , 62119 , 62129 , 62131 , 62137 , 62141 , 62143 , 62171 , 62189 , 62191 , 62201 , 62207 , 62213 , 62219 , 62233 , 62273 , 62297 , 62299 , 62303 , 62311 , 62323 , 62327 , 62347 , 62351 , 62383 , 62401 , 62417 , 62423 , 62459 , 62467 , 62473 , 62477 , 62483 , 62497 , 62501 , 62507 , 62533 , 62539 , 62549 , 62563 , 62581 , 62591 , 62597 , 62603 , 62617 , 62627 , 62633 , 62639 , 62653 , 62659 , 62683 , 62687 , 62701 , 62723 , 62731 , 62743 , 62753 , 62761 , 62773 , 62791 , 62801 , 62819 , 62827 , 62851 , 62861 , 62869 , 62873 , 62897 , 62903 , 62921 , 62927 , 62929 , 62939 , 62969 , 62971 , 62981 , 62983 , 62987 , 62989 , 63029 , 63031 , 63059 , 63067 , 63073 , 63079 , 63097 , 63103 , 63113 , 63127 , 63131 , 63149 , 63179 , 63197 , 63199 , 63211 , 63241 , 63247 , 63277 , 63281 , 63299 , 63311 , 63313 , 63317 , 63331 , 63337 , 63347 , 63353 , 63361 , 63367 , 63377 , 63389 , 63391 , 63397 , 63409 , 63419 , 63421 , 63439 , 63443 , 63463 , 63467 , 63473 , 63487 , 63493 , 63499 , 63521 , 63527 , 63533 , 63541 , 63559 , 63577 , 63587 , 63589 , 63599 , 63601 , 63607 , 63611 , 63617 , 63629 , 63647 , 63649 , 63659 , 63667 , 63671 , 63689 , 63691 , 63697 , 63703 , 63709 , 63719 , 63727 , 63737 , 63743 , 63761 , 63773 , 63781 , 63793 , 63799 , 63803 , 63809 , 63823 , 63839 , 63841 , 63853 , 63857 , 63863 , 63901 , 63907 , 63913 , 63929 , 63949 , 63977 , 63997 , 64007 , 64013 , 64019 , 64033 , 64037 , 64063 , 64067 , 64081 , 64091 , 64109 , 64123 , 64151 , 64153 , 64157 , 64171 , 64187 , 64189 , 64217 , 64223 , 64231 , 64237 , 64271 , 64279 , 64283 , 64301 , 64303 , 64319 , 64327 , 64333 , 64373 , 64381 , 64399 , 64403 , 64433 , 64439 , 64451 , 64453 , 64483 , 64489 , 64499 , 64513 , 64553 , 64567 , 64577 , 64579 , 64591 , 64601 , 64609 , 64613 , 64621 , 64627 , 64633 , 64661 , 64663 , 64667 , 64679 , 64693 , 64709 , 64717 , 64747 , 64763 , 64781 , 64783 , 64793 , 64811 , 64817 , 64849 , 64853 , 64871 , 64877 , 64879 , 64891 , 64901 , 64919 , 64921 , 64927 , 64937 , 64951 , 64969 , 64997 , 65003 , 65011 , 65027 , 65029 , 65033 , 65053 , 65063 , 65071 , 65089 , 65099 , 65101 , 65111 , 65119 , 65123 , 65129 , 65141 , 65147 , 65167 , 65171 , 65173 , 65179 , 65183 , 65203 , 65213 , 65239 , 65257 , 65267 , 65269 , 65287 , 65293 , 65309 , 65323 , 65327 , 65353 , 65357 , 65371 , 65381 , 65393 , 65407 , 65413 , 65419 , 65423 , 65437 , 65447 , 65449 , 65479 , 65497 , 65519 , 65521 , 65537 , 65539 , 65543 , 65551 , 65557 , 65563 , 65579 , 65581 , 65587 , 65599 , 65609 , 65617 , 65629 , 65633 , 65647 , 65651 , 65657 , 65677 , 65687 , 65699 , 65701 , 65707 , 65713 , 65717 , 65719 , 65729 , 65731 , 65761 , 65777 , 65789 , 65809 , 65827 , 65831 , 65837 , 65839 , 65843 , 65851 , 65867 , 65881 , 65899 , 65921 , 65927 , 65929 , 65951 , 65957 , 65963 , 65981 , 65983 , 65993 , 66029 , 66037 , 66041 , 66047 , 66067 , 66071 , 66083 , 66089 , 66103 , 66107 , 66109 , 66137 , 66161 , 66169 , 66173 , 66179 , 66191 , 66221 , 66239 , 66271 , 66293 , 66301 , 66337 , 66343 , 66347 , 66359 , 66361 , 66373 , 66377 , 66383 , 66403 , 66413 , 66431 , 66449 , 66457 , 66463 , 66467 , 66491 , 66499 , 66509 , 66523 , 66529 , 66533 , 66541 , 66553 , 66569 , 66571 , 66587 , 66593 , 66601 , 66617 , 66629 , 66643 , 66653 , 66683 , 66697 , 66701 , 66713 , 66721 , 66733 , 66739 , 66749 , 66751 , 66763 , 66791 , 66797 , 66809 , 66821 , 66841 , 66851 , 66853 , 66863 , 66877 , 66883 , 66889 , 66919 , 66923 , 66931 , 66943 , 66947 , 66949 , 66959 , 66973 , 66977 , 67003 , 67021 , 67033 , 67043 , 67049 , 67057 , 67061 , 67073 , 67079 , 67103 , 67121 , 67129 , 67139 , 67141 , 67153 , 67157 , 67169 , 67181 , 67187 , 67189 , 67211 , 67213 , 67217 , 67219 , 67231 , 67247 , 67261 , 67271 , 67273 , 67289 , 67307 , 67339 , 67343 , 67349 , 67369 , 67391 , 67399 , 67409 , 67411 , 67421 , 67427 , 67429 , 67433 , 67447 , 67453 , 67477 , 67481 , 67489 , 67493 , 67499 , 67511 , 67523 , 67531 , 67537 , 67547 , 67559 , 67567 , 67577 , 67579 , 67589 , 67601 , 67607 , 67619 , 67631 , 67651 , 67679 , 67699 , 67709 , 67723 , 67733 , 67741 , 67751 , 67757 , 67759 , 67763 , 67777 , 67783 , 67789 , 67801 , 67807 , 67819 , 67829 , 67843 , 67853 , 67867 , 67883 , 67891 , 67901 , 67927 , 67931 , 67933 , 67939 , 67943 , 67957 , 67961 , 67967 , 67979 , 67987 , 67993 , 68023 , 68041 , 68053 , 68059 , 68071 , 68087 , 68099 , 68111 , 68113 , 68141 , 68147 , 68161 , 68171 , 68207 , 68209 , 68213 , 68219 , 68227 , 68239 , 68261 , 68279 , 68281 , 68311 , 68329 , 68351 , 68371 , 68389 , 68399 , 68437 , 68443 , 68447 , 68449 , 68473 , 68477 , 68483 , 68489 , 68491 , 68501 , 68507 , 68521 , 68531 , 68539 , 68543 , 68567 , 68581 , 68597 , 68611 , 68633 , 68639 , 68659 , 68669 , 68683 , 68687 , 68699 , 68711 , 68713 , 68729 , 68737 , 68743 , 68749 , 68767 , 68771 , 68777 , 68791 , 68813 , 68819 , 68821 , 68863 , 68879 , 68881 , 68891 , 68897 , 68899 , 68903 , 68909 , 68917 , 68927 , 68947 , 68963 , 68993 , 69001 , 69011 , 69019 , 69029 , 69031 , 69061 , 69067 , 69073 , 69109 , 69119 , 69127 , 69143 , 69149 , 69151 , 69163 , 69191 , 69193 , 69197 , 69203 , 69221 , 69233 , 69239 , 69247 , 69257 , 69259 , 69263 , 69313 , 69317 , 69337 , 69341 , 69371 , 69379 , 69383 , 69389 , 69401 , 69403 , 69427 , 69431 , 69439 , 69457 , 69463 , 69467 , 69473 , 69481 , 69491 , 69493 , 69497 , 69499 , 69539 , 69557 , 69593 , 69623 , 69653 , 69661 , 69677 , 69691 , 69697 , 69709 , 69737 , 69739 , 69761 , 69763 , 69767 , 69779 , 69809 , 69821 , 69827 , 69829 , 69833 , 69847 , 69857 , 69859 , 69877 , 69899 , 69911 , 69929 , 69931 , 69941 , 69959 , 69991 , 69997 , 70001 , 70003 , 70009 , 70019 , 70039 , 70051 , 70061 , 70067 , 70079 , 70099 , 70111 , 70117 , 70121 , 70123 , 70139 , 70141 , 70157 , 70163 , 70177 , 70181 , 70183 , 70199 , 70201 , 70207 , 70223 , 70229 , 70237 , 70241 , 70249 , 70271 , 70289 , 70297 , 70309 , 70313 , 70321 , 70327 , 70351 , 70373 , 70379 , 70381 , 70393 , 70423 , 70429 , 70439 , 70451 , 70457 , 70459 , 70481 , 70487 , 70489 , 70501 , 70507 , 70529 , 70537 , 70549 , 70571 , 70573 , 70583 , 70589 , 70607 , 70619 , 70621 , 70627 , 70639 , 70657 , 70663 , 70667 , 70687 , 70709 , 70717 , 70729 , 70753 , 70769 , 70783 , 70793 , 70823 , 70841 , 70843 , 70849 , 70853 , 70867 , 70877 , 70879 , 70891 , 70901 , 70913 , 70919 , 70921 , 70937 , 70949 , 70951 , 70957 , 70969 , 70979 , 70981 , 70991 , 70997 , 70999 , 71011 , 71023 , 71039 , 71059 , 71069 , 71081 , 71089 , 71119 , 71129 , 71143 , 71147 , 71153 , 71161 , 71167 , 71171 , 71191 , 71209 , 71233 , 71237 , 71249 , 71257 , 71261 , 71263 , 71287 , 71293 , 71317 , 71327 , 71329 , 71333 , 71339 , 71341 , 71347 , 71353 , 71359 , 71363 , 71387 , 71389 , 71399 , 71411 , 71413 , 71419 , 71429 , 71437 , 71443 , 71453 , 71471 , 71473 , 71479 , 71483 , 71503 , 71527 , 71537 , 71549 , 71551 , 71563 , 71569 , 71593 , 71597 , 71633 , 71647 , 71663 , 71671 , 71693 , 71699 , 71707 , 71711 , 71713 , 71719 , 71741 , 71761 , 71777 , 71789 , 71807 , 71809 , 71821 , 71837 , 71843 , 71849 , 71861 , 71867 , 71879 , 71881 , 71887 , 71899 , 71909 , 71917 , 71933 , 71941 , 71947 , 71963 , 71971 , 71983 , 71987 , 71993 , 71999 , 72019 , 72031 , 72043 , 72047 , 72053 , 72073 , 72077 , 72089 , 72091 , 72101 , 72103 , 72109 , 72139 , 72161 , 72167 , 72169 , 72173 , 72211 , 72221 , 72223 , 72227 , 72229 , 72251 , 72253 , 72269 , 72271 , 72277 , 72287 , 72307 , 72313 , 72337 , 72341 , 72353 , 72367 , 72379 , 72383 , 72421 , 72431 , 72461 , 72467 , 72469 , 72481 , 72493 , 72497 , 72503 , 72533 , 72547 , 72551 , 72559 , 72577 , 72613 , 72617 , 72623 , 72643 , 72647 , 72649 , 72661 , 72671 , 72673 , 72679 , 72689 , 72701 , 72707 , 72719 , 72727 , 72733 , 72739 , 72763 , 72767 , 72797 , 72817 , 72823 , 72859 , 72869 , 72871 , 72883 , 72889 , 72893 , 72901 , 72907 , 72911 , 72923 , 72931 , 72937 , 72949 , 72953 , 72959 , 72973 , 72977 , 72997 , 73009 , 73013 , 73019 , 73037 , 73039 , 73043 , 73061 , 73063 , 73079 , 73091 , 73121 , 73127 , 73133 , 73141 , 73181 , 73189 , 73237 , 73243 , 73259 , 73277 , 73291 , 73303 , 73309 , 73327 , 73331 , 73351 , 73361 , 73363 , 73369 , 73379 , 73387 , 73417 , 73421 , 73433 , 73453 , 73459 , 73471 , 73477 , 73483 , 73517 , 73523 , 73529 , 73547 , 73553 , 73561 , 73571 , 73583 , 73589 , 73597 , 73607 , 73609 , 73613 , 73637 , 73643 , 73651 , 73673 , 73679 , 73681 , 73693 , 73699 , 73709 , 73721 , 73727 , 73751 , 73757 , 73771 , 73783 , 73819 , 73823 , 73847 , 73849 , 73859 , 73867 , 73877 , 73883 , 73897 , 73907 , 73939 , 73943 , 73951 , 73961 , 73973 , 73999 , 74017 , 74021 , 74027 , 74047 , 74051 , 74071 , 74077 , 74093 , 74099 , 74101 , 74131 , 74143 , 74149 , 74159 , 74161 , 74167 , 74177 , 74189 , 74197 , 74201 , 74203 , 74209 , 74219 , 74231 , 74257 , 74279 , 74287 , 74293 , 74297 , 74311 , 74317 , 74323 , 74353 , 74357 , 74363 , 74377 , 74381 , 74383 , 74411 , 74413 , 74419 , 74441 , 74449 , 74453 , 74471 , 74489 , 74507 , 74509 , 74521 , 74527 , 74531 , 74551 , 74561 , 74567 , 74573 , 74587 , 74597 , 74609 , 74611 , 74623 , 74653 , 74687 , 74699 , 74707 , 74713 , 74717 , 74719 , 74729 , 74731 , 74747 , 74759 , 74761 , 74771 , 74779 , 74797 , 74821 , 74827 , 74831 , 74843 , 74857 , 74861 , 74869 , 74873 , 74887 , 74891 , 74897 , 74903 , 74923 , 74929 , 74933 , 74941 , 74959 , 75011 , 75013 , 75017 , 75029 , 75037 , 75041 , 75079 , 75083 , 75109 , 75133 , 75149 , 75161 , 75167 , 75169 , 75181 , 75193 , 75209 , 75211 , 75217 , 75223 , 75227 , 75239 , 75253 , 75269 , 75277 , 75289 , 75307 , 75323 , 75329 , 75337 , 75347 , 75353 , 75367 , 75377 , 75389 , 75391 , 75401 , 75403 , 75407 , 75431 , 75437 , 75479 , 75503 , 75511 , 75521 , 75527 , 75533 , 75539 , 75541 , 75553 , 75557 , 75571 , 75577 , 75583 , 75611 , 75617 , 75619 , 75629 , 75641 , 75653 , 75659 , 75679 , 75683 , 75689 , 75703 , 75707 , 75709 , 75721 , 75731 , 75743 , 75767 , 75773 , 75781 , 75787 , 75793 , 75797 , 75821 , 75833 , 75853 , 75869 , 75883 , 75913 , 75931 , 75937 , 75941 , 75967 , 75979 , 75983 , 75989 , 75991 , 75997 , 76001 , 76003 , 76031 , 76039 , 76079 , 76081 , 76091 , 76099 , 76103 , 76123 , 76129 , 76147 , 76157 , 76159 , 76163 , 76207 , 76213 , 76231 , 76243 , 76249 , 76253 , 76259 , 76261 , 76283 , 76289 , 76303 , 76333 , 76343 , 76367 , 76369 , 76379 , 76387 , 76403 , 76421 , 76423 , 76441 , 76463 , 76471 , 76481 , 76487 , 76493 , 76507 , 76511 , 76519 , 76537 , 76541 , 76543 , 76561 , 76579 , 76597 , 76603 , 76607 , 76631 , 76649 , 76651 , 76667 , 76673 , 76679 , 76697 , 76717 , 76733 , 76753 , 76757 , 76771 , 76777 , 76781 , 76801 , 76819 , 76829 , 76831 , 76837 , 76847 , 76871 , 76873 , 76883 , 76907 , 76913 , 76919 , 76943 , 76949 , 76961 , 76963 , 76991 , 77003 , 77017 , 77023 , 77029 , 77041 , 77047 , 77069 , 77081 , 77093 , 77101 , 77137 , 77141 , 77153 , 77167 , 77171 , 77191 , 77201 , 77213 , 77237 , 77239 , 77243 , 77249 , 77261 , 77263 , 77267 , 77269 , 77279 , 77291 , 77317 , 77323 , 77339 , 77347 , 77351 , 77359 , 77369 , 77377 , 77383 , 77417 , 77419 , 77431 , 77447 , 77471 , 77477 , 77479 , 77489 , 77491 , 77509 , 77513 , 77521 , 77527 , 77543 , 77549 , 77551 , 77557 , 77563 , 77569 , 77573 , 77587 , 77591 , 77611 , 77617 , 77621 , 77641 , 77647 , 77659 , 77681 , 77687 , 77689 , 77699 , 77711 , 77713 , 77719 , 77723 , 77731 , 77743 , 77747 , 77761 , 77773 , 77783 , 77797 , 77801 , 77813 , 77839 , 77849 , 77863 , 77867 , 77893 , 77899 , 77929 , 77933 , 77951 , 77969 , 77977 , 77983 , 77999 , 78007 , 78017 , 78031 , 78041 , 78049 , 78059 , 78079 , 78101 , 78121 , 78137 , 78139 , 78157 , 78163 , 78167 , 78173 , 78179 , 78191 , 78193 , 78203 , 78229 , 78233 , 78241 , 78259 , 78277 , 78283 , 78301 , 78307 , 78311 , 78317 , 78341 , 78347 , 78367 , 78401 , 78427 , 78437 , 78439 , 78467 , 78479 , 78487 , 78497 , 78509 , 78511 , 78517 , 78539 , 78541 , 78553 , 78569 , 78571 , 78577 , 78583 , 78593 , 78607 , 78623 , 78643 , 78649 , 78653 , 78691 , 78697 , 78707 , 78713 , 78721 , 78737 , 78779 , 78781 , 78787 , 78791 , 78797 , 78803 , 78809 , 78823 , 78839 , 78853 , 78857 , 78877 , 78887 , 78889 , 78893 , 78901 , 78919 , 78929 , 78941 , 78977 , 78979 , 78989 , 79031 , 79039 , 79043 , 79063 , 79087 , 79103 , 79111 , 79133 , 79139 , 79147 , 79151 , 79153 , 79159 , 79181 , 79187 , 79193 , 79201 , 79229 , 79231 , 79241 , 79259 , 79273 , 79279 , 79283 , 79301 , 79309 , 79319 , 79333 , 79337 , 79349 , 79357 , 79367 , 79379 , 79393 , 79397 , 79399 , 79411 , 79423 , 79427 , 79433 , 79451 , 79481 , 79493 , 79531 , 79537 , 79549 , 79559 , 79561 , 79579 , 79589 , 79601 , 79609 , 79613 , 79621 , 79627 , 79631 , 79633 , 79657 , 79669 , 79687 , 79691 , 79693 , 79697 , 79699 , 79757 , 79769 , 79777 , 79801 , 79811 , 79813 , 79817 , 79823 , 79829 , 79841 , 79843 , 79847 , 79861 , 79867 , 79873 , 79889 , 79901 , 79903 , 79907 , 79939 , 79943 , 79967 , 79973 , 79979 , 79987 , 79997 , 79999 , 80021 , 80039 , 80051 , 80071 , 80077 , 80107 , 80111 , 80141 , 80147 , 80149 , 80153 , 80167 , 80173 , 80177 , 80191 , 80207 , 80209 , 80221 , 80231 , 80233 , 80239 , 80251 , 80263 , 80273 , 80279 , 80287 , 80309 , 80317 , 80329 , 80341 , 80347 , 80363 , 80369 , 80387 , 80407 , 80429 , 80447 , 80449 , 80471 , 80473 , 80489 , 80491 , 80513 , 80527 , 80537 , 80557 , 80567 , 80599 , 80603 , 80611 , 80621 , 80627 , 80629 , 80651 , 80657 , 80669 , 80671 , 80677 , 80681 , 80683 , 80687 , 80701 , 80713 , 80737 , 80747 , 80749 , 80761 , 80777 , 80779 , 80783 , 80789 , 80803 , 80809 , 80819 , 80831 , 80833 , 80849 , 80863 , 80897 , 80909 , 80911 , 80917 , 80923 , 80929 , 80933 , 80953 , 80963 , 80989 , 81001 , 81013 , 81017 , 81019 , 81023 , 81031 , 81041 , 81043 , 81047 , 81049 , 81071 , 81077 , 81083 , 81097 , 81101 , 81119 , 81131 , 81157 , 81163 , 81173 , 81181 , 81197 , 81199 , 81203 , 81223 , 81233 , 81239 , 81281 , 81283 , 81293 , 81299 , 81307 , 81331 , 81343 , 81349 , 81353 , 81359 , 81371 , 81373 , 81401 , 81409 , 81421 , 81439 , 81457 , 81463 , 81509 , 81517 , 81527 , 81533 , 81547 , 81551 , 81553 , 81559 , 81563 , 81569 , 81611 , 81619 , 81629 , 81637 , 81647 , 81649 , 81667 , 81671 , 81677 , 81689 , 81701 , 81703 , 81707 , 81727 , 81737 , 81749 , 81761 , 81769 , 81773 , 81799 , 81817 , 81839 , 81847 , 81853 , 81869 , 81883 , 81899 , 81901 , 81919 , 81929 , 81931 , 81937 , 81943 , 81953 , 81967 , 81971 , 81973 , 82003 , 82007 , 82009 , 82013 , 82021 , 82031 , 82037 , 82039 , 82051 , 82067 , 82073 , 82129 , 82139 , 82141 , 82153 , 82163 , 82171 , 82183 , 82189 , 82193 , 82207 , 82217 , 82219 , 82223 , 82231 , 82237 , 82241 , 82261 , 82267 , 82279 , 82301 , 82307 , 82339 , 82349 , 82351 , 82361 , 82373 , 82387 , 82393 , 82421 , 82457 , 82463 , 82469 , 82471 , 82483 , 82487 , 82493 , 82499 , 82507 , 82529 , 82531 , 82549 , 82559 , 82561 , 82567 , 82571 , 82591 , 82601 , 82609 , 82613 , 82619 , 82633 , 82651 , 82657 , 82699 , 82721 , 82723 , 82727 , 82729 , 82757 , 82759 , 82763 , 82781 , 82787 , 82793 , 82799 , 82811 , 82813 , 82837 , 82847 , 82883 , 82889 , 82891 , 82903 , 82913 , 82939 , 82963 , 82981 , 82997 , 83003 , 83009 , 83023 , 83047 , 83059 , 83063 , 83071 , 83077 , 83089 , 83093 , 83101 , 83117 , 83137 , 83177 , 83203 , 83207 , 83219 , 83221 , 83227 , 83231 , 83233 , 83243 , 83257 , 83267 , 83269 , 83273 , 83299 , 83311 , 83339 , 83341 , 83357 , 83383 , 83389 , 83399 , 83401 , 83407 , 83417 , 83423 , 83431 , 83437 , 83443 , 83449 , 83459 , 83471 , 83477 , 83497 , 83537 , 83557 , 83561 , 83563 , 83579 , 83591 , 83597 , 83609 , 83617 , 83621 , 83639 , 83641 , 83653 , 83663 , 83689 , 83701 , 83717 , 83719 , 83737 , 83761 , 83773 , 83777 , 83791 , 83813 , 83833 , 83843 , 83857 , 83869 , 83873 , 83891 , 83903 , 83911 , 83921 , 83933 , 83939 , 83969 , 83983 , 83987 , 84011 , 84017 , 84047 , 84053 , 84059 , 84061 , 84067 , 84089 , 84121 , 84127 , 84131 , 84137 , 84143 , 84163 , 84179 , 84181 , 84191 , 84199 , 84211 , 84221 , 84223 , 84229 , 84239 , 84247 , 84263 , 84299 , 84307 , 84313 , 84317 , 84319 , 84347 , 84349 , 84377 , 84389 , 84391 , 84401 , 84407 , 84421 , 84431 , 84437 , 84443 , 84449 , 84457 , 84463 , 84467 , 84481 , 84499 , 84503 , 84509 , 84521 , 84523 , 84533 , 84551 , 84559 , 84589 , 84629 , 84631 , 84649 , 84653 , 84659 , 84673 , 84691 , 84697 , 84701 , 84713 , 84719 , 84731 , 84737 , 84751 , 84761 , 84787 , 84793 , 84809 , 84811 , 84827 , 84857 , 84859 , 84869 , 84871 , 84913 , 84919 , 84947 , 84961 , 84967 , 84977 , 84979 , 84991 , 85009 , 85021 , 85027 , 85037 , 85049 , 85061 , 85081 , 85087 , 85091 , 85093 , 85103 , 85109 , 85121 , 85133 , 85147 , 85159 , 85193 , 85199 , 85201 , 85213 , 85223 , 85229 , 85237 , 85243 , 85247 , 85259 , 85297 , 85303 , 85313 , 85331 , 85333 , 85361 , 85363 , 85369 , 85381 , 85411 , 85427 , 85429 , 85439 , 85447 , 85451 , 85453 , 85469 , 85487 , 85513 , 85517 , 85523 , 85531 , 85549 , 85571 , 85577 , 85597 , 85601 , 85607 , 85619 , 85621 , 85627 , 85639 , 85643 , 85661 , 85667 , 85669 , 85691 , 85703 , 85711 , 85717 , 85733 , 85751 , 85781 , 85793 , 85817 , 85819 , 85829 , 85831 , 85837 , 85843 , 85847 , 85853 , 85889 , 85903 , 85909 , 85931 , 85933 , 85991 , 85999 , 86011 , 86017 , 86027 , 86029 , 86069 , 86077 , 86083 , 86111 , 86113 , 86117 , 86131 , 86137 , 86143 , 86161 , 86171 , 86179 , 86183 , 86197 , 86201 , 86209 , 86239 , 86243 , 86249 , 86257 , 86263 , 86269 , 86287 , 86291 , 86293 , 86297 , 86311 , 86323 , 86341 , 86351 , 86353 , 86357 , 86369 , 86371 , 86381 , 86389 , 86399 , 86413 , 86423 , 86441 , 86453 , 86461 , 86467 , 86477 , 86491 , 86501 , 86509 , 86531 , 86533 , 86539 , 86561 , 86573 , 86579 , 86587 , 86599 , 86627 , 86629 , 86677 , 86689 , 86693 , 86711 , 86719 , 86729 , 86743 , 86753 , 86767 , 86771 , 86783 , 86813 , 86837 , 86843 , 86851 , 86857 , 86861 , 86869 , 86923 , 86927 , 86929 , 86939 , 86951 , 86959 , 86969 , 86981 , 86993 , 87011 , 87013 , 87037 , 87041 , 87049 , 87071 , 87083 , 87103 , 87107 , 87119 , 87121 , 87133 , 87149 , 87151 , 87179 , 87181 , 87187 , 87211 , 87221 , 87223 , 87251 , 87253 , 87257 , 87277 , 87281 , 87293 , 87299 , 87313 , 87317 , 87323 , 87337 , 87359 , 87383 , 87403 , 87407 , 87421 , 87427 , 87433 , 87443 , 87473 , 87481 , 87491 , 87509 , 87511 , 87517 , 87523 , 87539 , 87541 , 87547 , 87553 , 87557 , 87559 , 87583 , 87587 , 87589 , 87613 , 87623 , 87629 , 87631 , 87641 , 87643 , 87649 , 87671 , 87679 , 87683 , 87691 , 87697 , 87701 , 87719 , 87721 , 87739 , 87743 , 87751 , 87767 , 87793 , 87797 , 87803 , 87811 , 87833 , 87853 , 87869 , 87877 , 87881 , 87887 , 87911 , 87917 , 87931 , 87943 , 87959 , 87961 , 87973 , 87977 , 87991 , 88001 , 88003 , 88007 , 88019 , 88037 , 88069 , 88079 , 88093 , 88117 , 88129 , 88169 , 88177 , 88211 , 88223 , 88237 , 88241 , 88259 , 88261 , 88289 , 88301 , 88321 , 88327 , 88337 , 88339 , 88379 , 88397 , 88411 , 88423 , 88427 , 88463 , 88469 , 88471 , 88493 , 88499 , 88513 , 88523 , 88547 , 88589 , 88591 , 88607 , 88609 , 88643 , 88651 , 88657 , 88661 , 88663 , 88667 , 88681 , 88721 , 88729 , 88741 , 88747 , 88771 , 88789 , 88793 , 88799 , 88801 , 88807 , 88811 , 88813 , 88817 , 88819 , 88843 , 88853 , 88861 , 88867 , 88873 , 88883 , 88897 , 88903 , 88919 , 88937 , 88951 , 88969 , 88993 , 88997 , 89003 , 89009 , 89017 , 89021 , 89041 , 89051 , 89057 , 89069 , 89071 , 89083 , 89087 , 89101 , 89107 , 89113 , 89119 , 89123 , 89137 , 89153 , 89189 , 89203 , 89209 , 89213 , 89227 , 89231 , 89237 , 89261 , 89269 , 89273 , 89293 , 89303 , 89317 , 89329 , 89363 , 89371 , 89381 , 89387 , 89393 , 89399 , 89413 , 89417 , 89431 , 89443 , 89449 , 89459 , 89477 , 89491 , 89501 , 89513 , 89519 , 89521 , 89527 , 89533 , 89561 , 89563 , 89567 , 89591 , 89597 , 89599 , 89603 , 89611 , 89627 , 89633 , 89653 , 89657 , 89659 , 89669 , 89671 , 89681 , 89689 , 89753 , 89759 , 89767 , 89779 , 89783 , 89797 , 89809 , 89819 , 89821 , 89833 , 89839 , 89849 , 89867 , 89891 , 89897 , 89899 , 89909 , 89917 , 89923 , 89939 , 89959 , 89963 , 89977 , 89983 , 89989 , 90001 , 90007 , 90011 , 90017 , 90019 , 90023 , 90031 , 90053 , 90059 , 90067 , 90071 , 90073 , 90089 , 90107 , 90121 , 90127 , 90149 , 90163 , 90173 , 90187 , 90191 , 90197 , 90199 , 90203 , 90217 , 90227 , 90239 , 90247 , 90263 , 90271 , 90281 , 90289 , 90313 , 90353 , 90359 , 90371 , 90373 , 90379 , 90397 , 90401 , 90403 , 90407 , 90437 , 90439 , 90469 , 90473 , 90481 , 90499 , 90511 , 90523 , 90527 , 90529 , 90533 , 90547 , 90583 , 90599 , 90617 , 90619 , 90631 , 90641 , 90647 , 90659 , 90677 , 90679 , 90697 , 90703 , 90709 , 90731 , 90749 , 90787 , 90793 , 90803 , 90821 , 90823 , 90833 , 90841 , 90847 , 90863 , 90887 , 90901 , 90907 , 90911 , 90917 , 90931 , 90947 , 90971 , 90977 , 90989 , 90997 , 91009 , 91019 , 91033 , 91079 , 91081 , 91097 , 91099 , 91121 , 91127 , 91129 , 91139 , 91141 , 91151 , 91153 , 91159 , 91163 , 91183 , 91193 , 91199 , 91229 , 91237 , 91243 , 91249 , 91253 , 91283 , 91291 , 91297 , 91303 , 91309 , 91331 , 91367 , 91369 , 91373 , 91381 , 91387 , 91393 , 91397 , 91411 , 91423 , 91433 , 91453 , 91457 , 91459 , 91463 , 91493 , 91499 , 91513 , 91529 , 91541 , 91571 , 91573 , 91577 , 91583 , 91591 , 91621 , 91631 , 91639 , 91673 , 91691 , 91703 , 91711 , 91733 , 91753 , 91757 , 91771 , 91781 , 91801 , 91807 , 91811 , 91813 , 91823 , 91837 , 91841 , 91867 , 91873 , 91909 , 91921 , 91939 , 91943 , 91951 , 91957 , 91961 , 91967 , 91969 , 91997 , 92003 , 92009 , 92033 , 92041 , 92051 , 92077 , 92083 , 92107 , 92111 , 92119 , 92143 , 92153 , 92173 , 92177 , 92179 , 92189 , 92203 , 92219 , 92221 , 92227 , 92233 , 92237 , 92243 , 92251 , 92269 , 92297 , 92311 , 92317 , 92333 , 92347 , 92353 , 92357 , 92363 , 92369 , 92377 , 92381 , 92383 , 92387 , 92399 , 92401 , 92413 , 92419 , 92431 , 92459 , 92461 , 92467 , 92479 , 92489 , 92503 , 92507 , 92551 , 92557 , 92567 , 92569 , 92581 , 92593 , 92623 , 92627 , 92639 , 92641 , 92647 , 92657 , 92669 , 92671 , 92681 , 92683 , 92693 , 92699 , 92707 , 92717 , 92723 , 92737 , 92753 , 92761 , 92767 , 92779 , 92789 , 92791 , 92801 , 92809 , 92821 , 92831 , 92849 , 92857 , 92861 , 92863 , 92867 , 92893 , 92899 , 92921 , 92927 , 92941 , 92951 , 92957 , 92959 , 92987 , 92993 , 93001 , 93047 , 93053 , 93059 , 93077 , 93083 , 93089 , 93097 , 93103 , 93113 , 93131 , 93133 , 93139 , 93151 , 93169 , 93179 , 93187 , 93199 , 93229 , 93239 , 93241 , 93251 , 93253 , 93257 , 93263 , 93281 , 93283 , 93287 , 93307 , 93319 , 93323 , 93329 , 93337 , 93371 , 93377 , 93383 , 93407 , 93419 , 93427 , 93463 , 93479 , 93481 , 93487 , 93491 , 93493 , 93497 , 93503 , 93523 , 93529 , 93553 , 93557 , 93559 , 93563 , 93581 , 93601 , 93607 , 93629 , 93637 , 93683 , 93701 , 93703 , 93719 , 93739 , 93761 , 93763 , 93787 , 93809 , 93811 , 93827 , 93851 , 93871 , 93887 , 93889 , 93893 , 93901 , 93911 , 93913 , 93923 , 93937 , 93941 , 93949 , 93967 , 93971 , 93979 , 93983 , 93997 , 94007 , 94009 , 94033 , 94049 , 94057 , 94063 , 94079 , 94099 , 94109 , 94111 , 94117 , 94121 , 94151 , 94153 , 94169 , 94201 , 94207 , 94219 , 94229 , 94253 , 94261 , 94273 , 94291 , 94307 , 94309 , 94321 , 94327 , 94331 , 94343 , 94349 , 94351 , 94379 , 94397 , 94399 , 94421 , 94427 , 94433 , 94439 , 94441 , 94447 , 94463 , 94477 , 94483 , 94513 , 94529 , 94531 , 94541 , 94543 , 94547 , 94559 , 94561 , 94573 , 94583 , 94597 , 94603 , 94613 , 94621 , 94649 , 94651 , 94687 , 94693 , 94709 , 94723 , 94727 , 94747 , 94771 , 94777 , 94781 , 94789 , 94793 , 94811 , 94819 , 94823 , 94837 , 94841 , 94847 , 94849 , 94873 , 94889 , 94903 , 94907 , 94933 , 94949 , 94951 , 94961 , 94993 , 94999 , 95003 , 95009 , 95021 , 95027 , 95063 , 95071 , 95083 , 95087 , 95089 , 95093 , 95101 , 95107 , 95111 , 95131 , 95143 , 95153 , 95177 , 95189 , 95191 , 95203 , 95213 , 95219 , 95231 , 95233 , 95239 , 95257 , 95261 , 95267 , 95273 , 95279 , 95287 , 95311 , 95317 , 95327 , 95339 , 95369 , 95383 , 95393 , 95401 , 95413 , 95419 , 95429 , 95441 , 95443 , 95461 , 95467 , 95471 , 95479 , 95483 , 95507 , 95527 , 95531 , 95539 , 95549 , 95561 , 95569 , 95581 , 95597 , 95603 , 95617 , 95621 , 95629 , 95633 , 95651 , 95701 , 95707 , 95713 , 95717 , 95723 , 95731 , 95737 , 95747 , 95773 , 95783 , 95789 , 95791 , 95801 , 95803 , 95813 , 95819 , 95857 , 95869 , 95873 , 95881 , 95891 , 95911 , 95917 , 95923 , 95929 , 95947 , 95957 , 95959 , 95971 , 95987 , 95989 , 96001 , 96013 , 96017 , 96043 , 96053 , 96059 , 96079 , 96097 , 96137 , 96149 , 96157 , 96167 , 96179 , 96181 , 96199 , 96211 , 96221 , 96223 , 96233 , 96259 , 96263 , 96269 , 96281 , 96289 , 96293 , 96323 , 96329 , 96331 , 96337 , 96353 , 96377 , 96401 , 96419 , 96431 , 96443 , 96451 , 96457 , 96461 , 96469 , 96479 , 96487 , 96493 , 96497 , 96517 , 96527 , 96553 , 96557 , 96581 , 96587 , 96589 , 96601 , 96643 , 96661 , 96667 , 96671 , 96697 , 96703 , 96731 , 96737 , 96739 , 96749 , 96757 , 96763 , 96769 , 96779 , 96787 , 96797 , 96799 , 96821 , 96823 , 96827 , 96847 , 96851 , 96857 , 96893 , 96907 , 96911 , 96931 , 96953 , 96959 , 96973 , 96979 , 96989 , 96997 , 97001 , 97003 , 97007 , 97021 , 97039 , 97073 , 97081 , 97103 , 97117 , 97127 , 97151 , 97157 , 97159 , 97169 , 97171 , 97177 , 97187 , 97213 , 97231 , 97241 , 97259 , 97283 , 97301 , 97303 , 97327 , 97367 , 97369 , 97373 , 97379 , 97381 , 97387 , 97397 , 97423 , 97429 , 97441 , 97453 , 97459 , 97463 , 97499 , 97501 , 97511 , 97523 , 97547 , 97549 , 97553 , 97561 , 97571 , 97577 , 97579 , 97583 , 97607 , 97609 , 97613 , 97649 , 97651 , 97673 , 97687 , 97711 , 97729 , 97771 , 97777 , 97787 , 97789 , 97813 , 97829 , 97841 , 97843 , 97847 , 97849 , 97859 , 97861 , 97871 , 97879 , 97883 , 97919 , 97927 , 97931 , 97943 , 97961 , 97967 , 97973 , 97987 , 98009 , 98011 , 98017 , 98041 , 98047 , 98057 , 98081 , 98101 , 98123 , 98129 , 98143 , 98179 , 98207 , 98213 , 98221 , 98227 , 98251 , 98257 , 98269 , 98297 , 98299 , 98317 , 98321 , 98323 , 98327 , 98347 , 98369 , 98377 , 98387 , 98389 , 98407 , 98411 , 98419 , 98429 , 98443 , 98453 , 98459 , 98467 , 98473 , 98479 , 98491 , 98507 , 98519 , 98533 , 98543 , 98561 , 98563 , 98573 , 98597 , 98621 , 98627 , 98639 , 98641 , 98663 , 98669 , 98689 , 98711 , 98713 , 98717 , 98729 , 98731 , 98737 , 98773 , 98779 , 98801 , 98807 , 98809 , 98837 , 98849 , 98867 , 98869 , 98873 , 98887 , 98893 , 98897 , 98899 , 98909 , 98911 , 98927 , 98929 , 98939 , 98947 , 98953 , 98963 , 98981 , 98993 , 98999 , 99013 , 99017 , 99023 , 99041 , 99053 , 99079 , 99083 , 99089 , 99103 , 99109 , 99119 , 99131 , 99133 , 99137 , 99139 , 99149 , 99173 , 99181 , 99191 , 99223 , 99233 , 99241 , 99251 , 99257 , 99259 , 99277 , 99289 , 99317 , 99347 , 99349 , 99367 , 99371 , 99377 , 99391 , 99397 , 99401 , 99409 , 99431 , 99439 , 99469 , 99487 , 99497 , 99523 , 99527 , 99529 , 99551 , 99559 , 99563 , 99571 , 99577 , 99581 , 99607 , 99611 , 99623 , 99643 , 99661 , 99667 , 99679 , 99689 , 99707 , 99709 , 99713 , 99719 , 99721 , 99733 , 99761 , 99767 , 99787 , 99793 , 99809 , 99817 , 99823 , 99829 , 99833 , 99839 , 99859 , 99871 , 99877 , 99881 , 99901 , 99907 , 99923 , 99929 , 99961 , 99971 , 99989 , 99991 , 100003 ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> index = bisect . bisect_left ( l , n ) <NEWLINE> ans = l [ index ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_g = A [ 1 ] <NEWLINE> dp_k = A [ 0 ] <NEWLINE> dp = [ 0 , max ( dp_g , dp_k ) ] <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> dp_g = max ( dp_k , dp_g ) + A [ i ] <NEWLINE> dp_k += A [ i - 1 ] <NEWLINE> dp . append ( max ( dp_g , dp_k ) ) <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> dp . append ( max ( dp [ i - 1 ] , dp [ i - 2 ] + A [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= l [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> A = [ 0 ] * N <NEWLINE> A [ 0 ] = 1 <NEWLINE> result = [ ] <NEWLINE> <NL> <NL> def dfs ( d , n , A ) : <NEWLINE> <COMMENT> <NL> <INDENT> if d > N or n > M : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> A [ d - 1 ] = n <NEWLINE> <NL> <COMMENT> <NL> if d == N : <NEWLINE> <INDENT> total = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ai = abcd [ i ] [ 0 ] <NEWLINE> bi = abcd [ i ] [ 1 ] <NEWLINE> ci = abcd [ i ] [ 2 ] <NEWLINE> di = abcd [ i ] [ 3 ] <NEWLINE> if A [ bi - 1 ] - A [ ai - 1 ] == ci : <NEWLINE> <INDENT> total += di <NEWLINE> <DEDENT> <DEDENT> result . append ( total ) <NEWLINE> <NL> <DEDENT> dfs ( d + 1 , n , A ) <NEWLINE> dfs ( d , n + 1 , A ) <NEWLINE> <NL> <NL> <DEDENT> dfs ( 2 , 1 , A ) <NEWLINE> <NL> print ( max ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ans = 1 <NEWLINE> if As . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for A in range ( N ) : <NEWLINE> <INDENT> if Ans > 10 ** 18 : <NEWLINE> <INDENT> Ans = - 1 <NEWLINE> print ( Ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NewAns = Ans * As [ A ] <NEWLINE> Ans = NewAns <NEWLINE> <DEDENT> <DEDENT> if Ans > 10 ** 18 : <NEWLINE> <INDENT> Ans = - 1 <NEWLINE> <NL> <DEDENT> print ( Ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( a , n + 1 ) : <NEWLINE> <INDENT> if n > a * b : <NEWLINE> <INDENT> if a == b : count += 1 <NEWLINE> else : count += 2 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> tatemono = [ <NEWLINE> [ [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] ] , <NEWLINE> [ [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] ] , <NEWLINE> [ [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] ] , <NEWLINE> [ [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] , [ 0 for i in range ( 10 ) ] ] ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> tatemono [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , tatemono [ i ] [ j ] ) ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , tatemono [ 3 ] [ i ] ) ) ) ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> if 1 <= num <= 2 * 10 ** 5 : <NEWLINE> <INDENT> lst = [ input ( ) for i in range ( num ) ] <NEWLINE> print ( len ( set ( lst ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> while A [ i ] + B [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * 100000 <NEWLINE> for i in A : <NEWLINE> <INDENT> a [ i - 1 ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> <NL> q = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ B - 1 ] >= 1 : <NEWLINE> <INDENT> ans = ans - B * a [ B - 1 ] + C * a [ B - 1 ] <NEWLINE> a [ C - 1 ] += a [ B - 1 ] <NEWLINE> a [ B - 1 ] = 0 <NEWLINE> <DEDENT> q . append ( ans ) <NEWLINE> <NL> <DEDENT> for i in q : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum_ = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum_ += math . gcd ( x , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = 0 <NEWLINE> m = 10 ** 9 <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if m >= a : <NEWLINE> <INDENT> m = a <NEWLINE> <DEDENT> if M < a : <NEWLINE> <INDENT> M = a <NEWLINE> c = b + 1 <NEWLINE> <DEDENT> <DEDENT> ans = c + M - 1 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> <NL> <COMMENT> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> s += gcd ( a , a , b ) * 6 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> s += gcd ( a , b , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( p ) for p in input ( ) . split ( ) ] <NEWLINE> <NL> is_exit = [ False ] * 101 <NEWLINE> <NL> for p in P : <NEWLINE> <INDENT> is_exit [ p ] = True <NEWLINE> <NL> <DEDENT> if not is_exit [ X ] : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = X - 1 <NEWLINE> r = X + 1 <NEWLINE> while True : <NEWLINE> <INDENT> if 1 <= l : <NEWLINE> <INDENT> if not is_exit [ l ] : <NEWLINE> <INDENT> print ( l ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if r <= 100 : <NEWLINE> <INDENT> if not is_exit [ r ] : <NEWLINE> <INDENT> print ( r ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l -= 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in List : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for x in List : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import deque <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> d = deque ( A ) <NEWLINE> import time <NEWLINE> l = [ ] <NEWLINE> if K % 2 == 0 or ( K % 2 == 1 and A [ 0 ] >= 0 ) : <NEWLINE> <INDENT> for i in range ( K // 2 ) : <NEWLINE> <INDENT> if d [ 0 ] * d [ 1 ] > d [ - 1 ] * d [ - 2 ] and ( i == K // 2 - 1 or ( len ( d ) > 2 and d [ 2 ] > 0 ) ) : <NEWLINE> <INDENT> l . append ( d . popleft ( ) ) <NEWLINE> l . append ( d . popleft ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( d . pop ( ) ) <NEWLINE> l . append ( d . pop ( ) ) <NEWLINE> <DEDENT> <DEDENT> if K % 2 == 1 : <NEWLINE> <INDENT> l . append ( d [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> l . append ( d . popleft ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ - 1 ] * ( n + 1 ) <NEWLINE> tmp = [ ] <NEWLINE> pos = 1 <NEWLINE> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if l [ pos ] != - 1 : <NEWLINE> <INDENT> t = cnt - l [ pos ] <NEWLINE> if k < cnt : <NEWLINE> <INDENT> print ( tmp [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tmp [ l [ pos ] + ( k - cnt ) % t ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> l [ pos ] = cnt <NEWLINE> cnt += 1 <NEWLINE> tmp . append ( pos ) <NEWLINE> pos = arr [ pos - 1 ] <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> lis = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lis . append ( [ a , b ] ) <NEWLINE> <DEDENT> for i in lis : <NEWLINE> <INDENT> for j in range ( i [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * i [ 1 ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * a <NEWLINE> for i in b : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in c : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis_score = [ ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> if i >= k : <NEWLINE> <INDENT> lis_edge_right = lis [ i ] <NEWLINE> lis_edge_left = lis [ i - k ] <NEWLINE> <NL> if lis_edge_right > lis_edge_left : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from scipy . special import comb <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N = z ( ) <NEWLINE> S = S ( ) <NEWLINE> after_lis = [ set ( ) for _ in range ( N + 1 ) ] <NEWLINE> i = N - 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> after_lis [ i ] = ( after_lis [ i ] | after_lis [ i + 1 ] ) <NEWLINE> after_lis [ i ] . add ( int ( s ) ) <NEWLINE> i -= 1 <NEWLINE> <NL> <DEDENT> left_index = { } <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s not in left_index : <NEWLINE> <INDENT> left_index [ s ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans_lis = np . zeros ( [ 10 , 10 , 10 ] , dtype = np . int32 ) <NEWLINE> <NL> for char in left_index : <NEWLINE> <INDENT> s_100 = int ( char ) <NEWLINE> for i_10 in range ( left_index [ char ] + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> s_10 = int ( S [ i_10 ] ) <NEWLINE> ans_lis [ s_100 , s_10 , list ( after_lis [ i_10 + 1 ] ) ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( np . sum ( ans_lis ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> q = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) - 1 <NEWLINE> q [ p ] = i <NEWLINE> <NL> <DEDENT> s = f = 0 <NEWLINE> c = set ( ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if q [ i ] < q [ i - 1 ] : <NEWLINE> <INDENT> f = i - 1 <NEWLINE> c . add ( f - s + 1 ) <NEWLINE> s = i <NEWLINE> <DEDENT> <DEDENT> if c == set ( ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - max ( c ) ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if 0 <= k <= K : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A = i + 1 <NEWLINE> B = N / A <NEWLINE> <NL> if B == int ( B ) : <NEWLINE> <INDENT> count += B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> binary_tree = [ { <STRING> : - 1 , <STRING> : - 1 } for _ in range ( N ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> node_input = input ( ) <NEWLINE> id , left , right = map ( int , node_input . split ( ) ) <NEWLINE> <NL> binary_tree [ id ] [ <STRING> ] = left <NEWLINE> binary_tree [ id ] [ <STRING> ] = right <NEWLINE> <NL> degree = 0 <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> binary_tree [ left ] [ <STRING> ] = id <NEWLINE> binary_tree [ left ] [ <STRING> ] = right <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> binary_tree [ right ] [ <STRING> ] = id <NEWLINE> binary_tree [ right ] [ <STRING> ] = left <NEWLINE> <DEDENT> binary_tree [ id ] [ <STRING> ] = degree <NEWLINE> <NL> <NL> <DEDENT> def measure_depth_and_height ( id , depth ) : <NEWLINE> <INDENT> H [ id ] = max ( H [ id ] , depth ) <NEWLINE> <NL> parent_id = binary_tree [ id ] [ <STRING> ] <NEWLINE> if parent_id == - 1 : <NEWLINE> <INDENT> return depth <NEWLINE> <NL> <DEDENT> return measure_depth_and_height ( parent_id , depth + 1 ) <NEWLINE> <NL> <DEDENT> D = [ 0 for i in range ( N ) ] <NEWLINE> H = [ 0 for i in range ( N ) ] <NEWLINE> for id in range ( N ) : <NEWLINE> <INDENT> depth = measure_depth_and_height ( id , 0 ) <NEWLINE> D [ id ] = depth <NEWLINE> <NL> <NL> <DEDENT> def get_type ( node ) : <NEWLINE> <INDENT> if node [ <STRING> ] == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if node [ <STRING> ] == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if node [ <STRING> ] == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> for id in range ( N ) : <NEWLINE> <INDENT> node = binary_tree [ id ] <NEWLINE> parent_id = node [ <STRING> ] <NEWLINE> sibling_id = node [ <STRING> ] <NEWLINE> degree = node [ <STRING> ] <NEWLINE> node_type = get_type ( node ) <NEWLINE> print ( <STRING> . format ( id , parent_id , sibling_id , degree , D [ id ] , H [ id ] , node_type ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] / A [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( n , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> r = C . count ( <STRING> ) <NEWLINE> ans = C [ : r ] . count ( <STRING> ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ ] <NEWLINE> p = 1 <NEWLINE> vis = [ <STRING> ] * n <NEWLINE> while vis [ p - 1 ] == <STRING> : <NEWLINE> <INDENT> memo . append ( p ) <NEWLINE> vis [ p - 1 ] = <STRING> <NEWLINE> p = alist [ p - 1 ] <NEWLINE> <NL> <DEDENT> loop = memo . index ( p ) <NEWLINE> if k < len ( memo ) : <NEWLINE> <INDENT> print ( memo [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( memo [ loop + ( k - loop ) % ( len ( memo ) - loop ) ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> H , W , N = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> node_posi = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> nodes = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] in nodes : <NEWLINE> <INDENT> node_posi [ nodes . index ( field [ i ] [ j ] ) ] = [ j , i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> cost = 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( node_posi ) - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> searched = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> start , goal = node_posi [ i ] , node_posi [ i + 1 ] <NEWLINE> Q = deque ( [ start ] ) <NEWLINE> searched [ start [ 1 ] ] [ start [ 0 ] ] = 0 <NEWLINE> goal_flag = False <NEWLINE> <NL> while Q and not goal_flag : <NEWLINE> <INDENT> x , y = Q . popleft ( ) <NEWLINE> goal_flag = False <NEWLINE> <NL> for q in range ( 4 ) : <NEWLINE> <INDENT> nx = x + [ 1 , 0 , - 1 , 0 ] [ q ] <NEWLINE> ny = y + [ 0 , 1 , 0 , - 1 ] [ q ] <NEWLINE> <NL> if nx >= 0 and nx < W and ny >= 0 and ny < H : <NEWLINE> <INDENT> if searched [ ny ] [ nx ] == - 1 and field [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> Q . append ( [ nx , ny ] ) <NEWLINE> searched [ ny ] [ nx ] = searched [ y ] [ x ] + 1 <NEWLINE> if ( [ nx , ny ] == goal ) : <NEWLINE> <INDENT> cost += searched [ ny ] [ nx ] <NEWLINE> goal_flag = True <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> cycle = set ( ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 7 <NEWLINE> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if n in cycle : <NEWLINE> <INDENT> i = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if n % K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cycle . add ( n ) <NEWLINE> n = ( n * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ 0 ] * ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ l - 1 ] += 1 <NEWLINE> road [ r - 1 ] -= 1 <NEWLINE> <DEDENT> road = list ( itertools . accumulate ( road ) ) [ : - 1 ] <NEWLINE> <NL> flag = 0 <NEWLINE> for ro in road : <NEWLINE> <INDENT> if ro % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> while m > 0 : <NEWLINE> <INDENT> a_max = heapq . heappop ( a ) <NEWLINE> if a_max == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> heapq . heappush ( a , ( - 1 ) * ( - a_max // 2 ) ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> print ( sum ( ( N - 1 ) // i for i in range ( 1 , N ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a + 1 < 2 * k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ - 1 ] + A <NEWLINE> memo = [ ] <NEWLINE> loop = [ ] <NEWLINE> visit = [ 0 ] * n <NEWLINE> town = 1 <NEWLINE> while visit [ town - 1 ] < 2 : <NEWLINE> <INDENT> if visit [ town - 1 ] == 0 : <NEWLINE> <INDENT> memo . append ( town ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( town ) <NEWLINE> <DEDENT> visit [ town - 1 ] += 1 <NEWLINE> town = A [ town ] <NEWLINE> <DEDENT> outlier = len ( memo ) - len ( loop ) <NEWLINE> T = len ( loop ) <NEWLINE> if k <= outlier : <NEWLINE> <INDENT> print ( memo [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( k - outlier ) % T ] ) <NEWLINE> <DEDENT>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> nx = set ( [ ] ) <NEWLINE> <NL> for _ in range ( H ) : <NEWLINE> <INDENT> C . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> def keiro ( x , y , k ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if y + i > W - 1 or C [ x ] [ y + i ] != <STRING> or i > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x , y + i ) not in nx : <NEWLINE> <INDENT> nx . add ( ( x , y + i ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if y - i < 0 or C [ x ] [ y - i ] != <STRING> or i > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x , y - i ) not in nx : <NEWLINE> <INDENT> nx . add ( ( x , y - i ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x + i > H - 1 or C [ x + i ] [ y ] != <STRING> or i > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x + i , y ) not in nx : <NEWLINE> <INDENT> nx . add ( ( x + i , y ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x - i < 0 or C [ x - i ] [ y ] != <STRING> or i > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x - i , y ) not in nx : <NEWLINE> <INDENT> nx . add ( ( x - i , y ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> C [ x1 - 1 ] [ y1 - 1 ] = 0 <NEWLINE> keiro ( x1 - 1 , y1 - 1 , K ) <NEWLINE> taisho = nx . copy ( ) <NEWLINE> result = 1 <NEWLINE> for j in nx : <NEWLINE> <INDENT> C [ j [ 0 ] ] [ j [ 1 ] ] = result <NEWLINE> <NL> <DEDENT> while C [ x2 - 1 ] [ y2 - 1 ] == <STRING> : <NEWLINE> <INDENT> nx = set ( [ ] ) <NEWLINE> if len ( taisho ) == 0 or result > 10 ** 6 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> for l in taisho : <NEWLINE> <INDENT> keiro ( l [ 0 ] , l [ 1 ] , K ) <NEWLINE> <DEDENT> result += 1 <NEWLINE> for j in nx : <NEWLINE> <INDENT> C [ j [ 0 ] ] [ j [ 1 ] ] = result <NEWLINE> <DEDENT> taisho = nx . copy ( ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> import heapq <NEWLINE> <NL> [ vertex , edge , r ] = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> infty = 999999999 <NEWLINE> final_c = [ infty for i in range ( vertex ) ] <NEWLINE> dict_c = [ [ ] for i in range ( vertex ) ] <NEWLINE> <NL> for i in range ( edge ) : <NEWLINE> <INDENT> [ e1 , e2 , c ] = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> dict_c [ e1 ] . append ( ( e2 , c ) ) <NEWLINE> <NL> <DEDENT> final_c [ r ] = 0 <NEWLINE> root_c = [ ( final_c [ r ] , r ) ] <NEWLINE> <NL> def Dijkstra ( root , n ) : <NEWLINE> <INDENT> global infty , root_c , final_c , dict_c , root_c <NEWLINE> while ( root_c ) : <NEWLINE> <INDENT> ( cost , v ) = heapq . heappop ( root_c ) <NEWLINE> if cost > final_c [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( len ( dict_c [ v ] ) ) : <NEWLINE> <INDENT> ( e2 , c ) = dict_c [ v ] [ i ] <NEWLINE> if final_c [ e2 ] > final_c [ v ] + c : <NEWLINE> <INDENT> final_c [ e2 ] = final_c [ v ] + c <NEWLINE> heapq . heappush ( root_c , ( final_c [ e2 ] , e2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> Dijkstra ( r , vertex ) <NEWLINE> for i in range ( vertex ) : <NEWLINE> <INDENT> if final_c [ i ] == infty : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( final_c [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> V = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> V [ p - 1 ] . append ( ( y , i ) ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * M <NEWLINE> for i , v in enumerate ( V , start = 1 ) : <NEWLINE> <INDENT> v . sort ( ) <NEWLINE> for j , ( y , k ) in enumerate ( v , start = 1 ) : <NEWLINE> <INDENT> ans [ k ] = format ( str ( i ) , <STRING> ) + format ( str ( j ) , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> nextroom = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> nextroom [ A - 1 ] . append ( B - 1 ) <NEWLINE> nextroom [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> sgn = [ - 1 for _ in range ( N ) ] <NEWLINE> sgn [ 0 ] = 0 <NEWLINE> <NL> depth = [ float ( <STRING> ) for _ in range ( N ) ] <NEWLINE> depth [ 0 ] = 0 <NEWLINE> <NL> now = [ 0 ] <NEWLINE> nextvisit = [ ] <NEWLINE> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for n in now : <NEWLINE> <INDENT> for i in nextroom [ n ] : <NEWLINE> <INDENT> if depth [ i ] > j : <NEWLINE> <INDENT> nextvisit . append ( i ) <NEWLINE> sgn [ i ] = n <NEWLINE> depth [ i ] = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now = [ ] + nextvisit <NEWLINE> nextvisit = [ ] <NEWLINE> <NL> <DEDENT> if - 1 in sgn : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for k in range ( 1 , len ( sgn ) ) : <NEWLINE> <INDENT> print ( sgn [ k ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> dic = { a + 1 : 0 for a in range ( 10 ** 5 ) } <NEWLINE> for a in A : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans += dic [ B ] * ( C - B ) <NEWLINE> dic [ C ] += dic [ B ] <NEWLINE> dic [ B ] = 0 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> K = [ 0 ] * N <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> K [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = deque ( ) <NEWLINE> cmd = [ <STRING> , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . appendleft ( int ( cmd [ 1 ] ) ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d . remove ( int ( cmd [ 1 ] ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * list ( d ) ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> score = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> score [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if score [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs_h = [ 0 ] * h <NEWLINE> bombs_w = [ 0 ] * w <NEWLINE> B = [ ] <NEWLINE> for n in range ( m ) : <NEWLINE> <INDENT> h1 , w1 = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> B . append ( ( h1 , w1 ) ) <NEWLINE> bombs_w [ w1 ] += 1 <NEWLINE> bombs_h [ h1 ] += 1 <NEWLINE> <DEDENT> max_h = max ( bombs_h ) <NEWLINE> max_w = max ( bombs_w ) <NEWLINE> h_maxindex = [ i for i , x in enumerate ( bombs_h ) if x == max_h ] <NEWLINE> w_maxindex = [ i for i , x in enumerate ( bombs_w ) if x == max_w ] <NEWLINE> cnt = 0 <NEWLINE> k = len ( h_maxindex ) * len ( w_maxindex ) <NEWLINE> for i , j in B : <NEWLINE> <INDENT> if bombs_h [ i ] == max_h and bombs_w [ j ] == max_w : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max_h + max_w - ( cnt == k ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def onigokko ( ) : <NEWLINE> <INDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if B < A : <NEWLINE> <INDENT> swap = A <NEWLINE> A = B <NEWLINE> B = swap <NEWLINE> <NL> <DEDENT> tikaduku = V - W <NEWLINE> <NL> <COMMENT> <NL> if tikaduku < 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> kyori = B - A <NEWLINE> <NL> if kyori <= tikaduku * T : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> print ( onigokko ( ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def mapinput ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , m = mapinput ( ) <NEWLINE> rootlist = [ [ ] for i in range ( n ) ] <NEWLINE> flag = [ False for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = mapinput ( ) <NEWLINE> rootlist [ a - 1 ] . append ( b ) <NEWLINE> rootlist [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = deque ( ) <NEWLINE> que . append ( 1 ) <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> now = que . popleft ( ) <NEWLINE> for room in rootlist [ now - 1 ] : <NEWLINE> <INDENT> if flag [ room - 1 ] == False : <NEWLINE> <INDENT> flag [ room - 1 ] = now <NEWLINE> que . append ( room ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i , root in enumerate ( flag ) : <COMMENT> <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( root ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> seen = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> def rec ( h , w , seen ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> res = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = [ 0 , 1 ] <NEWLINE> <DEDENT> dh = [ - 1 , 1 , 0 , 0 ] <NEWLINE> dw = [ 0 , 0 , - 1 , 1 ] <NEWLINE> seen [ h ] [ w ] = 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nh = h + dh [ i ] <NEWLINE> nw = w + dw [ i ] <NEWLINE> if 0 <= nh <= H - 1 and 0 <= nw <= W - 1 : <NEWLINE> <INDENT> if seen [ nh ] [ nw ] == 0 and S [ nh ] [ nw ] != S [ h ] [ w ] : <NEWLINE> <INDENT> r0 , r1 = rec ( nh , nw , seen ) <NEWLINE> res [ 0 ] += r0 <NEWLINE> res [ 1 ] += r1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if seen [ h ] [ w ] != 1 : <NEWLINE> <INDENT> t0 , t1 = rec ( h , w , seen ) <NEWLINE> ans += t0 * t1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ ] <NEWLINE> graph = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> edge . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> graph [ edge [ - 1 ] [ 0 ] ] . append ( edge [ - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> s , g = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> ans = [ [ INF , INF , INF ] for i in range ( n + 1 ) ] <NEWLINE> q = [ s ] <NEWLINE> d = 0 <NEWLINE> while q : <NEWLINE> <INDENT> nq = [ ] <NEWLINE> d += 1 <NEWLINE> p = d % 3 <NEWLINE> for cf in q : <NEWLINE> <INDENT> for ct in graph [ cf ] : <NEWLINE> <INDENT> if ans [ ct ] [ p ] == INF : <NEWLINE> <INDENT> ans [ ct ] [ p ] = d <NEWLINE> nq . append ( ct ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = copy . deepcopy ( nq ) <NEWLINE> <DEDENT> if ans [ g ] [ 0 ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ g ] [ 0 ] // 3 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> slist = [ ] <NEWLINE> if ( a > b ) : <NEWLINE> <INDENT> c = a % b <NEWLINE> d = b <NEWLINE> while ( c != 0 and d != 0 ) : <NEWLINE> <INDENT> if ( c < d ) : <NEWLINE> <INDENT> d = d % c <NEWLINE> <DEDENT> elif ( c > d ) : <NEWLINE> <INDENT> c = c % d <NEWLINE> <DEDENT> <DEDENT> if ( c == 0 ) : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> elif ( d == 0 ) : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> elif ( a < b ) : <NEWLINE> <INDENT> c = a <NEWLINE> d = b % a <NEWLINE> while ( c != 0 and d != 0 ) : <NEWLINE> <INDENT> if ( c < d ) : <NEWLINE> <INDENT> d = d % c <NEWLINE> <DEDENT> elif ( c > d ) : <NEWLINE> <INDENT> c = c % d <NEWLINE> <DEDENT> <DEDENT> if ( c == 0 ) : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> elif ( d == 0 ) : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 0 : : 2 ] [ : : - 1 ] + a [ 1 : : 2 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ( a [ 1 : : 2 ] [ : : - 1 ] + a [ 0 : : 2 ] ) ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> mod = 7 % k <NEWLINE> cnt = 1 <NEWLINE> answer = - 1 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if mod == 0 : <NEWLINE> <INDENT> answer = cnt <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> mod = ( mod * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> dp = [ [ 1 for _ in range ( k + 1 ) ] for _ in range ( k + 1 ) ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = math . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += dp [ a ] [ dp [ b ] [ c ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b != 0 : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> l = c . split ( ) <NEWLINE> cc = [ int ( s ) for s in l ] <NEWLINE> ccc = list ( cc ) <NEWLINE> for i in range ( a , 102 ) : <NEWLINE> <INDENT> if i in ccc : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in reversed ( range ( 0 , a ) ) : <NEWLINE> <INDENT> if i in ccc : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if x - a < a - y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> gra = [ [ ] for _ in range ( n ) ] <NEWLINE> visited = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> gra [ a - 1 ] . append ( b - 1 ) <NEWLINE> gra [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( st ) : <NEWLINE> <INDENT> temp = gra [ st ] <NEWLINE> for i in temp : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> visited [ i ] += 1 <NEWLINE> ans [ i ] += ans [ st ] <NEWLINE> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> visited [ 0 ] += 1 <NEWLINE> dfs ( 0 ) <NEWLINE> <NL> for h in range ( n ) : <NEWLINE> <INDENT> ans [ h ] = str ( ans [ h ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> bad = [ ] <NEWLINE> for i in ab : <NEWLINE> <INDENT> a , b = h [ i [ 0 ] - 1 ] , h [ i [ 1 ] - 1 ] <NEWLINE> if a < b : <NEWLINE> <INDENT> bad += [ i [ 0 ] ] <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> bad += [ i [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad += [ i [ 0 ] , i [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( set ( bad ) ) ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> a = None <NEWLINE> <NL> if ( len ( N ) == 1 ) : <NEWLINE> <INDENT> a = int ( N ) <NEWLINE> <DEDENT> elif ( len ( N ) == 2 ) : <NEWLINE> <INDENT> a = int ( N [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( N [ 2 ] ) <NEWLINE> <NL> <DEDENT> s = <STRING> <NEWLINE> <NL> if ( a == 3 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif ( a == 0 or a == 1 or a == 6 or a == 8 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> r_wa = [ a [ 0 ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> r_wa . append ( r_wa [ i - 1 ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( r_wa [ n - 1 ] - r_wa [ i ] ) <NEWLINE> ans = ans % 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def solve ( k ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> num *= 10 <NEWLINE> num += 7 <NEWLINE> num %= k <NEWLINE> if num == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = solve ( k ) <NEWLINE> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num = N // i <NEWLINE> e = num * i <NEWLINE> ans += ( i + e ) * num // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> dll = deque ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> raw = input ( ) . split ( ) <NEWLINE> command = raw [ 0 ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> value = raw [ 1 ] <NEWLINE> try : <NEWLINE> <INDENT> dll . remove ( value ) <NEWLINE> <DEDENT> except ValueError as err : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> value = raw [ 1 ] <NEWLINE> dll . appendleft ( value ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> except IndexError as err : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <DEDENT> except IndexError as err : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dll ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . children = { } <NEWLINE> self . end = False <NEWLINE> <NL> <DEDENT> def __contains__ ( self , key ) : <NEWLINE> <INDENT> if len ( key ) == 0 : <NEWLINE> <INDENT> return self . end <NEWLINE> <NL> <DEDENT> k , * rest = key <NEWLINE> if k not in self . children : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return rest in self . children [ k ] <NEWLINE> <NL> <DEDENT> def add ( self , key ) : <NEWLINE> <INDENT> if len ( key ) > 0 : <NEWLINE> <INDENT> k , * rest = key <NEWLINE> if k not in self . children : <NEWLINE> <INDENT> self . children [ k ] = self . __class__ ( ) <NEWLINE> <NL> <DEDENT> self . children [ k ] . add ( rest ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . end = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Dictionary : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . tree = Tree ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , word ) : <NEWLINE> <INDENT> self . tree . add ( word ) <NEWLINE> <NL> <DEDENT> def find ( self , word ) : <NEWLINE> <INDENT> return word in self . tree <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <COMMENT> <NEWLINE> words = Dictionary ( ) <NEWLINE> <NL> for command in sys . stdin : <NEWLINE> <NL> <INDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> words . insert ( command [ 7 : ] ) <NEWLINE> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> if words . find ( command [ 5 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> N = n % 10 <NEWLINE> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 0 or N == 6 or N == 8 or N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> big = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for num in a : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> big = 1 <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * num <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> big = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if big == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> graph [ ab [ i ] [ 0 ] ] . append ( ( ab [ i ] [ 1 ] , i ) ) <NEWLINE> graph [ ab [ i ] [ 1 ] ] . append ( ( ab [ i ] [ 0 ] , i ) ) <NEWLINE> <NL> <DEDENT> visit = [ False ] * ( n + 1 ) <NEWLINE> def dfs ( p , c ) : <NEWLINE> <INDENT> color = 1 <NEWLINE> visit [ p ] = True <NEWLINE> for n , i in graph [ p ] : <NEWLINE> <INDENT> if visit [ n ] == False : <NEWLINE> <INDENT> if color == c : <NEWLINE> <INDENT> color += 1 <NEWLINE> <DEDENT> ans [ i ] = color <NEWLINE> dfs ( n , color ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , 0 ) <NEWLINE> print ( max ( ans ) ) <NEWLINE> for t in ans : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def solve ( n , a ) : <NEWLINE> <INDENT> wa = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> wa += a [ i ] <NEWLINE> <DEDENT> <DEDENT> kotae = wa <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> wa += a [ ( n // 2 - i - 1 ) * 2 + 1 ] <NEWLINE> wa -= a [ ( n // 2 - i - 1 ) * 2 ] <NEWLINE> if ( wa > kotae ) : <NEWLINE> <INDENT> kotae = wa <NEWLINE> <DEDENT> <DEDENT> return kotae <NEWLINE> <NL> <DEDENT> def dfs ( n , a , k ) : <NEWLINE> <INDENT> global zen <NEWLINE> zen . append ( [ n , k ] ) <NEWLINE> if ( k == 1 ) : <NEWLINE> <INDENT> return max ( a ) <NEWLINE> <DEDENT> ari = a [ n - 1 ] + dfs ( n - 2 , a [ : n - 2 ] , k - 1 ) <NEWLINE> if ( n == k * 2 - 1 ) : <NEWLINE> <INDENT> return ari <NEWLINE> <DEDENT> nasi = dfs ( n - 1 , a [ : n - 1 ] , k ) <NEWLINE> return max ( ari , nasi ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> print ( solve ( n , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data = [ [ a [ 0 ] , a [ 0 ] ] , [ max ( a [ : 2 ] ) , max ( a [ : 2 ] ) ] ] <NEWLINE> <COMMENT> <NL> data . append ( [ max ( a [ : 3 ] ) , a [ 0 ] + a [ 2 ] ] ) <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> ari = a [ i ] + data [ i - 2 ] [ 0 ] <NEWLINE> nasi = data [ i - 1 ] [ 1 ] <NEWLINE> saiyo = max ( ari , nasi ) <NEWLINE> data . append ( [ saiyo , saiyo ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ooi = a [ i ] + data [ i - 2 ] [ 1 ] <NEWLINE> nasi = data [ i - 1 ] [ 1 ] <NEWLINE> ari = a [ i ] + data [ i - 2 ] [ 0 ] <NEWLINE> sukunai = max ( ari , nasi ) <NEWLINE> data . append ( [ sukunai , ooi ] ) <NEWLINE> <DEDENT> <DEDENT> print ( data [ n - 1 ] [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> V , E = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> <NL> no_route = 15001 <NEWLINE> <NL> <COMMENT> <NL> dp = [ [ no_route ] * ( V - 1 ) for i in range ( 1 << ( V - 1 ) ) ] <NEWLINE> <NL> adj = [ [ ] for i in range ( V ) ] <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> s , t , d = map ( int , line . split ( ) ) <NEWLINE> if s == V - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ 1 << t ] [ t ] = d <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> adj [ t ] . append ( ( s , d ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for b in range ( 1 , 1 << ( V - 1 ) ) : <NEWLINE> <INDENT> for i in range ( V - 1 ) : <NEWLINE> <INDENT> b_i = 1 << i <NEWLINE> if b & b_i : <NEWLINE> <INDENT> pre_bit = b ^ b_i <NEWLINE> dp_pre = dp [ pre_bit ] <NEWLINE> for s , d in adj [ i ] : <NEWLINE> <INDENT> pre_rec = dp_pre [ s ] <NEWLINE> if pre_rec != no_route : <NEWLINE> <INDENT> dp [ b ] [ i ] = min ( dp [ b ] [ i ] , pre_rec + d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = no_route <NEWLINE> <NL> <COMMENT> <NL> dp_comp = dp [ ( 1 << ( V - 1 ) ) - 1 ] <NEWLINE> <NL> for s , d in adj [ V - 1 ] : <NEWLINE> <INDENT> comp_rec = dp_comp [ s ] <NEWLINE> if comp_rec != no_route : <NEWLINE> <INDENT> ans = min ( ans , comp_rec + d ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == no_route : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = sorted ( [ ( i + 1 , a [ i ] ) for i in range ( n ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> m = float ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> m = min ( m , b [ i ] [ 0 ] ) <NEWLINE> if b [ i ] [ 1 ] == b [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ m ] += ( i + 1 ) * ( b [ i ] [ 1 ] - b [ i + 1 ] [ 1 ] ) <NEWLINE> <DEDENT> ans [ 1 ] += sum ( a ) - sum ( ans ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> def matchcount ( x , y ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] : ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> rec = len ( T ) <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> subst = S [ i : i + len ( T ) ] <NEWLINE> <COMMENT> <NL> rec = min ( rec , len ( T ) - matchcount ( subst , T ) ) <NEWLINE> <NL> <DEDENT> print ( rec ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> s = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> h = int ( s [ 0 ] ) <NEWLINE> w = int ( s [ 1 ] ) <NEWLINE> if ( h == 0 ) & ( w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lists = [ [ ] for _ in range ( N ) ] <NEWLINE> an . sort ( reverse = True ) <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> lists [ k ] . append ( an [ 2 * k ] ) <NEWLINE> lists [ k ] . append ( an [ 2 * k + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> lists [ i ] . append ( an [ 2 * N - 1 + i ] ) <NEWLINE> <NL> <DEDENT> sasa = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> sasa += lists [ j ] [ 1 ] <NEWLINE> <DEDENT> print ( sasa ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def bfs2 ( g , n , m ) : <NEWLINE> <INDENT> pre = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> pre [ 1 ] = 1 <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for i in range ( len ( g [ x ] ) ) : <NEWLINE> <INDENT> if pre [ g [ x ] [ i ] ] == 0 : <NEWLINE> <INDENT> q . append ( g [ x ] [ i ] ) <NEWLINE> pre [ g [ x ] [ i ] ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return pre <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , m = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> pre = bfs2 ( g , n , m ) <NEWLINE> <NL> print ( <STRING> if 0 not in pre [ 1 : ] else <STRING> ) <NEWLINE> for i in range ( 2 , len ( pre ) ) : <NEWLINE> <INDENT> print ( pre [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> l_count = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> from collections import deque <NEWLINE> def answer ( st_X , st_Y ) : <COMMENT> <NEWLINE> <INDENT> tmp_X , tmp_Y = st_X , st_Y <NEWLINE> que = deque ( [ [ tmp_X , tmp_Y ] ] ) <NEWLINE> after = set ( ) <NEWLINE> while que : <COMMENT> <NEWLINE> <INDENT> tmp_X , tmp_Y = que . popleft ( ) <NEWLINE> nu = l_count [ tmp_Y ] [ tmp_X ] <NEWLINE> after . add ( ( tmp_X , tmp_Y ) ) <NEWLINE> if tmp_X > 0 and l [ tmp_Y ] [ tmp_X - 1 ] == <STRING> and ( tmp_X - 1 , tmp_Y ) not in after and [ tmp_X - 1 , tmp_Y ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y ] [ tmp_X - 1 ] = nu + 1 <NEWLINE> que . append ( [ tmp_X - 1 , tmp_Y ] ) <NEWLINE> <DEDENT> if tmp_Y > 0 and l [ tmp_Y - 1 ] [ tmp_X ] == <STRING> and ( tmp_X , tmp_Y - 1 ) not in after and [ tmp_X , tmp_Y - 1 ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y - 1 ] [ tmp_X ] = nu + 1 <NEWLINE> que . append ( [ tmp_X , tmp_Y - 1 ] ) <NEWLINE> <DEDENT> if tmp_X < W - 1 and l [ tmp_Y ] [ tmp_X + 1 ] == <STRING> and ( tmp_X + 1 , tmp_Y ) not in after and [ tmp_X + 1 , tmp_Y ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y ] [ tmp_X + 1 ] = nu + 1 <NEWLINE> que . append ( [ tmp_X + 1 , tmp_Y ] ) <NEWLINE> <DEDENT> if tmp_Y < H - 1 and l [ tmp_Y + 1 ] [ tmp_X ] == <STRING> and ( tmp_X , tmp_Y + 1 ) not in after and [ tmp_X , tmp_Y + 1 ] not in que : <NEWLINE> <INDENT> l_count [ tmp_Y + 1 ] [ tmp_X ] = nu + 1 <NEWLINE> que . append ( [ tmp_X , tmp_Y + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> l_count = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> answer ( j , i ) <NEWLINE> tmp = max ( sum ( l_count , [ ] ) ) <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N , K = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> A = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> loop = [ ] <NEWLINE> pre = [ ] <NEWLINE> visited = set ( ) <NEWLINE> <NL> def dfs ( index , now ) : <NEWLINE> <INDENT> global pre <NEWLINE> global loop <NEWLINE> loop . append ( now ) <NEWLINE> if now in visited : <NEWLINE> <INDENT> for left in range ( len ( loop ) ) : <NEWLINE> <INDENT> if now == loop [ left ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> pre = loop [ : left ] <NEWLINE> loop = loop [ left : index ] <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . add ( now ) <NEWLINE> dfs ( index + 1 , A [ now - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , 1 ) <NEWLINE> <NL> if len ( pre ) > K : <NEWLINE> <INDENT> print ( pre [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= len ( pre ) <NEWLINE> print ( loop [ K % len ( loop ) ] ) <NEWLINE> <DEDENT>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> N , K = MI ( ) <NEWLINE> <NL> A = LI ( ) <NEWLINE> <NL> for j in range ( K , N + 1 ) : <NEWLINE> <INDENT> if j == K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ j - K - 1 ] < A [ j - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def is_good ( mid , key ) : <NEWLINE> <INDENT> return A_sum - np . minimum ( A , mid // F ) . sum ( ) <= key <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( bad , good , key ) : <NEWLINE> <INDENT> while good - bad > 1 : <NEWLINE> <INDENT> mid = ( bad + good ) // 2 <NEWLINE> if is_good ( mid , key ) : <NEWLINE> <INDENT> good = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad = mid <NEWLINE> <DEDENT> <DEDENT> return good <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A . sort ( ) <NEWLINE> F [ : : - 1 ] . sort ( ) <NEWLINE> A_sum = A . sum ( ) <NEWLINE> ans = binary_search ( - 1 , np . max ( A * F ) , K ) <NEWLINE> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> minnum = 10 ** 18 + 1 <NEWLINE> ans = ( - 10 ** 9 - 1 ) <NEWLINE> for n in range ( num ) : <NEWLINE> <INDENT> newnum = int ( input ( ) ) <NEWLINE> ans = max ( ans , newnum - minnum ) <NEWLINE> minnum = min ( minnum , newnum ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_l = [ ] <NEWLINE> lst_r = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_l . append ( l ) <NEWLINE> lst_r . append ( r ) <NEWLINE> <NL> <DEDENT> max_l = max ( lst_l ) <NEWLINE> min_r = min ( lst_r ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if max_l <= i + 1 <= min_r : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CA = Counter ( A ) <NEWLINE> sumA = 0 <NEWLINE> for key , value in CA . items ( ) : <NEWLINE> <INDENT> sumA += key * value <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sumA += ( c - b ) * CA [ b ] <NEWLINE> CA [ c ] += CA [ b ] <NEWLINE> CA [ b ] = 0 <NEWLINE> print ( sumA ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import copy <NEWLINE> li = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> ans += A [ j ] <NEWLINE> li . append ( copy . copy ( ans ) ) <NEWLINE> <NL> <DEDENT> li . sort ( ) <NEWLINE> ans = 0 <NEWLINE> temp = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <INDENT> if li [ i ] == li [ i + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> temp = 1 <NEWLINE> <DEDENT> <DEDENT> ans += temp * ( temp - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> count = 0 <NEWLINE> <NL> <COMMENT> <NL> x = 0 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
ans = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i == j ) : <NEWLINE> <INDENT> for k in range ( i , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( ( i == j ) and ( i == k ) ) : <NEWLINE> <INDENT> sum += math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += ( 3 * math . gcd ( i , math . gcd ( j , k ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( i + 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> sum += ( 3 * math . gcd ( i , math . gcd ( j , k ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> AB . sort ( key = lambda x : ( - x [ 1 ] , - x [ 0 ] ) ) <COMMENT> <NEWLINE> memo = [ 0 ] * ( 10 ** 5 + 1 ) <COMMENT> <NEWLINE> work = [ float ( <STRING> ) ] * ( 10 ** 5 + 1 ) <COMMENT> <NEWLINE> noMore = float ( <STRING> ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a < noMore : <COMMENT> <NEWLINE> <INDENT> flag = 1 <NEWLINE> for idx in range ( min ( M - a , work [ a ] ) , - 1 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> if memo [ idx ] == 0 : <COMMENT> <NEWLINE> <INDENT> ans += b <COMMENT> <NEWLINE> memo [ idx ] = 1 <COMMENT> <NEWLINE> flag = 0 <COMMENT> <NEWLINE> work [ a ] = idx <COMMENT> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <COMMENT> <NEWLINE> <INDENT> noMore = a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
spades = [ ] <NEWLINE> hearts = [ ] <NEWLINE> clubs = [ ] <NEWLINE> diamonds = [ ] <NEWLINE> <NL> mspades = [ ] <NEWLINE> mhearts = [ ] <NEWLINE> mclubs = [ ] <NEWLINE> mdiamonds = [ ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> while i < n : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> if <STRING> in card : <NEWLINE> <INDENT> spades . append ( card ) <NEWLINE> <DEDENT> elif <STRING> in card : <NEWLINE> <INDENT> hearts . append ( card ) <NEWLINE> <DEDENT> elif <STRING> in card : <NEWLINE> <INDENT> clubs . append ( card ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diamonds . append ( card ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> deck = [ spades , hearts , clubs , diamonds ] <NEWLINE> mdeck = [ mspades , mhearts , mclubs , mdiamonds ] <NEWLINE> symbols = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> onDeck = 0 <NEWLINE> <NL> while onDeck < 4 : <NEWLINE> <INDENT> rank = 1 <NEWLINE> while rank <= 13 : <NEWLINE> <INDENT> if symbols [ onDeck ] + str ( rank ) in deck [ onDeck ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mdeck [ onDeck ] . append ( symbols [ onDeck ] + str ( rank ) ) <NEWLINE> <DEDENT> rank += 1 <NEWLINE> <DEDENT> onDeck += 1 <NEWLINE> <NL> <DEDENT> onmDeck = 0 <NEWLINE> <NL> while onmDeck < 4 : <NEWLINE> <INDENT> if mdeck [ onmDeck ] != [ ] : <NEWLINE> <INDENT> print ( <STRING> . join ( mdeck [ onmDeck ] ) ) <NEWLINE> <DEDENT> onmDeck += 1 <NEWLINE> <DEDENT>
<NL> def is_triangle ( a , b , c ) : <NEWLINE> <INDENT> if a >= b + c : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if b >= a + c : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if c >= a + b : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> L . sort ( reverse = True ) <NEWLINE> <NL> count = 0 <NEWLINE> for a_i in range ( N - 2 ) : <NEWLINE> <INDENT> b_i = a_i + 1 <NEWLINE> c_i = 1 <NEWLINE> while b_i + c_i < N : <NEWLINE> <NL> <INDENT> if not is_triangle ( L [ a_i ] , L [ b_i ] , L [ - c_i ] ) : <NEWLINE> <INDENT> c_i += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count += ( N - b_i - c_i ) <NEWLINE> b_i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import string <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res *= a [ i ] <NEWLINE> if ( res > pow ( 10 , 18 ) ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( res <= pow ( 10 , 18 ) ) : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> elif ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <NL> tmp = [ ] <NEWLINE> for i in T : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> <NL> if len ( T ) == 1 : <NEWLINE> <INDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> tmp [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( tmp ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> L_cnt = [ ] <NEWLINE> R_cnt = [ ] <NEWLINE> LR_cnt = [ ] <NEWLINE> min_l , min_r = 10 ** 6 , 10 ** 6 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = s [ i ] <NEWLINE> flag = 0 <NEWLINE> l = 0 <NEWLINE> r = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if not flag and t [ j ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif t [ j ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l -= 1 <NEWLINE> if l == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if r == 0 and l == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if r == 0 : <NEWLINE> <INDENT> L_cnt . append ( l ) <NEWLINE> <DEDENT> elif l == 0 : <NEWLINE> <INDENT> R_cnt . append ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LR_cnt . append ( [ l , r ] ) <NEWLINE> min_l = min ( min_l , l ) <NEWLINE> min_r = min ( min_r , r ) <NEWLINE> <DEDENT> <DEDENT> L , R = sum ( L_cnt ) , sum ( R_cnt ) <NEWLINE> if not LR_cnt : <NEWLINE> <INDENT> if L == R : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if not ( L_cnt and R_cnt ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> box1 = [ ] <NEWLINE> box2 = [ ] <NEWLINE> for i in range ( len ( LR_cnt ) ) : <NEWLINE> <INDENT> if L >= LR_cnt [ i ] [ 1 ] and LR_cnt [ i ] [ 1 ] <= LR_cnt [ i ] [ 0 ] : <NEWLINE> <INDENT> L += LR_cnt [ i ] [ 0 ] - LR_cnt [ i ] [ 1 ] <NEWLINE> <DEDENT> elif LR_cnt [ i ] [ 1 ] <= LR_cnt [ i ] [ 0 ] : <NEWLINE> <INDENT> box1 . append ( LR_cnt [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> box2 . append ( LR_cnt [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( box1 ) ) : <NEWLINE> <INDENT> L -= box1 [ i ] [ 1 ] <NEWLINE> if L < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> L += box1 [ i ] [ 0 ] <NEWLINE> <DEDENT> for i in range ( len ( box2 ) ) : <NEWLINE> <INDENT> L -= box2 [ i ] [ 1 ] <NEWLINE> if L < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> L += box2 [ i ] [ 0 ] <NEWLINE> <DEDENT> if L == R : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> root = [ 1 ] <NEWLINE> for i in range ( 2 * n + 1000 ) : <NEWLINE> <INDENT> next_num = a [ root [ - 1 ] ] <NEWLINE> root . append ( next_num ) <NEWLINE> <NL> <DEDENT> if k < n + 1 : <NEWLINE> <INDENT> print ( root [ k ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> loop_end = n <NEWLINE> loop_start = n - 1 <NEWLINE> while ( root [ loop_start ] != root [ loop_end ] ) : <NEWLINE> <INDENT> loop_start -= 1 <NEWLINE> <DEDENT> period = loop_end - loop_start <NEWLINE> k %= period <NEWLINE> while k < n : <NEWLINE> <INDENT> k += period <NEWLINE> <DEDENT> print ( root [ k ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> a [ i ] = sum ( a [ i : : i ] ) % 2 <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = 0 <NEWLINE> r = max ( a ) <NEWLINE> <NL> x = ( l + r ) // 2 <NEWLINE> ans = r + 1 <NEWLINE> while ( r > 1 + l ) : <NEWLINE> <NL> <NL> <INDENT> x = ( l + r ) // 2 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count += math . ceil ( a [ i ] / x ) - 1 <NEWLINE> <DEDENT> if ( count <= K ) : <NEWLINE> <INDENT> if ( ans > x ) : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> r = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = x <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> ans = x <NEWLINE> if ( x != 0 and l != 0 ) : <NEWLINE> <NL> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> count += math . ceil ( a [ i ] / l ) - 1 <NEWLINE> <NL> <DEDENT> if ( count <= K ) : <NEWLINE> <INDENT> ans = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = r <NEWLINE> <NL> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> ans = r <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( ( b - a ) % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> R . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> for i in range ( 1 , len ( R ) ) : <NEWLINE> <INDENT> maxv = max ( maxv , ( R [ i ] - minv ) ) <NEWLINE> minv = min ( minv , R [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> tl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ts = list ( set ( tl ) ) <NEWLINE> tc = Counter ( tl ) <NEWLINE> dc = Counter ( dl ) <NEWLINE> <NL> for t in ts : <NEWLINE> <INDENT> if tc [ t ] <= dc [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> d = c [ b - 1 ] . swapcase ( ) <NEWLINE> c [ b - 1 ] = d <NEWLINE> c = <STRING> . join ( c ) <NEWLINE> print ( c ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> R = [ 0 ] * N <NEWLINE> ans = 10 ** 9 <NEWLINE> def myadd ( i ) : <NEWLINE> <INDENT> if R [ i ] == 3 : <NEWLINE> <INDENT> R [ i ] = 0 <NEWLINE> myadd ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 ** N - 1 ) : <NEWLINE> <INDENT> myadd ( 0 ) <NEWLINE> if 1 in R and 2 in R and 3 in R : <NEWLINE> <INDENT> tmp = - 30 <NEWLINE> t1 , t2 , t3 = 0 , 0 , 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if R [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if R [ j ] == 1 : <NEWLINE> <INDENT> t1 += L [ j ] <NEWLINE> <DEDENT> elif R [ j ] == 2 : <NEWLINE> <INDENT> t2 += L [ j ] <NEWLINE> <DEDENT> elif R [ j ] == 3 : <NEWLINE> <INDENT> t3 += L [ j ] <NEWLINE> <DEDENT> tmp += 10 <NEWLINE> <DEDENT> tmp += abs ( A - t1 ) + abs ( B - t2 ) + abs ( C - t3 ) <NEWLINE> ans = min ( tmp , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def lcs ( x , y ) : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> b = len ( y ) <NEWLINE> c1 = [ 0 ] * ( b + 1 ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> ret . append ( lcs ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x ] . append ( y ) <NEWLINE> edge [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> inf = 10 ** 18 <NEWLINE> LIS = [ inf ] * ( N + 10 ) <NEWLINE> <NL> <NL> def DFS ( s , parent = 0 ) : <NEWLINE> <INDENT> a = A [ s - 1 ] <NEWLINE> i = bisect . bisect_left ( LIS , a ) <NEWLINE> v = LIS [ i ] <NEWLINE> LIS [ i ] = a <NEWLINE> ans [ s ] = bisect . bisect_left ( LIS , inf ) <NEWLINE> for t in edge [ s ] : <NEWLINE> <INDENT> if t == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> DFS ( t , s ) <NEWLINE> <COMMENT> <NL> <DEDENT> LIS [ i ] = v <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> DFS ( 1 ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> cnt_a = 0 <NEWLINE> cnt_b = 0 <NEWLINE> cnt_c = 0 <NEWLINE> <NL> if ( a > 0 ) & ( a > k ) : <NEWLINE> <INDENT> cnt_a = k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_a = a <NEWLINE> k = k - cnt_a <NEWLINE> <NL> <DEDENT> if ( b > 0 ) & ( b > k ) : <NEWLINE> <INDENT> cnt_b = k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_b = b <NEWLINE> k = k - cnt_b <NEWLINE> <NL> <DEDENT> if c > 0 : <NEWLINE> <INDENT> cnt_c = k <NEWLINE> <NL> <DEDENT> result = cnt_a * 1 + cnt_b * 0 + cnt_c * ( - 1 ) <NEWLINE> print ( result ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> result += i <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> result += gcd ( i , k ) * 3 <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> result += gcd ( i , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += gcd ( gcd ( i , j ) , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> <NL> def inf_matrix ( n ) : <NEWLINE> <INDENT> return [ [ inf for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> <DEDENT> def dijkstra ( r , w , V ) : <NEWLINE> <INDENT> result = [ inf ] * V <NEWLINE> q = [ ] <NEWLINE> heappush ( q , ( 0 , r ) ) <NEWLINE> result [ r ] = 0 <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> min_w , min_next = heappop ( q ) <NEWLINE> for weight , nxt in w [ min_next ] : <NEWLINE> <INDENT> if result [ nxt ] > min_w + weight : <NEWLINE> <INDENT> result [ nxt ] = min_w + weight <NEWLINE> heappush ( q , ( min_w + weight , nxt ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> w = defaultdict ( list ) <NEWLINE> for e in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> w [ s ] . append ( ( d , t ) ) <NEWLINE> <NL> <DEDENT> result = dijkstra ( r , w , V ) <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> if result [ i ] == inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> d = [ None ] * k <NEWLINE> a = [ None ] * k <NEWLINE> <NL> syugou = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> a [ i ] = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <NL> syugou = syugou + a [ i ] <NEWLINE> <NL> <DEDENT> num = set ( syugou ) <NEWLINE> <NL> print ( n - len ( num ) ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in data : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in data : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> def f ( P ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while s + w [ i ] <= P : <NEWLINE> <INDENT> s += w [ i ] <NEWLINE> i += 1 <NEWLINE> if i == n : return n <NEWLINE> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = 100000 * 10000 <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> v = f ( mid ) <NEWLINE> if v >= n : right = mid <NEWLINE> else : left = mid <NEWLINE> <DEDENT> print ( right ) <NEWLINE>
X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = { i for i in range ( 0 , 102 ) } <NEWLINE> nothings = nums - set ( p ) <NEWLINE> differences = { } <NEWLINE> for i in nothings : <NEWLINE> <INDENT> difference = abs ( X - i ) <NEWLINE> if difference in differences : <NEWLINE> <INDENT> differences [ difference ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> differences [ difference ] = [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = sorted ( differences . items ( ) ) <NEWLINE> print ( min ( ans [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> min_v = int ( input ( ) ) <NEWLINE> ans = 1 - min_v <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> j = int ( input ( ) ) <NEWLINE> ans = max ( ans , j - min_v ) <NEWLINE> min_v = min ( min_v , j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
def c_marks ( ) : <NEWLINE> <INDENT> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ <STRING> if A [ i + K ] > A [ i ] else <STRING> for i in range ( N - K ) ] <NEWLINE> return <STRING> . join ( ans ) <NEWLINE> <NL> <DEDENT> print ( c_marks ( ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> max_num = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if K >= a [ i ] + b [ j ] : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> s_cu = [ 0 ] * ( n + 1 ) <NEWLINE> counter = [ 0 ] * 2019 <NEWLINE> counter [ 0 ] += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s_cu [ i + 1 ] = ( int ( s [ n - i - 1 ] ) * pow ( 10 , i , 2019 ) + s_cu [ i ] ) % 2019 <NEWLINE> counter [ s_cu [ i + 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in counter : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> from collections import deque <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200001 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> graph [ u ] . append ( v ) <NEWLINE> graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 11 <NEWLINE> ans = [ 0 ] * N <NEWLINE> dp = [ ] <COMMENT> <NEWLINE> stack = deque ( [ ] ) <NEWLINE> <NL> def LISonTree ( num , pre ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> p = bisect_left ( dp , a [ num ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if p >= len ( dp ) : <NEWLINE> <INDENT> stack . appendleft ( ( len ( dp ) , INF ) ) <NEWLINE> dp . append ( a [ num ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . appendleft ( ( p , dp [ p ] ) ) <NEWLINE> dp [ p ] = a [ num ] <NEWLINE> <NL> <NL> <DEDENT> q = bisect_left ( dp , INF ) <NEWLINE> ans [ num ] = q <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for x in graph [ num ] : <NEWLINE> <INDENT> if x == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> LISonTree ( x , num ) <NEWLINE> <NL> <DEDENT> changed_p , changed_v = stack . popleft ( ) <NEWLINE> <NL> dp [ changed_p ] = changed_v <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> LISonTree ( 0 , - 1 ) <NEWLINE> <COMMENT> <NL> <NL> for y in ans : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def gcd_3 ( a , b , c ) : <NEWLINE> <INDENT> a = gcd ( gcd ( a , b ) , c ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> num = list ( itertools . combinations_with_replacement ( range ( 1 , k + 1 ) , 3 ) ) <NEWLINE> <NL> for l in num : <NEWLINE> <INDENT> a , b , c = l <NEWLINE> if a == b == c : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif a != b != c : <NEWLINE> <INDENT> ans += gcd_3 ( a , b , c ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd_3 ( a , b , c ) * 3 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> jnum = K - sum ( 1 for i in table if i >= 0 ) <NEWLINE> num_mins = sum ( 1 for i in table if i < 0 ) <NEWLINE> q_plus = deque ( sorted ( [ i for i in table if i >= 0 ] , reverse = True ) ) <NEWLINE> q_mins = deque ( sorted ( [ - i for i in table if i < 0 ] , reverse = True ) ) <NEWLINE> s_plus = [ ] <NEWLINE> s_mins = [ ] <NEWLINE> total = 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> if ( K % 2 == 1 and N == num_mins ) or ( N == K and num_mins % 2 == 1 ) : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if not q_plus : <NEWLINE> <INDENT> total = - total * q_mins . pop ( ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> elif not q_mins : <NEWLINE> <INDENT> total = total * q_plus . pop ( ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> elif q_plus [ - 1 ] > q_mins [ - 1 ] : <NEWLINE> <INDENT> total = - total * q_mins . pop ( ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = total * q_plus . pop ( ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> total = total % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if not q_plus : <NEWLINE> <INDENT> s_mins . append ( q_mins . popleft ( ) ) <NEWLINE> <DEDENT> elif not q_mins : <NEWLINE> <INDENT> s_plus . append ( q_plus . popleft ( ) ) <NEWLINE> <DEDENT> elif q_plus [ 0 ] > q_mins [ 0 ] : <NEWLINE> <INDENT> s_plus . append ( q_plus . popleft ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_mins . append ( q_mins . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( s_mins ) % 2 == 1 : <NEWLINE> <INDENT> if not q_plus : <NEWLINE> <INDENT> s_plus [ - 1 ] = q_mins [ 0 ] <NEWLINE> <DEDENT> elif not q_mins or not s_plus : <NEWLINE> <INDENT> s_mins [ - 1 ] = q_plus [ 0 ] <NEWLINE> <DEDENT> elif q_mins [ 0 ] * s_mins [ - 1 ] > q_plus [ 0 ] * s_plus [ - 1 ] : <NEWLINE> <INDENT> s_plus [ - 1 ] = q_mins [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_mins [ - 1 ] = q_plus [ 0 ] <NEWLINE> <DEDENT> <DEDENT> s_plus . extend ( s_mins ) <NEWLINE> for j in s_plus : <NEWLINE> <INDENT> total = total * j % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = sys . stdin . readline <NEWLINE> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b <= k : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a < k : <NEWLINE> <INDENT> b = b - ( k - a ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a - k <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> row = [ 0 ] * H <NEWLINE> column = [ 0 ] * W <NEWLINE> grid = set ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , readline ( ) . split ( ) ) <NEWLINE> row [ h - 1 ] += 1 <NEWLINE> column [ w - 1 ] += 1 <NEWLINE> grid . add ( ( h - 1 , w - 1 ) ) <NEWLINE> <NL> <DEDENT> max_row = max ( row ) <NEWLINE> max_column = max ( column ) <NEWLINE> <NL> idx_row = [ i for i , x in enumerate ( row ) if x == max_row ] <NEWLINE> idx_column = [ i for i , x in enumerate ( column ) if x == max_column ] <NEWLINE> <NL> ans = max_row + max_column <NEWLINE> flag = False <NEWLINE> <NL> for h in idx_row : <NEWLINE> <INDENT> for w in idx_column : <NEWLINE> <INDENT> if not ( h , w ) in grid : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def tax ( p , x ) : <NEWLINE> <INDENT> return p * ( 100 + x ) // 100 <NEWLINE> <NL> <DEDENT> def solve ( X , Y , S ) : <NEWLINE> <INDENT> best = 0 <NEWLINE> for a in range ( 1 , S ) : <NEWLINE> <INDENT> for b in range ( 1 , S ) : <NEWLINE> <INDENT> sum = tax ( a , X ) + tax ( b , X ) <NEWLINE> if sum == S : <NEWLINE> <INDENT> tmp = tax ( a , Y ) + tax ( b , Y ) <NEWLINE> if tmp > best : <NEWLINE> <INDENT> best = tmp <NEWLINE> <DEDENT> <DEDENT> if sum > S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return best <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> X , Y , S = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if X == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( solve ( X , Y , S ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x . append ( l [ n - 1 - i ] ) <NEWLINE> <DEDENT> for s in x : <NEWLINE> <INDENT> if ( s == x [ n - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> . format ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( s ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ [ ] for i in range ( n ) ] <NEWLINE> near = [ - 1 for i in range ( n ) ] <NEWLINE> near [ 0 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] . append ( b - 1 ) <NEWLINE> t [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( len ( t [ 0 ] ) ) : <NEWLINE> <INDENT> c = t [ 0 ] [ i ] <NEWLINE> near [ c ] = 0 <NEWLINE> q . append ( c ) <NEWLINE> <DEDENT> while len ( q ) > 0 : <NEWLINE> <INDENT> e = q . popleft ( ) <NEWLINE> for j in range ( len ( t [ e ] ) ) : <NEWLINE> <INDENT> c = t [ e ] [ j ] <NEWLINE> if near [ c ] == - 1 : <NEWLINE> <INDENT> near [ c ] = e <NEWLINE> q . append ( c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( near ) ) : <NEWLINE> <INDENT> print ( near [ i ] + 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if a - i not in c : <NEWLINE> <INDENT> ans = a - i <NEWLINE> break <NEWLINE> <DEDENT> elif a + i not in c : <NEWLINE> <INDENT> ans = a + i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> product = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( n ) : <NEWLINE> <INDENT> product = product * A [ x ] <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( product ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> d [ 0 ] = 1 <NEWLINE> <NL> num = 0 <NEWLINE> for digit , c in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> num += int ( c ) * pow ( 10 , digit , 2019 ) <NEWLINE> num %= 2019 <NEWLINE> d [ num ] += 1 <NEWLINE> <DEDENT> ans = sum ( [ d [ i ] * ( d [ i ] - 1 ) // 2 for i in range ( 2019 ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> def update_state ( state , newx ) : <NEWLINE> <INDENT> tmp = list ( state ) <NEWLINE> tmp [ newx ] = 1 <NEWLINE> return tuple ( tmp ) <NEWLINE> <NL> <DEDENT> def get_co ( x , y ) : <NEWLINE> <INDENT> dc = do = 0 <NEWLINE> score = mp [ y ] [ x ] <NEWLINE> if score < 0 : <NEWLINE> <INDENT> dc = - score <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> do = score <NEWLINE> <DEDENT> return dc , do <NEWLINE> <NL> <DEDENT> def minimum_cost ( x , y , state , ox , goal , dic , w , m ) : <NEWLINE> <INDENT> if ( x , y , state , ox ) in dic : <NEWLINE> <INDENT> return dic [ ( x , y , state , ox ) ] <NEWLINE> <DEDENT> if y == goal : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ox <= 1 : <NEWLINE> <INDENT> return INF <NEWLINE> <NL> <DEDENT> ret = INF <NEWLINE> <NL> if x >= 1 : <NEWLINE> <INDENT> if state [ x - 1 ] == 0 : <NEWLINE> <INDENT> dc , do = get_co ( x - 1 , y ) <NEWLINE> ret = min ( ret , minimum_cost ( x - 1 , y , update_state ( state , x - 1 ) , min ( ox + do - 1 , m ) , goal , dic , w , m ) + dc ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = min ( ret , minimum_cost ( x - 1 , y , state , ox - 1 , goal , dic , w , m ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if x < w - 1 : <NEWLINE> <INDENT> if state [ x + 1 ] == 0 : <NEWLINE> <INDENT> dc , do = get_co ( x + 1 , y ) <NEWLINE> ret = min ( ret , minimum_cost ( x + 1 , y , update_state ( state , x + 1 ) , min ( ox + do - 1 , m ) , goal , dic , w , m ) + dc ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = min ( ret , minimum_cost ( x + 1 , y , state , ox - 1 , goal , dic , w , m ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dc , do = get_co ( x , y + 1 ) <NEWLINE> ret = min ( ret , minimum_cost ( x , y + 1 , tuple ( ( 1 if i == x else 0 for i in range ( w ) ) ) , min ( ox + do - 1 , m ) , goal , dic , w , m ) + dc ) <NEWLINE> dic [ ( x , y , state , ox ) ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> f , m , o = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> if o <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> dic = { } <NEWLINE> ans = INF <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> dc , do = get_co ( i , 0 ) <NEWLINE> state = tuple ( 1 if i == j else 0 for j in range ( w ) ) <NEWLINE> ans = min ( ans , minimum_cost ( i , 0 , state , min ( o + do - 1 , m ) , h - 1 , dic , w , m ) + dc ) <NEWLINE> <DEDENT> if ans > f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main ( init = int ( 2 ** 31 - 1 ) , readline = stdin . readline ) : <NEWLINE> <INDENT> n , q = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> <NL> a = [ init ] * n <NEWLINE> b = [ init ] * ( ( n // 100 ) + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> if com : <NEWLINE> <INDENT> bx = x - ( x % 100 ) + 100 <NEWLINE> by = y - ( y % 100 ) <NEWLINE> if bx < by : <NEWLINE> <INDENT> m = min ( min ( a [ x : bx ] ) , min ( b [ bx // 100 : by // 100 ] ) , <NEWLINE> <INDENT> min ( a [ by : y + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = min ( a [ x : y + 1 ] ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ x ] = y <NEWLINE> bx = x - ( x % 100 ) <NEWLINE> b [ x // 100 ] = min ( a [ bx : bx + 100 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( X ) > K * D : <NEWLINE> <INDENT> X = abs ( X ) - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> T = abs ( X ) // D <NEWLINE> <COMMENT> <NL> Y = abs ( X ) % D <NEWLINE> <NL> <COMMENT> <NL> X = abs ( Y - ( ( K - T ) % 2 ) * D ) <NEWLINE> <NL> <DEDENT> print ( X ) <NEWLINE>
<NL> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import breadth_first_order <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> row = AB . T [ 0 ] - 1 <NEWLINE> col = AB . T [ 1 ] - 1 <NEWLINE> data = [ 1 ] * M <NEWLINE> csr = csr_matrix ( ( data , ( row , col ) ) , shape = ( N , N ) ) <NEWLINE> _ , proc = breadth_first_order ( csr , 0 , directed = False ) <NEWLINE> <NL> impos = any ( proc [ 1 : ] >= 0 ) <NEWLINE> if impos : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * proc [ 1 : ] + 1 , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ [ 0 ] * 2 for _ in range ( 101010 ) ] <NEWLINE> E = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <NL> def dfs ( cur , pre , d , id ) : <NEWLINE> <INDENT> D [ cur ] [ id ] = d <NEWLINE> for nv in E [ cur ] : <NEWLINE> <INDENT> if nv != pre : <NEWLINE> <INDENT> dfs ( nv , cur , d + 1 , id ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> E [ x ] . append ( y ) <NEWLINE> E [ y ] . append ( x ) <NEWLINE> <DEDENT> dfs ( a , a , 0 , 0 ) <NEWLINE> dfs ( b , b , 0 , 1 ) <NEWLINE> max_d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if D [ i ] [ 0 ] < D [ i ] [ 1 ] : <NEWLINE> <INDENT> max_d = max ( max_d , D [ i ] [ 1 ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( max_d ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> A_abs = sorted ( A , key = lambda x : abs ( x ) ) <NEWLINE> A_p = [ ] <COMMENT> <NEWLINE> A_n = [ ] <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> A_n . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_p . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> A_n . sort ( ) <NEWLINE> A_p . sort ( reverse = True ) <NEWLINE> <NL> ok = True <NEWLINE> if len ( A_p ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if N == K : <NEWLINE> <COMMENT> <NL> <INDENT> ok = ( len ( A_n ) % 2 == 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ok = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ok = ( K % 2 == 0 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if ok == False : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A_abs [ i ] <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> ans *= A_p [ 0 ] <NEWLINE> ans = ans % mod <NEWLINE> A_p = A_p [ 1 : ] <NEWLINE> <DEDENT> position = 0 <NEWLINE> pairs = [ ] <NEWLINE> cnt_p = len ( A_p ) <NEWLINE> cnt_n = len ( A_n ) <NEWLINE> while cnt_p - position > 1 : <NEWLINE> <INDENT> pairs . append ( A_p [ position ] * A_p [ position + 1 ] ) <NEWLINE> position += 2 <NEWLINE> <DEDENT> position = 0 <NEWLINE> while cnt_n - position > 1 : <NEWLINE> <INDENT> pairs . append ( A_n [ position ] * A_n [ position + 1 ] ) <NEWLINE> position += 2 <NEWLINE> <NL> <DEDENT> pairs . sort ( reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= pairs [ i ] <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pos = 0 <NEWLINE> visit = [ 0 ] * n <NEWLINE> move = [ ] <NEWLINE> roop = [ ] <NEWLINE> while visit [ pos ] != 2 : <NEWLINE> <INDENT> if visit [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( pos ) <NEWLINE> <DEDENT> visit [ pos ] += 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> <DEDENT> if len ( move ) > k : <NEWLINE> <INDENT> print ( move [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( k - ( len ( move ) - len ( roop ) ) ) % len ( roop ) ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in num : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in num : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( input ( ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> dflag = 0 <NEWLINE> cmin = 0 <NEWLINE> cmax = h [ 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if h [ i - 1 ] < h [ i ] and dflag == 1 : <NEWLINE> <INDENT> count += cmax - cmin <NEWLINE> cmax = h [ i ] <NEWLINE> dflag = 0 <NEWLINE> cmin = h [ i - 1 ] <NEWLINE> <NL> <DEDENT> elif h [ i - 1 ] > h [ i ] : <NEWLINE> <INDENT> dflag = 1 <NEWLINE> <NL> <DEDENT> elif h [ i - 1 ] < h [ i ] : <NEWLINE> <INDENT> cmax = h [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if dflag == 1 : <NEWLINE> <INDENT> count += cmax - cmin <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += max ( cmax , h [ i ] ) - cmin <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Smod = [ 0 ] * 2019 <NEWLINE> Smod [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> S_i = 0 <NEWLINE> prevmod = 0 <NEWLINE> k = 1 <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> S_i = ( int ( S [ i ] ) * k + prevmod ) % 2019 <NEWLINE> ans += Smod [ S_i ] <NEWLINE> Smod [ S_i ] += 1 <NEWLINE> prevmod = S_i <NEWLINE> k = ( k * 10 ) % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from decimal import * <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> x = Decimal ( a ) <NEWLINE> y = Decimal ( b ) <NEWLINE> <NL> print ( int ( x * y ) ) <NEWLINE>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> n = input ( ) <NEWLINE> tmp = input ( ) . split ( <STRING> ) <NEWLINE> l = sorted ( [ int ( e ) for e in tmp ] ) <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for e in l : <NEWLINE> <INDENT> res = e * res <NEWLINE> if res > 1e+18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> tmp = n <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <COMMENT> <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <COMMENT> <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> p_list = factorization ( n ) <NEWLINE> <NL> <NL> N = n <NEWLINE> cnt = 0 <NEWLINE> while N != 1 : <NEWLINE> <INDENT> for i in range ( len ( p_list ) ) : <NEWLINE> <INDENT> p = p_list [ i ] [ 0 ] <NEWLINE> for e in range ( 1 , p_list [ i ] [ 1 ] + 1 ) : <NEWLINE> <INDENT> z = p ** e <NEWLINE> if z > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N % z == 0 : <NEWLINE> <INDENT> N = N // z <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> s = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s_dict = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] in s_dict : <NEWLINE> <INDENT> s_dict [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_dict [ s [ i ] ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for j in s_dict . values ( ) : <NEWLINE> <INDENT> ans += j * ( j - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> a , b , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = min ( a ) + min ( b ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ans = min ( ans , ( a [ x [ i ] [ 0 ] - 1 ] + b [ x [ i ] [ 1 ] - 1 ] - x [ i ] [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def pr ( a ) : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == len ( a ) - 1 : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> l = len ( x ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . insert ( 0 , x [ 7 : ] ) <NEWLINE> <DEDENT> elif x [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( x [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif l > 10 : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif l > 6 : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * q ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> import math <NEWLINE> def setwise_coprime ( a ) : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = math . gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def create_sieve ( n ) : <NEWLINE> <INDENT> sieve = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if sieve [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> sieve [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sieve <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def fast_factorization ( n , sieve ) : <NEWLINE> <INDENT> prime = { } <NEWLINE> while n > 1 : <NEWLINE> <INDENT> p = sieve [ n ] <NEWLINE> <COMMENT> <NL> if p == 0 : <NEWLINE> <INDENT> prime [ n ] = prime . get ( n , 0 ) + 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> prime [ p ] = prime . get ( p , 0 ) + 1 <NEWLINE> n = n // p <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> check = set ( ) <NEWLINE> if setwise_coprime ( a ) == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> sieve = create_sieve ( 10 ** 6 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != 1 : <NEWLINE> <INDENT> s = fast_factorization ( a [ i ] , sieve ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check . add ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import collections <NEWLINE> a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> abi = int ( min ( a , b ) ) <NEWLINE> abm = int ( max ( a , b ) ) <NEWLINE> cdi = int ( min ( c , d ) ) <NEWLINE> cdm = int ( max ( c , d ) ) <NEWLINE> res1 = [ ] <NEWLINE> res2 = [ ] <NEWLINE> if abi < 0 and abm < 0 : <NEWLINE> <INDENT> res1 = [ abi , abm ] <NEWLINE> <DEDENT> elif abi < 0 and abm == 0 : <NEWLINE> <INDENT> res1 = [ abi , - 1 , 0 ] <NEWLINE> <DEDENT> elif abi < 0 and abm > 0 : <NEWLINE> <INDENT> res1 = [ abi , - 1 , 0 , 1 , abm ] <NEWLINE> <DEDENT> elif abi == 0 and abm == 0 : <NEWLINE> <INDENT> res1 = [ 0 ] <NEWLINE> <DEDENT> elif abi == 0 and abm > 0 : <NEWLINE> <INDENT> res1 = [ 0 , 1 , abm ] <NEWLINE> <DEDENT> elif abi > 0 and abm > 0 : <NEWLINE> <INDENT> res1 = [ abi , abm ] <NEWLINE> <NL> <DEDENT> if cdi < 0 and cdm < 0 : <NEWLINE> <INDENT> res2 = [ cdi , cdm ] <NEWLINE> <DEDENT> elif cdi < 0 and cdm == 0 : <NEWLINE> <INDENT> res2 = [ cdi , - 1 , 0 ] <NEWLINE> <DEDENT> elif cdi < 0 and cdm > 0 : <NEWLINE> <INDENT> res2 = [ cdi , - 1 , 0 , 1 , cdm ] <NEWLINE> <DEDENT> elif cdi == 0 and cdm == 0 : <NEWLINE> <INDENT> res2 = [ 0 ] <NEWLINE> <DEDENT> elif cdi == 0 and cdm > 0 : <NEWLINE> <INDENT> res2 = [ 0 , 1 , cdm ] <NEWLINE> <DEDENT> elif cdi > 0 and cdm > 0 : <NEWLINE> <INDENT> res2 = [ cdi , cdm ] <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> for g in res1 : <NEWLINE> <INDENT> for h in res2 : <NEWLINE> <INDENT> res . append ( g * h ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( max ( res ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <COMMENT> <NL> if ( 0 == int ( s [ : 2 ] ) or 13 <= int ( s [ : 2 ] ) ) and ( 0 == int ( s [ - 2 : ] ) or 13 <= int ( s [ - 2 : ] ) ) : <NEWLINE> <INDENT> print ( ans [ 3 ] ) <NEWLINE> <DEDENT> if 0 < int ( s [ : 2 ] ) <= 12 and 0 < int ( s [ - 2 : ] ) <= 12 : <NEWLINE> <INDENT> print ( ans [ 2 ] ) <NEWLINE> <DEDENT> elif 0 < int ( s [ : 2 ] ) <= 12 : <NEWLINE> <INDENT> print ( ans [ 1 ] ) <NEWLINE> <DEDENT> elif 0 < int ( s [ - 2 : ] ) <= 12 : <NEWLINE> <INDENT> print ( ans [ 0 ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = A [ 0 ] <NEWLINE> s = ( N - 2 ) // 2 <NEWLINE> if s > 0 : <NEWLINE> <INDENT> ans += sum ( A [ 1 : 1 + s ] ) * 2 <NEWLINE> <DEDENT> if ( N - 2 ) % 2 : <NEWLINE> <INDENT> ans += A [ 1 + s ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> c += a [ i ] * a [ i ] <NEWLINE> <DEDENT> ans = ( b * b - c ) // 2 <NEWLINE> ans %= 1000000007 <NEWLINE> print ( ans ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> [ print ( * x ) for x in [ [ sum ( j * k for j , k in zip ( x , y ) ) for y in zip ( * b ) ] for x in a ] ] <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> q = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ a [ 0 ] - 1 ] <= h [ a [ 1 ] - 1 ] : <NEWLINE> <INDENT> q . append ( a [ 0 ] ) <NEWLINE> <DEDENT> if h [ a [ 0 ] - 1 ] >= h [ a [ 1 ] - 1 ] : <NEWLINE> <INDENT> q . append ( a [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> p = set ( p ) <NEWLINE> q = set ( q ) <NEWLINE> print ( len ( p - q ) ) <NEWLINE>
N = input ( ) <NEWLINE> n = int ( N ) <NEWLINE> a = { input ( ) for i in range ( n ) } <NEWLINE> print ( len ( a ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import deque , defaultdict <NEWLINE> <NL> inp = lambda v , w : v [ 0 ] * w [ 0 ] + v [ 1 ] * w [ 1 ] <NEWLINE> isprop = lambda a , b : a [ 0 ] * b [ 1 ] == a [ 1 ] * b [ 0 ] <NEWLINE> cwsum = lambda l : [ sum ( [ x [ 0 ] for x in l ] ) , sum ( [ x [ 1 ] for x in l ] ) ] <NEWLINE> chmin = lambda a , b : ( a , b ) [ b < a ] <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> infty = 10 ** 9 <NEWLINE> ch = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> p = [ ( - 1 ) * Mb , Ma ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> pch = [ [ inp ( v [ : 2 ] , p ) , v [ 2 ] ] for v in ch ] <NEWLINE> X = N * max ( [ abs ( w [ 0 ] ) for w in pch ] ) <NEWLINE> dp = [ [ infty ] * ( 2 * X + 1 ) for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 2 * X + 1 ) : <NEWLINE> <INDENT> if i == 0 and j == X + pch [ 0 ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = pch [ 0 ] [ 1 ] <NEWLINE> <DEDENT> elif i > 0 and j == X + pch [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = chmin ( dp [ i - 1 ] [ j ] , pch [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif i > 0 and j >= pch [ i ] [ 0 ] and j <= 2 * X + pch [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = chmin ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - pch [ i ] [ 0 ] ] + pch [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ N - 1 ] [ X ] == infty : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ N - 1 ] [ X ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i < int ( n / 2 ) : <NEWLINE> <INDENT> print ( a [ n - 2 * i - 1 ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 2 * i - n ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i <= n // 2 : <NEWLINE> <INDENT> print ( a [ n - 2 * i - 1 ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 2 * i - n ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += A [ i ] * a [ i ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> inputlinevec = sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> n = int ( inputlinevec [ 0 ] ) <NEWLINE> x = int ( inputlinevec [ 1 ] ) <NEWLINE> m = int ( inputlinevec [ 2 ] ) <NEWLINE> <NL> sum_res = x <NEWLINE> crcle_dict = dict ( ) <NEWLINE> crcle_list = list ( ) <NEWLINE> crcle_idx = 0 <NEWLINE> pre_a = x <NEWLINE> <NL> for idx in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> this_a = ( pre_a * pre_a ) % m <NEWLINE> pre_a = this_a <NEWLINE> <NL> if this_a not in crcle_dict : <NEWLINE> <INDENT> crcle_dict [ this_a ] = 1 <NEWLINE> crcle_list . append ( this_a ) <NEWLINE> sum_res = sum_res + this_a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> crcle_step = len ( crcle_list ) - crcle_list . index ( this_a ) <NEWLINE> remain_crcle = int ( ( n - idx ) / crcle_step ) <NEWLINE> remain_crcle_tail = int ( ( n - idx ) % crcle_step ) <NEWLINE> <NL> crcle_sum = 0 <NEWLINE> crcle_sum_tail = 0 <NEWLINE> for a_item in crcle_list [ crcle_list . index ( this_a ) : ] : <NEWLINE> <INDENT> crcle_sum = crcle_sum + a_item <NEWLINE> remain_crcle_tail = remain_crcle_tail - 1 <NEWLINE> if remain_crcle_tail == 0 : <NEWLINE> <INDENT> crcle_sum_tail = crcle_sum <NEWLINE> <DEDENT> <DEDENT> sum_res = sum_res + ( remain_crcle * crcle_sum ) + crcle_sum_tail <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_res ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> def func ( x ) : <NEWLINE> <INDENT> return int ( a * x / b ) - a * int ( x / b ) <NEWLINE> <NL> <DEDENT> if n < b - 1 : <NEWLINE> <INDENT> print ( func ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( func ( b - 1 ) ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> N = int ( s [ 0 ] ) <NEWLINE> K = int ( s [ 1 ] ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> m1 = int ( A [ i - K ] ) <NEWLINE> m2 = int ( A [ i ] ) <NEWLINE> print ( <STRING> if m1 < m2 else <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> s = input ( ) <NEWLINE> listS = list ( s ) <NEWLINE> n = len ( listS ) <NEWLINE> <NL> aIndex = 0 <NEWLINE> zIndex = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if listS [ i ] == <STRING> : <NEWLINE> <INDENT> aIndex = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if listS [ - ( i + 1 ) ] == <STRING> : <NEWLINE> <INDENT> zIndex = n - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = zIndex - aIndex <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> nocontest = [ 1 for i in range ( 26 ) ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> contest = [ 0 for j in range ( 26 ) ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> contest [ j ] = c [ j ] * nocontest [ j ] * s [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> max_contest = max ( contest ) <NEWLINE> ans = contest . index ( max_contest ) <NEWLINE> print ( ans + 1 ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> if i == ans : <NEWLINE> <INDENT> nocontest [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nocontest [ i ] += 1 <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i <= x ** ( 0.5 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if is_prime ( int ( input ( ) ) ) : cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> print ( x // 3600 , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ( x // 60 ) % 60 , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( x % 60 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> maxv = - 2 * 10 ** 9 <NEWLINE> minv = 2 * 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = int ( input ( ) ) <NEWLINE> maxv = max ( maxv , v - minv ) <NEWLINE> minv = min ( minv , v ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
<COMMENT> <NL> <NL> import fileinput <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> a = float ( input ( ) ) <NEWLINE> PI = math . pi <NEWLINE> area = a * a * PI <NEWLINE> circum = 2 * a * PI <NEWLINE> <NL> print ( <STRING> % ( area , circum ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def do ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> k *= i <NEWLINE> if k > 1 * 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return k <NEWLINE> <DEDENT> print ( do ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 or a == N or b == 1 or b == N : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = False <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if 1 in G [ i ] and N in G [ i ] : <NEWLINE> <INDENT> res = True <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if res : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> def partition ( A , p , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> def quickSort ( A , p , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quickSort ( A , p , q - 1 ) <NEWLINE> quickSort ( A , q + 1 , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def is_stable ( A , B ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> cA = list ( A ) <NEWLINE> for x in B : <NEWLINE> <INDENT> i = cA . index ( x ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif cA [ i - 1 ] [ 1 ] == x [ 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> del cA [ i ] <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> r = int ( sys . stdin . readline ( ) ) - 1 <NEWLINE> <NL> A = [ ] <NEWLINE> <NL> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> suit , num = x . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> A . append ( [ suit , num ] ) <NEWLINE> <NL> <DEDENT> B = list ( A ) <NEWLINE> <NL> quickSort ( A , 0 , r ) <NEWLINE> <NL> if is_stable ( A , B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for x in A : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ap = [ a for a in A if a >= 0 ] <NEWLINE> An = [ - a for a in A if a < 0 ] <NEWLINE> Ap . sort ( ) <NEWLINE> Ap . reverse ( ) <NEWLINE> An . sort ( ) <NEWLINE> An . reverse ( ) <NEWLINE> <NL> if len ( Ap ) == 0 and K % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> An . reverse ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * - An [ i ] ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> B = [ ( a , 1 ) if a >= 0 else ( - a , - 1 ) for a in A ] <NEWLINE> B . sort ( ) <NEWLINE> B . reverse ( ) <NEWLINE> M = [ 0 if B [ 0 ] [ 1 ] > 0 else 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> M . append ( M [ i - 1 ] + ( 0 if B [ i ] [ 1 ] > 0 else 1 ) ) <NEWLINE> <NL> <DEDENT> i = K - 1 <NEWLINE> if M [ i ] % 2 == 0 or K == N : <NEWLINE> <INDENT> ans = 1 <NEWLINE> v = 1 if ( M [ i ] % 2 == 0 ) else - 1 <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * B [ j ] [ 0 ] ) % MOD <NEWLINE> <DEDENT> print ( ( ans * v ) % MOD ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = M [ i ] <NEWLINE> p = K - n <NEWLINE> if len ( An ) == n or p == 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> p += 1 <NEWLINE> <DEDENT> elif len ( Ap ) == p : <NEWLINE> <INDENT> n += 1 <NEWLINE> p -= 1 <NEWLINE> <DEDENT> elif Ap [ p - 1 ] * Ap [ p ] >= An [ n - 1 ] * An [ n ] : <NEWLINE> <INDENT> n -= 1 <NEWLINE> p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> p -= 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> ans = ( ans * Ap [ i ] ) % MOD <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ( ans * An [ i ] ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> numbers = line . split ( <STRING> ) <NEWLINE> for i , item in enumerate ( numbers ) : <NEWLINE> <INDENT> numbers [ i ] = int ( item ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> if ( ( numbers [ 0 ] > 0 ) and ( numbers [ 1 ] > 0 ) ) : <NEWLINE> <INDENT> for i in range ( numbers [ 0 ] ) : <NEWLINE> <INDENT> result += <STRING> * numbers [ 1 ] + <STRING> <NEWLINE> <DEDENT> result += <STRING> <NEWLINE> <DEDENT> elif ( ( numbers [ 0 ] == 0 ) and ( numbers [ 1 ] == 0 ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result [ : - 1 ] ) <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> from collections import Counter <NEWLINE> readline = stdin . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> S = [ readline ( ) [ : - 1 ] for _ in [ 0 ] * n ] <NEWLINE> <NL> s = Counter ( S ) <NEWLINE> most = s . most_common ( 1 ) [ 0 ] [ 1 ] <NEWLINE> <NL> answers = [ i [ 0 ] for i in s . items ( ) if i [ 1 ] == most ] <NEWLINE> answers = sorted ( answers ) <NEWLINE> <NL> for ans in answers : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> length = 0 <NEWLINE> ans = [ 0 ] * ( len ( s ) - len ( t ) + 1 ) <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( t ) - max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> import numpy as np <NEWLINE> <NL> l = np . array ( [ 0 ] * ( 10 ** 6 + 10 ) ) <NEWLINE> m = np . array ( [ 0 ] * ( 10 ** 6 + 10 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ A [ i ] ] += 1 <NEWLINE> m [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> length = len ( l ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> if m [ i ] >= 1 : <NEWLINE> <INDENT> l [ i : : i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : l . append ( i ) <NEWLINE> for i in range ( max ( B - K + 1 , A ) , B + 1 ) : l . append ( i ) <NEWLINE> l = sorted ( list ( set ( l ) ) ) <NEWLINE> for i in l : print ( i ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> out = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> out += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> print ( out [ : : - 1 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> L = defaultdict ( lambda : 0 ) <NEWLINE> R = defaultdict ( lambda : 0 ) <NEWLINE> for i , val in enumerate ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> L [ i - val ] += 1 <COMMENT> <NEWLINE> R [ i + val ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for key , val in L . items ( ) : <NEWLINE> <INDENT> if key > 0 : <NEWLINE> <INDENT> cnt += L [ key ] * R [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * ( N // i * ( N // i + 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for k in range ( t ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> l . append ( s ) <NEWLINE> <DEDENT> l = list ( dict . fromkeys ( l ) ) <NEWLINE> print ( len ( l ) ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> st = deque ( [ 1 ] ) <NEWLINE> check = [ 0 ] * ( N + 1 ) <NEWLINE> check [ 1 ] = 1 <NEWLINE> mark = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> while st : <NEWLINE> <INDENT> s = st . popleft ( ) <NEWLINE> for t in l [ s ] : <NEWLINE> <INDENT> if check [ t ] == 0 : <NEWLINE> <INDENT> mark [ t ] = s <NEWLINE> check [ t ] = 1 <NEWLINE> st . append ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if sum ( check ) == N : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( mark [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> drinks = list ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> drinks . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> drinks . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> while M > 0 : <NEWLINE> <INDENT> a , b = drinks . pop ( 0 ) <NEWLINE> if M <= b : <NEWLINE> <INDENT> ans += a * M <NEWLINE> M = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a * b <NEWLINE> M -= b <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if nums [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if n > 0 and nums [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n_nods = 1 <NEWLINE> ans = 1 <NEWLINE> ret = sum ( nums ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> n_nods = min ( n_nods * 2 , ret ) <NEWLINE> ans += n_nods <NEWLINE> ret -= nums [ i ] <NEWLINE> n_nods -= nums [ i ] <NEWLINE> if n_nods < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n_nods == 0 and i < n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> x1 = sorted ( X ) [ N // 2 - 1 ] <NEWLINE> x2 = sorted ( X ) [ N // 2 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] >= x2 : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x2 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , v = c . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a . appendleft ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a . remove ( v ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i - 1 ] > a [ i - k - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> if sys . platform == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> count = 0 <NEWLINE> n , r = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if n == r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for n1 in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for n2 in range ( n1 + 1 , n ) : <NEWLINE> <INDENT> for n3 in range ( n2 + 1 , n + 1 ) : <NEWLINE> <INDENT> if n1 + n2 + n3 == r : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from decimal import Decimal , ROUND_HALF_UP <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def check ( length : int ) -> bool : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> for a in A_list : <NEWLINE> <INDENT> if a >= length : <NEWLINE> <INDENT> quotient = a / length <NEWLINE> divide = - ( - quotient // 1 ) <COMMENT> <NEWLINE> cnt += ( divide - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ( True if cnt <= K else False ) <NEWLINE> <NL> <NL> <DEDENT> L = 0.1 <COMMENT> <NEWLINE> R = max ( A_list ) <COMMENT> <NEWLINE> <NL> while ( R - L ) > 0.01 : <NEWLINE> <INDENT> M = L + ( R - L ) / 2 <NEWLINE> <NL> if check ( M ) : <NEWLINE> <INDENT> R = M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = M <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = float ( Decimal ( str ( M ) ) . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) ) <NEWLINE> ans = - ( - ans // 1 ) <COMMENT> <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> inv_M = pow ( M - 1 , - 1 , MOD ) if M > 1 else 0 <NEWLINE> ans = 0 <NEWLINE> tmp = pow ( M - 1 , N - 1 , MOD ) if M > 1 else 0 <NEWLINE> comb = 1 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans = ( ans + M * comb * tmp ) % MOD <NEWLINE> if i == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = ( tmp * inv_M ) % MOD <NEWLINE> comb = ( comb * ( N - 1 - i ) * pow ( i + 1 , - 1 , MOD ) ) % MOD <NEWLINE> <DEDENT> if M == 1 and K == N - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l = min ( n % ( a + b ) , a ) <NEWLINE> s = n // ( a + b ) <NEWLINE> print ( s * a + l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> original_pop_cnt = x . count ( <STRING> ) <NEWLINE> <NL> pop_cnt_add = original_pop_cnt + 1 <NEWLINE> pop_cnt_sub = original_pop_cnt - 1 <NEWLINE> <NL> n_after_once_popcount_add = 0 <NEWLINE> n_after_once_popcount_sub = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> n_after_once_popcount_add = ( n_after_once_popcount_add * 2 + int ( x [ i ] ) ) % pop_cnt_add <NEWLINE> if pop_cnt_sub != 0 : <NEWLINE> <INDENT> n_after_once_popcount_sub = ( n_after_once_popcount_sub * 2 + int ( x [ i ] ) ) % pop_cnt_sub <NEWLINE> <NL> <DEDENT> <DEDENT> pow_add = [ 1 ] * 250000 <NEWLINE> pow_sub = [ 1 ] * 250000 <NEWLINE> for i in range ( 1 , n + 100 ) : <NEWLINE> <INDENT> pow_add [ i ] = ( pow_add [ i - 1 ] * 2 ) % pop_cnt_add <NEWLINE> if pop_cnt_sub != 0 : <NEWLINE> <INDENT> pow_sub [ i ] = ( pow_sub [ i - 1 ] * 2 ) % pop_cnt_sub <NEWLINE> <NL> <DEDENT> <DEDENT> def f ( nex ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> num = nex <NEWLINE> while num != 0 : <NEWLINE> <INDENT> num = num % bin ( num ) . count ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> nxt = n_after_once_popcount_add <NEWLINE> nxt = nxt + pow_add [ i ] <NEWLINE> nxt = nxt % pop_cnt_add <NEWLINE> print ( f ( nxt ) + 1 ) <NEWLINE> <DEDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if pop_cnt_sub != 0 : <NEWLINE> <INDENT> nxt = n_after_once_popcount_sub <NEWLINE> nxt = nxt - pow_sub [ i ] <NEWLINE> nxt = nxt % pop_cnt_sub <NEWLINE> print ( f ( nxt ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> def Solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ar = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in ar : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for x in ar : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> Solve ( ) <NEWLINE>
N = str ( input ( ) ) <NEWLINE> <NL> if len ( N ) < 4 : <NEWLINE> <INDENT> print ( 1000 - int ( N ) ) <NEWLINE> <DEDENT> elif len ( N ) == 5 : <NEWLINE> <INDENT> print ( 10000 - int ( N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = ( 1 + int ( N [ 0 ] ) ) * 1000 <NEWLINE> if int ( N ) % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - int ( N ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import sqrt , floor <NEWLINE> from sys import stdin <NEWLINE> <NL> def cntPrime ( n ) : <NEWLINE> <INDENT> mx = sqrt ( n ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> l = [ 0 , 1 ] + [ 1 , 0 ] * ( int ( n / 2 ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ 0 , 1 ] + [ 1 , 0 ] * ( int ( n / 2 ) - 1 ) + [ 1 ] <NEWLINE> <DEDENT> c = 3 <NEWLINE> while c < mx : <NEWLINE> <INDENT> for k in range ( c * 2 , n + 1 , c ) : <NEWLINE> <INDENT> l [ k - 1 ] = 0 <NEWLINE> <DEDENT> c = l [ ( c + 1 ) : ] . index ( 1 ) + c + 2 <NEWLINE> while c % 2 == 0 : <NEWLINE> <INDENT> c = l [ ( c + 1 ) : ] . index ( 1 ) + c + 2 <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <DEDENT> t = cntPrime ( 1000000 ) <NEWLINE> for n in stdin : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> print ( sum ( t [ : n ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . buffer . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , v = rm ( ) <NEWLINE> b , w = rm ( ) <NEWLINE> t = ri ( ) <NEWLINE> if v - w == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 0 <= abs ( a - b ) / ( v - w ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v_odd = [ ] <NEWLINE> v_even = [ ] <NEWLINE> for i , v in enumerate ( v ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> v_even . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_odd . append ( v ) <NEWLINE> <DEDENT> <DEDENT> odd_n = len ( v_odd ) <NEWLINE> even_n = len ( v_even ) <NEWLINE> v_odd = collections . Counter ( v_odd ) <NEWLINE> v_odd = sorted ( v_odd . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> v_even = collections . Counter ( v_even ) <NEWLINE> v_even = sorted ( v_even . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> if v_odd [ 0 ] == v_even [ 0 ] and 2 <= len ( v_odd ) and 2 <= len ( v_even ) : <NEWLINE> <INDENT> if v_odd [ 1 ] [ 1 ] < v_even [ 1 ] [ 1 ] : <NEWLINE> <INDENT> v_even . pop ( 0 ) <NEWLINE> <DEDENT> elif v_odd [ 1 ] [ 1 ] > v_even [ 1 ] [ 1 ] : <NEWLINE> <INDENT> v_odd . pop ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> num = v_odd [ 0 ] [ 0 ] <NEWLINE> <NL> ans = odd_n - v_odd [ 0 ] [ 1 ] <NEWLINE> st = 0 <NEWLINE> for i , v in v_even : <NEWLINE> <INDENT> if num == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = v <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans + ( even_n - st ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> boxes = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> boxes . append ( [ h , w ] ) <NEWLINE> <DEDENT> for i in boxes : <NEWLINE> <INDENT> print ( <STRING> * i [ 1 ] ) <NEWLINE> for j in range ( i [ 0 ] - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( i [ 1 ] - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * i [ 1 ] ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> z = 0 <NEWLINE> N = [ 0 ] * 10000 <NEWLINE> ans = 0 <NEWLINE> ko = 0 <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> ko = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ko <= n : <NEWLINE> <INDENT> N [ ko - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( N [ i ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> bl = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cl = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for b in bl : <NEWLINE> <INDENT> i = bisect . bisect_left ( al , b ) <NEWLINE> j = bisect . bisect_right ( cl , b ) <NEWLINE> ans += i * ( n - j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 13 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> nm = { } <NEWLINE> def nCr ( n , b ) : <NEWLINE> <INDENT> if b > n - b : <NEWLINE> <INDENT> b = n - b <NEWLINE> <DEDENT> key = ( n , b ) <NEWLINE> if key in nm : <NEWLINE> <INDENT> return nm [ key ] <NEWLINE> <DEDENT> r = 1 <NEWLINE> for k in range ( n , n - b , - 1 ) : <NEWLINE> <INDENT> r = r * k <NEWLINE> <DEDENT> d = 1 <NEWLINE> for k in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> d = d * k <NEWLINE> <DEDENT> nm [ key ] = r / d <NEWLINE> return nm [ key ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> n , m , l = LI ( ) <NEWLINE> ps = [ LI ( ) for _ in range ( n ) ] <NEWLINE> ts = [ ] <NEWLINE> rs = [ ] <NEWLINE> us = [ ] <NEWLINE> <NL> for p , t , v in ps : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> ts . append ( 0 ) <NEWLINE> rs . append ( 0 ) <NEWLINE> us . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> p /= 100 <NEWLINE> u = l / v <NEWLINE> ti = [ ] <NEWLINE> ri = [ ] <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> ti . append ( u + t * i ) <NEWLINE> k = pow ( 1 - p , m - i ) * pow ( p , i ) * nCr ( m , i ) <NEWLINE> ri . append ( k ) <NEWLINE> <DEDENT> ts . append ( ti ) <NEWLINE> rs . append ( ri ) <NEWLINE> ui = ri [ : ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> ui [ i ] += ui [ i - 1 ] <NEWLINE> <DEDENT> us . append ( ui ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if ts [ i ] == 0 : <NEWLINE> <INDENT> rr . append ( r ) <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( m + 1 ) : <NEWLINE> <INDENT> tr = rs [ i ] [ j ] <NEWLINE> tt = ts [ i ] [ j ] + 1.0 / 10 ** 10 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if i == k or ts [ k ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> bi = bisect . bisect_left ( ts [ k ] , tt ) <NEWLINE> if bi > 0 : <NEWLINE> <INDENT> tr *= 1 - us [ k ] [ bi - 1 ] <NEWLINE> <DEDENT> <DEDENT> r += tr <NEWLINE> <DEDENT> rr . append ( <STRING> . format ( r ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = n % k <NEWLINE> print ( min ( a , abs ( a - k ) ) ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
bldgs = [ ] <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> bldgs . append ( [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> bldgs [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i , bldg in enumerate ( bldgs ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> for floor in bldg : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( f ) for f in floor ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> d . append ( S ) <NEWLINE> <DEDENT> print ( len ( set ( d ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> <NL> point = deque ( ) <NEWLINE> point . append ( A . pop ( 0 ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans += point . popleft ( ) <NEWLINE> point . append ( i ) <NEWLINE> point . append ( i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = math . ceil ( math . sqrt ( N ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> def f ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> for i in range ( 1 , x ) : <NEWLINE> <INDENT> for j in range ( i , x ) : <NEWLINE> <INDENT> for k in range ( j , x ) : <NEWLINE> <INDENT> s = f ( i , j , k ) <NEWLINE> t = len ( set ( [ i , j , k ] ) ) <NEWLINE> if N >= s : <NEWLINE> <INDENT> if t == 3 : <NEWLINE> <INDENT> ans [ s - 1 ] += 6 <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> ans [ s - 1 ] += 3 <NEWLINE> <DEDENT> elif t == 1 : <NEWLINE> <INDENT> ans [ s - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def readInt ( ) : return int ( input ( ) ) <NEWLINE> def readIntList ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def readStringList ( ) : return list ( input ( ) ) <NEWLINE> def readStringListWithSpace ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def readString ( ) : return input ( ) <NEWLINE> <NL> n = readInt ( ) <NEWLINE> text = readStringList ( ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( text ) <NEWLINE> if c [ <STRING> ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i , j , count = 0 , len ( text ) - 1 , 0 <NEWLINE> <NL> while i <= j and i < len ( text ) : <NEWLINE> <INDENT> if text [ i ] == <STRING> : <NEWLINE> <INDENT> while text [ j ] != <STRING> and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i <= j and j > 0 : <NEWLINE> <INDENT> text [ i ] , text [ j ] = text [ j ] , text [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL>
n = int ( input ( ) . strip ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> if L [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for v in L : <NEWLINE> <INDENT> ans *= v <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> PI = math . pi <NEWLINE> <NL> r = input ( ) <NEWLINE> men = r * r * PI <NEWLINE> sen = r * 2 * PI <NEWLINE> <NL> print ( <STRING> % ( men , sen ) ) <NEWLINE>
<STRING> <NEWLINE> import queue <NEWLINE> dr = [ 0 , 0 , 1 , - 1 ] <NEWLINE> dc = [ 1 , - 1 , 0 , 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> a = [ int ( num ) for num in input ( ) . split ( <STRING> ) ] <NEWLINE> if a [ 0 ] == 0 : break <NEWLINE> s = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> s . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> q = queue . Queue ( ) <NEWLINE> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( a [ 1 ] ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : continue <NEWLINE> f = s [ i ] [ j ] <NEWLINE> l = [ [ i , j ] ] <NEWLINE> while len ( l ) != 0 : <NEWLINE> <INDENT> next_depth = [ ] <NEWLINE> for cor in l : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> r = cor [ 0 ] + dr [ k ] <NEWLINE> c = cor [ 1 ] + dc [ k ] <NEWLINE> if 0 <= r < a [ 0 ] and 0 <= c < a [ 1 ] and s [ r ] [ c ] == f : <NEWLINE> <INDENT> s [ r ] [ c ] = <STRING> <NEWLINE> next_depth . append ( [ r , c ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> l = next_depth <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
a = ord ( <STRING> ) <NEWLINE> rdif = range ( ord ( <STRING> ) - a + 1 ) <NEWLINE> l = [ 0 for _ in rdif ] <NEWLINE> s = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : s += input ( ) . lower ( ) <NEWLINE> except : break <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] . isalpha ( ) : l [ ord ( s [ i ] ) - a ] += 1 <NEWLINE> <DEDENT> for i in rdif : <NEWLINE> <INDENT> print ( chr ( i + a ) , <STRING> , l [ i ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> A . append ( i + A [ - 1 ] ) <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> B . append ( i + B [ - 1 ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] + A [ i ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n > m // 2 : <NEWLINE> <INDENT> print ( m // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> c = n % ( m // 2 ) <NEWLINE> d = m - 2 * c <NEWLINE> c += d // 4 <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> fn = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if fn > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i != j and j != k and k != i : <NEWLINE> <INDENT> ans [ fn - 1 ] += 6 <NEWLINE> <DEDENT> elif i == j and j == k : <NEWLINE> <INDENT> ans [ fn - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ fn - 1 ] += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> import time <NEWLINE> def steps ( n , p ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while n : <NEWLINE> <INDENT> c += 1 <NEWLINE> n = n % p <NEWLINE> p = bin ( n ) . count ( <STRING> ) <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> p = x . count ( <STRING> ) <NEWLINE> ans = [ ] <NEWLINE> num = int ( x , 2 ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == n - 1 or x [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> incs = 1 <NEWLINE> decs = 1 <NEWLINE> inc = num % ( p + 1 ) <NEWLINE> dec = num % ( p - 1 ) <NEWLINE> start = time . time ( ) <NEWLINE> k = - 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cp = p <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> cp += 1 <NEWLINE> new = ( inc + incs ) % cp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cp -= 1 <NEWLINE> new = ( dec - decs ) % cp <NEWLINE> <DEDENT> k -= 1 <NEWLINE> incs = ( incs * 2 ) % ( p + 1 ) <NEWLINE> decs = ( decs * 2 ) % ( p - 1 ) <NEWLINE> sol = steps ( new , cp ) <NEWLINE> if sol == 0 : <NEWLINE> <INDENT> sol = 1 <NEWLINE> <DEDENT> ans . append ( sol ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
def selections ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i + 1 , len ( N ) ) : <NEWLINE> <INDENT> if N [ mini ] > N [ j ] : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> if i != mini : <NEWLINE> <INDENT> N [ mini ] , N [ i ] = N [ i ] , N [ mini ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> c = 1 <NEWLINE> for i in N : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> if c < len ( N ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( count ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> selections ( numbers ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = list ( range ( N ) ) <NEWLINE> rank = [ 1 ] * N <NEWLINE> size = [ 1 ] * N <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( par [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ x ] = y <NEWLINE> size [ y ] += size [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ y ] = x <NEWLINE> size [ x ] += size [ y ] <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> print ( max ( size ) ) <NEWLINE>
import collections <NEWLINE> <NL> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> smat = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> def bfs ( x0 , y0 ) : <NEWLINE> <INDENT> visited = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> deq = collections . deque ( ) <NEWLINE> deq . append ( ( x0 , y0 , - 1 ) ) <NEWLINE> <NL> mx = 0 <NEWLINE> while len ( deq ) > 0 : <NEWLINE> <INDENT> x , y , d = deq . popleft ( ) <NEWLINE> nd = d + 1 <NEWLINE> visited [ x ] [ y ] = 1 <NEWLINE> mx = max ( mx , nd ) <NEWLINE> <NL> for dx , dy in [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( + 1 , 0 ) , ( 0 , + 1 ) ] : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> if not ( 0 <= nx < h ) or not ( 0 <= ny < w ) : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> if smat [ nx ] [ ny ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> if visited [ nx ] [ ny ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> v = ( nx , ny , nd ) <NEWLINE> deq . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> return mx <NEWLINE> <NL> <DEDENT> if all ( all ( col == <STRING> for col in row ) for row in smat ) : <NEWLINE> <INDENT> print ( ( w - 1 ) + ( h - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mxall = 0 <NEWLINE> for x0 in range ( h ) : <NEWLINE> <INDENT> for y0 in range ( w ) : <NEWLINE> <INDENT> if smat [ x0 ] [ y0 ] == <STRING> : <NEWLINE> <INDENT> mx = bfs ( x0 , y0 ) <NEWLINE> mxall = max ( mxall , mx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mxall ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def calc ( vals ) : <NEWLINE> <INDENT> val , * vals = vals <NEWLINE> for v in vals : <NEWLINE> <INDENT> val ^= v <NEWLINE> <DEDENT> return val <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> total = calc ( lis ) <NEWLINE> for val in lis : <NEWLINE> <INDENT> ans . append ( total ^ val ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> import warnings <NEWLINE> warnings . filterwarnings ( <STRING> ) <NEWLINE> <NL> N , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> v = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w [ i + 1 ] , v [ i + 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dp = np . array ( [ [ 0 ] * ( W + 1 ) ] * ( N + 1 ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp_arr = np . zeros ( W + 1 , dtype = int ) <NEWLINE> tmp_arr = np . zeros ( W + 1 , dtype = int ) <NEWLINE> tmp_arr [ w [ i ] : ] = dp [ i - 1 ] [ : - w [ i ] ] + v [ i ] <NEWLINE> dp [ i ] = np . maximum ( dp [ i - 1 ] , tmp_arr ) <NEWLINE> <NL> <DEDENT> print ( dp [ N , W ] ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> <NL> N = 0 <NEWLINE> M = 0 <NEWLINE> <NL> def next_num ( x ) : <NEWLINE> <INDENT> if int ( x [ - 1 ] ) < M : <NEWLINE> <INDENT> return x [ : - 1 ] + [ str ( int ( x [ - 1 ] ) + 1 ) ] <NEWLINE> <DEDENT> elif int ( x [ - 1 ] ) == M : <NEWLINE> <INDENT> oya = next_num ( x [ : - 1 ] ) <NEWLINE> return oya + [ oya [ - 1 ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( N : int , M : int , Q : int , a : <STRING> , b : <STRING> , c : <STRING> , d : <STRING> ) : <NEWLINE> <INDENT> start = [ <STRING> for i in range ( N ) ] <NEWLINE> current = start <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> result = 0 <NEWLINE> for a_ , b_ , c_ , d_ in zip ( a , b , c , d ) : <NEWLINE> <INDENT> if int ( current [ b_ ] ) - int ( current [ a_ ] ) == c_ : <NEWLINE> <INDENT> result += d_ <NEWLINE> <DEDENT> <DEDENT> if result > ans : <NEWLINE> <INDENT> ans = result <NEWLINE> <DEDENT> if current [ 0 ] == str ( M ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> current = next_num ( current ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global N , M <NEWLINE> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> Q = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> c = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> d = [ int ( ) ] * ( Q ) <COMMENT> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) - 1 <NEWLINE> b [ i ] = int ( next ( tokens ) ) - 1 <NEWLINE> c [ i ] = int ( next ( tokens ) ) <NEWLINE> d [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> solve ( N , M , Q , a , b , c , d ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> dic [ tmp ] += 1 <NEWLINE> <DEDENT> print ( len ( dic ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> aaa = 2 <NEWLINE> maxi = 2 <NEWLINE> def prime ( aaa ) : <NEWLINE> <INDENT> global primemode <NEWLINE> if n != 1 : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i * i <= aaa : <NEWLINE> <INDENT> if aaa % i == 0 : <NEWLINE> <INDENT> primemode = False <NEWLINE> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> if prime ( n ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> a = 0 <NEWLINE> i = 2 <NEWLINE> while i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> n /= i <NEWLINE> i -= 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> elif a == i : <NEWLINE> <INDENT> n /= i <NEWLINE> i -= 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> def divisors ( a , i ) : <NEWLINE> <INDENT> global ans , aaa , maxi , primemode <NEWLINE> while i <= n and i <= a : <NEWLINE> <INDENT> if i * i <= a and primemode : <NEWLINE> <INDENT> if prime ( a ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a % i == 0 : <NEWLINE> <INDENT> if make_divisors ( i ) : <NEWLINE> <INDENT> primemode = True <NEWLINE> ans += 1 <NEWLINE> num = a / i <NEWLINE> aaa = num <NEWLINE> if maxi <= i : <NEWLINE> <INDENT> maxi = i <NEWLINE> <DEDENT> divisors ( num , i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if prime ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> divisors ( n , 2 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( N , Q , C , LR , A ) : <NEWLINE> <INDENT> data = [ 0 ] * ( N + 1 ) <NEWLINE> def add ( i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= N : <NEWLINE> <INDENT> data [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def sum ( a , b ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> i = b <NEWLINE> while i > 0 : <NEWLINE> <INDENT> r += data [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> i = a <NEWLINE> while i > 0 : <NEWLINE> <INDENT> r -= data [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> p = [ - 1 ] * N <NEWLINE> q = 0 <NEWLINE> a = [ 0 ] * Q <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ C [ i ] - 1 ] >= 0 : <NEWLINE> <INDENT> add ( p [ C [ i ] - 1 ] , - 1 ) <NEWLINE> <DEDENT> p [ C [ i ] - 1 ] = i <NEWLINE> add ( i , 1 ) <NEWLINE> while q < Q and LR [ A [ q ] ] [ 1 ] == i + 1 : <NEWLINE> <INDENT> a [ A [ q ] ] = sum ( LR [ A [ q ] ] [ 0 ] - 1 , LR [ A [ q ] ] [ 1 ] ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import * <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc_export ( main , ( i8 , i8 , i8 [ : ] , i8 [ : , : ] , i8 [ : ] ) ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> def input ( ) : return sys . stdin . buffer . readline ( ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> C = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> LR_ = [ 0 ] * ( Q * 2 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> LR_ [ i * 2 ] , LR_ [ i * 2 + 1 ] = input ( ) . split ( ) <NEWLINE> <DEDENT> LR = np . array ( LR_ , dtype = np . int64 ) . reshape ( Q , 2 ) <NEWLINE> <COMMENT> <NL> A = np . argsort ( LR [ : , 1 ] ) <NEWLINE> <NL> from my_module import main <NEWLINE> print ( * main ( N , Q , C , LR , A ) , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import networkx as nx <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> match_list = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a , b = ab [ i ] <NEWLINE> c , d = cd [ j ] <NEWLINE> <NL> if a < c and b < d : <NEWLINE> <INDENT> match_list [ i ] . append ( j ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> group1 = range ( n ) <NEWLINE> group2 = range ( n , 2 * n ) <NEWLINE> <NL> g = nx . Graph ( ) <NEWLINE> g . add_nodes_from ( group1 , bipartite = 1 ) <NEWLINE> g . add_nodes_from ( group2 , bipartite = 0 ) <NEWLINE> <NL> for i , list_ in enumerate ( match_list ) : <NEWLINE> <INDENT> for j in list_ : <NEWLINE> <INDENT> g . add_edge ( i , j + n , weight = 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> d = nx . max_weight_matching ( g ) <NEWLINE> <NL> print ( len ( d ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> As = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> deff_list = [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> deff_list . append ( As [ i ] - As [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> prev = 1000 <NEWLINE> res = 1000 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if deff_list [ i ] >= 0 : <NEWLINE> <INDENT> res = ( prev // As [ i - 1 ] ) * As [ i ] + prev % As [ i - 1 ] <NEWLINE> <NL> <DEDENT> prev = res <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> i = 0 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x = ( x * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nn = lambda : list ( stdin . readline ( ) . split ( ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += d [ i - a [ i ] ] <NEWLINE> d [ a [ i ] + i ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def mod_pow ( x , a , MOD ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> cur = x <NEWLINE> while a : <NEWLINE> <INDENT> if a & 1 : <NEWLINE> <INDENT> ret = ret * cur % MOD <NEWLINE> <DEDENT> cur = cur * cur % MOD <NEWLINE> a >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def prepare ( n , MOD ) : <NEWLINE> <INDENT> factorials = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> factorials [ i ] = factorials [ i - 1 ] * i % MOD <NEWLINE> <DEDENT> finvs = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> finvs [ n ] = mod_pow ( factorials [ n ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> finvs [ i - 1 ] = finvs [ i ] * i % MOD <NEWLINE> <DEDENT> return factorials , finvs <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( k , ls ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> facts , finvs = prepare ( k + ls , MOD ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> r = k - i <NEWLINE> pat = facts [ ls + r - 1 ] * finvs [ ls - 1 ] % MOD * finvs [ r ] % MOD <NEWLINE> ans = ( ans + pat * mod_pow ( 25 , r , MOD ) % MOD * mod_pow ( 26 , i , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( solve ( k , len ( s ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> answer = 1 <NEWLINE> flag = 0 <NEWLINE> x = 10 ** 18 <NEWLINE> <NL> if <STRING> in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> answer *= int ( A [ i ] ) <NEWLINE> if answer > x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from math import gcd <NEWLINE> cm = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cm = cm * a [ i ] // gcd ( cm , a [ i ] ) <NEWLINE> <DEDENT> ai = sum ( pow ( x , mod - 2 , mod ) for x in a ) <NEWLINE> print ( int ( ai * cm % mod ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> keys = list ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> memo = defaultdict ( int ) <NEWLINE> count = 0 <NEWLINE> for i , x in enumerate ( values ) : <NEWLINE> <INDENT> count += memo [ i - x ] <NEWLINE> memo [ i + x ] += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 1 <NEWLINE> ans = <STRING> <NEWLINE> while ( k * n ) <= b : <NEWLINE> <INDENT> if ( k * n ) >= a and ( k * n ) <= b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> ( x , y ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x == y == 0 : break <NEWLINE> print ( <STRING> * y ) <NEWLINE> for i in range ( 1 , x - 1 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( y - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * y ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = input ( ) <NEWLINE> a = l . split ( <STRING> ) <NEWLINE> <NL> tmp = 0 <NEWLINE> total2 = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp += int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> total2 += int ( a [ i ] ) * ( tmp - int ( a [ i ] ) ) <NEWLINE> tmp -= int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( total2 % 1000000007 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( 10001 ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v < 10001 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def search ( values , hp , vp , item ) : <NEWLINE> <INDENT> if not ( 0 <= hp < len ( values ) ) : return <NEWLINE> if not ( 0 <= vp < len ( values [ hp ] ) ) : return <NEWLINE> if item != values [ hp ] [ vp ] : return <NEWLINE> values [ hp ] [ vp ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> search ( values , hp - 1 , vp , item ) <NEWLINE> search ( values , hp + 1 , vp , item ) <NEWLINE> search ( values , hp , vp - 1 , item ) <NEWLINE> search ( values , hp , vp + 1 , item ) <NEWLINE> <NL> <DEDENT> def solve ( values ) : <NEWLINE> <INDENT> count , valid_items = 0 , set ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> for j in range ( len ( values [ i ] ) ) : <NEWLINE> <INDENT> if values [ i ] [ j ] in valid_items : <NEWLINE> <INDENT> search ( values , i , j , values [ i ] [ j ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line , values = input ( ) . strip ( ) , list ( ) <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> H , W = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> value = list ( ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <COMMENT> <NL> <INDENT> value . append ( list ( input ( ) . strip ( ) ) ) <NEWLINE> <DEDENT> print ( solve ( value ) ) <NEWLINE> <COMMENT> <NL> line = input ( ) . strip ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> count = count * i <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for r in range ( 4 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = a [ 0 ] [ 0 ] - 1 <NEWLINE> f = a [ 0 ] [ 1 ] - 1 <NEWLINE> r = a [ 0 ] [ 2 ] - 1 <NEWLINE> v = a [ 0 ] [ 3 ] <NEWLINE> arr [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , arr [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , arr [ 3 ] [ i ] ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd , val = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> d . add ( val ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( val in d ) or <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> import networkx as nx <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> MAX = 10 ** 15 <NEWLINE> N , M , S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( range ( 1 , N + 1 ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( u , v , yen = a , snuuk = b ) <NEWLINE> <NL> <DEDENT> yen_path = nx . single_source_dijkstra_path_length ( G , S , weight = <STRING> ) <NEWLINE> snuuk_path = nx . single_source_dijkstra_path_length ( G , T , weight = <STRING> ) <NEWLINE> <NL> ans = [ MAX ] * ( N + 1 ) <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> ans [ i - 1 ] = min ( ans [ i ] , yen_path [ i ] + snuuk_path [ i ] ) <NEWLINE> <DEDENT> for x in ans [ : N ] : <NEWLINE> <INDENT> print ( MAX - x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> li = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i * j <= n : <NEWLINE> <INDENT> li [ i * j ] += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( li [ 1 : n ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> gl = [ [ 0 ] * K for _ in range ( K ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> gl [ i ] [ j ] = math . gcd ( i + 1 , j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> tmp = gl [ i ] [ j ] <NEWLINE> res += gl [ tmp - 1 ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> btfl = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> btfl . append ( a [ j ] - a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 50 ) [ : : - 1 ] : <NEWLINE> <INDENT> num , cnt = ans + pow ( 2 , i ) , 0 <NEWLINE> for b in btfl : <NEWLINE> <INDENT> if num == num & b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> ans = num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def root ( x , root_ls ) : <NEWLINE> <INDENT> if root_ls [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root_ls [ x ] = root ( root_ls [ x ] , root_ls ) <NEWLINE> return root_ls [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( a , b , root_ls ) : <NEWLINE> <INDENT> a = root ( a , root_ls ) <NEWLINE> b = root ( b , root_ls ) <NEWLINE> if a != b : <NEWLINE> <INDENT> root_ls [ a ] += root_ls [ b ] <NEWLINE> root_ls [ b ] = a <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> members = [ - 1 for i in range ( n ) ] <NEWLINE> max_idx = 0 <NEWLINE> for mm in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> unite ( a - 1 , b - 1 , members ) <NEWLINE> <DEDENT> print ( max ( [ - m for m in members ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = s * a [ i ] <NEWLINE> if s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
import queue <NEWLINE> I = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> N , M = I ( ) <NEWLINE> ls = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in [ 0 ] * M : <NEWLINE> <INDENT> A , B = I ( ) <NEWLINE> ls [ A ] += [ B ] <NEWLINE> ls [ B ] += [ A ] <NEWLINE> <DEDENT> q = queue . Queue ( ) <NEWLINE> v = [ - 1 ] * ( N + 1 ) <NEWLINE> v [ 0 ] = v [ 1 ] = 0 <NEWLINE> q . put ( 1 ) <NEWLINE> while not ( q . empty ( ) ) : <NEWLINE> <INDENT> top = q . get ( ) <NEWLINE> for l in ls [ top ] : <NEWLINE> <INDENT> if v [ l ] < 0 : <NEWLINE> <INDENT> v [ l ] = top <NEWLINE> q . put ( l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if - 1 in v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> [ print ( k ) for k in v [ 2 : : ] ] <NEWLINE> <DEDENT>
import math <NEWLINE> abc = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> tmp = 9 <NEWLINE> ans = 0 <NEWLINE> ii = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> tmpp = min ( tmp , ( abc [ i ] - 1 ) % 10 ) <NEWLINE> if tmp != tmpp : <NEWLINE> <INDENT> tmp = tmpp <NEWLINE> ii = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == ii : <NEWLINE> <INDENT> ans += abc [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( math . ceil ( abc [ i ] / 10 ) ) * 10 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nmax = 0 <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b [ j ] + a [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> MOD = 998244353 <NEWLINE> N , M , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> f = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> f . append ( f [ i ] * ( i + 1 ) % MOD ) <NEWLINE> <NL> <DEDENT> f_inv = [ 1 ] * N <NEWLINE> f_inv [ N - 1 ] = pow ( f [ N - 1 ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( N - 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> f_inv [ i ] = f_inv [ i + 1 ] * ( i + 1 ) % MOD <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def comb_mod ( n , r , p ) : <NEWLINE> <INDENT> return ( f [ n ] * f_inv [ r ] * f_inv [ n - r ] ) % p <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans = ( ans + ( M * pow ( M - 1 , N - 1 - i , MOD ) ) * comb_mod ( N - 1 , i , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for ai in A : <NEWLINE> <INDENT> a . append ( a [ - 1 ] + ai ) <NEWLINE> <NL> <DEDENT> for bi in B : <NEWLINE> <INDENT> b . append ( b [ - 1 ] + bi ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> bs = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in reversed ( range ( bs + 1 ) ) : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> bs = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> if sys . version [ 0 ] == <STRING> : <NEWLINE> <INDENT> range , input = xrange , raw_input <NEWLINE> <NL> <NL> <DEDENT> class FenwickTree : <NEWLINE> <INDENT> def __init__ ( self , a_list , f , default ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . N = len ( a_list ) <NEWLINE> self . bit = a_list [ : ] <NEWLINE> self . f = f <NEWLINE> self . default = default <NEWLINE> for _ in range ( self . N , 1 << int ( math . ceil ( math . log ( self . N , 2 ) ) ) ) : <NEWLINE> <INDENT> self . bit . append ( self . default ) <NEWLINE> <DEDENT> for i in range ( self . N - 1 ) : <NEWLINE> <INDENT> self . bit [ i | ( i + 1 ) ] = self . f ( self . bit [ i | ( i + 1 ) ] , self . bit [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , i , val ) : <NEWLINE> <INDENT> while i < self . N : <NEWLINE> <INDENT> self . bit [ i ] = self . f ( self . bit [ i ] , val ) <NEWLINE> i |= i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ret = 0 <NEWLINE> while n >= 0 : <NEWLINE> <INDENT> ret = self . f ( ret , self . bit [ n ] ) <NEWLINE> n = ( n & ( n + 1 ) ) - 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> dp = FenwickTree ( [ 0 ] * N , lambda x , y : max ( x , y ) , 0 ) <NEWLINE> for x , i in sorted ( ( x , i ) for i , x in enumerate ( X ) ) : <NEWLINE> <INDENT> dp . update ( i , dp . query ( i ) + x ) <NEWLINE> <DEDENT> print ( N * ( N + 1 ) // 2 - dp . query ( N - 1 ) ) <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> array = [ ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> row = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> row . append ( sum ( row ) ) <NEWLINE> array . append ( row ) <NEWLINE> print ( * row ) <NEWLINE> <NL> <DEDENT> last_array = [ ] <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for a in array : <NEWLINE> <INDENT> total += a [ i ] <NEWLINE> <DEDENT> last_array . append ( total ) <NEWLINE> <DEDENT> print ( * last_array ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lst . add ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( len ( lst ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> first_A_find = s . find ( <STRING> ) <NEWLINE> end_Z_find = s . rfind ( <STRING> ) + 1 <NEWLINE> <NL> print ( end_Z_find - first_A_find ) <NEWLINE>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) + int ( input ( ) ) <NEWLINE> if ( n >= 10 ** 80 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp_s = { i for i in range ( A , A + K ) } <NEWLINE> tmp_l = { i for i in range ( B + 1 - K , B + 1 ) } <NEWLINE> <NL> ans = list ( tmp_s . union ( tmp_l ) ) <NEWLINE> ans = [ i for i in ans if A <= i <= B ] <NEWLINE> ans . sort ( ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 1 ] + A <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> target = 2019 <NEWLINE> res = 0 <NEWLINE> dic = defaultdict ( int ) <NEWLINE> dic [ 0 ] = 1 <NEWLINE> s = s [ : : - 1 ] <NEWLINE> num , d = 0 , 1 <NEWLINE> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= target <NEWLINE> d *= 10 <NEWLINE> d %= target <NEWLINE> dic [ num ] += 1 <NEWLINE> <DEDENT> for i in dic . values ( ) : <NEWLINE> <INDENT> res += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> arr = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> F1 = True <NEWLINE> for y in range ( x , N + 1 ) : <NEWLINE> <INDENT> F2 = True <NEWLINE> for z in range ( y , N + 1 ) : <NEWLINE> <INDENT> n = ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) + ( x * y ) + ( y * z ) + ( z * x ) <NEWLINE> if n > N : <NEWLINE> <INDENT> if y == z : <NEWLINE> <INDENT> F2 = False <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> arr [ n ] += 1 <NEWLINE> <DEDENT> elif ( x == y ) or ( y == z ) or ( z == x ) : <NEWLINE> <INDENT> arr [ n ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ n ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if F2 == False : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> F1 = False <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> if F1 == False : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in arr [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <NEWLINE> points_list = [ [ x1 , y1 ] , [ x2 , y2 ] , [ x3 , y3 ] ] <NEWLINE> points_list . sort ( ) <NEWLINE> <NL> if points_list [ 0 ] [ 0 ] == points_list [ 1 ] [ 0 ] : <NEWLINE> <INDENT> py = ( points_list [ 0 ] [ 1 ] + points_list [ 1 ] [ 1 ] ) / 2 <NEWLINE> if points_list [ 2 ] [ 1 ] == points_list [ 0 ] [ 1 ] : <NEWLINE> <INDENT> px = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a2_s = ( points_list [ 2 ] [ 1 ] - points_list [ 0 ] [ 1 ] ) / ( points_list [ 2 ] [ 0 ] - points_list [ 0 ] [ 0 ] ) <NEWLINE> a2 = - 1 / a2_s <NEWLINE> m13x = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> m13y = ( points_list [ 0 ] [ 1 ] + points_list [ 2 ] [ 1 ] ) / 2 <NEWLINE> b2 = m13y - a2 * m13x <NEWLINE> px = ( py - b2 ) / a2 <NEWLINE> <DEDENT> <DEDENT> elif points_list [ 1 ] [ 0 ] == points_list [ 2 ] [ 0 ] : <NEWLINE> <INDENT> py = ( points_list [ 1 ] [ 1 ] + points_list [ 2 ] [ 1 ] ) / 2 <NEWLINE> if points_list [ 2 ] [ 1 ] == points_list [ 0 ] [ 1 ] : <NEWLINE> <INDENT> px = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a2_s = ( points_list [ 2 ] [ 1 ] - points_list [ 0 ] [ 1 ] ) / ( points_list [ 2 ] [ 0 ] - points_list [ 0 ] [ 0 ] ) <NEWLINE> a2 = - 1 / a2_s <NEWLINE> m13x = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> m13y = ( points_list [ 0 ] [ 1 ] + points_list [ 2 ] [ 1 ] ) / 2 <NEWLINE> b2 = m13y - a2 * m13x <NEWLINE> px = ( py - b2 ) / a2 <NEWLINE> <DEDENT> <DEDENT> elif points_list [ 0 ] [ 1 ] == points_list [ 1 ] [ 1 ] : <NEWLINE> <INDENT> px = ( points_list [ 0 ] [ 0 ] + points_list [ 1 ] [ 0 ] ) / 2 <NEWLINE> a2_s = ( points_list [ 2 ] [ 1 ] - points_list [ 0 ] [ 1 ] ) / ( points_list [ 2 ] [ 0 ] - points_list [ 0 ] [ 0 ] ) <NEWLINE> a2 = - 1 / a2_s <NEWLINE> m13x = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> m13y = ( points_list [ 0 ] [ 1 ] + points_list [ 2 ] [ 1 ] ) / 2 <NEWLINE> b2 = m13y - a2 * m13x <NEWLINE> py = a2 * px + b2 <NEWLINE> <DEDENT> elif points_list [ 0 ] [ 1 ] == points_list [ 2 ] [ 1 ] : <NEWLINE> <INDENT> px = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> a1_s = ( points_list [ 1 ] [ 1 ] - points_list [ 0 ] [ 1 ] ) / ( points_list [ 1 ] [ 0 ] - points_list [ 0 ] [ 0 ] ) <NEWLINE> a1 = - 1 / a1_s <NEWLINE> m12x = ( points_list [ 0 ] [ 0 ] + points_list [ 1 ] [ 0 ] ) / 2 <NEWLINE> m12y = ( points_list [ 0 ] [ 1 ] + points_list [ 1 ] [ 1 ] ) / 2 <NEWLINE> b1 = m12y - a1 * m12x <NEWLINE> py = a1 * px + b1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1_s = ( points_list [ 1 ] [ 1 ] - points_list [ 0 ] [ 1 ] ) / ( points_list [ 1 ] [ 0 ] - points_list [ 0 ] [ 0 ] ) <NEWLINE> a1 = - 1 / a1_s <NEWLINE> a2_s = ( points_list [ 2 ] [ 1 ] - points_list [ 0 ] [ 1 ] ) / ( points_list [ 2 ] [ 0 ] - points_list [ 0 ] [ 0 ] ) <NEWLINE> a2 = - 1 / a2_s <NEWLINE> m12x = ( points_list [ 0 ] [ 0 ] + points_list [ 1 ] [ 0 ] ) / 2 <NEWLINE> m12y = ( points_list [ 0 ] [ 1 ] + points_list [ 1 ] [ 1 ] ) / 2 <NEWLINE> m13x = ( points_list [ 0 ] [ 0 ] + points_list [ 2 ] [ 0 ] ) / 2 <NEWLINE> m13y = ( points_list [ 0 ] [ 1 ] + points_list [ 2 ] [ 1 ] ) / 2 <NEWLINE> b1 = m12y - a1 * m12x <NEWLINE> b2 = m13y - a2 * m13x <NEWLINE> px = ( b2 - b1 ) / ( a1 - a2 ) <NEWLINE> py = a1 * px + b1 <NEWLINE> <DEDENT> r = math . sqrt ( math . pow ( ( px - points_list [ 0 ] [ 0 ] ) , 2 ) + math . pow ( ( py - points_list [ 0 ] [ 1 ] ) , 2 ) ) <NEWLINE> print ( <STRING> . format ( px , py , r ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> import re <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = LI ( ) <NEWLINE> <NL> HList = [ 0 ] * H <NEWLINE> WList = [ 0 ] * W <NEWLINE> graph = set ( ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> h , w = LI ( ) <NEWLINE> HList [ h - 1 ] += 1 <NEWLINE> WList [ w - 1 ] += 1 <NEWLINE> graph . add ( ( h - 1 , w - 1 ) ) <NEWLINE> <NL> <DEDENT> Hmax = max ( HList ) <NEWLINE> Wmax = max ( WList ) <NEWLINE> <NL> HIndex = [ i for i , v in enumerate ( HList ) if v == Hmax ] <NEWLINE> WIndex = [ i for i , v in enumerate ( WList ) if v == Wmax ] <NEWLINE> <NL> ans = Hmax + Wmax <NEWLINE> for h in HIndex : <NEWLINE> <INDENT> for w in WIndex : <NEWLINE> <INDENT> if not ( h , w ) in graph : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> L = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> L = L * a // math . gcd ( L , a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += L * pow ( a , MOD - 2 , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class RMQ : <NEWLINE> <COMMENT> <NL> <INDENT> INF = int ( ( 1 << 31 ) - 1 ) <NEWLINE> n = 0 <NEWLINE> n_ = 0 <NEWLINE> val = [ ] <NEWLINE> def __init__ ( self , n_ ) : <NEWLINE> <INDENT> n = 1 <NEWLINE> while n < n_ : <NEWLINE> <INDENT> n = n * 2 <NEWLINE> <DEDENT> self . n = n <NEWLINE> self . n_ = n_ <NEWLINE> self . val = [ self . INF ] * ( 2 * n - 1 ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def merge ( a , b ) : <NEWLINE> <INDENT> return min ( a , b ) <NEWLINE> <NL> <DEDENT> def update ( self , k , x ) : <NEWLINE> <INDENT> k = k + self . n - 1 <NEWLINE> self . val [ k ] = x <NEWLINE> while k : <NEWLINE> <INDENT> k = ( k - 1 ) // 2 <NEWLINE> self . val [ k ] = self . merge ( self . val [ k * 2 + 1 ] , self . val [ k * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( self , a , b , k , l , r ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return self . INF <NEWLINE> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return self . val [ k ] <NEWLINE> <DEDENT> vl = self . dfs ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) <NEWLINE> vr = self . dfs ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) <NEWLINE> return self . merge ( vl , vr ) <NEWLINE> <NL> <NL> <DEDENT> def query ( self , a , b ) : <NEWLINE> <INDENT> return self . dfs ( a , b , 0 , 0 , self . n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rmq = RMQ ( n ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> q = q - 1 <NEWLINE> com , x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> rmq . update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( rmq . query ( x , y + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> def get_par ( x , par_lst ) : <NEWLINE> <INDENT> if x == par_lst [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> ret = get_par ( par_lst [ x ] , par_lst ) <NEWLINE> par_lst [ x ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> par_lst = [ i for i in range ( n ) ] <NEWLINE> counter = [ 0 ] * n <NEWLINE> flag = False <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> counter [ u ] += 1 <NEWLINE> counter [ v ] += 1 <NEWLINE> pu , pv = get_par ( u , par_lst ) , get_par ( v , par_lst ) <NEWLINE> if pu == pv : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par_lst [ pu ] = pv <NEWLINE> <NL> <DEDENT> <DEDENT> if max ( counter ) > 2 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> A_sum = [ A [ 0 ] for i in range ( N ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A_sum [ i ] = A_sum [ i - 1 ] + A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += A [ i ] * A_sum [ i - 1 ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> c = input ( ) <NEWLINE> S . extend ( c ) <NEWLINE> <NL> if <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> t = S . count ( <STRING> ) <NEWLINE> S = S [ : t ] <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> pow = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pow = pow * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( pow ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> t = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> t *= A [ i ] <NEWLINE> if int ( t ) > 1e18 : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> if int ( t ) <= 1e18 : <NEWLINE> <INDENT> print ( int ( t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = ii ( ) <NEWLINE> A = li ( ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> if A == [ 1 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> max_a = [ 0 ] * ( N + 1 ) <NEWLINE> max_a [ 0 ] = 1 - A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> max_a [ i ] = max_a [ i - 1 ] * 2 - A [ i ] <NEWLINE> if max_a [ i ] < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt_list = [ 0 ] * ( N ) <NEWLINE> cnt_list [ - 1 ] = min ( A [ - 1 ] , max_a [ N - 1 ] ) <NEWLINE> <NL> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> if cnt_list [ i + 1 ] + A [ i + 1 ] <= max_a [ i ] : <NEWLINE> <INDENT> cnt_list [ i ] = cnt_list [ i + 1 ] + A [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_list [ i ] = max_a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = sum ( cnt_list [ : N + 1 ] ) + sum ( A ) <NEWLINE> <NL> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a , reverse = True ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
class BinaryTreeNode ( ) : <NEWLINE> <INDENT> def __init__ ( self , val , parent = None , left = None , right = None ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . val = val <NEWLINE> <NL> <DEDENT> def get_child_num ( self ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> if self . left != None : num += 1 <NEWLINE> if self . right != None : num += 1 <NEWLINE> return num <NEWLINE> <NL> <DEDENT> def get_successor ( self ) : <NEWLINE> <INDENT> x = self <NEWLINE> if x . right != None : <NEWLINE> <INDENT> return x . right . get_minimum ( ) <NEWLINE> <NL> <DEDENT> y = x . parent <NEWLINE> while y != None and x == y . right : <NEWLINE> <INDENT> x = y <NEWLINE> y = y . parent <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def get_minimum ( self ) : <NEWLINE> <INDENT> x = self <NEWLINE> while x . left != None : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> <DEDENT> class BinarySearchTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , val ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if val < x . val : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> node = BinaryTreeNode ( val = val , parent = y ) <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> elif node . val < y . val : <NEWLINE> <INDENT> y . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , val ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> if x . val == val : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> elif x . val < val : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def delete ( self , val ) : <NEWLINE> <INDENT> z = self . find ( val ) <NEWLINE> if z == None : return <NEWLINE> <NL> y = None <NEWLINE> if z . get_child_num ( ) < 2 : <NEWLINE> <INDENT> y = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = z . get_successor ( ) <NEWLINE> <NL> <DEDENT> x = None <NEWLINE> if y . left != None : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <DEDENT> if x != None : <NEWLINE> <INDENT> x . parent = y . parent <NEWLINE> <NL> <DEDENT> if y . parent == None : <NEWLINE> <INDENT> self . root = x <NEWLINE> <DEDENT> elif y == y . parent . left : <NEWLINE> <INDENT> y . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . right = x <NEWLINE> <NL> <DEDENT> if y != z : <NEWLINE> <INDENT> z . val = y . val <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> self . preorder_list = [ ] <NEWLINE> self . preorder_bfs ( self . root ) <NEWLINE> return self . preorder_list <NEWLINE> <NL> <DEDENT> def preorder_bfs ( self , u ) : <NEWLINE> <INDENT> if u == None : return <NEWLINE> self . preorder_list . append ( u . val ) <NEWLINE> self . preorder_bfs ( u . left ) <NEWLINE> self . preorder_bfs ( u . right ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> self . inorder_list = [ ] <NEWLINE> self . inorder_dfs ( self . root ) <NEWLINE> return self . inorder_list <NEWLINE> <NL> <DEDENT> def inorder_dfs ( self , u ) : <NEWLINE> <INDENT> if u == None : return <NEWLINE> self . inorder_dfs ( u . left ) <NEWLINE> self . inorder_list . append ( u . val ) <NEWLINE> self . inorder_dfs ( u . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_elements ( arr ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( item ) for item in arr ] ) ) <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> bst = BinarySearchTree ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> op = input ( ) <NEWLINE> if op . startswith ( <STRING> ) : <NEWLINE> <INDENT> num = int ( op [ 7 : ] ) <NEWLINE> bst . insert ( num ) <NEWLINE> <DEDENT> elif op . startswith ( <STRING> ) : <NEWLINE> <INDENT> num = int ( op [ 7 : ] ) <NEWLINE> bst . delete ( num ) <NEWLINE> <DEDENT> elif op . startswith ( <STRING> ) : <NEWLINE> <INDENT> num = int ( op [ 5 : ] ) <NEWLINE> if bst . find ( num ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print_elements ( bst . inorder ( ) ) <NEWLINE> print_elements ( bst . preorder ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , M , Q = MAP ( ) <NEWLINE> L = [ LIST ( ) for i in range ( Q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> A_list = list ( combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> for A in A_list : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in L : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = sum ( A ) <NEWLINE> SUM = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sumA -= A [ i ] <NEWLINE> SUM += A [ i ] * sumA <NEWLINE> <DEDENT> print ( SUM % ( 10 ** 9 + 7 ) ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2100 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 < ans : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def num_divisors_table ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <DEDENT> table = num_divisors_table ( 1000000 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> res = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> res += table [ i ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ARR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def prepare ( n , m , arr ) : <NEWLINE> <INDENT> nodes = [ [ ] for i in range ( n ) ] <NEWLINE> nodeStatus = [ False for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> <NL> nodes [ startNode ] . append ( endNode ) <NEWLINE> nodes [ endNode ] . append ( startNode ) <NEWLINE> <NL> <DEDENT> return nodes , nodeStatus <NEWLINE> <NL> <NL> <DEDENT> def calculate ( n , nodes , nodeStatus ) : <NEWLINE> <INDENT> nodeMarks = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> q = deque ( ) <NEWLINE> <NL> q . append ( ( 0 , - 1 ) ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> currentNode , parentNode = q . popleft ( ) <NEWLINE> <NL> if nodeStatus [ currentNode ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> nodeStatus [ currentNode ] = True <NEWLINE> nodeMarks [ currentNode ] = parentNode <NEWLINE> childNodes = nodes [ currentNode ] <NEWLINE> <NL> for childNode in childNodes : <NEWLINE> <INDENT> if nodeStatus [ childNode ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( childNode , currentNode ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> minusNumber = nodeMarks . count ( - 1 ) <NEWLINE> if minusNumber > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( nodeMarks [ i ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> nodes , nodeStatus = prepare ( N , M , ARR ) <NEWLINE> <NL> calculate ( N , nodes , nodeStatus ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( a , k ) <NEWLINE> s += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> P_ls . sort ( reverse = True ) <NEWLINE> diff = - 1 <NEWLINE> for i in range ( 101 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in P_ls : <NEWLINE> <INDENT> if diff == - 1 : <NEWLINE> <INDENT> diff = abs ( X - i ) <NEWLINE> rst = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = min ( diff , abs ( X - i ) ) <NEWLINE> if diff == abs ( X - i ) : <NEWLINE> <INDENT> rst = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ok = set ( ) <NEWLINE> now = 0 <NEWLINE> l = [ ] <NEWLINE> while now not in ok and k : <NEWLINE> <INDENT> l . append ( now ) <NEWLINE> ok . add ( now ) <NEWLINE> now = a [ now ] - 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> if k == 0 : print ( now + 1 ) ; exit ( ) <NEWLINE> length = len ( ok ) - ( h : = l . index ( now ) ) <NEWLINE> l = l [ h : ] <NEWLINE> <NL> k = ( k ) % length <NEWLINE> <NL> print ( l [ k ] + 1 ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> q = [ 0 for i in range ( n ) ] <NEWLINE> l = [ 1 ] <NEWLINE> i = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if q [ a [ l [ i ] - 1 ] - 1 ] == 1 : <NEWLINE> <INDENT> p = l . index ( a [ l [ i ] - 1 ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> q [ a [ l [ i ] - 1 ] - 1 ] = 1 <NEWLINE> l . append ( a [ l [ i ] - 1 ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if k < p : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= p <NEWLINE> x = k % ( len ( l ) - p ) <NEWLINE> print ( l [ x + p ] ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> a = np . cumsum ( A ) <NEWLINE> b = np . cumsum ( B ) <NEWLINE> a = np . insert ( a , 0 , 0 ) <NEWLINE> b = np . insert ( b , 0 , 0 ) <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a [ 0 ] - a [ 1 ] ) : <NEWLINE> <INDENT> if b [ i ] < b [ i + a [ 1 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> d_i = defaultdict ( list ) <NEWLINE> d_j = defaultdict ( list ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> d_i [ i - A [ i ] ] . append ( i ) <NEWLINE> d_j [ i + A [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for key in d_j . keys ( ) : <NEWLINE> <INDENT> arr_i = d_i [ key ] <NEWLINE> arr_j = d_j [ key ] <NEWLINE> cnt += len ( arr_j ) * len ( arr_i ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> end = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> if s == end : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> if ( <STRING> not in s ) or ( <STRING> in s ) + ( <STRING> in s ) + ( <STRING> in s ) != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for c in <STRING> : <NEWLINE> <INDENT> if c not in s : <NEWLINE> <INDENT> s = s . replace ( <STRING> , c ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> moji = str ( input ( ) ) <NEWLINE> guall = len ( moji ) // 2 <NEWLINE> kiall = guall + len ( moji ) % 2 <NEWLINE> gucount = dict ( Counter ( moji [ 1 : : 2 ] ) ) <NEWLINE> kicount = dict ( Counter ( moji [ 0 : : 2 ] ) ) <NEWLINE> if len ( moji ) == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif max ( gucount , key = gucount . get ) != max ( kicount , key = kicount . get ) : <NEWLINE> <INDENT> ans = guall - max ( gucount . values ( ) ) + kiall - max ( kicount . values ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if kiall - max ( kicount . values ( ) ) > guall - max ( gucount . values ( ) ) : <NEWLINE> <INDENT> ans = max ( kicount . values ( ) ) + guall - max ( gucount . values ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( gucount . values ( ) ) + kiall - max ( kicount . values ( ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alphabet = [ chr ( i ) for i in range ( 97 , 123 ) ] <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans = chr ( 97 + ( N % 26 ) ) + ans <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <NL> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( m == - 1 or f == - 1 ) or m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= m + f < 50 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
int ( input ( ) ) <NEWLINE> numbers = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in numbers : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = 1 <NEWLINE> for n in numbers : <NEWLINE> <INDENT> mul *= n <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> num = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> num . append ( num [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num . append ( num [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( num [ r - 1 ] - num [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p , m = [ ] , [ ] <NEWLINE> z = 0 <NEWLINE> for i in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> if i < 0 : m . append ( i ) <NEWLINE> elif i == 0 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> else : p . append ( i ) <NEWLINE> <DEDENT> if p and m : <NEWLINE> <INDENT> print ( sum ( p ) - sum ( m ) ) <NEWLINE> if z : <NEWLINE> <INDENT> for h in range ( z - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> <DEDENT> else : now = p . pop ( ) <NEWLINE> for j in m [ 1 : ] : <NEWLINE> <INDENT> print ( now , j ) <NEWLINE> now -= j <NEWLINE> <DEDENT> if p : <NEWLINE> <INDENT> print ( m [ 0 ] , now ) <NEWLINE> now = - now + m [ 0 ] <NEWLINE> for j in p [ 1 : ] : <NEWLINE> <INDENT> print ( now , j ) <NEWLINE> now -= j <NEWLINE> <DEDENT> print ( p [ 0 ] , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( now , m [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> elif p : <NEWLINE> <INDENT> if z : <NEWLINE> <INDENT> print ( sum ( p ) ) <NEWLINE> for h in range ( z - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> f = p . pop ( ) <NEWLINE> for i in p : <NEWLINE> <INDENT> print ( now , i ) <NEWLINE> now -= i <NEWLINE> <DEDENT> print ( f , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( p ) - 2 * min ( p ) ) <NEWLINE> p . sort ( ) <NEWLINE> now = p [ 0 ] <NEWLINE> k = p . pop ( ) <NEWLINE> for j in p [ 1 : ] : <NEWLINE> <INDENT> print ( now , j ) <NEWLINE> now -= j <NEWLINE> <DEDENT> print ( k , now ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if z : <NEWLINE> <INDENT> print ( - sum ( m ) ) <NEWLINE> for h in range ( z - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . sort ( ) <NEWLINE> print ( - sum ( m ) + 2 * max ( m ) ) <NEWLINE> now = m . pop ( ) <NEWLINE> <DEDENT> for i in m : <NEWLINE> <INDENT> print ( now , i ) <NEWLINE> now -= i <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> def Circle_Area ( r ) : <NEWLINE> <INDENT> print ( format ( r * r * math . pi , <STRING> ) , format ( 2 * r * math . pi , <STRING> ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Circle_Area ( float ( input ( ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sorted ( A , reverse = True ) <NEWLINE> w , h = 0 , 0 <NEWLINE> <NL> cnt = 0 <NEWLINE> tmp = S [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == tmp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == 2 : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> w = tmp <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = tmp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> tmp = S [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = w * h <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n . count ( n [ 0 ] ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> while n != <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l = <STRING> . join ( sorted ( list ( n ) , reverse = True ) ) <NEWLINE> s = <STRING> . join ( sorted ( list ( n ) ) ) <NEWLINE> n = str ( int ( l ) - int ( s ) ) . zfill ( 4 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> while m > 0 : <NEWLINE> <INDENT> ma = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> ma //= 2 <NEWLINE> heapq . heappush ( a , ma * ( - 1 ) ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> T = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> mod = 1000000007 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> st = 0 <NEWLINE> T [ i + 1 ] = T [ i ] + A [ i ] <NEWLINE> S [ i + 1 ] = S [ i ] + A [ i + 1 ] * T [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( int ( S [ N - 1 ] % mod ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = defaultdict ( int ) <NEWLINE> R = defaultdict ( int ) <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> L [ i + v ] += 1 <NEWLINE> R [ i - v ] += 1 <NEWLINE> <DEDENT> print ( sum ( L . get ( i , 0 ) * R . get ( i , 0 ) for i in range ( n ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b >= k : <NEWLINE> <INDENT> print ( min ( a , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - k + ( a + b ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a != b and b != c and c != a : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) * 6 <NEWLINE> <DEDENT> elif a == b and b == c : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def swap ( a , b ) : <NEWLINE> <INDENT> dummy = a <NEWLINE> a = b <NEWLINE> b = dummy <NEWLINE> return a , b <NEWLINE> <NL> <NL> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> l [ 0 ] , l [ 1 ] = swap ( l [ 0 ] , l [ 1 ] ) <NEWLINE> <NL> <DEDENT> if l [ 1 ] > l [ 2 ] : <NEWLINE> <INDENT> l [ 1 ] , l [ 2 ] = swap ( l [ 1 ] , l [ 2 ] ) <NEWLINE> <NL> <DEDENT> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> l [ 0 ] , l [ 1 ] = swap ( l [ 0 ] , l [ 1 ] ) <NEWLINE> <NL> <DEDENT> for n , i in enumerate ( l ) : <NEWLINE> <INDENT> if n != 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( i , end = <STRING> ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * w + <STRING> ) * h ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> c = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> h = [ [ 0 for _ in range ( m ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , m ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> h [ i ] [ j ] = h [ i - 1 ] [ j - 1 ] + d [ i ] * c [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h [ i ] [ j ] = min ( h [ i ] [ j - 1 ] , h [ i - 1 ] [ j - 1 ] + d [ i ] * c [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( h [ n - 1 ] [ m - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . par = [ n for n in range ( N ) ] <NEWLINE> self . rank = [ 1 ] * N <NEWLINE> <NL> <DEDENT> def find ( self , u ) : <NEWLINE> <INDENT> if self . par [ u ] == u : <NEWLINE> <INDENT> return u <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( self . par [ u ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , u , v ) : <NEWLINE> <NL> <INDENT> pu = self . find ( u ) <NEWLINE> pv = self . find ( v ) <NEWLINE> <NL> if pu == pv : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . rank [ pu ] < self . rank [ pv ] : <NEWLINE> <INDENT> self . par [ pu ] = pv <NEWLINE> self . rank [ pv ] += self . rank [ pu ] <NEWLINE> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> self . par [ pv ] = pu <NEWLINE> self . rank [ pu ] += self . rank [ pv ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> UF = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = A - 1 , B - 1 <NEWLINE> UF . union ( A , B ) <NEWLINE> <NL> <NL> <DEDENT> ret = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> ret = max ( ret , UF . rank [ n ] ) <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> count = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> <NL> <DEDENT> max = min ( int ( math . sqrt ( N ) ) , int ( N / 2 ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 1 , max + 1 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> h = itertools . combinations_with_replacement ( l , 3 ) <NEWLINE> <NL> <COMMENT> <NL> for i , j , k in h : <NEWLINE> <INDENT> n = ( i + j + k ) ** 2 - i * j - j * k - k * i <NEWLINE> <COMMENT> <NL> <NL> if ( n <= N ) : <NEWLINE> <INDENT> if ( i == j == k ) : <NEWLINE> <INDENT> count [ n - 1 ] += 1 <NEWLINE> <DEDENT> elif ( i == j or j == k or i == k ) : <NEWLINE> <INDENT> count [ n - 1 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ n - 1 ] += 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for c in count : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import collections <NEWLINE> a = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_2 = collections . Counter ( l ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( l_2 [ i + 1 ] ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( sum ( abs ( i ) for i in a ) - 2 * min ( abs ( a [ - 1 ] ) , abs ( a [ 0 ] ) ) * ( a [ 0 ] * a [ - 1 ] > 0 ) ) <NEWLINE> if a [ 0 ] > 0 : <NEWLINE> <INDENT> print ( a [ 0 ] , a [ - 1 ] ) <NEWLINE> a [ 0 ] -= a [ - 1 ] <NEWLINE> for i in a [ 1 : - 2 ] : <NEWLINE> <INDENT> print ( a [ 0 ] , i ) <NEWLINE> a [ 0 ] -= i <NEWLINE> <DEDENT> print ( a [ - 2 ] , a [ 0 ] ) <NEWLINE> <DEDENT> elif a [ - 1 ] < 0 : <NEWLINE> <INDENT> for i in a [ : - 1 ] : <NEWLINE> <INDENT> print ( a [ - 1 ] , i ) <NEWLINE> a [ - 1 ] -= i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in a [ 1 : - 1 ] : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> print ( a [ - 1 ] , i ) <NEWLINE> a [ - 1 ] -= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 0 ] , i ) <NEWLINE> a [ 0 ] -= i <NEWLINE> <DEDENT> <DEDENT> print ( a [ - 1 ] , a [ 0 ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( p ) for p in input ( ) . split ( ) ] <NEWLINE> B = [ int ( p ) for p in input ( ) . split ( ) ] <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> a_apnd = a . append <NEWLINE> b_apnd = b . append <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_apnd ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_apnd ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> t = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if k < a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ t ] > k - a [ i ] : <NEWLINE> <INDENT> t -= 1 <NEWLINE> <DEDENT> count = max ( count , i + t ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def g ( x : int , y : int , z : int ) -> int : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <NL> <DEDENT> l = [ 0 for n in range ( N ) ] <NEWLINE> for x , y , z in itertools . product ( range ( 1 , int ( math . sqrt ( N ) ) + 1 ) , repeat = 3 ) : <NEWLINE> <INDENT> v = g ( x , y , z ) <NEWLINE> if v <= N : <NEWLINE> <INDENT> l [ v - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for ans in l : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d_h = [ 0 ] * ( h + 1 ) <NEWLINE> d_w = [ 0 ] * ( w + 1 ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> nh , nw = map ( int , input ( ) . split ( ) ) <NEWLINE> d_h [ nh ] += 1 <NEWLINE> d_w [ nw ] += 1 <NEWLINE> d . append ( [ nh , nw ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> hantei = 0 <NEWLINE> ans1 = max ( d_h ) <NEWLINE> memoh = set ( ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> hantei = d_h [ i ] <NEWLINE> if ans1 == hantei : <NEWLINE> <INDENT> memoh . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> hantei = 0 <NEWLINE> ans2 = max ( d_w ) <NEWLINE> memow = set ( ) <NEWLINE> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> hantei = d_w [ j ] <NEWLINE> if ans2 == hantei : <NEWLINE> <INDENT> memow . add ( j ) <NEWLINE> <DEDENT> <DEDENT> ans = ans2 + ans1 - 1 <NEWLINE> <COMMENT> <NL> count = len ( memoh ) * len ( memow ) <NEWLINE> for hw in d : <NEWLINE> <INDENT> if hw [ 0 ] in memoh and hw [ 1 ] in memow : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
p = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> LRs = [ ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> lj , rj = map ( int , input ( ) . split ( ) ) <NEWLINE> LRs . append ( ( lj , rj ) ) <NEWLINE> <DEDENT> A = [ 0 ] * ( n + 1 ) <NEWLINE> i0 = min ( lj for lj , rj in LRs ) <NEWLINE> A [ 0 ] = 1 <NEWLINE> A [ i0 ] = 1 <NEWLINE> for i in range ( i0 + 1 , n ) : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> lj , rj = LRs [ j ] <NEWLINE> if i - lj >= 0 : <NEWLINE> <INDENT> A [ i ] += A [ i - lj ] <NEWLINE> <DEDENT> if i - 1 - rj >= 0 : <NEWLINE> <INDENT> A [ i ] -= A [ i - 1 - rj ] <NEWLINE> <DEDENT> A [ i ] %= p <NEWLINE> <DEDENT> <DEDENT> print ( A [ n - 1 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ False ] * ( k + 1 ) <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i - a_list [ j ] >= 0 : <NEWLINE> <INDENT> dp [ i ] |= not ( dp [ i - a_list [ j ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> info = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> info = list ( map ( lambda x : int ( x * 10 ** 10 ) , info ) ) <NEWLINE> if info [ 2 ] == info [ 0 ] : <NEWLINE> <INDENT> if info [ 6 ] == info [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif info [ 6 ] == info [ 4 ] : <NEWLINE> <INDENT> if info [ 2 ] == info [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( info [ 3 ] - info [ 1 ] ) / ( info [ 2 ] - info [ 0 ] ) == ( info [ 7 ] - info [ 5 ] ) / ( info [ 6 ] - info [ 4 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> n , m = I ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a += [ list ( input ( ) ) ] <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b += [ list ( input ( ) ) ] <NEWLINE> <NL> <DEDENT> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> for j in range ( n - m + 1 ) : <NEWLINE> <INDENT> if [ k [ j : m + j ] for k in a [ i : m + i ] ] == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ input ( ) for _ in range ( H ) ] <NEWLINE> sy , sx , gy , gx = 0 , 0 , H - 1 , W - 1 <NEWLINE> seen = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> if G [ sy ] [ sx ] == <STRING> or G [ gy ] [ gx ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> que = deque ( ) <NEWLINE> que . append ( [ sy , sx ] ) <NEWLINE> seen [ sy ] [ sx ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for d in [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] : <NEWLINE> <INDENT> dy = y + d [ 0 ] <NEWLINE> dx = x + d [ 1 ] <NEWLINE> if dy < 0 or H <= dy or dx < 0 or W <= dx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if G [ dy ] [ dx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen [ dy ] [ dx ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . append ( [ dy , dx ] ) <NEWLINE> seen [ dy ] [ dx ] = seen [ y ] [ x ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> bunpu = [ 0 ] * ( H * W + 1 ) <NEWLINE> if seen [ gy ] [ gx ] == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> all = H * W <NEWLINE> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if G [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = all - black - seen [ gy ] [ gx ] - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> list_line = sys . stdin . readlines ( ) <NEWLINE> <NL> for index , element in enumerate ( list_line ) : <NEWLINE> <INDENT> list_line [ index ] = element . rstrip ( <STRING> ) <NEWLINE> <NL> <DEDENT> for element in list_line : <NEWLINE> <INDENT> x_y_list = element . split ( <STRING> ) <NEWLINE> x = int ( x_y_list [ 0 ] ) <NEWLINE> y = int ( x_y_list [ 1 ] ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( str ( y ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( element ) <NEWLINE> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> inp = sys . stdin . buffer . readline <NEWLINE> <NL> import numpy as np <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> K , Q = map ( int , inp ( ) . split ( ) ) <NEWLINE> D = np . array ( inp ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> nxm = [ list ( map ( int , inp ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> for n , x , m in nxm : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> E = D % m <NEWLINE> acc_E = np . cumsum ( E ) <NEWLINE> <NL> <COMMENT> <NL> loop , rem = divmod ( n - 1 , K ) <NEWLINE> tot = x % m + acc_E [ - 1 ] * loop <NEWLINE> <NL> <COMMENT> <NL> zero_acc = np . cumsum ( E == 0 ) . astype ( np . int64 ) <NEWLINE> tot_zero = zero_acc [ - 1 ] * loop <NEWLINE> <NL> if rem > 0 : <NEWLINE> <INDENT> tot += acc_E [ rem - 1 ] <NEWLINE> tot_zero += zero_acc [ rem - 1 ] <NEWLINE> <DEDENT> dame = tot // m <NEWLINE> print ( n - 1 - dame - tot_zero ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from queue import Queue <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> visited = { 0 : - 1 } <NEWLINE> <NL> q = Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> current = q . get ( ) <NEWLINE> for nxt in edges [ current ] : <NEWLINE> <INDENT> if nxt not in visited : <NEWLINE> <INDENT> visited [ nxt ] = current <NEWLINE> q . put ( nxt ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( visited ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( visited [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = tuple ( [ int ( x ) for x in raw_input ( ) . split ( <STRING> ) ] ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> <NL> for ih in range ( h ) : <NEWLINE> <INDENT> if ih == 0 or ih == h - 1 or w <= 2 : print <STRING> * w <NEWLINE> else : print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <NL> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> data = list ( input ( ) . split ( ) ) <NEWLINE> data = [ int ( i ) for i in data ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> , i + 1 , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> , data [ i ] , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <NL> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> , data [ ( i - 1 ) // 2 ] , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> if 2 * i + 1 >= 0 and 2 * i + 1 < n : <NEWLINE> <INDENT> print ( <STRING> , data [ 2 * i + 1 ] , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if 2 * ( i + 1 ) >= 0 and 2 * ( i + 1 ) < n : <NEWLINE> <INDENT> print ( <STRING> , data [ 2 * ( i + 1 ) ] , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( ( A * min ( B - 1 , N ) ) / B ) - A * math . floor ( min ( B - 1 , N ) / B ) ) <NEWLINE>
import heapq <NEWLINE> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ - int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> value = heapq . heappop ( a ) <NEWLINE> value /= 2 <NEWLINE> heapq . heappush ( a , value ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( - a [ i ] ) <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE>
inf = 1100000 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> detect = [ 0 ] * inf <NEWLINE> for x in a : <NEWLINE> <INDENT> if detect [ x ] != 0 : <NEWLINE> <INDENT> detect [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( x , inf , x ) : <NEWLINE> <INDENT> detect [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if detect [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , m , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> frends_num = [ 0 for i in range ( n ) ] <NEWLINE> def make_frends ( m , n ) : <NEWLINE> <INDENT> data = [ 1 for i in range ( m ) ] <NEWLINE> <NL> row = [ ] <NEWLINE> col = [ ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> i , j = [ int ( l ) for l in input ( ) . split ( ) ] <NEWLINE> new_i = min ( i , j ) - 1 <NEWLINE> new_j = max ( i , j ) - 1 <NEWLINE> row . append ( new_i ) <NEWLINE> col . append ( new_j ) <NEWLINE> frends_num [ new_i ] += 1 <NEWLINE> frends_num [ new_j ] += 1 <NEWLINE> <DEDENT> frend_sparce_matrix = csr_matrix ( ( data , ( row , col ) ) , shape = ( n , n ) ) <NEWLINE> return frend_sparce_matrix <NEWLINE> <NL> <NL> <DEDENT> frends = make_frends ( m , n ) <NEWLINE> l , labels = connected_components ( frends ) <NEWLINE> labels <NEWLINE> labels = list ( labels ) <NEWLINE> <NL> class Group : <NEWLINE> <INDENT> def __init__ ( self , labels ) : <NEWLINE> <INDENT> self . labels = labels <NEWLINE> self . group_num = [ 0 for i in range ( l ) ] <NEWLINE> for i in labels : <NEWLINE> <INDENT> self . group_num [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> def get_group_num ( self , i ) : <NEWLINE> <INDENT> return self . group_num [ self . labels [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> group = Group ( labels ) <NEWLINE> <NL> <NL> def get_frend_num ( i ) : <NEWLINE> <INDENT> return frends_num [ i ] <NEWLINE> <NL> <NL> <DEDENT> def make_block ( k , n ) : <NEWLINE> <INDENT> block_num = [ 0 for i in range ( n ) ] <NEWLINE> for p in range ( k ) : <NEWLINE> <INDENT> i , j = [ int ( l ) - 1 for l in input ( ) . split ( ) ] <NEWLINE> new_i = min ( i , j ) <NEWLINE> new_j = max ( i , j ) <NEWLINE> if labels [ new_i ] == labels [ new_j ] : <NEWLINE> <INDENT> block_num [ i ] += 1 <NEWLINE> block_num [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> return block_num <NEWLINE> <NL> <DEDENT> block = make_block ( k , n ) <NEWLINE> <NL> def get_block_num ( i ) : <NEWLINE> <INDENT> return block [ i ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( str ( group . get_group_num ( i ) - 1 - get_frend_num ( i ) - get_block_num ( i ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> b = list ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> c = np . zeros ( 9 ) . reshape ( 3 , 3 ) <NEWLINE> <NL> for k in b : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if k == a [ i ] [ j ] : <NEWLINE> <INDENT> c [ i , j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( max ( c . sum ( axis = 0 ) ) == 3 ) or ( max ( c . sum ( axis = 1 ) ) == 3 ) or ( sum ( [ c [ i , i ] for i in range ( 3 ) ] ) == 3 ) or ( c [ 2 , 0 ] + c [ 1 , 1 ] + c [ 0 , 2 ] == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> R_count = 0 <NEWLINE> G_count = 0 <NEWLINE> B_count = 0 <NEWLINE> for s in list ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> R_count += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G_count += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> B_count += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = R_count * G_count * B_count <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
make = False <NEWLINE> def check_possible ( req , num ) : <NEWLINE> <INDENT> for i in range ( 0 , req + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , req + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * j == num and i + j == req : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> req , num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if check_possible ( req , num ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> C = 0 <NEWLINE> l = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( C ) <NEWLINE> C = 0 <NEWLINE> <DEDENT> <DEDENT> l . append ( C ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> f = [ [ True ] for i in range ( n ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if f [ s - 1 ] == False : <NEWLINE> <INDENT> if ans [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if f [ s - 1 ] : <NEWLINE> <INDENT> f [ s - 1 ] = False <NEWLINE> <DEDENT> ans [ s - 1 ] = c <NEWLINE> <NL> <DEDENT> a = map ( str , ans ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if s == 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if f [ s - 1 ] == False : <NEWLINE> <INDENT> if ans [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if f [ s - 1 ] : <NEWLINE> <INDENT> f [ s - 1 ] = False <NEWLINE> <DEDENT> ans [ s - 1 ] = c <NEWLINE> <DEDENT> if ans [ 0 ] == 0 : <NEWLINE> <INDENT> ans [ 0 ] = 1 <NEWLINE> <DEDENT> a = map ( str , ans ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> import math <NEWLINE> read = sys . stdin . readline <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> <NL> for a in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for b in range ( 0 , 1000 ) : <NEWLINE> <INDENT> a4 = a ** 4 <NEWLINE> b4 = b ** 4 <NEWLINE> a3 = a ** 3 <NEWLINE> b3 = b ** 3 <NEWLINE> a2 = a ** 2 <NEWLINE> b2 = b ** 2 <NEWLINE> if ( ( a - b ) * ( a4 + ( a3 * b ) + ( a2 * b2 ) + ( b3 * a ) + b4 ) ) == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> b = - 1 * b <NEWLINE> b3 = - 1 * b3 <NEWLINE> if ( ( a - b ) * ( a4 + ( a3 * b ) + ( a2 * b2 ) + ( b3 * a ) + b4 ) ) == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> flag = 1 <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
is_able_make = [ False ] * 2000 <NEWLINE> <NL> input ( ) <NEWLINE> <NL> A = [ int ( val ) for val in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = [ int ( val ) for val in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> for j in range ( 2000 - i , 0 , - 1 ) : <NEWLINE> <INDENT> if is_able_make [ j ] == True : <NEWLINE> <INDENT> is_able_make [ i + j ] = True <NEWLINE> <DEDENT> <DEDENT> is_able_make [ i ] = True <NEWLINE> <NL> <DEDENT> for x in M : <NEWLINE> <INDENT> if ( is_able_make [ x ] == True ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for p in range ( 2 , x ) : <NEWLINE> <INDENT> if b ** p <= x : <NEWLINE> <INDENT> c = max ( c , b ** p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = list ( str ( input ( ) ) ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> t = t + i <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> t = t + s [ i ] <NEWLINE> <DEDENT> t = t + <STRING> <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 0 <NEWLINE> sumA = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sumA -= A [ i ] <NEWLINE> a = A [ i ] * sumA <NEWLINE> a %= mod <NEWLINE> ans += a <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = defaultdict ( list ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> t = [ ] <NEWLINE> heapq . heapify ( t ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in cnt [ i ] : <NEWLINE> <INDENT> heapq . heappush ( t , - j ) <NEWLINE> <DEDENT> if t : ans -= heapq . heappop ( t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> sub = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> sub -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sub ) <NEWLINE>
import sys <NEWLINE> <NL> H , W , D = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> num = { } <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> tmp = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> for i , n in enumerate ( tmp ) : <NEWLINE> <INDENT> num [ n ] = ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> S = [ 0 for _ in range ( H * W + D ) ] <NEWLINE> for i in range ( D + 1 , H * W + 1 ) : <NEWLINE> <INDENT> x , y = num [ i ] <NEWLINE> a , b = num [ i - D ] <NEWLINE> S [ i ] = S [ i - D ] + abs ( x - a ) + abs ( y - b ) <NEWLINE> <COMMENT> <NL> <DEDENT> Q = int ( sys . stdin . readline ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> r = L % D <NEWLINE> print ( S [ R ] - S [ L ] ) <NEWLINE> <DEDENT>
A , B , C = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> K = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> while K > 0 : <NEWLINE> <INDENT> if B <= A : <NEWLINE> <INDENT> B *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> elif C <= B : <NEWLINE> <INDENT> C *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if C > B > A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> K = int ( input ( ) ) <NEWLINE> CNT = 0 <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> GCD = gcd ( i , j ) <NEWLINE> if GCD == 1 : <NEWLINE> <INDENT> CNT += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if gcd ( GCD , k ) != 1 : <NEWLINE> <INDENT> CNT += gcd ( GCD , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> CNT += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( CNT ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> c = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b = n // i <NEWLINE> c = i * b * ( b + 1 ) / 2 <NEWLINE> answer = answer + c <NEWLINE> <DEDENT> print ( int ( answer ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> parent = [ i for i in range ( n ) ] <NEWLINE> rank = [ 0 ] * len ( parent ) <NEWLINE> <NL> def root ( s ) : <NEWLINE> <INDENT> if parent [ s ] == s : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ s ] = root ( parent [ s ] ) <NEWLINE> return parent [ s ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( s1 , s2 ) : <NEWLINE> <INDENT> if root ( s1 ) == root ( s2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( s1 , s2 ) : <NEWLINE> <INDENT> s1 = root ( s1 ) <NEWLINE> s2 = root ( s2 ) <NEWLINE> <NL> if s1 == s2 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if rank [ s1 ] < rank [ s2 ] : <NEWLINE> <INDENT> parent [ s1 ] = s2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ s2 ] = s1 <NEWLINE> if rank [ s1 ] == rank [ s2 ] : <NEWLINE> <INDENT> rank [ s1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> query , item1 , item2 = input ( ) . split ( <STRING> ) <NEWLINE> item1 , item2 = int ( item1 ) , int ( item2 ) <NEWLINE> <NL> if query == <STRING> : <NEWLINE> <INDENT> unite ( item1 , item2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same ( item1 , item2 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
( r , p ) = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> route_list = [ [ ] for i in range ( r ) ] <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> ( x , y ) = [ int ( n ) - 1 for n in input ( ) . split ( ) ] <NEWLINE> route_list [ x ] . append ( y ) <NEWLINE> route_list [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> upstair = [ 0 ] <NEWLINE> ans = [ - 1 ] * r <NEWLINE> while upstair : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for i in upstair : <NEWLINE> <INDENT> for j in route_list [ i ] : <NEWLINE> <INDENT> if ans [ j ] == - 1 : <NEWLINE> <INDENT> ans [ j ] = i + 1 <NEWLINE> tmp . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> upstair = tmp <NEWLINE> <NL> <DEDENT> if - 1 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> routes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> otozureta = set ( [ 1 ] ) <NEWLINE> otozureta_list = [ 1 ] <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def search ( list , next ) : <NEWLINE> <INDENT> if not otozureta . isdisjoint ( set ( [ next ] ) ) : <NEWLINE> <INDENT> return next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> otozureta . add ( next ) <NEWLINE> otozureta_list . append ( next ) <NEWLINE> return search ( list , routes [ next - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> target = search ( routes , routes [ 0 ] ) <NEWLINE> target_index = otozureta_list . index ( target ) <NEWLINE> <NL> otozureta_list_len = len ( otozureta_list ) <NEWLINE> loop_length = otozureta_list_len - target_index <NEWLINE> loop_made_length = target_index <NEWLINE> <COMMENT> <NL> <NL> if K < otozureta_list_len : <NEWLINE> <INDENT> print ( otozureta_list [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( otozureta_list [ loop_made_length + ( ( K - loop_made_length ) % loop_length ) ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , parent = None , children = None , name = None , depth = None ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . children = children <NEWLINE> self . name = name <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , parent = None , children = None , name = None , depth = None ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . children = children <NEWLINE> self . name = name <NEWLINE> <NL> <DEDENT> <DEDENT> def print_nodes ( nodes , n ) : <NEWLINE> <INDENT> def get_depth ( nodes , u ) : <NEWLINE> <INDENT> p = nodes [ u ] . parent <NEWLINE> nonlocal d <NEWLINE> if p != None and p != - 1 : <NEWLINE> <INDENT> get_depth ( nodes , p ) <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> if nodes [ i ] . parent == None : <NEWLINE> <INDENT> nodes [ i ] . parent = - 1 <NEWLINE> nodes [ i ] . name = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( <NEWLINE> <INDENT> i , nodes [ i ] . parent , get_depth ( nodes , i ) , nodes [ i ] . name , nodes [ i ] . children ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def read_rooted_tree ( nodes , n ) : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> i = [ int ( i ) for i in stdin . readline ( ) . strip ( ) . split ( ) ] <NEWLINE> c = i [ 2 : len ( i ) ] <NEWLINE> nodes [ i [ 0 ] ] . children = c <NEWLINE> if c : <NEWLINE> <INDENT> nodes [ i [ 0 ] ] . name = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nodes [ i [ 0 ] ] . name = <STRING> <NEWLINE> <DEDENT> for j in nodes [ i [ 0 ] ] . children : <NEWLINE> <INDENT> nodes [ j ] . parent = i [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> nodes = [ Node ( ) for _ in range ( n ) ] <NEWLINE> read_rooted_tree ( nodes , n ) <NEWLINE> print_nodes ( nodes , n ) <NEWLINE>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> diff = - 1 <NEWLINE> for i in range ( 101 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in P_ls : <NEWLINE> <INDENT> if diff == - 1 : <NEWLINE> <INDENT> diff = abs ( X - i ) <NEWLINE> rst = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = min ( diff , abs ( X - i ) ) <NEWLINE> if diff == abs ( X - i ) : <NEWLINE> <INDENT> rst = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> from scipy . sparse . csgraph import csgraph_from_dense , floyd_warshall <NEWLINE> from decimal import Decimal <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A = il ( ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> already = set ( ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> mx = max ( A ) <NEWLINE> ret = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in already : continue <NEWLINE> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while a * i <= mx : <NEWLINE> <INDENT> already . add ( a * i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = make_divisors ( n ) <NEWLINE> <NL> if len ( x ) % 2 == 0 : <NEWLINE> <INDENT> print ( x [ len ( x ) // 2 ] + x [ ( len ( x ) // 2 ) - 1 ] - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( x [ ( len ( x ) // 2 ) ] * 2 ) - 2 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for i in range ( 0 , q ) : <NEWLINE> <INDENT> ay , by1 , cy , dy = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( ay ) <NEWLINE> b . append ( by1 ) <NEWLINE> c . append ( cy ) <NEWLINE> d . append ( dy ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> smax = - 100 <NEWLINE> <NL> sys . setrecursionlimit ( 3000 ) <NEWLINE> <NL> <NL> <NL> def dfs ( h ) : <NEWLINE> <INDENT> global smax <NEWLINE> if len ( h ) == n + 1 : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( 0 , q ) : <NEWLINE> <INDENT> if h [ b [ j ] ] - h [ a [ j ] ] == c [ j ] : <NEWLINE> <INDENT> s += d [ j ] <NEWLINE> <DEDENT> <DEDENT> if s > smax : <NEWLINE> <INDENT> smax = s <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( 0 , m + 1 - h [ len ( h ) - 1 ] ) : <NEWLINE> <NL> <INDENT> h2 = h [ : ] <NEWLINE> h2 . append ( h [ len ( h ) - 1 ] + i ) <NEWLINE> dfs ( h2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> sta = [ 1 ] <NEWLINE> dfs ( sta ) <NEWLINE> print ( smax ) <NEWLINE>
W , H , x , y , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if x >= r and x <= ( W - r ) : <NEWLINE> <INDENT> if y >= r and y <= ( H - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> targets = [ ] <NEWLINE> n_target_h = [ 0 ] * H <NEWLINE> n_target_w = [ 0 ] * W <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> targets . append ( ( h , w ) ) <NEWLINE> n_target_h [ h - 1 ] += 1 <NEWLINE> n_target_w [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> h_max = max ( n_target_h ) <NEWLINE> w_max = max ( n_target_w ) <NEWLINE> <NL> bomb_h = [ i + 1 for i , h in enumerate ( n_target_h ) if h == h_max ] <NEWLINE> bomb_w = [ i + 1 for i , w in enumerate ( n_target_w ) if w == w_max ] <NEWLINE> <NL> count = len ( bomb_h ) * len ( bomb_w ) <NEWLINE> for target in targets : <NEWLINE> <INDENT> if ( n_target_h [ target [ 0 ] - 1 ] == h_max ) and ( n_target_w [ target [ 1 ] - 1 ] == w_max ) : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> ans = h_max + w_max <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = h_max + w_max - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
<NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n_ = 1 <COMMENT> <NEWLINE> while n_ < n : <NEWLINE> <INDENT> n_ *= 2 <NEWLINE> <NL> <DEDENT> seg_tree = [ 0 for i in range ( 2 * n_ - 1 ) ] <NEWLINE> <NL> def add ( i , x ) : <NEWLINE> <INDENT> i += n_ - 1 <NEWLINE> seg_tree [ i ] += x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i = int ( ( i - 1 ) / 2 ) <NEWLINE> <COMMENT> <NL> seg_tree [ i ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> def getSum ( s , t ) : <NEWLINE> <INDENT> return query ( s , t + 1 , 0 , 0 , n_ ) <NEWLINE> <NL> <DEDENT> def query ( a , b , k , l , r ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return seg_tree [ k ] <NEWLINE> <NL> <DEDENT> vl = query ( a , b , k * 2 + 1 , l , int ( ( l + r ) / 2 ) ) <NEWLINE> vr = query ( a , b , k * 2 + 2 , int ( ( l + r ) / 2 ) , r ) <NEWLINE> return vl + vr <NEWLINE> <NL> <NL> <DEDENT> output = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <COMMENT> <NL> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if line [ 0 ] == 0 : <NEWLINE> <INDENT> add ( line [ 1 ] - 1 , line [ 2 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> output . append ( getSum ( line [ 1 ] - 1 , line [ 2 ] - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for ans in output : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> n = inint ( ) <NEWLINE> A = inintl ( ) <NEWLINE> <NL> S = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] + A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += A [ i - 1 ] * ( S [ - 1 ] - S [ i ] ) <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> C = [ 1 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ A [ i ] ] == 0 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if C [ A [ i ] ] == - 1 : <COMMENT> <NEWLINE> <INDENT> C [ A [ i ] ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> C [ A [ i ] ] *= - 1 <COMMENT> <NEWLINE> j = 2 <NEWLINE> while A [ i ] * j <= 10 ** 6 : <COMMENT> <NEWLINE> <INDENT> C [ A [ i ] * j ] = 0 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C . count ( - 1 ) ) <NEWLINE>
def calcAreas ( sections ) : <NEWLINE> <INDENT> areas = [ ] <NEWLINE> <NL> for s in sections : <NEWLINE> <INDENT> if len ( s ) <= 1 : <NEWLINE> <INDENT> continue ; <NEWLINE> <NL> <DEDENT> areas . append ( toArea ( s ) ) <NEWLINE> <NL> <DEDENT> return areas <NEWLINE> <NL> <DEDENT> def toArea ( section ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> b , _ = section [ 0 ] <NEWLINE> <NL> for s , e in section : <NEWLINE> <INDENT> a += ( max ( s , e ) - b ) - ( 0.5 if s != e else 0 ) <NEWLINE> <NL> <DEDENT> return int ( a ) <NEWLINE> <NL> <DEDENT> def toDelta ( p ) : <NEWLINE> <INDENT> if <STRING> == p : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> if <STRING> == p : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def toPaths ( path ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> ph = 0 <NEWLINE> paths = [ ] <NEWLINE> <NL> for p in path : <NEWLINE> <INDENT> h += toDelta ( p ) <NEWLINE> paths . append ( ( ph , h ) ) <NEWLINE> ph = h <NEWLINE> <NL> <DEDENT> return paths <NEWLINE> <NL> <DEDENT> def update ( sections ) : <NEWLINE> <INDENT> [ ( lf , ll ) ] = sections . pop ( ) <NEWLINE> <NL> n = None <NEWLINE> <NL> for i in range ( len ( sections ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if sections [ i ] [ 0 ] [ 0 ] == ll : <NEWLINE> <INDENT> n = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n == None : <NEWLINE> <INDENT> sections . append ( [ ( lf , ll ) ] ) <NEWLINE> return False <NEWLINE> <NL> <DEDENT> lst = [ ( lf , ll ) ] <NEWLINE> for i in range ( len ( sections ) - 1 , n - 1 , - 1 ) : <NEWLINE> <INDENT> s = sections . pop ( ) <NEWLINE> lst = s + lst <NEWLINE> <NL> <DEDENT> sections . append ( lst ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> paths = toPaths ( input ( ) ) <NEWLINE> <NL> prev = - 1 <NEWLINE> sections = [ ] <NEWLINE> <NL> prev_update = True <NEWLINE> <NL> for f , l in paths : <NEWLINE> <INDENT> sections . append ( [ ( f , l ) ] ) <NEWLINE> if l < prev : <NEWLINE> <INDENT> if prev_update : <NEWLINE> <INDENT> prev_update = update ( sections ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> prev_update = True <NEWLINE> <NL> <DEDENT> prev = l <NEWLINE> <NL> <DEDENT> areas = calcAreas ( sections ) <NEWLINE> l = len ( areas ) <NEWLINE> <NL> print ( sum ( areas ) ) <NEWLINE> print ( l , end = <STRING> ) <NEWLINE> if l > 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> . join ( [ str ( x ) for x in areas ] ) ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> P [ : ] += 1 <NEWLINE> Pcum = np . zeros ( N + 1 , np . int32 ) <NEWLINE> Pcum [ 1 : ] = np . cumsum ( P ) <NEWLINE> length_K_sums = Pcum [ K : ] - Pcum [ : - K ] <NEWLINE> print ( length_K_sums . max ( ) / 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def binary_search ( ary , key , imin , imax ) : <NEWLINE> <INDENT> if imax < imin : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> imid = imin + ( imax - imin ) // 2 <NEWLINE> if ary [ imid ] > key : <NEWLINE> <INDENT> return binary_search ( ary , key , imin , imid - 1 ) <NEWLINE> <DEDENT> elif ary [ imid ] < key : <NEWLINE> <INDENT> return binary_search ( ary , key , imid + 1 , imax ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> if binary_search ( s , i , 0 , n - 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> g = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nodes = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> g [ i ] = nodes [ 1 : ] <NEWLINE> <NL> <DEDENT> euler , height = euler_tour ( g , n ) <NEWLINE> index = defaultdict ( list ) <NEWLINE> for i in range ( len ( euler ) ) : <NEWLINE> <INDENT> index [ euler [ i ] ] . append ( i ) <NEWLINE> <DEDENT> rmql = [ ( height [ i ] , i ) for i in euler ] <NEWLINE> rmq = segment_tree ( rmql , min , ( float ( <STRING> ) , ) ) <NEWLINE> <NL> q = int ( readline ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> u , v = map ( int , readline ( ) . split ( ) ) <NEWLINE> l , r = index [ u ] [ 0 ] , index [ v ] [ - 1 ] <NEWLINE> if l > r : <NEWLINE> <INDENT> l , r = index [ v ] [ 0 ] , index [ u ] [ - 1 ] <NEWLINE> <DEDENT> print ( rmq . find ( l , r ) [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def euler_tour ( g , size ) : <NEWLINE> <INDENT> height = [ None ] * size <NEWLINE> euler = [ ] <NEWLINE> root = 0 <NEWLINE> dfs_stack = [ ( root , None , 0 ) ] <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev , h = dfs_stack . pop ( ) <NEWLINE> height [ u ] = h <NEWLINE> euler . append ( prev ) <NEWLINE> if g [ u ] : <NEWLINE> <INDENT> dfs_stack . extend ( ( v , u , h + 1 ) for v in g [ u ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> euler . append ( u ) <NEWLINE> <DEDENT> <DEDENT> return euler [ 1 : ] , height <NEWLINE> <NL> <DEDENT> import math <NEWLINE> class segment_tree : <NEWLINE> <INDENT> def __init__ ( self , dat , query , default = 0 ) : <NEWLINE> <INDENT> self . offset = 2 ** math . ceil ( math . log ( len ( dat ) , 2 ) ) <NEWLINE> self . table = [ default ] * self . offset + dat + [ default ] * ( self . offset - len ( dat ) ) <NEWLINE> self . query = query <NEWLINE> for i in reversed ( range ( 1 , self . offset ) ) : <NEWLINE> <INDENT> self . table [ i ] = self . query ( self . table [ 2 * i ] , self . table [ 2 * i + 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def find ( self , l , r ) : <NEWLINE> <INDENT> return self . query ( self . __range ( l , r ) ) <NEWLINE> <NL> <DEDENT> def __range ( self , l , r ) : <NEWLINE> <INDENT> l += self . offset <NEWLINE> r += self . offset <NEWLINE> while l <= r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> yield self . table [ l ] <NEWLINE> l += 1 <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> if r & 1 == 0 : <NEWLINE> <INDENT> yield self . table [ r ] <NEWLINE> r -= 1 <NEWLINE> <DEDENT> r >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += self . offset <NEWLINE> self . table [ i ] = x <NEWLINE> while 1 < i : <NEWLINE> <INDENT> i >>= 1 <NEWLINE> self . table [ i ] = self . query ( self . table [ 2 * i ] , self . table [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ary = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> qs = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def search_rec ( ind , s , q ) : <NEWLINE> <INDENT> if ind == n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ary [ ind ] <NEWLINE> if s + tmp == q : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return search ( ind + 1 , s , q ) or search ( ind + 1 , s + tmp , q ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def search ( q ) : <NEWLINE> <INDENT> sum_ary = [ 0 ] <NEWLINE> <NL> for i in ary : <NEWLINE> <INDENT> for s in sum_ary : <NEWLINE> <INDENT> if s + i == q : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> sum_ary += [ i + _ for _ in sum_ary ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for q in qs : <NEWLINE> <INDENT> if search ( q ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> ans += k - 1 - j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = 1 <NEWLINE> r = 10 ** 9 + 1 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] > mid : <NEWLINE> <INDENT> count += math . ceil ( A [ i ] // mid ) <NEWLINE> <NL> <DEDENT> <DEDENT> if count <= k : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
import itertools <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> l = [ 0 for q in range ( Q ) ] <NEWLINE> r = [ 0 for q in range ( Q ) ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> l [ q ] , r [ q ] = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> max_r = max ( r ) <NEWLINE> prime_numbers = [ True for n in range ( max_r + 1 ) ] <NEWLINE> similar_numbers = [ False for n in range ( max_r + 1 ) ] <NEWLINE> <NL> prime_numbers [ 0 ] , prime_numbers [ 1 ] = False , False <COMMENT> <NEWLINE> for divisor in range ( 2 , max_r // 2 + 1 ) : <NEWLINE> <INDENT> if prime_numbers [ divisor ] : <NEWLINE> <INDENT> for multipler in range ( 2 , max_r // divisor + 1 ) : <NEWLINE> <INDENT> prime_numbers [ divisor * multipler ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for N in range ( 1 , max_r + 1 , 2 ) : <NEWLINE> <INDENT> if prime_numbers [ N ] and prime_numbers [ ( N + 1 ) // 2 ] : <NEWLINE> <INDENT> similar_numbers [ N ] = True <NEWLINE> <DEDENT> <DEDENT> accumulate_sim_nums = list ( itertools . accumulate ( map ( int , similar_numbers ) ) ) <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> print ( accumulate_sim_nums [ r [ q ] ] - accumulate_sim_nums [ l [ q ] - 1 ] ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> if h == 1 or w == 1 : <NEWLINE> <INDENT> if h == 1 and w == 1 : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif h == 1 : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if s [ 0 ] [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ 0 ] [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ 0 ] [ i ] = str ( t ) <NEWLINE> <DEDENT> elif i == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ 0 ] [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ 0 ] [ i ] = str ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ 0 ] [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ 0 ] [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ 0 ] [ i ] = str ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i + 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ 0 ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ 0 ] = str ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i + 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ 0 ] = str ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ i ] ) ) <NEWLINE> <DEDENT> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == 0 and j == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 and j == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 and j == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> if s [ i - 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if s [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> s [ i ] [ j ] = str ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ i ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> <NL> f_inf = float ( <STRING> ) <NEWLINE> dp = [ f_inf ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> h = np . array ( h ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = max ( 0 , i - K ) <NEWLINE> <COMMENT> <NL> dp [ i ] = min ( dp [ start : i ] + np . abs ( h [ i ] - h [ start : i ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> N = int ( a [ 0 ] ) <NEWLINE> M = int ( a [ 1 ] ) <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> way = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> way . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dic [ i ] = set ( ) <NEWLINE> <NL> <DEDENT> for h in way : <NEWLINE> <INDENT> dic [ h [ 0 ] - 1 ] . add ( h [ 1 ] - 1 ) <NEWLINE> dic [ h [ 1 ] - 1 ] . add ( h [ 0 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( sum ( all ( [ H [ i ] > H [ hs ] for hs in dic [ i ] ] ) for i in range ( N ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = [ int ( tmp ) for tmp in input ( ) . split ( <STRING> ) ] <NEWLINE> [ print ( <STRING> ) if a < b else print ( <STRING> ) for a , b in zip ( a [ : n - k ] , a [ k : ] ) ] <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] + B [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> <COMMENT> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> chk = False <NEWLINE> while ( n % k == 0 ) : <NEWLINE> <INDENT> chk = True <NEWLINE> n /= k <NEWLINE> if k not in check : <NEWLINE> <INDENT> check [ k ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> if chk : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> <DEDENT> if n in check : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ n ] = 1 <NEWLINE> return 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> check = { } <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( 1 ) : <NEWLINE> <INDENT> n = is_prime ( n ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k , v in check . items ( ) : <NEWLINE> <INDENT> for i in range ( 1 , 50 ) : <NEWLINE> <INDENT> v -= i <NEWLINE> if v < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = [ - 1 ] <NEWLINE> w = [ - 1 ] <NEWLINE> hw_dict = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> h . append ( hi ) <NEWLINE> w . append ( wi ) <NEWLINE> hw_dict [ ( hi , wi ) ] = 1 <NEWLINE> <NL> <DEDENT> h_cnt = [ 0 ] * ( H + 1 ) <NEWLINE> w_cnt = [ 0 ] * ( W + 1 ) <NEWLINE> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> h_cnt [ h [ i ] ] += 1 <NEWLINE> w_cnt [ w [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> h_max = max ( h_cnt ) <NEWLINE> w_max = max ( w_cnt ) <NEWLINE> <NL> h_max_idx = [ ] <NEWLINE> w_max_idx = [ ] <NEWLINE> <NL> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> if h_cnt [ i ] == h_max : <NEWLINE> <INDENT> h_max_idx . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if w_cnt [ i ] == w_max : <NEWLINE> <INDENT> w_max_idx . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in h_max_idx : <NEWLINE> <INDENT> for j in w_max_idx : <NEWLINE> <INDENT> if hw_dict [ ( i , j ) ] == 0 : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( 1001 ) : <NEWLINE> <INDENT> for b in range ( 1001 ) : <NEWLINE> <INDENT> if ( a ** 5 ) - ( b ** 5 ) == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( a ** 5 ) + ( b ** 5 ) == x : <NEWLINE> <INDENT> print ( a , - 1 * b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( b ** 5 ) - ( a ** 5 ) == x : <NEWLINE> <INDENT> print ( - 1 * a , - 1 * b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> l = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> a = X // 100 <NEWLINE> b = X % 100 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if b % i == 0 : <NEWLINE> <INDENT> if b // i <= a : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> N = I ( ) <NEWLINE> L = LI ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> l1 = [ L [ i ] , L [ j ] , L [ k ] ] <NEWLINE> l = sorted ( l1 ) <NEWLINE> for n in range ( 3 ) : <NEWLINE> <INDENT> if ( l . count ( l [ n ] ) > 1 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> if ( l [ 1 ] - l [ 0 ] < l [ 2 ] and l [ 1 ] + l [ 0 ] > l [ 2 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> ans = <STRING> if N % 9 == 0 else <STRING> <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 7 + 10 ** 9 <NEWLINE> SUM = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> SUM -= A [ i ] <NEWLINE> ans += A [ i ] * SUM % MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
BILLS = [ 10000 , 5000 , 1000 ] <NEWLINE> <NL> <NL> def calc_price ( counts ) : <NEWLINE> <INDENT> return sum ( [ bill * count for bill , count in zip ( BILLS , counts ) ] ) <NEWLINE> <NL> <NL> <DEDENT> def main ( n , y ) : <NEWLINE> <INDENT> for c1 in range ( n + 1 ) : <NEWLINE> <INDENT> for c2 in range ( 0 , n - c1 + 1 ) : <NEWLINE> <INDENT> counts = [ c1 , c2 , n - c1 - c2 ] <NEWLINE> if calc_price ( counts ) == y : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( c ) for c in counts ] ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> main ( n , y ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( root ) : <NEWLINE> <INDENT> global time <NEWLINE> Q = deque ( ) <NEWLINE> distance [ root ] = 0 <NEWLINE> Q . append ( root ) <NEWLINE> i = root <NEWLINE> while len ( Q ) > 0 : <NEWLINE> <INDENT> i = Q . popleft ( ) <NEWLINE> for v in adjDict [ i ] : <NEWLINE> <INDENT> if color [ v ] == <STRING> : <NEWLINE> <INDENT> Q . append ( v ) <NEWLINE> color [ v ] = <STRING> <NEWLINE> distance [ v ] = distance [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> color [ i ] = <STRING> <NEWLINE> label [ i ] = time <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> firstline = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = firstline [ 0 ] <NEWLINE> adjDict = { i : [ ] for i in range ( n ) } <NEWLINE> color = [ <STRING> ] * n <NEWLINE> distance = [ - 1 ] * n <NEWLINE> label = [ - 1 ] * n <NEWLINE> <NL> m = firstline [ 1 ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> adj = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adjDict [ adj [ 0 ] ] . append ( adj [ 1 ] ) <NEWLINE> adjDict [ adj [ 1 ] ] . append ( adj [ 0 ] ) <NEWLINE> <NL> <DEDENT> time = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] == <STRING> : <NEWLINE> <INDENT> bfs ( i ) <NEWLINE> time += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> question = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if label [ question [ 0 ] ] == label [ question [ 1 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , - ( - a // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
<NL> <NL> class Combination : <NEWLINE> <INDENT> def __init__ ( self , n_max , mod = 10 ** 9 + 7 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . mod = mod <NEWLINE> f = 1 <NEWLINE> self . fac = fac = [ f ] <NEWLINE> for i in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> fac . append ( f ) <NEWLINE> <DEDENT> f = pow ( f , mod - 2 , mod ) <NEWLINE> self . facinv = facinv = [ f ] <NEWLINE> for i in range ( n_max , 0 , - 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> facinv . append ( f ) <NEWLINE> <DEDENT> facinv . reverse ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def __call__ ( self , n , r ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def nCr ( self , n , r ) : <NEWLINE> <INDENT> if not 0 <= r <= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> def f ( r , c ) : <NEWLINE> <INDENT> return cmb . nCr ( r + c + 2 , r + 1 ) - 1 <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> r1 -= 1 <NEWLINE> c1 -= 1 <NEWLINE> <NL> cmb = Combination ( r2 + c2 + 5 ) <NEWLINE> ans = f ( r2 , c2 ) <NEWLINE> ans -= f ( r1 , c2 ) <NEWLINE> ans -= f ( r2 , c1 ) <NEWLINE> ans += f ( r1 , c1 ) <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> Li = [ input ( ) for _ in range ( n ) ] <NEWLINE> Li . sort ( ) <NEWLINE> s = Li [ 0 ] <NEWLINE> c = 1 <NEWLINE> for l in Li [ 1 : ] : <NEWLINE> <INDENT> if l == s : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> s = l <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> k = K <NEWLINE> a = min ( A , k ) <NEWLINE> k -= a <NEWLINE> b = min ( B , k ) <NEWLINE> k -= b <NEWLINE> c = min ( C , k ) <NEWLINE> print ( a - c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nu1 = 2 <NEWLINE> nu2 = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> nu3 = nu1 + nu2 <NEWLINE> nu1 = nu2 <NEWLINE> nu2 = nu3 <NEWLINE> <DEDENT> <DEDENT> print ( nu3 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> z = 1 <NEWLINE> if 0 in y : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> z = z * y [ i ] <NEWLINE> if z > 10 ** 18 : <NEWLINE> <INDENT> z = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N = int ( pin ( ) ) <NEWLINE> P = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if m >= P [ i ] : <NEWLINE> <INDENT> m = P [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> stn = input ( ) <NEWLINE> m = stn . count ( <STRING> ) <NEWLINE> r = m <NEWLINE> w = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if stn [ i ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w += 1 <NEWLINE> <NL> <DEDENT> m = min ( m , max ( r , w ) ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> g = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> g = math . gcd ( g , a [ i ] ) <NEWLINE> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> d = [ 1 for i in range ( a [ - 1 ] ) ] <NEWLINE> for i in range ( 2 , a [ - 1 ] + 1 ) : <NEWLINE> <INDENT> if d [ i - 1 ] == 1 : <NEWLINE> <INDENT> for j in range ( 1 , a [ - 1 ] // i + 1 ) : <NEWLINE> <INDENT> if d [ i * j - 1 ] == 1 : <NEWLINE> <INDENT> d [ i * j - 1 ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> prm = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = [ ] <NEWLINE> while a [ i ] != 1 : <NEWLINE> <INDENT> p . append ( d [ a [ i ] - 1 ] ) <NEWLINE> a [ i ] = a [ i ] // d [ a [ i ] - 1 ] <NEWLINE> <DEDENT> p = set ( p ) <NEWLINE> for p_ in p : <NEWLINE> <INDENT> if prm . get ( p_ ) == None : <NEWLINE> <INDENT> prm [ p_ ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> elif K % 5 == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> an = 7 <NEWLINE> counter = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> modan = an % K <NEWLINE> <NL> if modan == 0 : <NEWLINE> <INDENT> return counter <NEWLINE> <NL> <DEDENT> an = modan * 10 + 7 <NEWLINE> counter = counter + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> answer = main ( ) <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( x % pop_count ( x ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = Scanner . int ( ) <NEWLINE> S = Scanner . string ( ) <NEWLINE> pc = sum ( [ s == <STRING> for s in S ] ) <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> for b in range ( 2 ) : <NEWLINE> <INDENT> npc = pc <NEWLINE> if b == 0 : <NEWLINE> <INDENT> npc += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> npc -= 1 <NEWLINE> <DEDENT> if npc <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> r0 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r0 = ( ( r0 * 2 ) + int ( S [ i ] ) ) % npc <NEWLINE> <DEDENT> k = 1 <NEWLINE> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> if int ( S [ i ] ) == b : <NEWLINE> <INDENT> r = r0 <NEWLINE> if b == 0 : <NEWLINE> <INDENT> r = ( r + k ) % npc <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( r - k + npc ) % npc <NEWLINE> <DEDENT> ans [ i ] = f ( r ) + 1 <NEWLINE> <DEDENT> k = ( k * 2 ) % npc <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if sum ( list ( map ( int , str ( N ) ) ) ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
input ( ) <NEWLINE> a = 1 <NEWLINE> d = 1000000000000000000 <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> a = min ( a * int ( i ) , d + 1 ) <NEWLINE> <DEDENT> print ( [ a , - 1 ] [ a > d ] ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for a in list ( A ) : <NEWLINE> <INDENT> result *= a <NEWLINE> if ( result > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = 0 <NEWLINE> Q = [ 0 ] + [ 1 for _ in range ( N - 1 ) ] <NEWLINE> R = [ - 1 ] + [ 0 for _ in range ( N - 1 ) ] <NEWLINE> L = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> P = A [ P ] - 1 <NEWLINE> if Q [ P ] == 0 : <NEWLINE> <INDENT> L = i - R [ P ] <NEWLINE> S = ( K - R [ P ] - 1 ) % L <NEWLINE> G = 0 <NEWLINE> for j in range ( S + R [ P ] + 1 ) : <NEWLINE> <INDENT> G = A [ G ] - 1 <NEWLINE> <DEDENT> print ( G + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if Q [ P ] == 1 : <NEWLINE> <INDENT> R [ P ] = i <NEWLINE> Q [ P ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( P + 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> graph [ i ] = list ( ) <NEWLINE> <DEDENT> for i in range ( M ) : <COMMENT> <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> graph [ 0 ] . append ( 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> ans [ 1 ] = 0 <NEWLINE> dis_stack = list ( ) <NEWLINE> dis_stack . extend ( graph [ 0 ] ) <NEWLINE> bef_stack = [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> while dis_stack : <NEWLINE> <INDENT> now_watch = dis_stack . pop ( 0 ) <NEWLINE> next_watch = graph [ now_watch ] <NEWLINE> for spot in next_watch : <NEWLINE> <INDENT> if ( ans [ spot ] != - 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> dis_stack . append ( spot ) <NEWLINE> ans [ spot ] = now_watch <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans . pop ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( s [ : 3 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> threshold = 1000000007 <NEWLINE> tmp = sum ( list_A [ 1 : ] ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += list_A [ i ] * tmp % threshold <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = tmp - list_A [ i ] <NEWLINE> ans += ( list_A [ i ] * tmp % threshold ) <NEWLINE> <DEDENT> <DEDENT> ans = ans % threshold <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> es = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> es [ u - 1 ] . append ( [ v , w ] ) <NEWLINE> es [ v - 1 ] . append ( [ u , w ] ) <NEWLINE> <NL> <DEDENT> colors = [ 0 for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> def dfs ( v , color ) : <NEWLINE> <INDENT> colors [ v - 1 ] = color <NEWLINE> for i in es [ v - 1 ] : <NEWLINE> <INDENT> if i [ 1 ] % 2 == 0 and colors [ i [ 0 ] - 1 ] == 0 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , color ) <NEWLINE> <DEDENT> elif i [ 1 ] % 2 == 1 and colors [ i [ 0 ] - 1 ] == 0 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , ( - 1 ) * color ) <NEWLINE> <DEDENT> <DEDENT> return colors <NEWLINE> <NL> <NL> <DEDENT> a = dfs ( 1 , - 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> class TreeNode ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . key = None <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <DEDENT> def inoder ( self ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> if self . left : <NEWLINE> <INDENT> r += self . left . inoder ( ) <NEWLINE> <DEDENT> r += [ self . key ] <NEWLINE> if self . right : <NEWLINE> <INDENT> r += self . right . inoder ( ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def preoder ( self ) : <NEWLINE> <INDENT> r = [ self . key ] <NEWLINE> if self . left : <NEWLINE> <INDENT> r += self . left . preoder ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> r += self . right . preoder ( ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> class BinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . root . inoder ( ) ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . root . preoder ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> currentNode = self . root <NEWLINE> while currentNode : <NEWLINE> <INDENT> if key == currentNode . key : <NEWLINE> <INDENT> return currentNode <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if key < currentNode . key : <NEWLINE> <INDENT> currentNode = currentNode . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> currentNode = currentNode . right <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> def next ( self , key ) : <NEWLINE> <INDENT> return self . min ( key . right ) <NEWLINE> <DEDENT> def min ( self , key ) : <NEWLINE> <INDENT> while key . left is not None : <NEWLINE> <INDENT> key = key . left <NEWLINE> <DEDENT> return key <NEWLINE> <NL> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> z = self . find ( key ) <NEWLINE> if z == False : return <NEWLINE> if z . left and z . right : <NEWLINE> <INDENT> y = self . next ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = z <NEWLINE> if z == self . root : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> <DEDENT> if z . left : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <DEDENT> if x : <NEWLINE> <INDENT> x . parent = y . parent <NEWLINE> <DEDENT> if y . parent is None : <NEWLINE> <INDENT> self . root = x <NEWLINE> <DEDENT> elif y == y . parent . left : <NEWLINE> <INDENT> y . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . right = x <NEWLINE> <DEDENT> if y != z : <NEWLINE> <INDENT> z . key = y . key <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> Tree = BinaryTree ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L = input ( ) . split ( ) <NEWLINE> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> Node = TreeNode ( ) <NEWLINE> Node . key = int ( L [ 1 ] ) <NEWLINE> Tree . insert ( Node ) <NEWLINE> <DEDENT> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> Tree . show ( ) <NEWLINE> <DEDENT> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> if Tree . find ( int ( L [ 1 ] ) ) == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> Tree . delete ( int ( L [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
def merge ( A , left , mid , right ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> L = A [ left : mid ] + [ 1000000001 ] <NEWLINE> R = A [ mid : right ] + [ 1000000001 ] <NEWLINE> <NL> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ cnt1 ] <= R [ cnt2 ] : <NEWLINE> <INDENT> A [ k ] = L [ cnt1 ] <NEWLINE> cnt1 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ cnt2 ] <NEWLINE> cnt2 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> global cnt <NEWLINE> cnt += cnt1 + cnt2 <NEWLINE> <NL> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> <NL> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( A , 0 , len ( A ) ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( str ( cnt ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> seven = 7 <NEWLINE> count = 0 <NEWLINE> <NL> if ( K % 2 == 0 or K % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> if ( K == 7 or K == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> seven = ( seven * 10 + 7 ) % K <NEWLINE> if ( seven % K == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import string <NEWLINE> S = [ item for item in input ( ) ] <NEWLINE> temp_abc = [ item for item in string . ascii_lowercase ] <NEWLINE> <NL> if len ( S ) < 26 : <NEWLINE> <INDENT> for item in S : <NEWLINE> <INDENT> temp_abc . remove ( item ) <NEWLINE> <DEDENT> res = <STRING> . join ( S ) + temp_abc [ 0 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if S == temp_abc [ : : - 1 ] : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail_inorder = [ ] <NEWLINE> prev = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for item in S [ : : - 1 ] : <NEWLINE> <INDENT> if item >= prev : <NEWLINE> <INDENT> tail_inorder += [ item ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prev = item <NEWLINE> <DEDENT> end_letter = S [ - 1 * ( cnt + 1 ) ] <NEWLINE> tail_inorder . sort ( ) <NEWLINE> for item in tail_inorder : <NEWLINE> <INDENT> if end_letter < item : <NEWLINE> <INDENT> res_end_letter = item <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> res = S [ : - 1 * ( cnt + 1 ) ] + [ res_end_letter ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( res ) ) if res != - 1 else print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
price = [ 1 , 5 , 10 , 50 , 100 , 500 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p , n = values [ 0 ] , values [ 1 : ] <NEWLINE> ans = 1e100 <NEWLINE> if p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> p_sum = sum ( map ( lambda s : s [ 0 ] * s [ 1 ] , zip ( price , n ) ) ) <NEWLINE> <NL> for change in range ( 1000 ) : <NEWLINE> <INDENT> total = p + change <NEWLINE> pay = [ 0 ] * 6 <NEWLINE> for i in reversed ( range ( 6 ) ) : <NEWLINE> <INDENT> if total >= price [ i ] : <NEWLINE> <INDENT> pay [ i ] = min ( n [ i ] , int ( total / price [ i ] ) ) <NEWLINE> total -= pay [ i ] * price [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if total > 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> coins = sum ( pay ) <NEWLINE> <NL> _change = change <NEWLINE> for i in reversed ( range ( 6 ) ) : <NEWLINE> <INDENT> if _change >= price [ i ] : <NEWLINE> <INDENT> coins += int ( _change / price [ i ] ) <NEWLINE> _change %= price [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = min ( ans , coins ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> if len ( s ) < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if s [ 1 ] == <STRING> or s [ 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == len ( s ) - 1 : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> or <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
def maximum_profit ( n ) : <NEWLINE> <INDENT> maxv = min ( n ) - max ( n ) <NEWLINE> minv = n [ 0 ] <NEWLINE> for i in range ( 1 , len ( n ) ) : <NEWLINE> <INDENT> maxv = n [ i ] - minv if maxv < n [ i ] - minv else maxv <NEWLINE> minv = n [ i ] if minv > n [ i ] else minv <NEWLINE> <DEDENT> return maxv <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> numbers = [ int ( input ( ) ) for i in range ( 0 , n ) ] <NEWLINE> print ( maximum_profit ( numbers ) ) <NEWLINE> <NL> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> <NL> order = dict ( zip ( num , a ) ) <NEWLINE> <NL> order2 = sorted ( order . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( order2 [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ str ( n ) for n in ans ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import heapq <NEWLINE> <NL> distance = ( <NEWLINE> <INDENT> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) , <NEWLINE> ( 6 , 5 , 4 , 3 , 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 ) , <NEWLINE> ) <NEWLINE> <NL> <DEDENT> def d_manhattan ( node_list ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( 16 ) : <NEWLINE> <INDENT> j = node_list [ i ] - 1 <NEWLINE> if j == - 1 : continue <NEWLINE> s += distance [ i ] [ j ] <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def moveNode ( node_list , space , direction ) : <NEWLINE> <INDENT> node_tmp = node_list [ : ] <NEWLINE> node_tmp [ space ] , node_tmp [ space + direction ] = node_tmp [ space + direction ] , node_tmp [ space ] <NEWLINE> return node_tmp <NEWLINE> <NL> <DEDENT> class board : <NEWLINE> <INDENT> def __init__ ( self , node_list , move ) : <NEWLINE> <INDENT> self . node = node_list <NEWLINE> self . space = node_list . index ( 0 ) <NEWLINE> self . move = move <NEWLINE> self . h = d_manhattan ( node_list ) <NEWLINE> self . f = self . move + self . h <NEWLINE> <NL> <DEDENT> def makeBoard ( self , node_close ) : <NEWLINE> <INDENT> node_now = self . node <NEWLINE> space = self . space <NEWLINE> move = self . move <NEWLINE> x_s = space % 4 <NEWLINE> y_s = space // 4 <NEWLINE> if x_s < 3 : <NEWLINE> <INDENT> node_tmp = moveNode ( node_now , space , 1 ) <NEWLINE> if tuple ( node_tmp ) not in node_close : <NEWLINE> <INDENT> yield board ( node_tmp , move + 1 ) <NEWLINE> <DEDENT> <DEDENT> if x_s > 0 : <NEWLINE> <INDENT> node_tmp = moveNode ( node_now , space , - 1 ) <NEWLINE> if tuple ( node_tmp ) not in node_close : <NEWLINE> <INDENT> yield board ( node_tmp , move + 1 ) <NEWLINE> <DEDENT> <DEDENT> if y_s < 3 : <NEWLINE> <INDENT> node_tmp = moveNode ( node_now , space , 4 ) <NEWLINE> if tuple ( node_tmp ) not in node_close : <NEWLINE> <INDENT> yield board ( node_tmp , move + 1 ) <NEWLINE> <DEDENT> <DEDENT> if y_s > 0 : <NEWLINE> <INDENT> node_tmp = moveNode ( node_now , space , - 4 ) <NEWLINE> if tuple ( node_tmp ) not in node_close : <NEWLINE> <INDENT> yield board ( node_tmp , move + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> b_open = [ ] <NEWLINE> n_close = set ( ) <NEWLINE> n_goal = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 0 ] <NEWLINE> n_start = [ ] <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n_start . extend ( inp ) <NEWLINE> <NL> <DEDENT> b_start = board ( n_start , 0 ) <NEWLINE> heapq . heappush ( b_open , ( b_start . f , b_start . h , 0 , b_start ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while b_open : <NEWLINE> <INDENT> _ , _ , _ , b_now = heapq . heappop ( b_open ) <NEWLINE> if b_now . node == n_goal : <NEWLINE> <INDENT> b_goal = b_now <NEWLINE> break <NEWLINE> <DEDENT> n_close . add ( tuple ( b_now . node ) ) <NEWLINE> for b_new in b_now . makeBoard ( n_close ) : <NEWLINE> <INDENT> heapq . heappush ( b_open , ( b_new . f , b_new . h , i , b_new ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b_goal . move ) <NEWLINE>
import sys <NEWLINE> <NL> BLOCK_WIDTH = 4 <NEWLINE> BLOCK_HEIGHT = 2 <NEWLINE> field = [ ] <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> w = 0 <NEWLINE> h = 0 <NEWLINE> xg = 0 <NEWLINE> yg = 0 <NEWLINE> start_color = 0 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> global field , w , h , c , xg , yg , start_color <NEWLINE> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> xs , ys = map ( int , input ( ) . split ( ) ) <NEWLINE> xg , yg = map ( int , input ( ) . split ( ) ) <NEWLINE> xs -= 1 <NEWLINE> ys -= 1 <NEWLINE> xg -= 1 <NEWLINE> yg -= 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> field = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , d , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> arrangement ( c , d , x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> start_color = field [ ys ] [ xs ] <NEWLINE> if dfs ( xs , ys ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def arrangement ( c , d , x , y ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> [ [ draw ( x + j , y + i , c ) for j in range ( BLOCK_WIDTH ) ] for i in range ( BLOCK_HEIGHT ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ [ draw ( x + j , y + i , c ) for j in range ( BLOCK_HEIGHT ) ] for i in range ( BLOCK_WIDTH ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def draw ( x , y , c ) : <NEWLINE> <INDENT> global field <NEWLINE> field [ y ] [ x ] = c <NEWLINE> <NL> <NL> <DEDENT> def dfs ( x , y ) : <NEWLINE> <INDENT> global field <NEWLINE> <NL> if x == xg and y == yg : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if start_color == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> field [ y ] [ x ] = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> next_x = x + dx [ i ] <NEWLINE> next_y = y + dy [ i ] <NEWLINE> if next_x < 0 or next_x >= w or next_y < 0 or next_y >= h : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ next_y ] [ next_x ] != start_color : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dfs ( next_x , next_y ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] ; b = [ - 1 ] * n ; b [ 0 ] = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ u - 1 ] . append ( [ v - 1 , w ] ) ; a [ v - 1 ] . append ( [ u - 1 , w ] ) <NEWLINE> <DEDENT> def dfs ( A , k ) : <NEWLINE> <INDENT> for i in A [ k ] : <NEWLINE> <INDENT> if b [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> b [ i [ 0 ] ] = b [ k ] + i [ 1 ] <NEWLINE> dfs ( A , i [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( a , 0 ) <NEWLINE> for i in b : <NEWLINE> <INDENT> print ( 0 ) if i % 2 == 0 else print ( 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> SA = abs ( A - B ) <NEWLINE> CHIJI = ( V - W ) <NEWLINE> SA = SA - ( CHIJI * T ) <NEWLINE> <COMMENT> <NL> <NL> if SA <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> import math <NEWLINE> import sys <NEWLINE> A = [ math . pow ( i , 5 ) for i in range ( - 1000 , 1000 , 1 ) ] <NEWLINE> B = [ math . pow ( i , 5 ) for i in range ( - 1000 , 1000 , 1 ) ] <NEWLINE> for n in A : <NEWLINE> <INDENT> for m in B : <NEWLINE> <INDENT> if n - m == x : <NEWLINE> <INDENT> print ( - 1000 + A . index ( n ) , - 1000 + B . index ( m ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> resA = 0 <NEWLINE> resB = 0 <NEWLINE> for a in range ( 500 ) : <NEWLINE> <INDENT> for b in range ( - 500 , 500 ) : <NEWLINE> <INDENT> A = a ** 5 <NEWLINE> B = b ** 5 <NEWLINE> N = A - B <NEWLINE> if A - B == x : <NEWLINE> <INDENT> resA = a <NEWLINE> resB = b <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if A - B == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( resA , resB ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> <NL> def dubbling ( a : np . array , k : int , MAXk = 10 ** 12 ) -> np . array : <NEWLINE> <INDENT> bl = MAXk . bit_length ( ) <NEWLINE> b = np . empty ( [ bl , len ( a ) + 1 ] , dtype = np . int64 ) <NEWLINE> b [ 0 ] = np . append ( a , - 1 ) <NEWLINE> for i in range ( 1 , bl ) : <NEWLINE> <INDENT> x = b [ i - 1 ] <NEWLINE> b [ i ] = x [ x ] <NEWLINE> <DEDENT> X1 = b [ np . array ( list ( format ( k , <STRING> + str ( bl ) + <STRING> ) ) , dtype = np . int8 ) . astype ( np . bool ) [ : : - 1 ] ] <NEWLINE> ret = np . append ( np . arange ( len ( a ) ) , - 1 ) <NEWLINE> for i in X1 : <NEWLINE> <INDENT> ret = ret [ i ] <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( read ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> maxk = 10 ** 18 <NEWLINE> <NL> ans = dubbling ( a - 1 , k , MAXk = maxk ) [ 0 ] + 1 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in str ( n ) : <NEWLINE> <INDENT> total += int ( i ) <NEWLINE> <NL> <DEDENT> if total % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , W = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> value = [ ] <NEWLINE> weight = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> value . append ( a ) <NEWLINE> weight . append ( b ) <NEWLINE> <DEDENT> def knap ( N , W , value , weight ) : <NEWLINE> <INDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for w in range ( W + 1 ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if weight [ i - 1 ] <= w : <NEWLINE> <INDENT> dp [ i ] [ w ] = max ( dp [ i - 1 ] [ w ] , dp [ i - 1 ] [ w - weight [ i - 1 ] ] + value [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ w ] = dp [ i - 1 ] [ w ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp [ N ] [ W ] <NEWLINE> <DEDENT> print ( knap ( N , W , value , weight ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif A [ 0 ] == 1 and A [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Eratos = [ False ] * 1000001 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if Eratos [ A [ i ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i < N - 1 and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( A [ i ] , 1000001 , A [ i ] ) : <NEWLINE> <INDENT> Eratos [ j ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( N - ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> memo = { } <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ab = math . gcd ( a , b ) <NEWLINE> try : <NEWLINE> <INDENT> memo [ gcd_ab ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> memo [ gcd_ab ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for key in memo . keys ( ) : <NEWLINE> <INDENT> ans += math . gcd ( c , key ) * memo [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class D_Linked_List : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , next = None , prev = None ) : <NEWLINE> <INDENT> self . next = next <NEWLINE> self . prev = prev <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nil = D_Linked_List . Node ( None ) <NEWLINE> self . nil . next = self . nil <NEWLINE> self . nil . prev = self . nil <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> node_x = D_Linked_List . Node ( key , self . nil . next , self . nil ) <NEWLINE> self . nil . next . prev = node_x <NEWLINE> self . nil . next = node_x <NEWLINE> <NL> <DEDENT> def _listSearch ( self , key ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> while ( cur_node != self . nil ) and ( cur_node . key != key ) : <NEWLINE> <INDENT> cur_node = cur_node . next <NEWLINE> <DEDENT> return cur_node <NEWLINE> <NL> <DEDENT> def _deleteNode ( self , node ) : <NEWLINE> <INDENT> if node == self . nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . prev ) <NEWLINE> <NL> <DEDENT> def deleteKey ( self , key ) : <NEWLINE> <INDENT> node = self . _listSearch ( key ) <NEWLINE> self . _deleteNode ( node ) <NEWLINE> <NL> <DEDENT> def show_keys ( self ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> keys_str = <STRING> <NEWLINE> while cur_node != self . nil : <NEWLINE> <INDENT> keys_str += <STRING> . format ( cur_node . key ) <NEWLINE> cur_node = cur_node . next <NEWLINE> <DEDENT> print ( keys_str . rstrip ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> d_ll = D_Linked_List ( ) <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> x = int ( i . split ( ) [ 1 ] ) <NEWLINE> d_ll . insert ( x ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteFirst ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteLast ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> x = int ( i . split ( ) [ 1 ] ) <NEWLINE> d_ll . deleteKey ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> d_ll . show_keys ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import numpy as np <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> rad = 0 <NEWLINE> k = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> y += np . cos ( rad * np . pi / 180 ) <NEWLINE> x += np . sin ( rad * np . pi / 180 ) <NEWLINE> if x < 0.0001 and y < 0.0001 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> rad += n <NEWLINE> <DEDENT> <DEDENT>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( h2 * 60 + m2 - k ) - ( h1 * 60 + m1 ) <NEWLINE> print ( x ) <NEWLINE>
K , S = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if x > S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if x + y > S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif x + y + K < S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a [ : 3 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ ] <NEWLINE> m = 10 ** 17 <NEWLINE> for p in P : <NEWLINE> <INDENT> m = min ( m , p ) <NEWLINE> Q . append ( m ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for x , y in zip ( P , Q ) : <NEWLINE> <INDENT> if x <= y : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> anslist = [ ] <NEWLINE> def sarch ( i , j , visited ) : <NEWLINE> <NL> <INDENT> if 0 < i : <NEWLINE> <INDENT> if visited [ i - 1 ] [ j ] == 0 : <NEWLINE> <INDENT> visited [ i - 1 ] [ j ] = 1 <NEWLINE> sarch ( i - 1 , j , visited ) <NEWLINE> <DEDENT> if 0 < j : <NEWLINE> <INDENT> if visited [ i - 1 ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> visited [ i - 1 ] [ j - 1 ] = 1 <NEWLINE> sarch ( i - 1 , j - 1 , visited ) <NEWLINE> <DEDENT> <DEDENT> if j < len ( visited [ 0 ] ) - 1 : <NEWLINE> <INDENT> if visited [ i - 1 ] [ j + 1 ] == 0 : <NEWLINE> <INDENT> visited [ i - 1 ] [ j + 1 ] = 1 <NEWLINE> sarch ( i - 1 , j + 1 , visited ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if i < len ( visited ) - 1 : <NEWLINE> <INDENT> if visited [ i + 1 ] [ j ] == 0 : <NEWLINE> <INDENT> visited [ i + 1 ] [ j ] = 1 <NEWLINE> sarch ( i + 1 , j , visited ) <NEWLINE> <DEDENT> if 0 < j : <NEWLINE> <INDENT> if visited [ i + 1 ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> visited [ i + 1 ] [ j - 1 ] = 1 <NEWLINE> sarch ( i + 1 , j - 1 , visited ) <NEWLINE> <DEDENT> <DEDENT> if j < len ( visited [ 0 ] ) - 1 : <NEWLINE> <INDENT> if visited [ i + 1 ] [ j + 1 ] == 0 : <NEWLINE> <INDENT> visited [ i + 1 ] [ j + 1 ] = 1 <NEWLINE> sarch ( i + 1 , j + 1 , visited ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if 0 < j : <NEWLINE> <INDENT> if visited [ i ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> visited [ i ] [ j - 1 ] = 1 <NEWLINE> sarch ( i , j - 1 , visited ) <NEWLINE> <DEDENT> <DEDENT> if j < len ( visited [ 0 ] ) - 1 : <NEWLINE> <INDENT> if visited [ i ] [ j + 1 ] == 0 : <NEWLINE> <INDENT> visited [ i ] [ j + 1 ] = 1 <NEWLINE> sarch ( i , j + 1 , visited ) <NEWLINE> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> grid = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( h ) ] <NEWLINE> visited = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> starti = 0 <NEWLINE> startj = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == 0 : <NEWLINE> <INDENT> visited [ i ] [ j ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> if i >= h : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if j >= w : <NEWLINE> <INDENT> j = 0 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> if visited [ i ] [ j ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> visited [ i ] [ j ] = 1 <NEWLINE> visited = sarch ( i , j , visited ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <COMMENT> <NL> if cnt > w * h : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> anslist . append ( ans ) <NEWLINE> <NL> <DEDENT> for i in anslist : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> n2 = n <NEWLINE> for i in range ( 2 , int ( n2 ** 0.5 // 1 + 1 ) ) : <NEWLINE> <INDENT> index = 0 <NEWLINE> while n2 % i == 0 : <NEWLINE> <INDENT> index += 1 <NEWLINE> n2 = n2 // i <NEWLINE> <DEDENT> if index != 0 : <NEWLINE> <INDENT> p . append ( index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> t = 1 <NEWLINE> <NL> if n2 == 1 : <NEWLINE> <INDENT> next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif not p : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> while p [ i ] - t >= 0 : <NEWLINE> <INDENT> p [ i ] -= t <NEWLINE> count += 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> t = 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
def score ( c , s , t , lis ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> lis = [ 0 ] * 26 <NEWLINE> ans += s [ t - 1 ] <NEWLINE> lis [ t - 1 ] = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if t - 1 != j : <NEWLINE> <INDENT> lis [ j ] += 1 <NEWLINE> ans -= lis [ j ] * c [ j ] <NEWLINE> <DEDENT> <DEDENT> return ans , lis <NEWLINE> <NL> <DEDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * d <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> lis = [ 0 ] * 26 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> z = 0 <NEWLINE> L = lis <NEWLINE> q = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> y , p = score ( c , s [ i ] , j , L ) <NEWLINE> if ans < y : <NEWLINE> <INDENT> ans = y <NEWLINE> z = j <NEWLINE> q = p <NEWLINE> <DEDENT> <DEDENT> print ( z + 1 ) <NEWLINE> lis = q <NEWLINE> <DEDENT>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( float ( r * r * pi ) , float ( 2 * r * pi ) ) ) <NEWLINE>
from collections import deque <NEWLINE> S = input ( ) . strip ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> a = [ 0 if x == <STRING> else 1 for x in S ] <NEWLINE> <NL> q = deque ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if q : <NEWLINE> <INDENT> if q [ - 1 ] != i : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( q ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if scores [ i ] > scores [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> count = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for a in c : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
mod = 2019 <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> w = 0 <NEWLINE> d = [ 0 ] * mod <NEWLINE> p = 1 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> w += int ( s [ i ] ) * p <NEWLINE> p *= 10 <NEWLINE> p %= mod <NEWLINE> w %= mod <NEWLINE> d [ w ] += 1 <NEWLINE> <DEDENT> d [ 0 ] += 1 <NEWLINE> o = 0 <NEWLINE> for x in d : <NEWLINE> <INDENT> o += x * ( x - 1 ) // 2 <NEWLINE> <DEDENT> print ( o ) <NEWLINE>
import math <NEWLINE> <NL> def floor ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> print ( floor ( A , B , x ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> ss = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> s += math . gcd ( ss , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MONEY = [ ] <NEWLINE> UNDERSTAND = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> MONEY . append ( lst [ 0 ] ) <NEWLINE> UNDERSTAND . append ( lst [ 1 : ] ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <INDENT> understand = [ 0 ] * m <NEWLINE> money = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> money += MONEY [ j ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> understand [ k ] += UNDERSTAND [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> if all ( [ i >= x for i in understand ] ) : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = money <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , money ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def solve ( h , w , a ) : <NEWLINE> <INDENT> used = [ [ True ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> used [ r + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , a [ r ] ) <NEWLINE> for c in range ( w ) : <NEWLINE> <INDENT> if a [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> que . append ( ( r + 1 , c + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> neighbors = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> r , c , k = que . popleft ( ) <NEWLINE> for dr , dc in neighbors : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if not used [ nr ] [ nc ] : <NEWLINE> <INDENT> que . append ( ( nr , nc , k + 1 ) ) <NEWLINE> used [ nr ] [ nc ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> print ( solve ( h , w , a ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( a * min ( n , b - 1 ) / b ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> num_node = int ( input ( ) ) <NEWLINE> relation = [ [ [ ] , [ ] ] for i in range ( num_node + 1 ) ] <NEWLINE> for i in range ( num_node - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w % 2 == 0 : <NEWLINE> <INDENT> relation [ u ] [ 0 ] . append ( v ) <NEWLINE> relation [ v ] [ 0 ] . append ( u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> relation [ u ] [ 1 ] . append ( v ) <NEWLINE> relation [ v ] [ 1 ] . append ( u ) <NEWLINE> <DEDENT> <DEDENT> colors = [ None ] * ( num_node + 1 ) <NEWLINE> <NL> <NL> def dfs ( n : int , c : int ) : <NEWLINE> <INDENT> colors [ n ] = c <NEWLINE> <COMMENT> <NL> for even_idx in relation [ n ] [ 0 ] : <NEWLINE> <INDENT> if colors [ even_idx ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( even_idx , colors [ n ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for odd_idx in relation [ n ] [ 1 ] : <NEWLINE> <INDENT> if colors [ odd_idx ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( odd_idx , 1 - colors [ n ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dfs ( 1 , 0 ) <NEWLINE> for ans in list ( map ( int , colors [ 1 : ] ) ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> mul = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> mul *= a <NEWLINE> <NL> if mul > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
alphabet = <STRING> <NEWLINE> from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> adict = defaultdict ( int ) <NEWLINE> <NL> for l in sys . stdin : <NEWLINE> <INDENT> for c in l . lower ( ) : <NEWLINE> <INDENT> adict [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k in alphabet : <NEWLINE> <INDENT> print ( <STRING> % ( k , adict [ k ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , d , mods = 0 , 1 , [ 1 ] + [ 0 ] * 2019 <NEWLINE> for i in reversed ( input ( ) ) : <NEWLINE> <INDENT> n = ( n + int ( i ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> mods [ n ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in mods ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if x - diff not in list_ : <NEWLINE> <INDENT> print ( x - diff ) <NEWLINE> break <NEWLINE> <DEDENT> if x + diff not in list_ : <NEWLINE> <INDENT> print ( x + diff ) <NEWLINE> break <NEWLINE> <DEDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u , k = inp [ 0 ] , inp [ 1 ] <NEWLINE> v = inp [ 2 : ] <NEWLINE> if k != 0 : <NEWLINE> <INDENT> for vv in v : <NEWLINE> <INDENT> result [ u - 1 ] [ vv - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = list ( result ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( * result [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> c = [ <STRING> ] * n <NEWLINE> c [ 0 ] = <STRING> <NEWLINE> x = 0 <NEWLINE> y = 1 <NEWLINE> while x != k : <NEWLINE> <INDENT> c [ y - 1 ] = <STRING> <NEWLINE> x += 1 <NEWLINE> y = a [ y - 1 ] <NEWLINE> b [ x - 1 ] = y <NEWLINE> if c [ y - 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if x != k : <NEWLINE> <INDENT> y = b . index ( a [ y - 1 ] ) <NEWLINE> k -= x <NEWLINE> k %= ( x - y ) <NEWLINE> c = b [ y : x ] <NEWLINE> print ( c [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import os <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> lst = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for i in range ( 0 , int ( input ( ) ) ) : <NEWLINE> <INDENT> temp = float ( input ( ) ) <NEWLINE> if temp < 165 : <NEWLINE> <INDENT> lst [ 0 ] += 1 <NEWLINE> <DEDENT> elif temp < 170 : <NEWLINE> <INDENT> lst [ 1 ] += 1 <NEWLINE> <DEDENT> elif temp < 175 : <NEWLINE> <INDENT> lst [ 2 ] += 1 <NEWLINE> <DEDENT> elif temp < 180 : <NEWLINE> <INDENT> lst [ 3 ] += 1 <NEWLINE> <DEDENT> elif temp < 185 : <NEWLINE> <INDENT> lst [ 4 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ 5 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , 6 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 ) , end = <STRING> ) <NEWLINE> for j in range ( 0 , lst [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from math import floor <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> i = min ( n , b - 1 ) <NEWLINE> print ( floor ( a * i / b ) - a * floor ( i / b ) ) <NEWLINE>
import collections <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 for _ in range ( Q ) ] <NEWLINE> C = [ 0 for _ in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = collections . Counter ( A ) <NEWLINE> S = np . sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> S += ( C [ i ] - B [ i ] ) * a [ B [ i ] ] <NEWLINE> a [ C [ i ] ] += a [ B [ i ] ] <NEWLINE> a [ B [ i ] ] = 0 <NEWLINE> <NL> print ( S ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> B . sort ( ) <NEWLINE> C = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += bisect_right ( C , B [ i ] ) - bisect_left ( C , B [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
B = [ False ] * 100005 <NEWLINE> C = [ 0 ] * 100005 <NEWLINE> for i in range ( 2 , 100001 ) : <NEWLINE> <INDENT> if not B [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , 100001 , i ) : <NEWLINE> <INDENT> B [ j ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 , 100001 , 2 ) : <NEWLINE> <INDENT> if not B [ i ] and not B [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 , 100001 ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( C [ b ] - C [ a - 1 ] ) <NEWLINE> <DEDENT>
import queue <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_list = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> edge_que = queue . Queue ( ) <NEWLINE> edge_que . put ( A_list [ 0 ] ) <NEWLINE> score = 0 <NEWLINE> for i , a in enumerate ( A_list [ 1 : ] ) : <NEWLINE> <INDENT> score += edge_que . get ( ) <NEWLINE> edge_que . put ( a ) <NEWLINE> edge_que . put ( a ) <NEWLINE> <DEDENT> print ( score ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = k <NEWLINE> while i < len ( listA ) : <NEWLINE> <INDENT> if listA [ i ] > listA [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if n - k < a_list . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( sum ( [ 1 for a in a_list if np . sign ( a ) != - 1 ] ) == 0 and k % 2 == 1 ) or ( k == n and len ( [ 1 for a in a_list if np . sign ( a ) == - 1 ] ) % 2 == 1 ) : <NEWLINE> <INDENT> a_list . sort ( key = abs ) <NEWLINE> ans = 1 <NEWLINE> for num in a_list [ : k ] : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_list . sort ( key = abs , reverse = True ) <NEWLINE> add = 1 <NEWLINE> remove = 1 <NEWLINE> if len ( [ a for a in a_list [ : k ] if np . sign ( a ) == - 1 ] ) % 2 != 0 : <NEWLINE> <INDENT> negative_big = [ num for num in a_list [ : k ] if np . sign ( num ) == - 1 ] <NEWLINE> positive_big = [ num for num in a_list [ : k ] if np . sign ( num ) != - 1 ] <NEWLINE> negative_small = [ num for num in a_list [ k : ] if np . sign ( num ) == - 1 ] <NEWLINE> positive_small = [ num for num in a_list [ k : ] if np . sign ( num ) != - 1 ] <NEWLINE> <NL> <NL> if len ( negative_big ) == 0 or len ( positive_small ) == 0 : <NEWLINE> <INDENT> remove = min ( positive_big ) <NEWLINE> add = min ( negative_small ) <NEWLINE> <DEDENT> elif len ( positive_big ) == 0 or len ( negative_small ) == 0 : <NEWLINE> <INDENT> remove = max ( negative_big ) <NEWLINE> add = max ( positive_small ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> positive_small_max = max ( positive_small ) <NEWLINE> negative_big_max = max ( negative_big ) <NEWLINE> negative_small_min = min ( negative_small ) <NEWLINE> positive_big_min = min ( positive_big ) <NEWLINE> if positive_small_max * positive_big_min > negative_small_min * negative_big_max : <NEWLINE> <INDENT> remove = negative_big_max <NEWLINE> add = positive_small_max <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remove = positive_big_min <NEWLINE> add = negative_small_min <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for num in a_list [ : k ] : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> if len ( [ a for a in a_list [ : k ] if np . sign ( a ) == - 1 ] ) % 2 != 0 : <NEWLINE> <INDENT> ans *= add <NEWLINE> ans %= mod <NEWLINE> ans *= pow ( remove , mod - 2 , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> import itertools <NEWLINE> <NL> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> pos = [ m . end ( ) for m in re . finditer ( <STRING> , s ) ] <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for p in pos : <NEWLINE> <INDENT> dp [ p ] = 1 <NEWLINE> <DEDENT> dp = list ( itertools . accumulate ( dp ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans . append ( dp [ r ] - dp [ l ] ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if not arr : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> p = factorization ( N ) <NEWLINE> count = 0 <NEWLINE> for x in p : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( 1 , x [ 1 ] + 1 ) : <NEWLINE> <INDENT> if N % ( x [ 0 ] ** j ) == 0 : <NEWLINE> <INDENT> N /= x [ 0 ] ** j <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h1 > h2 : <NEWLINE> <INDENT> h2 = h2 + 24 <NEWLINE> <DEDENT> if m2 >= m1 : <NEWLINE> <INDENT> mk = m2 - m1 <NEWLINE> T = mk + ( h2 - h1 ) * 60 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mk = m2 + 60 - m1 <NEWLINE> T = mk + ( h2 - h1 - 1 ) * 60 <NEWLINE> <DEDENT> print ( T - k ) <NEWLINE>
<COMMENT> <NL> import random <NEWLINE> random . seed ( 0 ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> answer = [ ] <NEWLINE> <NL> def manzoku ( A ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> L = [ 0 for _ in range ( 26 ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S = list_S [ i ] <NEWLINE> contest_index = A [ i ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j == contest_index : <NEWLINE> <INDENT> L [ j ] = 0 <NEWLINE> score += S [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ j ] += C [ j ] <NEWLINE> score -= L [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> L = [ 0 for _ in range ( 26 ) ] <NEWLINE> for S in list_S : <NEWLINE> <INDENT> contest_index = - 1 <NEWLINE> contest_manzoku = - 10 ** 9 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> i_manzoku = S [ i ] + C [ i ] + L [ i ] <NEWLINE> if i_manzoku > contest_manzoku : <NEWLINE> <INDENT> contest_index = i <NEWLINE> contest_manzoku = i_manzoku <NEWLINE> <DEDENT> <DEDENT> answer . append ( contest_index ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if i == contest_index : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] += C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> answer = [ 0 for _ in range ( D ) ] <NEWLINE> manzoku_now = manzoku ( answer ) <NEWLINE> <NL> answer_tmp = [ answer [ i ] for i in range ( D ) ] <NEWLINE> for j in range ( 365 ) : <NEWLINE> <INDENT> day = j % D <NEWLINE> contest = random . randrange ( 26 ) <NEWLINE> answer_tmp = [ answer [ i ] for i in range ( D ) ] <NEWLINE> answer_tmp [ day ] = contest <NEWLINE> if manzoku_now < manzoku ( answer_tmp ) : <NEWLINE> <INDENT> manzoku_now = manzoku ( answer_tmp ) <NEWLINE> answer [ day ] = contest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer_tmp [ day ] = answer [ day ] <NEWLINE> <NL> <DEDENT> <DEDENT> for index in answer : <NEWLINE> <INDENT> print ( index + 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = str ( a / b ) <NEWLINE> sum = 0 <NEWLINE> x = s . index ( <STRING> ) + 1 <NEWLINE> for i in s [ x : x + n ] : <NEWLINE> <INDENT> sum += int ( i ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
R , G , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> x = N - R * r <NEWLINE> for g in range ( x // G + 1 ) : <NEWLINE> <INDENT> if ( x - G * g ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> pos_a = s . find ( <STRING> ) <NEWLINE> pos_z = s . rfind ( <STRING> ) <NEWLINE> <NL> print ( pos_z - pos_a + 1 ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> dic = defaultdict ( int ) <NEWLINE> dic [ 0 ] = 1 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ N - 1 - i ] <NEWLINE> tmp += int ( s ) * pow ( 10 , i , 2019 ) <NEWLINE> ans += dic [ tmp % 2019 ] <NEWLINE> dic [ tmp % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
<NL> <NL> n = 0 <NEWLINE> a = [ ] <NEWLINE> <NL> def format_input ( filename = None ) : <NEWLINE> <INDENT> global n <NEWLINE> global a <NEWLINE> if filename == None : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> elif filename == <STRING> : <NEWLINE> <INDENT> from random import randint as rng <NEWLINE> n = rng ( 2 , 2 * 10 ** 5 ) <NEWLINE> a = [ rng ( 1 , i ) for i in range ( 1 , n ) ] <NEWLINE> print ( n ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , a ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_answer ( ) : <NEWLINE> <INDENT> count = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> format_input ( ) <NEWLINE> <NL> get_answer ( ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> num_a = F // ( 100 * A ) <NEWLINE> num_b = F // ( 100 * B ) <NEWLINE> num_c = int ( ( F * E / ( E + 100 ) ) // C ) <NEWLINE> num_d = int ( ( F * E / ( E + 100 ) ) // D ) <NEWLINE> <NL> def check_w ( w_mizu , w_sato , F ) : <NEWLINE> <INDENT> return w_mizu + w_sato <= F <NEWLINE> <NL> <DEDENT> def check_tokeru ( w_mizu , w_sato , E ) : <NEWLINE> <INDENT> return 100 * w_sato / ( w_mizu + w_sato ) <= 100 * E / ( 100 + E ) <NEWLINE> <NL> <DEDENT> def culc_density ( w_mizu , w_sato ) : <NEWLINE> <INDENT> return 100 * w_sato / ( w_mizu + w_sato ) <NEWLINE> <NL> <DEDENT> max = [ 100 * A , 0 , 0 ] <COMMENT> <NEWLINE> for _a , _b , in product ( range ( num_a + 1 ) , range ( num_b + 1 ) ) : <NEWLINE> <INDENT> w_mizu = ( A * _a + B * _b ) * 100 <NEWLINE> if w_mizu == 0 or w_mizu >= F : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for _c , _d in product ( range ( num_c + 1 ) , range ( num_d + 1 ) ) : <NEWLINE> <INDENT> w_sato = ( C * _c + D * _d ) <NEWLINE> if w_sato == 0 or w_sato >= F or ( w_mizu + w_sato ) > F : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> density = culc_density ( w_mizu , w_sato ) <NEWLINE> <NL> if check_w ( w_mizu , w_sato , F ) and check_tokeru ( w_mizu , w_sato , E ) : <NEWLINE> <INDENT> if max [ 2 ] < density : <NEWLINE> <INDENT> max [ 0 ] = w_mizu + w_sato <NEWLINE> max [ 1 ] = w_sato <NEWLINE> max [ 2 ] = density <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if max [ 0 ] : <NEWLINE> <INDENT> print ( max [ 0 ] , max [ 1 ] ) <NEWLINE> <NL> <DEDENT>
N , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> v = [ 0 ] * N <NEWLINE> w = [ 0 ] * N <NEWLINE> dp = [ [ - 1 for i in range ( W + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def rec ( i , j ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> if i == N : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> elif j < w [ i ] : <NEWLINE> <INDENT> res = rec ( i + 1 , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = max ( rec ( i + 1 , j ) , rec ( i + 1 , j - w [ i ] ) + v [ i ] ) <NEWLINE> dp [ i ] [ j ] = res <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> print ( rec ( 0 , W ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> i = 1 <NEWLINE> s0 = s [ 0 ] <NEWLINE> ct = 1 <NEWLINE> while i < len ( s ) - 1 : <NEWLINE> <INDENT> if s0 == s [ i ] : <NEWLINE> <INDENT> s0 = s [ i : i + 2 ] <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s0 = s [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> ct += 1 <NEWLINE> <DEDENT> if i >= len ( s ) : <NEWLINE> <INDENT> print ( ct ) <NEWLINE> <DEDENT> elif s0 == s [ i ] : <NEWLINE> <INDENT> print ( ct ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ct + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> class Rs ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . Rs = [ ] <NEWLINE> <NL> <DEDENT> def append ( self , R ) : <NEWLINE> <INDENT> self . Rs . append ( R ) <NEWLINE> <NL> <DEDENT> def search ( self ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> new_nodes , count = self . _search ( 1 , count ) <NEWLINE> while count < N : <NEWLINE> <INDENT> _new_nodes = set ( ) <NEWLINE> for num in new_nodes : <NEWLINE> <INDENT> _new_node , count = self . _search ( num , count ) <NEWLINE> _new_nodes . update ( _new_node ) <NEWLINE> <DEDENT> new_nodes = _new_nodes <NEWLINE> <NL> <DEDENT> return [ self . Rs [ i ] . fastest_room for i in range ( 1 , len ( self . Rs ) ) ] <NEWLINE> <NL> <DEDENT> def _search ( self , num , count ) : <NEWLINE> <INDENT> r = self . Rs [ num - 1 ] <NEWLINE> cons = r . connection <NEWLINE> new_nodes = set ( ) <NEWLINE> cons -= r . searched_from <NEWLINE> <NL> for con in cons : <NEWLINE> <INDENT> if len ( self . Rs [ con - 1 ] . searched_from ) == 0 : <NEWLINE> <INDENT> self . Rs [ con - 1 ] . fastest_room = num <NEWLINE> self . Rs [ con - 1 ] . searched_from . add ( num ) <NEWLINE> new_nodes . add ( con ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> return new_nodes , count <NEWLINE> <NL> <DEDENT> <DEDENT> class R ( ) : <NEWLINE> <INDENT> def __init__ ( self , num , connection ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . connection = connection <NEWLINE> self . searched_from = set ( [ ] ) <NEWLINE> self . fastest_room = None <NEWLINE> <NL> <DEDENT> <DEDENT> r = Rs ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r . append ( R ( i + 1 , set ( graph [ i + 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> l = r . search ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for room in l : <NEWLINE> <INDENT> print ( room ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans == 0 or ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> can = 1 <COMMENT> <NEWLINE> will = n - 1 <COMMENT> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += A [ will ] <NEWLINE> can -= 1 <NEWLINE> if can == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> can = 2 <COMMENT> <NEWLINE> will -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> tmp += math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> tmp *= 2 <NEWLINE> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp += math . gcd ( a , b ) <NEWLINE> <DEDENT> ans += tmp <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> aint = lambda : int ( input ( ) ) <NEWLINE> ints = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = aint ( ) <NEWLINE> a = ints ( ) <NEWLINE> c = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> d = deque ( c ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( d . popleft ( ) ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> r_max = N // R + 1 <NEWLINE> for r in range ( r_max + 1 ) : <NEWLINE> <INDENT> temp = N - R * r <NEWLINE> for g in range ( temp // G + 1 ) : <NEWLINE> <INDENT> now = temp - G * g <NEWLINE> if now % B == 0 and now // B >= 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 1000005 <NEWLINE> <NL> cnt = [ 0 for i in range ( M ) ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if cnt [ x ] != 0 : <NEWLINE> <INDENT> cnt [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( x , M , x ) : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> t = s [ len ( s ) - 1 ] <NEWLINE> n = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> mod [ int ( t ) % 2019 ] += 1 <NEWLINE> <COMMENT> <NL> t = int ( t ) + n * 10 * int ( s [ i - 1 ] ) <NEWLINE> n = n * 10 % 2019 <NEWLINE> <DEDENT> for i in range ( 0 , 2019 ) : <NEWLINE> <INDENT> ans += mod [ i ] * ( mod [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> ans += mod [ 0 ] <NEWLINE> print ( int ( ans ) ) <NEWLINE>
<NL> <NL> G = [ 120001 , 60001 , 30001 , 15001 , 3001 , 901 , 601 , 301 , 91 , 58 , 31 , 7 , 4 , 1 ] <NEWLINE> <NL> def insertion_sort ( array , g ) : <NEWLINE> <INDENT> for i in range ( g , len ( array ) - 1 ) : <NEWLINE> <INDENT> v = array [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + g ] = array [ j ] <NEWLINE> j = j - g <NEWLINE> array [ - 1 ] += 1 <NEWLINE> <DEDENT> array [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shell_sort ( array , G ) : <NEWLINE> <INDENT> for i in G : <NEWLINE> <INDENT> insertion_sort ( array , i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for i in range ( n ) ] + [ 0 ] <NEWLINE> Gn = [ i for i in G if i <= n ] <NEWLINE> <NL> <NL> shell_sort ( arr , Gn ) <NEWLINE> print ( len ( Gn ) ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in Gn ] ) ) <NEWLINE> print ( arr [ - 1 ] ) <NEWLINE> [ print ( i ) for i in arr [ : - 1 ] ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> num2 = [ ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> <DEDENT> if i % 5 == 0 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num2 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( num2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> rabit = input ( ) . split ( <STRING> ) <NEWLINE> skip = [ ] <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = int ( rabit [ i ] ) <NEWLINE> if n < i + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if int ( rabit [ n - 1 ] ) == i + 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > max ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ab = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> zero = 0 <NEWLINE> for a , b in ab : <NEWLINE> <COMMENT> <NL> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> d [ ( 0 , 1 ) ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> d [ ( 1 , 0 ) ] += 1 <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> g = gcd ( a , b ) <NEWLINE> d [ ( a // g , b // g ) ] += 1 <NEWLINE> <NL> <DEDENT> all = n - zero <NEWLINE> ans = 1 <NEWLINE> for k1 , v in d . items ( ) : <NEWLINE> <INDENT> k2 = ( k1 [ 1 ] , - k1 [ 0 ] ) <NEWLINE> if k2 in d . keys ( ) : <NEWLINE> <INDENT> all -= v <NEWLINE> all -= d [ k2 ] <NEWLINE> ans = ans * ( pow ( 2 , v , mod ) + pow ( 2 , d [ k2 ] , mod ) - 1 ) % mod <NEWLINE> <DEDENT> <DEDENT> ans = ans * pow ( 2 , all , mod ) % mod <NEWLINE> print ( ( ans - 1 + zero ) % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> total = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] == S [ k ] or S [ j ] == S [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( total - cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> prev = [ 0 ] * N <NEWLINE> to_list = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> to_list [ a - 1 ] . append ( b - 1 ) <NEWLINE> to_list [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> marked = { 0 } <NEWLINE> que = [ 0 ] <NEWLINE> <NL> for i in que : <NEWLINE> <INDENT> for j in to_list [ i ] : <NEWLINE> <INDENT> if j in marked : continue <NEWLINE> que . append ( j ) <NEWLINE> marked . add ( j ) <NEWLINE> prev [ j ] = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * prev [ 1 : ] , sep = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for b , c in zip ( al , al [ k : ] ) : <NEWLINE> <INDENT> print ( <STRING> if b < c else <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_all = [ i + 1 for i in range ( M ) ] <NEWLINE> <COMMENT> <NL> Comb = list ( itertools . combinations_with_replacement ( num_all , N ) ) <NEWLINE> <NL> num_l = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> num_l . append ( [ a , b , c , d ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> d_sum_max = 0 <NEWLINE> for A in Comb : <NEWLINE> <INDENT> d_sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for x in num_l : <NEWLINE> <INDENT> a , b , c , d = x [ 0 ] , x [ 1 ] , x [ 2 ] , x [ 3 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( A [ b - 1 ] - A [ a - 1 ] == c ) : <NEWLINE> <INDENT> d_sum += d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> d_sum_max = max ( d_sum_max , d_sum ) <NEWLINE> <NL> <DEDENT> print ( d_sum_max ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> money = [ float ( <STRING> ) ] <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> temp_money = 0 <NEWLINE> temp_skill = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> temp_money += c [ j ] [ 0 ] <NEWLINE> temp_skill = [ a + b for a , b in zip ( temp_skill , c [ j ] [ 1 : m + 1 ] ) ] <NEWLINE> <DEDENT> if all ( [ i >= x for i in temp_skill ] ) == True : <NEWLINE> <INDENT> money . append ( temp_money ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , min ( money ) ) <NEWLINE> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l . append ( [ ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for a , b in ab : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> color = [ None ] * n <NEWLINE> <NL> sys . setrecursionlimit ( 3 * 10 ** 5 ) <NEWLINE> <NL> <NL> def dfs ( i , c ) : <NEWLINE> <INDENT> if color [ i ] is not None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> color [ i ] = c <NEWLINE> <NL> for f in l [ i ] : <NEWLINE> <INDENT> dfs ( f , c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] is None : <NEWLINE> <INDENT> dfs ( i , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( [ v for k , v in collections . Counter ( color ) . items ( ) ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> pc = X . count ( <STRING> ) <NEWLINE> <NL> if pc == 1 : <NEWLINE> <INDENT> if X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i , s in enumerate ( X ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 2 ] * ( N - 1 ) + [ 0 ] <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> m01 = 0 <NEWLINE> m10 = 0 <NEWLINE> b01 = 1 <NEWLINE> b10 = 1 <NEWLINE> for i , s in enumerate ( X [ : : - 1 ] ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> m01 += b01 <NEWLINE> m01 %= pc + 1 <NEWLINE> m10 += b10 <NEWLINE> m10 %= pc - 1 <NEWLINE> <DEDENT> b01 *= 2 <NEWLINE> b01 %= pc + 1 <NEWLINE> b10 *= 2 <NEWLINE> b10 %= pc - 1 <NEWLINE> <NL> <NL> <DEDENT> def pop_count ( T ) : <NEWLINE> <INDENT> T = ( T & 0x55555555 ) + ( ( T >> 1 ) & 0x55555555 ) <NEWLINE> T = ( T & 0x33333333 ) + ( ( T >> 2 ) & 0x33333333 ) <NEWLINE> T = ( T & 0x0F0F0F0F ) + ( ( T >> 4 ) & 0x0F0F0F0F ) <NEWLINE> T = ( T & 0x00FF00FF ) + ( ( T >> 8 ) & 0x00FF00FF ) <NEWLINE> T = ( T & 0x0000FFFF ) + ( ( T >> 16 ) & 0x0000FFFF ) <NEWLINE> return T <NEWLINE> <NL> <NL> <DEDENT> memo = [ 0 ] * ( N + 10 ) <NEWLINE> for i in range ( 1 , N + 10 ) : <NEWLINE> <INDENT> p = pop_count ( i ) <NEWLINE> memo [ i ] = memo [ i % p ] + 1 <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> b01 = 1 <NEWLINE> b10 = 1 <NEWLINE> for i , s in enumerate ( X [ : : - 1 ] ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> m = m01 <NEWLINE> m += b01 <NEWLINE> m %= pc + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = m10 <NEWLINE> m -= b10 <NEWLINE> m %= pc - 1 <NEWLINE> <DEDENT> ans [ i ] = memo [ m ] + 1 <NEWLINE> b01 *= 2 <NEWLINE> b01 %= pc + 1 <NEWLINE> b10 *= 2 <NEWLINE> b10 %= pc - 1 <NEWLINE> <NL> <DEDENT> print ( * ans [ : : - 1 ] , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> number = range ( 1 , N + 1 ) <NEWLINE> numhei = [ 0 ] * N <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> numhei [ n ] = number [ n ] + A [ n ] <NEWLINE> <NL> <DEDENT> c = Counter ( numhei ) <NEWLINE> count = 0 <NEWLINE> for n in number : <NEWLINE> <INDENT> count += c [ n - A [ n - 1 ] ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> c = sorted ( b ) [ - 2 ] <NEWLINE> d = max ( b ) <NEWLINE> if b . count ( d ) >= 2 : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in b : <NEWLINE> <INDENT> if i == d : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AS = [ 0 ] <NEWLINE> BS = [ 0 ] <NEWLINE> r = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i + AS [ - 1 ] <= k : <NEWLINE> <INDENT> AS . append ( i + AS [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in B : <NEWLINE> <INDENT> if i + BS [ - 1 ] <= k : <NEWLINE> <INDENT> BS . append ( i + BS [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> j = len ( BS ) - 1 <NEWLINE> for i in range ( len ( AS ) ) : <NEWLINE> <INDENT> while AS [ i ] + BS [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> r = max ( r , i + j ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> s1 = list ( S ) <NEWLINE> t1 = list ( T ) <NEWLINE> a = len ( s1 ) ; b = len ( t1 ) <NEWLINE> z = [ ] <NEWLINE> for i in range ( a - b + 1 ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> y = 0 <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> x . append ( s1 [ i + j ] ) <NEWLINE> <DEDENT> for k in range ( b ) : <NEWLINE> <INDENT> if t1 [ k ] == x [ k ] : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> <DEDENT> z . append ( y ) <NEWLINE> <DEDENT> print ( b - max ( z ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n >= 3 and m >= 3 : <NEWLINE> <INDENT> a = n * m <NEWLINE> b = n * 2 + m * 2 - 4 <NEWLINE> ans = a - b <NEWLINE> <DEDENT> elif n == 1 and m == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif n == 1 or m == 1 : <NEWLINE> <INDENT> a = n * m <NEWLINE> b = 2 <NEWLINE> ans = a - b <NEWLINE> <DEDENT> elif n == 2 or m == 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <NL> def solve ( N , M , X , C , A ) : <NEWLINE> <INDENT> lis = [ i for i in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> for k , _ in enumerate ( lis , 1 ) : <NEWLINE> <INDENT> for c in itertools . combinations ( lis , r = k ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> dic = { key : 0 for key in range ( M ) } <NEWLINE> for i in set ( c ) : <NEWLINE> <INDENT> tmp += C [ i ] <NEWLINE> for n , a in enumerate ( A [ i ] ) : <NEWLINE> <INDENT> dic [ n ] += a <NEWLINE> <DEDENT> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> if ( dic [ m ] < X ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return min ( ans ) if ( ans != [ ] ) else - 1 <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( tmp . pop ( 0 ) ) <NEWLINE> A . append ( tmp ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( solve ( N , M , X , C , A ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = g = b = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : r += 1 <NEWLINE> elif i == <STRING> : g += 1 <NEWLINE> else : b += 1 <NEWLINE> <DEDENT> ans = r * g * b <NEWLINE> for i in range ( 1 , n // 2 + 2 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j + i + i >= n : break <NEWLINE> if not ( s [ j ] == s [ j + i ] or s [ j + i ] == s [ j + i + i ] or s [ j ] == s [ j + i + i ] ) : ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) . rstrip ( ) <NEWLINE> <NL> lst = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> lst . append ( lst [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( lst [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lst [ r - 1 ] - lst [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> DP = [ 0 for i in range ( n + 2 ) ] <NEWLINE> DP [ n + 1 ] = 0 <NEWLINE> <NL> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> DP [ i ] = ( DP [ i + 1 ] + int ( s [ i ] ) * ( pow ( 10 , n - i - 1 , mod ) ) ) % mod <NEWLINE> <DEDENT> DP . pop ( - 1 ) <NEWLINE> <NL> arr = defaultdict ( int ) <NEWLINE> for dp in DP : <NEWLINE> <INDENT> arr [ dp ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in arr . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> LCM = reduce ( lcm , A ) % mod <NEWLINE> <NL> print ( sum ( [ LCM * pow ( A [ i ] , - 1 , mod ) % mod for i in range ( N ) ] ) % mod ) <NEWLINE>
import sys <NEWLINE> count = 0 <NEWLINE> <NL> def merge_sort ( arr ) : <NEWLINE> <INDENT> merge_sort_ ( arr , 0 , len ( arr ) ) <NEWLINE> <NL> <DEDENT> def merge_sort_ ( arr , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( left + ( right - left ) / 2 ) <NEWLINE> merge_sort_ ( arr , left , mid ) <NEWLINE> merge_sort_ ( arr , mid , right ) <NEWLINE> merge ( arr , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( arr , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> <NL> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> L = arr [ left : left + n1 ] <NEWLINE> R = arr [ mid : mid + n2 ] <NEWLINE> L . append ( sys . maxsize ) <NEWLINE> R . append ( sys . maxsize ) <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> arr [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( arr ) <NEWLINE> print ( <STRING> . join ( map ( str , arr ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( count ) <NEWLINE>
def solve ( X , Y ) : <NEWLINE> <INDENT> from numpy . linalg import solve <NEWLINE> left = [ [ 1 , 1 ] , [ 2 , 4 ] ] <NEWLINE> right = [ X , Y ] <NEWLINE> res = solve ( left , right ) <NEWLINE> x = res [ 0 ] <NEWLINE> y = res [ 1 ] <NEWLINE> <NL> if x == float ( int ( x ) ) and y == float ( int ( y ) ) and x >= 0 and y >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> X , Y = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> solve ( X , Y ) <NEWLINE>
<COMMENT> <NL> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ 0 ] * 10 ** 5 <NEWLINE> A [ 0 ] = X <NEWLINE> D = dict ( ) <NEWLINE> <COMMENT> <NL> s = N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i - 1 ] ** 2 % M <NEWLINE> if a in D : <NEWLINE> <INDENT> s = A . index ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> A [ i ] = a <NEWLINE> D [ a ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if s == N : <NEWLINE> <INDENT> ans = sum ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = A [ : i ] <NEWLINE> Z = [ 0 ] * ( len ( A ) + 1 ) <NEWLINE> for i in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> Z [ i ] = Z [ i - 1 ] + A [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> l = len ( A ) - s <NEWLINE> <COMMENT> <NL> ans += Z [ s ] <NEWLINE> <COMMENT> <NL> S = Z [ len ( A ) ] - Z [ s ] <NEWLINE> T = ( N - s ) // l <NEWLINE> ans += T * S <NEWLINE> K = N - s - l * T <NEWLINE> <COMMENT> <NL> ans += Z [ s + K ] - Z [ s ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list ( <STRING> ) <NEWLINE> if str ( i ) . count ( <STRING> ) != 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def Tarjan ( current , low , dfn , scc_stack , in_scc_stack ) : <NEWLINE> <INDENT> global timer <NEWLINE> dfn [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> scc_stack . append ( current ) <NEWLINE> in_scc_stack [ current ] = True <NEWLINE> <NL> current_scc_set = set ( ) <NEWLINE> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if isinf ( low [ adj ] ) : <NEWLINE> <INDENT> Tarjan ( adj , low , dfn , scc_stack , in_scc_stack ) <NEWLINE> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <NL> <DEDENT> elif in_scc_stack [ adj ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , dfn [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scc_candidate = - 1 <NEWLINE> if dfn [ current ] == low [ current ] : <NEWLINE> <INDENT> while scc_candidate != current : <NEWLINE> <INDENT> scc_candidate = scc_stack . pop ( ) <NEWLINE> in_scc_stack [ scc_candidate ] = False <NEWLINE> current_scc_set . add ( scc_candidate ) <NEWLINE> <NL> <DEDENT> init_scc_sets_list . append ( current_scc_set ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def scc_cluster ( ) : <NEWLINE> <INDENT> dfn = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> scc_stack = list ( ) <NEWLINE> in_scc_stack = [ False ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if isinf ( low [ v ] ) : <NEWLINE> <INDENT> Tarjan ( v , low , dfn , scc_stack , in_scc_stack ) <NEWLINE> <NL> <DEDENT> <DEDENT> return init_scc_sets_list <NEWLINE> <NL> <NL> <DEDENT> def solve ( _scc_sets_list ) : <NEWLINE> <INDENT> for question in q_list : <NEWLINE> <INDENT> flag = False <NEWLINE> ele1 , ele2 = map ( int , question ) <NEWLINE> for each in _scc_sets_list : <NEWLINE> <INDENT> if ( ele1 in each ) and ( ele2 in each ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : edges + 1 ] ) <NEWLINE> q_num = int ( _input [ edges + 1 ] ) <NEWLINE> q_list = map ( lambda x : x . split ( ) , _input [ edges + 2 : ] ) <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> timer = 0 <NEWLINE> init_scc_sets_list = [ ] <NEWLINE> scc_sets_list = scc_cluster ( ) <NEWLINE> <NL> solve ( scc_sets_list ) <NEWLINE> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> c = 1 <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> answer += ( M * c * pow ( M - 1 , N - i - 1 , mod ) ) % mod <NEWLINE> answer %= mod <NEWLINE> c = ( c * ( N - i - 1 ) * pow ( i + 1 , mod - 2 , mod ) ) % mod <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> <NL> if 0 not in a : <NEWLINE> <INDENT> for x in range ( n ) : <NEWLINE> <INDENT> ans *= a [ x ] <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Point ( ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> <DEDENT> class Segment ( ) : <NEWLINE> <INDENT> def __init__ ( self , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> self . p1 = Point ( x1 , y1 ) <NEWLINE> self . p2 = Point ( x2 , y2 ) <NEWLINE> self . slope = None <NEWLINE> if self . p1 . x == self . p2 . x : <NEWLINE> <INDENT> self . slope = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . slope = ( self . p2 . y - self . p1 . y ) / ( self . p2 . x - self . p1 . x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def is_intersect ( self , seg ) : <NEWLINE> <INDENT> a = ( seg . p1 . x - seg . p2 . x ) * ( self . p1 . y - seg . p1 . y ) + ( seg . p1 . y - seg . p2 . y ) * ( seg . p1 . x - self . p1 . x ) <NEWLINE> b = ( seg . p1 . x - seg . p2 . x ) * ( self . p2 . y - seg . p1 . y ) + ( seg . p1 . y - seg . p2 . y ) * ( seg . p1 . x - self . p2 . x ) <NEWLINE> c = ( self . p1 . x - self . p2 . x ) * ( seg . p1 . y - self . p1 . y ) + ( self . p1 . y - self . p2 . y ) * ( self . p1 . x - seg . p1 . x ) <NEWLINE> d = ( self . p1 . x - self . p2 . x ) * ( seg . p2 . y - self . p1 . y ) + ( self . p1 . y - self . p2 . y ) * ( self . p1 . x - seg . p2 . x ) <NEWLINE> e = ( self . p1 . x - seg . p1 . x ) * ( self . p2 . x - seg . p2 . x ) <NEWLINE> f = ( self . p1 . x - seg . p2 . x ) * ( self . p2 . x - seg . p1 . x ) <NEWLINE> g = ( self . p1 . y - seg . p1 . y ) * ( self . p2 . y - seg . p2 . y ) <NEWLINE> h = ( self . p1 . y - seg . p2 . y ) * ( self . p2 . y - seg . p1 . y ) <NEWLINE> return a * b <= 0 and c * d <= 0 and ( e <= 0 or f <= 0 ) and ( g <= 0 or h <= 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> line1 , line2 = Segment ( x0 , y0 , x1 , y1 ) , Segment ( x2 , y2 , x3 , y3 ) <NEWLINE> if line1 . is_intersect ( line2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x , y = [ 0 ] * n , [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> from collections import defaultdict <NEWLINE> xy = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> xy [ ( x [ i ] - x [ j ] , y [ i ] - y [ j ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> if xy == { } : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> p , q = max ( xy , key = lambda x : xy [ x ] ) <NEWLINE> ans = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> if x [ i ] - x [ j ] == p and y [ i ] - y [ j ] == q : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
maxv = - 2 * 10 ** 9 <NEWLINE> minv = 2 * 10 ** 9 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> maxv = max ( x - minv , maxv ) <NEWLINE> minv = min ( x , minv ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> alist = input ( ) . split ( <STRING> ) <NEWLINE> <NL> aint = [ ] <NEWLINE> <NL> sumlist = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> aint . append ( int ( alist [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sumlist . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in aint : <NEWLINE> <INDENT> sumlist [ i - 1 ] = sumlist [ i - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in sumlist : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return set ( a ) <NEWLINE> <NL> <DEDENT> prime_list = prime_factorize ( N ) <NEWLINE> <NL> if prime_list : <NEWLINE> <INDENT> for prime_num in prime_list : <NEWLINE> <INDENT> if N % prime_num == 0 : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> if N < prime_num ** j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N % prime_num ** j == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> N //= prime_num ** j <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] *= - 1 <NEWLINE> <DEDENT> heapq . heapify ( A ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x = heapq . heappop ( A ) <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> x //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x // 2 + 1 <NEWLINE> <DEDENT> heapq . heappush ( A , x ) <NEWLINE> <NL> <DEDENT> ans = - 1 * sum ( A ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> flag = True <NEWLINE> for x in A : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for x in A : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ans > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> z = 10 ** 9 + 7 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x *= n <NEWLINE> x %= z <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def prime_factorization ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 2 <NEWLINE> ans = [ ] <NEWLINE> k = int ( n ** 0.5 ) + 1 <NEWLINE> for j in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> if n == 1 : break <NEWLINE> if n % j == 0 : <NEWLINE> <INDENT> n //= j <NEWLINE> ans . append ( j ) <NEWLINE> while n % j == 0 : <NEWLINE> <INDENT> n //= j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> if n != 1 : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ 1 , n ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> A = prime_factorization ( a ) <NEWLINE> B = prime_factorization ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( len ( set ( A ) & set ( B ) ) ) <NEWLINE> <NL>
from sys import stdin , stdout <NEWLINE> import numba as nb <NEWLINE> <NL> @ nb . njit ( ) <NEWLINE> def solve ( n , w , weights , values ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( w + 1 ) ] for k in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if weights [ i ] <= j : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , <NEWLINE> <INDENT> dp [ i - 1 ] [ j - weights [ i ] ] + values [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ n ] [ w ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values = [ ] <NEWLINE> weights = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> v , a = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values . append ( a ) <NEWLINE> weights . append ( v ) <NEWLINE> <NL> <DEDENT> values = [ 0 ] + values <NEWLINE> weights = [ 0 ] + weights <NEWLINE> print ( solve ( n , w , weights , values ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
lines = input ( ) <NEWLINE> stack_1 = [ ] <NEWLINE> stack_2 = [ ] <NEWLINE> <NL> area = 0 <NEWLINE> for i , line in enumerate ( lines ) : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> stack_1 . append ( i ) <NEWLINE> <DEDENT> elif line == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif line == <STRING> : <NEWLINE> <INDENT> if stack_1 == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> last_index = stack_1 . pop ( ) <NEWLINE> this_area = i - last_index <NEWLINE> area += this_area <NEWLINE> <NL> if stack_2 == [ ] : <NEWLINE> <INDENT> stack_2 . append ( ( last_index , this_area ) ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> block_area = this_area <NEWLINE> while True : <NEWLINE> <INDENT> if stack_2 == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> stack_2_index , stack_2_area = stack_2 . pop ( ) <NEWLINE> if stack_2_index < last_index : <NEWLINE> <INDENT> stack_2 . append ( ( stack_2_index , stack_2_area ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> block_area += stack_2_area <NEWLINE> <DEDENT> <DEDENT> stack_2 . append ( ( last_index , block_area ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( area ) <NEWLINE> kazu = len ( stack_2 ) <NEWLINE> kaku_menseki = [ stack_2 [ i ] [ 1 ] for i in range ( len ( stack_2 ) ) ] <NEWLINE> kaku_menseki_out = <STRING> . join ( map ( str , kaku_menseki ) ) <NEWLINE> if kazu > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def actual ( K , S ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - ( x + y ) <NEWLINE> <NL> cond1 = ( 0 <= x <= K ) and ( 0 <= y <= K ) and ( 0 <= z <= K ) <NEWLINE> cond2 = ( x + y + z ) == S <NEWLINE> <NL> if cond1 and cond2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( actual ( K , S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i + j * 2 < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> t -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> base = [ <STRING> * ( w + 4 ) ] <NEWLINE> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for n in range ( h ) : <NEWLINE> <INDENT> base . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> ans = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for j in range ( w + 4 ) : <NEWLINE> <INDENT> for i in range ( h + 4 ) : <NEWLINE> <INDENT> if base [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ch += 1 ; cw += 1 <NEWLINE> dh += 1 ; dw += 1 <NEWLINE> ans [ ch ] [ cw ] = 0 <NEWLINE> move = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> move2 = [ <NEWLINE> <INDENT> [ - 2 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 2 , 2 ] , [ - 1 , - 2 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 1 , 2 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , - 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] <NEWLINE> ] <NEWLINE> <DEDENT> q = deque ( [ [ ch , cw ] ] ) <NEWLINE> one_time = deque ( [ ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> x , y = q . popleft ( ) <NEWLINE> one_time . append ( [ x , y ] ) <NEWLINE> for i , j in move : <NEWLINE> <INDENT> v1 , v2 = x + i , y + j <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <NEWLINE> <INDENT> ans [ v1 ] [ v2 ] = ans [ x ] [ y ] <NEWLINE> q . append ( [ v1 , v2 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> while len ( one_time ) > 0 : <NEWLINE> <INDENT> x2 , y2 = one_time . popleft ( ) <NEWLINE> for i , j in move2 : <NEWLINE> <INDENT> v1 , v2 = x2 + i , y2 + j <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <NEWLINE> <INDENT> ans [ v1 ] [ v2 ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> q . append ( [ v1 , v2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for small in range ( n - 2 ) : <NEWLINE> <INDENT> for mid in range ( small + 1 , n - 1 ) : <NEWLINE> <INDENT> div = bisect_left ( arr , arr [ small ] + arr [ mid ] , 0 , n ) <NEWLINE> if div > mid + 1 : <NEWLINE> <INDENT> ans += div - mid - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
d = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> lista = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for k in lista : <NEWLINE> <INDENT> k %= d <NEWLINE> <NL> <DEDENT> totalJ = sum ( lista ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> totalJ -= lista [ i ] <NEWLINE> total += totalJ * lista [ i ] <NEWLINE> <DEDENT> total %= d <NEWLINE> print ( total ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> start = X % M <NEWLINE> rset = set ( ) <NEWLINE> rireki = list ( ) <NEWLINE> rset . add ( start ) <NEWLINE> rireki . append ( start ) <NEWLINE> ss = 0 <NEWLINE> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> start = ( start ** 2 ) % M <NEWLINE> if start in rset : <NEWLINE> <INDENT> ss = rireki . index ( start ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rireki . append ( start ) <NEWLINE> rset . add ( start ) <NEWLINE> <DEDENT> <DEDENT> nn = len ( rireki ) <NEWLINE> rep = ( N - ss ) // ( nn - ss ) <NEWLINE> nokori = N - ss - rep * ( nn - ss ) <NEWLINE> loop = rireki [ ss : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if 0 in rireki : <NEWLINE> <INDENT> goukei = sum ( rireki ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> goukei = rep * sum ( loop ) + sum ( rireki [ : ss ] ) + sum ( loop [ : nokori ] ) <NEWLINE> <DEDENT> print ( goukei ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> if A [ M - 1 ] >= sum ( A ) / ( 4 * M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = list ( collections . Counter ( s ) . values ( ) ) <NEWLINE> if len ( l ) == 3 : <NEWLINE> <INDENT> ans = l [ 0 ] * l [ 1 ] * l [ 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if n <= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( int ( n / 2 ) - 1 ) : <NEWLINE> <INDENT> count += int ( ( n - 1 ) / ( i + 1 ) ) <NEWLINE> <DEDENT> count += int ( n / 2 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( n / 2 ) ) : <NEWLINE> <INDENT> count += int ( ( n - 1 ) / ( i + 1 ) ) <NEWLINE> <DEDENT> count += int ( n / 2 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in alist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in alist : <NEWLINE> <INDENT> if a <= 10 ** 18 : <NEWLINE> <INDENT> a = a * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> s = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += A [ i ] * s <NEWLINE> <NL> <DEDENT> print ( ans % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
n = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> ans = ans % 9 <NEWLINE> <NL> <DEDENT> print ( <STRING> if ans == 0 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X *= A [ i ] <NEWLINE> if X > int ( 1e18 ) : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> j = 0 <NEWLINE> ls1 = [ ] <NEWLINE> ls2 = [ ] <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> ls1 . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( len ( ls1 ) ) : <NEWLINE> <INDENT> for j in ls1 [ i ] : <NEWLINE> <INDENT> ls2 . append ( j ) <NEWLINE> x = set ( ls2 ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( x ) ) <NEWLINE>
class Process ( object ) : <NEWLINE> <INDENT> def __init__ ( self , name , s ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . s = s <NEWLINE> <NL> <DEDENT> def exec ( self , q ) : <NEWLINE> <INDENT> if self . s <= q : <NEWLINE> <INDENT> time = self . s <NEWLINE> self . s = 0 <NEWLINE> return time <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time = q <NEWLINE> self . s = self . s - q <NEWLINE> return time <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def execute ( processes , q ) : <NEWLINE> <INDENT> time = 0 <NEWLINE> completed = [ ] <NEWLINE> while processes : <NEWLINE> <INDENT> p = processes . pop ( ) <NEWLINE> time += p . exec ( q ) <NEWLINE> if p . s == 0 : <NEWLINE> <INDENT> completed . append ( ( p , time ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> processes . insert ( 0 , p ) <NEWLINE> <DEDENT> <DEDENT> return completed <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> processes = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> processes . append ( Process ( name , int ( time ) ) ) <NEWLINE> <DEDENT> processes . reverse ( ) <NEWLINE> completed = execute ( processes , q ) <NEWLINE> for c in completed : <NEWLINE> <INDENT> print ( c [ 0 ] . name , c [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def insert ( root , insert_node ) : <NEWLINE> <INDENT> focus_node = root <NEWLINE> parent = None <NEWLINE> while not focus_node == None : <NEWLINE> <INDENT> parent = focus_node <NEWLINE> if focus_node [ <STRING> ] > insert_node [ <STRING> ] : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if parent [ <STRING> ] > insert_node [ <STRING> ] : <NEWLINE> <INDENT> parent [ <STRING> ] = insert_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ <STRING> ] = insert_node <NEWLINE> <NL> <DEDENT> <DEDENT> def get_preorder ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> r = [ ] <NEWLINE> r . append ( str ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_preorder ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_preorder ( node [ <STRING> ] ) ) <NEWLINE> <NL> return r <NEWLINE> <NL> <DEDENT> def get_inorder ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> r = [ ] <NEWLINE> r . extend ( get_inorder ( node [ <STRING> ] ) ) <NEWLINE> r . append ( str ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_inorder ( node [ <STRING> ] ) ) <NEWLINE> <NL> return r <NEWLINE> <DEDENT> def print_tree ( root ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( get_inorder ( root ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( get_preorder ( root ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> n_line = int ( input ( ) ) <NEWLINE> input_list = [ input ( ) for i in range ( n_line ) ] <NEWLINE> root = { <STRING> : None , <STRING> : None , <STRING> : int ( input_list [ 0 ] . split ( ) [ 1 ] ) } <NEWLINE> <NL> for line in input_list [ 1 : ] : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> print_tree ( root ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = { <STRING> : None , <STRING> : None , <STRING> : int ( line . split ( ) [ 1 ] ) } <NEWLINE> insert ( root , node ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
case = 1 <NEWLINE> while True : <NEWLINE> <INDENT> w_limit = int ( input ( ) ) <NEWLINE> if not w_limit : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> treasures = [ tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> furoshiki = [ 0 ] * ( w_limit + 1 ) <NEWLINE> for v , w in treasures : <NEWLINE> <INDENT> for j in range ( w_limit , w - 1 , - 1 ) : <NEWLINE> <INDENT> furoshiki [ j ] = max ( furoshiki [ j ] , furoshiki [ j - w ] + v ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_v = max_v_w = 0 <NEWLINE> for w in range ( w_limit + 1 ) : <NEWLINE> <INDENT> if furoshiki [ w ] > max_v : <NEWLINE> <INDENT> max_v = furoshiki [ w ] <NEWLINE> max_v_w = w <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( case ) ) <NEWLINE> print ( max_v ) <NEWLINE> print ( max_v_w ) <NEWLINE> case += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> m = e + 1 <NEWLINE> z = 0 <NEWLINE> while z <= e : <NEWLINE> <INDENT> z3 = z ** 3 <NEWLINE> if z3 > e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y = int ( math . sqrt ( e - z3 ) ) <NEWLINE> x = e - y ** 2 - z3 <NEWLINE> m = min ( m , x + y + z ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> mods = [ 0 ] <NEWLINE> num , ten = 0 , 1 <NEWLINE> for n in S [ : : - 1 ] : <NEWLINE> <INDENT> num += int ( n ) * ten <NEWLINE> num %= 2019 <NEWLINE> mods . append ( num ) <NEWLINE> ten *= 10 <NEWLINE> ten %= 2019 <NEWLINE> <NL> <DEDENT> c = Counter ( mods ) <NEWLINE> ans = 0 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_li = [ 0 ] + a_li <NEWLINE> b_li = [ 0 ] + b_li <NEWLINE> <NL> time = 0 <NEWLINE> ans = 0 <NEWLINE> a = 0 <NEWLINE> temp = 0 <NEWLINE> <NL> a_wa = [ 0 ] * ( n + 10 ) <NEWLINE> b_wa = [ 0 ] * ( m + 10 ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> s += a_li [ i ] <NEWLINE> a_wa [ i ] = s <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> s += b_li [ i ] <NEWLINE> b_wa [ i ] = s <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( max ( min ( temp - i , m ) , 0 ) , m + 1 ) : <NEWLINE> <INDENT> time = a_wa [ i ] + b_wa [ j ] <NEWLINE> if time <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> temp = ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10001 <NEWLINE> for x in range ( 1 , int ( math . sqrt ( n + 1 ) ) ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( n + 1 ) ) ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( n + 1 ) ) ) : <NEWLINE> <INDENT> t = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if t <= n : <NEWLINE> <INDENT> ans [ t ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> keiro = [ 1 ] <NEWLINE> keiro_set = { 1 } <NEWLINE> flag = True <NEWLINE> now = 1 <NEWLINE> start = 0 <NEWLINE> loopN = 0 <NEWLINE> loop_list = [ ] <NEWLINE> not_loop = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> if now in keiro_set : <NEWLINE> <INDENT> start = keiro . index ( now ) <NEWLINE> loop_list = keiro [ start : ] <NEWLINE> loopN = len ( loop_list ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keiro . append ( now ) <NEWLINE> keiro_set . add ( now ) <NEWLINE> <DEDENT> if i + 2 > K : <NEWLINE> <INDENT> not_loop = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not_loop : <NEWLINE> <INDENT> print ( keiro [ K ] ) <NEWLINE> <DEDENT> elif K - start >= 0 : <NEWLINE> <INDENT> print ( loop_list [ ( K - start ) % loopN ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( keiro [ K ] ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ - int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t = heapq . heappop ( a ) <NEWLINE> t = - t // 2 <NEWLINE> heapq . heappush ( a , - t ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def binbin ( binn ) : <NEWLINE> <INDENT> return bin ( binn ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def popcount ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 + popcount ( n % binbin ( n ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) . strip ( ) <NEWLINE> <NL> x1 = 0 <NEWLINE> xc = binbin ( int ( X , 2 ) ) <NEWLINE> if xc == 1 : <NEWLINE> <INDENT> x2 = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x2 = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> x1 += pow ( 2 , i , xc + 1 ) <NEWLINE> if x2 != - 1 : <NEWLINE> <INDENT> x2 += pow ( 2 , i , xc - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 1 + popcount ( ( x1 + pow ( 2 , N - i - 1 , xc + 1 ) ) % ( xc + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x2 == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 + popcount ( ( x2 - pow ( 2 , N - i - 1 , xc - 1 ) + xc - 1 ) % ( xc - 1 ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A_ , B_ = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A_ - 1 ] >= H [ B_ - 1 ] : <NEWLINE> <INDENT> lst . append ( B_ ) <NEWLINE> <DEDENT> if H [ A_ - 1 ] <= H [ B_ - 1 ] : <NEWLINE> <INDENT> lst . append ( A_ ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( set ( lst ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> nil = - 1 <NEWLINE> <NL> def preParse ( u ) : <NEWLINE> <INDENT> if u == nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> print ( <STRING> . format ( u ) , end = <STRING> ) <NEWLINE> preParse ( tree [ u ] [ <STRING> ] ) <NEWLINE> preParse ( tree [ u ] [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> def inParse ( u ) : <NEWLINE> <INDENT> if u == nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> inParse ( tree [ u ] [ <STRING> ] ) <NEWLINE> print ( <STRING> . format ( u ) , end = <STRING> ) <NEWLINE> inParse ( tree [ u ] [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> def postParse ( u ) : <NEWLINE> <INDENT> if u == nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> postParse ( tree [ u ] [ <STRING> ] ) <NEWLINE> postParse ( tree [ u ] [ <STRING> ] ) <NEWLINE> print ( <STRING> . format ( u ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> tree = collections . defaultdict ( dict ) <NEWLINE> roots = list ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> id_num , left , right = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tree [ id_num ] [ <STRING> ] = left <NEWLINE> tree [ id_num ] [ <STRING> ] = right <NEWLINE> if left != nil : <NEWLINE> <INDENT> tree [ left ] [ <STRING> ] = id_num <NEWLINE> <DEDENT> if right != nil : <NEWLINE> <INDENT> tree [ right ] [ <STRING> ] = id_num <NEWLINE> <NL> <DEDENT> <DEDENT> for key , val in tree . items ( ) : <NEWLINE> <INDENT> if not <STRING> in tree [ key ] : <NEWLINE> <INDENT> roots . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> preParse ( roots [ 0 ] ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> inParse ( roots [ 0 ] ) <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> postParse ( roots [ 0 ] ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sum = 1 <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> A_sum = A_sum * A [ i ] <NEWLINE> <NL> if A_sum > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A_sum ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def binary_search ( ary , target ) : <NEWLINE> <NL> <INDENT> left = 0 <NEWLINE> right = len ( ary ) <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> <NL> if ary [ mid ] == target : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif ary [ mid ] < target : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for target in T : <NEWLINE> <INDENT> if binary_search ( S , target ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> g = N // gcd ( N , M ) * M <NEWLINE> ans = defaultdict ( bool ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i * g // N ] = S [ i ] <NEWLINE> <DEDENT> ok = True <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> idx = i * g // M <NEWLINE> if ans [ idx ] and ans [ idx ] != T [ i ] : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( g ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = 998244353 <NEWLINE> LR = [ 0 ] * K <NEWLINE> <COMMENT> <NL> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> LR [ i ] = [ l , r ] <NEWLINE> <NL> <DEDENT> AS = [ 0 ] * ( N + 2 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = [ 0 ] * ( N + 2 ) <NEWLINE> A [ 1 ] = 1 <NEWLINE> A [ 2 ] = - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> AS [ i ] = ( AS [ i - 1 ] + A [ i ] ) % L <NEWLINE> rest = AS [ i ] <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> if i + l > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> right = min ( N + 1 , i + r + 1 ) <NEWLINE> A [ i + l ] += rest <NEWLINE> A [ right ] += - rest <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A [ 1 : N + 1 ] ) % L ) <NEWLINE> <NL> <NL> <NL> <NL>
a = eval ( input ( ) ) <NEWLINE> print ( a ) <NEWLINE>
from math import floor <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( n , b - 1 ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <NL> <DEDENT> print ( floor ( a * x / b ) - a * floor ( x / b ) ) <NEWLINE>
<COMMENT> <NL> <NL> iim = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( enumerate ( iim ( ) ) ) <NEWLINE> <NL> A . sort ( key = lambda x : ( x [ 1 ] , ( 2 * x [ 0 ] - N ) ** 2 ) , reverse = True ) <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp0 = dp [ : ] <NEWLINE> for i , ( j , ai ) in enumerate ( A ) : <NEWLINE> <INDENT> for k in range ( i + 1 ) : <NEWLINE> <INDENT> dp [ k ] = max ( dp [ k ] , dp0 [ k ] + abs ( N - i + k - 1 - j ) * ai ) <NEWLINE> dp [ k + 1 ] = max ( dp [ k + 1 ] , dp0 [ k ] + abs ( k - j ) * ai ) <NEWLINE> <DEDENT> dp , dp0 = dp0 , dp <NEWLINE> <NL> <DEDENT> print ( max ( dp0 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import random <NEWLINE> from decimal import Decimal <NEWLINE> import itertools <NEWLINE> import re <NEWLINE> from collections import deque , Counter <NEWLINE> from functools import lru_cache <NEWLINE> <NL> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> INF = 10 ** 13 <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> mod = 1000000007 <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> factos = factorization ( n ) <NEWLINE> count = 0 <NEWLINE> for num , facto in factos : <NEWLINE> <INDENT> sum_tmp = 0 <NEWLINE> for i in range ( 1 , facto + 1 ) : <NEWLINE> <INDENT> sum_tmp += i <NEWLINE> if sum_tmp <= facto : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 998244353 <NEWLINE> LR = [ ] <NEWLINE> S = [ ] <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dps = [ 0 ] * ( N + 1 ) <NEWLINE> dps [ 1 ] = 1 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> LR . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for l , r in LR : <NEWLINE> <INDENT> l , r = i - r , i - l <NEWLINE> <COMMENT> <NL> if r < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l = max ( 1 , l ) <NEWLINE> dp [ i ] += dps [ r ] - dps [ l - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> dps [ i ] = dps [ i - 1 ] + dp [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( q ) ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> <DEDENT> import itertools <NEWLINE> l = list ( itertools . combinations_with_replacement ( b , n ) ) <NEWLINE> max = 0 <NEWLINE> <COMMENT> <NL> for ll in l : <NEWLINE> <INDENT> m = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> if ll [ aa [ 1 ] - 1 ] - ll [ aa [ 0 ] - 1 ] == aa [ 2 ] : <NEWLINE> <INDENT> m += aa [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if max < m : <NEWLINE> <INDENT> max = m <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> r_n = math . floor ( math . sqrt ( N ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( 1 , r_n ) : <NEWLINE> <INDENT> for y in range ( 1 , r_n ) : <NEWLINE> <INDENT> for z in range ( 1 , r_n ) : <NEWLINE> <INDENT> n = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if n < 10050 : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
<NL> <NL> <NL> import random as ra <NEWLINE> import copy <NEWLINE> import time <NEWLINE> <NL> start_time = time . time ( ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def cal_point ( t ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> score += s [ d ] [ t [ d ] - 1 ] <NEWLINE> last [ t [ d ] - 1 ] = d + 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> score -= c [ i ] * ( d + 1 - last [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <NL> <DEDENT> t = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> opt1 = s [ i ] . index ( max ( s [ i ] ) ) <NEWLINE> opt2 = last . index ( min ( last ) ) <NEWLINE> if ra . random ( ) < 0.5 : <NEWLINE> <INDENT> t . append ( opt1 + 1 ) <NEWLINE> last [ opt1 ] = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . append ( opt2 + 1 ) <NEWLINE> last [ opt2 ] = i + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> max_score = 0 <NEWLINE> optimal_t = copy . deepcopy ( t ) <NEWLINE> <COMMENT> <NL> while ( time . time ( ) - start_time ) < 1.95 : <NEWLINE> <COMMENT> <NL> <INDENT> d = ra . randint ( 1 , D ) <NEWLINE> q = ra . randint ( 1 , 26 ) <NEWLINE> td = t [ d - 1 ] <NEWLINE> t [ d - 1 ] = q <NEWLINE> now = cal_point ( t ) <NEWLINE> if now > max_score : <NEWLINE> <INDENT> optimal_t = copy . deepcopy ( t ) <NEWLINE> max_score = now <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ d - 1 ] = td <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * optimal_t , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : r += 1 <NEWLINE> if c == <STRING> : g += 1 <NEWLINE> if c == <STRING> : b += 1 <NEWLINE> <NL> <DEDENT> total = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : continue <NEWLINE> <NL> k = 2 * j - i <NEWLINE> if k >= N : continue <NEWLINE> if S [ i ] == S [ k ] or S [ j ] == S [ k ] : continue <NEWLINE> total -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( eval ( <STRING> + input ( ) . replace ( <STRING> , <STRING> ) + <STRING> ) ** 0.5 <= d for _ in range ( n ) ) ) <NEWLINE>
import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( l ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for vl in itertools . combinations ( c , i ) : <NEWLINE> <INDENT> a = [ 0 ] * m <NEWLINE> p = 0 <NEWLINE> for v in vl : <NEWLINE> <INDENT> p += v [ 0 ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ j ] += v [ 1 + j ] <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> if a [ k ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans . append ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( a [ i ] + ans ) % b [ i ] != 0 : <NEWLINE> <INDENT> ans += b [ i ] - ( a [ i ] + ans ) % b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ) ) <NEWLINE> <INDENT> < 1e-10 else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = sorted ( [ int ( input ( ) ) for i in range ( 2 ) ] ) <NEWLINE> print ( <STRING> if a == [ 2 , 3 ] else <STRING> if a == [ 1 , 3 ] else <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> k_arr = range ( 1 , k + 1 ) <NEWLINE> <NL> a_arr = list ( ) <NEWLINE> b_arr = list ( ) <NEWLINE> <NL> for k in k_arr : <NEWLINE> <INDENT> for a in k_arr : <NEWLINE> <INDENT> a_arr . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> for b in k_arr : <NEWLINE> <INDENT> for k in k_arr : <NEWLINE> <INDENT> b_arr . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> gcds = list ( map ( math . gcd , a_arr , b_arr ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for c in k_arr : <NEWLINE> <INDENT> c_arr = [ c ] * k * k <NEWLINE> total += sum ( map ( math . gcd , gcds , c_arr ) ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k <= N - 1 : <NEWLINE> <INDENT> if S [ j ] != S [ i ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xs = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> <NL> for v in a : <NEWLINE> <INDENT> if xs [ v ] == 0 : <NEWLINE> <INDENT> for j in range ( v , len ( xs ) , v ) : <NEWLINE> <INDENT> xs [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> xs [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( list ( filter ( lambda v : xs [ v ] == 1 , a ) ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] *= ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> v , e , r = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> edge_info = [ 0 ] * v ; <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> edge_info [ i ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( e ) : <NEWLINE> <INDENT> e1 , e2 , w = map ( int , input ( ) . split ( ) ) ; <NEWLINE> edge_info [ e1 ] . append ( ( e2 , w ) ) <NEWLINE> <NL> <DEDENT> v_q = deque ( ) ; <NEWLINE> <NL> INF = 9999999999999999999 <NEWLINE> d = [ INF for i in range ( v ) ] <NEWLINE> d [ r ] = 0 <NEWLINE> v_q . append ( ( 0 , r ) ) <NEWLINE> while ( len ( v_q ) != 0 ) : <NEWLINE> <INDENT> cost , u = v_q . popleft ( ) <NEWLINE> if ( cost > d [ u ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( len ( edge_info [ u ] ) ) : <NEWLINE> <INDENT> e2 , w = edge_info [ u ] [ j ] <NEWLINE> alt = cost + w <NEWLINE> if ( d [ e2 ] > alt ) : <NEWLINE> <INDENT> d [ e2 ] = alt <NEWLINE> v_q . append ( ( alt , e2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( v ) : <NEWLINE> <INDENT> if ( d [ i ] != INF ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = x * ( i + 1 ) <NEWLINE> x = x % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> a , L = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a == 0 and L == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a_set = dict ( ) <NEWLINE> a_set [ a ] = 0 <NEWLINE> a = str ( a ) <NEWLINE> a = a + <STRING> * ( L - len ( a ) ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( <STRING> . join ( reversed ( sorted ( a ) ) ) ) - int ( <STRING> . join ( sorted ( a ) ) ) <NEWLINE> if a in a_set : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_set [ a ] = i <NEWLINE> <DEDENT> a = str ( a ) <NEWLINE> a = a + <STRING> * ( L - len ( a ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( a_set [ a ] , a , i - a_set [ a ] ) <NEWLINE> <DEDENT>
import math as mt <NEWLINE> from collections import defaultdict <NEWLINE> <NL> MAXN = 10 ** 6 <NEWLINE> <NL> spf = [ 0 for i in range ( MAXN ) ] <NEWLINE> <NL> def sieve ( ) : <NEWLINE> <INDENT> spf [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAXN ) : <NEWLINE> <INDENT> spf [ i ] = i <NEWLINE> <DEDENT> for i in range ( 4 , MAXN , 2 ) : <NEWLINE> <INDENT> spf [ i ] = 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , mt . ceil ( mt . sqrt ( MAXN ) ) ) : <NEWLINE> <INDENT> if ( spf [ i ] == i ) : <NEWLINE> <INDENT> for j in range ( i * i , MAXN , i ) : <NEWLINE> <INDENT> if ( spf [ j ] == j ) : <NEWLINE> <INDENT> spf [ j ] = i <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getFactorization ( x ) : <NEWLINE> <INDENT> d = defaultdict ( int ) <NEWLINE> while ( x != 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> d [ spf [ x ] ] += 1 <NEWLINE> x = x // spf [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 1 <NEWLINE> for i in d : <NEWLINE> <INDENT> ans *= ( d [ i ] + 1 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> sieve ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += getFactorization ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( S = None ) : <NEWLINE> <INDENT> if not S : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> <DEDENT> r = [ 0 ] * 2019 <NEWLINE> r [ 0 ] = 1 <NEWLINE> tmp = 0 <NEWLINE> base = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> s = int ( s ) * base <NEWLINE> base *= 10 <NEWLINE> base %= 2019 <NEWLINE> tmp += s <NEWLINE> tmp %= 2019 <NEWLINE> r [ tmp ] += 1 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for v in r : <NEWLINE> <INDENT> count += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> return count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import string <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> s = string . ascii_lowercase <NEWLINE> <NL> k = 1 <NEWLINE> lis = [ 0 ] <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> k *= 26 <NEWLINE> lis . append ( k + lis [ - 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> keta = bisect . bisect ( lis , N - 1 ) <NEWLINE> <COMMENT> <NL> <NL> ans = <STRING> <NEWLINE> n = N - lis [ keta - 1 ] - 1 <NEWLINE> for i in range ( keta ) : <NEWLINE> <INDENT> q , m = divmod ( n , 26 ) <NEWLINE> <COMMENT> <NL> n = q <NEWLINE> ans += s [ m ] <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> table_len = 2 * 10 ** 6 + 10 <NEWLINE> <NL> fac = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , table_len ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * i % MOD ) <NEWLINE> <NL> <DEDENT> finv = [ 0 ] * table_len <NEWLINE> finv [ - 1 ] = pow ( fac [ - 1 ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( table_len - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> finv [ i - 1 ] = finv [ i ] * i % MOD <NEWLINE> <NL> <DEDENT> def comb ( a , b ) : <NEWLINE> <INDENT> return fac [ a + b ] * finv [ a ] * finv [ b ] % MOD <NEWLINE> <NL> <NL> <DEDENT> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ( comb ( r1 , c1 ) + comb ( r2 + 1 , c2 + 1 ) - comb ( r1 , c2 + 1 ) - comb ( r2 + 1 , c1 ) ) % MOD <NEWLINE> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> key = [ 0 ] * 2019 <NEWLINE> mod = 1 <NEWLINE> judge = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> judge += ( ( mod % 2019 ) * int ( n [ l - i - 1 ] ) ) % 2019 <NEWLINE> judge %= 2019 <NEWLINE> k = judge % 2019 <NEWLINE> key [ k ] += 1 <NEWLINE> mod *= 10 <NEWLINE> mod %= 2019 <NEWLINE> <NL> <DEDENT> ans = key [ 0 ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> if key [ i ] >= 2 : <NEWLINE> <INDENT> ans += key [ i ] * ( key [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> fn = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if fn > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ fn ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for aj , bj in zip ( a [ i ] , b ) : <NEWLINE> <INDENT> c [ i ] += aj * bj <NEWLINE> <NL> <DEDENT> <DEDENT> for ci in c : <NEWLINE> <INDENT> print ( ci ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = dict ( [ ( i , [ ] ) for i in range ( 1 , N + 1 ) ] ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> G [ i ] . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> l = deque ( [ A [ 1 ] ] ) <NEWLINE> seen = [ False for i in range ( N + 1 ) ] <NEWLINE> seen [ 1 ] = True <NEWLINE> d = [ 0 for i in range ( N + 1 ) ] <NEWLINE> d [ A [ 1 ] ] = 1 <NEWLINE> if A [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> v = l . popleft ( ) <NEWLINE> if seen [ v ] == False : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> l . append ( A [ v ] ) <NEWLINE> if seen [ A [ v ] ] == True : <NEWLINE> <INDENT> a = d [ A [ v ] ] <NEWLINE> b = d [ v ] + 1 - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ v ] ] = d [ v ] + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> start = v <NEWLINE> break <NEWLINE> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> print ( v ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> kaisu = ( K - a ) % b <NEWLINE> p = start <NEWLINE> for i in range ( kaisu ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> val = [ 0 ] * 100000000 <NEWLINE> val [ 0 ] = X <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> limit = 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> limit = 5 <NEWLINE> <DEDENT> i = 0 <NEWLINE> if abs ( X ) > K * D : <NEWLINE> <INDENT> if X > 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X + K * D ) ) <NEWLINE> <DEDENT> <DEDENT> elif abs ( X ) == K * D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == 0 : <NEWLINE> <INDENT> if limit == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> syo = abs ( X ) // D <NEWLINE> <COMMENT> <NL> if syo > 3 : <NEWLINE> <INDENT> if X > 0 : <NEWLINE> <INDENT> val [ 0 ] = X - ( syo - 2 ) * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val [ 0 ] = X + ( syo - 2 ) * D <NEWLINE> <COMMENT> <NL> <DEDENT> K = K - ( syo - 2 ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> limit = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> limit = 3 <NEWLINE> <DEDENT> <DEDENT> for j in val : <NEWLINE> <COMMENT> <NL> <INDENT> if abs ( val [ i ] - D ) < abs ( val [ i ] + D ) : <NEWLINE> <INDENT> val [ i + 1 ] = val [ i ] - D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val [ i + 1 ] = val [ i ] + D <NEWLINE> <COMMENT> <NL> <DEDENT> if ( abs ( val [ i + 1 ] ) == abs ( val [ i - 1 ] ) ) and i > limit : <NEWLINE> <COMMENT> <NL> <INDENT> print ( abs ( val [ i + 1 ] ) ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> if i == K : <NEWLINE> <COMMENT> <NL> <INDENT> print ( abs ( val [ i ] ) ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> a = k <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> <DEDENT> if a < k and a + b >= k : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> if a + b < k : <NEWLINE> <INDENT> c = k - a - b <NEWLINE> <NL> <DEDENT> sum_a = 1 * a <NEWLINE> sum_c = - 1 * c <NEWLINE> <NL> print ( sum_a + sum_c ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( N ) ] <NEWLINE> sortA = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> sortB = sorted ( AB , key = lambda x : x [ 1 ] ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> k1 = int ( N / 2 - 1 ) <NEWLINE> k2 = int ( N / 2 ) <NEWLINE> minM = sortA [ k1 ] [ 0 ] + sortA [ k2 ] [ 0 ] <NEWLINE> maxM = sortB [ k1 ] [ 1 ] + sortB [ k2 ] [ 1 ] <NEWLINE> print ( maxM - minM + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = int ( ( N + 1 ) / 2 ) - 1 <NEWLINE> A = sortA [ k ] [ 0 ] <NEWLINE> B = sortB [ k ] [ 1 ] <NEWLINE> print ( B - A + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def calculate ( n , s ) : <NEWLINE> <INDENT> arr = list ( s ) <NEWLINE> <NL> rNum = arr . count ( <STRING> ) <NEWLINE> gNum = arr . count ( <STRING> ) <NEWLINE> bNum = arr . count ( <STRING> ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for step in range ( 1 , math . ceil ( n / 2 ) + 1 ) : <NEWLINE> <INDENT> for i in range ( n - 2 * step ) : <NEWLINE> <INDENT> s = <STRING> . join ( [ arr [ i ] , arr [ i + step ] , arr [ i + step * 2 ] ] ) <NEWLINE> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( rNum * gNum * bNum - sum ) <NEWLINE> <NL> <NL> <NL> <DEDENT> calculate ( N , S ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> tmp = <STRING> <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if 0 < h < H - 1 and 0 < w < W - 1 : <NEWLINE> <INDENT> tmp += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> fact = [ 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> factinv = [ 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> fact [ i + 1 ] = fact [ i ] * ( i + 1 ) % MOD <COMMENT> <NEWLINE> factinv [ i + 1 ] = pow ( fact [ i + 1 ] , MOD - 2 , MOD ) <COMMENT> <NEWLINE> <NL> <DEDENT> def nCk ( n , k ) : <COMMENT> <NEWLINE> <INDENT> return fact [ n ] * factinv [ n - k ] * factinv [ k ] % MOD <NEWLINE> <NL> <DEDENT> def solve ( k ) : <NEWLINE> <INDENT> r = M * pow ( M - 1 , N - 1 - k , MOD ) * nCk ( N - 1 , k ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += solve ( k ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( W + 1 ) <NEWLINE> def dp_opt ( n , w ) : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = dp [ j - w ] + v <NEWLINE> if tmp > dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT> dp_opt ( N , W ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> k = 0 <NEWLINE> buf = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> buf += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - buf ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_num = max ( p ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( max_num + 2 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> lst . append ( i ) <NEWLINE> <DEDENT> <DEDENT> tmp = float ( <STRING> ) <NEWLINE> for j in lst : <NEWLINE> <INDENT> if tmp > abs ( X - j ) : <NEWLINE> <INDENT> tmp = abs ( X - j ) <NEWLINE> ans = j <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in d . keys ( ) : <NEWLINE> <INDENT> d [ a [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = sum ( [ k * v for k , v in d . items ( ) ] ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b in d . keys ( ) : <NEWLINE> <INDENT> s += ( c - b ) * d [ b ] <NEWLINE> if c in d . keys ( ) : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s += i * ( ( n // i ) * ( n // i + 1 ) // 2 ) <NEWLINE> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> x = 1 <NEWLINE> tot = 0 <COMMENT> <NEWLINE> cnt = [ 0 for i in range ( 2019 ) ] <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt [ tot ] += 1 <NEWLINE> tot += int ( s [ i ] ) * x <NEWLINE> <COMMENT> <NL> tot %= 2019 <NEWLINE> <COMMENT> <NL> ans += cnt [ tot ] <NEWLINE> <COMMENT> <NL> x = x * 10 % 2019 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import bisect <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> minA = A [ 0 ] <NEWLINE> Query = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if c > minA : <NEWLINE> <INDENT> Query . append ( [ b , c ] ) <NEWLINE> <DEDENT> <DEDENT> Query = sorted ( Query , key = lambda x : ( x [ 1 ] , x [ 0 ] ) , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> index = 0 <NEWLINE> for b , c in Query : <NEWLINE> <INDENT> if index >= n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> cnt = 0 <NEWLINE> Flag = True <NEWLINE> while Flag : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ index ] < c : <NEWLINE> <INDENT> A [ index ] = c <NEWLINE> cnt += 1 <NEWLINE> index += 1 <NEWLINE> if ( cnt >= b ) or ( index >= n ) : <NEWLINE> <INDENT> Flag = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if n % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif n / 10 < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = math . floor ( n / 10 ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> read = stdin . readline <NEWLINE> N = int ( read ( ) ) <NEWLINE> data = list ( map ( int , read ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> flg = False <NEWLINE> if 0 in data : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in data : <NEWLINE> <NL> <INDENT> if ans * i > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> flag = False <NEWLINE> b = [ False ] * 1000010 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> if b [ a [ i ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a [ i ] , 1000010 , a [ i ] ) : <NEWLINE> <INDENT> b [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not b [ a [ i ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> for j in range ( a [ i ] , 1000010 , a [ i ] ) : <NEWLINE> <INDENT> b [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> from math import sqrt , ceil , pow <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> <NL> <NL> <COMMENT> <NL> class SieveOfAtkin : <NEWLINE> <INDENT> def __init__ ( self , limit ) : <NEWLINE> <INDENT> self . limit = limit <NEWLINE> self . primes = [ ] <NEWLINE> self . sieve = [ False ] * ( self . limit + 1 ) <NEWLINE> <NL> <DEDENT> def flip ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . sieve [ prime ] = True if self . sieve [ prime ] == False else False <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def invalidate ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if self . sieve [ prime ] == True : self . sieve [ prime ] = False <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def isPrime ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . sieve [ prime ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def getPrimes ( self ) : <NEWLINE> <INDENT> testingLimit = int ( ceil ( sqrt ( self . limit ) ) ) <NEWLINE> <NL> for i in range ( testingLimit ) : <NEWLINE> <INDENT> for j in range ( testingLimit ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 4 * int ( pow ( i , 2 ) ) + int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and ( n % 12 == 1 or n % 12 == 5 ) : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = 3 * int ( pow ( i , 2 ) ) + int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and n % 12 == 7 : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = 3 * int ( pow ( i , 2 ) ) - int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and i > j and n % 12 == 11 : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 5 , testingLimit ) : <NEWLINE> <INDENT> if self . isPrime ( i ) : <NEWLINE> <INDENT> k = int ( pow ( i , 2 ) ) <NEWLINE> for j in range ( k , self . limit , k ) : <NEWLINE> <INDENT> self . invalidate ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> self . primes = [ 2 , 3 ] + [ x for x in range ( len ( self . sieve ) ) if self . isPrime ( x ) and x >= 5 ] <NEWLINE> return self . primes <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> def solve1 ( num , primes ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = bisect . bisect_left ( primes , num ) <NEWLINE> lt = primes [ i - 1 ] <NEWLINE> i = bisect . bisect_left ( primes , num + 1 ) <NEWLINE> gt = primes [ i ] <NEWLINE> return lt , gt <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A = SieveOfAtkin ( 55000 ) <NEWLINE> A . getPrimes ( ) <NEWLINE> <COMMENT> <NL> for line in sys . stdin : <NEWLINE> <INDENT> num = int ( line ) <NEWLINE> lt , gt = solve1 ( num , A . primes ) <NEWLINE> print ( <STRING> . format ( lt , gt ) ) <NEWLINE> <DEDENT> <DEDENT>
kazu , ashi = map ( int , input ( ) . split ( ) ) <NEWLINE> tsuru , kame = 0 , 0 <NEWLINE> hantei = 0 <NEWLINE> <NL> for i in range ( kazu + 1 ) : <NEWLINE> <INDENT> kame = i <NEWLINE> tsuru = kazu - i <NEWLINE> if kame * 4 + tsuru * 2 == ashi : <NEWLINE> <INDENT> hantei = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if hantei : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( nums [ i ] == 0 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> <DEDENT> if ( res != 0 ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> res *= nums [ i ] <NEWLINE> if ( res > 1000000000000000000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if res <= 1000000000000000000 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> data = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> spam = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> spam . append ( sum ( spam ) ) <NEWLINE> data . append ( spam ) <NEWLINE> <DEDENT> spam = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> spam . append ( sum ( x [ i ] for x in data ) ) <NEWLINE> <DEDENT> data . append ( spam ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( data [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hoge = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( hoge [ 0 ] ) <NEWLINE> b . append ( hoge [ 1 ] ) <NEWLINE> <NL> <DEDENT> tenbo = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h [ a [ i ] - 1 ] > h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> tenbo . append ( b [ i ] ) <NEWLINE> <DEDENT> elif h [ a [ i ] - 1 ] < h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> tenbo . append ( a [ i ] ) <NEWLINE> <DEDENT> elif h [ a [ i ] - 1 ] == h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> tenbo . append ( a [ i ] ) <NEWLINE> tenbo . append ( b [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( Counter ( tenbo ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * 100001 <NEWLINE> for i in A : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( C - B ) * cnt [ B ] <NEWLINE> S += diff <NEWLINE> print ( S ) <NEWLINE> cnt [ C ] += cnt [ B ] <NEWLINE> cnt [ B ] = 0 <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = [ [ 0 for i in range ( 6 ) ] for j in range ( n + 1 ) ] <NEWLINE> absDiff = abs ( x [ 0 ] - y [ 0 ] ) <NEWLINE> tmp [ 0 ] [ 3 ] = tmp [ 0 ] [ 0 ] = absDiff <NEWLINE> tmp [ 0 ] [ 4 ] = tmp [ 0 ] [ 1 ] = absDiff ** 2 <NEWLINE> tmp [ 0 ] [ 5 ] = tmp [ 0 ] [ 2 ] = absDiff ** 3 <NEWLINE> max = absDiff <NEWLINE> for i in range ( 1 , n , 1 ) : <NEWLINE> <INDENT> absDiff = abs ( x [ i ] - y [ i ] ) <NEWLINE> tmp [ i ] [ 0 ] = absDiff <NEWLINE> tmp [ i ] [ 1 ] = absDiff ** 2 <NEWLINE> tmp [ i ] [ 2 ] = absDiff ** 3 <NEWLINE> tmp [ i ] [ 3 ] = tmp [ i - 1 ] [ 3 ] + tmp [ i ] [ 0 ] <NEWLINE> tmp [ i ] [ 4 ] = tmp [ i - 1 ] [ 4 ] + tmp [ i ] [ 1 ] <NEWLINE> tmp [ i ] [ 5 ] = tmp [ i - 1 ] [ 5 ] + tmp [ i ] [ 2 ] <NEWLINE> if absDiff > max : <NEWLINE> <INDENT> max = absDiff <NEWLINE> <DEDENT> <DEDENT> print ( tmp [ n - 1 ] [ 3 ] ) <NEWLINE> print ( math . sqrt ( tmp [ n - 1 ] [ 4 ] ) ) <NEWLINE> print ( tmp [ n - 1 ] [ 5 ] ** ( 1 / 3 ) ) <NEWLINE> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> p = str ( i ) . zfill ( 3 ) <NEWLINE> if S . find ( p [ 0 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S1 = S [ S . find ( p [ 0 ] ) + 1 : ] <NEWLINE> if S1 . find ( p [ 1 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S2 = S1 [ S1 . find ( p [ 1 ] ) + 1 : ] <NEWLINE> if S2 . find ( p [ 2 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 6 <NEWLINE> <NL> A . sort ( ) <NEWLINE> check = [ False ] + [ True ] * ( INF ) <NEWLINE> <NL> setA = list ( set ( A ) ) <NEWLINE> length = len ( setA ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> x = setA [ i ] <NEWLINE> for j in range ( 2 , int ( INF / x ) + 1 ) : <NEWLINE> <INDENT> check [ x * j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> prev = 0 <NEWLINE> count = 0 <NEWLINE> flag = False <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> if check [ x ] : <NEWLINE> <INDENT> if x != prev : <NEWLINE> <INDENT> count += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> count -= 1 <NEWLINE> flag = False <NEWLINE> <DEDENT> prev = x <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> A = 100 <NEWLINE> c = 0 <NEWLINE> while ( A < X ) : <NEWLINE> <INDENT> A = int ( A * 1.01 ) <NEWLINE> c = c + 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> a_cnt = S . count ( <STRING> ) <NEWLINE> b_cnt = S . count ( <STRING> ) <NEWLINE> c_cnt = S . count ( <STRING> ) <NEWLINE> if abs ( a_cnt - b_cnt ) <= 1 and abs ( a_cnt - c_cnt ) <= 1 and abs ( b_cnt - c_cnt ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <COMMENT> <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n // 2 ) : <NEWLINE> <INDENT> if ( num_list [ 2 * i ] % 2 ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( n // 2 ) + 1 ) : <NEWLINE> <INDENT> if ( num_list [ 2 * i ] % 2 ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_ , b_ = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_ . append ( a_ [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_ . append ( b_ [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <NL> <INDENT> if a_ [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_ [ j ] > k - a_ [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> S = collections . Counter ( s ) <NEWLINE> M = S . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> S = sorted ( S . most_common ( ) ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] [ 1 ] == M : <NEWLINE> <INDENT> print ( S [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> count = num <NEWLINE> lists = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> lists . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( lists ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> A . sort ( ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> <INDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> a = b <NEWLINE> a += 1 <NEWLINE> b = c <NEWLINE> b += 1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> elif A [ i ] + 2 == A [ i + 1 ] : <NEWLINE> <INDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if ans < b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> a = c <NEWLINE> a += 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if ans < b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> if ans < c : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if ans < b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> if ans < c : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] + A + [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> L = [ A [ 1 ] ] <NEWLINE> tempL = A [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tempL = gcd ( tempL , A [ i + 1 ] ) <NEWLINE> L . append ( tempL ) <NEWLINE> <DEDENT> L = [ 0 ] + L <NEWLINE> <NL> <COMMENT> <NL> R = [ A [ - 2 ] ] <NEWLINE> tempR = A [ - 2 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tempR = gcd ( tempR , A [ - i - 2 ] ) <NEWLINE> R . append ( tempR ) <NEWLINE> <DEDENT> R = list ( reversed ( R ) ) + [ 0 ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result = gcd ( L [ i ] , R [ i + 1 ] ) <NEWLINE> ans . append ( result ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N_ko , K_kai = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A_list , dtype = np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def cal_cumsum ( A ) : <NEWLINE> <INDENT> Light_length = np . zeros ( N_ko , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( N_ko ) : <NEWLINE> <INDENT> left = max ( 0 , i - A [ i ] ) <NEWLINE> right = min ( N_ko - 1 , i + A [ i ] ) <NEWLINE> <NL> Light_length [ left ] += 1 <NEWLINE> <NL> if ( right + 1 < N_ko ) : <NEWLINE> <INDENT> Light_length [ right + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Light_length = np . cumsum ( Light_length ) <NEWLINE> <NL> return ( Light_length ) <NEWLINE> <NL> <DEDENT> for k in range ( min ( 42 , K_kai ) ) : <NEWLINE> <INDENT> A = cal_cumsum ( A ) <NEWLINE> <NL> <NL> <DEDENT> print ( * A ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in l : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
limit = 1E18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> total = 1 <NEWLINE> <COMMENT> <NL> line = str ( input ( ) ) <NEWLINE> <NL> if line . startswith ( <STRING> ) or <STRING> in line : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in line . split ( ) : <NEWLINE> <INDENT> x = int ( i ) <NEWLINE> total *= x <NEWLINE> if total > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if total > limit else total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> word = input ( ) <NEWLINE> a . append ( word ) <NEWLINE> <DEDENT> print ( len ( set ( a ) ) ) <NEWLINE>
def totalcost_recur ( i , cost , N , lookup ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i in lookup : <NEWLINE> <INDENT> return lookup [ i ] <NEWLINE> <DEDENT> option1 = abs ( cost [ i ] - cost [ i + 1 ] ) + totalcost_recur ( i + 1 , cost , N , lookup ) <NEWLINE> ans = option1 <NEWLINE> if i + 2 <= N : <NEWLINE> <INDENT> option2 = abs ( cost [ i ] - cost [ i + 2 ] ) + totalcost_recur ( i + 2 , cost , N , lookup ) <NEWLINE> ans = min ( option2 , ans ) <NEWLINE> <DEDENT> lookup [ i ] = ans <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> def totalcost_dp ( cost , N ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = abs ( cost [ 2 ] - cost [ 1 ] ) <NEWLINE> i = 3 <NEWLINE> while i <= N : <NEWLINE> <INDENT> option1 = dp [ i - 1 ] + abs ( cost [ i ] - cost [ i - 1 ] ) <NEWLINE> option2 = dp [ i - 2 ] + abs ( cost [ i ] - cost [ i - 2 ] ) <NEWLINE> dp [ i ] = min ( option1 , option2 ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> return dp [ N ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 0 ] + cost <NEWLINE> lookup = { } <NEWLINE> <NL> print ( totalcost_dp ( cost , n ) ) <NEWLINE>
n = [ 0 for i in range ( 10001 ) ] <NEWLINE> for z in range ( 1 , 100 , 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 , 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , 100 , 1 ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if tmp > 10 ** 4 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ tmp ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> print ( n [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input_methods = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> using_method = 1 <NEWLINE> input_method = input_methods [ using_method ] <NEWLINE> <NL> IN = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> LIN = lambda : list ( IN ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , k = IN ( ) <NEWLINE> <COMMENT> <NL> al = LIN ( ) <NEWLINE> pre_aa = [ - 1 ] * n <NEWLINE> pos = 0 <NEWLINE> pre_aa [ 0 ] = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> pos = al [ pos ] - 1 <NEWLINE> if pre_aa [ pos ] >= 0 : <NEWLINE> <INDENT> loop = i - pre_aa [ pos ] <NEWLINE> break <NEWLINE> <DEDENT> pre_aa [ pos ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return pos + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for _ in range ( ( k - i ) % loop ) : <NEWLINE> <INDENT> pos = al [ pos ] - 1 <NEWLINE> <NL> <DEDENT> print ( pos + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> isTest = False <NEWLINE> <NL> def pa ( v ) : <NEWLINE> <INDENT> if isTest : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> def input_clipboard ( ) : <NEWLINE> <INDENT> import clipboard <NEWLINE> input_text = clipboard . get ( ) <NEWLINE> input_l = input_text . splitlines ( ) <NEWLINE> for l in input_l : <NEWLINE> <INDENT> yield l <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if sys . platform == <STRING> : <NEWLINE> <INDENT> if input_method == input_methods [ 0 ] : <NEWLINE> <INDENT> ic = input_clipboard ( ) <NEWLINE> input = lambda : ic . __next__ ( ) <NEWLINE> <DEDENT> elif input_method == input_methods [ 1 ] : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> isTest = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ret = main ( ) <NEWLINE> if ret is not None : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = 1000000007 <NEWLINE> <NL> sm = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for s in range ( len ( A ) - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> sm -= A [ s ] <NEWLINE> ans += A [ s ] * sm <NEWLINE> <NL> <DEDENT> if ans > 1000000007 : <NEWLINE> <INDENT> print ( ans % k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( int ( input ( ) ) for _ in range ( q ) ) <NEWLINE> p = [ k - q ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> p [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if p [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> readline = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> inf = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> K = N // 2 <NEWLINE> DP0 = [ - inf ] * N <NEWLINE> DP1 = [ - inf ] * N <NEWLINE> DP2 = [ - inf ] * N <NEWLINE> <NL> DP2 [ 0 ] = A [ 0 ] <NEWLINE> DP2 [ 1 ] = max ( A [ 0 ] , A [ 1 ] ) <NEWLINE> DP1 [ : 2 ] = [ 0 ] * 2 <NEWLINE> DP0 [ : 4 ] = [ 0 ] * 4 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> DP2 [ i ] = DP2 [ i - 2 ] + A [ i ] <NEWLINE> DP1 [ i ] = max ( DP2 [ i - 1 ] , DP1 [ i - 2 ] + A [ i ] ) <NEWLINE> DP0 [ i ] = max ( DP1 [ i - 1 ] , DP0 [ i - 2 ] + A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP2 [ i ] = max ( DP2 [ i - 2 ] + A [ i ] , DP2 [ i - 1 ] ) <NEWLINE> DP1 [ i ] = max ( DP1 [ i - 1 ] , DP1 [ i - 2 ] + A [ i ] ) <NEWLINE> DP0 [ i ] = max ( DP0 [ i - 1 ] , DP0 [ i - 2 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 2 == 0 : <NEWLINE> <INDENT> ans = DP2 [ N - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = DP1 [ N - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxA = max ( A ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] = 1 <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> n = n0 ( ) <NEWLINE> a = n1 ( ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> clist = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> c = Counter ( clist ) <NEWLINE> <NL> print ( sum ( [ v * ( v - 1 ) // 2 for v in c . values ( ) ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> l . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <NL> <DEDENT> l = sorted ( l , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> l = sorted ( l , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( l [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ok = 0 ; <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> c *= a [ i ] <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> ok = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> if ( ok ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
def calc_allocatable_packet ( packets , num_of_trucks , p_max ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num_of_packets = len ( packets ) <NEWLINE> next_p = 0 <COMMENT> <NEWLINE> for t in range ( num_of_trucks ) : <NEWLINE> <INDENT> payload = 0 <COMMENT> <NEWLINE> while next_p < num_of_packets : <NEWLINE> <INDENT> if payload + packets [ next_p ] <= p_max : <COMMENT> <NEWLINE> <INDENT> payload += packets [ next_p ] <NEWLINE> next_p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return next_p <NEWLINE> <NL> <NL> <DEDENT> def calc_minimum_payload ( packets , num_of_trucks ) : <NEWLINE> <INDENT> num_of_packets = len ( packets ) <NEWLINE> lower_limit = packets [ 0 ] <NEWLINE> upper_limit = 10000 * num_of_packets <NEWLINE> <NL> while lower_limit < upper_limit : <NEWLINE> <INDENT> middle = ( lower_limit + upper_limit ) // 2 <NEWLINE> result = calc_allocatable_packet ( packets , num_of_trucks , middle ) <NEWLINE> if result < num_of_packets : <NEWLINE> <INDENT> lower_limit = middle + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> upper_limit = middle <NEWLINE> <NL> <DEDENT> <DEDENT> return lower_limit <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_packets , num_of_trucks = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> packets = [ int ( input ( ) ) for _ in range ( num_of_packets ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> result = calc_minimum_payload ( packets , num_of_trucks ) <NEWLINE> <NL> <COMMENT> <NL> print ( result ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> a_max = max ( a ) <NEWLINE> dp = [ True for _ in range ( a_max + 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] ] : <NEWLINE> <INDENT> for j in range ( 0 , a_max + 1 , a [ i ] ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> if a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> ar = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( len ( a ) - t + 1 ) : <NEWLINE> <INDENT> if a [ i : i + t ] not in ar : <NEWLINE> <INDENT> ar . append ( a [ i : i + t ] ) <NEWLINE> <DEDENT> <DEDENT> t += 1 <NEWLINE> if t > len ( a ) or t > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ar . sort ( ) <NEWLINE> print ( ar [ n - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dict_L = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i + 1 + A [ i ] in dict_L . keys ( ) ) : <NEWLINE> <INDENT> dict_L [ i + 1 + A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict_L [ i + 1 + A [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> R = j + 1 - A [ j ] <NEWLINE> if ( R in dict_L . keys ( ) ) : <NEWLINE> <INDENT> cnt += dict_L [ R ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> class Ruiwa ( ) : <NEWLINE> <INDENT> def __init__ ( self , a ) : <NEWLINE> <INDENT> self . H = h = len ( a ) <NEWLINE> self . W = w = len ( a [ 0 ] ) <NEWLINE> self . R = r = a <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( 1 , w ) : <NEWLINE> <INDENT> r [ i ] [ j ] += r [ i ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> r [ i ] [ j ] += r [ i - 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def search ( self , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> if x1 > x2 or y1 > y2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> r = self . R <NEWLINE> rr = r [ y2 ] [ x2 ] <NEWLINE> if x1 > 0 and y1 > 0 : <NEWLINE> <INDENT> return rr - r [ y1 - 1 ] [ x2 ] - r [ y2 ] [ x1 - 1 ] + r [ y1 - 1 ] [ x1 - 1 ] <NEWLINE> <DEDENT> if x1 > 0 : <NEWLINE> <INDENT> rr -= r [ y2 ] [ x1 - 1 ] <NEWLINE> <DEDENT> if y1 > 0 : <NEWLINE> <INDENT> rr -= r [ y1 - 1 ] [ x2 ] <NEWLINE> <NL> <DEDENT> return rr <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> na = [ LI ( ) for _ in range ( n ) ] <NEWLINE> xd = set ( ) <NEWLINE> yd = set ( ) <NEWLINE> for x , y in na : <NEWLINE> <INDENT> xd . add ( x ) <NEWLINE> yd . add ( y ) <NEWLINE> <NL> <DEDENT> xl = sorted ( list ( xd ) ) <NEWLINE> yl = sorted ( list ( yd ) ) <NEWLINE> xx = { } <NEWLINE> yy = { } <NEWLINE> for i in range ( len ( xl ) ) : <NEWLINE> <INDENT> xx [ xl [ i ] ] = i <NEWLINE> <DEDENT> for i in range ( len ( yl ) ) : <NEWLINE> <INDENT> yy [ yl [ i ] ] = i <NEWLINE> <DEDENT> a = [ [ 0 ] * ( len ( yl ) + 1 ) for _ in range ( len ( xl ) + 1 ) ] <NEWLINE> for x , y in na : <NEWLINE> <INDENT> a [ xx [ x ] ] [ yy [ y ] ] += 1 <NEWLINE> <DEDENT> rui = Ruiwa ( a ) <NEWLINE> r = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = LI ( ) <NEWLINE> xx1 = bisect . bisect_left ( xl , x1 ) <NEWLINE> yy1 = bisect . bisect_left ( yl , y1 ) <NEWLINE> xx2 = bisect . bisect ( xl , x2 ) - 1 <NEWLINE> yy2 = bisect . bisect ( yl , y2 ) - 1 <NEWLINE> r . append ( rui . search ( yy1 , xx1 , yy2 , xx2 ) ) <NEWLINE> <NL> <NL> <DEDENT> return <STRING> . join ( map ( str , r ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum_s = sum ( A ) ** 2 <NEWLINE> <NL> for e in A : <NEWLINE> <INDENT> A_sum_s -= e ** 2 <NEWLINE> <DEDENT> print ( A_sum_s // 2 % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a += A [ N - i - 1 ] <NEWLINE> ans += A [ N - i - 2 ] * a <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> rem = 7 % K <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif rem % K == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( rem % K ) != 0 and count <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> rem += 7 * pow ( 10 , count - 1 , mod = K ) % K <NEWLINE> <DEDENT> if count <= K : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> x = str ( i ) <NEWLINE> if i % 3 == 0 : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in x : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> from networkx import Graph <NEWLINE> from networkx . algorithms . traversal . breadth_first_search import bfs_predecessors <NEWLINE> G = Graph ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> rows = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> G . add_edges_from ( rows ) <NEWLINE> <NL> <COMMENT> <NL> preds = bfs_predecessors ( G , source = 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> preds = dict ( preds ) <NEWLINE> if len ( preds ) + 1 != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( preds [ i ] ) <NEWLINE> <DEDENT>
[ n , k ] , [ * a ] = [ [ * map ( int , t . split ( ) ) ] for t in open ( 0 ) ] <NEWLINE> count = 0 <NEWLINE> visited = dict ( ) <NEWLINE> tmp = 1 <NEWLINE> while count < k : <NEWLINE> <INDENT> visited [ tmp ] = count <NEWLINE> count += 1 <NEWLINE> tmp = a [ tmp - 1 ] <NEWLINE> if tmp in visited : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if count < k : <NEWLINE> <INDENT> k = ( k - count ) % ( count - visited [ tmp ] ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> tmp = a [ tmp - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
treeRoot = { <STRING> : None , <STRING> : None , <STRING> : None , <STRING> : None } <NEWLINE> <NL> root = None <NEWLINE> <NL> <NL> def insert ( val ) : <NEWLINE> <INDENT> global root <NEWLINE> z = { <STRING> : None , <STRING> : None , <STRING> : None , <STRING> : val } <NEWLINE> x = root <NEWLINE> y = None <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z [ <STRING> ] < x [ <STRING> ] : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> z [ <STRING> ] = y <NEWLINE> if y is None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if z [ <STRING> ] < y [ <STRING> ] : <NEWLINE> <INDENT> y [ <STRING> ] = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y [ <STRING> ] = z <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def inorder ( root ) : <NEWLINE> <INDENT> if root is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( root [ <STRING> ] ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( root [ <STRING> ] , end = <STRING> ) <NEWLINE> inorder ( root [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> def preorder ( root ) : <NEWLINE> <INDENT> if root is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( root [ <STRING> ] , end = <STRING> ) <NEWLINE> preorder ( root [ <STRING> ] ) <NEWLINE> preorder ( root [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> M = int ( input ( ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> line = input ( ) . strip ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> inorder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> preorder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inst , k = line . split ( ) <NEWLINE> k = int ( k ) <NEWLINE> if inst == <STRING> : <NEWLINE> <INDENT> insert ( k ) <NEWLINE> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> if ( len ( s ) <= k ) : <NEWLINE> <INDENT> word = <STRING> . join ( s ) <NEWLINE> print ( word ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> l . append ( s [ i ] ) <NEWLINE> name = <STRING> . join ( l ) <NEWLINE> <NL> <DEDENT> print ( name + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> L = S . split ( ) <NEWLINE> a = L [ 0 ] <NEWLINE> a = int ( a ) <NEWLINE> b = L [ 1 ] <NEWLINE> b = int ( b ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> d = 1 <NEWLINE> num = 0 <NEWLINE> ans = 0 <NEWLINE> mod_list = [ 0 ] * 2019 <NEWLINE> mod_list [ 0 ] = 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> mod_list [ num % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += mod_list [ i ] * ( mod_list [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = list ( B ) <NEWLINE> if len ( B ) <= 2 : <NEWLINE> <INDENT> B . append ( <STRING> ) <NEWLINE> B . append ( <STRING> ) <NEWLINE> <DEDENT> elif B [ - 3 ] == <STRING> : <NEWLINE> <INDENT> B . remove ( <STRING> ) <NEWLINE> <DEDENT> elif B [ - 2 ] == <STRING> : <NEWLINE> <INDENT> B . remove ( <STRING> ) <NEWLINE> B . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( <STRING> ) <NEWLINE> B . append ( <STRING> ) <NEWLINE> <DEDENT> n = len ( B ) <NEWLINE> b = sum ( 10 ** ( n - 1 - j ) * int ( B [ j ] ) for j in range ( n ) ) <NEWLINE> ans = list ( str ( A * b ) ) <NEWLINE> if len ( ans ) <= 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( len ( ans ) - 1 ) <NEWLINE> ans . pop ( len ( ans ) - 1 ) <NEWLINE> <DEDENT> n2 = len ( ans ) <NEWLINE> trueans = sum ( 10 ** ( n2 - 1 - j ) * int ( ans [ j ] ) for j in range ( n2 ) ) <NEWLINE> print ( trueans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ K ] * N <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> L [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in L : <NEWLINE> <INDENT> if i - Q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> info = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , list ( input ( ) . split ( ) ) ) <NEWLINE> info [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , info [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ans += d [ i - a ] <COMMENT> <NEWLINE> d [ i + a ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( min ( X ) , 1 + max ( X ) ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> tmp += ( X [ j ] - i ) ** 2 <NEWLINE> <DEDENT> ans . append ( tmp ) <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
def incr_lunlun ( num ) : <NEWLINE> <INDENT> num [ 0 ] += 1 <NEWLINE> if len ( num ) == 1 : <NEWLINE> <INDENT> if num [ 0 ] == 10 : <NEWLINE> <INDENT> num . append ( 1 ) <NEWLINE> num [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> elif num [ 0 ] > num [ 1 ] + 1 or num [ 0 ] == 10 : <NEWLINE> <INDENT> suffix = incr_lunlun ( num [ 1 : ] ) <NEWLINE> digit = max ( 0 , suffix [ 0 ] - 1 ) <NEWLINE> num = [ digit ] + list ( suffix ) <NEWLINE> <NL> <DEDENT> return num <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> num = [ 1 ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> num = incr_lunlun ( num ) <NEWLINE> <NL> <DEDENT> print ( int ( <STRING> . join ( str ( i ) for i in reversed ( num ) ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for m in range ( n , N + 1 , n ) : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> MOD = 1_000_000_007 <NEWLINE> print ( reduce ( lambda a , b : a * b % MOD , range ( 1 , int ( input ( ) ) + 1 ) , 1 ) ) <NEWLINE>
h1 , m1 , h2 , m2 , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = h2 - h1 <NEWLINE> m = m2 - m1 <NEWLINE> print ( h * 60 + m - k ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = int ( N / i ) <NEWLINE> ans += n * ( n + 1 ) / 2 * i <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
a , b , c = input ( ) <NEWLINE> <NL> if a == <STRING> or b == <STRING> or c == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] <NEWLINE> H . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> R = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a ] . append ( b ) <NEWLINE> R [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in R [ i ] : <NEWLINE> <INDENT> if H [ i ] <= H [ j ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
data = input ( ) . split ( ) <NEWLINE> <NL> for n in range ( len ( data ) ) : <NEWLINE> <INDENT> data [ n ] = int ( data [ n ] ) <NEWLINE> <NL> <DEDENT> W , H , x , y , r = data <NEWLINE> <NL> if ( r <= x <= W - r ) and ( r <= y <= H - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif d == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif e == 0 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
h , w = [ ] , [ ] <NEWLINE> while True : <NEWLINE> <INDENT> ( h , w ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for x in range ( h ) : <NEWLINE> <INDENT> for y in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = list ( range ( 2 * n ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def find ( x ) : <NEWLINE> <NL> <INDENT> while par [ x ] != x : <NEWLINE> <INDENT> tmp = par [ x ] <NEWLINE> par [ x ] = par [ par [ x ] ] <NEWLINE> x = par [ x ] <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x1 = find ( x ) <NEWLINE> y1 = find ( y ) <NEWLINE> if x1 != y1 : <NEWLINE> <INDENT> par [ x1 ] = y1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> s = [ 0 for i in range ( n + 5 ) ] <NEWLINE> <NL> <COMMENT> <NL> for k in range ( n ) : <NEWLINE> <INDENT> s [ find ( k ) ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( s ) ) <NEWLINE>
<COMMENT> <NL> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 for _ in range ( 201 ) ] <NEWLINE> for i in range ( - 100 , 101 ) : <NEWLINE> <INDENT> d [ i + 100 ] = i + 1 <NEWLINE> <NL> <DEDENT> for i in p : <NEWLINE> <INDENT> d . remove ( i ) <NEWLINE> <NL> <DEDENT> d2 = [ 0 for _ in range ( len ( d ) ) ] <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> d2 [ i ] = abs ( d [ i ] - x ) <NEWLINE> <NL> <DEDENT> m = 10000 <NEWLINE> for i in reversed ( range ( len ( d2 ) ) ) : <NEWLINE> <INDENT> if d2 [ i ] <= m : <NEWLINE> <INDENT> m = d2 [ i ] <NEWLINE> tmpi = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d [ tmpi ] ) <NEWLINE>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> if list ( set ( s ) ) == [ <STRING> ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> t = [ i for i in s if i != <STRING> ] <NEWLINE> n = len ( t ) <NEWLINE> if <STRING> . join ( t ) != <STRING> . join ( t [ : : - 1 ] ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic = { } <NEWLINE> cnt = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == n // 2 : <NEWLINE> <INDENT> a = s [ : j + 1 ] <NEWLINE> a = a [ : : - 1 ] <NEWLINE> <DEDENT> if cnt == n // 2 + 1 : <NEWLINE> <INDENT> b = s [ j : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = 0 <NEWLINE> fa = [ ] <NEWLINE> fb = [ ] <NEWLINE> for k in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ k ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> for p in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ p ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fb . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fb . append ( c ) <NEWLINE> ans = 0 <NEWLINE> for q in range ( len ( fa ) ) : <NEWLINE> <INDENT> ans += max ( fa [ q ] , fb [ q ] ) - min ( fa [ q ] , fb [ q ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == int ( n / 2 ) + 1 : <NEWLINE> <INDENT> a = s [ : j + 1 ] <NEWLINE> a = a [ : : - 1 ] <NEWLINE> b = s [ j : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = 0 <NEWLINE> fa = [ ] <NEWLINE> fb = [ ] <NEWLINE> for k in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ k ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fa . append ( c ) <NEWLINE> c = 0 <NEWLINE> for p in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ p ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fb . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> fb . append ( c ) <NEWLINE> ans = 0 <NEWLINE> for q in range ( len ( fa ) ) : <NEWLINE> <INDENT> ans += max ( fa [ q ] , fb [ q ] ) - min ( fa [ q ] , fb [ q ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxA = max ( A ) + 1 <NEWLINE> <NL> C = [ 0 ] * maxA <NEWLINE> <NL> g = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> g = math . gcd ( g , a ) <NEWLINE> <NL> <DEDENT> pairwise = True <NEWLINE> <NL> is_prime = [ True ] * maxA <NEWLINE> <NL> for i in range ( 2 , maxA ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , maxA , i ) : <NEWLINE> <INDENT> cnt += C [ j ] <NEWLINE> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if g == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> if A + B - 1 <= N <= A * B : <NEWLINE> <INDENT> S = N - A <NEWLINE> cur = N <NEWLINE> ans = [ ] <NEWLINE> for i in range ( A + 1 ) : <NEWLINE> <INDENT> num = min ( B - 1 , S ) + 1 <NEWLINE> S -= num - 1 <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> ans . append ( cur - num + 1 + j ) <NEWLINE> <DEDENT> cur -= num <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] [ 1 : ] <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> from bisect import bisect <NEWLINE> <NL> <NL> def LIS ( L ) : <NEWLINE> <INDENT> INF , N = 10 ** 12 , len ( L ) <NEWLINE> seq = [ INF ] * N <NEWLINE> for i in L : <NEWLINE> <INDENT> seq [ bisect ( seq , i ) ] = i <NEWLINE> <DEDENT> return N - seq . count ( INF ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> dist = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> print ( dist ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> text = input ( ) <NEWLINE> <NL> dataset = text . split ( ) <NEWLINE> reverse = [ ] <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> reverse . append ( dataset [ n - x - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( reverse ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> from math import gcd <NEWLINE> count = defaultdict ( int ) <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> zeros = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if A == B == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if A == 0 : <NEWLINE> <INDENT> angle = ( 0 , 1 ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> angle = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sgn = A // abs ( A ) <NEWLINE> g = gcd ( A , B ) <NEWLINE> angle = ( A // sgn // g , B // sgn // g ) <NEWLINE> <NL> <DEDENT> count [ angle ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> pairs = { } <NEWLINE> solos = [ ] <NEWLINE> for k1 in count : <NEWLINE> <INDENT> if k1 in pairs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if k1 == ( 0 , 1 ) : <NEWLINE> <INDENT> if ( 1 , 0 ) in count : <NEWLINE> <INDENT> pairs [ ( 1 , 0 ) ] = k1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solos . append ( k1 ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> A , B = k1 <NEWLINE> if B : <NEWLINE> <INDENT> sgn = - B // abs ( B ) <NEWLINE> k2 = ( - B // sgn , A // sgn ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k2 = ( 0 , 1 ) <NEWLINE> <DEDENT> if k2 in count : <NEWLINE> <INDENT> pairs [ k2 ] = k1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solos . append ( k1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> P = 1000000007 <NEWLINE> <NL> <NL> def pow2 ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return pow ( 2 , n , P ) <NEWLINE> <NL> <NL> <DEDENT> result = 1 <NEWLINE> for p in pairs : <NEWLINE> <COMMENT> <NL> <INDENT> n = count [ p ] <NEWLINE> m = count [ pairs [ p ] ] <NEWLINE> result = result * ( ( pow2 ( n ) - 1 ) + ( pow2 ( m ) - 1 ) + 1 ) % P <NEWLINE> <DEDENT> for k in solos : <NEWLINE> <COMMENT> <NL> <INDENT> result = result * pow2 ( count [ k ] ) % P <NEWLINE> <NL> <DEDENT> print ( ( result + zeros - 1 ) % P ) <NEWLINE>
XKD = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> X = int ( XKD [ 0 ] ) <NEWLINE> K = int ( XKD [ 1 ] ) <NEWLINE> D = int ( XKD [ 2 ] ) <NEWLINE> AX = abs ( X ) <NEWLINE> <NL> if AX > K * D : <NEWLINE> <INDENT> print ( AX - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K2 = AX // D <NEWLINE> if ( K - K2 ) % 2 == 0 : <NEWLINE> <INDENT> P = AX - K2 * D <NEWLINE> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = abs ( AX - ( K2 + 1 ) * D ) <NEWLINE> print ( P ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> <NL> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> x //= 10 <NEWLINE> <NL> if x != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> or c == <STRING> or c == <STRING> or c == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from collections import deque <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> minus , zero , plus = 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 0 : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <DEDENT> elif a [ i ] == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> que = deque ( a ) <NEWLINE> <NL> <COMMENT> <NL> plus_flg = False <NEWLINE> tmp = plus - k <NEWLINE> if tmp >= 0 : <NEWLINE> <INDENT> plus_flg = True <NEWLINE> <DEDENT> elif ( - tmp <= minus and - tmp % 2 == 0 ) or ( - tmp < minus and plus >= 1 ) : <NEWLINE> <INDENT> plus_flg = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if plus_flg : <NEWLINE> <INDENT> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while cnt < k : <NEWLINE> <INDENT> if k - cnt >= 2 : <NEWLINE> <INDENT> if que [ 0 ] * que [ 1 ] >= que [ - 1 ] * que [ - 2 ] : <NEWLINE> <INDENT> ans *= que . popleft ( ) <NEWLINE> ans *= que . popleft ( ) <NEWLINE> ans %= mod <NEWLINE> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= que . pop ( ) <NEWLINE> ans %= mod <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans *= que . pop ( ) <NEWLINE> ans %= mod <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> elif zero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = [ abs ( a [ i ] ) for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans = - ans % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] > A [ i ] : <NEWLINE> <INDENT> count += A [ i - 1 ] - A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> work = 7 <NEWLINE> <NL> answer = - 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> i_mod = work % K <NEWLINE> if i_mod == 0 : <NEWLINE> <INDENT> answer = i <NEWLINE> break <NEWLINE> <DEDENT> work = i_mod * 10 + 7 <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for li in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ li ] ] ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> def isfeasible ( L ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < L : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a % L == 0 : <NEWLINE> <INDENT> dk = a // L - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dk = a // L <NEWLINE> <DEDENT> k += dk <NEWLINE> if k > K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = A [ 0 ] <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <INDENT> L = ( r + l ) // 2 <NEWLINE> if isfeasible ( L ) : <NEWLINE> <INDENT> r = L <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = L <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for h in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = math . gcd ( x , h ) <NEWLINE> sum = sum + p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> . join ( reversed ( a ) ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> _n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for num in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from networkx import * <NEWLINE> N = int ( input ( ) ) <NEWLINE> G = MultiDiGraph ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_node ( i , demand = - c ) <NEWLINE> G . add_weighted_edges_from ( [ ( i , - 1 , x + y ) , ( i , - 2 , x - y ) , ( i , - 3 , - x + y ) , ( i , - 4 , - x - y ) ] , capacity = c ) <NEWLINE> <DEDENT> for i in range ( N , N * 2 ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_node ( i , demand = c ) <NEWLINE> G . add_weighted_edges_from ( [ ( - 1 , i , - x - y ) , ( - 2 , i , - x + y ) , ( - 3 , i , x - y ) , ( - 4 , i , x + y ) ] , capacity = c ) <NEWLINE> <NL> <DEDENT> print ( - min_cost_flow_cost ( G ) ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> d = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> <NL> ans = [ <STRING> ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if d [ s [ i ] [ 0 ] ] == 0 and d [ s [ i ] [ 1 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if d [ s [ i ] [ 0 ] ] == 1 and d [ s [ i ] [ 1 ] ] == 1 and n - i > 1 : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] = 2 <NEWLINE> d [ s [ i ] [ 1 ] ] = 0 <NEWLINE> if d [ s [ i + 1 ] [ 0 ] ] == 0 and d [ s [ i + 1 ] [ 1 ] ] == 0 : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] = 0 <NEWLINE> d [ s [ i ] [ 1 ] ] = 2 <NEWLINE> ans . append ( s [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( s [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> elif d [ s [ i ] [ 0 ] ] >= d [ s [ i ] [ 1 ] ] : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] = d [ s [ i ] [ 0 ] ] - 1 <NEWLINE> d [ s [ i ] [ 1 ] ] = d [ s [ i ] [ 1 ] ] + 1 <NEWLINE> ans . append ( s [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] = d [ s [ i ] [ 0 ] ] + 1 <NEWLINE> d [ s [ i ] [ 1 ] ] = d [ s [ i ] [ 1 ] ] - 1 <NEWLINE> ans . append ( s [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> zall = 0 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A == 0 and B == 0 : <NEWLINE> <INDENT> zall += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A and B : <NEWLINE> <INDENT> if A < 0 and B < 0 : <NEWLINE> <INDENT> A *= - 1 <NEWLINE> B *= - 1 <NEWLINE> <DEDENT> elif A < 0 and B > 0 : <NEWLINE> <INDENT> A *= - 1 <NEWLINE> B *= - 1 <NEWLINE> <NL> <DEDENT> g = gcd ( A , B ) <NEWLINE> A //= g <NEWLINE> B //= g <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> B = 1 <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> A = 1 <NEWLINE> <NL> <DEDENT> if ( A , B ) in d : <NEWLINE> <INDENT> d [ ( A , B ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( A , B ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> used = defaultdict ( int ) <NEWLINE> <NL> for ( i , j ) , v in d . items ( ) : <NEWLINE> <INDENT> if used [ ( i , j ) ] : continue <NEWLINE> used [ ( i , j ) ] = 1 <NEWLINE> buf = 0 <NEWLINE> <NL> if j > 0 : <NEWLINE> <INDENT> if ( j , - i ) in d : <NEWLINE> <INDENT> used [ ( j , - i ) ] = 1 <NEWLINE> buf = d [ ( j , - i ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( - j , i ) in d : <NEWLINE> <INDENT> used [ ( - j , i ) ] = 1 <NEWLINE> buf = d [ ( - j , i ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= ( pow ( 2 , buf , MOD ) + pow ( 2 , v , MOD ) - 1 ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ( ans + zall - 1 ) % MOD ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uvab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> uvab [ i ] [ 0 ] -= 1 <NEWLINE> uvab [ i ] [ 1 ] -= 1 <NEWLINE> <NL> <DEDENT> railways = [ [ ] for _ in range ( N ) ] <NEWLINE> max_a = 0 <NEWLINE> for u , v , a , b in uvab : <NEWLINE> <INDENT> railways [ u ] . append ( ( v , a , b ) ) <NEWLINE> railways [ v ] . append ( ( u , a , b ) ) <NEWLINE> max_a = max ( max_a , a ) <NEWLINE> <DEDENT> del uvab <NEWLINE> <NL> max_silver = max_a * ( N - 1 ) <NEWLINE> <NL> ans = [ - 1 ] * N <NEWLINE> d = dict ( ) <NEWLINE> d [ ( S , 0 ) ] = 0 <COMMENT> <NEWLINE> Q = [ ( 0 , S , 0 ) ] <COMMENT> <NEWLINE> sum_reached = 0 <NEWLINE> reached = [ False ] * N <NEWLINE> <NL> while Q : <NEWLINE> <INDENT> t , sv , st = heapq . heappop ( Q ) <NEWLINE> if not reached [ st ] : <NEWLINE> <INDENT> ans [ st ] = t <NEWLINE> reached [ st ] = True <NEWLINE> sum_reached += 1 <NEWLINE> if sum_reached == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> new_key = ( min ( max_silver , sv + cd [ st ] [ 0 ] ) , st ) <NEWLINE> new_value = t + cd [ st ] [ 1 ] <NEWLINE> if new_key not in d or d [ new_key ] > new_value : <NEWLINE> <INDENT> d [ new_key ] = t + cd [ st ] [ 1 ] <NEWLINE> heapq . heappush ( Q , ( new_value , * new_key ) ) <NEWLINE> <NL> <DEDENT> for dist , a , b in railways [ st ] : <NEWLINE> <INDENT> if sv >= a : <NEWLINE> <INDENT> new_key = ( sv - a , dist ) <NEWLINE> new_value = t + b <NEWLINE> if new_key not in d or d [ new_key ] > new_value : <NEWLINE> <INDENT> d [ new_key ] = new_value <NEWLINE> heapq . heappush ( Q , ( new_value , * new_key ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( 10 ** 6 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i - a [ i ] > 0 : <NEWLINE> <INDENT> ans += b [ i - a [ i ] ] <NEWLINE> <DEDENT> if i + a [ i ] < 10 ** 6 : <NEWLINE> <INDENT> b [ i + a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> i = 3 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> for j in range ( 3 * i , n + 1 , 2 * i ) : a [ j ] = 1 <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> count = int ( n >= 2 ) <NEWLINE> count += sum ( a [ i ] == 0 for i in range ( 3 , n + 1 , 2 ) ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = a <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab = a + b <NEWLINE> ans = aa - ( k - ab ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> BN = len ( B ) <NEWLINE> <NL> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> res += BN <NEWLINE> ii , jj = i , j <NEWLINE> if ii > jj : <NEWLINE> <INDENT> ii , jj = jj , ii <NEWLINE> <DEDENT> if ii - ( jj - ii ) >= 0 : <NEWLINE> <INDENT> if S [ ii - ( jj - ii ) ] == <STRING> : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( abs ( jj - ii ) ) % 2 == 0 : <NEWLINE> <INDENT> if S [ ( jj + ii ) // 2 ] == <STRING> : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> if jj + ( jj - ii ) <= N - 1 : <NEWLINE> <INDENT> if S [ jj + ( jj - ii ) ] == <STRING> : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> m = s - i - j <NEWLINE> if ( 0 <= m <= k ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for x in range ( q ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> hikaku = 0 <NEWLINE> a_wa = sum ( a ) <NEWLINE> cou = collections . Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a_wa += cou [ b [ i ] [ 0 ] ] * b [ i ] [ 1 ] - cou [ b [ i ] [ 0 ] ] * b [ i ] [ 0 ] <NEWLINE> cou [ b [ i ] [ 1 ] ] += cou [ b [ i ] [ 0 ] ] <NEWLINE> cou [ b [ i ] [ 0 ] ] = 0 <NEWLINE> <NL> print ( a_wa ) <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> from datetime import date <NEWLINE> <NL> eras = { <STRING> : { <STRING> : None , <STRING> : date ( 1868 , 9 , 7 ) } , <NEWLINE> <STRING> : { <STRING> : date ( 1868 , 9 , 8 ) , <STRING> : date ( 1912 , 7 , 29 ) } , <NEWLINE> <STRING> : { <STRING> : date ( 1912 , 7 , 30 ) , <STRING> : date ( 1926 , 12 , 24 ) } , <NEWLINE> <STRING> : { <STRING> : date ( 1926 , 12 , 25 ) , <STRING> : date ( 1989 , 1 , 7 ) } , <NEWLINE> <STRING> : { <STRING> : date ( 1989 , 1 , 8 ) , <STRING> : None } } <NEWLINE> <NL> for line in f : <NEWLINE> <INDENT> y , m , d = map ( int , line . split ( ) ) <NEWLINE> target = date ( y , m , d ) <NEWLINE> for era_name , period in eras . items ( ) : <NEWLINE> <INDENT> if ( period [ <STRING> ] is None or period [ <STRING> ] <= target ) and ( period [ <STRING> ] is None or target <= period [ <STRING> ] ) : <NEWLINE> <INDENT> if era_name == <STRING> : <NEWLINE> <INDENT> print ( era_name ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( era_name , target . year - period [ <STRING> ] . year + 1 , target . month , target . day ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> x = A [ i ] / A [ i - K ] <NEWLINE> if x > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from numpy import zeros , int64 <NEWLINE> from numba import njit <NEWLINE> <NL> R , C , K , * RCV = map ( int64 , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> V = zeros ( ( R + 1 , C + 1 ) , int64 ) <NEWLINE> for r , c , v in zip ( * [ iter ( RCV ) ] * 3 ) : <NEWLINE> <INDENT> V [ r ] [ c ] = v <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> dp = zeros ( ( R + 1 , C + 1 , 4 ) , int64 ) <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <NL> <INDENT> vij = V [ i ] [ j ] <NEWLINE> <NL> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( <NEWLINE> <INDENT> dp [ i ] [ j - 1 ] [ k ] , <NEWLINE> dp [ i - 1 ] [ j ] [ 3 ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> for k in range ( 3 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] , <NEWLINE> vij + dp [ i ] [ j ] [ k - 1 ] <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ R ] [ C ] [ 3 ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> def popcnt ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def rec ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return rec ( n % popcnt ( n ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ret = [ rec ( x ) for x in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> arr = input ( ) <NEWLINE> <NL> ALL_ARR = int ( arr , 2 ) <NEWLINE> <NL> cnt = popcnt ( int ( arr , 2 ) ) <NEWLINE> init_big = ALL_ARR % ( cnt + 1 ) <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> init_small = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> init_small = ALL_ARR % ( cnt - 1 ) <NEWLINE> <NL> <NL> <DEDENT> li = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] == <STRING> : <NEWLINE> <INDENT> li [ i ] = ( init_big + pow ( 2 , n - i - 1 , cnt + 1 ) ) % ( cnt + 1 ) <NEWLINE> <DEDENT> elif ALL_ARR - ( 1 << ( n - i - 1 ) ) == 0 or cnt - 1 == 0 : <NEWLINE> <INDENT> li [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ i ] = ( init_small - pow ( 2 , n - i - 1 , cnt - 1 ) ) % ( cnt - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for x in li : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ret [ x ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = int ( N ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum *= int ( A [ i ] ) <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( H ) : <NEWLINE> <INDENT> for _ in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> T [ a ] . append ( b ) <NEWLINE> T [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> D = [ INF ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> Q = [ [ 0 , 0 , - 1 ] ] <NEWLINE> while Q : <NEWLINE> <INDENT> d , v , p = heappop ( Q ) <NEWLINE> if d >= D [ v ] : continue <NEWLINE> A [ v ] = p <NEWLINE> D [ v ] = d <NEWLINE> d += 1 <NEWLINE> for c in T [ v ] : <NEWLINE> <INDENT> if c == p : continue <NEWLINE> if d >= D [ c ] : continue <NEWLINE> heappush ( Q , [ d , c , v ] ) <NEWLINE> <DEDENT> <DEDENT> if INF in D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( A [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> G = [ 1 ] <NEWLINE> S = str ( G [ 0 ] ) <NEWLINE> <COMMENT> <NL> t = n // 5 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> f = 1.0 <NEWLINE> while f < t : <NEWLINE> <INDENT> f *= 2.2 <NEWLINE> f = int ( f ) <NEWLINE> G . insert ( 0 , f ) <NEWLINE> <COMMENT> <NL> S = str ( G [ 0 ] ) + <STRING> + S <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> print ( m ) <NEWLINE> print ( S ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> g = G [ i ] <NEWLINE> for j in range ( g , n ) : <NEWLINE> <INDENT> v = A [ j ] <NEWLINE> k = j - g <NEWLINE> while k >= 0 and A [ k ] > v : <NEWLINE> <INDENT> A [ k + g ] = A [ k ] <NEWLINE> k = k - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ k + g ] = v <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> li = [ 0 ] * 100001 <NEWLINE> for a in A : <NEWLINE> <INDENT> li [ a ] += 1 <NEWLINE> <DEDENT> ans = sum ( A ) <NEWLINE> <COMMENT> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * li [ b ] <NEWLINE> li [ c ] += li [ b ] <NEWLINE> li [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if C [ b ] != 0 : <NEWLINE> <INDENT> cnt = C [ b ] <NEWLINE> C [ c ] += cnt <NEWLINE> C [ b ] = 0 <NEWLINE> ans += ( c - b ) * cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = n // 2 <NEWLINE> if sum ( a ) / 2 == sum ( a [ : ( n // 2 ) ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif sum ( a ) / 2 >= sum ( a [ : ( n // 2 ) ] ) : <NEWLINE> <INDENT> while sum ( a ) / 2 >= sum ( a [ : x ] ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> print ( min ( abs ( 2 * sum ( a [ : x ] ) - sum ( a ) ) , abs ( 2 * sum ( a [ : x - 1 ] ) - sum ( a ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while sum ( a ) / 2 <= sum ( a [ : x ] ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> print ( min ( abs ( 2 * sum ( a [ : x ] ) - sum ( a ) ) , abs ( 2 * sum ( a [ : x + 1 ] ) - sum ( a ) ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> A_list . sort ( key = lambda x : - abs ( x ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> L_plus = R_plus = - 1 <COMMENT> <NEWLINE> L_minus = R_minus = - 1 <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( L_plus == - 1 ) and ( A_list [ i ] >= 0 ) : <NEWLINE> <INDENT> L_plus = i <NEWLINE> <DEDENT> if ( L_minus == - 1 ) and ( A_list [ i ] < 0 ) : <NEWLINE> <INDENT> L_minus = i <NEWLINE> <DEDENT> if ( L_plus != - 1 ) and ( L_minus != - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( R_plus == - 1 ) and ( A_list [ i ] >= 0 ) : <NEWLINE> <INDENT> R_plus = i <NEWLINE> <DEDENT> if ( R_minus == - 1 ) and ( A_list [ i ] < 0 ) : <NEWLINE> <INDENT> R_minus = i <NEWLINE> <DEDENT> if ( R_plus != - 1 ) and ( R_minus != - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cnt_minus = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if A_list [ i ] < 0 : <NEWLINE> <INDENT> cnt_minus += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if cnt_minus % 2 == 0 : <NEWLINE> <INDENT> target = A_list [ : K ] <NEWLINE> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if ( R_plus == - 1 ) and ( ( L_plus == - 1 ) or ( R_minus == - 1 ) ) : <NEWLINE> <NL> <INDENT> calc1 = calc2 = 0 <NEWLINE> <NL> <DEDENT> elif ( R_plus != - 1 ) and ( ( L_plus == - 1 ) or ( R_minus == - 1 ) ) : <NEWLINE> <NL> <INDENT> calc1 = 1 <NEWLINE> calc2 = 0 <NEWLINE> <NL> <DEDENT> elif ( R_plus == - 1 ) and ( ( L_plus != - 1 ) and ( R_minus != - 1 ) ) : <NEWLINE> <NL> <INDENT> calc1 = 0 <NEWLINE> calc2 = 1 <NEWLINE> <NL> <DEDENT> elif ( R_plus != - 1 ) and ( ( L_plus != - 1 ) and ( R_minus != - 1 ) ) : <NEWLINE> <NL> <INDENT> calc1 = A_list [ L_plus ] * A_list [ R_plus ] <NEWLINE> calc2 = A_list [ L_minus ] * A_list [ R_minus ] <NEWLINE> <NL> <NL> <DEDENT> if calc1 == calc2 : <NEWLINE> <INDENT> target = A_list [ N - K : N ] <NEWLINE> <NL> <DEDENT> elif calc1 > calc2 : <NEWLINE> <INDENT> A_list [ L_minus ] , A_list [ R_plus ] = A_list [ R_plus ] , A_list [ L_minus ] <NEWLINE> target = A_list [ : K ] <NEWLINE> <NL> <DEDENT> elif calc1 < calc2 : <NEWLINE> <INDENT> A_list [ L_plus ] , A_list [ R_minus ] = A_list [ R_minus ] , A_list [ L_plus ] <NEWLINE> target = A_list [ : K ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( len ( target ) ) : <NEWLINE> <INDENT> ans *= target [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = s [ i ] <NEWLINE> for j in range ( i + 1 , ( n + i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ 2 * j - i ] != s [ j ] and s [ j ] != tmp and s [ 2 * j - i ] != tmp : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numcntlist = [ 0 ] * N <NEWLINE> numCounter = Counter ( Alist ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> numcntlist [ i - 1 ] = numCounter [ i ] <NEWLINE> <NL> <DEDENT> sumcomb = 0 <NEWLINE> for i in numcntlist : <NEWLINE> <INDENT> sumcomb += int ( i * ( i - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> for i in Alist : <NEWLINE> <INDENT> ans = sumcomb - ( numCounter [ i ] - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> r = range ( 1 , K + 1 ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in r : <NEWLINE> <INDENT> for k in r : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ False ] * ( n + 1 ) <NEWLINE> visited [ 1 ] = True <NEWLINE> l = [ 1 ] <NEWLINE> i = a [ 0 ] <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> if visited [ i ] : break <NEWLINE> visited [ i ] = True <NEWLINE> l . append ( i ) <NEWLINE> i = a [ i - 1 ] <NEWLINE> <NL> <DEDENT> d = - 1 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> if l [ x ] == i : <NEWLINE> <INDENT> d = x <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> f = l [ : d ] <NEWLINE> b = l [ d : ] <NEWLINE> <NL> if len ( f ) == 0 : <NEWLINE> <INDENT> print ( b [ k % len ( b ) ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( b ) == 0 : <NEWLINE> <INDENT> print ( f [ k % len ( f ) ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if k <= d : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> k -= len ( f ) <NEWLINE> print ( b [ k % len ( b ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( i + i * ( n // i ) ) * ( n // i ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> S = 0 <NEWLINE> C = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] == C [ - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> C . append ( A [ i ] ) <NEWLINE> <DEDENT> A = C <NEWLINE> if len ( C ) == 1 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> return <NEWLINE> <DEDENT> C = [ ( A [ 0 ] , <STRING> if A [ 0 ] < A [ 1 ] else <STRING> ) ] <NEWLINE> <NL> for i in range ( 1 , len ( A ) - 1 ) : <NEWLINE> <INDENT> if C [ - 1 ] == A [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ i - 1 ] > A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> C . append ( ( A [ i ] , <STRING> ) ) <NEWLINE> <DEDENT> elif A [ i - 1 ] < A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> C . append ( ( A [ i ] , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> if C [ - 1 ] [ 0 ] != A [ - 1 ] : <NEWLINE> <INDENT> C . append ( ( A [ - 1 ] , <STRING> if A [ - 1 ] > C [ - 1 ] [ 0 ] else <STRING> ) ) <NEWLINE> <NL> <DEDENT> S = 0 <NEWLINE> m = 1000 <NEWLINE> if C and C [ 0 ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> C = C [ 1 : ] <NEWLINE> <DEDENT> if C and C [ - 1 ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> C = C [ : - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for p , s in C : <NEWLINE> <INDENT> m_ = m <NEWLINE> S_ = S <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> m += p * S <NEWLINE> S = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> m -= ( m_ // p ) * p <NEWLINE> S = ( m_ // p ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL> <DEDENT> solve ( N , A ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> rs = { } <NEWLINE> gs = { } <NEWLINE> bs = { } <NEWLINE> <NL> for i , e in enumerate ( s ) : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> rs [ i ] = <STRING> <NEWLINE> <DEDENT> if e == <STRING> : <NEWLINE> <INDENT> gs [ i ] = <STRING> <NEWLINE> <DEDENT> if e == <STRING> : <NEWLINE> <INDENT> bs [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> saidai = len ( rs ) * len ( gs ) * len ( bs ) <NEWLINE> if saidai == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = max ( bs . keys ( ) ) <NEWLINE> b = min ( bs . keys ( ) ) <NEWLINE> for i in rs . keys ( ) : <NEWLINE> <INDENT> for j in gs . keys ( ) : <NEWLINE> <INDENT> mi = i if i < j else j <NEWLINE> ma = j if i < j else i <NEWLINE> p = [ mi - ( ma - mi ) , mi + ( ma - mi ) / 2 , ma + ( ma - mi ) ] <NEWLINE> for e in p : <NEWLINE> <INDENT> if e % 1 != 0 or e < b or e > a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if e in bs : <NEWLINE> <INDENT> saidai -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( saidai ) ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> max_fare = 99000001 <NEWLINE> def dijkstra ( start , goal ) : <NEWLINE> <INDENT> unvisited = [ i for i in range ( n ) ] <NEWLINE> fare = [ max_fare ] * n <NEWLINE> fare [ start ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> min_fare = max_fare <NEWLINE> for i in unvisited : <NEWLINE> <INDENT> f = fare [ i ] <NEWLINE> if f < min_fare : <NEWLINE> <INDENT> min_fare = f <NEWLINE> u = i <NEWLINE> <NL> <DEDENT> <DEDENT> if u == goal : <NEWLINE> <INDENT> return min_fare <NEWLINE> <DEDENT> elif min_fare == max_fare : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> unvisited . remove ( u ) <NEWLINE> <NL> for v , f in adj [ u ] : <NEWLINE> <INDENT> if v in unvisited : <NEWLINE> <INDENT> fare [ v ] = min ( min_fare + f , fare [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> file_input = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , k = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> if n == 0 and k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> adj = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> line = file_input . readline ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> a , b = map ( int , line [ 2 : ] . split ( ) ) <NEWLINE> print ( dijkstra ( a - 1 , b - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , d , e = map ( int , line [ 2 : ] . split ( ) ) <NEWLINE> adj [ c - 1 ] . append ( ( d - 1 , e ) ) <NEWLINE> adj [ d - 1 ] . append ( ( c - 1 , e ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
from heapq import heappush , heappop , heapify <NEWLINE> <NL> <NL> def dijkstra ( s , t , links ) : <NEWLINE> <INDENT> heap = list ( links [ s ] ) <NEWLINE> heapify ( heap ) <NEWLINE> visited = set ( ) <NEWLINE> while heap : <NEWLINE> <INDENT> fare , node = heappop ( heap ) <NEWLINE> if node == t : <NEWLINE> <INDENT> return fare <NEWLINE> <DEDENT> if node in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( node ) <NEWLINE> for fare2 , node2 in links [ node ] : <NEWLINE> <INDENT> if node2 not in visited : <NEWLINE> <INDENT> heappush ( heap , ( fare + fare2 , node2 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> links = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> o = map ( int , input ( ) . split ( ) ) <NEWLINE> if next ( o ) : <NEWLINE> <INDENT> c , d , e = o <NEWLINE> c , d = c - 1 , d - 1 <NEWLINE> links [ c ] . add ( ( e , d ) ) <NEWLINE> links [ d ] . add ( ( e , c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = o <NEWLINE> print ( dijkstra ( a - 1 , b - 1 , links ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_int = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> squ = 0 <NEWLINE> num = 10 ** 9 + 7 <NEWLINE> <NL> a_sum = 0 <NEWLINE> for i_sum in range ( 1 , n ) : <NEWLINE> <INDENT> a_sum += a_int [ i_sum ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> squ += a_int [ i ] * a_sum <NEWLINE> a_sum -= a_int [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = squ % num <NEWLINE> print ( ans ) <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> <NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def nCr ( n , r ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> num = functools . reduce ( lambda x , y : x * y % mod , range ( n , n - r , - 1 ) ) <NEWLINE> den = functools . reduce ( lambda x , y : x * y % mod , map ( lambda x : pow ( x , mod - 2 , mod ) , range ( 1 , r + 1 ) ) ) <NEWLINE> return num * den % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( ( pow ( 2 , n , mod ) - nCr ( n , a ) - nCr ( n , b ) - 1 ) % mod ) <NEWLINE>
import sys <NEWLINE> import heapq , math <NEWLINE> from itertools import zip_longest , permutations , combinations , combinations_with_replacement <NEWLINE> from itertools import accumulate , dropwhile , takewhile , groupby <NEWLINE> from functools import lru_cache <NEWLINE> from copy import deepcopy <NEWLINE> <NL> N , S = [ int ( input ( ) ) , int ( input ( ) ) ] <NEWLINE> <NL> <NL> def solve1 ( ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if ok ( i , N , S ) : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return 1 << 60 <NEWLINE> <NL> <NL> <DEDENT> def solve2 ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> ret = 1 << 60 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> b = ( N - S ) // i + 1 <NEWLINE> if ok ( b , N , S ) : <NEWLINE> <INDENT> ret = min ( ret , b ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def ok ( b , N , S ) : <NEWLINE> <INDENT> if b <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> s , n = 0 , N <NEWLINE> while n > 0 : <NEWLINE> <INDENT> s += n % b <NEWLINE> n //= b <NEWLINE> <NL> <DEDENT> return s == S <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> if S == N : <NEWLINE> <INDENT> return N + 1 <NEWLINE> <DEDENT> ret = min ( solve1 ( ) , solve2 ( ) ) <NEWLINE> return ret if ret != 1 << 60 else - 1 <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for x in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> t = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if t <= N : <NEWLINE> <INDENT> dp [ t ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( dp [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> l = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> s = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * l [ b ] <NEWLINE> l [ c ] += l [ b ] <NEWLINE> l [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ac , wa , tle , re = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if inp == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif inp == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif inp == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ac , wa , tle , re ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = a <NEWLINE> q = b <NEWLINE> while True : <NEWLINE> <INDENT> r = p % q <NEWLINE> if r == 0 : <NEWLINE> <INDENT> x = q <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = q <NEWLINE> q = r <NEWLINE> <DEDENT> <DEDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a * i % b == 0 : <NEWLINE> <INDENT> y = a * i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( x , y ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import math <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 20000000 ) <NEWLINE> s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> k = 1 <NEWLINE> a = defaultdict ( int ) <NEWLINE> a [ 0 ] += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + int ( s [ i ] ) * k ) % 2019 <NEWLINE> k *= 10 <NEWLINE> k %= 2019 <NEWLINE> a [ dp [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in a . keys ( ) : <NEWLINE> <INDENT> ans += a [ i ] * ( a [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> <NL> s . sort ( ) <NEWLINE> <NL> ans = sum ( s ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in s : <NEWLINE> <INDENT> if x % 10 != 0 : <NEWLINE> <INDENT> ans -= x <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> <NL> <NL> A = list ( A ) <NEWLINE> <NL> hashmap = { } <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> hashmap [ A [ i ] ] = hashmap . get ( A [ i ] , [ 0 , A [ i ] ] ) <NEWLINE> hashmap [ A [ i ] ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B in hashmap : <NEWLINE> <INDENT> num = hashmap [ B ] [ 0 ] <NEWLINE> del hashmap [ B ] <NEWLINE> s -= num * B <NEWLINE> s += num * C <NEWLINE> <NL> hashmap [ C ] = hashmap . get ( C , [ 0 , C ] ) <NEWLINE> hashmap [ C ] [ 0 ] += num <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> A_list . sort ( ) <NEWLINE> <NL> <NL> dp = [ 0 for item in range ( A_list [ - 1 ] + 1 ) ] <NEWLINE> for item in A_list : <NEWLINE> <NL> <INDENT> temp = item <NEWLINE> while temp <= A_list [ - 1 ] : <NEWLINE> <INDENT> dp [ temp ] += 1 <NEWLINE> temp += item <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for item in A_list : <NEWLINE> <INDENT> if dp [ item ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
s_max = [ 0 ] <NEWLINE> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> s += ( 10 - j - 1 ) * ( i - j ) <NEWLINE> <DEDENT> s_max . append ( s ) <NEWLINE> <NL> <DEDENT> def check ( u , r , s , m ) : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> return s == 0 <NEWLINE> <DEDENT> n = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> n *= 2 <NEWLINE> if u [ i ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> if ( n , r , s ) in m : <NEWLINE> <INDENT> return m [ ( n , r , s ) ] <NEWLINE> <DEDENT> if s < 0 or s > s_max [ r ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if not u [ i ] : <NEWLINE> <INDENT> u [ i ] = True <NEWLINE> ans += check ( u , r - 1 , s - i * r , m ) <NEWLINE> u [ i ] = False <NEWLINE> <DEDENT> <DEDENT> m [ ( n , r , s ) ] = ans <NEWLINE> return m [ ( n , r , s ) ] <NEWLINE> <NL> <DEDENT> memo = { } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> used = [ False for i in range ( 10 ) ] <NEWLINE> ans = check ( used , n , s , memo ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> abacus = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> <DEDENT> ans = [ [ <STRING> for c in range ( 5 ) ] for r in range ( 8 ) ] <NEWLINE> <NL> first = True <NEWLINE> while True : <NEWLINE> <INDENT> try : n = list ( input ( ) ) <NEWLINE> except : break <NEWLINE> for i in range ( 5 - len ( n ) ) : <NEWLINE> <INDENT> for r in range ( 8 ) : ans [ r ] [ i ] = abacus [ r ] [ 0 ] <NEWLINE> <DEDENT> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> for r in range ( 8 ) : ans [ r ] [ 5 - len ( n ) + i ] = abacus [ r ] [ int ( n [ i ] ) ] <NEWLINE> <DEDENT> if first : first = False <NEWLINE> else : print ( ) <NEWLINE> for r in range ( 8 ) : print ( * ans [ r ] , sep = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> list = [ 0 for i in range ( n + 1 ) ] <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> w = 0 <NEWLINE> list [ 0 ] = max ( r , w ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> list [ i + 1 ] = max ( r , w ) <NEWLINE> <DEDENT> print ( min ( list ) ) <NEWLINE>
N = 1000001 <NEWLINE> a = [ 0 ] * N <NEWLINE> input ( ) <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> a [ int ( x ) ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , N , i ) : <NEWLINE> <INDENT> a [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a . count ( 1 ) ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> re = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> v = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> re += gcd ( v , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( re ) <NEWLINE>
import random <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> j = 27 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> c = 26 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> c -= 1 <NEWLINE> if C [ j - 1 ] > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if j == 1 : <NEWLINE> <INDENT> j = 27 <NEWLINE> <DEDENT> <DEDENT> print ( j ) <NEWLINE> if j == 1 : <NEWLINE> <INDENT> j = 27 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> <NL> for j in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> c += A [ j ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> c = c - A [ i ] <NEWLINE> b += A [ i ] * c <NEWLINE> <NL> <DEDENT> print ( b % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from math import floor <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B <= N : <NEWLINE> <INDENT> mx = floor ( A * ( B - 1 ) / B ) - A * floor ( ( B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mx = floor ( A * N / B ) - A * floor ( N / B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( mx ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d . get ( j , 0 ) ) <NEWLINE> <DEDENT>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> if ( k not in l ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( d == 0 ) : <NEWLINE> <INDENT> if ( k - c not in l ) : <NEWLINE> <INDENT> print ( k - c ) <NEWLINE> break <NEWLINE> <DEDENT> if ( k + c not in l ) : <NEWLINE> <INDENT> print ( k + c ) <NEWLINE> break <NEWLINE> <DEDENT> c = c + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <NL> t = 0 <NEWLINE> <NL> x = 1 <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> <NL> <NL> for i in s : <NEWLINE> <INDENT> t += int ( i ) * x <NEWLINE> t %= 2019 <NEWLINE> x *= 10 <NEWLINE> x %= 2019 <NEWLINE> cnt [ t ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
O , E = input ( ) , input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> if ( len ( O ) + len ( E ) ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> ans += O [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( x + n // x * x ) * ( n // x ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from bisect import bisect_left <NEWLINE> l . sort ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> idx = bisect_left ( l , l [ a ] + l [ b ] , lo = b ) <NEWLINE> count += idx - ( b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = [ ] <NEWLINE> s = [ ] <NEWLINE> num = [ 0 ] * N <NEWLINE> maxi = max ( a ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s . append ( 1 + i - a [ i ] ) <NEWLINE> if 1 + i + a [ i ] < N : <NEWLINE> <INDENT> num [ 1 + i + a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] >= 0 : <NEWLINE> <INDENT> count += num [ s [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from bisect import bisect_left <NEWLINE> from string import ascii_lowercase <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> dict_s = { c : [ ] for c in ascii_lowercase } <NEWLINE> for i , c in enumerate ( s * 2 ) : <NEWLINE> <INDENT> dict_s [ c ] . append ( i ) <NEWLINE> <NL> <DEDENT> for c in ascii_lowercase : <NEWLINE> <INDENT> if not dict_s [ c ] : <NEWLINE> <INDENT> del dict_s [ c ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dict_next_i = { <NEWLINE> <INDENT> c : [ dict_s [ c ] [ bisect_left ( dict_s [ c ] , i + 1 ) ] for i in range ( n ) ] <NEWLINE> for c in dict_s . keys ( ) <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL> def next_i ( i , c ) : <NEWLINE> <INDENT> return n * ( i // n ) + dict_next_i [ c ] [ i % n ] <NEWLINE> <NL> <NL> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> if not all ( c in s for c in t ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> i = - 1 <NEWLINE> for c in t : <NEWLINE> <INDENT> i = next_i ( i , c ) <NEWLINE> <DEDENT> return i + 1 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> print ( answer ( ) ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( l ) ) <NEWLINE>
from math import sqrt , ceil , pow <NEWLINE> <NL> class SieveOfAtkin : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , limit ) : <NEWLINE> <INDENT> self . limit = limit <NEWLINE> self . primes = [ ] <NEWLINE> self . sieve = [ False ] * ( self . limit + 1 ) <NEWLINE> <NL> <DEDENT> def flip ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . sieve [ prime ] = True if self . sieve [ prime ] == False else False <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def invalidate ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if self . sieve [ prime ] == True : self . sieve [ prime ] = False <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def isPrime ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . sieve [ prime ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def getPrimes ( self ) : <NEWLINE> <INDENT> testingLimit = int ( ceil ( sqrt ( self . limit ) ) ) <NEWLINE> <NL> for i in range ( testingLimit ) : <NEWLINE> <INDENT> for j in range ( testingLimit ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 4 * int ( pow ( i , 2 ) ) + int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and ( n % 12 == 1 or n % 12 == 5 ) : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = 3 * int ( pow ( i , 2 ) ) + int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and n % 12 == 7 : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = 3 * int ( pow ( i , 2 ) ) - int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and i > j and n % 12 == 11 : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 5 , testingLimit ) : <NEWLINE> <INDENT> if self . isPrime ( i ) : <NEWLINE> <INDENT> k = int ( pow ( i , 2 ) ) <NEWLINE> for j in range ( k , self . limit , k ) : <NEWLINE> <INDENT> self . invalidate ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> self . primes = [ 2 , 3 ] + [ x for x in range ( len ( self . sieve ) ) if self . isPrime ( x ) and x >= 5 ] <NEWLINE> return self . primes <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A = SieveOfAtkin ( 110000 ) <NEWLINE> A . getPrimes ( ) <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> if data == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = A . primes [ : data ] <NEWLINE> print ( sum ( result ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> T = list ( input ( ) . strip ( ) ) <NEWLINE> <NL> <NL> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( T ) == 1 : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> elif T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> T [ 1 ] = <STRING> <NEWLINE> <DEDENT> elif T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> points = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> cnt [ ( 0 , 0 ) ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ ( points [ i ] [ 0 ] - points [ j ] [ 0 ] , points [ i ] [ 1 ] - points [ j ] [ 1 ] ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = n - max ( cnt . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> C = list ( C ) <NEWLINE> <NL> d = { 0 : 0 } <NEWLINE> tot = 0 <NEWLINE> <NL> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> tot += 1 <NEWLINE> <DEDENT> d [ i + 1 ] = tot <NEWLINE> <NL> <DEDENT> ans = tot - d [ tot ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Plist = [ ] <NEWLINE> i = 1 <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> while i <= N : <NEWLINE> <INDENT> k = 1 <NEWLINE> if i % 3 == 0 : <NEWLINE> <INDENT> Plist . append ( i ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> Plist . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i // k > 1 and k >= 0 : <NEWLINE> <INDENT> if i // k % 10 == 3 : <NEWLINE> <INDENT> Plist . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k * 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , Plist ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> AA = sorted ( A , key = lambda x : - abs ( x ) ) <NEWLINE> <NL> nega1 = [ ] <NEWLINE> posi1 = [ ] <NEWLINE> for a in AA [ : k ] : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> nega1 . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posi1 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> nega2 = [ ] <NEWLINE> posi2 = [ ] <NEWLINE> for a in AA [ k : ] : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> nega2 . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posi2 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if all ( a < 0 for a in A ) and k % 2 == 1 : <NEWLINE> <INDENT> AA = sorted ( A , key = lambda x : abs ( x ) ) <NEWLINE> nega1 = [ ] <NEWLINE> posi1 = [ ] <NEWLINE> for a in AA [ : k ] : <NEWLINE> <INDENT> nega1 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif n == k : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> elif len ( nega1 ) % 2 != 0 : <NEWLINE> <INDENT> if posi1 and nega2 and posi2 : <NEWLINE> <INDENT> if abs ( nega1 [ - 1 ] * nega2 [ 0 ] ) < abs ( posi1 [ - 1 ] * posi2 [ 0 ] ) : <NEWLINE> <INDENT> del nega1 [ - 1 ] <NEWLINE> nega1 . append ( posi2 [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del posi1 [ - 1 ] <NEWLINE> posi1 . append ( nega2 [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> elif not posi1 or not nega2 : <NEWLINE> <INDENT> del nega1 [ - 1 ] <NEWLINE> nega1 . append ( posi2 [ 0 ] ) <NEWLINE> <DEDENT> elif not posi2 : <NEWLINE> <INDENT> del posi1 [ - 1 ] <NEWLINE> posi1 . append ( nega2 [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = 1 <NEWLINE> for m in posi1 : <NEWLINE> <INDENT> a = ( a * m ) % MOD <NEWLINE> <DEDENT> for p in nega1 : <NEWLINE> <INDENT> a = ( a * p ) % MOD <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
s = set ( open ( 0 ) ) <NEWLINE> print ( len ( s ) - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pr = 1 <NEWLINE> t = [ ] <NEWLINE> for i in range ( len ( l ) - k ) : <NEWLINE> <INDENT> if l [ i ] < l [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> n1 = X . count ( <STRING> ) <NEWLINE> Xn = int ( X , 2 ) <NEWLINE> <NL> Xms = ( Xn % ( n1 - 1 ) ) if n1 > 1 else 0 <NEWLINE> Xml = Xn % ( n1 + 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> xi = 0 <NEWLINE> if X [ i ] == <STRING> and n1 == 1 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <INDENT> xi = ( Xms - pow ( 2 , N - i - 1 , n1 - 1 ) ) % ( n1 - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi = ( Xml + pow ( 2 , N - i - 1 , n1 + 1 ) ) % ( n1 + 1 ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> while xi != 0 : <NEWLINE> <INDENT> xi %= bin ( xi ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> plus . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ok = False <NEWLINE> if len ( plus ) > 0 : <NEWLINE> <INDENT> if n == k : <NEWLINE> <INDENT> ok = ( len ( minus ) % 2 == 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ok = ( k % 2 == 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> if not ok : <NEWLINE> <INDENT> A . sort ( key = abs ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> plus . sort ( ) <NEWLINE> minus . sort ( reverse = True ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans *= plus . pop ( ) <NEWLINE> <DEDENT> P = [ ] <NEWLINE> while len ( plus ) >= 2 : <NEWLINE> <INDENT> P . append ( ( plus . pop ( ) ) * ( plus . pop ( ) ) ) <NEWLINE> <DEDENT> while len ( minus ) >= 2 : <NEWLINE> <INDENT> P . append ( ( minus . pop ( ) ) * ( minus . pop ( ) ) ) <NEWLINE> <DEDENT> P . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> ans *= P [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 0 , N - K ) : <NEWLINE> <COMMENT> <NL> <INDENT> prev_score = As [ i ] <NEWLINE> score = As [ K + i ] <NEWLINE> <COMMENT> <NL> if prev_score < score : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> k = min ( n , b - 1 ) <NEWLINE> print ( math . floor ( a * k / b ) - a * math . floor ( k / b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v <= N : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ku = k <NEWLINE> a = [ 0 ] * ku <NEWLINE> c = [ 0 ] * ku <NEWLINE> b = [ 0 ] * ku <NEWLINE> <NL> for i in range ( ku ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> b [ i ] = 7 % k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = ( b [ i - 1 ] * 10 + 7 ) % k <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in b : <NEWLINE> <INDENT> print ( b . index ( 0 ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> DP = [ 0 for i in range ( n + 2 ) ] <NEWLINE> DP [ n + 1 ] = 0 <NEWLINE> <NL> num = 1 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> DP [ i ] = ( DP [ i + 1 ] + int ( s [ i ] ) * ( num ) ) % mod <NEWLINE> num = num * 10 % mod <NEWLINE> <DEDENT> DP . pop ( - 1 ) <NEWLINE> <NL> arr = defaultdict ( int ) <NEWLINE> for dp in DP : <NEWLINE> <INDENT> arr [ dp ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in arr . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
score = [ 1800 , 1600 , 1400 , 1200 , 1000 , 800 , 600 , 400 ] <NEWLINE> ranks = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> while ( x < score [ i ] ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ranks [ i ] ) <NEWLINE>
N = int ( input ( ) ) ; a = [ 0 ] * 10_001 ; X = Y = Z = range ( 1 , 101 ) <NEWLINE> for x in X : <NEWLINE> <INDENT> for y in Y : <NEWLINE> <INDENT> for z in Z : <NEWLINE> <INDENT> if ( n : = x * x + y * y + z * z + x * y + y * z + z * x ) < N + 1 : a [ n - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a [ : N ] , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> a = i_list ( ) <NEWLINE> <NL> k = [ 0 ] <NEWLINE> for i in range ( 2 * 10 ** 5 ) : <NEWLINE> <INDENT> k . append ( k [ i ] + ( i + 1 ) ) <NEWLINE> <DEDENT> t = a . copy ( ) <NEWLINE> t . sort ( ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> m = [ 0 ] * n <NEWLINE> <NL> for i , n in itertools . groupby ( t ) : <NEWLINE> <INDENT> l = len ( list ( n ) ) <NEWLINE> s += k [ l - 1 ] <NEWLINE> if l > 1 : <NEWLINE> <INDENT> m [ i - 1 ] = k [ l - 2 ] - k [ l - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( s + m [ i - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = 1000000007 <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * s <NEWLINE> s += A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % m ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> r = b % a <NEWLINE> <NL> if r == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( a , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <NL> <NL> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( x , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def slove ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> abc = <STRING> <NEWLINE> count = 0 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> k = n % 26 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> n = n // 26 <NEWLINE> ans = abc [ k ] + ans <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> slove ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S ^= a [ i ] <NEWLINE> <NL> <DEDENT> Ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( S ^ a [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( N ) ] <NEWLINE> b = set ( a ) <NEWLINE> print ( len ( b ) ) <NEWLINE>
<NL> o = list ( ) <NEWLINE> top = - 1 <NEWLINE> for s in input ( ) . split ( ) : <NEWLINE> <INDENT> if s . isdigit ( ) : <NEWLINE> <INDENT> o . append ( int ( s ) ) <NEWLINE> top += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s is <STRING> : <NEWLINE> <INDENT> n = o [ top ] + o [ top - 1 ] <NEWLINE> o . pop ( top ) <NEWLINE> top -= 1 <NEWLINE> o . pop ( top ) <NEWLINE> top -= 1 <NEWLINE> o . append ( n ) <NEWLINE> top += 1 <NEWLINE> <DEDENT> if s is <STRING> : <NEWLINE> <INDENT> n = o [ top - 1 ] - o [ top ] <NEWLINE> o . pop ( top ) <NEWLINE> top -= 1 <NEWLINE> o . pop ( top ) <NEWLINE> top -= 1 <NEWLINE> o . append ( n ) <NEWLINE> top += 1 <NEWLINE> <DEDENT> if s is <STRING> : <NEWLINE> <INDENT> n = o [ top ] * o [ top - 1 ] <NEWLINE> o . pop ( top ) <NEWLINE> top -= 1 <NEWLINE> o . pop ( top ) <NEWLINE> top -= 1 <NEWLINE> o . append ( n ) <NEWLINE> top += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( o [ 0 ] ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] * a <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> A = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.1415926535897932384626 <NEWLINE> print ( pi * r * r , 2 * pi * r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for k in range ( 1 , N + 2 ) : <NEWLINE> <INDENT> sn = k - 1 <NEWLINE> if k * sn != 2 * N : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( k ) <NEWLINE> s = [ [ 0 ] * sn for _ in range ( sn ) ] <NEWLINE> for i in range ( sn ) : <NEWLINE> <INDENT> s [ i ] [ i ] = s [ i - 1 ] [ i - 1 ] + ( i + 1 ) <NEWLINE> for j in range ( i + 1 , sn ) : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j - 1 ] + j <NEWLINE> s [ j ] [ i ] = s [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> s . append ( [ s [ i ] [ i ] for i in range ( sn ) ] ) <NEWLINE> for x in s : <NEWLINE> <INDENT> print ( sn , <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = list ( s ) . count ( <STRING> ) <NEWLINE> g = list ( s ) . count ( <STRING> ) <NEWLINE> b = list ( s ) . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if ( k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> l = a [ left : mid ] + [ float ( <STRING> ) ] <NEWLINE> r = a [ mid : right ] + [ float ( <STRING> ) ] <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if l [ i ] <= r [ j ] : <NEWLINE> <INDENT> a [ k ] = l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = r [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def mergeSort ( a , left , right , x ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( a , left , mid , x ) <NEWLINE> mergeSort ( a , mid , right , x ) <NEWLINE> x [ 0 ] += merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] <NEWLINE> mergeSort ( s , 0 , n , x ) <NEWLINE> print ( * s ) <NEWLINE> print ( x [ 0 ] ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ ] <NEWLINE> for i in range ( len ( A ) + 1 ) : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> count [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in count : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dpList = [ ] <NEWLINE> if ( n , m ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> row = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dpList . append ( row ) <NEWLINE> <DEDENT> dpList = sorted ( dpList , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if m >= dpList [ i ] [ 0 ] : <NEWLINE> <INDENT> m -= dpList [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += ( dpList [ i ] [ 0 ] - m ) * dpList [ i ] [ 1 ] <NEWLINE> m = 0 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s ^= A [ i ] <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> si = s <NEWLINE> si ^= A [ i ] <NEWLINE> print ( si ) <NEWLINE> <DEDENT>
def check ( st ) : <NEWLINE> <INDENT> for d in range ( len ( st ) ) : <NEWLINE> <INDENT> if st [ d ] == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> num = int ( input ( ) ) <NEWLINE> str = <STRING> <NEWLINE> for d in range ( 3 , num + 1 ) : <NEWLINE> <INDENT> s = <STRING> % ( d ) <NEWLINE> if d % 3 == 0 or check ( s ) : <NEWLINE> <INDENT> str += <STRING> % ( d ) <NEWLINE> <DEDENT> <DEDENT> print ( str ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> li . sort ( ) <NEWLINE> if li [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in li [ : : - 1 ] : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = list ( ) <NEWLINE> if K >= N : <NEWLINE> <INDENT> sums = 0 <NEWLINE> c = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sums += L [ i ] <NEWLINE> sums %= K <NEWLINE> a = ( sums - i - 1 ) % K <NEWLINE> if a in c : <NEWLINE> <INDENT> c [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> ans += ( c [ i ] - 1 ) * c [ i ] // 2 <NEWLINE> <DEDENT> if 0 in c : <NEWLINE> <INDENT> print ( ans + c [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> c = [ 0 ] * K <NEWLINE> sums = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sums += L [ i ] <NEWLINE> sums %= K <NEWLINE> a = ( sums - i - 1 ) % K <NEWLINE> R . append ( a ) <NEWLINE> <DEDENT> for i in range ( K - 1 ) : <NEWLINE> <INDENT> c [ R [ i ] ] += 1 <NEWLINE> <DEDENT> ans += c [ 0 ] <NEWLINE> c [ R [ K - 1 ] ] += 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < N - K : <NEWLINE> <INDENT> ans += c [ R [ i ] ] - 1 <NEWLINE> c [ R [ i ] ] -= 1 <NEWLINE> c [ R [ i + K ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += c [ R [ i ] ] - 1 <NEWLINE> c [ R [ i ] ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( list ) <NEWLINE> <NL> p = 1 <NEWLINE> root = [ ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d [ p ] . append ( i ) <NEWLINE> root . append ( p ) <NEWLINE> if len ( d [ p ] ) == 2 : <NEWLINE> <INDENT> s = d [ p ] [ 0 ] <NEWLINE> e = i <NEWLINE> n = ( K - s ) % ( e - s ) <NEWLINE> p = root [ s + n ] <NEWLINE> break <NEWLINE> <DEDENT> p = A [ p - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in d : <NEWLINE> <INDENT> if i [ 0 ] == i [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = 998244353 <NEWLINE> <NL> start = ( M * pow ( M - 1 , N - 1 , P ) ) % P <NEWLINE> <NL> <NL> <NL> if N >= 2 : <NEWLINE> <INDENT> fac = [ 0 ] * N <NEWLINE> finv = [ 0 ] * N <NEWLINE> inv = [ 0 ] * N <NEWLINE> fac [ 0 ] = 1 <NEWLINE> fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = 1 <NEWLINE> finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> fac [ i ] = ( fac [ i - 1 ] * i ) % P <NEWLINE> inv [ i ] = P - ( inv [ P % i ] * ( P // i ) ) % P <NEWLINE> finv [ i ] = ( finv [ i - 1 ] * inv [ i ] ) % P <NEWLINE> <NL> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % P ) % P <NEWLINE> <NL> <NL> <NL> <DEDENT> comp = 0 <NEWLINE> last = ( N - 1 ) - K <COMMENT> <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> comp = ( comp + comb ( N - 1 , i ) * pow ( M - 1 , ( N - 1 ) - i , P ) ) % P <NEWLINE> <DEDENT> comp = ( comp * M ) % P <NEWLINE> <NL> print ( ( start + comp ) % P ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( M % P ) <NEWLINE> <DEDENT>
import fractions <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res , ans = [ ] , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res . append ( abs ( a [ i ] - x ) ) <NEWLINE> <DEDENT> if len ( res ) > 3 : <NEWLINE> <INDENT> D = fractions . gcd ( res [ 0 ] , res [ 1 ] ) <NEWLINE> for j in range ( 2 , len ( res ) - 2 ) : <NEWLINE> <INDENT> D = fractions . gcd ( D , res [ j ] ) <NEWLINE> <DEDENT> ans = D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> collect_dict = dict ( collections . Counter ( a ) ) <NEWLINE> <NL> now = sum ( a ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in collect_dict . keys ( ) : <NEWLINE> <INDENT> ans . append ( now ) <NEWLINE> continue <NEWLINE> <DEDENT> now -= collect_dict [ b ] * b <NEWLINE> tmp = collect_dict [ b ] <NEWLINE> collect_dict . pop ( b ) <NEWLINE> if c not in collect_dict . keys ( ) : <NEWLINE> <INDENT> collect_dict [ c ] = 0 <NEWLINE> <DEDENT> collect_dict [ c ] += tmp <NEWLINE> now += c * tmp <NEWLINE> ans . append ( now ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> fr = [ 0 ] * n <NEWLINE> uf_fr = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf_fr . union ( a - 1 , b - 1 ) <NEWLINE> fr [ a - 1 ] += 1 <NEWLINE> fr [ b - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf_fr . find ( c - 1 ) == uf_fr . find ( d - 1 ) : <NEWLINE> <INDENT> fr [ c - 1 ] += 1 <NEWLINE> fr [ d - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans_list . append ( uf_fr . size ( i ) - fr [ i ] - 1 ) <NEWLINE> <DEDENT> print ( * ans_list ) <NEWLINE>
def m ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> times = 1 <NEWLINE> c = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if times <= 10 ** 18 and c < N : <NEWLINE> <INDENT> times *= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> if times > 10 ** 18 : <NEWLINE> <INDENT> times = - 1 <NEWLINE> <DEDENT> if 0 in A : <NEWLINE> <INDENT> times = 0 <NEWLINE> <DEDENT> print ( times ) <NEWLINE> <DEDENT> m ( ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> str = input ( ) <NEWLINE> list . append ( str ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( list ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ara = [ 0 ] <NEWLINE> ara += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> vis = [ ] <NEWLINE> taken = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> while taken [ now ] == 0 : <NEWLINE> <INDENT> vis . append ( now ) <NEWLINE> taken [ now ] = 1 <NEWLINE> now = ara [ now ] <NEWLINE> <NL> <DEDENT> cycleLen = len ( vis ) - vis . index ( now ) <NEWLINE> <NL> if k < vis . index ( now ) : <NEWLINE> <INDENT> print ( vis [ k ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> k -= vis . index ( now ) <NEWLINE> k %= cycleLen <NEWLINE> <NL> print ( vis [ k + vis . index ( now ) ] ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls . sort ( ) <NEWLINE> di = ls [ : ] <NEWLINE> di . append ( ls [ - 1 ] // 2 ) <NEWLINE> di . sort ( ) <NEWLINE> ind = di . index ( ls [ - 1 ] // 2 ) <NEWLINE> il , ir = - 1 , - 1 <NEWLINE> if ind > 0 : <NEWLINE> <INDENT> il = ind - 1 <NEWLINE> <DEDENT> if ind < n - 1 : <NEWLINE> <INDENT> ir = ind + 1 <NEWLINE> <DEDENT> if il < 0 or ir < 0 : <NEWLINE> <INDENT> now = max ( ir , il ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ls [ - 1 ] % 2 == 0 : <NEWLINE> <INDENT> if abs ( ls [ - 1 ] // 2 - di [ ir ] ) < abs ( ls [ - 1 ] // 2 - di [ il ] ) : <NEWLINE> <INDENT> now = di [ ir ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = di [ il ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if min ( abs ( ls [ - 1 ] // 2 - di [ ir ] ) , abs ( ls [ - 1 ] // 2 + 1 - di [ ir ] ) ) < min ( abs ( ls [ - 1 ] // 2 - di [ il ] ) , abs ( ls [ - 1 ] // 2 + 1 - di [ il ] ) ) : <NEWLINE> <INDENT> now = di [ ir ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = di [ il ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ls [ - 1 ] , now ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> from collections import namedtuple <NEWLINE> from itertools import permutations <NEWLINE> <NL> <NL> def solve ( items ) : <NEWLINE> <INDENT> total_weight = 0 <NEWLINE> for i in items : <NEWLINE> <INDENT> total_weight += i . w <NEWLINE> <DEDENT> best_ans = [ ] <NEWLINE> best_gp = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> for perm in permutations ( items ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> squashed = False <NEWLINE> cw = 0 <NEWLINE> gp = 0 <NEWLINE> n = len ( items ) <NEWLINE> for p in perm : <NEWLINE> <INDENT> if p . s < cw : <NEWLINE> <INDENT> squashed = True <NEWLINE> break <NEWLINE> <DEDENT> cw += p . w <NEWLINE> ans . append ( p . name ) <NEWLINE> gp += n * p . w <NEWLINE> n -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if not squashed : <NEWLINE> <INDENT> gp /= total_weight <NEWLINE> if gp < best_gp : <NEWLINE> <INDENT> best_gp = gp <NEWLINE> best_ans = ans [ : ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> best_ans . reverse ( ) <NEWLINE> return best_ans <NEWLINE> <NL> <NL> <DEDENT> def solve2 ( items ) : <NEWLINE> <INDENT> items . sort ( key = lambda x : x . w , reverse = True ) <NEWLINE> ans = [ ] <NEWLINE> while items : <NEWLINE> <INDENT> total_weight = 0 <NEWLINE> for i in items : <NEWLINE> <INDENT> total_weight += i . w <NEWLINE> <DEDENT> cap = [ x . s - total_weight + x . w for x in items ] <NEWLINE> for i in range ( len ( items ) ) : <NEWLINE> <INDENT> if cap [ i ] >= 0 : <NEWLINE> <INDENT> ans . append ( items [ i ] . name ) <NEWLINE> items . pop ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> item = namedtuple ( <STRING> , [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> items = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> name , w , s = input ( ) . split ( ) <NEWLINE> items . append ( item ( name , int ( w ) , int ( s ) ) ) <NEWLINE> <DEDENT> result = solve2 ( items ) <NEWLINE> print ( <STRING> . join ( result ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
x , k , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sign = 0 <NEWLINE> if x != 0 : <NEWLINE> <INDENT> sign = int ( x / abs ( x ) ) <NEWLINE> <NL> <DEDENT> if ( abs ( x ) // d ) < k : <NEWLINE> <INDENT> tmp = x - sign * d * ( abs ( x ) // d ) <NEWLINE> <COMMENT> <NL> if ( k - ( abs ( x ) // d ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( tmp + d ) , abs ( tmp - d ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - sign * d * k ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def func ( z , c ) : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> z = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = z % c <NEWLINE> <DEDENT> a = bin ( z ) <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> return z , b <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> s0 = int ( x , 2 ) % ( c + 1 ) <NEWLINE> if c <= 1 : <NEWLINE> <INDENT> s1 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 = int ( x , 2 ) % ( c - 1 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sw = 0 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> d = c + 1 <NEWLINE> z = ( s0 + pow ( 2 , n - i - 1 , d ) ) % d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = c - 1 <NEWLINE> if d == 0 : <NEWLINE> <INDENT> z = 0 <NEWLINE> sw = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = ( s1 - pow ( 2 , n - i - 1 , d ) ) % d <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> p = bin ( z ) <NEWLINE> e = 0 <NEWLINE> for A in str ( p ) : <NEWLINE> <INDENT> if A == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> <DEDENT> d = e <NEWLINE> if sw == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while z : <NEWLINE> <INDENT> z , d = func ( z , d ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import random <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 ] * 26 <NEWLINE> ans = [ ] <NEWLINE> numans = 0 <NEWLINE> s = [ ] <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> num1 = 1 <NEWLINE> num2 = - ( 10 ** 100 ) <NEWLINE> num3 = [ 0 ] * 26 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> num3 [ j ] = - 1 * ( ( i - num [ j ] ) * c [ j ] ) <NEWLINE> <DEDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> num5 = s [ i - 1 ] [ j ] - num3 [ j ] <NEWLINE> if num5 > num2 : <NEWLINE> <INDENT> num1 = j + 1 <NEWLINE> num2 = num5 <NEWLINE> <DEDENT> <DEDENT> ans . append ( num1 ) <NEWLINE> numans += num2 + s [ i - 1 ] [ num1 - 1 ] <NEWLINE> num [ num1 - 1 ] = i <NEWLINE> <DEDENT> def sco ( n1 , n2 , n3 ) : <NEWLINE> <INDENT> n0 = 0 <NEWLINE> n01 = [ 0 ] * 26 <NEWLINE> old = ans [ n1 ] <NEWLINE> ans [ n1 ] = n2 <NEWLINE> for k in range ( n3 ) : <NEWLINE> <INDENT> n0 += s [ k ] [ ans [ k ] - 1 ] <NEWLINE> n01 [ ans [ k ] - 1 ] = k + 1 <NEWLINE> for l in range ( 26 ) : <NEWLINE> <INDENT> n0 -= ( k + 1 - n01 [ l ] ) * c [ l ] <NEWLINE> <DEDENT> <DEDENT> return n0 <NEWLINE> <DEDENT> for i in range ( 1400 ) : <NEWLINE> <INDENT> num6 = random . randint ( 1 , 26 ) <NEWLINE> num7 = random . randint ( 1 , 365 ) <NEWLINE> num100 = sco ( num7 - 1 , num6 , d ) <NEWLINE> if num100 > numans : <NEWLINE> <INDENT> ans [ j ] = num6 <NEWLINE> <DEDENT> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ P [ 0 ] ] <NEWLINE> for i in P [ 1 : ] : <NEWLINE> <INDENT> if i < Q [ - 1 ] : <NEWLINE> <INDENT> Q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( Q ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * ( n - r_cnt - g_cnt ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> s1 = s [ i ] <NEWLINE> s2 = s [ j ] <NEWLINE> if s1 != s2 : <NEWLINE> <INDENT> t = ( s1 , s2 ) <NEWLINE> for s3 in <STRING> : <NEWLINE> <INDENT> if s3 not in t : <NEWLINE> <INDENT> if 2 * j - i < n and s [ 2 * j - i ] == s3 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> flg = False <NEWLINE> a = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10e17 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> z = Node ( key ) <NEWLINE> y = None <NEWLINE> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> self . root = z ; <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> def pre_order ( self , node ) : <NEWLINE> <INDENT> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . left : <NEWLINE> <INDENT> self . pre_order ( node . left ) <NEWLINE> <DEDENT> if node . right : <NEWLINE> <INDENT> self . pre_order ( node . right ) <NEWLINE> <DEDENT> <DEDENT> def in_order ( self , node ) : <NEWLINE> <INDENT> if node . left : <NEWLINE> <INDENT> self . in_order ( node . left ) <NEWLINE> <DEDENT> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . right : <NEWLINE> <INDENT> self . in_order ( node . right ) <NEWLINE> <DEDENT> <DEDENT> def out ( self ) : <NEWLINE> <INDENT> self . in_order ( self . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> self . pre_order ( self . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = input ( ) . split ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( c [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . out ( ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> prices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prices = sorted ( prices ) <NEWLINE> <NL> print ( sum ( prices [ : k ] ) ) <NEWLINE>
def insertion_sort ( array , g , result ) : <NEWLINE> <INDENT> for i in range ( g , len ( array ) ) : <NEWLINE> <INDENT> v = array [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + g ] = array [ j ] <NEWLINE> j -= g <NEWLINE> result [ <STRING> ] += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def g_gene ( n ) : <NEWLINE> <INDENT> yield 1 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> x = int ( ( 3 ** i - 1 ) / 2 ) <NEWLINE> if x < n : <NEWLINE> <INDENT> yield x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise StopIteration ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def shell_sort ( array , result ) : <NEWLINE> <INDENT> result [ <STRING> ] = 0 <NEWLINE> G = list ( reversed ( list ( g_gene ( len ( array ) ) ) ) ) <NEWLINE> m = len ( G ) <NEWLINE> result [ <STRING> ] = G <NEWLINE> result [ <STRING> ] = m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertion_sort ( array , G [ i ] , result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> <DEDENT> result = { } <NEWLINE> shell_sort ( A , result ) <NEWLINE> print ( result [ <STRING> ] ) <NEWLINE> print ( <STRING> . join ( map ( str , result [ <STRING> ] ) ) ) <NEWLINE> print ( result [ <STRING> ] ) <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = [ ] <NEWLINE> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if X - i not in P : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> if X + i not in P : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> L = N * M // gcd ( N , M ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if M * i % N == 0 : <NEWLINE> <INDENT> j = M * i // N <NEWLINE> if S [ i ] != T [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( L ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> ans *= i <NEWLINE> <NL> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> S = [ _ for _ in input ( ) ] <NEWLINE> <NL> left , right = 0 , S [ 1 : ] . count ( <STRING> ) <NEWLINE> ans = left + right <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <NL> <DEDENT> ans = min ( ans , left + right ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ret = ret * a <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> start = 1 <NEWLINE> list = [ 1 ] <NEWLINE> kenti = [ 0 for i in range ( n ) ] <NEWLINE> kenti [ 0 ] = 1 <NEWLINE> <NL> zan = - 1 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> start -= 1 <NEWLINE> next = a [ start ] <NEWLINE> start = next <NEWLINE> <NL> if kenti [ start - 1 ] != 0 : <NEWLINE> <INDENT> zan = k - ( i + 1 ) <NEWLINE> inx = list . index ( start ) <NEWLINE> list = list [ inx : ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( start ) <NEWLINE> kenti [ start - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if zan == - 1 : <NEWLINE> <INDENT> print ( list [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif zan == 0 : <NEWLINE> <INDENT> print ( list [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> zan %= len ( list ) <NEWLINE> <COMMENT> <NL> <STRING> <NEWLINE> print ( list [ zan ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> ss = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = n - i - 1 <NEWLINE> s += ( a [ j ] * ss % ( 10 ** 9 + 7 ) ) <NEWLINE> s %= ( 10 ** 9 + 7 ) <NEWLINE> ss += a [ j ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> a , b , x = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> if x <= 0.5 * a * a * b : <NEWLINE> <INDENT> res = math . degrees ( math . atan ( 2 * x / ( a * b * b ) ) ) <NEWLINE> <DEDENT> elif x < a * a * b : <NEWLINE> <INDENT> res = math . degrees ( math . atan ( a / ( 2 * ( b - x / a ** 2 ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 90.0 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> d = [ None ] * n <NEWLINE> def bfs ( u ) : <NEWLINE> <INDENT> queue = deque ( [ u ] ) <NEWLINE> d [ u ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = d [ v ] + 1 <NEWLINE> queue . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> bfs ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt - 1 ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> alist . sort ( ) <NEWLINE> <NL> hurui = [ 0 ] * ( alist [ - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , alist [ - 1 ] // alist [ i ] + 1 ) : <NEWLINE> <INDENT> hurui [ alist [ i ] * j ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if hurui [ alist [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( H == 0 ) & ( W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for _ in range ( H ) : <NEWLINE> <INDENT> print ( W * <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , - ~ n ) : d [ i ] = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in d : d [ i ] = 1 <NEWLINE> else : d [ i ] += 1 <NEWLINE> <DEDENT> for i in d . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> S = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> ans += A [ i ] * S <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = set ( list ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <NL> dic = { 1 : 2 , 2 : 5 , 3 : 5 , 4 : 4 , 5 : 5 , 6 : 6 , 7 : 3 , 8 : 7 , 9 : 6 } <NEWLINE> <NL> <COMMENT> <NL> candi = [ [ ] , [ ] , [ 1 ] , [ 7 ] , [ 4 ] , [ 2 , 3 , 5 ] , [ 6 , 9 ] , [ 8 ] ] <NEWLINE> <NL> <COMMENT> <NL> if 2 in A and 3 in A : <NEWLINE> <INDENT> A . remove ( 2 ) <NEWLINE> <DEDENT> if 2 in A and 5 in A : <NEWLINE> <INDENT> A . remove ( 2 ) <NEWLINE> <DEDENT> if 3 in A and 5 in A : <NEWLINE> <INDENT> A . remove ( 3 ) <NEWLINE> <DEDENT> if 6 in A and 9 in A : <NEWLINE> <INDENT> A . remove ( 6 ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( candi ) ) : <NEWLINE> <INDENT> for j in range ( len ( candi [ i ] ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if candi [ i ] [ j ] not in A : <NEWLINE> <INDENT> del candi [ i ] [ j ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> ans = [ <STRING> ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> def to_num ( x ) : <NEWLINE> <INDENT> return int ( <STRING> . join ( sorted ( x , reverse = True ) ) ) <NEWLINE> <DEDENT> for i in range ( len ( candi ) ) : <NEWLINE> <INDENT> if not candi [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num = str ( candi [ i ] [ 0 ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> for j in range ( len ( dp ) ) : <NEWLINE> <INDENT> if dp [ j ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if j + i > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dp [ j + i ] < dp [ j ] + 1 : <NEWLINE> <INDENT> dp [ j + i ] = dp [ j ] + 1 <NEWLINE> ans [ j + i ] = ans [ j ] + num <NEWLINE> <DEDENT> elif dp [ j + i ] == dp [ j ] + 1 : <NEWLINE> <INDENT> if to_num ( ans [ j + i ] ) < to_num ( ans [ j ] + num ) : <NEWLINE> <INDENT> ans [ j + i ] = ans [ j ] + num <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( to_num ( ans [ N ] ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> rectangle = [ ] <NEWLINE> h , w = 1 , 1 <NEWLINE> <NL> while not ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> rectangle . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> l = len ( rectangle ) <NEWLINE> count = 0 <NEWLINE> <NL> for rec in rectangle : <NEWLINE> <INDENT> count += 1 <NEWLINE> for row in range ( rec [ 0 ] ) : <NEWLINE> <INDENT> for col in range ( rec [ 1 ] ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( count < l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> input_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> input_len = len ( input_list ) <NEWLINE> remain_num = sum ( input_list [ 1 : ] ) <NEWLINE> remain_list = [ remain_num ] <NEWLINE> for i in range ( 1 , input_len ) : <NEWLINE> <INDENT> remain_list . append ( remain_list [ i - 1 ] - input_list [ i ] ) <NEWLINE> <NL> <DEDENT> temp = 0 <NEWLINE> for i in range ( input_len ) : <NEWLINE> <INDENT> temp = ( temp + input_list [ i ] * remain_list [ i ] ) % mod <NEWLINE> <DEDENT> print ( temp ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( accumulate ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> B = list ( accumulate ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> <NL> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > K - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> k = [ i for i in range ( n + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for a , b in itertools . product ( k , k ) : <NEWLINE> <INDENT> if n >= a + b and a * 10000 + b * 5000 + ( n - a - b ) * 1000 == y : <NEWLINE> <INDENT> print ( a , b , n - a - b ) <NEWLINE> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_inputs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ab_inputs = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( m ) ] <NEWLINE> <NL> map_li = [ 1 ] * n <NEWLINE> for line in ab_inputs : <NEWLINE> <INDENT> a , b = line [ 0 ] , line [ 1 ] <NEWLINE> if h_inputs [ a - 1 ] > h_inputs [ b - 1 ] : <NEWLINE> <INDENT> map_li [ b - 1 ] = 0 <NEWLINE> <DEDENT> if h_inputs [ a - 1 ] < h_inputs [ b - 1 ] : <NEWLINE> <INDENT> map_li [ a - 1 ] = 0 <NEWLINE> <DEDENT> if h_inputs [ a - 1 ] == h_inputs [ b - 1 ] : <NEWLINE> <INDENT> map_li [ a - 1 ] = 0 <NEWLINE> map_li [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( map_li ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> minlist = [ ] <NEWLINE> <NL> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> minlist . append ( p ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if p < minlist [ i - 1 ] : <NEWLINE> <INDENT> minlist . append ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minlist . append ( minlist [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> pj_min = minlist [ i ] <NEWLINE> if p <= pj_min : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> x = int ( input ( ) ) <NEWLINE> digits = len ( str ( x ) ) <NEWLINE> dic = { } <NEWLINE> keta = [ ] <NEWLINE> for i in range ( 121 ) : <NEWLINE> <INDENT> num = i ** 5 <NEWLINE> if ( num > 10 ** ( digits + 2 ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if num > 10 ** ( digits - 2 ) : <NEWLINE> <INDENT> dic [ i ] = num <NEWLINE> dic [ - i ] = - num <NEWLINE> <DEDENT> elif num < 10 ** ( digits + 1 ) : <NEWLINE> <INDENT> dic [ i ] = num <NEWLINE> dic [ - i ] = - num <NEWLINE> <NL> <DEDENT> <DEDENT> for num1 , num2 in itertools . combinations ( dic . keys ( ) , 2 ) : <NEWLINE> <INDENT> a , b = dic [ num1 ] , dic [ num2 ] <NEWLINE> if x == ( a - b ) : <NEWLINE> <INDENT> ans = ( num1 , num2 ) <NEWLINE> break <NEWLINE> <DEDENT> if x == ( - a + b ) : <NEWLINE> <INDENT> ans = ( num2 , num1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> t = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> m = N // j <NEWLINE> t += ( 1 + m ) * m // 2 * j <NEWLINE> <COMMENT> <NL> <DEDENT> print ( t ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> if x == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> for i in range ( 3 , int ( math . sqrt ( ans ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if ans % i == 0 : <NEWLINE> <INDENT> ans += 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> import glob <NEWLINE> import os <NEWLINE> <NL> bn = os . path . basename ( __file__ ) . split ( <STRING> ) [ 0 ] <NEWLINE> dn = os . path . dirname ( __file__ ) . split ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> REL_PATH = dn [ len ( dn ) - 2 ] + <STRING> + dn [ len ( dn ) - 1 ] + <STRING> + bn <NEWLINE> <NL> <COMMENT> <NL> TOP_PATH = <STRING> <NEWLINE> <NL> class Common : <NEWLINE> <NL> <INDENT> problem = [ ] <NEWLINE> index = 0 <NEWLINE> <NL> def __init__ ( self , rel_path ) : <NEWLINE> <INDENT> self . rel_path = rel_path <NEWLINE> <NL> <DEDENT> def initialize ( self , path ) : <NEWLINE> <INDENT> file = open ( path ) <NEWLINE> self . problem = file . readlines ( ) <NEWLINE> self . index = 0 <NEWLINE> return <NEWLINE> <NL> <DEDENT> def input_data ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> IS_TEST <NEWLINE> self . index += 1 <NEWLINE> return self . problem [ self . index - 1 ] <NEWLINE> <NL> <DEDENT> except NameError : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def resolve ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def exec_resolve ( self ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> IS_TEST <NEWLINE> for path in glob . glob ( TOP_PATH + <STRING> + self . rel_path + <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> + path ) <NEWLINE> self . initialize ( path ) <NEWLINE> self . resolve ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except NameError : <NEWLINE> <INDENT> self . resolve ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Solver ( Common ) : <NEWLINE> <NL> <INDENT> def resolve ( self ) : <NEWLINE> <NL> <INDENT> N = int ( self . input_data ( ) ) <NEWLINE> A = list ( map ( int , self . input_data ( ) . split ( ) ) ) <NEWLINE> A_sorted = sorted ( A ) <NEWLINE> <NL> check_list = [ - 1 ] * 1000001 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for i in range ( a , 1000001 , a ) : <NEWLINE> <INDENT> if i == a : <NEWLINE> <INDENT> if check_list [ i ] == - 1 : <NEWLINE> <INDENT> check_list [ i ] = 0 <NEWLINE> <DEDENT> elif check_list [ i ] == 0 : <NEWLINE> <INDENT> check_list [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> check_list [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> for i in A_sorted : <NEWLINE> <INDENT> if check_list [ i ] < 1 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( result ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solver = Solver ( REL_PATH ) <NEWLINE> solver . exec_resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> total = r * g * b <NEWLINE> for i in range ( 2000 ) : <NEWLINE> <INDENT> for j in range ( n - 2 * i ) : <NEWLINE> <INDENT> if j + ( 2 * i ) <= n - 1 : <NEWLINE> <INDENT> if s [ j ] != s [ j + i ] and s [ j + i ] != s [ j + ( 2 * i ) ] and s [ j + ( 2 * i ) ] != s [ j ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> flag = False <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> for i in a : <NEWLINE> <COMMENT> <NL> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
t = input ( ) <NEWLINE> <NL> ans = t <NEWLINE> tem = <STRING> <NEWLINE> if <STRING> in t : <NEWLINE> <INDENT> if len ( t ) == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif len ( t ) == 2 : <NEWLINE> <INDENT> if t [ 0 ] == <STRING> and t [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif t [ 0 ] == <STRING> and t [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif t [ 0 ] == <STRING> and t [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif t [ 1 ] == <STRING> and t [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif t [ 1 ] == <STRING> and t [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , len ( t ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if t [ i ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif t [ i ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> elif i == len ( t ) - 1 : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if ans [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> res = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> res *= i ; <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> aa = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa += a [ i ] ** 2 <NEWLINE> b += a [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ( b ** 2 - aa ) // 2 % mod ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> def DFS ( u , G , H , A , visited , P ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if not ( min ( u , v ) , max ( u , v ) ) in P : <NEWLINE> <INDENT> if H [ u - 1 ] > H [ v - 1 ] : <NEWLINE> <INDENT> A [ u ] += 1 <NEWLINE> <DEDENT> elif H [ v - 1 ] > H [ u - 1 ] : <NEWLINE> <INDENT> A [ v ] += 1 <NEWLINE> <DEDENT> P . add ( ( min ( u , v ) , max ( u , v ) ) ) <NEWLINE> <DEDENT> if not visited [ v ] : <NEWLINE> <INDENT> DFS ( v , G , H , A , visited , P ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def DFSUtil ( G , H , N ) : <NEWLINE> <INDENT> visited = [ False ] * ( N + 1 ) <NEWLINE> A = [ 0 ] * ( N + 1 ) <NEWLINE> P = set ( ) <NEWLINE> for u in G : <NEWLINE> <INDENT> if ( not visited [ u ] ) : <NEWLINE> <INDENT> DFS ( u , G , H , A , visited , P ) <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <DEDENT> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> G = defaultdict ( list ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( v ) <NEWLINE> G [ v ] . append ( u ) <NEWLINE> <DEDENT> A = DFSUtil ( G , H , N ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> neighbours = len ( list ( set ( G [ i ] ) ) ) <NEWLINE> if neighbours == A [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( A [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> b = B [ N // 2 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += abs ( B [ i ] - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> MOD2 = 998244353 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def num_divisors_table ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> print ( sum ( num_divisors_table ( N - 1 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> huga = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in huga : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flg = 0 <NEWLINE> for number in huga : <NEWLINE> <INDENT> ans = ans * number <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> <NL> dice0 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def dice_roll ( dice , c ) : <NEWLINE> <INDENT> copy = dice [ : ] <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> dice [ 2 ] = copy [ 0 ] <NEWLINE> dice [ 5 ] = copy [ 2 ] <NEWLINE> dice [ 3 ] = copy [ 5 ] <NEWLINE> dice [ 0 ] = copy [ 3 ] <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] = copy [ 1 ] <NEWLINE> dice [ 4 ] = copy [ 0 ] <NEWLINE> dice [ 5 ] = copy [ 4 ] <NEWLINE> dice [ 1 ] = copy [ 5 ] <NEWLINE> pass <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice [ 1 ] = copy [ 0 ] <NEWLINE> dice [ 0 ] = copy [ 4 ] <NEWLINE> dice [ 4 ] = copy [ 5 ] <NEWLINE> dice [ 5 ] = copy [ 1 ] <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] = copy [ 2 ] <NEWLINE> dice [ 2 ] = copy [ 5 ] <NEWLINE> dice [ 5 ] = copy [ 3 ] <NEWLINE> dice [ 3 ] = copy [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice [ 2 ] = copy [ 1 ] <NEWLINE> dice [ 4 ] = copy [ 2 ] <NEWLINE> dice [ 3 ] = copy [ 4 ] <NEWLINE> dice [ 1 ] = copy [ 3 ] <NEWLINE> <DEDENT> return dice <NEWLINE> <NL> <NL> <DEDENT> def check ( ) : <NEWLINE> <INDENT> global dice0 <NEWLINE> global dice1 <NEWLINE> <NL> <COMMENT> <NL> num = 0 <NEWLINE> while dice0 [ 0 ] != dice1 [ 0 ] : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> dice0 = dice_roll ( dice0 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice0 = dice_roll ( dice0 , <STRING> ) <NEWLINE> <DEDENT> num += 1 <NEWLINE> if num > 10 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> num = 0 <NEWLINE> while dice0 [ 1 ] != dice1 [ 1 ] : <NEWLINE> <INDENT> dice0 = dice_roll ( dice0 , <STRING> ) <NEWLINE> num += 1 <NEWLINE> if num > 10 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if dice0 [ 2 ] == dice1 [ 2 ] and dice0 [ 3 ] == dice1 [ 3 ] and dice0 [ 4 ] == dice1 [ 4 ] and dice0 [ 5 ] == dice1 [ 5 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> result = check ( ) <NEWLINE> if result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dice0 = dice_roll ( dice0 , <STRING> ) <NEWLINE> result = check ( ) <NEWLINE> if result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( a ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans_A = [ ] <NEWLINE> ans_B = [ ] <NEWLINE> for i in range ( a , min ( b , a + k ) ) : <NEWLINE> <INDENT> ans_A . append ( i ) <NEWLINE> <DEDENT> for i in range ( max ( a , b - k + 1 ) , b + 1 ) : <NEWLINE> <INDENT> ans_B . append ( i ) <NEWLINE> <DEDENT> ans = sorted ( list ( set ( ans_A ) | set ( ans_B ) ) ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for i in range ( len ( AL [ v ] [ CHILDREN ] ) ) : <NEWLINE> <INDENT> u = AL [ v ] [ CHILDREN ] [ i ] <NEWLINE> if visited [ u ] : <NEWLINE> <INDENT> AL [ v ] [ CHILDREN ] [ i ] = None <NEWLINE> continue <NEWLINE> <DEDENT> AL [ v ] [ SIZE ] += dfs ( u ) <NEWLINE> <DEDENT> return AL [ v ] [ SIZE ] <NEWLINE> <NL> <DEDENT> def anaaki ( v ) : <NEWLINE> <INDENT> ret = powp - 1 <NEWLINE> for ch in AL [ v ] [ CHILDREN ] : <NEWLINE> <INDENT> if ch is None : continue <NEWLINE> ret -= pow ( 2 , AL [ ch ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> <DEDENT> ret -= pow ( 2 , n - AL [ v ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> SIZE = 0 <NEWLINE> CHILDREN = 1 <NEWLINE> AL = [ [ 1 , [ ] ] for _ in range ( n ) ] <NEWLINE> visited = [ False ] * n <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> powp = pow ( 2 , n - 1 , p ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> AL [ a ] [ CHILDREN ] . append ( b ) <NEWLINE> AL [ b ] [ CHILDREN ] . append ( a ) <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> numer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numer += anaaki ( i ) <NEWLINE> numer %= p <NEWLINE> <NL> <DEDENT> denom = powp * 2 % p <NEWLINE> print ( numer * pow ( denom , p - 2 , p ) % p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x - 1 , a ) ) <NEWLINE> <NL> cnts = [ 0 for _ in range ( n ) ] <NEWLINE> for ai in a : <NEWLINE> <INDENT> cnts [ ai ] += 1 <NEWLINE> <NL> <DEDENT> for cnt in cnts : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while y > 0 : x , y = y , x % y <NEWLINE> print ( x ) <NEWLINE>
n , k , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i - k ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> xyh = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> if xyh [ 0 ] [ 2 ] : <NEWLINE> <INDENT> x , y , h = xyh [ 0 ] <NEWLINE> <DEDENT> if xyh [ 1 ] [ 2 ] : <NEWLINE> <INDENT> x , y , h = xyh [ 1 ] <NEWLINE> <DEDENT> if xyh [ - 1 ] [ 2 ] : <NEWLINE> <INDENT> x , y , h = xyh [ - 1 ] <NEWLINE> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> k = h + abs ( i - x ) + abs ( j - y ) <NEWLINE> if all ( h == max ( k - abs ( i - x ) - abs ( j - y ) , 0 ) for x , y , h in xyh ) : <NEWLINE> <INDENT> print ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tree = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ u - 1 ] . append ( v - 1 ) ; tree [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> ans [ 0 ] = 1 <NEWLINE> INF = 10 ** 10 <NEWLINE> dp = [ INF ] * N <NEWLINE> dp [ 0 ] = A [ 0 ] <NEWLINE> stack = [ ] <NEWLINE> def dfs ( node , par ) : <NEWLINE> <INDENT> global ans <NEWLINE> global dp <NEWLINE> global stack <NEWLINE> children = tree [ node ] <NEWLINE> for child in children : <NEWLINE> <INDENT> if child == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num = A [ child ] <NEWLINE> idx = bisect . bisect_left ( dp , num ) <NEWLINE> stack . append ( [ idx , dp [ idx ] ] ) <NEWLINE> dp [ idx ] = num <NEWLINE> ans [ child ] = bisect . bisect_left ( dp , INF ) <NEWLINE> dfs ( child , node ) <NEWLINE> <COMMENT> <NL> idx , num = stack . pop ( ) <NEWLINE> dp [ idx ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> import heapq <NEWLINE> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> C = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> A_max = max ( [ a for _ , _ , a , _ in E ] ) * N <NEWLINE> <NL> D = defaultdict ( lambda : [ ] ) <NEWLINE> <NL> for u , v , a , b in E : <NEWLINE> <INDENT> u -= 1 ; v -= 1 <NEWLINE> for from_a in range ( A_max + 1 ) : <NEWLINE> <INDENT> if from_a - a < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> from_state_u = ( u , from_a ) <NEWLINE> to_state_v = ( v , from_a - a ) <NEWLINE> D [ from_state_u ] . append ( ( b , to_state_v ) ) <NEWLINE> <NL> from_state_v = ( v , from_a ) <NEWLINE> to_state_u = ( u , from_a - a ) <NEWLINE> D [ from_state_v ] . append ( ( b , to_state_u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for n , [ c , d ] in enumerate ( C ) : <NEWLINE> <INDENT> for a in range ( A_max + 1 ) : <NEWLINE> <INDENT> a_after = min ( A_max , a + c ) <NEWLINE> from_state = ( n , a ) <NEWLINE> to_state = ( n , a_after ) <NEWLINE> D [ from_state ] . append ( ( d , to_state ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> start = ( 0 , min ( A_max , S ) ) <NEWLINE> Q = [ ( 0 , start ) ] <NEWLINE> <NL> Dist = defaultdict ( lambda : float ( <STRING> ) ) <NEWLINE> <NL> Dist [ start ] = 0 <NEWLINE> <NL> while Q : <NEWLINE> <INDENT> q = heapq . heappop ( Q ) <NEWLINE> cur_time , cur_state = q <NEWLINE> <NL> if Dist [ cur_state ] < cur_time : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for cost , next_state in D [ cur_state ] : <NEWLINE> <INDENT> next_time = cost + cur_time <NEWLINE> <NL> if Dist [ next_state ] > next_time : <NEWLINE> <INDENT> Dist [ next_state ] = next_time <NEWLINE> heapq . heappush ( Q , ( next_time , next_state ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for dest in range ( 1 , N ) : <NEWLINE> <INDENT> ans = float ( <STRING> ) <NEWLINE> for a in range ( A_max + 1 ) : <NEWLINE> <INDENT> state = ( dest , a ) <NEWLINE> ans = min ( ans , Dist [ state ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , n , func , e , arrange = None ) : <NEWLINE> <INDENT> self . init ( n ) <NEWLINE> self . func = func <NEWLINE> self . e = e <NEWLINE> self . make_arrange ( arrange ) <NEWLINE> <NL> <DEDENT> def init ( self , n ) : <NEWLINE> <INDENT> self . inf = pow ( 2 , 32 ) <NEWLINE> self . n = n <NEWLINE> self . N = 1 <NEWLINE> while self . N < self . n : <NEWLINE> <INDENT> self . N *= 2 <NEWLINE> <DEDENT> self . size = self . N * 2 - 1 <NEWLINE> self . N -= 1 <NEWLINE> <NL> <DEDENT> def make_arrange ( self , arrange ) : <NEWLINE> <INDENT> self . set_arrange ( arrange ) <NEWLINE> self . construct ( arrange ) <NEWLINE> <NL> <DEDENT> def set_arrange ( self , arrange ) : <NEWLINE> <INDENT> if arrange == None : <NEWLINE> <INDENT> self . segment = [ self . e ] * ( self . size ) <NEWLINE> return <NEWLINE> <DEDENT> self . segment = [ 0 ] * ( self . N ) + arrange + [ self . e ] * ( self . size - self . N - self . n ) <NEWLINE> <NL> <DEDENT> def construct ( self , arrange ) : <NEWLINE> <INDENT> if arrange == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for i in range ( self . N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> self . segment [ i ] = self . func ( self . segment [ 2 * i + 1 ] , self . segment [ 2 * i + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i += ( self . N - 1 ) <NEWLINE> self . segment [ i ] = x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> self . segment [ i ] = self . func ( self . segment [ 2 * i + 1 ] , self . segment [ 2 * i + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , a , b , k , l , r ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return self . e <NEWLINE> <DEDENT> elif a <= l and r <= b : <NEWLINE> <INDENT> return self . segment [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> find_l = self . find ( a , b , 2 * k + 1 , l , ( l + r ) // 2 ) <NEWLINE> find_r = self . find ( a , b , 2 * k + 2 , ( l + r ) // 2 , r ) <NEWLINE> res = self . func ( find_l , find_r ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> <DEDENT> def count ( self , l , r ) : <NEWLINE> <INDENT> return self . find ( l - 1 , r , 0 , 0 , self . size - self . N ) <NEWLINE> <NL> <DEDENT> def bisect_sub ( self , a , b , k , l , r , x ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return b + 1 <NEWLINE> <DEDENT> if self . segment [ k ] < x : <NEWLINE> <INDENT> return b + 1 <NEWLINE> <DEDENT> if k >= self . N : <NEWLINE> <INDENT> return r <NEWLINE> <NL> <DEDENT> find_l = self . bisect_sub ( a , b , 2 * k + 1 , l , ( l + r ) // 2 , x ) <NEWLINE> if find_l <= b : <NEWLINE> <INDENT> return find_l <NEWLINE> <NL> <DEDENT> find_r = self . bisect_sub ( a , b , 2 * k + 2 , ( l + r ) // 2 , r , x ) <NEWLINE> return find_r <NEWLINE> <NL> <NL> <NL> <DEDENT> def bisect ( self , l , r , x ) : <NEWLINE> <INDENT> return self . bisect_sub ( l - 1 , r , 0 , 0 , self . size - self . N , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seg = SegmentTree ( n , max , 0 , arrange = p ) <NEWLINE> <NL> res = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> seg . update ( b , c ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> ans = seg . count ( b , c ) <NEWLINE> res . append ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = seg . bisect ( b , n , c ) <NEWLINE> res . append ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * res , sep = <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import itertools <NEWLINE> alsum = list ( itertools . accumulate ( al ) ) <NEWLINE> <NL> temp1 = 0 <NEWLINE> temp2 = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res += al [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if res > 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res * ( - 1 ) + 1 <NEWLINE> temp1 += y <NEWLINE> res = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if res < 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res + 1 <NEWLINE> temp1 += y <NEWLINE> res = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> res += al [ j ] <NEWLINE> if j % 2 == 0 : <NEWLINE> <INDENT> if res < 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res + 1 <NEWLINE> temp2 += y <NEWLINE> res = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if res > 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res * ( - 1 ) + 1 <NEWLINE> temp2 += y <NEWLINE> res = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( temp1 , temp2 ) ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <COMMENT> <NL> PM = [ [ 0 , 0 ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now = 0 <NEWLINE> mini = 0 <NEWLINE> for j in input ( ) : <NEWLINE> <INDENT> if j == <STRING> : now += 1 <NEWLINE> else : <NEWLINE> <INDENT> now -= 1 ; mini = min ( mini , now ) <NEWLINE> <DEDENT> <DEDENT> PM [ i ] = [ mini , now ] <NEWLINE> <NL> <DEDENT> if sum ( [ PM [ i ] [ 1 ] for i in range ( n ) ] ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> MINI = 0 <NEWLINE> NOW = 0 <NEWLINE> PMf = [ PM [ i ] for i in range ( n ) if PM [ i ] [ 1 ] >= 0 ] <NEWLINE> PMf . sort ( ) <NEWLINE> for i in range ( len ( PMf ) ) : <NEWLINE> <INDENT> MINI = min ( MINI , NOW + PMf [ - i - 1 ] [ 0 ] ) <NEWLINE> NOW += PMf [ - i - 1 ] [ 1 ] <NEWLINE> if MINI < 0 : print ( <STRING> ) ; exit ( ) <NEWLINE> <NL> <DEDENT> PMs = [ PM [ i ] for i in range ( n ) if PM [ i ] [ 1 ] < 0 ] <NEWLINE> PMs = sorted ( PMs , key = lambda x : x [ 1 ] - x [ 0 ] ) <NEWLINE> for i in range ( len ( PMs ) ) : <NEWLINE> <INDENT> MINI = min ( MINI , NOW + PMs [ - i - 1 ] [ 0 ] ) <NEWLINE> NOW += PMs [ - i - 1 ] [ 1 ] <NEWLINE> if MINI < 0 : print ( <STRING> ) ; exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> cnt = [ 0 for i in range ( 0 , 10 ** 5 + 1 ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> total = sum ( a ) <NEWLINE> <NL> for j in range ( q ) : <NEWLINE> <INDENT> b = bc [ j ] [ 0 ] <NEWLINE> c = bc [ j ] [ 1 ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> total += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> red = 0 ; blue = 0 <NEWLINE> if n >= a + b : <NEWLINE> <INDENT> stack = n // ( a + b ) <NEWLINE> red += b * stack <NEWLINE> blue += a * stack <NEWLINE> n -= ( a + b ) * stack <NEWLINE> <DEDENT> if n > a : <NEWLINE> <INDENT> n -= a <NEWLINE> blue += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> blue += n <NEWLINE> <DEDENT> if n > b : <NEWLINE> <INDENT> n -= b <NEWLINE> red += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> red += n <NEWLINE> <DEDENT> print ( blue ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> colors = [ 0 ] * n <NEWLINE> def dfs ( v , color ) : <NEWLINE> <INDENT> colors [ v ] = color <NEWLINE> for to in edges [ v ] : <NEWLINE> <INDENT> if colors [ to ] == color : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if colors [ to ] == 0 and ( not dfs ( to , - color ) ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if dfs ( 0 , 1 ) : <NEWLINE> <INDENT> x = colors . count ( 1 ) <NEWLINE> print ( x * ( n - x ) - m ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 1 ) // 2 - m ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if i + 1 == a [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a += math . gcd ( b , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> z = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z . append ( x - y ) <NEWLINE> w . append ( x + y ) <NEWLINE> <NL> <DEDENT> z_ans = max ( z ) - min ( z ) <NEWLINE> w_ans = max ( w ) - min ( w ) <NEWLINE> print ( max ( z_ans , w_ans ) ) <NEWLINE>
l = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( l [ int ( input ( ) ) - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def search ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> pos = deque ( [ ] ) <NEWLINE> <NL> D = [ [ True ] * ( W + 2 ) ] <COMMENT> <NEWLINE> D += [ [ True ] + [ False ] * W + [ True ] for i in range ( H ) ] <COMMENT> <NEWLINE> D . append ( [ True ] * ( W + 2 ) ) <COMMENT> <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> maze = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if maze [ j ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( pos ) > 0 : <COMMENT> <NEWLINE> <INDENT> h , w , depth = pos . popleft ( ) <NEWLINE> if not D [ h + 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h + 1 , w , depth + 1 ] ) <NEWLINE> D [ h + 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h - 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h - 1 , w , depth + 1 ] ) <NEWLINE> D [ h - 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w + 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w + 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w + 1 ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w - 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w - 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> print ( search ( ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> MAX = 2 * 10 ** 6 + 10 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> fac = [ 1 ] * MAX <NEWLINE> f_inv = [ 1 ] * MAX <NEWLINE> <NL> def prepare ( n , mod ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fac [ i ] = ( fac [ i - 1 ] * i ) % mod <NEWLINE> <NL> <DEDENT> f_inv [ n ] = pow ( fac [ n ] , - 1 , MOD ) <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> f_inv [ i ] = ( f_inv [ i + 1 ] * ( i + 1 ) ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def modcmb ( n , r , mod ) : <NEWLINE> <INDENT> if n < 0 or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> return fac [ n ] * f_inv [ r ] * f_inv [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( readline ( ) ) <NEWLINE> S = readline ( ) . strip ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> prepare ( N + K + 5 , MOD ) <NEWLINE> <NL> inv26 = pow ( 26 , - 1 , MOD ) <NEWLINE> pow26 = pow ( 26 , K , MOD ) <NEWLINE> pow25 = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += ( modcmb ( N - 1 + i , i , MOD ) * pow25 * pow26 ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <NL> pow25 *= 25 <NEWLINE> pow25 %= MOD <NEWLINE> pow26 *= inv26 <NEWLINE> pow26 %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> valueA = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> valueA += i <NEWLINE> <NL> <DEDENT> <DEDENT> valueB = 0 <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> valueB += ( len ( S ) - 1 - i ) <NEWLINE> <NL> <DEDENT> print ( valueB - valueA ) <NEWLINE>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> N , M = map ( int , e . split ( ) ) <NEWLINE> k , p = 1 , 0 <NEWLINE> S = [ int ( input ( ) ) for _ in [ 0 ] * N ] <NEWLINE> for d in [ int ( input ( ) ) for _ in [ 0 ] * M ] : <NEWLINE> <INDENT> p += d if N <= p + d else d + S [ p + d ] <NEWLINE> if N <= p + 1 : break <NEWLINE> k += 1 <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) + [ 10 ** 6 + 1 ] <NEWLINE> A . sort ( ) <NEWLINE> B = np . zeros ( 10 ** 6 + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if B [ A [ i ] ] == 0 : <NEWLINE> <INDENT> B [ : : A [ i ] ] = 1 <NEWLINE> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> matches = [ ] <NEWLINE> i = 1 <NEWLINE> l = N // 2 - 1 if N % 2 == 0 else N // 2 <NEWLINE> while len ( matches ) < M : <NEWLINE> <INDENT> if l <= 0 : <NEWLINE> <INDENT> i = N // 2 + 1 if N % 2 == 0 else N // 2 + 2 <NEWLINE> l = N // 2 - 2 if N % 2 == 0 else N // 2 - 1 <NEWLINE> continue <NEWLINE> <DEDENT> matches . append ( ( i , i + l ) ) <NEWLINE> i += 1 ; l -= 2 <NEWLINE> <DEDENT> for a , b in matches : print ( a , b ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> x1 = a * d <NEWLINE> x2 = a * c <NEWLINE> x3 = b * c <NEWLINE> x4 = b * d <NEWLINE> <NL> print ( max ( x1 , x2 , x3 , x4 ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> if ( i * A - i + 1 >= B ) : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . par = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : return x <NEWLINE> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( - min ( uf . par ) ) <NEWLINE>
import sys <NEWLINE> <NL> input ( ) <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> print ( i . replace ( <STRING> , <STRING> ) , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] + i + 1 not in c . keys ( ) : <NEWLINE> <INDENT> c [ a [ i ] + i + 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ a [ i ] + i + 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 - a [ i ] not in c . keys ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += c [ i + 1 - a [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> vmax = sum ( [ wv [ i ] [ 1 ] for i in range ( N ) ] ) <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> dp = np . full ( vmax + 1 , INF ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = wv [ i - 1 ] <NEWLINE> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <NL> <DEDENT> print ( max ( [ i for i in range ( vmax + 1 ) if dp [ i ] <= W ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> p = [ 0 ] * n <NEWLINE> d = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] = a [ i ] + p [ i - 2 ] <NEWLINE> if ( i & 1 ) : <NEWLINE> <INDENT> d [ i ] = max ( p [ i - 1 ] , a [ i ] + d [ i - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = max ( d [ i - 1 ] , a [ i ] + d [ i - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( d [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v . sort ( ) <NEWLINE> ans = v [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ( ans + v [ i ] ) / 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += A [ i ] <NEWLINE> tmp = tmp % mod <NEWLINE> <DEDENT> all = ( tmp % mod ) ** 2 <NEWLINE> all = all % mod <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += ( A [ i ] * A [ i ] ) % mod <NEWLINE> <DEDENT> di = tmp % mod <NEWLINE> <NL> ans = all - di <NEWLINE> ans *= ( mod + 1 ) // 2 <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> import collections <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class UnionFindPathCompression ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = list ( range ( n ) ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> self . parents [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFindPathCompression ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> hoge = [ uf . find ( i ) for i in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> hogehoge = collections . Counter ( hoge ) . most_common ( ) <NEWLINE> <NL> print ( hogehoge [ 0 ] [ 1 ] ) <NEWLINE>
import bisect <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> for i in b : <NEWLINE> <INDENT> s = bisect . bisect_right ( c , i ) <NEWLINE> s_num = n - s <NEWLINE> <NL> t = bisect . bisect_left ( a , i ) <NEWLINE> t_num = t <NEWLINE> <NL> ans += s_num * t_num <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def peak ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( ) <NEWLINE> B = list ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> dummy = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( dummy [ 0 ] ) <NEWLINE> B . append ( dummy [ 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ovservatory_max_height = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ B [ i ] - 1 ] > ovservatory_max_height [ A [ i ] - 1 ] : <NEWLINE> <INDENT> ovservatory_max_height [ A [ i ] - 1 ] = H [ B [ i ] - 1 ] <NEWLINE> <DEDENT> if H [ A [ i ] - 1 ] > ovservatory_max_height [ B [ i ] - 1 ] : <NEWLINE> <INDENT> ovservatory_max_height [ B [ i ] - 1 ] = H [ A [ i ] - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> is_good_list = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > ovservatory_max_height [ i ] or ovservatory_max_height == 0 : <NEWLINE> <INDENT> is_good_list . append ( True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_good_list . append ( False ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return is_good_list . count ( True ) <NEWLINE> <NL> <DEDENT> result = peak ( ) <NEWLINE> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def m_dis ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return abs ( x2 - x1 ) + abs ( y2 - y1 ) <NEWLINE> <NL> <DEDENT> points = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> points . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> x , y = points [ 0 ] <NEWLINE> <NL> maxvalue_p = x + y <NEWLINE> minvalue_p = x + y <NEWLINE> maxvalue_m = x - y <NEWLINE> minvalue_m = x - y <NEWLINE> maxvalue_p_p = points [ 0 ] <NEWLINE> minvalue_p_p = points [ 0 ] <NEWLINE> maxvalue_m_p = points [ 0 ] <NEWLINE> minvalue_m_p = points [ 0 ] <NEWLINE> <NL> for x , y in points : <NEWLINE> <INDENT> p = x + y <NEWLINE> m = x - y <NEWLINE> if maxvalue_p == None or maxvalue_p < p : <NEWLINE> <INDENT> maxvalue_p = p <NEWLINE> maxvalue_p_p = ( x , y ) <NEWLINE> <DEDENT> if minvalue_p == None or minvalue_p > p : <NEWLINE> <INDENT> minvalue_p = p <NEWLINE> minvalue_p_p = ( x , y ) <NEWLINE> <DEDENT> if maxvalue_m == None or maxvalue_m < m : <NEWLINE> <INDENT> maxvalue_m = m <NEWLINE> maxvalue_m_p = ( x , y ) <NEWLINE> <DEDENT> if minvalue_m == None or minvalue_m > m : <NEWLINE> <INDENT> minvalue_m = m <NEWLINE> minvalue_m_p = ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> topvalue = 0 <NEWLINE> <NL> for x , y in points : <NEWLINE> <INDENT> topvalue = max ( topvalue , <NEWLINE> <INDENT> m_dis ( x , y , maxvalue_p_p [ 0 ] , maxvalue_p_p [ 1 ] ) , <NEWLINE> m_dis ( x , y , minvalue_p_p [ 0 ] , minvalue_p_p [ 1 ] ) , <NEWLINE> m_dis ( x , y , maxvalue_m_p [ 0 ] , maxvalue_m_p [ 1 ] ) , <NEWLINE> m_dis ( x , y , minvalue_m_p [ 0 ] , minvalue_m_p [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( topvalue ) <NEWLINE>
from functools import lru_cache <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 2000 ) <NEWLINE> <NL> s = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> if n <= 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> count += dfs ( n - i ) <NEWLINE> count %= mod <NEWLINE> <NL> <DEDENT> return count % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = dfs ( s ) <NEWLINE> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( ( <STRING> * W ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> arr = np . zeros ( 100000 , dtype = np . int32 ) <NEWLINE> <NL> for s in range ( 3 , 128 + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , s - 2 + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , s - 1 + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> arr [ s ** 2 - ( x * y + y * z + z * x ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> num = int ( input ( ) ) <NEWLINE> for i in range ( 0 , num ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> freq_w = [ 0 for _ in range ( W ) ] <NEWLINE> freq_h = [ 0 for _ in range ( H ) ] <NEWLINE> pos = dict ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> freq_h [ h - 1 ] += 1 <NEWLINE> freq_w [ w - 1 ] += 1 <NEWLINE> pos [ ( h - 1 , w - 1 ) ] = True <NEWLINE> <NL> <NL> <DEDENT> m_w = max ( freq_w ) <NEWLINE> pos_w = [ i for i , j in enumerate ( freq_w ) if j == m_w ] <NEWLINE> <NL> m_h = max ( freq_h ) <NEWLINE> pos_h = [ i for i , j in enumerate ( freq_h ) if j == m_h ] <NEWLINE> <NL> max_ = m_w + m_h - 1 <NEWLINE> found = False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in pos_h : <NEWLINE> <INDENT> for j in pos_w : <NEWLINE> <INDENT> if not ( ( i , j ) in pos ) : <NEWLINE> <INDENT> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if found == True : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_ + int ( found ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> rem = N % K <NEWLINE> print ( min ( rem , abs ( rem - K ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] <NEWLINE> b = [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ l [ i ] - 1 ] - 1 ] += 1 <NEWLINE> if b [ a [ l [ i ] - 1 ] - 1 ] == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( a [ l [ i ] - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> lindex = l . index ( a [ l [ i ] - 1 ] ) <NEWLINE> r = len ( l ) - lindex <NEWLINE> rlist = l [ lindex : ] <NEWLINE> <NL> if k >= lindex : <NEWLINE> <INDENT> kmod = ( k - lindex ) % r <NEWLINE> ans = rlist [ kmod ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = l [ k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> data = abs ( data ) <NEWLINE> if data == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif pow ( 2 , data - 1 , data ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> numerator = 1 <NEWLINE> for i in range ( n - r + 1 , n + 1 ) : <NEWLINE> <INDENT> numerator = numerator * i % p <NEWLINE> <DEDENT> denominator = 1 <NEWLINE> for j in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> denominator = denominator * j % p <NEWLINE> <DEDENT> denominator = pow ( denominator , p - 2 , p ) <NEWLINE> return ( numerator * denominator ) % p <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> t = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if t % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while t % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t //= i <NEWLINE> <DEDENT> l . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if t != 1 : <NEWLINE> <INDENT> l . append ( [ t , 1 ] ) <NEWLINE> <DEDENT> if l == [ ] : <NEWLINE> <INDENT> l . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return l <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> F = factorization ( M ) <NEWLINE> for i in range ( len ( F ) ) : <NEWLINE> <INDENT> f = F [ i ] [ 1 ] <NEWLINE> ans *= cmb ( f + N - 1 , f , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> if M == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
S = [ a for a in input ( ) ] <NEWLINE> N = [ int ( a ) for a in S ] <NEWLINE> M = [ N [ 0 ] ] + [ - N [ i ] for i in range ( 1 , 4 ) ] <NEWLINE> <NL> S . insert ( 1 , <STRING> ) <NEWLINE> S . insert ( 3 , <STRING> ) <NEWLINE> S . insert ( 5 , <STRING> ) <NEWLINE> <NL> if sum ( N ) == 7 : <NEWLINE> <INDENT> S = S <NEWLINE> print ( <STRING> . join ( S ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> N [ i ] = - N [ i ] <NEWLINE> <NL> if sum ( N ) == 7 : <NEWLINE> <NL> <INDENT> S [ 2 * i - 1 ] = <STRING> <NEWLINE> print ( <STRING> . join ( S ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : N [ i ] = - N [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> S [ 1 ] , S [ 3 ] , S [ 5 ] = <STRING> , <STRING> , <STRING> <NEWLINE> <NL> M [ i ] = - M [ i ] <NEWLINE> <NL> if sum ( M ) == 7 : <NEWLINE> <INDENT> S [ 2 * i - 1 ] = <STRING> <NEWLINE> print ( <STRING> . join ( S ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M [ i ] = - M [ i ] <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( m ) ] <NEWLINE> kr = [ [ ] for _ in range ( n ) ] <NEWLINE> dist = [ - 1 for _ in range ( n ) ] <NEWLINE> dist [ 0 ] = 0 <NEWLINE> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> qn = deque ( [ 1 ] ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = min ( a , b ) , max ( a , b ) <NEWLINE> ab [ i ] = [ a , b ] <NEWLINE> kr [ a - 1 ] . append ( b ) <NEWLINE> kr [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> dis = 1 <NEWLINE> while len ( qn ) > 0 : <NEWLINE> <INDENT> v = qn . popleft ( ) <NEWLINE> d = dist [ v - 1 ] <NEWLINE> for w in kr [ v - 1 ] : <NEWLINE> <INDENT> if dist [ w - 1 ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w - 1 ] = d + 1 <NEWLINE> qn . append ( w ) <NEWLINE> ans [ w - 1 ] = v <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> c = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = a [ i ] + i <NEWLINE> c [ i ] = i - a [ i ] <NEWLINE> <DEDENT> bs = sorted ( b ) <NEWLINE> cs = sorted ( c ) <NEWLINE> lx = [ 1 + 10 ** 10 ] * n <NEWLINE> ly = [ 2 + 10 ** 10 ] * n <NEWLINE> rx = [ 3 + 10 ** 10 ] * n <NEWLINE> ry = [ 4 + 10 ** 10 ] * n <NEWLINE> <NL> lx [ 0 ] = 1 <NEWLINE> ly [ 0 ] = bs [ 0 ] <NEWLINE> rx [ 0 ] = 1 <NEWLINE> ry [ 0 ] = cs [ 0 ] <NEWLINE> <NL> d = 0 <NEWLINE> e = 0 <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if bs [ j ] == bs [ j - 1 ] : <NEWLINE> <INDENT> lx [ d ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> lx [ d ] = 1 <NEWLINE> ly [ d ] = bs [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( 1 , n ) : <NEWLINE> <INDENT> if cs [ k ] == cs [ k - 1 ] : <NEWLINE> <INDENT> rx [ e ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e += 1 <NEWLINE> rx [ e ] = 1 <NEWLINE> ry [ e ] = cs [ k ] <NEWLINE> <DEDENT> <DEDENT> x = 0 <NEWLINE> ans = 0 <NEWLINE> for l in range ( d ) : <NEWLINE> <INDENT> while ry [ x ] <= ly [ l ] and x < n - 1 : <NEWLINE> <INDENT> if ry [ x ] == ly [ l ] : <NEWLINE> <INDENT> ans += ( lx [ l ] * rx [ x ] ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( xg , yg ) : <NEWLINE> <INDENT> queue = deque ( [ ( xs , ys , 0 ) ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> x , y , dep = queue . popleft ( ) <NEWLINE> l = [ ] <NEWLINE> f1 = True <NEWLINE> f2 = True <NEWLINE> f3 = True <NEWLINE> f4 = True <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if f1 : <NEWLINE> <INDENT> if cord [ y ] [ x + i ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x + i , y ) ) <NEWLINE> <DEDENT> elif cord [ y ] [ x + i ] == <STRING> or cord [ y ] [ x + i ] != dep + 1 : <NEWLINE> <INDENT> f1 = False <NEWLINE> <DEDENT> <DEDENT> if f2 : <NEWLINE> <INDENT> if cord [ y ] [ x - i ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x - i , y ) ) <NEWLINE> <DEDENT> elif cord [ y ] [ x - i ] == <STRING> or cord [ y ] [ x - i ] != dep + 1 : <NEWLINE> <INDENT> f2 = False <NEWLINE> <DEDENT> <DEDENT> if f3 : <NEWLINE> <INDENT> if cord [ y + i ] [ x ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x , y + i ) ) <NEWLINE> <DEDENT> elif cord [ y + i ] [ x ] == <STRING> or cord [ y + i ] [ x ] != dep + 1 : <NEWLINE> <INDENT> f3 = False <NEWLINE> <DEDENT> <DEDENT> if f4 : <NEWLINE> <INDENT> if cord [ y - i ] [ x ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x , y - i ) ) <NEWLINE> <DEDENT> elif cord [ y - i ] [ x ] == <STRING> or cord [ y - i ] [ x ] != dep + 1 : <NEWLINE> <INDENT> f4 = False <NEWLINE> <DEDENT> <DEDENT> if not ( f1 or f2 or f3 or f4 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for nx , ny in l : <NEWLINE> <INDENT> if cord [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> cord [ ny ] [ nx ] = dep + 1 <NEWLINE> if ( nx , ny ) == ( xg , yg ) : <NEWLINE> <INDENT> return dep + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> queue . append ( ( nx , ny , dep + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> h , w , k = iim ( ) <NEWLINE> ys , xs , yg , xg = iim ( ) <NEWLINE> <NL> cord = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> cord . append ( [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] ) <NEWLINE> <DEDENT> cord . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> cord [ ys ] [ xs ] = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( bfs ( xg , yg ) ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> x = [ LIST ( ) for i in range ( n ) ] <NEWLINE> reg = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> p = x [ j ] [ 0 ] - x [ i ] [ 0 ] <NEWLINE> q = x [ j ] [ 1 ] - x [ i ] [ 1 ] <NEWLINE> count = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for l in range ( n ) : <NEWLINE> <INDENT> if x [ l ] [ 0 ] - x [ k ] [ 0 ] == p and x [ l ] [ 1 ] - x [ k ] [ 1 ] == q : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> reg = max ( reg , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = n - reg <NEWLINE> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> o = <STRING> <NEWLINE> for h in range ( a ) : <NEWLINE> <INDENT> for w in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> answer = <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> B *= 2 <NEWLINE> <DEDENT> elif B >= C : <NEWLINE> <INDENT> C *= 2 <NEWLINE> <DEDENT> <DEDENT> if A < B and B < C : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> buff = input ( ) . split ( ) <NEWLINE> h = int ( buff [ 0 ] ) <NEWLINE> w = int ( buff [ 1 ] ) <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 or j == w - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> <NL> n = 10 ** 5 + 1 <NEWLINE> flag = [ True ] * n <NEWLINE> flag [ 1 ] = False <NEWLINE> for i in range ( 4 , n , 2 ) : flag [ i ] = False <NEWLINE> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , n , i ) : flag [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> nums = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> if flag [ i ] and flag [ ( i + 1 ) // 2 ] : nums [ i ] = nums [ i - 1 ] + 1 <NEWLINE> else : nums [ i ] = nums [ i - 1 ] <NEWLINE> <DEDENT> else : nums [ i ] = nums [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( nums [ r ] - nums [ l - 1 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m != 0 : <NEWLINE> <INDENT> edge = np . array ( [ input ( ) . split ( ) for _ in range ( m ) ] , dtype = np . int64 ) . T <NEWLINE> tmp = np . ones ( m , dtype = np . int64 ) . T <NEWLINE> graph = csr_matrix ( ( tmp , ( edge [ : ] - 1 ) ) , ( n , n ) ) <NEWLINE> <NL> cnt = collections . Counter ( connected_components ( graph ) [ 1 ] ) <NEWLINE> <NL> print ( max ( cnt . values ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans_list [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( ans_list [ j ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = math . ceil <NEWLINE> min8 , max8 = c ( a * 12.5 ) , c ( ( a + 1 ) * 12.5 ) <NEWLINE> min10 , max10 = c ( b * 10 ) , c ( ( b + 1 ) * 10 ) <NEWLINE> <NL> l8 , l10 = list ( range ( min8 , max8 ) ) , list ( range ( min10 , max10 ) ) <NEWLINE> s8 , s10 = set ( l8 ) , set ( l10 ) <NEWLINE> <NL> ss = s8 & s10 <NEWLINE> <COMMENT> <NL> print ( min ( ss ) if len ( ss ) > 0 else - 1 ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
def paint ( h , w ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> * w ] * h ) ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> <NL> paint ( H , W ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> explored = set ( ) <NEWLINE> next = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> from collections import deque <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ls . append ( ( u - 1 , v - 1 , w % 2 ) ) <NEWLINE> next [ u - 1 ] . append ( ( v - 1 , w % 2 ) ) <NEWLINE> next [ v - 1 ] . append ( ( u - 1 , w % 2 ) ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * n <NEWLINE> <NL> exploring = deque ( ) <NEWLINE> next_que = deque ( [ 0 ] ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> explored . add ( 0 ) <NEWLINE> while next_que : <NEWLINE> <INDENT> i = next_que . popleft ( ) <NEWLINE> exploring . extend ( next [ i ] ) <NEWLINE> while exploring : <NEWLINE> <INDENT> a , b = exploring . popleft ( ) <NEWLINE> ans [ a ] = ( ans [ i ] + b ) % 2 <NEWLINE> list = next [ a ] <NEWLINE> if a not in explored : <NEWLINE> <INDENT> next_que . append ( a ) <NEWLINE> <DEDENT> explored . add ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> p = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p *= a [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
from math import ceil <COMMENT> <NEWLINE> import numpy as np <NEWLINE> <NL> def inp ( ) : return int ( input ( ) ) <COMMENT> <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> A , B , N = inpl ( ) <NEWLINE> if B <= N : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> print ( A * x // B ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) if x . isdigit ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> be = x % m <NEWLINE> ans = be <NEWLINE> memo = [ [ 0 , 0 ] for i in range ( m ) ] <NEWLINE> am = [ be ] <NEWLINE> memo [ be - 1 ] = [ 1 , 0 ] <COMMENT> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> be = be ** 2 % m <NEWLINE> if be == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif memo [ be - 1 ] [ 0 ] == 1 : <NEWLINE> <INDENT> kazu = memo [ be - 1 ] [ 1 ] <NEWLINE> l = len ( am ) - kazu <NEWLINE> syou = ( n - i - 1 ) // l <NEWLINE> amari = ( n - i - 1 ) % l <NEWLINE> sum = 0 <NEWLINE> for k in range ( kazu , len ( am ) ) : <NEWLINE> <INDENT> sum += am [ k ] <NEWLINE> <DEDENT> ans = ans + syou * sum <NEWLINE> if amari > 0 : <NEWLINE> <INDENT> for j in range ( kazu , kazu + amari ) : <NEWLINE> <INDENT> ans += am [ j ] <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += be <NEWLINE> am . append ( be ) <NEWLINE> memo [ be - 1 ] [ 0 ] = 1 <NEWLINE> memo [ be - 1 ] [ 1 ] = len ( am ) - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> p [ i ] += 1 <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> print ( sum ( p [ : n - k + 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( n // i ) * ( n // i + 1 ) / 2 * i <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> score = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> score . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> non10 = [ ] <NEWLINE> flg10 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if score [ i ] % 10 != 0 : <NEWLINE> <INDENT> non10 . append ( score [ i ] ) <NEWLINE> flg10 = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg10 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sum ( score ) % 10 == 0 : <NEWLINE> <INDENT> ans = sum ( score ) - min ( non10 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( score ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = max ( 0 , A - K ) <NEWLINE> b = B <NEWLINE> if K - A > 0 : <NEWLINE> <INDENT> b = max ( 0 , B - K + A ) <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> P = 2019 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . rstrip ( ) <NEWLINE> <NL> n = len ( S ) <NEWLINE> counts = [ 0 ] * P <NEWLINE> counts [ 0 ] += 1 <NEWLINE> T = 0 <NEWLINE> d = 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> T = ( T + ( d * int ( s ) ) % P ) % P <NEWLINE> d = ( d * 10 ) % P <NEWLINE> counts [ T ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in counts : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> input = sys . stdin . readline <NEWLINE> def IS ( cb ) : return cb ( input ( ) . strip ( ) ) <NEWLINE> def IL ( cb ) : return [ cb ( s ) for s in input ( ) . strip ( ) . split ( ) ] <NEWLINE> def IR ( cb , rows ) : return [ IS ( cb ) for _ in range ( rows ) ] <NEWLINE> def ILL ( cb , rows ) : return [ IL ( cb ) for _ in range ( rows ) ] <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , K = IL ( int ) <NEWLINE> A = IL ( lambda x : int ( x ) - 1 ) <NEWLINE> memo = [ 0 ] <NEWLINE> visited = [ False ] * N <NEWLINE> i = 0 <NEWLINE> while ( not visited [ A [ i ] ] ) : <NEWLINE> <INDENT> memo . append ( A [ i ] ) <NEWLINE> visited [ A [ i ] ] = True <NEWLINE> i = A [ i ] <NEWLINE> <DEDENT> if K < len ( memo ) : <NEWLINE> <INDENT> print ( memo [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = memo [ memo . index ( A [ i ] ) : ] <NEWLINE> print ( loop [ ( K - ( len ( memo ) - len ( loop ) ) ) % len ( loop ) ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> V = [ 0 ] * ( N + 1 ) <NEWLINE> flug = 0 <NEWLINE> Lsum = sum ( A ) <NEWLINE> <NL> V [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> V [ i + 1 ] = ( V [ i ] * 2 - A [ i + 1 ] ) <NEWLINE> if V [ i + 1 ] < 0 : <NEWLINE> <INDENT> flug = 1 <NEWLINE> <DEDENT> Lsum = Lsum - A [ i + 1 ] <NEWLINE> if V [ i + 1 ] > Lsum : <NEWLINE> <INDENT> V [ i + 1 ] = Lsum <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( V ) + sum ( A ) <NEWLINE> if A [ 0 ] != 0 or A [ N ] == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> if flug == 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> if N == 0 and A [ 0 ] != 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif N == 0 and A [ 0 ] == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<NL> import math <NEWLINE> <NL> <NL> class LinearProbingIntSet : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . count = 0 <NEWLINE> self . size = 1 <NEWLINE> self . keys = [ None ] * self . size <NEWLINE> <NL> <DEDENT> def add ( self , key ) : <NEWLINE> <INDENT> i = self . _hash ( key ) <NEWLINE> for j in range ( self . size ) : <NEWLINE> <INDENT> k = ( i + j ) % self . size <NEWLINE> if self . keys [ k ] is None : <NEWLINE> <INDENT> self . keys [ k ] = key <NEWLINE> self . count += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif self . keys [ k ] == key : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <NL> <DEDENT> if self . count > self . size // 2 : <NEWLINE> <INDENT> size = int ( 2 ** ( math . log2 ( self . size + 1 ) + 1 ) ) - 1 <NEWLINE> self . _resize ( size ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> i = self . _hash ( key ) <NEWLINE> while self . keys [ i ] is not None and self . keys [ i ] != key : <NEWLINE> <INDENT> i = ( i + 1 ) % self . size <NEWLINE> <NL> <DEDENT> if self . keys [ i ] != key : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . keys [ i ] = None <NEWLINE> self . count -= 1 <NEWLINE> <NL> i = ( i + 1 ) % self . size <NEWLINE> while self . keys [ i ] is not None : <NEWLINE> <INDENT> key = self . keys [ i ] <NEWLINE> if i != self . _hash ( key ) : <NEWLINE> <INDENT> self . keys [ i ] = None <NEWLINE> self . count -= 1 <NEWLINE> self . add ( key ) <NEWLINE> <DEDENT> i = ( i + 1 ) % self . size <NEWLINE> <NL> <DEDENT> if self . count <= self . size // 4 : <NEWLINE> <INDENT> size = max ( 1 , int ( 2 ** ( math . log2 ( self . size + 1 ) - 1 ) ) - 1 ) <NEWLINE> self . _resize ( size ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __contains__ ( self , key ) : <NEWLINE> <INDENT> i = self . _hash ( key ) <NEWLINE> for j in range ( self . size ) : <NEWLINE> <INDENT> k = ( i + j ) % self . size <NEWLINE> if self . keys [ k ] is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif self . keys [ k ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> raise RuntimeError ( <STRING> ) <NEWLINE> <NL> <DEDENT> def _hash ( self , key ) : <NEWLINE> <INDENT> return ( key * 13 ) % self . size <NEWLINE> <NL> <DEDENT> def _resize ( self , size ) : <NEWLINE> <INDENT> old_keys = self . keys <NEWLINE> self . count = 0 <NEWLINE> self . size = size <NEWLINE> self . keys = [ None ] * self . size <NEWLINE> <NL> for key in old_keys : <NEWLINE> <INDENT> if key is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . add ( key ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> s = LinearProbingIntSet ( ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> command , value = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if command == 0 : <NEWLINE> <INDENT> s . add ( value ) <NEWLINE> print ( s . count ) <NEWLINE> <DEDENT> elif command == 1 : <NEWLINE> <INDENT> if value in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif command == 2 : <NEWLINE> <INDENT> s . delete ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if l . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
_ , * lines = open ( 0 ) . readlines ( ) <NEWLINE> H = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> for line in lines : <NEWLINE> <INDENT> b , f , r , v = map ( int , line . split ( ) ) <NEWLINE> H [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i , h in enumerate ( H ) : <NEWLINE> <INDENT> if i : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for r in h : <NEWLINE> <INDENT> print ( <STRING> , * r ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> from pprint import pprint <NEWLINE> from collections import deque , defaultdict <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + A [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> prev = s [ K ] <NEWLINE> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> score = s [ i ] - s [ i - K ] <NEWLINE> <COMMENT> <NL> if prev < score : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> prev = score <NEWLINE> <DEDENT>
import sys , math , itertools , collections , bisect <NEWLINE> input = lambda : sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> inf = float ( <STRING> ) ; mod = 10 ** 9 + 7 <NEWLINE> mans = inf ; ans = 0 ; count = 0 ; pro = 1 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> left = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> left [ i + a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sub = i - a [ i ] <NEWLINE> if sub in left : <NEWLINE> <INDENT> ans += left [ sub ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> uniqued = list ( set ( S ) ) <NEWLINE> print ( len ( uniqued ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> b = ( N - 1 ) // a <NEWLINE> cnt += b <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acum1 = [ 0 ] <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> acum1 . append ( acum1 [ - 1 ] + arr1 [ i ] ) <NEWLINE> <DEDENT> acum2 = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> acum2 . append ( acum2 [ - 1 ] + arr2 [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum1 [ i ] > k : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> B = [ A [ i ] - A [ i - 1 ] for i in range ( 1 , N ) ] <NEWLINE> ans = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if B [ i ] != 0 : <NEWLINE> <INDENT> first = B [ i ] <NEWLINE> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if first * B [ i ] >= 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> j = i + 1 <NEWLINE> while j <= N - 2 : <NEWLINE> <INDENT> if B [ j ] != 0 : <NEWLINE> <INDENT> first = B [ j ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> As = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> logsum = 0 <NEWLINE> prod = 1 <NEWLINE> for a in As : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> logsum += math . log10 ( a ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if logsum > 18.2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for a in As : <NEWLINE> <INDENT> prod *= a <NEWLINE> <NL> <DEDENT> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( prod ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> h = s - i - j <NEWLINE> if 0 <= h and h <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > ma : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = sum ( [ gcd ( gcd ( i , j ) , k ) for i in range ( 1 , N + 1 ) for j in range ( 1 , N + 1 ) for k in range ( 1 , N + 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
from math import floor <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = eval ( input ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = eval ( input ( ) ) <NEWLINE> ls . append ( m ) <NEWLINE> <DEDENT> ls . remove ( max ( ls ) ) <NEWLINE> ls . remove ( min ( ls ) ) <NEWLINE> print ( floor ( sum ( ls ) / len ( ls ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> def input1 ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n = input1 ( ) <NEWLINE> A = input_array ( ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> kouho = [ [ ] for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : <NEWLINE> <INDENT> kouho [ a - 1 ] . append ( - b ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> p = [ ] <NEWLINE> heapq . heapify ( p ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <NL> <INDENT> for j in kouho [ i ] : <NEWLINE> <INDENT> heapq . heappush ( p , j ) <NEWLINE> <DEDENT> if p : <NEWLINE> <INDENT> ans -= heapq . heappop ( p ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = <STRING> + input ( ) <NEWLINE> lx = len ( X ) <NEWLINE> ly = len ( Y ) <NEWLINE> T = [ 0 ] * ly <NEWLINE> for j in range ( lx ) : <NEWLINE> <INDENT> xj = X [ j ] <NEWLINE> C = T [ : ] <NEWLINE> for k in range ( 1 , ly ) : <NEWLINE> <INDENT> k1 = k - 1 <NEWLINE> if xj == Y [ k ] : <NEWLINE> <INDENT> T [ k ] = C [ k1 ] + 1 <NEWLINE> <DEDENT> elif T [ k ] < T [ k1 ] : <NEWLINE> <INDENT> T [ k ] = T [ k1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( T [ k ] ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> S . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> y_1 , y_0 = [ 0 ] , [ 0 ] <NEWLINE> st = set ( ) <NEWLINE> <NL> for t , d in S : <NEWLINE> <INDENT> if t in st : <NEWLINE> <COMMENT> <NL> <INDENT> y_0 . append ( y_0 [ - 1 ] + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . add ( t ) <NEWLINE> y_1 . append ( y_1 [ - 1 ] + d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> max_sum = - 1 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if k - i >= len ( y_0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i >= len ( y_1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> max_sum = max ( max_sum , y_0 [ k - i ] + y_1 [ i ] + i ** 2 ) <NEWLINE> <NL> <DEDENT> print ( max_sum ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L = list ( ) <NEWLINE> R = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ a , b ] ) <NEWLINE> <DEDENT> k = dict ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a , b = L [ i ] <NEWLINE> c , d = L [ j ] <NEWLINE> R . append ( [ a - c , b - d ] ) <NEWLINE> n = str ( a - c ) + <STRING> + str ( b - d ) <NEWLINE> if n in k : <NEWLINE> <INDENT> k [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ n ] = 1 <NEWLINE> <DEDENT> R . append ( [ c - a , d - b ] ) <NEWLINE> n = str ( c - a ) + <STRING> + str ( d - b ) <NEWLINE> if n in k : <NEWLINE> <INDENT> k [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ n ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> op = max ( k . values ( ) ) <NEWLINE> print ( N - op ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> sum = sum ( number ) <NEWLINE> s = sum % MOD <NEWLINE> ans = 0 <NEWLINE> for i in number : <NEWLINE> <INDENT> s -= i <NEWLINE> s %= MOD <NEWLINE> ans += s * i <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 118 , 119 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_price = min ( a ) + min ( b ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> discount_price = a [ x - 1 ] + b [ y - 1 ] - c <NEWLINE> if min_price > discount_price : <NEWLINE> <INDENT> min_price = discount_price <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_price ) <NEWLINE>
from collections import * <NEWLINE> s = input ( ) <NEWLINE> p = 2019 <NEWLINE> c = Counter ( ) <NEWLINE> c [ 0 ] += 1 <NEWLINE> v = r = 0 <NEWLINE> k = 1 <NEWLINE> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> v += int ( i ) * k <NEWLINE> v %= p <NEWLINE> r += c [ v ] <NEWLINE> c [ v ] += 1 <NEWLINE> k *= 10 <NEWLINE> k %= p <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ma = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 - 1 ) : <NEWLINE> <INDENT> ma = max ( b [ i - 1 ] + b [ i ] + b [ i + 1 ] , ma ) <NEWLINE> <DEDENT> print ( ma ) <NEWLINE>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> a = [ - 1 for _ in range ( 26 ) ] <NEWLINE> b = [ - 1 for _ in range ( 26 ) ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num0 , num1 = a [ ord ( s [ i ] ) - 97 ] , b [ ord ( t [ i ] ) - 97 ] <NEWLINE> if num0 >= 0 : <NEWLINE> <INDENT> if chr ( num0 + 97 ) != t [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a [ ord ( s [ i ] ) - 97 ] = ord ( t [ i ] ) - 97 <NEWLINE> <NL> <DEDENT> if num1 >= 0 : <NEWLINE> <INDENT> if chr ( num1 + 97 ) != s [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b [ ord ( t [ i ] ) - 97 ] = ord ( s [ i ] ) - 97 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> battle = n * ( n - 1 ) // 2 <NEWLINE> lis = [ [ ] for i in range ( battle ) ] <NEWLINE> num = [ - 1 ] * ( n ** 2 ) <NEWLINE> cnt = - 1 <NEWLINE> for x in range ( n ** 2 ) : <NEWLINE> <INDENT> if x // n < x % n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> num [ x ] = cnt <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n - 2 ) : <NEWLINE> <INDENT> x = a [ j ] - 1 <NEWLINE> y = a [ j + 1 ] - 1 <NEWLINE> px = num [ min ( i * n + x , x * n + i ) ] <NEWLINE> py = num [ min ( i * n + y , y * n + i ) ] <NEWLINE> lis [ px ] . append ( py ) <NEWLINE> <DEDENT> <DEDENT> node_in = [ 0 ] * ( battle ) <NEWLINE> for i in range ( battle ) : <NEWLINE> <INDENT> for x in lis [ i ] : <NEWLINE> <INDENT> node_in [ x ] += 1 <NEWLINE> <DEDENT> <DEDENT> zero = deque ( [ ] ) <NEWLINE> days = [ 10 ** 9 ] * ( battle ) <NEWLINE> for i in range ( battle ) : <NEWLINE> <INDENT> if node_in [ i ] == 0 : <NEWLINE> <INDENT> zero . append ( i ) <NEWLINE> days [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> while zero : <NEWLINE> <INDENT> r = zero . popleft ( ) <NEWLINE> for x in lis [ r ] : <NEWLINE> <INDENT> node_in [ x ] -= 1 <NEWLINE> if node_in [ x ] == 0 : <NEWLINE> <INDENT> zero . append ( x ) <NEWLINE> days [ x ] = days [ r ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if 10 ** 9 in days : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( days ) ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sub = A [ i - 1 ] - A [ i ] <NEWLINE> if sub > 0 : <NEWLINE> <INDENT> A [ i ] += sub <NEWLINE> ans += sub <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> cnt = Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt_b = cnt [ b ] <NEWLINE> cnt [ b ] , cnt [ c ] = 0 , cnt [ c ] + cnt_b <NEWLINE> s += ( c - b ) * cnt_b <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( S ) - 1 <NEWLINE> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if t == S [ mid ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif t < S [ mid ] : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> ans = [ s [ 0 ] ] <NEWLINE> cnt = 1 <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] , end = <STRING> ) <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> ans . append ( s [ i + 1 ] ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if s [ - 1 ] == s [ - 2 ] : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> ans2 = [ 0 ] * len ( s ) <NEWLINE> sm = 0 <NEWLINE> for i in range ( len ( ans ) // 2 ) : <NEWLINE> <INDENT> sm += ans [ 2 * i + 1 ] <NEWLINE> if ans [ i * 2 ] == <STRING> : <NEWLINE> <INDENT> if ans [ 2 * i + 1 ] % 2 == 1 : <NEWLINE> <INDENT> ans2 [ sm - ans [ i * 2 + 1 ] ] += ( ans [ 2 * i + 1 ] + 1 ) // 2 <NEWLINE> ans2 [ sm - ans [ i * 2 + 1 ] - 1 ] += ( ans [ 2 * i + 1 ] - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 [ sm - ans [ i * 2 + 1 ] ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> ans2 [ sm - ans [ i * 2 + 1 ] - 1 ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans [ 2 * i + 1 ] % 2 == 1 : <NEWLINE> <INDENT> ans2 [ sm - 1 ] += ( ans [ 2 * i + 1 ] + 1 ) // 2 <NEWLINE> ans2 [ sm ] += ( ans [ 2 * i + 1 ] - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 [ sm ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> ans2 [ sm - 1 ] += ( ans [ 2 * i + 1 ] ) // 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans2 : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = sum ( l ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( l [ i ] in d ) : <NEWLINE> <INDENT> d [ l [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ l [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for w in range ( q ) : <NEWLINE> <INDENT> b , c = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if ( b in d ) : <NEWLINE> <INDENT> s -= ( d [ b ] * b ) <NEWLINE> s += ( d [ b ] * c ) <NEWLINE> if ( c in d ) : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> <DEDENT> d [ b ] = 0 <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> road_dict = defaultdict ( list ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> road_dict [ A ] . append ( B ) <NEWLINE> road_dict [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> result_dict = defaultdict ( int ) <NEWLINE> <NL> next_list = [ ] <NEWLINE> for i in road_dict [ 1 ] : <NEWLINE> <INDENT> if i not in result_dict : <NEWLINE> <INDENT> result_dict [ i ] = 1 <NEWLINE> next_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> taisho_list = next_list [ : ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> next_list = [ ] <NEWLINE> <NL> if len ( taisho_list ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for j in taisho_list : <NEWLINE> <INDENT> for k in road_dict [ j ] : <NEWLINE> <INDENT> if k not in result_dict : <NEWLINE> <INDENT> result_dict [ k ] = j <NEWLINE> next_list . append ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> taisho_list = next_list [ : ] <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for k in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( result_dict [ k ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> max = A [ 1 ] - A [ 0 ] <NEWLINE> min = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( max < A [ i ] - min ) : <NEWLINE> <INDENT> max = A [ i ] - min <NEWLINE> <DEDENT> if ( min > A [ i ] ) : <NEWLINE> <INDENT> min = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> type = set ( C ) <NEWLINE> L = 0 <NEWLINE> R = 0 <NEWLINE> RR = 0 <NEWLINE> X = 0 <NEWLINE> if <STRING> in type and <STRING> in type : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> L = i <NEWLINE> R = RR <NEWLINE> if L >= N - 1 - R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> for ii in range ( N - L - R ) : <NEWLINE> <INDENT> if C [ N - 1 - R - ii ] == <STRING> : <NEWLINE> <INDENT> C [ L ] = <STRING> <NEWLINE> C [ N - 1 - R - ii ] = <STRING> <NEWLINE> X += 1 <NEWLINE> break <NEWLINE> <DEDENT> RR += 1 <NEWLINE> if L >= N - 1 - R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( X ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> import itertools as it <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ord_ = [ - 1 ] * ( n + 1 ) <NEWLINE> s = [ ] <NEWLINE> v = 1 <NEWLINE> while ord_ [ v ] == - 1 : <NEWLINE> <INDENT> ord_ [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <DEDENT> c = len ( s ) - ord_ [ v ] <NEWLINE> l = ord_ [ v ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> if n [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> n = int ( readline ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> b = defaultdict ( list ) <NEWLINE> c = defaultdict ( list ) <NEWLINE> <NL> for i , v in enumerate ( a , 1 ) : <NEWLINE> <INDENT> b [ i + v ] . append ( i ) <NEWLINE> if 2 <= i - v <= 100000001 : <NEWLINE> <INDENT> c [ i - v ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> c = dict ( c ) <NEWLINE> <NL> ans = 0 <NEWLINE> for v , L in b . items ( ) : <NEWLINE> <INDENT> for j in L : <NEWLINE> <INDENT> if v in c : <NEWLINE> <INDENT> ans += len ( c [ v ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def prime_factor ( num ) : <NEWLINE> <INDENT> factor_list = [ ] <NEWLINE> while num % 2 == 0 : <NEWLINE> <INDENT> factor_list . append ( 2 ) <NEWLINE> num /= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= num : <NEWLINE> <INDENT> if num % f == 0 : <NEWLINE> <INDENT> factor_list . append ( f ) <NEWLINE> num /= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if num != 1 : <NEWLINE> <INDENT> factor_list . append ( num ) <NEWLINE> <DEDENT> return factor_list <NEWLINE> <NL> <DEDENT> def get_count ( c ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> _max = c <NEWLINE> for i in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> if i <= _max : <NEWLINE> <INDENT> ans += 1 <NEWLINE> _max -= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> a = int ( input ( ) ) <NEWLINE> counter = Counter ( prime_factor ( a ) ) <NEWLINE> ans = 0 <NEWLINE> for i in counter : <NEWLINE> <INDENT> ans += get_count ( counter [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> A , B , N = FLI ( ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return ( A * x ) // B - A * ( x // B ) <NEWLINE> <DEDENT> max = 0 <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> <NL> print ( f ( x ) ) <NEWLINE>
from collections import Counter <NEWLINE> import time <NEWLINE> <NL> def SL ( S ) : <NEWLINE> <INDENT> t = [ <STRING> ] * len ( S ) <NEWLINE> for i in range ( len ( S ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] > S [ i + 1 ] or ( S [ i ] == S [ i + 1 ] and t [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> def LMS ( t ) : <NEWLINE> <INDENT> lms = [ False ] * len ( t ) <NEWLINE> for i in range ( 1 , len ( t ) ) : <NEWLINE> <INDENT> if t [ i - 1 ] == <STRING> and t [ i ] == <STRING> : <NEWLINE> <INDENT> lms [ i ] = True <NEWLINE> <DEDENT> <DEDENT> return lms <NEWLINE> <NL> <DEDENT> def Bucket ( S ) : <NEWLINE> <INDENT> bucket = Counter ( S ) <NEWLINE> tmp = 0 <NEWLINE> for i in sorted ( bucket ) : <NEWLINE> <INDENT> bucket [ i ] = { <STRING> : tmp , <STRING> : tmp + bucket [ i ] - 1 } <NEWLINE> tmp = bucket [ i ] [ <STRING> ] + 1 <NEWLINE> <DEDENT> return bucket <NEWLINE> <NL> <DEDENT> def STEP2 ( S , t , bucket , SA ) : <NEWLINE> <INDENT> for i in range ( len ( SA ) ) : <NEWLINE> <INDENT> tmp = SA [ i ] - 1 <NEWLINE> if t [ tmp ] == <STRING> and tmp > - 1 : <NEWLINE> <INDENT> head = bucket [ S [ tmp ] ] [ <STRING> ] <NEWLINE> SA [ head ] = tmp <NEWLINE> bucket [ S [ tmp ] ] [ <STRING> ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def STEP3 ( S , t , SA ) : <NEWLINE> <INDENT> bucket = Bucket ( S ) <NEWLINE> for i in range ( len ( SA ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = SA [ i ] - 1 <NEWLINE> if t [ tmp ] == <STRING> and tmp > - 1 : <NEWLINE> <INDENT> tail = bucket [ S [ tmp ] ] [ <STRING> ] <NEWLINE> SA [ tail ] = tmp <NEWLINE> bucket [ S [ tmp ] ] [ <STRING> ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def InducedSorting ( S ) : <NEWLINE> <INDENT> l = len ( S ) <NEWLINE> t = SL ( S ) <NEWLINE> lms = LMS ( t ) <NEWLINE> bucket = Bucket ( S ) <NEWLINE> SA = [ - 1 ] * l <NEWLINE> P1 = [ i for i in range ( l ) if lms [ i ] ] <NEWLINE> <COMMENT> <NL> for i , j in enumerate ( lms ) : <NEWLINE> <INDENT> if j : <NEWLINE> <INDENT> tail = bucket [ S [ i ] ] [ <STRING> ] <NEWLINE> SA [ tail ] = i <NEWLINE> bucket [ S [ i ] ] [ <STRING> ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> STEP2 ( S , t , bucket , SA ) <NEWLINE> <COMMENT> <NL> STEP3 ( S , t , SA ) <NEWLINE> <COMMENT> <NL> prev = None <NEWLINE> Name = [ None ] * l <NEWLINE> name = 0 <NEWLINE> S1 = [ ] <NEWLINE> for i in SA : <NEWLINE> <INDENT> if lms [ i ] : <NEWLINE> <INDENT> if prev and not i == len ( S ) - 1 : <NEWLINE> <INDENT> j = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if not S [ i + j ] == S [ prev + j ] or not t [ i + j ] == t [ prev + j ] : <NEWLINE> <INDENT> name += 1 <NEWLINE> break <NEWLINE> <DEDENT> if j > 0 and lms [ i + j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> Name [ i ] = name <NEWLINE> prev = i <NEWLINE> <DEDENT> <DEDENT> for i in Name : <NEWLINE> <INDENT> if not i == None : <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> uniq = True <NEWLINE> dtmp = { } <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in S1 : <NEWLINE> <INDENT> if i in dtmp : <NEWLINE> <INDENT> uniq = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dtmp [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> if uniq : <NEWLINE> <INDENT> SA1 = [ None ] * len ( S1 ) <NEWLINE> for i , j in enumerate ( S1 ) : <NEWLINE> <INDENT> SA1 [ j ] = i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> SA1 = InducedSorting ( S1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> bucket = Bucket ( S ) <NEWLINE> SA = [ - 1 ] * l <NEWLINE> for i in SA1 [ : : - 1 ] : <NEWLINE> <INDENT> p = P1 [ i ] <NEWLINE> tail = bucket [ S [ p ] ] [ <STRING> ] <NEWLINE> SA [ tail ] = p <NEWLINE> bucket [ S [ p ] ] [ <STRING> ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> STEP2 ( S , t , bucket , SA ) <NEWLINE> <COMMENT> <NL> STEP3 ( S , t , SA ) <NEWLINE> return SA <NEWLINE> <NL> <DEDENT> def contain ( T , sa , P ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = len ( T ) <NEWLINE> while ( b - a > 1 ) : <NEWLINE> <INDENT> c = ( a + b ) // 2 <NEWLINE> if T [ sa [ c ] : sa [ c ] + len ( P ) ] < P : <NEWLINE> <INDENT> a = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = c <NEWLINE> <DEDENT> <DEDENT> return P == T [ sa [ b ] : sa [ b ] + len ( P ) ] <NEWLINE> <NL> <DEDENT> T = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> P = [ input ( ) for _ in range ( Q ) ] <NEWLINE> SA = InducedSorting ( T + <STRING> ) <NEWLINE> for i in P : <NEWLINE> <INDENT> if contain ( T , SA , i ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x * y , x * 2 + y * 2 ) <NEWLINE>
<COMMENT> <NL> <NL> from itertools import accumulate , islice <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ys = list ( accumulate ( xs ) ) <NEWLINE> zs , total = ys [ : - 1 ] , ys [ - 1 ] <NEWLINE> <NL> res = max ( xs ) - min ( xs ) <NEWLINE> for i , z in islice ( enumerate ( zs ) , 1 , n - 1 ) : <NEWLINE> <INDENT> j = bisect_left ( zs , z // 2 ) <NEWLINE> splits = ( ( zs [ j + k ] , z - zs [ j + k ] ) for k in ( - 1 , 0 , 1 ) if 0 <= j + k <= i ) <NEWLINE> a , b = min ( splits , key = lambda s : abs ( s [ 0 ] - s [ 1 ] ) ) <NEWLINE> <NL> j = bisect_left ( zs , ( total - z ) // 2 + z ) <NEWLINE> splits = ( ( zs [ j + k ] - z , total - zs [ j + k ] ) <NEWLINE> <INDENT> for k in ( - 1 , 0 , 1 ) if i <= j + k <= n - 2 ) <NEWLINE> <DEDENT> c , d = min ( splits , key = lambda s : abs ( s [ 0 ] - s [ 1 ] ) ) <NEWLINE> <NL> minn , _ , _ , maxx = sorted ( ( a , b , c , d ) ) <NEWLINE> if maxx - minn < res : <NEWLINE> <INDENT> res = maxx - minn <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 2 or n == 3 or n == 5 or n == 7 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if n > 3 and n % 2 != 0 : <NEWLINE> <INDENT> for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i == int ( math . sqrt ( n ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> num = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> res *= i <NEWLINE> if res >= 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif res <= 10 ** 18 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> parent_dict = dict ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def add_connect ( A , B ) : <NEWLINE> <INDENT> A_parent = get_parent ( A ) <NEWLINE> B_parent = get_parent ( B ) <NEWLINE> <NL> if A_parent != B_parent : <NEWLINE> <INDENT> parent_dict [ B_parent ] = A_parent <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def judge_connection ( A , B ) : <NEWLINE> <INDENT> A_parent = get_parent ( A ) <COMMENT> <NEWLINE> B_parent = get_parent ( B ) <NEWLINE> <NL> if A_parent != B_parent : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_parent ( child ) : <NEWLINE> <INDENT> if child not in parent_dict : <COMMENT> <NEWLINE> <INDENT> parent_dict [ child ] = child <NEWLINE> <NL> <DEDENT> parent = parent_dict [ child ] <NEWLINE> <NL> if parent == child : <NEWLINE> <INDENT> return parent <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> parent_dict [ child ] = get_parent ( parent ) <NEWLINE> return parent_dict [ child ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> add_connect ( A , B ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> get_parent ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> child_dict = dict ( ) <COMMENT> <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if parent_dict [ i ] not in child_dict : <NEWLINE> <INDENT> child_dict [ parent_dict [ i ] ] = set ( ) <NEWLINE> <DEDENT> child_dict [ parent_dict [ i ] ] . add ( i ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for parent in child_dict : <NEWLINE> <INDENT> if len ( child_dict [ parent ] ) > ans : <NEWLINE> <INDENT> ans = len ( child_dict [ parent ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> b = b * i <NEWLINE> <NL> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
[ _x , _k , _d ] = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> _x = abs ( _x ) <NEWLINE> <NL> if _x >= _d : <NEWLINE> <INDENT> _y = _x // _d <NEWLINE> if _k < _y : <NEWLINE> <INDENT> _y = _k <NEWLINE> <DEDENT> _x = abs ( _x - _d * _y ) <NEWLINE> _k -= _y <NEWLINE> <DEDENT> if _k % 2 == 1 : <NEWLINE> <INDENT> _x = abs ( _x - _d ) <NEWLINE> <NL> <DEDENT> print ( _x ) <NEWLINE>
<COMMENT> <NL> import itertools <NEWLINE> from collections import defaultdict <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> t = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if ( t [ i ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> import bisect <NEWLINE> b = [ ] <NEWLINE> for i in B : <NEWLINE> <INDENT> x = bisect . bisect_right ( C , i ) <NEWLINE> b . append ( N - x ) <NEWLINE> <DEDENT> y = sum ( b ) <NEWLINE> c = [ y ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> y -= b [ i - 1 ] <NEWLINE> c . append ( y ) <NEWLINE> <DEDENT> c . append ( 0 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> a = bisect . bisect_right ( B , i ) <NEWLINE> ans += c [ a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> def find_cost ( s ) : <NEWLINE> <INDENT> counter , i , j = 0 , 0 , len ( s ) - 1 <NEWLINE> while i < j : <NEWLINE> <INDENT> while i < len ( s ) and s [ i ] != <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while j >= 0 and s [ j ] != <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i < j : <NEWLINE> <COMMENT> <NL> <INDENT> s [ i ] , s [ j ] = s [ j ] , s [ i ] <NEWLINE> <COMMENT> <NL> counter += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 0 , len ( s ) - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <NL> <DEDENT> s = list ( s ) <NEWLINE> find_cost ( s ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K , S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if S == 10 ** 9 : <NEWLINE> <INDENT> ans = [ 10 ** 9 - 1 ] * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 10 ** 9 ] * N <NEWLINE> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans [ i ] = S <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( List ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( Q ) ] <NEWLINE> <NL> p = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] > 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = 2 * C * min ( X , Y ) + 2 * C * ( max ( X , Y ) - min ( X , Y ) ) <NEWLINE> <NL> <COMMENT> <NL> if X > Y : <NEWLINE> <INDENT> b = 2 * C * Y + ( X - Y ) * A <NEWLINE> <DEDENT> elif Y > X : <NEWLINE> <INDENT> b = 2 * C * X + ( Y - X ) * B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = A * X + B * Y <NEWLINE> <NL> print ( min ( a , b , c ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> arrA = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> arrB = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> arrA = np . cumsum ( arrA , dtype = <STRING> ) <NEWLINE> arrB = np . cumsum ( arrB , dtype = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> j = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> while j >= 0 : <NEWLINE> <INDENT> if arrA [ i ] + arrB [ j ] <= K : <NEWLINE> <INDENT> ans = max ( i + j , ans ) <NEWLINE> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
N = int ( input ( ) ) <NEWLINE> Alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Blst = [ 0 ] * ( N + 1 ) <NEWLINE> num = 0 <NEWLINE> for i in Alst : <NEWLINE> <INDENT> num = num + Blst [ i ] <NEWLINE> Blst [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in Alst : <NEWLINE> <INDENT> k = Blst [ i ] - 1 <NEWLINE> print ( num - k ) <NEWLINE> <DEDENT>
import time <NEWLINE> <NL> p0 = time . time ( ) <NEWLINE> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> Y = { 0 : 1 } <NEWLINE> <COMMENT> <NL> Y [ 0 ] = 1 <NEWLINE> A = [ 0 ] <NEWLINE> pk = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = ( int ( S [ - i ] ) * pow ( 10 , i - 1 , 2019 ) + pk ) % 2019 <NEWLINE> A . append ( k ) <NEWLINE> if k not in Y : <NEWLINE> <INDENT> Y [ k ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y [ k ] += 1 <NEWLINE> <DEDENT> pk = k <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> c = 0 <NEWLINE> for y in Y : <NEWLINE> <INDENT> d = Y [ y ] <NEWLINE> c += d * ( d - 1 ) // 2 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <COMMENT> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> M = [ [ float ( <STRING> ) for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> M [ a ] [ b ] = d <NEWLINE> M [ b ] [ a ] = d <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> M [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> X = [ ] <COMMENT> <NEWLINE> Y = [ i for i in range ( n ) ] <COMMENT> <NEWLINE> <NL> X . append ( 0 ) <NEWLINE> Y . remove ( 0 ) <NEWLINE> <NL> light_num = 0 <NEWLINE> while len ( X ) != n : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for x in X : <NEWLINE> <INDENT> for y in Y : <NEWLINE> <INDENT> dist = M [ x ] [ y ] <NEWLINE> lst . append ( ( dist , x , y ) ) <NEWLINE> <DEDENT> <DEDENT> lst . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> dist , x , y = lst [ 0 ] <NEWLINE> light_num += ( dist // 100 ) - 1 <NEWLINE> <NL> if x not in X : <NEWLINE> <INDENT> X . append ( x ) <NEWLINE> Y . remove ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X . append ( y ) <NEWLINE> Y . remove ( y ) <NEWLINE> <DEDENT> <DEDENT> print ( light_num ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ tuple ( map ( lambda x : int ( x ) - 1 , s . split ( ) ) ) for s in sys . stdin . readlines ( ) ] <NEWLINE> X = [ 0 ] * H <COMMENT> <NEWLINE> Y = [ 0 ] * W <COMMENT> <NEWLINE> for h , w in bomb : <NEWLINE> <INDENT> X [ h ] += 1 <NEWLINE> Y [ w ] += 1 <NEWLINE> <DEDENT> maxX = max ( X ) <NEWLINE> maxY = max ( Y ) <NEWLINE> <NL> R = [ h for h , x in enumerate ( X ) if x == maxX ] <COMMENT> <NEWLINE> C = [ w for w , y in enumerate ( Y ) if y == maxY ] <COMMENT> <NEWLINE> <NL> bomb = set ( bomb ) <NEWLINE> for r in R : <NEWLINE> <INDENT> for c in C : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( r , c ) not in bomb : <NEWLINE> <INDENT> print ( maxX + maxY ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( maxX + maxY - 1 ) <NEWLINE>
<COMMENT> <NL> S_list = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( S_list ) ) : <NEWLINE> <INDENT> if ( S_list [ i ] == <STRING> ) : <NEWLINE> <INDENT> S_list [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * S_list , sep = <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> old = A [ 0 ] <NEWLINE> a = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cur = A [ i ] <NEWLINE> if cur == old : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if old <= a : <NEWLINE> <INDENT> ans += a - old <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> a = 1 <NEWLINE> <DEDENT> old = cur <NEWLINE> <DEDENT> if old <= a : <NEWLINE> <INDENT> ans += a - old <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> x_popcnt = x . count ( <STRING> ) <NEWLINE> one_popcnt = x_popcnt - 1 <NEWLINE> zero_popcnt = x_popcnt + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if one_popcnt != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_popcnt <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_popcnt <NEWLINE> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> popcnt = [ 0 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> popcnt [ i ] = popcnt [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % popcnt [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if one_popcnt != 0 : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= pow ( 2 , i , one_popcnt ) <NEWLINE> nxt %= one_popcnt <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += pow ( 2 , i , zero_popcnt ) <NEWLINE> nxt %= zero_popcnt <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> if s >= N : <NEWLINE> <INDENT> ans = s - N <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 1000 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> com = [ int ( x ) for x in range ( 1 , m + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in combinations_with_replacement ( com , n - 1 ) : <NEWLINE> <INDENT> cur = list ( i ) <NEWLINE> A = [ 1 ] + cur <NEWLINE> tot = 0 <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = l [ k ] <NEWLINE> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> tot += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tot ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> T = A = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> total = T + A <NEWLINE> x = - ( - total // ( a + t ) ) <NEWLINE> x = max ( x , - ( - T // t ) ) <NEWLINE> x = max ( x , - ( - A // a ) ) <NEWLINE> T = t * x <NEWLINE> A = a * x <NEWLINE> <NL> <DEDENT> print ( T + A ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> w , r = 0 , c [ <STRING> ] <NEWLINE> ans = max ( w , r ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : w += 1 <NEWLINE> else : r -= 1 <NEWLINE> ans = min ( ans , max ( w , r ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = 1 <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in lis : <NEWLINE> <INDENT> if ( prod > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> prod = prod * i <NEWLINE> <DEDENT> print ( prod ) if ( prod <= 1000000000000000000 ) else print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> dic = { k : 0 for k in <STRING> } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> dic [ s [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> res = dic [ <STRING> ] * dic [ <STRING> ] * dic [ <STRING> ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : continue <NEWLINE> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : res -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> from scipy . special import comb <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> odd = [ ] <NEWLINE> even = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if aa [ i ] % 2 == 0 : <NEWLINE> <INDENT> even . append ( aa [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd . append ( aa [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = len ( odd ) <NEWLINE> y = len ( even ) <NEWLINE> <NL> <NL> sum1 = 0 <NEWLINE> for i in range ( 0 , x + 1 , 2 ) : <NEWLINE> <INDENT> sum1 += comb ( x , i ) <NEWLINE> <DEDENT> sum2 = 0 <NEWLINE> for i in range ( 1 , x + 1 , 2 ) : <NEWLINE> <INDENT> sum2 += comb ( x , i ) <NEWLINE> <NL> <DEDENT> if p == 0 : <NEWLINE> <INDENT> ans = int ( ( 2 ** y ) * sum1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( ( 2 ** y ) * sum2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> print ( len ( str ( n // i ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> cnt += n & 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return cnt <NEWLINE> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = n % popcount ( n ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> ones = X . count ( <STRING> ) <NEWLINE> MOD1 = ones + 1 <NEWLINE> MOD2 = ones - 1 <NEWLINE> pow1 = [ 1 ] * ( len ( X ) + 1 ) <NEWLINE> pow2 = [ 0 ] * ( len ( X ) + 1 ) <NEWLINE> if MOD2 != 0 : <NEWLINE> <INDENT> pow1 [ 0 ] = 1 <NEWLINE> pow2 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , len ( X ) + 1 ) : <NEWLINE> <INDENT> pow1 [ i ] = ( pow1 [ i - 1 ] * 2 ) % MOD1 <NEWLINE> pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , len ( X ) + 1 ) : <NEWLINE> <INDENT> pow1 [ i ] = ( pow1 [ i - 1 ] * 2 ) % MOD1 <NEWLINE> <NL> <DEDENT> <DEDENT> X1 = 0 <NEWLINE> X2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> X1 += pow1 [ N - i - 1 ] <NEWLINE> X2 += pow2 [ N - i - 1 ] <NEWLINE> <DEDENT> <DEDENT> X1 %= MOD1 <NEWLINE> if MOD2 != 0 : <NEWLINE> <INDENT> X2 %= MOD2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> d = N - i - 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> x = ( X1 + pow1 [ d ] ) % MOD1 <NEWLINE> print ( f ( x ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if MOD2 != 0 : <NEWLINE> <INDENT> x = ( X2 - pow2 [ d ] ) % MOD2 <NEWLINE> print ( f ( x ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> xre = x [ : : - 1 ] <NEWLINE> <NL> cou = x . count ( <STRING> ) <NEWLINE> <NL> if cou == 0 : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> if cou == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 and x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif x [ i ] == <STRING> and x [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif x [ i ] == <STRING> and x [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> basepl = int ( x , 2 ) % ( cou + 1 ) <NEWLINE> basemi = int ( x , 2 ) % ( cou - 1 ) <NEWLINE> <NL> li = [ 0 ] * n <NEWLINE> pl = 1 <NEWLINE> mi = 1 <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if xre [ i ] == <STRING> : <NEWLINE> <INDENT> li [ i ] = ( basepl + pl ) % ( cou + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ i ] = ( basemi - mi ) % ( cou - 1 ) <NEWLINE> <DEDENT> mi = ( mi * 2 ) % ( cou - 1 ) <NEWLINE> pl = ( pl * 2 ) % ( cou + 1 ) <NEWLINE> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> m = n <NEWLINE> k = 1 <NEWLINE> while m > 0 : <NEWLINE> <INDENT> co = str ( bin ( m ) ) . count ( <STRING> ) <NEWLINE> m = m % co <NEWLINE> k += 1 <NEWLINE> <DEDENT> return k <NEWLINE> <NL> <NL> <DEDENT> for x in li [ : : - 1 ] : <NEWLINE> <INDENT> print ( f ( x ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> l = list ( range ( 1 , m + 1 ) ) <NEWLINE> l = list ( itertools . combinations_with_replacement ( l , n ) ) <NEWLINE> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> kari = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if i [ abcd [ j ] [ 1 ] - 1 ] - i [ abcd [ j ] [ 0 ] - 1 ] == abcd [ j ] [ 2 ] : <NEWLINE> <INDENT> kari += abcd [ j ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , kari ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import random <NEWLINE> <NL> <NL> class Cube : <NEWLINE> <INDENT> def __init__ ( self , u , s , e , w , n , d ) : <NEWLINE> <INDENT> self . u = u <NEWLINE> self . s = s <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = n <NEWLINE> self . d = d <NEWLINE> <NL> <DEDENT> def rotate ( self , dic ) : <NEWLINE> <INDENT> if dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . s <NEWLINE> self . s = self . d <NEWLINE> self . d = self . n <NEWLINE> self . n = tmp <NEWLINE> <DEDENT> elif dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . w <NEWLINE> self . w = self . d <NEWLINE> self . d = self . e <NEWLINE> self . e = tmp <NEWLINE> <DEDENT> elif dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . e <NEWLINE> self . e = self . d <NEWLINE> self . d = self . w <NEWLINE> self . w = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . n <NEWLINE> self . n = self . d <NEWLINE> self . d = self . s <NEWLINE> self . s = tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> cubeL = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> u , s , e , w , n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cube = Cube ( u , s , e , w , n , d ) <NEWLINE> cubeL . append ( cube ) <NEWLINE> <NL> <DEDENT> ret = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for k in range ( 100 ) : <NEWLINE> <INDENT> cubeL [ j ] . rotate ( random . choice ( <STRING> ) ) <NEWLINE> if cubeL [ i ] . u == cubeL [ j ] . u and cubeL [ i ] . n == cubeL [ j ] . n and cubeL [ i ] . w == cubeL [ j ] . w and cubeL [ i ] . e == cubeL [ j ] . e and cubeL [ i ] . s == cubeL [ j ] . s and cubeL [ i ] . d == cubeL [ j ] . d : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> from itertools import count <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global counter <NEWLINE> n1 , n2 = mid - left , right - mid <NEWLINE> L , R = list ( A [ left : left + n1 ] + [ float ( <STRING> ) ] ) , list ( A [ mid : mid + n2 ] + [ float ( <STRING> ) ] ) <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> counter += right - left <NEWLINE> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 ; <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> counter = 0 <NEWLINE> mergeSort ( A , 0 , len ( A ) ) <NEWLINE> print ( * A ) <NEWLINE> print ( counter ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> num_data = sys . stdin . readlines ( ) <NEWLINE> str_num_list = num_data [ 1 ] . split ( ) <NEWLINE> num_list = [ int ( s ) for s in str_num_list ] <NEWLINE> ans = 1 <NEWLINE> if 0 in num_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( num_data [ 0 ] ) ) : <NEWLINE> <INDENT> ans *= num_list [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ANS = np . zeros ( N + 1 ) <NEWLINE> CR = np . zeros ( N + 1 ) <NEWLINE> CW = np . zeros ( N + 1 ) <NEWLINE> <NL> CR [ 0 ] = c . count ( <STRING> ) <NEWLINE> CW [ N ] = c . count ( <STRING> ) <NEWLINE> <NL> ANS [ 0 ] = c . count ( <STRING> ) <NEWLINE> ANS [ N ] = c . count ( <STRING> ) <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( c [ i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> CR [ i ] = CR [ i - 1 ] - 1 <NEWLINE> CW [ i ] = CW [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> CR [ i ] = CR [ i - 1 ] <NEWLINE> CW [ i ] = CW [ i - 1 ] + 1 <NEWLINE> <DEDENT> ANS [ i ] = max ( CR [ i ] , CW [ i ] ) <NEWLINE> <NL> <DEDENT> print ( int ( min ( ANS ) ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> val1 , val2 = a [ 0 ] , a [ 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if val1 % val2 == 0 : <NEWLINE> <INDENT> ans = a [ 0 ] * a [ 1 ] // val2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = val2 <NEWLINE> val2 = val1 % val2 <NEWLINE> val1 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> val1 , val2 = ans , a [ i ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if val1 % val2 == 0 : <NEWLINE> <INDENT> ans *= a [ i ] // val2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = val2 <NEWLINE> val2 = val1 % val2 <NEWLINE> val1 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> f_ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> f_ans += ( ans - 1 ) % a [ i ] <NEWLINE> <DEDENT> print ( int ( f_ans ) ) <NEWLINE> <NL> <NL>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if 0 < K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A < K < A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C_num = K - ( A + B ) <NEWLINE> print ( A - C_num ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while A >= B : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> i += 1 <NEWLINE> if A < B : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while B >= C : <NEWLINE> <INDENT> C = C * 2 <NEWLINE> i += 1 <NEWLINE> if B < C : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i > K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = 1000000000000000000 <NEWLINE> <NL> n = input ( ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <NL> <INDENT> o = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if o <= m : <NEWLINE> <INDENT> o = o * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if o > m : <NEWLINE> <INDENT> o = - 1 <NEWLINE> <NL> <DEDENT> print ( o ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> R , G , B = 0 , 0 , 0 <NEWLINE> <NL> for a in range ( 0 , K ) : <NEWLINE> <INDENT> if S [ a ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ a ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = R * G * B <NEWLINE> <NL> for i in range ( 0 , K ) : <NEWLINE> <INDENT> for j in range ( i , K ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < K : <NEWLINE> <INDENT> if S [ i ] != S [ k ] and S [ i ] != S [ j ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ None for _ in range ( m ) ] <NEWLINE> used = set ( ) <NEWLINE> a = 1 <NEWLINE> b = n <NEWLINE> good = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if b - a == n - ( b - a ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> ans [ i ] = ( a , b ) <NEWLINE> if ( b - a ) in used : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( b - a ) <NEWLINE> <DEDENT> if ( n - ( b - a ) ) in used : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( n - ( b - a ) ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <DEDENT> if not good : <NEWLINE> <INDENT> ans = [ None for _ in range ( m ) ] <NEWLINE> used = set ( ) <NEWLINE> a = 1 <NEWLINE> b = n - 1 <NEWLINE> good = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if b - a == n - ( b - a ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> ans [ i ] = ( a , b ) <NEWLINE> if ( b - a ) in used : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( b - a ) <NEWLINE> <DEDENT> if ( n - ( b - a ) ) in used : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( n - ( b - a ) ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if not good : <NEWLINE> <INDENT> ans = [ None for _ in range ( m ) ] <NEWLINE> used = set ( ) <NEWLINE> a = 1 <NEWLINE> b = n <NEWLINE> good = True <NEWLINE> dec = False <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if b - a == n - ( b - a ) : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> if not dec and ( ( b - a ) in used or ( n - ( b - a ) ) in used ) : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> ans [ i ] = ( a , b ) <NEWLINE> if ( b - a ) in used : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( b - a ) <NEWLINE> <DEDENT> if ( n - ( b - a ) ) in used : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used . add ( n - ( b - a ) ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( ans [ i ] [ 0 ] , ans [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> s = sum ( a ) % mod <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> ans += s * i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> s = ( s + a [ j ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> <DEDENT> ans = ( ans + ( a [ i ] * ( s ) ) % mod ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = collections . Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( x ) <NEWLINE> c . append ( y ) <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> tmp = d [ b [ i ] ] <NEWLINE> d [ b [ i ] ] = 0 <NEWLINE> d [ c [ i ] ] += tmp <NEWLINE> sum = sum - b [ i ] * tmp + tmp * c [ i ] <NEWLINE> print ( sum ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> dic = { } <NEWLINE> cntr = s . count ( <STRING> ) <NEWLINE> cntg = s . count ( <STRING> ) <NEWLINE> cntb = s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dic [ i ] = <STRING> <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dic [ i ] = <STRING> <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dic [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if 2 * j - i <= n - 1 : <NEWLINE> <INDENT> if dic [ i ] != dic [ j ] and dic [ i ] != dic [ 2 * j - i ] and dic [ j ] != dic [ 2 * j - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cntr * cntg * cntb - cnt ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <NL> <NL> <INDENT> if x [ i - K - 1 ] < x [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> k = 1 <NEWLINE> countlist = { } <NEWLINE> <COMMENT> <NL> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> k = A [ k - 1 ] <NEWLINE> <NL> if k in countlist : <NEWLINE> <INDENT> cycle = count - countlist [ k ] <NEWLINE> rest = K - count <NEWLINE> move = rest % cycle <NEWLINE> for i in range ( min ( rest , move ) ) : <NEWLINE> <INDENT> k = A [ k - 1 ] <NEWLINE> <DEDENT> print ( k ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> countlist [ k ] = count <NEWLINE> <NL> if count == K : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> d = { <STRING> : 7 , <STRING> : 6 , <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> print ( d [ S ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ False ] + [ True ] * n <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if h [ A [ i ] - 1 ] > h [ B [ i ] - 1 ] : <NEWLINE> <INDENT> p [ B [ i ] ] = False <NEWLINE> <DEDENT> if h [ A [ i ] - 1 ] < h [ B [ i ] - 1 ] : <NEWLINE> <INDENT> p [ A [ i ] ] = False <NEWLINE> <DEDENT> if h [ A [ i ] - 1 ] == h [ B [ i ] - 1 ] : <NEWLINE> <INDENT> p [ A [ i ] ] = False <NEWLINE> p [ B [ i ] ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ i for i in range ( n + 1 ) if p [ i ] ] <NEWLINE> <NL> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= int ( a [ i ] ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> if <STRING> in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> a = 0.5 * i * ( i - 1 ) <NEWLINE> b = 0.5 * i * ( 2 * n - i + 1 ) <NEWLINE> ans += ( b - a + 1 ) <NEWLINE> <DEDENT> print ( int ( ans % mod ) ) <NEWLINE>
def check ( P , w , n ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while s + w [ i ] <= P : <NEWLINE> <INDENT> s += w [ i ] <NEWLINE> i += 1 <NEWLINE> if i == n : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <DEDENT> s = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( s [ 0 ] ) <NEWLINE> k = int ( s [ 1 ] ) <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> w . append ( a ) <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = 100000 * 10000 <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = int ( ( right + left ) / 2 ) <NEWLINE> v = check ( mid , w , n ) <NEWLINE> if v >= n : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> C = [ [ 0 ] * l for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] [ j ] = str ( sum ( A [ i ] [ k ] * B [ k ] [ j ] for k in range ( m ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( C [ i ] ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in list1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in list1 : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> S2 = sum ( map ( lambda x : x * x , A ) ) <NEWLINE> <NL> print ( ( S * S - S2 ) // 2 % 1000000007 ) <NEWLINE>
N = input ( ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( l ) <NEWLINE> print ( <STRING> . format ( min ( l ) , max ( l ) , sum ( l ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for j in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> moji = s [ j : j + len ( t ) ] <NEWLINE> for k in range ( len ( t ) ) : <NEWLINE> <INDENT> if moji [ k ] != t [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( cnt ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if str ( k ) [ - 1 ] not in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> tmp = 7 % k <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if tmp == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = ( tmp * 10 + 7 ) % k <NEWLINE> i += 1 <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res += gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
X , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> if ( 2 * Y - X ) % 3 != 0 or ( 2 * X - Y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( 2 * Y - X ) < 0 or ( 2 * X - Y ) < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x = ( 2 * Y - X ) // 3 <NEWLINE> y = ( 2 * X - Y ) // 3 <NEWLINE> <COMMENT> <NL> fac = [ 0 for i in range ( x + y + 1 ) ] <NEWLINE> inv = [ 0 for i in range ( x + y + 1 ) ] <NEWLINE> finv = [ 0 for i in range ( x + y + 1 ) ] <NEWLINE> <COMMENT> <NL> p = 1000000007 <NEWLINE> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> for i in range ( 2 , x + y + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % p <NEWLINE> <COMMENT> <NL> inv [ i ] = ( - ( p // i ) * inv [ p % i ] ) % p <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % p <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ( fac [ x + y ] * finv [ x ] % p ) * finv [ y ] % p ) <NEWLINE> <NL> <NL>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ - 1 ] + p + [ 102 ] <NEWLINE> import bisect <NEWLINE> p . sort ( ) <NEWLINE> i = bisect . bisect_left ( p , x ) <NEWLINE> if p [ i ] != x : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for h in range ( 102 ) : <NEWLINE> <INDENT> if p [ i - h ] != x - h : <NEWLINE> <INDENT> print ( x - h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p [ i + h ] != x + h : <NEWLINE> <INDENT> print ( x + h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> r = a [ n - 1 ] <NEWLINE> l = 0 <NEWLINE> <NL> <NL> def calc ( t , x ) : <NEWLINE> <INDENT> return math . ceil ( t / x ) - 1 <NEWLINE> <NL> <NL> <DEDENT> while r - l > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> count += calc ( i , mid ) <NEWLINE> <DEDENT> if count > k : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = { } <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , int ( X ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> A . append ( [ i , X // i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> for a in range ( 1 , int ( X ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> b = a - i [ 0 ] <NEWLINE> if a ** 4 + a ** 3 * b + a ** 2 * b ** 2 + a * b ** 3 + b ** 4 == i [ 1 ] : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> sumN = sum ( int ( digit ) for digit in str ( N ) ) <NEWLINE> if sumN % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> <NL> p = 0 <NEWLINE> class N ( int ) : <NEWLINE> <INDENT> def __add__ ( self , n ) : <NEWLINE> <INDENT> return N ( ( int ( self ) + int ( n ) ) % p ) <NEWLINE> <DEDENT> def __sub__ ( self , n ) : <NEWLINE> <INDENT> return N ( ( int ( self ) - int ( n ) ) % p ) <NEWLINE> <DEDENT> def __mul__ ( self , n ) : <NEWLINE> <INDENT> return N ( ( int ( self ) * int ( n ) ) % p ) <NEWLINE> <DEDENT> def __floordiv__ ( self , n ) : <NEWLINE> <INDENT> if not n : <NEWLINE> <INDENT> raise ZeroDivisionError <NEWLINE> <DEDENT> return self * pow ( int ( n ) , p - 2 , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> p , s = s . split ( <STRING> ) <NEWLINE> p = int ( p ) <NEWLINE> if not p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> n = eval ( re . sub ( <STRING> , <STRING> , s ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( <STRING> % ( s , n , p ) ) <NEWLINE> <DEDENT> except ZeroDivisionError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def is_ok ( mid : int , target : int , ls : [ ] ) : <NEWLINE> <INDENT> return target <= ls [ mid ] <NEWLINE> <NL> <NL> <DEDENT> def bi_search ( target : int , ls : [ ] ) : <NEWLINE> <INDENT> ng = - 1 <NEWLINE> ok = len ( ls ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ng + int ( ( ok - ng ) / 2 ) <NEWLINE> cnt += 1 <NEWLINE> if is_ok ( mid , target , ls ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l_dic = { } <NEWLINE> r_dic = { } <NEWLINE> i = 0 <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> ld = l_dic . setdefault ( i + a , [ ] ) <NEWLINE> ld . append ( i ) <NEWLINE> rd = r_dic . setdefault ( i - a , [ ] ) <NEWLINE> rd . append ( i ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for rk , rv_list in r_dic . items ( ) : <NEWLINE> <INDENT> if rk not in l_dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> lv_list = l_dic [ rk ] <NEWLINE> for rv in rv_list : <NEWLINE> <INDENT> ind = bi_search ( rv , lv_list ) <NEWLINE> if ind == len ( lv_list ) : <NEWLINE> <INDENT> count += ind <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += ind + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if any ( [ n == 0 for n in a ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for n in a : <NEWLINE> <INDENT> ans *= n <NEWLINE> if ans > INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def calc_p ( a , b , c ) : <NEWLINE> <INDENT> u = { a , b , c } <NEWLINE> if len ( u ) == 3 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> if len ( u ) == 2 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> if len ( u ) == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def std_in ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def _main ( ) : <NEWLINE> <INDENT> N = int ( std_in ( ) ) <NEWLINE> fn = [ 0 ] * ( N + 1 ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> x_max = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_max = int ( math . sqrt ( N - 2 ) ) - 1 <NEWLINE> <NL> <DEDENT> n2 = [ i ** 2 for i in range ( 1 , x_max + 1 ) ] <NEWLINE> <NL> ij = [ [ 0 for _ in range ( 1 , x_max + 1 ) ] for _ in range ( 1 , x_max + 1 ) ] <NEWLINE> for i in range ( x_max ) : <NEWLINE> <INDENT> for j in range ( i , x_max ) : <NEWLINE> <INDENT> ij [ i ] [ j ] = ( i + 1 ) * ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( 1 , x_max + 1 ) : <NEWLINE> <INDENT> y_min = x <NEWLINE> x2 = n2 [ x - 1 ] <NEWLINE> for y in range ( y_min , x_max + 1 ) : <NEWLINE> <INDENT> z_min = y <NEWLINE> y2 = n2 [ y - 1 ] <NEWLINE> xy = ij [ x - 1 ] [ y - 1 ] <NEWLINE> tmp_n = x2 + xy + y2 <NEWLINE> if tmp_n > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( z_min , x_max + 1 ) : <NEWLINE> <INDENT> z2 = n2 [ z - 1 ] <NEWLINE> yz = ij [ y - 1 ] [ z - 1 ] <NEWLINE> zx = ij [ x - 1 ] [ z - 1 ] <NEWLINE> n = tmp_n + z2 + yz + zx <NEWLINE> if n > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> fn [ n ] += calc_p ( x , y , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( fn [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _main ( ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <NL> <DEDENT> for n in a : <NEWLINE> <INDENT> if temp == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> temp *= n <NEWLINE> if temp > 10 ** 18 : <NEWLINE> <INDENT> temp = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( temp ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i - a [ i ] in d : <NEWLINE> <INDENT> count += d [ i - a [ i ] ] <NEWLINE> <DEDENT> if i + a [ i ] in d : <NEWLINE> <INDENT> d [ i + a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( M ) ] <NEWLINE> h = [ 0 ] * H <NEWLINE> w = [ 0 ] * W <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h [ l [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> w [ l [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> maxh = max ( h ) <NEWLINE> maxw = max ( w ) <NEWLINE> hlist = [ ] <NEWLINE> wlist = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if h [ i ] == maxh : <NEWLINE> <INDENT> hlist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> if w [ i ] == maxw : <NEWLINE> <INDENT> wlist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if h [ l [ i ] [ 0 ] - 1 ] == maxh and w [ l [ i ] [ 1 ] - 1 ] == maxw : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( hlist ) * len ( wlist ) == c : <NEWLINE> <INDENT> print ( maxh + maxw - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxh + maxw ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( set ( q ) ) <NEWLINE> p = [ i for i in range ( - 2 , 102 ) ] <NEWLINE> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> p . remove ( q [ i ] ) <NEWLINE> <NL> <DEDENT> S = 103 <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if abs ( X - p [ i ] ) < S : <NEWLINE> <INDENT> ans = p [ i ] <NEWLINE> S = X - ans <NEWLINE> <DEDENT> elif abs ( X - p [ i ] ) == S : <NEWLINE> <INDENT> if p [ i ] < ans : <NEWLINE> <INDENT> ans = p [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tmp + R * G * B ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = int ( s ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> for num in range ( n ) : <NEWLINE> <INDENT> x *= num + 1 <NEWLINE> x = x % ( ( 1000000000 ) + 7 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( x ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> A = [ [ ] for i in range ( M ) ] <NEWLINE> resC = [ ] <NEWLINE> resA = list ( A ) <NEWLINE> <NL> NEW = 0 <NEWLINE> <NL> def update ( base ) : <NEWLINE> <COMMENT> <NL> <INDENT> if base == None : <NEWLINE> <INDENT> return NEW <NEWLINE> <DEDENT> return base + NEW <NEWLINE> <NL> <DEDENT> def check ( num ) : <NEWLINE> <INDENT> return num >= X <NEWLINE> <NL> <DEDENT> def check2 ( * args ) : <NEWLINE> <INDENT> res = True <NEWLINE> for val in args : <NEWLINE> <INDENT> buf = ( val >= X ) <NEWLINE> res = res and buf <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> buf = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( buf [ 0 ] ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> A [ j ] . append ( buf [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> NEW = C [ i ] <NEWLINE> resC = [ 0 , NEW ] <NEWLINE> resA = [ [ 0 , A [ j ] [ i ] ] for j in range ( M ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NEW = C [ i ] <NEWLINE> resC = resC + list ( map ( update , resC ) ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> NEW = A [ j ] [ i ] <NEWLINE> resA [ j ] = resA [ j ] + list ( map ( update , resA [ j ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = list ( map ( check2 , * resA ) ) <NEWLINE> <COMMENT> <NL> if sum ( res ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( np . asarray ( resC ) [ res ] ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> count = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> A = list ( input ( ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> S . append ( A ) <NEWLINE> <NL> <DEDENT> mas = deque ( [ ( 0 , 0 , 0 ) ] ) <NEWLINE> while mas : <NEWLINE> <INDENT> y , x , n = mas . popleft ( ) <NEWLINE> if 0 <= y <= H - 1 and 0 <= x <= W - 1 : <NEWLINE> <INDENT> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> S [ y ] [ x ] = n <NEWLINE> mas . append ( ( y + 1 , x , n + 1 ) ) <NEWLINE> mas . append ( ( y , x + 1 , n + 1 ) ) <NEWLINE> mas . append ( ( y - 1 , x , n + 1 ) ) <NEWLINE> mas . append ( ( y , x - 1 , n + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> short = S [ H - 1 ] [ W - 1 ] <NEWLINE> if short == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count - ( short + 1 ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> is_p = [ 1 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> <NL> for i in set ( a ) : <NEWLINE> <INDENT> v = i <NEWLINE> if is_p [ v ] : <NEWLINE> <INDENT> for j in range ( v + v , 10 ** 6 + 1 , v ) : <NEWLINE> <INDENT> is_p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = Counter ( a ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if is_p [ i ] == 1 and c [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> button = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> button [ i ] = int ( input ( ) ) - 1 <NEWLINE> <DEDENT> count , now = 0 , 0 <NEWLINE> <NL> while count <= N : <NEWLINE> <INDENT> now = button [ now ] <NEWLINE> count += 1 <NEWLINE> if now == 1 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> last_ok_postion = 0 <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ last_ok_postion ] >= P [ i ] : <NEWLINE> <INDENT> m = min ( P [ last_ok_postion : i ] ) <NEWLINE> if m >= P [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> last_ok_postion = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 1030302 <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> number = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> ans [ number ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ x ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : ( int ( x ) + 1 ) / 2 , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( p [ : k ] ) <NEWLINE> ans = s <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> s -= p [ i - k ] <NEWLINE> s += p [ i ] <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = sum ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c = c - a [ i ] <NEWLINE> ans += a [ i ] * c <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> ans = B [ N // 2 ] - A [ N // 2 ] + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( A [ N // 2 - 1 ] + A [ N // 2 ] ) <NEWLINE> b = ( B [ N // 2 - 1 ] + B [ N // 2 ] ) <NEWLINE> print ( b - a + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = x ^ a [ i ] <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = a [ i ] ^ x <NEWLINE> if i < n - 1 : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Cnt = [ 0 for i in range ( 10 ** 6 + 8 ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if Cnt [ i ] != 0 : <NEWLINE> <INDENT> Cnt [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> for j in range ( i , 10 ** 6 + 8 , i ) : <NEWLINE> <INDENT> Cnt [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if Cnt [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( n - 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> t = i + 1 <NEWLINE> u = j + 1 <NEWLINE> H = min ( abs ( u - t ) , abs ( t - x ) + 1 + abs ( y - u ) , abs ( t - y ) + 1 + abs ( x - u ) ) <NEWLINE> ans [ H - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for l in ans : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> n = int ( readline ( ) ) <NEWLINE> <NL> ls = [ ] <NEWLINE> rs = [ ] <NEWLINE> <NL> total = 0 <NEWLINE> S = list ( map ( lambda x : x . strip ( ) . decode ( ) , readlines ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> <NL> b = 0 <NEWLINE> h = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h -= 1 <NEWLINE> b = min ( b , h ) <NEWLINE> <NL> <DEDENT> <DEDENT> if h >= 0 : <NEWLINE> <INDENT> ls . append ( ( b , h ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rs . append ( ( b - h , - h ) ) <NEWLINE> <DEDENT> total += h <NEWLINE> <NL> <DEDENT> if total != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ls = sorted ( ls , reverse = True ) <NEWLINE> rs = sorted ( rs , reverse = True ) <NEWLINE> <NL> h = 0 <NEWLINE> OK = True <NEWLINE> for p in ls : <NEWLINE> <INDENT> b = h + p [ 0 ] <NEWLINE> h += p [ 1 ] <NEWLINE> if b < 0 : <NEWLINE> <INDENT> OK = False <NEWLINE> <NL> <DEDENT> <DEDENT> h = 0 <NEWLINE> for p in rs : <NEWLINE> <INDENT> b = h + p [ 0 ] <NEWLINE> h += p [ 1 ] <NEWLINE> if b < 0 or h < 0 : <NEWLINE> <INDENT> OK = False <NEWLINE> <NL> <DEDENT> <DEDENT> if not OK : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> rhombus = rectangle = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c = map ( int , line . split ( <STRING> ) ) <NEWLINE> if c ** 2 == a ** 2 + b ** 2 : <NEWLINE> <INDENT> rectangle += 1 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> rhombus += 1 <NEWLINE> <DEDENT> <DEDENT> print ( rectangle ) <NEWLINE> print ( rhombus ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , num : int ) : <NEWLINE> <INDENT> self . r = [ - 1 for i in range ( num ) ] <NEWLINE> <DEDENT> def root ( self , x : int ) : <NEWLINE> <INDENT> if ( self . r [ x ] < 0 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . r [ x ] = self . root ( self . r [ x ] ) <NEWLINE> return self . r [ x ] <NEWLINE> <DEDENT> def unite ( self , x : int , y : int ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if ( rx == ry ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( self . r [ rx ] > self . r [ ry ] ) : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> <DEDENT> self . r [ rx ] += self . r [ ry ] <NEWLINE> self . r [ ry ] = rx <NEWLINE> return True <NEWLINE> <DEDENT> def size ( self , x : int ) : <NEWLINE> <INDENT> return - self . r [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> group = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> group . unite ( A - 1 , B - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , group . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = <STRING> * W <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ defaultdict ( lambda : - float ( <STRING> ) ) for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : dp [ i ] [ 0 ] = 0 <NEWLINE> for i , a in enumerate ( a ) : <NEWLINE> <INDENT> for j in range ( n // 2 - ( n - i ) // 2 , i // 2 + 2 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 2 ] [ j ] , dp [ i - 2 ] [ j - 1 ] + a , dp [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ n // 2 ] ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> def List ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def Num ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> x , k , d = List ( ) <NEWLINE> x = abs ( x ) <NEWLINE> if d * k > x : <NEWLINE> <INDENT> distance = x % d <NEWLINE> do = k - ( x // d ) <NEWLINE> if do & 1 : <NEWLINE> <INDENT> print ( d - distance ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( distance ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if n == m == 0 : break <NEWLINE> D = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> d_i , p_i = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> D . append ( ( d_i , p_i ) ) <NEWLINE> <DEDENT> D = sorted ( D , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> while m > 0 : <NEWLINE> <INDENT> if len ( D ) == 0 : break <NEWLINE> temp = D . pop ( 0 ) <NEWLINE> if temp [ 0 ] > m : <NEWLINE> <INDENT> temp = ( temp [ 0 ] - m , temp [ 1 ] ) <NEWLINE> m = 0 <NEWLINE> D . append ( temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m -= temp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in D : <NEWLINE> <INDENT> ans += i [ 0 ] * i [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> cnt = [ 0 ] * n <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a , b = ab [ j ] <NEWLINE> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> cnt [ a - 1 ] -= 1 <NEWLINE> <DEDENT> elif h [ b - 1 ] < h [ a - 1 ] : <NEWLINE> <INDENT> cnt [ b - 1 ] -= 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> cnt [ a - 1 ] -= 1 <NEWLINE> cnt [ b - 1 ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return cnt . count ( 0 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flg = 0 <NEWLINE> max = 10 ** 18 + 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> <DEDENT> if ans // max > 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg != 0 and ans != 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = N % 1000 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - N % 1000 ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> x = int ( a [ 0 ] ) <NEWLINE> y = int ( a [ 1 ] ) <NEWLINE> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pro = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> pro = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if pro > 10 ** 18 : <NEWLINE> <INDENT> pro = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pro = pro * i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if pro > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pro ) <NEWLINE> <DEDENT>
import os <NEWLINE> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> <NL> N = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> row_or = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> col_or = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> right = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> down = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> row_or = np . array ( row_or , dtype = bool ) <NEWLINE> row_and = ~ row_or <NEWLINE> col_or = np . array ( col_or , dtype = bool ) <NEWLINE> col_and = ~ col_or <NEWLINE> right = np . array ( right , dtype = <STRING> ) <NEWLINE> down = np . array ( down , dtype = <STRING> ) <NEWLINE> <NL> <NL> def solve ( right , down ) : <NEWLINE> <INDENT> ret = np . full ( ( N , N ) , 7 , dtype = <STRING> ) <NEWLINE> yet_rows = [ ] <NEWLINE> yet_cols = [ ] <NEWLINE> used = [ False ] * 2 <NEWLINE> for r in range ( N ) : <NEWLINE> <INDENT> if row_or [ r ] and right [ r ] == 0 : <NEWLINE> <INDENT> ret [ r , : ] = 0 <NEWLINE> used [ 0 ] = True <NEWLINE> <DEDENT> elif row_and [ r ] and right [ r ] == 1 : <NEWLINE> <INDENT> ret [ r , : ] = 1 <NEWLINE> used [ 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yet_rows . append ( r ) <NEWLINE> <DEDENT> <DEDENT> for c in range ( N ) : <NEWLINE> <INDENT> if col_or [ c ] and down [ c ] == 0 : <NEWLINE> <INDENT> ret [ : , c ] = 0 <NEWLINE> used [ 0 ] = True <NEWLINE> <DEDENT> elif col_and [ c ] and down [ c ] == 1 : <NEWLINE> <INDENT> ret [ : , c ] = 1 <NEWLINE> used [ 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yet_cols . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( yet_cols ) == 1 : <NEWLINE> <INDENT> c = yet_cols [ 0 ] <NEWLINE> if not used [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ret [ yet_rows , c ] = 0 <NEWLINE> if down [ c ] == 1 : <NEWLINE> <INDENT> for r in yet_rows : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if row_or [ r ] and right [ r ] == 1 : <NEWLINE> <INDENT> ret [ r , c ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif not used [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ret [ yet_rows , c ] = 1 <NEWLINE> if down [ c ] == 0 : <NEWLINE> <INDENT> for r in yet_rows : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if row_and [ r ] and right [ r ] == 0 : <NEWLINE> <INDENT> ret [ r , c ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ret [ yet_rows , c ] = np . arange ( len ( yet_rows ) , dtype = int ) % 2 <NEWLINE> <DEDENT> <DEDENT> elif len ( yet_rows ) == 1 : <NEWLINE> <INDENT> r = yet_rows [ 0 ] <NEWLINE> if not used [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ret [ r , yet_cols ] = 0 <NEWLINE> if right [ r ] == 1 : <NEWLINE> <INDENT> for c in yet_cols : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if col_or [ c ] and down [ c ] == 1 : <NEWLINE> <INDENT> ret [ r , c ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif not used [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ret [ r , yet_cols ] = 1 <NEWLINE> if right [ r ] == 0 : <NEWLINE> <INDENT> for c in yet_cols : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if col_and [ c ] and down [ c ] == 0 : <NEWLINE> <INDENT> ret [ r , c ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ret [ r , yet_cols ] = np . arange ( len ( yet_cols ) , dtype = int ) % 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> for i , r in enumerate ( yet_rows ) : <NEWLINE> <INDENT> ret [ r , yet_cols ] = ( np . arange ( len ( yet_cols ) , dtype = int ) + i ) % 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ok = True <NEWLINE> for r in range ( N ) : <NEWLINE> <INDENT> if row_and [ r ] : <NEWLINE> <INDENT> if right [ r ] == 1 : <NEWLINE> <INDENT> ok &= np . all ( ret [ r , : ] == 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok &= np . any ( ret [ r , : ] == 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if right [ r ] == 1 : <NEWLINE> <INDENT> ok &= np . any ( ret [ r , : ] == 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok &= np . all ( ret [ r , : ] == 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for c in range ( N ) : <NEWLINE> <INDENT> if col_and [ c ] : <NEWLINE> <INDENT> if down [ c ] == 1 : <NEWLINE> <INDENT> ok &= np . all ( ret [ : , c ] == 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok &= np . any ( ret [ : , c ] == 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if down [ c ] == 1 : <NEWLINE> <INDENT> ok &= np . any ( ret [ : , c ] == 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok &= np . all ( ret [ : , c ] == 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> assert np . all ( ret <= 1 ) <NEWLINE> return ret & 1 , ok <NEWLINE> <NL> <NL> <DEDENT> ans = np . zeros ( ( N , N ) , dtype = <STRING> ) <NEWLINE> for i in range ( 64 ) : <NEWLINE> <INDENT> bits , ok = solve ( right >> i & 1 , down >> i & 1 ) <NEWLINE> if not ok : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans |= bits << i <NEWLINE> <NL> <DEDENT> for row in ans : <NEWLINE> <INDENT> print ( * row ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = set ( input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = set ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( len ( S & T ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( 1 , int ( N ** ( 1 / 2 ) ) + 2 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> a = max ( a , i ) <NEWLINE> <DEDENT> <DEDENT> print ( a + N // a - 2 ) <NEWLINE>
import sys <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 100 ) : <NEWLINE> <INDENT> if ( x - i ) not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( x + i ) not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans , ansf = 1 , n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = max ( ans , l ) <NEWLINE> ansf = min ( ansf , r ) <NEWLINE> <NL> <DEDENT> if ansf - ans < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ansf - ans + 1 ) <NEWLINE> <DEDENT>
dice = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mask = { <NEWLINE> <INDENT> <STRING> : ( 1 , 5 , 2 , 3 , 0 , 4 ) , <NEWLINE> <STRING> : ( 0 , 2 , 4 , 1 , 3 , 5 ) <NEWLINE> } <NEWLINE> <NL> <NL> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lim = 0 <NEWLINE> while dice [ 0 ] != a : <NEWLINE> <INDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> lim += 1 <NEWLINE> if lim == 4 : <NEWLINE> <INDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> lim = 0 <NEWLINE> <DEDENT> <DEDENT> while dice [ 1 ] != b : <NEWLINE> <INDENT> dice = [ dice [ x ] for x in mask [ <STRING> ] ] <NEWLINE> <DEDENT> print ( dice [ 2 ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> i = 1 <NEWLINE> for a in sys . stdin : <NEWLINE> <INDENT> a = a . strip ( ) <NEWLINE> if a == <STRING> : break <NEWLINE> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def leap_year ( y ) : <NEWLINE> <INDENT> return y % 4 == 0 and ( y % 100 != 0 or y % 400 == 0 ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> first = True <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a , b = list ( map ( int , line . split ( ) ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if first : <NEWLINE> <INDENT> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT> f = False <NEWLINE> for y in range ( a , b + 1 ) : <NEWLINE> <INDENT> if leap_year ( y ) : <NEWLINE> <INDENT> print ( y ) <NEWLINE> f = True <NEWLINE> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( n ) ] <NEWLINE> ans = collections . Counter ( S ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
x , k , d = input ( ) . split ( ) <NEWLINE> x = abs ( int ( x ) ) <NEWLINE> k = int ( k ) <NEWLINE> d = int ( d ) <NEWLINE> a = x // d <NEWLINE> b = x - a * d <NEWLINE> c = ( x - b ) / d <NEWLINE> i = int ( c ) <NEWLINE> if k <= i : <NEWLINE> <INDENT> print ( abs ( x ) - d * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - ( i ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) - d * ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - d * ( i + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> XYU = [ list ( input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> dis = 10 ** 19 <NEWLINE> <NL> <COMMENT> <NL> box = { <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) } <NEWLINE> <NL> for x , y , u in XYU : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> if u in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> box [ u ] [ x ] . append ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> box [ u ] [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k1 in box . keys ( ) : <NEWLINE> <INDENT> for k2 in box [ k1 ] . keys ( ) : <NEWLINE> <INDENT> box [ k1 ] [ k2 ] = sorted ( box [ k1 ] [ k2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in box [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> if k in box [ <STRING> ] : <NEWLINE> <INDENT> for pos in v : <NEWLINE> <INDENT> if pos < box [ <STRING> ] [ k ] [ - 1 ] : <NEWLINE> <INDENT> a = bisect_right ( box [ <STRING> ] [ k ] , pos ) <NEWLINE> dis = min ( dis , ( box [ <STRING> ] [ k ] [ a ] - pos ) * 10 // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k , v in box [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> if k in box [ <STRING> ] : <NEWLINE> <INDENT> for pos in v : <NEWLINE> <INDENT> if pos < box [ <STRING> ] [ k ] [ - 1 ] : <NEWLINE> <INDENT> a = bisect_right ( box [ <STRING> ] [ k ] , pos ) <NEWLINE> dis = min ( dis , ( box [ <STRING> ] [ k ] [ a ] - pos ) * 10 // 2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cox = { <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) } <NEWLINE> <NL> for x , y , u in XYU : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> cox [ u ] [ x + y ] . append ( x ) <NEWLINE> <NL> <DEDENT> for k1 in cox . keys ( ) : <NEWLINE> <INDENT> for k2 in cox [ k1 ] . keys ( ) : <NEWLINE> <INDENT> cox [ k1 ] [ k2 ] = sorted ( cox [ k1 ] [ k2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in cox [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> if k in cox [ <STRING> ] : <NEWLINE> <INDENT> for pos in v : <NEWLINE> <INDENT> if pos < cox [ <STRING> ] [ k ] [ - 1 ] : <NEWLINE> <INDENT> a = bisect_right ( cox [ <STRING> ] [ k ] , pos ) <NEWLINE> dis = min ( dis , ( cox [ <STRING> ] [ k ] [ a ] - pos ) * 10 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k , v in cox [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> if k in cox [ <STRING> ] : <NEWLINE> <INDENT> for pos in v : <NEWLINE> <INDENT> if pos < cox [ <STRING> ] [ k ] [ - 1 ] : <NEWLINE> <INDENT> a = bisect_right ( cox [ <STRING> ] [ k ] , pos ) <NEWLINE> dis = min ( dis , ( cox [ <STRING> ] [ k ] [ a ] - pos ) * 10 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dox = { <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) , <STRING> : defaultdict ( list ) } <NEWLINE> <NL> for x , y , u in XYU : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> dox [ u ] [ x - y ] . append ( x ) <NEWLINE> <NL> <DEDENT> for k1 in dox . keys ( ) : <NEWLINE> <INDENT> for k2 in dox [ k1 ] . keys ( ) : <NEWLINE> <INDENT> dox [ k1 ] [ k2 ] = sorted ( dox [ k1 ] [ k2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in dox [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> if k in dox [ <STRING> ] : <NEWLINE> <INDENT> for pos in v : <NEWLINE> <INDENT> if pos < dox [ <STRING> ] [ k ] [ - 1 ] : <NEWLINE> <INDENT> a = bisect_right ( dox [ <STRING> ] [ k ] , pos ) <NEWLINE> dis = min ( dis , ( dox [ <STRING> ] [ k ] [ a ] - pos ) * 10 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k , v in dox [ <STRING> ] . items ( ) : <NEWLINE> <INDENT> if k in dox [ <STRING> ] : <NEWLINE> <INDENT> for pos in v : <NEWLINE> <INDENT> if pos < dox [ <STRING> ] [ k ] [ - 1 ] : <NEWLINE> <INDENT> a = bisect_right ( dox [ <STRING> ] [ k ] , pos ) <NEWLINE> dis = min ( dis , ( dox [ <STRING> ] [ k ] [ a ] - pos ) * 10 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dis == 10 ** 19 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dis ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> counter = set ( [ ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> si = input ( ) <NEWLINE> if si not in counter : <NEWLINE> <INDENT> counter . add ( si ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( counter ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> t = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] - i in t : <NEWLINE> <INDENT> ans += t [ A [ i ] - i ] <NEWLINE> <DEDENT> t . setdefault ( - A [ i ] - i , 0 ) <NEWLINE> t [ - A [ i ] - i ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pos = bisect_left ( x , 0 ) <NEWLINE> if pos < len ( x ) and x [ pos ] == 0 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . insert ( pos , 0 ) <NEWLINE> <NL> <DEDENT> l = pos <NEWLINE> r = pos + k <NEWLINE> <NL> if r >= len ( x ) : <NEWLINE> <INDENT> diff = r - len ( x ) + 1 <NEWLINE> l -= diff <NEWLINE> r -= diff <NEWLINE> <NL> <DEDENT> ans = min ( abs ( x [ l ] ) , x [ r ] ) * 2 + max ( abs ( x [ l ] ) , x [ r ] ) <NEWLINE> <NL> while r >= pos : <NEWLINE> <INDENT> if l < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> dist = min ( abs ( x [ l ] ) , x [ r ] ) * 2 + max ( abs ( x [ l ] ) , x [ r ] ) <NEWLINE> if dist < ans : <NEWLINE> <INDENT> ans = dist <NEWLINE> <NL> <DEDENT> l -= 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def cal ( b , e ) : <NEWLINE> <INDENT> return ( ( b + ( e // b ) * b ) * ( e // b ) ) // 2 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += cal ( i , n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> if l < a or a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l / a == 2 or l / a == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> f = a * 4 <NEWLINE> if f > l : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> f = f - 2 <NEWLINE> if f == l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n + 1 ) : <COMMENT> <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> a [ i ] = int ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def have_ABC_string ( n , str ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if str [ i ] == <STRING> and str [ i + 1 ] == <STRING> and str [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> result = have_ABC_string ( N , S ) <NEWLINE> print ( result ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hk = [ [ 0 , i ] for i in range ( H + 1 ) ] <NEWLINE> wk = [ [ 0 , j ] for j in range ( W + 1 ) ] <NEWLINE> s = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> hk [ h ] [ 0 ] += 1 <NEWLINE> wk [ w ] [ 0 ] += 1 <NEWLINE> s . add ( ( h , w ) ) <NEWLINE> <DEDENT> hk . sort ( reverse = True ) <NEWLINE> wk . sort ( reverse = True ) <NEWLINE> colmax = wk [ 0 ] [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for lowacc , i in hk : <NEWLINE> <INDENT> if lowacc + colmax <= ans : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for colacc , j in wk : <NEWLINE> <INDENT> if lowacc + colacc <= ans : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , lowacc + colacc - ( ( i , j ) in s ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> x1 = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x2 = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if x2 [ i ] == x1 [ 0 ] : <NEWLINE> <INDENT> count = i <NEWLINE> if x2 [ 5 - i ] == x1 [ 5 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if x2 [ count ] == x1 [ 0 ] and x2 [ 5 - count ] == x1 [ 5 ] : <NEWLINE> <INDENT> if count == 0 or count == 5 : <NEWLINE> <INDENT> if count == 5 : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> x2 [ 1 ] , x2 [ 0 ] = x2 [ 0 ] , x2 [ 1 ] <NEWLINE> x2 [ 5 ] , x2 [ 1 ] = x2 [ 1 ] , x2 [ 5 ] <NEWLINE> x2 [ 4 ] , x2 [ 5 ] = x2 [ 5 ] , x2 [ 4 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if count == 1 or count == 4 : <NEWLINE> <INDENT> while x1 [ 0 ] != x2 [ 0 ] or x1 [ 5 ] != x2 [ 5 ] : <NEWLINE> <INDENT> x2 [ 1 ] , x2 [ 0 ] = x2 [ 0 ] , x2 [ 1 ] <NEWLINE> x2 [ 5 ] , x2 [ 1 ] = x2 [ 1 ] , x2 [ 5 ] <NEWLINE> x2 [ 4 ] , x2 [ 5 ] = x2 [ 5 ] , x2 [ 4 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while x1 [ 0 ] != x2 [ 0 ] or x1 [ 5 ] != x2 [ 5 ] : <NEWLINE> <INDENT> x2 [ 3 ] , x2 [ 0 ] = x2 [ 0 ] , x2 [ 3 ] <NEWLINE> x2 [ 5 ] , x2 [ 3 ] = x2 [ 3 ] , x2 [ 5 ] <NEWLINE> x2 [ 2 ] , x2 [ 5 ] = x2 [ 5 ] , x2 [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if x2 [ 2 ] == x1 [ 2 ] and x2 [ 3 ] == x1 [ 3 ] and x2 [ 4 ] == x1 [ 4 ] and x2 [ 1 ] == x1 [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x2 [ 1 ] , x2 [ 2 ] = x2 [ 2 ] , x2 [ 1 ] <NEWLINE> x2 [ 2 ] , x2 [ 4 ] = x2 [ 4 ] , x2 [ 2 ] <NEWLINE> x2 [ 4 ] , x2 [ 3 ] = x2 [ 3 ] , x2 [ 4 ] <NEWLINE> <DEDENT> if i == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> points = [ k ] * ( n + 1 ) <NEWLINE> plus = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> plus [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> points [ i ] = points [ i ] - q + plus [ i ] <NEWLINE> if points [ i ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> num = [ ] <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> H , W = i . split ( ) <NEWLINE> if H == W == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num . append ( ( int ( H ) , int ( W ) ) ) <NEWLINE> <NL> <DEDENT> for cnt in range ( len ( num ) ) : <NEWLINE> <INDENT> for h in range ( num [ cnt ] [ 0 ] ) : <NEWLINE> <INDENT> for w in range ( num [ cnt ] [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def area ( ls ) : <NEWLINE> <INDENT> return ls [ 0 ] * ls [ 1 ] <NEWLINE> <NL> <DEDENT> def per ( ls ) : <NEWLINE> <INDENT> return ( 2 * ls [ 0 ] ) + ( 2 * ls [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = area ( data ) <NEWLINE> l = per ( data ) <NEWLINE> print ( s , l ) <NEWLINE> <DEDENT>
import time <NEWLINE> X = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> T_0 = time . time ( ) <NEWLINE> <NL> A = 0 <NEWLINE> B = 0 <NEWLINE> for a in range ( 2000 ) : <NEWLINE> <INDENT> for b in range ( 2000 ) : <NEWLINE> <INDENT> if ( a - 1000 ) ** 5 - ( b - 1000 ) ** 5 == X : <NEWLINE> <INDENT> flag = 1 <NEWLINE> A = a - 1000 <NEWLINE> B = b - 1000 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> T_1 = time . time ( ) <NEWLINE> <NL> print ( A , B ) <NEWLINE>
n = 1000000 <NEWLINE> p = [ 1 ] * ( n + 1 ) <NEWLINE> p [ 0 ] , p [ 1 ] = 0 , 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = [ i for i in range ( n + 1 ) if p [ i ] == 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : n = int ( input ( ) ) <NEWLINE> except : break <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] == n : <NEWLINE> <INDENT> print ( p [ i - 1 ] , p [ i + 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif p [ i ] > n : <NEWLINE> <INDENT> print ( p [ i - 1 ] , p [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def f ( l ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for li in l : <NEWLINE> <INDENT> res = res * li <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> sc = [ ] <NEWLINE> alr = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> if i == k - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> first = al [ i - k + 1 ] <NEWLINE> alr = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> last = al [ i ] <NEWLINE> if last > first : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> first = al [ i - k + 1 ] <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> while True : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = deque ( int ( input ( ) ) for _ in range ( k ) ) <NEWLINE> ans = tmp = sum ( a ) <NEWLINE> for _ in range ( n - k ) : <NEWLINE> <INDENT> x = a . popleft ( ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> a . append ( y ) <NEWLINE> tmp += y - x <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> v = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v *= a [ i ] <NEWLINE> if v > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if v > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ str ( input ( ) ) for i in range ( n ) ] <NEWLINE> lis = [ a , b , c ] <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if lis [ ord ( s [ i ] [ 0 ] ) - ord ( <STRING> ) ] == 0 and lis [ ord ( s [ i ] [ 1 ] ) - ord ( <STRING> ) ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> if lis [ ord ( s [ i ] [ 0 ] ) - ord ( <STRING> ) ] == 0 : <NEWLINE> <INDENT> ans += s [ i ] [ 0 ] <NEWLINE> lis [ ord ( s [ i ] [ 0 ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> lis [ ord ( s [ i ] [ 1 ] ) - ord ( <STRING> ) ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ i ] [ 1 ] <NEWLINE> lis [ ord ( s [ i ] [ 0 ] ) - ord ( <STRING> ) ] -= 1 <NEWLINE> lis [ ord ( s [ i ] [ 1 ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if lis [ 1 ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 1 ] += 1 <NEWLINE> lis [ 0 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 0 ] += 1 <NEWLINE> lis [ 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if lis [ 0 ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 0 ] += 1 <NEWLINE> lis [ 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 0 ] -= 1 <NEWLINE> lis [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if lis [ 2 ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 2 ] += 1 <NEWLINE> lis [ 0 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 0 ] += 1 <NEWLINE> lis [ 2 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if lis [ 0 ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 0 ] += 1 <NEWLINE> lis [ 2 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 0 ] -= 1 <NEWLINE> lis [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if lis [ 2 ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 2 ] += 1 <NEWLINE> lis [ 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 2 ] -= 1 <NEWLINE> lis [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if lis [ 1 ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 1 ] += 1 <NEWLINE> lis [ 2 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> lis [ 2 ] += 1 <NEWLINE> lis [ 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if lis [ ord ( s [ - 1 ] [ 0 ] ) - ord ( <STRING> ) ] == 0 : <NEWLINE> <INDENT> if lis [ ord ( s [ - 1 ] [ 1 ] ) - ord ( <STRING> ) ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ - 1 ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ - 1 ] [ 1 ] <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> strN = input ( ) <NEWLINE> splN = list ( strN ) <NEWLINE> intN = [ int ( s ) for s in splN ] <NEWLINE> sumN = sum ( intN ) <NEWLINE> if sumN % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * pi * r ) ) <NEWLINE>
import re <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = <STRING> <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = input ( ) . split ( ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> a = max ( [ len ( x ) for x in re . findall ( <STRING> , s ) ] ) <NEWLINE> if a >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def circum ( x1 , y1 , x2 , y2 , x3 , y3 ) : <NEWLINE> <INDENT> a1 = 2 * ( x2 - x1 ) <NEWLINE> b1 = 2 * ( y2 - y1 ) <NEWLINE> c1 = x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2 <NEWLINE> a2 = 2 * ( x3 - x1 ) <NEWLINE> b2 = 2 * ( y3 - y1 ) <NEWLINE> c2 = x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2 <NEWLINE> X = ( b1 * c2 - b2 * c1 ) / ( a1 * b2 - a2 * b1 ) <NEWLINE> Y = ( c1 * a2 - c2 * a1 ) / ( a1 * b2 - a2 * b1 ) <NEWLINE> R = ( ( x1 - X ) ** 2 + ( y1 - Y ) ** 2 ) ** 0.5 <NEWLINE> return map ( lambda n : round ( n , 3 ) , [ X , Y , R ] ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( circum ( * list ( map ( float , input ( ) . split ( ) ) ) ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( * ans [ i ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> t = [ True ] * ( n + 1 ) <NEWLINE> l = n // 2 - 1 <NEWLINE> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> if l <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not t [ i ] or not t [ i + l ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans . append ( [ i , i + l ] ) <NEWLINE> t [ i ] = False <NEWLINE> t [ i + l ] = False <NEWLINE> l -= 2 <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> l = n // 2 <NEWLINE> for i in range ( n // 2 , n ) : <NEWLINE> <INDENT> if l <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not t [ i ] or not t [ i + l ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans . append ( [ i , i + l ] ) <NEWLINE> t [ i ] = False <NEWLINE> t [ i + l ] = False <NEWLINE> l -= 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = n // 2 - 2 <NEWLINE> for i in range ( n // 2 , n ) : <NEWLINE> <INDENT> if l <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not t [ i ] or not t [ i + l ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans . append ( [ i , i + l ] ) <NEWLINE> t [ i ] = False <NEWLINE> t [ i + l ] = False <NEWLINE> l -= 2 <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( ans [ i ] [ 0 ] , ans [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> h = math . floor ( S / 3600 ) <NEWLINE> m = math . floor ( ( S - h * 3600 ) / 60 ) <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> <NL> print ( h , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( m , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( s ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Scc = min ( n , m // 2 ) <NEWLINE> cccc = ( m - Scc * 2 ) // 4 <NEWLINE> print ( Scc + cccc ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> anslist = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> anslist [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in anslist : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1e19 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> tate = W * i <COMMENT> <NEWLINE> <COMMENT> <NL> if i < H - 1 : <NEWLINE> <INDENT> mini = W * ( ( H - i ) // 2 ) <COMMENT> <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( tate , mini , H * W - mini - tate ) - min ( tate , mini , H * W - mini - tate ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mini = ( H - i ) * ( W // 2 ) <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( tate , mini , H * W - tate - mini ) - min ( tate , mini , H * W - tate - mini ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , W ) : <NEWLINE> <INDENT> yoko = H * i <NEWLINE> if i < W - 1 : <NEWLINE> <INDENT> mini = H * ( ( W - i ) // 2 ) <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( yoko , mini , H * W - mini - yoko ) - min ( yoko , mini , H * W - yoko - mini ) ) <NEWLINE> <DEDENT> mini = ( W - i ) * ( H // 2 ) <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( yoko , mini , H * W - yoko - mini ) - min ( yoko , mini , H * W - yoko - mini ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sample = input ( ) <NEWLINE> S . append ( sample ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> base = map ( int , input ( ) . split ( ) ) <NEWLINE> c = collections . Counter ( base ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 0 : print ( 1 ) <NEWLINE> else : print ( 0 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> low = 0 <NEWLINE> high = max ( A ) <NEWLINE> while high - low > 1 : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> cnt += ( i - 1 ) // mid <NEWLINE> <DEDENT> if cnt > K : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> print ( high ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> X = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X *= A [ i ] <NEWLINE> if X > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> l = [ ] <NEWLINE> if len ( S ) != len ( T ) : <NEWLINE> <INDENT> for i in range ( len ( S ) - len ( T ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] != S [ i + j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if T [ i ] != S [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if mem [ a ] [ b ] : <NEWLINE> <INDENT> return mem [ a ] [ b ] <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> mem [ a ] [ b ] = gcd ( b , a % b ) <NEWLINE> return mem [ a ] [ b ] <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> mem = [ [ 0 for a in range ( k + 1 ) ] for b in range ( k + 1 ) ] <NEWLINE> n = k + 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> d = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <INDENT> ans += gcd ( d , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> def bfs ( u ) : <NEWLINE> <INDENT> queue = deque ( [ u ] ) <NEWLINE> d = [ - 1 ] * n <NEWLINE> pre = [ - 1 ] * n <NEWLINE> d [ u ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> if d [ i ] is - 1 : <NEWLINE> <INDENT> if pre [ i ] == - 1 : <NEWLINE> <INDENT> pre [ i ] = v <NEWLINE> <DEDENT> d [ i ] = d [ v ] + 1 <NEWLINE> queue . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d , pre <NEWLINE> <DEDENT> d , pre = bfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( pre [ i ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( N // i ) * ( ( N // i ) + 1 ) * i / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B . sort ( ) <NEWLINE> <NL> print ( sum ( B [ : A [ 1 ] ] ) ) <NEWLINE>
n , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ x - 1 for x in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> current = 0 <NEWLINE> d = dict ( ) <NEWLINE> d [ current ] = d . get ( current , 0 ) + 1 <NEWLINE> pattern = [ 0 ] <NEWLINE> cnt = K <NEWLINE> <NL> while True : <NEWLINE> <INDENT> current = A [ current ] <NEWLINE> if d . get ( current ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if d . get ( current ) == None : <NEWLINE> <INDENT> d [ current ] = d . get ( current , 0 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ current ] = d . get ( current ) + 1 <NEWLINE> <DEDENT> pattern . append ( current ) <NEWLINE> cnt -= 1 <NEWLINE> if cnt == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( pattern [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = len ( [ key for key , value in d . items ( ) if value == 2 ] ) <NEWLINE> not_loop = len ( [ key for key , value in d . items ( ) if value != 2 ] ) <NEWLINE> pattern = pattern [ not_loop : ] <NEWLINE> ans_position = ( K - not_loop ) % loop <NEWLINE> <NL> print ( pattern [ ans_position ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left as bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 6 ) <NEWLINE> <NL> <NL> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> class solve : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . ans = [ 0 ] * N <NEWLINE> self . DP = [ ] <NEWLINE> <NL> <DEDENT> def recur ( self , i , pi = - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> rev_i = bisect ( self . DP , self . A [ i ] ) <NEWLINE> if rev_i == len ( self . DP ) : <NEWLINE> <INDENT> self . DP . append ( self . A [ i ] ) <NEWLINE> rev_v = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rev_v = self . DP [ rev_i ] <NEWLINE> self . DP [ rev_i ] = self . A [ i ] <NEWLINE> <NL> <DEDENT> self . ans [ i ] = len ( self . DP ) <NEWLINE> <NL> for nv in self . edges [ i ] : <NEWLINE> <INDENT> if nv != pi : <NEWLINE> <INDENT> self . recur ( nv , i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if rev_v is None : <NEWLINE> <INDENT> self . DP . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . DP [ rev_i ] = rev_v <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = solve ( N ) <NEWLINE> S . A = inpl ( ) <NEWLINE> S . edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = inpl ( ) <NEWLINE> S . edges [ u - 1 ] . append ( v - 1 ) <NEWLINE> S . edges [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> S . recur ( 0 ) <NEWLINE> <NL> print ( * S . ans , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = a [ 0 ] <NEWLINE> K = a [ 1 ] <NEWLINE> <NL> i = 2 <NEWLINE> x = ( N - K + 1 ) <NEWLINE> y = 1 <NEWLINE> z = ( x * y ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( z ) <NEWLINE> <NL> while K >= i : <NEWLINE> <INDENT> if ( N - K + 1 ) >= i : <NEWLINE> <INDENT> x = ( N - K + 2 - i ) * x // i <NEWLINE> y = ( K - i + 1 ) * y // ( i - 1 ) <NEWLINE> z = ( x * y ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> countH = [ 0 ] * ( H + 1 ) <NEWLINE> countW = [ 0 ] * ( W + 1 ) <NEWLINE> S = { } <NEWLINE> i = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> countH [ h ] += 1 <NEWLINE> countW [ w ] += 1 <NEWLINE> S [ str ( h ) + <STRING> + str ( w ) ] = 1 <NEWLINE> <NL> <DEDENT> mh = max ( countH ) <NEWLINE> mw = max ( countW ) <NEWLINE> ans = mh + mw - 1 <NEWLINE> <NL> c_mh = [ ] <NEWLINE> i = 0 <NEWLINE> while i <= H : <NEWLINE> <INDENT> if countH [ i ] == mh : <NEWLINE> <INDENT> c_mh . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> c_mw = [ ] <NEWLINE> i = 0 <NEWLINE> while i <= W : <NEWLINE> <INDENT> if countW [ i ] == mw : <NEWLINE> <INDENT> c_mw . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ok = 0 <NEWLINE> ok1 = 0 <NEWLINE> ok2 = 0 <NEWLINE> for h in c_mh : <NEWLINE> <INDENT> for w in c_mw : <NEWLINE> <INDENT> S . setdefault ( str ( h ) + <STRING> + str ( w ) ) <NEWLINE> if S [ str ( h ) + <STRING> + str ( w ) ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ok = 1 <NEWLINE> <DEDENT> if ok : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> near = [ [ i ] for i in range ( N ) ] <NEWLINE> flag = [ i for i in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> near [ A - 1 ] . append ( B - 1 ) <NEWLINE> near [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for n in near : <NEWLINE> <INDENT> k = 1 <NEWLINE> for j in n [ 1 : ] : <NEWLINE> <INDENT> if H [ n [ 0 ] ] <= H [ j ] : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> <DEDENT> if k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> n , m , k = n1 ( ) <NEWLINE> <NL> def cmb ( n , k , mod , fac , ifac ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> k = min ( k , n - k ) <NEWLINE> return fac [ n ] * ifac [ k ] * ifac [ n - k ] % mod <NEWLINE> <NL> <NL> <DEDENT> def make_tables ( mod , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> fac = [ 1 , 1 ] <COMMENT> <NEWLINE> ifac = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fac . append ( ( fac [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> ifac . append ( ( ifac [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> return fac , ifac <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> a = 1 <NEWLINE> MOD = 998244353 <NEWLINE> fac , ifac = make_tables ( MOD , n - 1 ) <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += m * pow ( m - 1 , n - 1 - i , 998244353 ) * cmb ( n - 1 , i , MOD , fac , ifac ) <NEWLINE> <DEDENT> print ( ans % 998244353 ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> if ( K % 2 == 0 or K % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> x = 7 <NEWLINE> first = True <NEWLINE> flag = False <NEWLINE> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if ( first ) : <NEWLINE> <INDENT> x = 7 <NEWLINE> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> x = ( x * 10 ) % K + 7 % K <NEWLINE> <NL> <DEDENT> if ( x % K == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flag != True ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> abs_x = abs ( X ) <NEWLINE> hikukazu = abs ( X ) // D <NEWLINE> count = K - ( hikukazu ) <NEWLINE> if K > hikukazu : <NEWLINE> <INDENT> if count % 2 == 0 : <NEWLINE> <INDENT> hikukazu = hikukazu <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hikukazu = hikukazu + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> hikukazu = K <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> abs_x = abs_x - ( D * hikukazu ) <NEWLINE> <COMMENT> <NL> <NL> print ( abs ( abs_x ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> r = [ 0 ] * len ( s ) <NEWLINE> r [ 0 ] = int ( s [ - 1 ] ) <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> temp = s [ - ( 1 + i ) ] * pow ( 10 , i , 2019 ) <NEWLINE> r [ i ] = ( temp + r [ i - 1 ] ) % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> cts = [ 0 ] * 2019 <NEWLINE> for i in r : <NEWLINE> <INDENT> ans += cts [ i ] <NEWLINE> cts [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans += cts [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> import numpy as np <NEWLINE> A = np . array ( A , dtype = <STRING> ) <NEWLINE> Z = A [ A == 0 ] <NEWLINE> H = A [ A < 0 ] <NEWLINE> S = A [ A > 0 ] <NEWLINE> l , r = - 10 ** 19 , 10 ** 19 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> cnt = 0 <NEWLINE> cnt += A . searchsorted ( mid // S , side = <STRING> ) . sum ( ) <NEWLINE> cnt += ( N - A . searchsorted ( ( - mid - 1 ) // ( - H ) , side = <STRING> ) ) . sum ( ) <NEWLINE> cnt -= np . count_nonzero ( A * A <= mid ) <NEWLINE> if mid >= 0 : <NEWLINE> <INDENT> cnt += len ( Z ) * N <NEWLINE> <DEDENT> cnt //= 2 <NEWLINE> if cnt >= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import numpy as np <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( set ( P ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = [ i for i in range ( 1 , 210 ) ] <NEWLINE> <NL> for i in P : <NEWLINE> <INDENT> A . remove ( i ) <NEWLINE> <NL> <DEDENT> a = ( np . array ( A ) - X ) ** 2 <NEWLINE> j = np . argmin ( a ) <NEWLINE> if ( A [ j ] - X ) ** 2 >= X ** 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ j ] ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = input ( ) <NEWLINE> T = int ( t ) <NEWLINE> <NL> d = b - a <NEWLINE> d = int ( d ) <NEWLINE> dv = v - w <NEWLINE> dv = int ( dv ) <NEWLINE> d = abs ( d ) <NEWLINE> if dv > 0 and abs ( d ) <= abs ( dv ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def getN ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def getNM ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def getList ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def getArray ( intn ) : <NEWLINE> <INDENT> return [ int ( input ( ) ) for i in range ( intn ) ] <NEWLINE> <DEDENT> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <DEDENT> def rand_N ( ran1 , ran2 ) : <NEWLINE> <INDENT> return random . randint ( ran1 , ran2 ) <NEWLINE> <DEDENT> def rand_List ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> return [ random . randint ( ran1 , ran2 ) for i in range ( rantime ) ] <NEWLINE> <DEDENT> def rand_ints_nodup ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> ns = [ ] <NEWLINE> while len ( ns ) < rantime : <NEWLINE> <INDENT> n = random . randint ( ran1 , ran2 ) <NEWLINE> if not n in ns : <NEWLINE> <INDENT> ns . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( ns ) <NEWLINE> <NL> <DEDENT> def rand_query ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> r_query = [ ] <NEWLINE> while len ( r_query ) < rantime : <NEWLINE> <INDENT> n_q = rand_ints_nodup ( ran1 , ran2 , 2 ) <NEWLINE> if not n_q in r_query : <NEWLINE> <INDENT> r_query . append ( n_q ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( r_query ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict , deque , Counter <NEWLINE> from sys import exit <NEWLINE> from decimal import * <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> import math <NEWLINE> import random <NEWLINE> import string <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import combinations , permutations , product <NEWLINE> from operator import mul , itemgetter <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> N = getN ( ) <NEWLINE> A = getList ( ) <NEWLINE> query = [ getList ( ) for i in range ( N - 1 ) ] <NEWLINE> <NL> dist = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = query [ i ] <NEWLINE> dist [ a - 1 ] . append ( b - 1 ) <NEWLINE> dist [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ignore = [ 0 ] * N <NEWLINE> ignore [ 0 ] = 1 <NEWLINE> lis = [ A [ 0 ] ] <NEWLINE> rec = [ 0 ] * N <NEWLINE> rec [ 0 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> def dfs ( u ) : <NEWLINE> <INDENT> global lis <NEWLINE> for i in dist [ u ] : <NEWLINE> <INDENT> if ignore [ i ] != 1 : <NEWLINE> <INDENT> ignore [ i ] = 1 <NEWLINE> <COMMENT> <NL> plus = 0 <COMMENT> <NEWLINE> change = ( 0 , 0 , 0 ) <COMMENT> <NEWLINE> <NL> if A [ i ] > lis [ - 1 ] : <NEWLINE> <INDENT> lis . append ( A [ i ] ) <NEWLINE> plus = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = bisect_left ( lis , A [ i ] ) <NEWLINE> change = ( 1 , index , lis [ index ] ) <NEWLINE> lis [ index ] = A [ i ] <NEWLINE> <DEDENT> rec [ i ] = len ( lis ) <NEWLINE> dfs ( i ) <NEWLINE> <COMMENT> <NL> if plus : <NEWLINE> <INDENT> lis . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ change [ 1 ] ] = change [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> for i in rec : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l [ A [ i - 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x , k , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> k1 = math . floor ( x / d ) <NEWLINE> <NL> if k < k1 : <NEWLINE> <INDENT> k1 = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k1 = k1 <NEWLINE> <NL> <DEDENT> k2 = k1 - k <NEWLINE> <NL> y = x - k1 * d <NEWLINE> <NL> if k2 % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( y - d ) ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i <= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if i >= a + k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> X , Y , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> q = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> r = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> now = sum ( p [ : X ] ) + sum ( q [ : Y ] ) <NEWLINE> ans = now <NEWLINE> i = X - 1 <NEWLINE> j = Y - 1 <NEWLINE> <NL> for k in range ( min ( C , X + Y ) ) : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> now += r [ k ] - q [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> elif j < 0 : <NEWLINE> <INDENT> now += r [ k ] - p [ i ] <NEWLINE> i -= 1 <NEWLINE> <DEDENT> elif p [ i ] < q [ j ] : <NEWLINE> <INDENT> now += r [ k ] - p [ i ] <NEWLINE> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += r [ k ] - q [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( N , A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> culm = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> culm -= A [ i ] <NEWLINE> ans += A [ i ] * culm <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = main ( N , A ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> aa = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> aa += A [ i - 1 ] <NEWLINE> a . append ( aa ) <NEWLINE> <NL> <DEDENT> b = [ 0 ] <NEWLINE> bb = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> bb += B [ i - 1 ] <NEWLINE> b . append ( bb ) <NEWLINE> <NL> <DEDENT> time0 = 1 <NEWLINE> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( j >= 0 ) : <NEWLINE> <INDENT> if b [ j ] <= K - a [ i ] : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) + 1 - i ) : <NEWLINE> <INDENT> dic . setdefault ( s [ j : j + i ] , 0 ) <NEWLINE> dic [ s [ j : j + i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> sort_dic = sorted ( dic ) <NEWLINE> print ( sort_dic [ k - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> change_list = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> cnt = [ 0 ] * 10 ** 6 <NEWLINE> tot = sum ( a_list ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ a_list [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> tot += cnt [ change_list [ j ] [ 0 ] ] * ( change_list [ j ] [ 1 ] - change_list [ j ] [ 0 ] ) <NEWLINE> cnt [ change_list [ j ] [ 1 ] ] += cnt [ change_list [ j ] [ 0 ] ] <NEWLINE> cnt [ change_list [ j ] [ 0 ] ] = 0 <NEWLINE> print ( tot ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = <STRING> * W <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> total = 1 <NEWLINE> maxi = 10 ** 18 <NEWLINE> for ae in a : <NEWLINE> <INDENT> total *= ae <NEWLINE> if total > maxi : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> total = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total *= A [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ns = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : return False <NEWLINE> if n == 2 : return True <NEWLINE> if n % 2 == 0 : return False <NEWLINE> <NL> d = 3 <NEWLINE> while d ** 2 <= n : <NEWLINE> <INDENT> if n % d == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> d += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> print ( len ( [ n for n in ns if is_prime ( n ) ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) ; <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = 1 <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> b *= int ( i ) <NEWLINE> if ( b > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( b <= 1000000000000000000 ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> sum = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( x , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mem = [ 0 ] * ( n ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> mem [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in mem : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> items = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in items : <NEWLINE> <INDENT> items . setdefault ( s , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> items [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( items ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mapint ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = mapint ( ) <NEWLINE> As = list ( mapint ( ) ) <NEWLINE> num_lis = [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> need_m = [ num_lis [ a - 1 ] for a in As ] <NEWLINE> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for a , need in zip ( As , need_m ) : <NEWLINE> <INDENT> if need > i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dp [ i - need ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dp [ i - need ] == 0 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ i - need ] * 10 + a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ac_list = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ac_list [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ac_sum = list ( accumulate ( ac_list ) ) <NEWLINE> <NL> for l , r in lr : <NEWLINE> <INDENT> l -= 1 <NEWLINE> r -= 1 <NEWLINE> if l == 0 : <NEWLINE> <INDENT> print ( ac_sum [ r - 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( ac_sum [ r - 1 ] - ac_sum [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> room = [ [ [ 0 for k in range ( 10 ) ] for j in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for a in data : <NEWLINE> <INDENT> room [ a [ 0 ] - 1 ] [ a [ 1 ] - 1 ] [ a [ 2 ] - 1 ] += a [ 3 ] <NEWLINE> <NL> <DEDENT> for x , i in enumerate ( room ) : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , j ) ) ) <NEWLINE> <DEDENT> if x <= 2 : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> G = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> G . append ( input ( ) . split ( ) ) <NEWLINE> for j in range ( len ( G [ i ] ) ) : <NEWLINE> <INDENT> G [ i ] [ j ] = int ( G [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> mincost = [ 2001 ] * n <NEWLINE> flag = [ 0 ] * n <NEWLINE> mincost [ 0 ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> v = - 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if flag [ j ] != 1 and ( v == - 1 or mincost [ j ] < mincost [ v ] ) : <NEWLINE> <INDENT> v = j <NEWLINE> <DEDENT> <DEDENT> if v == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flag [ v ] = 1 <NEWLINE> ans += mincost [ v ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if G [ v ] [ j ] == - 1 : continue <NEWLINE> mincost [ j ] = min ( mincost [ j ] , G [ v ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> line = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> sum = 1 <NEWLINE> line . sort ( reverse = True ) <NEWLINE> if line [ len ( line ) - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for num in line : <NEWLINE> <INDENT> sum = sum * num <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
input ( ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ls . sort ( reverse = True ) <NEWLINE> <NL> def main ( ls ) : <NEWLINE> <INDENT> if ls . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> result = 1 <NEWLINE> for i in ls : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ls ) <NEWLINE>
def make_kmp_table ( t ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> j = 0 <NEWLINE> m = len ( t ) <NEWLINE> tbl = [ 0 ] * ( m + 1 ) <NEWLINE> tbl [ 0 ] = - 1 <NEWLINE> while i <= m : <NEWLINE> <INDENT> if t [ i - 1 ] == t [ j ] : <NEWLINE> <INDENT> tbl [ i ] = j + 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif j > 0 : <NEWLINE> <INDENT> j = tbl [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tbl [ i ] = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> return tbl <NEWLINE> <NL> <NL> <DEDENT> def kmp ( s , t ) : <NEWLINE> <INDENT> matched_indices = [ ] <NEWLINE> tbl = make_kmp_table ( t ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> n = len ( s ) <NEWLINE> m = len ( t ) <NEWLINE> while i + j < n : <NEWLINE> <INDENT> if t [ j ] == s [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> if j == m : <NEWLINE> <INDENT> matched_indices . append ( i ) <NEWLINE> i += j - tbl [ j ] <NEWLINE> j = tbl [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += j - tbl [ j ] <NEWLINE> if j > 0 : <NEWLINE> <INDENT> j = tbl [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return matched_indices <NEWLINE> <NL> <NL> <DEDENT> t = input ( ) <NEWLINE> p = input ( ) <NEWLINE> result = kmp ( t , p ) <NEWLINE> if result : <NEWLINE> <INDENT> print ( * result , sep = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt *= A [ i ] <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> S = 0 <NEWLINE> sl = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sl += A [ i ] <NEWLINE> sl %= mod <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> sl -= A [ j ] <NEWLINE> if sl < 0 : <NEWLINE> <INDENT> sl += mod <NEWLINE> <DEDENT> S += A [ j ] * sl <NEWLINE> S = S % mod <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> check = True <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if check else <STRING> ) <NEWLINE>
inf = 100000000 <NEWLINE> <NL> def calc ( uth , dis , c ) : <NEWLINE> <INDENT> fare = 0 <NEWLINE> if dis >= inf : <NEWLINE> <INDENT> return inf <NEWLINE> <DEDENT> if unchin [ c ] == 1 : <NEWLINE> <INDENT> return uth [ c ] [ 1 ] [ 0 ] * dis <NEWLINE> <DEDENT> ddis = uth [ c ] [ 0 ] <NEWLINE> dcost = uth [ c ] [ 1 ] <NEWLINE> i = 1 <NEWLINE> while ( i < unchin [ c ] and dis > ddis [ i ] ) : <NEWLINE> <INDENT> fare += ( ddis [ i ] - ddis [ i - 1 ] ) * dcost [ i - 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> fare += ( dis - ddis [ i - 1 ] ) * dcost [ i - 1 ] <NEWLINE> return fare <NEWLINE> <NL> <DEDENT> def floyd ( bigmap , n ) : <NEWLINE> <INDENT> res = bigmap <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if res [ i ] [ j ] > res [ i ] [ k ] + res [ k ] [ j ] : <NEWLINE> <INDENT> res [ i ] [ j ] = res [ i ] [ k ] + res [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def init2d ( bigmap , n ) : <NEWLINE> <INDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> bigmap . append ( [ ] ) <NEWLINE> <DEDENT> for map1 in bigmap : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> map1 . append ( inf ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> bigmap [ i ] [ i ] = 0 <NEWLINE> <DEDENT> return bigmap <NEWLINE> <NL> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> n , m , c , s , g = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( n == m == 0 ) : break <NEWLINE> rosen = [ ] <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> map0 = [ ] <NEWLINE> rosen . append ( init2d ( map0 , n ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y , d , c0 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rosen [ c0 ] [ x ] [ y ] = min ( rosen [ c0 ] [ x ] [ y ] , d ) <NEWLINE> rosen [ c0 ] [ y ] [ x ] = min ( rosen [ c0 ] [ x ] [ y ] , d ) <NEWLINE> <NL> <DEDENT> unchin = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> unchin . insert ( 0 , 0 ) <NEWLINE> uth = [ ] <NEWLINE> uth . append ( [ ] ) <NEWLINE> for i in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> ddis = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> ddis . insert ( 0 , 0 ) <NEWLINE> dcost = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> uth . append ( [ ddis , dcost ] ) <NEWLINE> <NL> <DEDENT> bigmap = [ ] <NEWLINE> bigmap = init2d ( bigmap , n ) <NEWLINE> <NL> <NL> for c0 , cmap in enumerate ( rosen [ 1 : ] ) : <NEWLINE> <INDENT> tmp = floyd ( cmap , n ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> bigmap [ i ] [ j ] = min ( bigmap [ i ] [ j ] , calc ( uth , tmp [ i ] [ j ] , c0 + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> bigmap = floyd ( bigmap , n ) <NEWLINE> <NL> ans = bigmap [ s ] [ g ] <NEWLINE> if ans < inf : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ansbox = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> def count ( N , A , Ansbox ) : <NEWLINE> <NL> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Ansbox [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( Ansbox [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> count ( N , A , Ansbox ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> set = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in set : <NEWLINE> <INDENT> set . add ( s ) <NEWLINE> <DEDENT> <DEDENT> print ( str ( len ( set ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> ans_list = [ ] <NEWLINE> <NL> R_index = [ ] <NEWLINE> G_index = [ ] <NEWLINE> B_index = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R_index . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G_index . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> B_index . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( R_index ) * len ( G_index ) * len ( B_index ) <NEWLINE> <NL> for j in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for i in range ( min ( n - j - 1 , j ) + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s [ j - i ] != s [ j ] and s [ j ] != s [ j + i ] and s [ j - i ] != s [ j + i ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visitset = set ( ) <NEWLINE> visitcount = dict ( ) <NEWLINE> n_point = dict ( ) <NEWLINE> <NL> x = 1 <NEWLINE> count = 0 <NEWLINE> while ( x not in visitset ) : <NEWLINE> <INDENT> visitset . add ( x ) <NEWLINE> visitcount [ x ] = count <NEWLINE> n_point [ count ] = x <NEWLINE> x = A [ x - 1 ] <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT> period = count - visitcount [ x ] <NEWLINE> <NL> if ( K < visitcount [ x ] ) : <NEWLINE> <INDENT> print ( n_point [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( K - visitcount [ x ] ) % period <NEWLINE> print ( n_point [ visitcount [ x ] + y ] ) <NEWLINE> <NL> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> a . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> n = 0 <NEWLINE> ans = [ ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> if y % 2 == 0 : <NEWLINE> <INDENT> for x in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ y ] [ x ] & 1 : <NEWLINE> <INDENT> a [ y ] [ x + 1 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , x + 1 , y + 1 , x + 2 ) ) <NEWLINE> <DEDENT> <DEDENT> if y != H - 1 and ( a [ y ] [ W - 1 ] & 1 ) : <NEWLINE> <INDENT> a [ y + 1 ] [ W - 1 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , W , y + 2 , W ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( W - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ y ] [ x ] & 1 : <NEWLINE> <INDENT> a [ y ] [ x - 1 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , x + 1 , y + 1 , x ) ) <NEWLINE> <DEDENT> <DEDENT> if y != H - 1 and ( a [ y ] [ 0 ] & 1 ) : <NEWLINE> <INDENT> a [ y + 1 ] [ 0 ] += 1 <NEWLINE> n += 1 <NEWLINE> ans . append ( <STRING> . format ( y + 1 , 1 , y + 2 , 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ 0 ] * ( N + 1 ) <NEWLINE> L = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in L : <NEWLINE> <INDENT> P [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , len ( P ) ) : <NEWLINE> <INDENT> print ( P [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> memo = [ 0 ] * ( K + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> memo [ i ] = pow ( K // i , N , mod ) <NEWLINE> j = 2 <NEWLINE> while i * j <= K : <NEWLINE> <INDENT> memo [ i ] -= memo [ i * j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> ans += memo [ i ] * i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> output = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> r = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> output += math . gcd ( r , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> def gcd2 ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if len ( set ( [ a , b , c ] ) ) == 2 : <NEWLINE> <INDENT> sum = sum + gcd2 ( a , b , c ) * 3 <NEWLINE> <DEDENT> elif len ( set ( [ a , b , c ] ) ) == 1 : <NEWLINE> <INDENT> sum = sum + gcd2 ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = sum + gcd2 ( a , b , c ) * 6 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = nums [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if nums [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ans * nums [ x + 1 ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> items = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] , dtype = np . int32 ) <NEWLINE> all_book = [ i for i in range ( N ) ] <NEWLINE> out = 10 ** 18 <NEWLINE> flag = False <NEWLINE> <COMMENT> <NL> for num in range ( 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> for t in combinations ( all_book , num ) : <COMMENT> <NEWLINE> <INDENT> book_buy = np . array ( t , dtype = int ) <NEWLINE> understand_now = items [ book_buy ] <NEWLINE> tmp = np . sum ( understand_now , axis = 0 ) <NEWLINE> if np . all ( tmp [ 1 : ] >= X ) : <NEWLINE> <INDENT> out = min ( out , tmp [ 0 ] ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> def seachPrimeNum ( N ) : <NEWLINE> <INDENT> max = int ( np . sqrt ( N ) ) <NEWLINE> seachList = [ i for i in range ( 2 , N + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> while seachList [ 0 ] <= max : <NEWLINE> <INDENT> primeNum . append ( seachList [ 0 ] ) <NEWLINE> tmp = seachList [ 0 ] <NEWLINE> seachList = [ i for i in seachList if i % tmp != 0 ] <NEWLINE> <DEDENT> primeNum . extend ( seachList ) <NEWLINE> return primeNum <NEWLINE> <NL> <DEDENT> n = 10 ** 5 <NEWLINE> a = seachPrimeNum ( n ) <NEWLINE> b = [ ] <NEWLINE> y = 0 <NEWLINE> x = 0 <NEWLINE> while x <= 100000 : <NEWLINE> <INDENT> t = a [ y ] <NEWLINE> x = t * 2 - 1 <NEWLINE> b . append ( x ) <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> c = set ( a ) & set ( b ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> r = [ 0 for _ in range ( 100000 ) ] <NEWLINE> for f in c : <NEWLINE> <INDENT> r [ f ] = 1 <NEWLINE> <DEDENT> for g in range ( len ( r ) - 1 ) : <NEWLINE> <INDENT> r [ g + 1 ] = r [ g ] + r [ g + 1 ] <NEWLINE> <NL> <DEDENT> for p in range ( q ) : <NEWLINE> <INDENT> w , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( r [ z ] - r [ w - 1 ] ) <NEWLINE> <NL> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> mul = [ 0 , 1 , 3 , 6 ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( a , b ) , c ) * mul [ len ( { a , b , c } ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for j in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
alphabet = list ( <STRING> ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> for i in S : <NEWLINE> <INDENT> print ( alphabet [ ( alphabet . index ( i ) + N ) % 26 ] , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( ( i , x , y ) ) <NEWLINE> <DEDENT> xx = sorted ( xy , key = lambda x : x [ 1 ] ) <NEWLINE> yy = sorted ( xy , key = lambda x : x [ 2 ] ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> li . append ( ( xx [ i ] [ 0 ] , xx [ i + 1 ] [ 0 ] , xx [ i + 1 ] [ 1 ] - xx [ i ] [ 1 ] ) ) <NEWLINE> li . append ( ( yy [ i ] [ 0 ] , yy [ i + 1 ] [ 0 ] , yy [ i + 1 ] [ 2 ] - yy [ i ] [ 2 ] ) ) <NEWLINE> <DEDENT> li . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , li ) : <NEWLINE> <INDENT> self . li = li <NEWLINE> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . li [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . li [ x ] = self . root ( self . li [ x ] ) <NEWLINE> return self . li [ x ] <NEWLINE> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . li [ ry ] = rx <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <DEDENT> <DEDENT> uf = UnionFind ( list ( range ( n ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x , y , cost in li : <NEWLINE> <INDENT> if uf . same ( x , y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> uf . unite ( x , y ) <NEWLINE> ans += cost <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> d [ 0 ] += 1 <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j += int ( s [ - i ] ) * pow ( 10 , i - 1 , 2019 ) <NEWLINE> j %= 2019 <NEWLINE> d [ j ] += 1 <NEWLINE> <NL> <DEDENT> def calc ( x ) : return x * ( x - 1 ) // 2 <NEWLINE> ans = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> ans += calc ( v ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> r_add = r . add <NEWLINE> g_add = g . add <NEWLINE> for ind , c in enumerate ( s ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> r_add ( ind ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> g_add ( ind ) <NEWLINE> <DEDENT> <DEDENT> b = set ( range ( n ) ) - r - g <NEWLINE> <NL> ans = 0 <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> p , q = min ( i , j ) , max ( i , j ) <NEWLINE> if ( q - p ) % 2 == 0 and ( p + q ) // 2 in b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( q + ( q - p ) ) in b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( p - ( q - p ) ) in b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> ans += len ( b ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> val = { } <NEWLINE> <NL> suss = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i not in val : <NEWLINE> <INDENT> val [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in val . items ( ) : <NEWLINE> <INDENT> suss += k * v <NEWLINE> <NL> <DEDENT> while q : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if c in val : <NEWLINE> <INDENT> if d in val : <NEWLINE> <INDENT> val [ d ] += val [ c ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val [ d ] = val [ c ] <NEWLINE> <DEDENT> suss -= c * val [ c ] <NEWLINE> suss += d * val [ c ] <NEWLINE> del val [ c ] <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( suss ) <NEWLINE> <NL> q -= 1 <NEWLINE> <NL> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ int ( num ) for num in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> b = [ [ int ( num ) for num in input ( ) . split ( ) ] for i in range ( m ) ] <NEWLINE> c = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ j ] [ i ] += a [ j ] [ k ] * b [ k ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> if j == l - 1 : <NEWLINE> <INDENT> print ( c [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( c [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
old_id = input ( ) <NEWLINE> new_id = input ( ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> result = <STRING> if len ( old_id ) + 1 == len ( new_id ) and old_id . index ( new_id [ 0 ] ) == 0 and old_id in new_id else <STRING> <NEWLINE> print ( result ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N , M , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def combmod ( n , k , p = MOD , numden = [ ( 1 , 1 ) ] ) : <NEWLINE> <INDENT> if k > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if k > n - k : <NEWLINE> <INDENT> k = n - k <NEWLINE> <COMMENT> <NL> <DEDENT> if k < len ( numden ) : <NEWLINE> <INDENT> num , den = numden [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> num , den = numden [ - 1 ] <NEWLINE> for i in range ( len ( numden ) - 1 , k ) : <NEWLINE> <INDENT> num = num * ( n - i ) % p <NEWLINE> den = den * ( i + 1 ) % p <NEWLINE> numden . append ( ( num , den ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> inv_dev = pow ( den , p - 2 , p ) <NEWLINE> return num * inv_dev % p <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += combmod ( N - 1 , i ) * M * pow ( M - 1 , N - 1 - i , MOD ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <NL> <INDENT> def func ( m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return func ( m - 1 ) * 3 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> G = [ ] <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> gi = func ( i ) <NEWLINE> if gi <= n : <NEWLINE> <INDENT> G . append ( gi ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> G = G [ : : - 1 ] <NEWLINE> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <NL> <DEDENT> return A , G <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> A , G = shellSort ( A , n ) <NEWLINE> <NL> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
def is_prime ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> l = x ** 0.5 <NEWLINE> n = 3 <NEWLINE> while n <= l : <NEWLINE> <INDENT> if x % n == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> n += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( n ) , end = <STRING> ) <NEWLINE> ans = [ ] <NEWLINE> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> n //= 2 <NEWLINE> ans . append ( 2 ) <NEWLINE> <NL> <DEDENT> d = 3 <NEWLINE> while n >= d : <NEWLINE> <INDENT> if is_prime ( d ) : <NEWLINE> <INDENT> while n % d == 0 : <NEWLINE> <INDENT> n //= d <NEWLINE> ans . append ( d ) <NEWLINE> <DEDENT> <DEDENT> if is_prime ( n ) : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> break <NEWLINE> <DEDENT> d += 2 <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ * input ( ) ] for _ in range ( n ) ] <NEWLINE> a = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> ans = [ <STRING> ] + [ 0 ] * n <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for p , m in [ s [ i ] , s [ i ] [ : : - 1 ] ] : <NEWLINE> <INDENT> if a [ m ] : <NEWLINE> <INDENT> a [ p ] += 1 ; a [ m ] -= 1 ; ans [ i + 1 ] = p <NEWLINE> dfs ( i + 1 ) <NEWLINE> <COMMENT> <NL> a [ p ] -= 1 ; a [ m ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> from operator import itemgetter <NEWLINE> from collections import deque , Counter <NEWLINE> import math <NEWLINE> import pprint <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import random <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import time <NEWLINE> <COMMENT> <NL> <NL> <NL> MOD = int ( 1e9 + 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def keta ( kazu ) : <COMMENT> <NEWLINE> <INDENT> kazu_str = str ( kazu ) <NEWLINE> kazu_list = [ int ( kazu_str [ i ] ) for i in range ( 0 , len ( kazu_str ) ) ] <NEWLINE> return kazu_list <NEWLINE> <NL> <DEDENT> def gcd ( * numbers ) : <COMMENT> <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def combination ( m , n ) : <COMMENT> <NEWLINE> <NL> <INDENT> if n > m : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return math . factorial ( m ) // ( math . factorial ( m - n ) * math . factorial ( n ) ) <NEWLINE> <NL> <DEDENT> def pow_k ( x , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> K = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 != 0 : <NEWLINE> <INDENT> K *= x <NEWLINE> <DEDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return K * x <NEWLINE> <NL> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> arr = { } <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr [ temp ] = 1 <NEWLINE> <DEDENT> if arr == { } : <NEWLINE> <INDENT> arr [ n ] = 1 <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] ) ) <NEWLINE> now = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> now -= A [ i ] <NEWLINE> ans += ( ( A [ i ] % MOD ) * ( now % MOD ) ) % MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> <NL> if len ( T ) == 1 : <NEWLINE> <INDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> if T [ 1 ] == <STRING> or T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> if T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> and T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i + 1 ] == <STRING> and T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i + 1 ] == <STRING> and T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> if T [ i + 1 ] == <STRING> and T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> . join ( T ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> sum = K <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> sum += i <NEWLINE> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> base = math . gcd ( i , j ) <NEWLINE> sum += math . gcd ( base , k ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> base = math . gcd ( i , j ) <NEWLINE> sum += math . gcd ( base , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = N // K <NEWLINE> b = abs ( N - ( a + 1 ) * K ) <NEWLINE> <NL> if N - a * K <= b : <NEWLINE> <INDENT> print ( N - a * K ) <NEWLINE> <DEDENT> elif N - a * K > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * ( n + 1 ) <NEWLINE> b = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] = A [ i - 1 ] + a [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ j ] = B [ j - 1 ] + b [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> num_b = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( num_b , - 1 , - 1 ) : <NEWLINE> <INDENT> if b [ j ] <= k - a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num_b -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a [ 0 ] == 0 and a [ 1 ] == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for x in range ( a [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * a [ 1 ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = np . zeros ( 3 ) <COMMENT> <NEWLINE> <NL> s [ 0 ] = n * ( n + 1 ) // 2 <NEWLINE> for i in np . arange ( n ) + 1 : <NEWLINE> <INDENT> for j in np . arange ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> s [ 1 ] += math . gcd ( i , j ) <NEWLINE> for k in np . arange ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> s [ 2 ] += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( sum ( s * [ 1 , 6 , 6 ] ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min , max = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if L > max or R < min : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif min < L <= max : <NEWLINE> <INDENT> min = L <NEWLINE> <DEDENT> elif min <= R < max : <NEWLINE> <INDENT> max = R <NEWLINE> <DEDENT> <DEDENT> print ( max - min + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = ( ( n + 1 ) * n ) // 2 - n <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k = min ( k , n ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * n <NEWLINE> kn = np . arange ( 1 , k ) <NEWLINE> h0 = h [ 0 ] <NEWLINE> c0 = c [ 0 ] <NEWLINE> for ( ii , hii ) in zip ( kn , h [ 1 : k ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> cii = c0 + abs ( hii - h0 ) <NEWLINE> for ( cjj , hjj ) in zip ( c [ 1 : ii ] , h [ 1 : ii ] ) : <NEWLINE> <INDENT> if cii > cjj : <NEWLINE> <COMMENT> <NL> <INDENT> if hii == hjj : <NEWLINE> <COMMENT> <NL> <INDENT> cii = cjj <NEWLINE> <DEDENT> elif hii > hjj : <NEWLINE> <INDENT> if cii > cjj + hii - hjj : <NEWLINE> <INDENT> cii = cjj + hii - hjj <NEWLINE> <DEDENT> <DEDENT> elif cii > cjj - hii + hjj : <NEWLINE> <INDENT> cii = cjj - hii + hjj <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c [ ii ] = cii <NEWLINE> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> kn = np . arange ( k , n ) <NEWLINE> for ( ii , hii , hiik ) in zip ( kn , h [ k : n ] , h [ 0 : n - k ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> cii = c [ ii - k ] + abs ( hii - hiik ) <NEWLINE> for ( cjj , hjj ) in zip ( c [ ii - k + 1 : ii ] , h [ ii - k + 1 : ii ] ) : <NEWLINE> <INDENT> if cii > cjj : <NEWLINE> <COMMENT> <NL> <INDENT> if hii == hjj : <NEWLINE> <COMMENT> <NL> <INDENT> cii = cjj <NEWLINE> <DEDENT> elif hii > hjj : <NEWLINE> <INDENT> if cii > cjj + hii - hjj : <NEWLINE> <INDENT> cii = cjj + hii - hjj <NEWLINE> <DEDENT> <DEDENT> elif cii > cjj - hii + hjj : <NEWLINE> <INDENT> cii = cjj - hii + hjj <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c [ ii ] = cii <NEWLINE> <COMMENT> <NL> <DEDENT> print ( c [ n - 1 ] ) <NEWLINE>
def create_prime_list ( limit ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = limit ** 0.5 <NEWLINE> primes = [ ] <NEWLINE> <COMMENT> <NL> nums = [ x for x in range ( 2 , limit + 1 ) ] <NEWLINE> while nums [ 0 ] <= x : <NEWLINE> <INDENT> primes . append ( nums [ 0 ] ) <NEWLINE> current_prime = nums [ 0 ] <NEWLINE> nums = [ x for x in nums if x % current_prime != 0 ] <NEWLINE> <DEDENT> primes . extend ( nums ) <NEWLINE> <COMMENT> <NL> return primes <NEWLINE> <NL> <NL> <NL> <DEDENT> def calc_divisors ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n in Primes : <NEWLINE> <INDENT> return [ n ] <NEWLINE> <DEDENT> results = [ ] <NEWLINE> i = 2 <NEWLINE> start_num = n <NEWLINE> while n >= i ** 2 : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> results . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> if n in Primes : <NEWLINE> <INDENT> results . append ( n ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if not results : <NEWLINE> <INDENT> results = [ start_num ] <NEWLINE> <DEDENT> return results <NEWLINE> <NL> <NL> <DEDENT> Primes = set ( ) <NEWLINE> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> target_number = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> Primes = set ( create_prime_list ( int ( 10 ** 4.5 ) + 1 ) ) <NEWLINE> results = calc_divisors ( target_number ) <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( target_number , <STRING> . join ( map ( str , results ) ) ) ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> flag = True <NEWLINE> s = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( 1 , A ) : <NEWLINE> <INDENT> if B [ j ] < B [ j - 1 ] : <NEWLINE> <INDENT> B [ j ] , B [ j - 1 ] = B [ j - 1 ] , B [ j ] <NEWLINE> flag = True <NEWLINE> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( A ) : <NEWLINE> <INDENT> if i != A - 1 : <NEWLINE> <INDENT> print ( B [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min = 1000 <NEWLINE> <NL> for i in range ( - 50 , 150 ) : <NEWLINE> <NL> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> elif min > abs ( x - i ) : <NEWLINE> <INDENT> result = i <NEWLINE> min = abs ( x - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> maxxy = max ( a * c , a * d , b * c , b * d ) <NEWLINE> <NL> print ( maxxy ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> from itertools import accumulate <NEWLINE> import copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = 10 ** 12 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> M = 101 <NEWLINE> offset = M // 2 <NEWLINE> cnt = [ [ 0 ] * M for _ in range ( M ) ] <NEWLINE> p = [ None for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> n = len ( A ) <NEWLINE> tmp = [ 0 , 0 ] <COMMENT> <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> tmp [ 0 ] -= n - 1 - A . index ( <STRING> ) <NEWLINE> tmp [ 1 ] -= n - 1 - A . index ( <STRING> ) <NEWLINE> <DEDENT> A = int ( A . replace ( <STRING> , <STRING> ) ) <NEWLINE> while A % 2 == 0 : <NEWLINE> <INDENT> A //= 2 <NEWLINE> tmp [ 0 ] += 1 <NEWLINE> <DEDENT> while A % 5 == 0 : <NEWLINE> <INDENT> A //= 5 <NEWLINE> tmp [ 1 ] += 1 <NEWLINE> <DEDENT> cnt [ offset + tmp [ 0 ] ] [ offset + tmp [ 1 ] ] += 1 <NEWLINE> p [ i ] = ( tmp [ 0 ] + offset , tmp [ 1 ] + offset ) <NEWLINE> <COMMENT> <NL> <DEDENT> cnt2 = copy . deepcopy ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( M - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if j < M - 1 : <NEWLINE> <INDENT> cnt [ i ] [ j ] += cnt [ i ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( M - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( M - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i < M - 1 : <NEWLINE> <INDENT> cnt [ i ] [ j ] += cnt [ i + 1 ] [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if cnt2 [ i ] [ j ] == 0 : continue <NEWLINE> ans += cnt2 [ i ] [ j ] * cnt [ offset * 2 - i ] [ offset * 2 - j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ( ans - cnt [ offset ] [ offset ] ) // 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 10 ** n - 9 ** n - 9 ** n + 8 ** n <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> nvertices , nedges = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( nvertices ) ] <NEWLINE> AdjRev = [ [ ] for i in range ( nvertices ) ] <NEWLINE> for i in range ( nedges ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj [ u ] . append ( v ) <NEWLINE> AdjRev [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> lst = [ ] <NEWLINE> visited = [ False ] * nvertices <NEWLINE> for u in range ( nvertices ) : <NEWLINE> <INDENT> if not visited [ u ] : <NEWLINE> <INDENT> dfs_first ( u , Adj , visited , lst ) <NEWLINE> <NL> <DEDENT> <DEDENT> lst . reverse ( ) <NEWLINE> ids = [ - 1 ] * nvertices <NEWLINE> visited = [ False ] * nvertices <NEWLINE> id = 0 <NEWLINE> for u in lst : <NEWLINE> <INDENT> if not visited [ u ] : <NEWLINE> <INDENT> dfs_second ( u , AdjRev , visited , id , ids ) <NEWLINE> id += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 1 if ids [ u ] == ids [ v ] else 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs_first ( u , Adj , visited , lst ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> for v in Adj [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs_first ( v , Adj , visited , lst ) <NEWLINE> <DEDENT> <DEDENT> lst . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> def dfs_second ( u , Adj , visited , id , ids ) : <NEWLINE> <INDENT> ids [ u ] = id <NEWLINE> visited [ u ] = True <NEWLINE> for v in Adj [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs_second ( v , Adj , visited , id , ids ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def solve ( n , k , a ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> l = 0 <NEWLINE> r = n - 1 <NEWLINE> a . sort ( ) <NEWLINE> <NL> if k % 2 == 1 : <NEWLINE> <INDENT> ans *= a [ r ] <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a [ n - i - 1 ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( k // 2 ) : <NEWLINE> <INDENT> tmp_min = a [ l ] * a [ l + 1 ] <NEWLINE> tmp_max = a [ r ] * a [ r - 1 ] <NEWLINE> if tmp_max > tmp_min : <NEWLINE> <INDENT> ans *= tmp_max <NEWLINE> ans %= mod <NEWLINE> r -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= tmp_min <NEWLINE> ans %= mod <NEWLINE> l += 2 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = solve ( n , k , A ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> N , M = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> Length = N * M // math . gcd ( N , M ) <NEWLINE> Flag = True <NEWLINE> SIndex = [ Nk * ( Length // N ) for Nk in range ( 0 , N ) ] <NEWLINE> SList = list ( S ) <NEWLINE> <NL> for Mk in range ( 0 , M ) : <NEWLINE> <INDENT> if Mk % ( Length // N ) == 0 : <NEWLINE> <INDENT> MInd = SIndex . index ( Mk * ( Length // M ) ) <NEWLINE> if SList [ MInd ] != T [ Mk ] : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( Length ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> r_pos = [ ] <NEWLINE> g_pos = [ ] <NEWLINE> b_pos = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> st = s [ i ] <NEWLINE> if st == <STRING> : <NEWLINE> <INDENT> r_pos . append ( i ) <NEWLINE> <NL> <DEDENT> if st == <STRING> : <NEWLINE> <INDENT> g_pos . append ( i ) <NEWLINE> <NL> <DEDENT> if st == <STRING> : <NEWLINE> <INDENT> b_pos . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> colors = [ r_pos , g_pos , b_pos ] <NEWLINE> if len ( colors [ 0 ] ) > len ( colors [ 1 ] ) : <NEWLINE> <INDENT> colors [ 0 ] , colors [ 1 ] = colors [ 1 ] , colors [ 0 ] <NEWLINE> <DEDENT> if len ( colors [ 0 ] ) > len ( colors [ 2 ] ) : <NEWLINE> <INDENT> colors [ 0 ] , colors [ 2 ] = colors [ 2 ] , colors [ 0 ] <NEWLINE> <DEDENT> if len ( colors [ 1 ] ) > len ( colors [ 2 ] ) : <NEWLINE> <INDENT> colors [ 1 ] , colors [ 2 ] = colors [ 2 ] , colors [ 1 ] <NEWLINE> <NL> <DEDENT> x_num , y_num , z_num = len ( colors [ 0 ] ) , len ( colors [ 1 ] ) , len ( colors [ 2 ] ) <NEWLINE> <NL> ans = x_num * y_num * z_num <NEWLINE> c = set ( colors [ 2 ] ) <NEWLINE> for a in colors [ 0 ] : <NEWLINE> <INDENT> for b in colors [ 1 ] : <NEWLINE> <INDENT> x , y = min ( a , b ) , max ( a , b ) <NEWLINE> <NL> dif = y - x <NEWLINE> left_pos = x - dif <NEWLINE> right_pos = y + dif <NEWLINE> mid_pos = 4000 <NEWLINE> if dif % 2 == 0 : <NEWLINE> <INDENT> mid_pos = x + dif // 2 <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = 0 <NEWLINE> mid = 0 <NEWLINE> if left_pos in c : <NEWLINE> <INDENT> left = 1 <NEWLINE> <DEDENT> if right_pos in c : <NEWLINE> <INDENT> right = 1 <NEWLINE> <DEDENT> if mid_pos in c : <NEWLINE> <INDENT> mid = 1 <NEWLINE> <NL> <DEDENT> ans -= left + right + mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> m = p [ 0 ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if m >= p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> m = min ( m , p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> d [ s ] = True <NEWLINE> <DEDENT> print ( len ( d ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H = sorted ( H ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans += H [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> if R == 0 or G == 0 or B == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = R * G * B <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : continue <NEWLINE> n = 2 * j - i <NEWLINE> if n >= N : continue <NEWLINE> if S [ i ] != S [ n ] and S [ j ] != S [ n ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = set ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> ans = x <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if i <= x : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x - ans > i - x : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> <NL> def roundup ( n ) : <NEWLINE> <INDENT> return int ( math . ceil ( n / 10 ) ) * 10 <NEWLINE> <DEDENT> def get_digit ( number ) : <NEWLINE> <INDENT> return number % 10 <NEWLINE> <DEDENT> s = 0 <NEWLINE> m = [ ] <NEWLINE> li = [ A , B , C , D , E ] <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if get_digit ( li [ i ] ) >= 1 : <NEWLINE> <INDENT> m . append ( get_digit ( li [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> f = False <NEWLINE> m . sort ( ) <NEWLINE> for l in range ( len ( li ) ) : <NEWLINE> <INDENT> if len ( m ) > 0 : <NEWLINE> <INDENT> if m [ 0 ] == get_digit ( li [ l ] ) and f == False : <NEWLINE> <INDENT> s += li [ l ] <NEWLINE> f = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += roundup ( li [ l ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = sum ( li ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( n ) + <STRING> <NEWLINE> b = True <NEWLINE> d = n <NEWLINE> i = 2 <NEWLINE> while b : <NEWLINE> <INDENT> if d % i == 0 : <NEWLINE> <INDENT> d /= i <NEWLINE> s += <STRING> + str ( i ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> b = i < d ** 0.5 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if d != 1 : s += <STRING> + str ( int ( d ) ) <NEWLINE> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ deque ( [ ] ) for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> stack = deque ( [ 0 ] ) <NEWLINE> sign = [ 0 ] * N <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . popleft ( ) <NEWLINE> for w in G [ v ] : <NEWLINE> <INDENT> if sign [ w ] == 0 : <NEWLINE> <INDENT> sign [ w ] = v + 1 <NEWLINE> stack . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sign = sign [ 1 : ] <NEWLINE> if all ( s > 0 for s in sign ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for s in sign : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> su = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> m = int ( n / i ) - i + 1 <NEWLINE> su += m * ( 2 * i * i + ( m - 1 ) * i ) - i * i <NEWLINE> <NL> <NL> <DEDENT> print ( su ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> AB = [ LI ( ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> link = [ [ ] for _ in range ( N ) ] <NEWLINE> children = [ [ ] for _ in range ( N ) ] <NEWLINE> w = [ 1 ] * N <NEWLINE> visit = [ False ] * N <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def create_link ( ) : <NEWLINE> <INDENT> for a , b in AB : <NEWLINE> <INDENT> link [ a - 1 ] . append ( b - 1 ) <NEWLINE> link [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> visit [ s ] = True <NEWLINE> for t in link [ s ] : <NEWLINE> <INDENT> if visit [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> children [ s ] . append ( t ) <NEWLINE> dfs ( t ) <NEWLINE> w [ s ] += w [ t ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def modinv ( x ) : <NEWLINE> <INDENT> return pow ( x , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> create_link ( ) <NEWLINE> dfs ( 0 ) <NEWLINE> p2 = [ None ] * ( N + 1 ) <NEWLINE> p2 [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p2 [ i + 1 ] = 2 * p2 [ i ] % MOD <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = p2 [ N - w [ i ] ] <NEWLINE> for j in children [ i ] : <NEWLINE> <INDENT> s = ( s + p2 [ w [ j ] ] - 1 ) % MOD <NEWLINE> <DEDENT> x = ( x + p2 [ N - 1 ] - s ) % MOD <NEWLINE> <DEDENT> y = p2 [ N ] <NEWLINE> <NL> ans = x * modinv ( y ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import * <NEWLINE> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> num = str ( Decimal ( A ) * Decimal ( B ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += num [ i ] <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans > 10 ** 9 : <NEWLINE> <INDENT> if A [ i ] >= 10 ** 9 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> dum = round ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( dum , - 1 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n , a , s , m = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , input ( ) , [ ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans = a [ i ] <NEWLINE> for j in m : <NEWLINE> <INDENT> ans = min ( ans , ans ^ j ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> m . append ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while a % b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> total += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> total += 3 * gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += 6 * gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> numlist = [ str ( i ) for i in range ( 10 ) ] <NEWLINE> for a in numlist : <NEWLINE> <INDENT> idx_a = S . find ( a ) <NEWLINE> if idx_a == - 1 or idx_a >= N - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for b in numlist : <NEWLINE> <INDENT> idx_b = S [ idx_a + 1 : ] . find ( b ) <NEWLINE> if idx_b == - 1 or idx_a + idx_b + 1 >= N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for c in numlist : <NEWLINE> <INDENT> if c in S [ idx_a + idx_b + 2 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import queue <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = qb <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> def dq ( ) : <NEWLINE> <INDENT> return queue . deque ( ) <NEWLINE> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def bitArr ( n ) : <COMMENT> <NEWLINE> <INDENT> x = 1 <NEWLINE> zero = <STRING> * n <NEWLINE> ans = [ ] <NEWLINE> ans . append ( [ 0 ] * n ) <NEWLINE> for i in range ( 2 ** n - 1 ) : <NEWLINE> <INDENT> ans . append ( list ( map ( lambda x : int ( x ) , list ( ( zero + bin ( x ) [ 2 : ] ) [ - 1 * n : ] ) ) ) ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> return ans ; <NEWLINE> <DEDENT> def arrsSum ( a1 , a2 ) : <NEWLINE> <INDENT> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> a1 [ i ] += a2 [ i ] <NEWLINE> <DEDENT> return a1 <NEWLINE> <NL> <NL> <DEDENT> n , k = readInts ( ) <NEWLINE> a = readInts ( ) <NEWLINE> <NL> now = [ 1 ] <NEWLINE> check = [ 0 ] * n <NEWLINE> check [ 0 ] = 1 <NEWLINE> l = 1 <NEWLINE> <NL> while check [ l - 1 ] < 2 : <NEWLINE> <INDENT> l = a [ l - 1 ] <NEWLINE> check [ l - 1 ] += 1 <NEWLINE> now . append ( l ) <NEWLINE> <NL> <DEDENT> zen = now . index ( now [ - 1 ] ) <NEWLINE> kou = len ( now ) - zen <NEWLINE> <NL> if k < zen : <NEWLINE> <INDENT> print ( now [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( k - zen ) % ( kou - 1 ) <NEWLINE> print ( now [ zen : ] [ x ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = 10 ** 9 + 7 <NEWLINE> B = 0 <NEWLINE> a = 0 <NEWLINE> ans = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a += A [ i ] <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a -= A [ i ] <NEWLINE> B = A [ i ] * a <NEWLINE> ans += B <NEWLINE> B = 0 <NEWLINE> <DEDENT> print ( ans % C ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = 10 ** 10 <NEWLINE> <NL> partA = 0 <NEWLINE> partB = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> diff = min ( diff , abs ( partA - partB ) ) <NEWLINE> partA += A [ i ] <NEWLINE> partB -= A [ i ] <NEWLINE> <DEDENT> print ( diff ) <NEWLINE> return <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( 2 , 1001 // 2 ) : <NEWLINE> <INDENT> for a in range ( 1 , 1001 // 2 ) : <NEWLINE> <INDENT> if i * a + ( 0.5 * ( i - 1 ) * i ) == n : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = sorted ( b ) <NEWLINE> mod = int ( 1000000 ) <NEWLINE> d = { } <NEWLINE> e = collections . Counter ( b ) <NEWLINE> X = int ( 0 ) <NEWLINE> ans = int ( 0 ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> if d . get ( b [ i ] ) == None : <NEWLINE> <INDENT> if e . get ( b [ i ] ) != 1 : <NEWLINE> <INDENT> d [ b [ i ] ] = 1 <NEWLINE> <DEDENT> X = b [ i ] <NEWLINE> while X <= ( mod - b [ i ] ) : <NEWLINE> <INDENT> X += b [ i ] <NEWLINE> d [ X ] = 1 <NEWLINE> <DEDENT> X = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if d . get ( b [ i ] ) == None : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> distance = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print ( distance ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , exit <NEWLINE> <NL> <NL> def main ( readline = stdin . readline ) : <NEWLINE> <INDENT> leap_year = [ not y % 4 and y % 100 or not y % 400 for y in range ( 3001 ) ] <NEWLINE> separator = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> if not a and not b : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> print ( separator , end = <STRING> ) <NEWLINE> <NL> result = <STRING> <NEWLINE> for year , leap in enumerate ( leap_year [ a : b + 1 ] , a ) : <NEWLINE> <INDENT> if leap : <NEWLINE> <INDENT> print ( year ) <NEWLINE> result = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result , end = <STRING> ) <NEWLINE> separator = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ k ] [ j ] [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if not k == 3 : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> c = collections . Counter ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
t = list ( input ( ) ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 and len ( t ) != 1 : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> t [ i + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i != len ( t ) - 1 : <NEWLINE> <INDENT> if t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> elif t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> t [ i + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * t , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> ans = len ( str ( b ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> n = int ( stdin . readline ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 or x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> x //= 10 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i - K ] < A [ i ] else <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> T = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p = int ( S [ - 1 - i ] ) <NEWLINE> T . append ( ( T [ - 1 ] + pow ( 10 , i , 2019 ) * p ) % 2019 ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> ans = 0 <NEWLINE> U = dict ( Counter ( T ) ) <NEWLINE> for num in U : <NEWLINE> <INDENT> ans += U [ num ] * ( U [ num ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum = sum * a [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> w = 0 <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> ans = min ( N , r ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> ans = min ( ans , max ( w , r ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> class Calc ( ) : <NEWLINE> <INDENT> def multi ( self , x , y ) : <NEWLINE> <INDENT> x , y , sign , rslt = str ( x ) + <STRING> , str ( y ) + <STRING> , 1 , <STRING> <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> sign *= - 1 <NEWLINE> x = x [ 1 : ] <NEWLINE> <DEDENT> if y [ 0 ] == <STRING> : <NEWLINE> <INDENT> sign *= - 1 <NEWLINE> y = y [ 1 : ] <NEWLINE> <DEDENT> x , y = x . split ( <STRING> ) , y . split ( <STRING> ) <NEWLINE> x2 = [ int ( x [ 1 ] [ - i - 1 ] ) for i in range ( len ( x [ 1 ] ) ) ] + [ int ( x [ 0 ] [ - i - 1 ] ) for i in range ( len ( x [ 0 ] ) ) ] <NEWLINE> y2 = [ int ( y [ 1 ] [ - i - 1 ] ) for i in range ( len ( y [ 1 ] ) ) ] + [ int ( y [ 0 ] [ - i - 1 ] ) for i in range ( len ( y [ 0 ] ) ) ] <NEWLINE> sum = [ 0 ] * ( len ( x2 ) + len ( y2 ) ) <NEWLINE> for i , p in enumerate ( y2 ) : <NEWLINE> <INDENT> for j , q in enumerate ( x2 ) : <NEWLINE> <INDENT> K = i + j <NEWLINE> sum [ K ] += p * q <NEWLINE> while sum [ K ] > 9 : <NEWLINE> <INDENT> sum [ K + 1 ] , sum [ K ] = sum [ K + 1 ] + int ( sum [ K ] / 10 ) , sum [ K ] % 10 <NEWLINE> K += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( sum ) ) : rslt += str ( sum [ - i - 1 ] ) <NEWLINE> dclen = len ( x [ 1 ] ) + len ( y [ 1 ] ) <NEWLINE> if dclen > 0 : rslt = rslt [ : len ( rslt ) - dclen ] + <STRING> + rslt [ len ( rslt ) - dclen : len ( rslt ) ] <NEWLINE> for i in range ( len ( rslt ) ) : <NEWLINE> <INDENT> if rslt [ i ] == <STRING> and ( rslt [ i + 1 ] if i < len ( rslt ) - 1 else <STRING> ) != <STRING> : continue <NEWLINE> else : <NEWLINE> <INDENT> rslt = rslt [ max ( i , 0 ) : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return ( <STRING> if sign == - 1 else <STRING> ) + rslt <NEWLINE> <NL> <DEDENT> def max_2 ( self , x , y ) : <NEWLINE> <INDENT> X , Y = x , y <NEWLINE> x , y , rslt = str ( x ) + <STRING> , str ( y ) + <STRING> , <STRING> <NEWLINE> if x [ 0 ] == <STRING> and y [ 0 ] != <STRING> : return Y <NEWLINE> if x [ 0 ] != <STRING> and y [ 0 ] == <STRING> : return X <NEWLINE> if x [ 0 ] == <STRING> and y [ 0 ] == <STRING> : return <COMMENT> <NEWLINE> x , y = x . split ( <STRING> ) , y . split ( <STRING> ) <NEWLINE> size0 , size1 = max ( len ( x [ 0 ] ) , len ( y [ 0 ] ) ) , max ( len ( x [ 1 ] ) , len ( y [ 1 ] ) ) <NEWLINE> x [ 0 ] , y [ 0 ] = <STRING> * ( size0 - len ( x [ 0 ] ) ) + x [ 0 ] , <STRING> * ( size0 - len ( y [ 0 ] ) ) + y [ 0 ] <NEWLINE> x [ 1 ] , y [ 1 ] = x [ 1 ] + <STRING> * ( size1 - len ( x [ 1 ] ) ) , y [ 1 ] + <STRING> * ( size1 - len ( y [ 1 ] ) ) <NEWLINE> for s in [ 0 , 1 ] : <NEWLINE> <INDENT> for i in range ( size0 if s == 0 else size1 ) : <NEWLINE> <INDENT> p , q = int ( x [ s ] [ i ] ) , int ( y [ s ] [ i ] ) <NEWLINE> if p == q : continue <NEWLINE> elif p > q : return X <NEWLINE> elif p < q : return Y <NEWLINE> <DEDENT> <DEDENT> return X <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> R , lim = <STRING> , <STRING> + <STRING> * 17 + <STRING> <NEWLINE> if <STRING> in A : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> R = Calc ( ) . multi ( R , A [ i ] ) <NEWLINE> if Calc ( ) . max_2 ( lim , R ) == R : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( R ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if data [ i ] < data [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> def solve ( string ) : <NEWLINE> <INDENT> n , * a = map ( int , string . split ( ) ) <NEWLINE> table = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> ma = max ( a ) <NEWLINE> for _a in a : <NEWLINE> <INDENT> if table [ _a ] : <NEWLINE> <INDENT> for i in range ( 2 * _a , ma + 1 , _a ) : <NEWLINE> <INDENT> table [ i ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return str ( sum ( table [ k ] for k , v in Counter ( a ) . items ( ) if v == 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
<NL> n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> B_T = list ( map ( list , zip ( * B ) ) ) <NEWLINE> <NL> C = [ [ 0 for j in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] [ j ] = sum ( [ a * b for ( a , b ) in zip ( A [ i ] , B_T [ j ] ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( * C [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dist = np . zeros ( N + 1 , dtype = int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dist [ i + 1 ] = dist [ i ] + L [ i ] <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> count = 0 <NEWLINE> while dist [ i ] <= X : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> if i == N + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <STRING> <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N <= 5 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i + 1 , j + 1 ) , math . gcd ( j + 1 , k + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( i + 1 , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( math . gcd ( i + 1 , j + 1 ) , math . gcd ( j + 1 , k + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = set ( int ( x ) for x in read ( ) . split ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( N + 2 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> now = dp [ i ] <NEWLINE> if i + 1 not in a : <NEWLINE> <INDENT> dp [ i + 1 ] += now <NEWLINE> <DEDENT> if i + 2 not in a : <NEWLINE> <INDENT> dp [ i + 2 ] += now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] % 1_000_000_007 ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> d . sort ( ) <NEWLINE> <NL> print ( sum ( d [ : n - k + 1 ] ) ) <NEWLINE>
def grouping ( G ) : <NEWLINE> <INDENT> gid_list = [ 0 ] * len ( G ) <NEWLINE> <NL> gid = 1 <NEWLINE> for i , _ in enumerate ( G ) : <NEWLINE> <INDENT> if gid_list [ i ] > 0 : continue <NEWLINE> q = [ i ] <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . pop ( 0 ) <NEWLINE> gid_list [ v ] = gid <NEWLINE> for v in sorted ( G [ v ] ) : <NEWLINE> <INDENT> if gid_list [ v ] <= 0 : q . append ( v ) <NEWLINE> <DEDENT> <DEDENT> gid += 1 <NEWLINE> <DEDENT> return gid_list <NEWLINE> <NL> <DEDENT> u , n = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( u ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in G [ a ] : G [ a ] . append ( b ) <NEWLINE> if a not in G [ b ] : G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> gid_list = grouping ( G ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if gid_list [ s ] == gid_list [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> a_3 = a [ 3 ] <NEWLINE> a_0 = a [ 0 ] <NEWLINE> a_1 = a [ 1 ] <NEWLINE> a_2 = a [ 2 ] <NEWLINE> <NL> <NL> if a_3 <= a_0 : <NEWLINE> <INDENT> print ( a_3 ) <NEWLINE> <NL> <DEDENT> elif a_3 > a_0 and a_3 <= ( a_0 + a_1 ) : <NEWLINE> <INDENT> print ( a_0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> sum = a_0 - ( a_3 - a_0 - a_1 ) <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , M = [ int ( str ) for str in input ( ) . strip ( ) . split ( ) ] <NEWLINE> H = [ int ( str ) for str in input ( ) . strip ( ) . split ( ) ] <NEWLINE> AB = [ [ int ( str ) - 1 for str in input ( ) . strip ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> G = [ 0 ] * N <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> G [ a ] = max ( G [ a ] , H [ b ] ) <NEWLINE> G [ b ] = max ( G [ b ] , H [ a ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > G [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> lists = [ 0 for i in range ( 2019 ) ] <NEWLINE> lists [ 0 ] += 1 <NEWLINE> <NL> num = 0 <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> num += pow ( 10 , len ( S ) - 1 - i , 2019 ) * int ( S [ i ] ) <NEWLINE> lists [ num % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> if lists [ i ] >= 2 : <NEWLINE> <INDENT> ans += ( lists [ i ] * ( lists [ i ] - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ls = len ( S ) <NEWLINE> t1 = [ ] <NEWLINE> <NL> t = 1 <NEWLINE> for i in range ( 1 , ls ) : <NEWLINE> <INDENT> if S [ i - 1 ] == S [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t > 1 : <NEWLINE> <INDENT> t1 . append ( t ) <NEWLINE> <DEDENT> t = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if t > 1 or t == ls : <NEWLINE> <INDENT> t1 . append ( t ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for t in t1 : <NEWLINE> <INDENT> ans += t // 2 <NEWLINE> <NL> <DEDENT> if len ( t1 ) == 1 : <NEWLINE> <INDENT> if t1 [ 0 ] == ls : <NEWLINE> <INDENT> print ( ls * K // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ 0 ] != S [ - 1 ] : <NEWLINE> <INDENT> print ( ans * K ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ta = t1 [ 0 ] <NEWLINE> tb = t1 [ - 1 ] <NEWLINE> print ( ans * K - ( ta // 2 + tb // 2 - ( ta + tb ) // 2 ) * ( K - 1 ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> <NL> def search ( n , m , tile , N , M ) : <NEWLINE> <INDENT> for dy , dx in zip ( [ - 1 , - 1 , - 1 , 0 , 0 , 1 , 1 , 1 ] , [ - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 ] ) : <NEWLINE> <INDENT> if 0 <= dy + n < N and 0 <= dx + m < M : <NEWLINE> <INDENT> if tile [ dy + n ] [ dx + m ] == <STRING> : <NEWLINE> <INDENT> tile [ dy + n ] [ dx + m ] = <STRING> <NEWLINE> search ( dy + n , dx + m , tile , N , M ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> M , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if M == 0 and N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tile = [ input ( ) . split ( ) for n in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> for m in range ( M ) : <NEWLINE> <INDENT> if tile [ n ] [ m ] == <STRING> : <NEWLINE> <INDENT> tile [ n ] [ m ] = <STRING> <NEWLINE> search ( n , m , tile , N , M ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ ] <NEWLINE> for j in range ( 30 ) : <NEWLINE> <INDENT> p . append ( pow ( 2 , j ) ) <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = t ^ a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( 30 ) : <NEWLINE> <INDENT> ans = ans + p [ j ] * ( ( ( a [ i ] ^ t ) // p [ j ] ) % 2 ) <NEWLINE> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> count = - 1 <NEWLINE> n = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if n % K == 0 : <NEWLINE> <INDENT> count = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> n = int ( str ( n ) + <STRING> ) <NEWLINE> n %= K <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> l = len ( ai ) <NEWLINE> <NL> integ = [ ai [ 0 ] ] * len ( ai ) <NEWLINE> for i in range ( 1 , len ( ai ) ) : <NEWLINE> <INDENT> integ [ i ] = integ [ i - 1 ] + ai [ i ] <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> this_s = integ [ - 1 ] - integ [ j ] <NEWLINE> s += ai [ j ] * this_s <NEWLINE> <NL> <DEDENT> ans = s % ( 1000000000 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> answer *= i <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> import time <NEWLINE> st = time . time ( ) <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> clist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> last_c = [ 0 ] * 26 <NEWLINE> select_c = [ 0 ] * 26 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> select_c [ i ] = [ ] <NEWLINE> <NL> <DEDENT> slist = [ 0 ] * d <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> slist [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> tlist = [ 0 ] * d <NEWLINE> satisfy = [ 0 ] * ( d + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 0 , d ) : <NEWLINE> <INDENT> max = 0 <NEWLINE> max_n = 0 <NEWLINE> for n in range ( 26 ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> curr = slist [ i ] [ n ] + satisfy [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> curr = slist [ i ] [ n ] <NEWLINE> <DEDENT> minus = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if n != j : <NEWLINE> <INDENT> minus -= clist [ j ] * ( i - last_c [ j ] ) <NEWLINE> <DEDENT> <DEDENT> curr += minus <NEWLINE> if curr > max : <NEWLINE> <INDENT> max = curr <NEWLINE> max_n = n <NEWLINE> <DEDENT> <DEDENT> satisfy [ i ] = max <NEWLINE> last_c [ max_n ] = i + 1 <NEWLINE> select_c [ max_n ] . append ( i + 1 ) <NEWLINE> tlist [ i ] = max_n + 1 <NEWLINE> <NL> <DEDENT> import random <NEWLINE> import numpy as np <NEWLINE> <NL> sum = 0 <NEWLINE> total_c = 0 <NEWLINE> <NL> <NL> for i in range ( d ) : <NEWLINE> <INDENT> sum += slist [ i ] [ tlist [ i ] - 1 ] <NEWLINE> <NL> <DEDENT> ct = time . time ( ) <NEWLINE> <NL> for i in range ( len ( select_c ) ) : <NEWLINE> <INDENT> start = 1 <NEWLINE> c_change = 0 <NEWLINE> if select_c [ i ] == [ ] : <NEWLINE> <INDENT> c_change = np . sum ( np . arange ( d + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( select_c [ i ] ) ) : <NEWLINE> <INDENT> end = select_c [ i ] [ j ] <NEWLINE> if end > start : <NEWLINE> <INDENT> c_change += np . sum ( np . arange ( end - start + 1 ) ) <NEWLINE> <DEDENT> start = end <NEWLINE> <DEDENT> end = d + 1 <NEWLINE> c_change += np . sum ( np . arange ( end - start ) ) <NEWLINE> start = end <NEWLINE> <DEDENT> total_c += clist [ i ] * c_change <NEWLINE> <NL> <DEDENT> current_max = sum - total_c <NEWLINE> <NL> import bisect <NEWLINE> while ct - st < 1.9 : <NEWLINE> <INDENT> change_d = random . randint ( 1 , d ) <NEWLINE> change_d_to_c = random . randint ( 0 , len ( select_c ) - 1 ) <NEWLINE> for x in range ( len ( select_c ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ind = select_c [ x ] . index ( change_d ) <NEWLINE> change = x <NEWLINE> s_change = slist [ change_d - 1 ] [ ind ] <NEWLINE> select_c [ x ] . remove ( change_d ) <NEWLINE> break <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> None <NEWLINE> <NL> <DEDENT> <DEDENT> s_change2 = slist [ change_d - 1 ] [ change_d_to_c ] <NEWLINE> <NL> bisect . insort ( select_c [ change_d_to_c ] , change_d ) <NEWLINE> <COMMENT> <NL> sum2 = sum - s_change + s_change2 <NEWLINE> total_c2 = 0 <NEWLINE> for i in range ( len ( select_c ) ) : <NEWLINE> <INDENT> start = 1 <NEWLINE> c_change = 0 <NEWLINE> if select_c [ i ] == [ ] : <NEWLINE> <INDENT> c_change = np . sum ( np . arange ( d + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( select_c [ i ] ) ) : <NEWLINE> <INDENT> end = select_c [ i ] [ j ] <NEWLINE> if end > start : <NEWLINE> <INDENT> c_change += np . sum ( np . arange ( end - start + 1 ) ) <NEWLINE> <DEDENT> start = end <NEWLINE> <DEDENT> end = d + 1 <NEWLINE> c_change += np . sum ( np . arange ( end - start ) ) <NEWLINE> start = end <NEWLINE> <DEDENT> total_c2 += clist [ i ] * c_change <NEWLINE> <NL> <DEDENT> if sum - total_c < sum2 - total_c2 : <NEWLINE> <INDENT> sum = sum2 <NEWLINE> total_c = total_c2 <NEWLINE> tlist [ change_d - 1 ] = change_d_to_c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bisect . insort ( select_c [ change ] , change_d ) <NEWLINE> select_c [ change_d_to_c ] . remove ( change_d ) <NEWLINE> <NL> <DEDENT> ct = time . time ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in tlist : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> for i in range ( d ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> n -= 1 <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> def Base_10_to_n ( X , n , ans ) : <NEWLINE> <INDENT> if ( int ( X / n ) ) : <NEWLINE> <INDENT> ans . append ( chr ( ord ( <STRING> ) + ( X % n ) ) ) <NEWLINE> return Base_10_to_n ( int ( X / n ) - 1 , n , ans ) + str ( X % n ) <NEWLINE> <DEDENT> ans . append ( chr ( ord ( <STRING> ) + ( X % n ) ) ) <NEWLINE> return str ( X % n ) <NEWLINE> <NL> <DEDENT> num = Base_10_to_n ( n , 26 , ans ) <NEWLINE> <NL> ans . reverse ( ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def input ( ) -> str : <COMMENT> <NEWLINE> <INDENT> <STRING> <NEWLINE> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> RESULT_TEXT = { <NEWLINE> <INDENT> 1 : <STRING> , <NEWLINE> 2 : <STRING> , <NEWLINE> 3 : <STRING> , <NEWLINE> <DEDENT> } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> MAX = 1000000 + 1 <NEWLINE> counts = [ 0 ] * MAX <NEWLINE> for a in a_list : <NEWLINE> <INDENT> counts [ a ] += 1 <NEWLINE> <NL> <DEDENT> max_count = 0 <NEWLINE> <NL> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> max_count = max ( max_count , sum ( counts [ i : : i ] ) ) <NEWLINE> <NL> <DEDENT> if max_count == n : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif max_count >= 2 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> print ( RESULT_TEXT [ ans ] ) <NEWLINE>
ans = 0 <NEWLINE> R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> rl = ( N + R - 1 ) // R + 1 <NEWLINE> gl = ( N + G - 1 ) // G + 1 <NEWLINE> bl = ( N + B - 1 ) // B <NEWLINE> for r in range ( rl ) : <NEWLINE> <INDENT> for g in range ( gl ) : <NEWLINE> <INDENT> tmp = N - ( r * R ) - ( g * G ) <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif tmp % B == 0 and tmp % B <= bl : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def equal ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = equal ( x , y , z ) <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in dic : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( dic ) ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) <NEWLINE> t = ( 10 ** 9 ) + 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if abs ( i - ( m // 2 ) ) < t and i != m : <NEWLINE> <INDENT> t = abs ( i - ( m // 2 ) ) <NEWLINE> s = i <NEWLINE> <DEDENT> <DEDENT> print ( m , s ) <NEWLINE>
a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> N = a [ 0 ] <NEWLINE> si = a [ 1 ] <NEWLINE> ti = a [ 2 ] <NEWLINE> s = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> s = sorted ( s ) <NEWLINE> X = int ( 0 ) <NEWLINE> ans = int ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> while N != X : <NEWLINE> <COMMENT> <NL> <INDENT> X += 1 <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> if N == X : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> temp = X <NEWLINE> for i in range ( min ( [ si - 1 , N - X ] ) ) : <NEWLINE> <INDENT> if s [ temp + i ] <= s [ temp - 1 ] + ti : <NEWLINE> <INDENT> X += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> height = np . array ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> height_all = np . array ( list ( height ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> if height [ a - 1 ] > height [ b - 1 ] : <NEWLINE> <INDENT> height_all [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> elif height [ a - 1 ] == height [ b - 1 ] : <NEWLINE> <INDENT> height_all [ a - 1 ] = 0 <NEWLINE> height_all [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> height_all [ a - 1 ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( len ( np . nonzero ( height_all ) [ 0 ] ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for b in range ( 1 << n ) : <NEWLINE> <INDENT> a = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b & ( 1 << i ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k , l in enumerate ( cc [ i ] ) : <NEWLINE> <INDENT> a [ k ] += l <NEWLINE> <DEDENT> if min ( a [ 1 : ] ) >= x : <NEWLINE> <INDENT> ans = min ( ans , a [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> a = [ 0 ] * ( m + 1 ) <NEWLINE> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i + K ] > A [ i ] : <NEWLINE> <INDENT> p . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ j ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t = deque ( list ( ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) ) <NEWLINE> A . append ( t ) <NEWLINE> <NL> <DEDENT> que = deque ( list ( range ( n ) ) ) <NEWLINE> res = 0 <NEWLINE> emp = [ False ] * n <NEWLINE> while que : <NEWLINE> <INDENT> next_que = deque ( [ ] ) <NEWLINE> check = set ( ) <NEWLINE> while que : <NEWLINE> <INDENT> i = que . popleft ( ) <NEWLINE> if A [ i ] : <NEWLINE> <INDENT> idx = A [ i ] [ 0 ] <NEWLINE> if i not in check and idx not in check and A [ idx ] [ 0 ] == i : <NEWLINE> <INDENT> A [ i ] . popleft ( ) <NEWLINE> A [ idx ] . popleft ( ) <NEWLINE> next_que . append ( i ) <NEWLINE> next_que . append ( idx ) <NEWLINE> check . add ( i ) <NEWLINE> check . add ( idx ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> emp [ i ] = True <NEWLINE> <DEDENT> <DEDENT> que = next_que <NEWLINE> if que : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res if all ( emp ) else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> arr . append ( S ) <NEWLINE> <NL> <DEDENT> arr . sort ( ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = arr [ i ] <NEWLINE> b = arr [ i + 1 ] <NEWLINE> if a != b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( cnt ) ) <NEWLINE>
<COMMENT> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , ID , left , right ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . id = ID <NEWLINE> self . parent = - 1 <COMMENT> <NEWLINE> self . sibling = - 1 <COMMENT> <NEWLINE> self . degree = - 1 <COMMENT> <NEWLINE> self . depth = - 1 <COMMENT> <NEWLINE> self . height = - 1 <COMMENT> <NEWLINE> self . type = None <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_depth ( i ) : <NEWLINE> <INDENT> global node_list <NEWLINE> <NL> if node_list [ i ] . depth != - 1 : <NEWLINE> <INDENT> return node_list [ i ] . depth <NEWLINE> <NL> <DEDENT> depth = 0 <NEWLINE> if node_list [ i ] . parent != - 1 : <NEWLINE> <INDENT> depth = calc_depth ( node_list [ i ] . parent ) + 1 <NEWLINE> <NL> <DEDENT> node_list [ i ] . depth = depth <NEWLINE> return depth <NEWLINE> <NL> <NL> <DEDENT> def calc_height ( i ) : <NEWLINE> <INDENT> global node_list <NEWLINE> <NL> if node_list [ i ] . height != - 1 : <NEWLINE> <INDENT> return node_list [ i ] . height <NEWLINE> <NL> <DEDENT> h1 = h2 = 0 <NEWLINE> if node_list [ i ] . right != - 1 : <NEWLINE> <INDENT> h1 = calc_height ( node_list [ i ] . right ) + 1 <NEWLINE> <DEDENT> if node_list [ i ] . left != - 1 : <NEWLINE> <INDENT> h2 = calc_height ( node_list [ i ] . left ) + 1 <NEWLINE> <NL> <DEDENT> height = max ( h1 , h2 ) <NEWLINE> node_list [ i ] . height = height <NEWLINE> return height <NEWLINE> <NL> <DEDENT> def pre_order ( node ) : <NEWLINE> <INDENT> global node_list <NEWLINE> global pre_ordered_node_list <NEWLINE> <NL> if node == - 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> pre_ordered_node_list . append ( node ) <NEWLINE> pre_order ( node_list [ node ] . left ) <NEWLINE> pre_order ( node_list [ node ] . right ) <NEWLINE> <NL> <DEDENT> def in_order ( node ) : <NEWLINE> <INDENT> global node_list <NEWLINE> global in_ordered_node_list <NEWLINE> <NL> if node == - 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> in_order ( node_list [ node ] . left ) <NEWLINE> in_ordered_node_list . append ( node ) <NEWLINE> in_order ( node_list [ node ] . right ) <NEWLINE> <NL> <DEDENT> def post_order ( node ) : <NEWLINE> <INDENT> global node_list <NEWLINE> global post_ordered_node_list <NEWLINE> <NL> if node == - 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> post_order ( node_list [ node ] . left ) <NEWLINE> post_order ( node_list [ node ] . right ) <NEWLINE> post_ordered_node_list . append ( node ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> data = [ tuple ( map ( int , input ( ) . split ( ) ) ) for x in range ( n ) ] <NEWLINE> node_list = [ ] <NEWLINE> root_node = None <NEWLINE> pre_ordered_node_list = [ ] <NEWLINE> in_ordered_node_list = [ ] <NEWLINE> post_ordered_node_list = [ ] <NEWLINE> <NL> for data_row in data : <NEWLINE> <INDENT> ID , left , right = data_row <NEWLINE> node = Node ( ID , left , right ) <NEWLINE> node_list . append ( node ) <NEWLINE> <NL> <DEDENT> node_list . sort ( key = lambda node : node . id ) <NEWLINE> <NL> for i , node in enumerate ( node_list ) : <NEWLINE> <INDENT> left = node . left <NEWLINE> right = node . right <NEWLINE> degree = 0 <NEWLINE> <NL> <COMMENT> <NL> if left != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> node_list [ left ] . parent = i <NEWLINE> node_list [ left ] . sibling = right <NEWLINE> <NL> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> node_list [ right ] . parent = i <NEWLINE> node_list [ right ] . sibling = left <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> node . degree = degree <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> calc_depth ( i ) <NEWLINE> calc_height ( i ) <NEWLINE> <NL> node = node_list [ i ] <NEWLINE> <NL> if node . depth == 0 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> root_node = node . id <NEWLINE> <DEDENT> elif node . height == 0 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> pre_order ( root_node ) <NEWLINE> in_order ( root_node ) <NEWLINE> post_order ( root_node ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( <STRING> , * pre_ordered_node_list ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , * in_ordered_node_list ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> , * post_ordered_node_list ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> <NL> def test ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> rcv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> items = np . zeros ( ( R + 1 , C + 1 ) , dtype = <STRING> ) <NEWLINE> for item in rcv : <NEWLINE> <INDENT> items [ item [ 0 ] ] [ item [ 1 ] ] = item [ 2 ] <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( R + 1 , C + 1 ) , dtype = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> for j in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , C + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ j ] [ i ] = max ( dp [ j ] [ i ] , dp [ j - 1 ] [ i ] + items [ j ] [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> dp [ j ] [ i ] = max ( dp [ j ] [ i ] , dp [ j ] [ i - 1 ] + items [ j ] [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ R ] [ C ] ) <NEWLINE> <NL> <NL> <DEDENT> @ jit <NEWLINE> def main ( R , C , items ) : <NEWLINE> <NL> <INDENT> dp = np . zeros ( ( 4 , R + 1 , C + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dp [ 0 ] [ i ] [ j ] = max ( dp [ 0 ] [ i ] [ j ] , dp [ k ] [ i - 1 ] [ j ] ) <NEWLINE> <COMMENT> <NL> dp [ 1 ] [ i ] [ j ] = max ( dp [ 1 ] [ i ] [ j ] , dp [ k ] [ i - 1 ] [ j ] + items [ i ] [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> dp [ k ] [ i ] [ j ] = max ( dp [ k ] [ i ] [ j ] , dp [ k ] [ i ] [ j - 1 ] ) <NEWLINE> <COMMENT> <NL> if k > 0 : <NEWLINE> <INDENT> dp [ k ] [ i ] [ j ] = max ( dp [ k ] [ i ] [ j ] , dp [ k - 1 ] <NEWLINE> <INDENT> [ i ] [ j - 1 ] + items [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> if ans < dp [ k ] [ R ] [ C ] : <NEWLINE> <INDENT> ans = dp [ k ] [ R ] [ C ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> rcv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> items = np . zeros ( ( R + 1 , C + 1 ) , dtype = np . int64 ) <NEWLINE> for item in rcv : <NEWLINE> <INDENT> items [ item [ 0 ] ] [ item [ 1 ] ] = item [ 2 ] <NEWLINE> <DEDENT> main ( R , C , items ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( input ( ) for _ in range ( n ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> ans = N <NEWLINE> <NL> left_W = 0 <NEWLINE> right_E = S [ 1 : ] . count ( <STRING> ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans = min ( ans , S [ 1 : ] . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> elif n == N - 1 : <NEWLINE> <INDENT> ans = min ( ans , S [ : n ] . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if S [ n ] == <STRING> : <NEWLINE> <INDENT> right_E -= 1 <NEWLINE> <DEDENT> if S [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> left_W += 1 <NEWLINE> <DEDENT> ans = min ( ans , left_W + right_E ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> num = list ( map ( int , N ) ) <NEWLINE> <NL> sum = sum ( num ) <NEWLINE> <NL> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = ( 10 ** 9 + 7 ) <NEWLINE> <NL> def calc ( i ) : <NEWLINE> <INDENT> small = i * ( i - 1 ) // 2 <NEWLINE> large = i * ( 2 * N - i + 1 ) // 2 <NEWLINE> return large - small + 1 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> total += calc ( i ) <NEWLINE> total %= mod <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = set ( A ) <NEWLINE> C = Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i not in B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <COMMENT> <NL> a = np . array ( sys . stdin . readline ( ) . split ( ) , dtype = <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> t1 = 0 <NEWLINE> t2 = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for l in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j == l : <NEWLINE> <INDENT> t = t + i <NEWLINE> <DEDENT> elif i == j or j == l or l == i : <NEWLINE> <INDENT> t = t + 3 * gcd ( i , j , l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = t + 6 * gcd ( i , j , l ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
import time <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> stime = time . time ( ) <NEWLINE> F = [ 0 ] * ( n + 1 ) <NEWLINE> F [ 0 ] = 1 <NEWLINE> F [ 1 ] = 2 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> etime = time . time ( ) <NEWLINE> <NL> <NL> a = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> io = - 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if 0 != a [ i ] : <NEWLINE> <INDENT> io = i + 1 <NEWLINE> if 0 != a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ i + 1 ] and i - io > 1 : <NEWLINE> <INDENT> ans *= F [ i - io - 1 ] % MOD <NEWLINE> s = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = n - 1 <NEWLINE> if i - io > 0 : <NEWLINE> <INDENT> ans *= F [ i - io - 1 ] % MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> d = [ 0 for i in range ( MOD ) ] <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> k = 0 <NEWLINE> d [ 0 ] = 1 <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <COMMENT> <NL> p = 1 <NEWLINE> for i in s : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> k = ( p * int ( i ) + k ) % MOD <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans += d [ k ] <NEWLINE> d [ k ] += 1 <NEWLINE> p = ( p * 10 ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> k -= ( a + b ) <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a <NEWLINE> <NL> <DEDENT> print ( ans - k ) <NEWLINE>
<NL> def howManyPresent ( N ) : <NEWLINE> <INDENT> seen = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p = str ( input ( ) ) <NEWLINE> seen . append ( p ) <NEWLINE> <DEDENT> return len ( set ( seen ) ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> print ( howManyPresent ( N ) ) <NEWLINE>
target = int ( input ( ) ) <NEWLINE> num = target <NEWLINE> waru = 2 <NEWLINE> exp = [ ] <NEWLINE> while waru ** 2 <= target and num > 1 : <NEWLINE> <INDENT> rep = 0 <NEWLINE> while num % waru == 0 : <NEWLINE> <INDENT> num /= waru <NEWLINE> rep += 1 <NEWLINE> <DEDENT> waru += 1 <NEWLINE> if rep > 0 : <NEWLINE> <INDENT> exp . append ( rep ) <NEWLINE> <DEDENT> <DEDENT> if num > 1 : <NEWLINE> <INDENT> exp . append ( 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for item in exp : <NEWLINE> <INDENT> hiku = 1 <NEWLINE> while item - hiku >= 0 : <NEWLINE> <INDENT> item -= hiku <NEWLINE> ans += 1 <NEWLINE> hiku += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> l = len ( t ) <NEWLINE> ans = 0 <NEWLINE> a = 0 <NEWLINE> list1 = [ 0 ] <NEWLINE> for i in range ( len ( s ) - l + 1 ) : <NEWLINE> <INDENT> ss = list ( s [ i : i + l ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> if ss [ j ] == t [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> list1 . append ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <DEDENT> m = max ( list1 ) <NEWLINE> print ( l - m ) <NEWLINE>
def calc ( n ) : <NEWLINE> <INDENT> x = 1 << ( n . bit_length ( ) + 4 ) // 5 <NEWLINE> y = ( 4 * x + n // ( x ** 4 ) ) // 5 <NEWLINE> while y < x : <NEWLINE> <INDENT> x = y <NEWLINE> y = ( 4 * x + n // ( x ** 4 ) ) // 5 <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> return calc ( n ) if n > 0 and calc ( n ) ** 5 == n else 0 <NEWLINE> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> for i in range ( 1 << 10 ) : <NEWLINE> <INDENT> a = f ( X + i ** 5 ) <NEWLINE> if a : <NEWLINE> <INDENT> print ( a , i ) <NEWLINE> break <NEWLINE> <DEDENT> a = f ( X - i ** 5 ) <NEWLINE> if a : <NEWLINE> <INDENT> print ( a , - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> chk = [ 0 for i in range ( m ) ] <NEWLINE> a = x <NEWLINE> s = x <NEWLINE> c = 0 <NEWLINE> ary = [ x ] <NEWLINE> flg = False <NEWLINE> while True : <NEWLINE> <INDENT> if c == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = ( x ** 2 ) % m <NEWLINE> s += x <NEWLINE> c += 1 <NEWLINE> if chk [ x ] : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> ary . append ( x ) <NEWLINE> chk [ x ] = c <NEWLINE> <DEDENT> if flg == False : <NEWLINE> <INDENT> print ( sum ( ary [ : - 1 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cyc = ary [ chk [ x ] : ] <NEWLINE> l1 = len ( cyc ) <NEWLINE> ss = ary [ : chk [ x ] ] <NEWLINE> l2 = len ( ss ) <NEWLINE> tot = sum ( ss ) + sum ( cyc ) * ( ( n - l2 ) // l1 ) + sum ( cyc [ : ( ( n - l2 ) % l1 ) ] ) <NEWLINE> print ( tot ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors , upper_divisors <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> low , up = make_divisors ( n ) <NEWLINE> if len ( low ) != 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( low [ - 1 ] + up [ - 1 ] - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> from itertools import permutations <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , deque <NEWLINE> from math import factorial , sqrt , gcd <NEWLINE> from functools import lru_cache , reduce <NEWLINE> INF = 1 << 60 <NEWLINE> mod = 1000000007 <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def dijkstra_heap ( s , edge , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ 10 ** 20 ] * n <NEWLINE> used = [ True ] * n <COMMENT> <NEWLINE> d [ s ] = 0 <NEWLINE> used [ s ] = False <NEWLINE> edgelist = [ ] <NEWLINE> for a , b in edge [ s ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , a * ( 10 ** 6 ) + b ) <NEWLINE> <DEDENT> while len ( edgelist ) : <NEWLINE> <INDENT> minedge = heapq . heappop ( edgelist ) <NEWLINE> <COMMENT> <NL> if not used [ minedge % ( 10 ** 6 ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = minedge % ( 10 ** 6 ) <NEWLINE> d [ v ] = minedge // ( 10 ** 6 ) <NEWLINE> used [ v ] = False <NEWLINE> for e in edge [ v ] : <NEWLINE> <INDENT> if used [ e [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , ( e [ 0 ] + d [ v ] ) * ( 10 ** 6 ) + e [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm , numbers , 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( gcd , numbers ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans3 = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> print ( ans3 [ k - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> iim = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = iim ( ) <NEWLINE> it = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> <NL> d1 = defaultdict ( list ) <NEWLINE> <NL> for i , j in zip ( it , it ) : <NEWLINE> <INDENT> d1 [ i ] . append ( j ) <NEWLINE> d1 [ j ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> dq = [ 1 ] <NEWLINE> visited = set ( [ 1 ] ) <NEWLINE> <NL> updated = True <NEWLINE> while updated : <NEWLINE> <INDENT> updated = False <NEWLINE> dq2 = [ ] <NEWLINE> for i in dq : <NEWLINE> <INDENT> for j in d1 [ i ] : <NEWLINE> <INDENT> if j in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ j ] = i <NEWLINE> dq2 . append ( j ) <NEWLINE> visited . add ( j ) <NEWLINE> updated = True <NEWLINE> <DEDENT> <DEDENT> dq = dq2 <NEWLINE> <NL> <DEDENT> if len ( visited ) == N : <NEWLINE> <INDENT> print ( <STRING> , * ans [ 2 : ] , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> s_par = [ i for i in range ( n + 1 ) ] <NEWLINE> t_par = [ i for i in range ( n + 1 ) ] <NEWLINE> <NL> def operation ( x , par ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if x [ i ] == x [ j ] : <NEWLINE> <INDENT> par [ i ] = par [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return par <NEWLINE> <NL> <DEDENT> if operation ( s , s_par ) == operation ( t , t_par ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> n = 7 <NEWLINE> ans = 1 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while n % k != 0 : <NEWLINE> <INDENT> n = ( n * 10 + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = { X : 0 } <NEWLINE> l = [ X ] <NEWLINE> s = X <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l += [ ( l [ i - 1 ] ** 2 ) % M ] <NEWLINE> s += l [ i ] <NEWLINE> if l [ i ] in d : <NEWLINE> <INDENT> dl = l [ d [ l [ i ] ] + 1 : ] <NEWLINE> s += sum ( dl ) * ( ( N - i - 1 ) // len ( dl ) ) <NEWLINE> if ( N - i - 1 ) % len ( dl ) != 0 : <NEWLINE> <INDENT> s += sum ( dl [ 0 : ( N - i - 1 ) % len ( dl ) ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> d [ l [ i ] ] = i <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <DEDENT> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> d = Counter ( A ) <NEWLINE> <NL> sub_s = sum ( A ) <NEWLINE> <NL> for b , c in BC : <NEWLINE> <INDENT> sub_s += d [ b ] * ( c - b ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <NL> print ( sub_s ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ - 1 for _ in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> clis = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> clis . append ( c ) <NEWLINE> <DEDENT> if len ( set ( clis ) ) == 1 : <NEWLINE> <INDENT> print ( clis [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( set ( clis ) ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if s == 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans [ s - 1 ] == c or ans [ s - 1 ] == - 1 : <NEWLINE> <INDENT> ans [ s - 1 ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans [ 0 ] = max ( 1 , ans [ 0 ] ) <NEWLINE> answer = <STRING> <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if ans [ k ] == - 1 : <NEWLINE> <INDENT> answer += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer += str ( ans [ k ] ) <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ 2 * j - i ] and S [ 2 * j - i ] != S [ i ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count += r * g * b <NEWLINE> print ( count ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> nmax = K <NEWLINE> <DEDENT> elif B >= K - A : <NEWLINE> <INDENT> nmax = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nmax = A - ( K - A - B ) <NEWLINE> <NL> <DEDENT> print ( nmax ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> A = list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( len ( l ) ) : <NEWLINE> <INDENT> if A [ i ] [ l [ j ] [ 1 ] - 1 ] - A [ i ] [ l [ j ] [ 0 ] - 1 ] == l [ j ] [ 2 ] : <NEWLINE> <INDENT> tmp += l [ j ] [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> res = max ( res , tmp ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> pos = int ( input ( ) ) <NEWLINE> a [ pos ] = 1 <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> step = [ 0 ] * ( n + 1 ) <NEWLINE> step [ 0 ] = 1 <NEWLINE> step [ 1 ] = 1 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> step [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != 0 and i != 1 : <NEWLINE> <INDENT> step [ i ] = ( step [ i - 1 ] + step [ i - 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( step [ - 1 ] ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 0 for n in range ( N ) ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> L [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if K - ( Q - L [ j ] ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> a = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a [ b ] = 1 <NEWLINE> <DEDENT> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 2 ] <NEWLINE> <DEDENT> dp [ i ] = dp [ i ] % mod <NEWLINE> <DEDENT> print ( dp [ N ] % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c *= a [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
length0 = input ( ) <NEWLINE> <COMMENT> <NL> length = length0 . split ( ) <NEWLINE> a = int ( length [ 0 ] ) <NEWLINE> b = int ( length [ 1 ] ) <NEWLINE> <COMMENT> <NL> area = a * b <NEWLINE> per = 2 * a + 2 * b <NEWLINE> print ( str ( area ) + <STRING> + str ( per ) ) <NEWLINE>
from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( A [ i ] + i + 1 ) <NEWLINE> r . append ( i + 1 - A [ i ] ) <NEWLINE> <NL> <DEDENT> C = Counter ( r ) <NEWLINE> <NL> for x in l : <NEWLINE> <INDENT> c += C . get ( x , 0 ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] <NEWLINE> f = [ 0 ] * a <NEWLINE> f [ 0 ] += 1 <NEWLINE> tmp = 1 <NEWLINE> s = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> l . append ( c [ tmp - 1 ] ) <NEWLINE> tmp = c [ tmp - 1 ] <NEWLINE> if f [ tmp - 1 ] != 0 : <NEWLINE> <INDENT> s = c [ tmp - 1 ] <NEWLINE> t = len ( l ) + 1 <NEWLINE> break <NEWLINE> <DEDENT> f [ tmp - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( l [ b ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> h = l . index ( s ) + 1 <NEWLINE> <NL> <COMMENT> <NL> l2 = l [ h - 1 : t - 1 ] <NEWLINE> <COMMENT> <NL> if s == 1 : <NEWLINE> <INDENT> id = b % ( t - 1 ) <NEWLINE> print ( l2 [ id ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> id = ( b - h + 1 ) % ( t - h ) <NEWLINE> print ( l2 [ id ] ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = X <NEWLINE> hist = [ a ] <NEWLINE> indices = [ - 1 ] * M <NEWLINE> indices [ a ] = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( 1 , min ( 10 ** 6 , N ) ) : <NEWLINE> <INDENT> a = a ** 2 % M <NEWLINE> if indices [ a ] != - 1 : <NEWLINE> <INDENT> idx = indices [ a ] <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> hist . append ( a ) <NEWLINE> indices [ a ] = i <NEWLINE> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( sum ( hist ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cycle = hist [ idx : ] <NEWLINE> margin = hist [ : idx ] <NEWLINE> q , r = divmod ( ( N - len ( margin ) ) , len ( cycle ) ) <NEWLINE> print ( sum ( margin ) + sum ( cycle ) * q + sum ( cycle [ : r ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( lambda x : x - 1 , A ) ) <NEWLINE> <NL> next = 0 <NEWLINE> hoge = [ ] <NEWLINE> zisyo = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> next = A [ next ] <NEWLINE> if next in zisyo : <NEWLINE> <INDENT> t = next <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zisyo [ next ] = 1 <NEWLINE> hoge . append ( next ) <NEWLINE> <DEDENT> <DEDENT> hoge_1 = [ ] <NEWLINE> hoge_2 = [ ] <NEWLINE> for i in range ( len ( hoge ) ) : <NEWLINE> <INDENT> if hoge [ i ] == t : <NEWLINE> <INDENT> hoge_1 = hoge [ : i ] <NEWLINE> hoge_2 = hoge [ i : ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if k <= len ( hoge_1 ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k = k - len ( hoge_1 ) - 1 <NEWLINE> k = k % len ( hoge_2 ) <NEWLINE> ans = hoge_2 [ 0 ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , d = 0 , dict ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> key = A [ i ] + i <NEWLINE> if d . get ( key ) == None : <NEWLINE> <INDENT> d [ key ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ key ] += 1 <NEWLINE> <NL> <DEDENT> key = i - A [ i ] <NEWLINE> if d . get ( key ) != None : <NEWLINE> <INDENT> ans += d [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> R = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in L : <NEWLINE> <INDENT> R [ i - 1 ] += 1 <NEWLINE> <DEDENT> ans = sum ( L ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ b - 1 ] += R [ a - 1 ] <NEWLINE> ans += ( b - a ) * R [ a - 1 ] <NEWLINE> R [ a - 1 ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ [ int ( c ) for c in l . split ( ) ] for l in sys . stdin ] <NEWLINE> a = a [ 0 ] <NEWLINE> m = 1 <NEWLINE> <NL> if ( 0 in a ) == True : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> m *= a [ i ] <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> m = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n , m = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = [ 1 ] * n <NEWLINE> ans = int ( 0 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> temp [ b - 1 ] *= 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> temp [ a - 1 ] *= 0 <NEWLINE> temp [ b - 1 ] *= 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp [ a - 1 ] *= 0 <NEWLINE> <DEDENT> <DEDENT> ans += temp . count ( 1 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> x = i <NEWLINE> while ( x ) : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , line . split ( ) ) <NEWLINE> x = ( c * e - f * b ) / ( a * e - d * b ) <NEWLINE> y = ( c * d - f * a ) / ( b * d - e * a ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> if y == 0 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> num = ( int ) ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> sub = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( sub , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 3 != 0 : <NEWLINE> <INDENT> if ( i + 1 ) % 5 != 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> s ^= x <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for x in a : <NEWLINE> <INDENT> ans += str ( s ^ x ) + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> table = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> table [ - 2 - i ] = ( int ( s [ - 1 - i ] ) * pow ( 10 , i , 2019 ) + table [ - 1 - i ] ) % 2019 <NEWLINE> <DEDENT> count = [ 0 for _ in range ( 2019 ) ] <NEWLINE> ans = 0 <NEWLINE> for t in table : <NEWLINE> <INDENT> if count [ t ] != 0 : <NEWLINE> <INDENT> ans += count [ t ] <NEWLINE> <DEDENT> count [ t ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> T = False <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> T = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = a [ i ] / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if T : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
num = input ( ) <NEWLINE> data = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> ans = 1 <NEWLINE> if <STRING> in data : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in data : <NEWLINE> <INDENT> ans = ans * int ( i ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> ls = [ 1 ] + [ 0 ] * 2018 <NEWLINE> ans = 0 <NEWLINE> temp = 0 <NEWLINE> m = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> temp = ( temp + m * int ( s [ - i - 1 ] ) ) % mod <NEWLINE> m = ( m * 10 ) % mod <NEWLINE> <NL> ls [ temp ] += 1 <NEWLINE> <NL> <DEDENT> for i in ls : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , fromNode , toNode , cap , rev = None ) : <NEWLINE> <INDENT> self . fromNode = fromNode <NEWLINE> self . toNode = toNode <NEWLINE> self . cap = cap <NEWLINE> self . rev = rev <NEWLINE> <NL> <DEDENT> <DEDENT> class MaxFlow : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . v = V <NEWLINE> self . edges = [ [ ] for _ in range ( V ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , fromNode , toNode , cap ) : <NEWLINE> <INDENT> forEdge = Edge ( fromNode , toNode , cap ) <NEWLINE> backEdge = Edge ( toNode , fromNode , 0 ) <NEWLINE> forEdge . rev = backEdge <NEWLINE> backEdge . rev = forEdge <NEWLINE> self . edges [ fromNode ] . append ( forEdge ) <NEWLINE> self . edges [ toNode ] . append ( backEdge ) <NEWLINE> <NL> <DEDENT> def bfs ( self , source , sink ) : <NEWLINE> <INDENT> self . level = [ None ] * self . v <NEWLINE> self . level [ source ] = 0 <NEWLINE> que = deque ( ) <NEWLINE> que . append ( source ) <NEWLINE> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> newLevel = self . level [ node ] + 1 <NEWLINE> for edge in self . edges [ node ] : <NEWLINE> <INDENT> if edge . cap and self . level [ edge . toNode ] is None : <NEWLINE> <INDENT> self . level [ edge . toNode ] = newLevel <NEWLINE> que . append ( edge . toNode ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return self . level [ sink ] is not None <NEWLINE> <NL> <DEDENT> def dfs ( self , node , sink , f ) : <NEWLINE> <INDENT> if node == sink : return f <NEWLINE> <NL> for edge in self . edges [ node ] : <NEWLINE> <INDENT> if edge . cap and self . level [ edge . fromNode ] < self . level [ edge . toNode ] : <NEWLINE> <INDENT> newFlow = self . dfs ( edge . toNode , sink , min ( f , edge . cap ) ) <NEWLINE> if newFlow : <NEWLINE> <INDENT> edge . cap -= newFlow <NEWLINE> edge . rev . cap += newFlow <NEWLINE> return newFlow <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def run ( self , source , sink ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> INF = 10 ** 10 <NEWLINE> while self . bfs ( source , sink ) : <NEWLINE> <INDENT> addFlow = INF <NEWLINE> while addFlow : <NEWLINE> <INDENT> addFlow = self . dfs ( source , sink , INF ) <NEWLINE> flow += addFlow <NEWLINE> <NL> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> <DEDENT> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> net = MaxFlow ( V ) <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> u , v , c = map ( int , input ( ) . split ( ) ) <NEWLINE> net . addEdge ( u , v , c ) <NEWLINE> <DEDENT> print ( net . run ( 0 , V - 1 ) ) <NEWLINE>
<COMMENT> <NL> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = nums [ 0 ] <NEWLINE> b = nums [ 1 ] <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import copy <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_plus1 = copy . copy ( a ) <NEWLINE> a_minus1 = copy . copy ( a ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a_plus1 [ x ] += 1 <NEWLINE> <DEDENT> for y in range ( n ) : <NEWLINE> <INDENT> a_minus1 [ y ] -= 1 <NEWLINE> <DEDENT> a_total = a + a_plus1 + a_minus1 <NEWLINE> cnt = Counter ( a_total ) <NEWLINE> a_max = list ( cnt . values ( ) ) <NEWLINE> print ( max ( a_max ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> li = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> li2 = [ 0 ] * num <NEWLINE> num = len ( li ) <NEWLINE> for i in li : <NEWLINE> <INDENT> li2 [ i - 1 ] = li2 [ i - 1 ] + 1 <NEWLINE> <DEDENT> for j in range ( num + 1 ) : <NEWLINE> <INDENT> print ( li2 [ j ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = deque ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> ans = A . pop ( ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> x = A . pop ( ) <NEWLINE> <DEDENT> ans += x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> M = 2019 <NEWLINE> <NL> remainder = [ 0 ] * M <NEWLINE> val = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> val = ( int ( S [ N - 1 - i ] ) * pow ( 10 , i , M ) + val ) % M <NEWLINE> remainder [ val ] += 1 <NEWLINE> <NL> <DEDENT> ans = remainder [ 0 ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += remainder [ i ] * ( remainder [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = tuple ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> x = 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> x *= aa <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
a = [ 1 ] * 45 <NEWLINE> for i in range ( 2 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + a [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( a [ int ( input ( ) ) ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( T : str ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <COMMENT> <NL> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> t = T [ i ] <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> a += t <NEWLINE> <COMMENT> <NL> <DEDENT> print ( a ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> T = next ( tokens ) <COMMENT> <NEWLINE> solve ( T ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( len ( set ( input ( ) . rstrip ( <STRING> ) for _ in range ( n ) ) ) ) <NEWLINE> <DEDENT>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( str ( a ) for a in A ) ) <NEWLINE> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( ( r * r * math . pi ) , ( 2 * r * math . pi ) ) <NEWLINE>
import sys <NEWLINE> <NL> def binarySearch ( t , w ) : <NEWLINE> <INDENT> left = max ( w ) <NEWLINE> right = sum ( w ) <NEWLINE> while left < right : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> if hantei ( t , w , middle ) : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = middle + 1 <NEWLINE> <DEDENT> <DEDENT> return left <NEWLINE> <NL> <DEDENT> def hantei ( t , w , p ) : <NEWLINE> <INDENT> track_on = 0 <NEWLINE> daisu = 1 <NEWLINE> for j in range ( len ( w ) ) : <NEWLINE> <INDENT> track_on += w [ j ] <NEWLINE> if track_on > p : <NEWLINE> <INDENT> daisu += 1 <NEWLINE> track_on = w [ j ] <NEWLINE> if daisu > t : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> nimotsu , track = map ( int , input ( ) . split ( ) ) <NEWLINE> weight = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> <NL> <NL> <NL> print ( binarySearch ( track , weight ) ) <NEWLINE>
from collections import deque <NEWLINE> dq = deque ( ) <NEWLINE> for _ in [ None ] * int ( input ( ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = s . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b in dq : <NEWLINE> <INDENT> dq . remove ( b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE> <NL>
pupils = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( l ) == - 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pupils . append ( l ) <NEWLINE> <NL> <DEDENT> for pupil in pupils : <NEWLINE> <INDENT> score = pupil [ 0 ] + pupil [ 1 ] <NEWLINE> if pupil [ 0 ] == - 1 or pupil [ 1 ] == - 1 : <NEWLINE> <INDENT> rank = <STRING> <NEWLINE> <DEDENT> elif score >= 80 : <NEWLINE> <INDENT> rank = <STRING> <NEWLINE> <DEDENT> elif score >= 65 : <NEWLINE> <INDENT> rank = <STRING> <NEWLINE> <DEDENT> elif ( score >= 50 ) or ( score >= 30 and pupil [ 2 ] >= 50 ) : <NEWLINE> <INDENT> rank = <STRING> <NEWLINE> <DEDENT> elif score >= 30 : <NEWLINE> <INDENT> rank = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rank = <STRING> <NEWLINE> <DEDENT> print ( rank ) <NEWLINE> <DEDENT>
is_able_make = [ False ] * 2000 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> for j in range ( 2000 - i , 0 , - 1 ) : <NEWLINE> <INDENT> if is_able_make [ j ] == True : <NEWLINE> <INDENT> is_able_make [ i + j ] = True <NEWLINE> <DEDENT> <DEDENT> is_able_make [ i ] = True <NEWLINE> <NL> <DEDENT> for x in M : <NEWLINE> <INDENT> if is_able_make [ x ] == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> arr [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in arr ] <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for d in range ( 61 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( a >> d ) & 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> ans += x * ( n - x ) * 2 ** d <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b2 = [ ] <NEWLINE> t = k <NEWLINE> start = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if start == len ( b ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t - b [ start ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t -= b [ start ] <NEWLINE> b2 . append ( b [ start ] ) <NEWLINE> start += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> num = start <NEWLINE> lst = [ start ] <NEWLINE> M = start <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] > t and b2 == [ ] : <NEWLINE> <INDENT> print ( M ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> while a [ i ] > t and b2 != [ ] : <NEWLINE> <INDENT> b_ = b2 . pop ( ) <NEWLINE> t = t + b_ <NEWLINE> num -= 1 <NEWLINE> <NL> <DEDENT> if a [ i ] <= t : <NEWLINE> <INDENT> t -= a [ i ] <NEWLINE> num += 1 <NEWLINE> <NL> <NL> <DEDENT> if M < num : <NEWLINE> <INDENT> M = num <NEWLINE> <DEDENT> lst . append ( num ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> print ( M ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = 1 <NEWLINE> ans = 1 <NEWLINE> count = 0 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> t *= a <NEWLINE> while t >= 10 : <NEWLINE> <INDENT> t /= 10 <NEWLINE> count += 1 <NEWLINE> if count >= 19 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 for n in range ( 100000 + 1 ) ] <NEWLINE> for n in range ( len ( A ) ) : <NEWLINE> <INDENT> dp [ A [ n ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> init = 0 <NEWLINE> for n in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> init += n * dp [ n - 1 ] <NEWLINE> <NL> <DEDENT> ans = init <NEWLINE> for n in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> ans = ans - dp [ B - 1 ] * B + dp [ B - 1 ] * C <NEWLINE> dp [ C - 1 ] += dp [ B - 1 ] <NEWLINE> dp [ B - 1 ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> r = [ 0 ] * ls <NEWLINE> c = 0 <NEWLINE> for ii in range ( ls - 1 ) : <NEWLINE> <INDENT> if s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> r [ ii ] += c // 2 + c % 2 <NEWLINE> r [ ii + 1 ] += c // 2 <NEWLINE> c = 0 <NEWLINE> <DEDENT> elif s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ ii ] == <STRING> and s [ ii + 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for jj in range ( ls - 1 ) : <NEWLINE> <INDENT> ii = ls - 1 - jj <NEWLINE> if s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> r [ ii - 1 ] += c // 2 <NEWLINE> r [ ii ] += c // 2 + c % 2 <NEWLINE> c = 0 <NEWLINE> <DEDENT> elif s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif s [ ii - 1 ] == <STRING> and s [ ii ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( * r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> d = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i + 1 ] == s [ i ] : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - d ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , m ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> o = list ( input ( ) ) <NEWLINE> e = list ( input ( ) ) + [ <STRING> ] <NEWLINE> <NL> for x , y in zip ( o , e ) : print ( x + y , end = <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = np . array ( P ) <NEWLINE> <NL> P = np . sort ( P ) <NEWLINE> ind = bisect . bisect_right ( P , X ) <NEWLINE> <NL> if len ( P ) == 0 or P [ ind - 1 ] != X : <NEWLINE> <INDENT> return X <NEWLINE> <NL> <DEDENT> if len ( P ) == 1 : <NEWLINE> <INDENT> if P [ 0 ] != X : <NEWLINE> <INDENT> return X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return X - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Left = P [ : ind - 1 ] - X <NEWLINE> Right = P [ ind : ] - X <NEWLINE> <NL> Left = abs ( Left [ : : - 1 ] ) <NEWLINE> <NL> diff = 1 <NEWLINE> Left_over = False <NEWLINE> Right_over = False <NEWLINE> <NL> if len ( Left ) == 0 : <NEWLINE> <INDENT> Left_over = True <NEWLINE> <DEDENT> if len ( Right ) == 0 : <NEWLINE> <INDENT> Right_over = True <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if not Left_over and Left [ 0 ] != diff : <NEWLINE> <INDENT> return X - diff <NEWLINE> <DEDENT> elif Left_over : <NEWLINE> <INDENT> return P [ 0 ] - 1 <NEWLINE> <DEDENT> elif not Right_over and Right [ 0 ] != diff : <NEWLINE> <INDENT> return X + diff <NEWLINE> <DEDENT> elif Right_over : <NEWLINE> <INDENT> return P [ - 1 ] + 1 <NEWLINE> <DEDENT> diff += 1 <NEWLINE> if len ( Left ) >= 2 : <NEWLINE> <INDENT> Left = Left [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Left_over = True <NEWLINE> <DEDENT> if len ( Right ) >= 2 : <NEWLINE> <INDENT> Right = Right [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Right_over = True <NEWLINE> <NL> <DEDENT> if Left_over and Right_over : <NEWLINE> <INDENT> return P [ 0 ] - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> li = collections . Counter ( lis ) <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( li [ str ( i + 1 ) ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] > A [ i ] : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) - ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 ] * ( n ) <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : return x <NEWLINE> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> px , py = find ( x ) , find ( y ) <NEWLINE> if px == py : return False <NEWLINE> else : <NEWLINE> <INDENT> if px < py : px , py = py , px <NEWLINE> par [ px ] += par [ py ] <NEWLINE> par [ py ] = px <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gl = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( x - 1 , y - 1 ) <NEWLINE> <DEDENT> for c in range ( n ) : <COMMENT> <NEWLINE> <INDENT> ap = find ( c ) <NEWLINE> gl [ ap ] . append ( c ) <NEWLINE> <DEDENT> g = 0 <NEWLINE> for sg in gl : <NEWLINE> <INDENT> temp = [ p [ index ] - 1 for index in sg ] <NEWLINE> newset = set ( sg ) & set ( temp ) <NEWLINE> g += len ( newset ) <NEWLINE> <DEDENT> print ( g ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for x in l : <NEWLINE> <INDENT> ans *= x <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> inf = 10 ** 9 + 1 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) ) <NEWLINE> max_d = - inf <NEWLINE> min_v = inf * 2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> r = int ( stdin . readline ( ) ) <NEWLINE> <NL> max_d = max ( max_d , r - min_v ) <NEWLINE> min_v = min ( min_v , r ) <NEWLINE> <NL> <DEDENT> print ( max_d ) <NEWLINE> <NL> <NL> <DEDENT> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> J = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D1 , D2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if D1 == D2 : <NEWLINE> <INDENT> j += 1 <NEWLINE> if j >= 3 : <NEWLINE> <INDENT> J = 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> <DEDENT> if J >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( int ( n * ( n - 1 ) // 2 ) ) <NEWLINE>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> aa = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cnt = 0 <NEWLINE> pl = aa + np . array ( range ( n ) ) <NEWLINE> ms = - aa + np . array ( range ( n ) ) <NEWLINE> common = set ( pl ) . intersection ( set ( ms ) ) <NEWLINE> <NL> dic_pl = Counter ( pl ) <NEWLINE> dic_ms = Counter ( ms ) <NEWLINE> <NL> for k in dic_ms . keys ( ) : <NEWLINE> <INDENT> cnt += dic_ms [ k ] * dic_pl . get ( k , 0 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> cnt += ( A [ k ] < A [ i ] + A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . int32 ( input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( f ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> multi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in multi : <NEWLINE> <INDENT> result = 0 <NEWLINE> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> result = result * multi [ i ] <NEWLINE> if ( result > 10 ** 18 ) : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> rev = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( i , j ) <NEWLINE> for l in range ( j , k + 1 ) : <NEWLINE> <INDENT> if i == j and j == l : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif i == j or j == l or l == i : <NEWLINE> <INDENT> ans += gcd ( tmp , l ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( tmp , l ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import itertools <NEWLINE> from collections import defaultdict <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> sub = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > sub : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , m = i2 ( ) <NEWLINE> h = intl ( ) <NEWLINE> cnt = 0 <NEWLINE> score = 0 <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a , b = i2 ( ) <NEWLINE> l [ a - 1 ] . append ( b - 1 ) <NEWLINE> l [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in l [ j ] : <NEWLINE> <INDENT> if h [ j ] > h [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == len ( l [ j ] ) : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( l [ i ] ) == 0 : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
s = input ( ) <NEWLINE> p = 2019 <NEWLINE> mods = [ 0 ] * p <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> base = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for c in map ( int , s [ : : - 1 ] ) : <NEWLINE> <INDENT> current = ( current + base * int ( c ) ) % p <NEWLINE> base = base * 10 % p <NEWLINE> mods [ current ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( el * ( el - 1 ) // 2 for el in mods ) ) <NEWLINE>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
def a ( t , i ) : <NEWLINE> <INDENT> if i == l : <NEWLINE> <INDENT> if eval ( t ) == 7 : <NEWLINE> <INDENT> print ( t + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> a ( t + <STRING> + s [ i + 1 ] , i + 1 ) <NEWLINE> a ( t + <STRING> + s [ i + 1 ] , i + 1 ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> l = len ( s ) - 1 <NEWLINE> a ( s [ 0 ] , 0 ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> score = 0 <NEWLINE> if N >= B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> score = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> print ( score ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> dlist = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> code = input ( ) . split ( ) <NEWLINE> if code [ 0 ] == <STRING> : <NEWLINE> <INDENT> dlist . insert ( 0 , code [ 1 ] ) <NEWLINE> <DEDENT> if code [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dlist . remove ( code [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if code [ 0 ] == <STRING> : <NEWLINE> <INDENT> dlist . popleft ( ) <NEWLINE> <DEDENT> if code [ 0 ] == <STRING> : <NEWLINE> <INDENT> dlist . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * dlist , sep = <STRING> ) <NEWLINE>
class bit : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . bit = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def make ( self , lst ) : <NEWLINE> <INDENT> self . bit = [ 0 ] + lst [ : ] <NEWLINE> for i in range ( 1 , self . size + 1 ) : <NEWLINE> <INDENT> if i + ( i & - i ) > self . size : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . bit [ i + ( i & - i ) ] += self . bit [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( self , a , b ) : <NEWLINE> <INDENT> i = a + 1 <NEWLINE> while i <= self . size : <NEWLINE> <INDENT> self . bit [ i ] += b <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , a ) : <NEWLINE> <INDENT> i = a <NEWLINE> ret = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> ret += self . bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def sub ( self , a , b ) : <NEWLINE> <INDENT> return self . sum ( b ) - self . sum ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l = bit ( n ) <NEWLINE> l . make ( lst ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> l . add ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l . sub ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> a [ i ] += [ sum ( a [ i ] ) ] <NEWLINE> for j in range ( n ) : print ( <STRING> % a [ i ] [ j ] , end = <STRING> ) <NEWLINE> print ( <STRING> % a [ i ] [ n ] ) <NEWLINE> <DEDENT> a = list ( zip ( * a [ : : - 1 ] ) ) <NEWLINE> for i in range ( n ) : print ( <STRING> % sum ( a [ i ] ) , end = <STRING> ) <NEWLINE> print ( <STRING> % sum ( a [ n ] ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] >= a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> c = collections . Counter ( a ) <NEWLINE> cnt = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> if c [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( x [ n % 10 ] ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ ai - 1 ] . append ( bi - 1 ) <NEWLINE> g [ bi - 1 ] . append ( ai - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif icase == 1 : <NEWLINE> <INDENT> n , m = 4 , 4 <NEWLINE> g = [ [ 1 ] , [ 0 , 2 , 3 ] , [ 1 , 3 ] , [ 2 , 1 ] ] <NEWLINE> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 6 , 9 <NEWLINE> g = [ [ 5 , 4 ] , [ 3 , 5 ] , [ 3 , 4 ] , [ 2 , 1 , 5 , 4 ] , [ 2 , 0 , 3 , 5 ] , [ 0 , 3 , 1 , 4 ] ] <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> <NL> stack = [ 0 ] <NEWLINE> parent = [ - 1 ] * n <NEWLINE> parent [ 0 ] = 0 <NEWLINE> dist = [ - 1 ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> state = q . popleft ( ) <NEWLINE> <COMMENT> <NL> for v in g [ state ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if parent [ v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> parent [ v ] = state <NEWLINE> dist [ v ] = dist [ state ] + 1 <NEWLINE> q . append ( v ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if parent [ i ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( parent [ i ] + 1 ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import sys <NEWLINE> <NL> h = [ ] <NEWLINE> <NL> for com in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( h , - int ( com [ 7 : ] ) ) <NEWLINE> <DEDENT> elif com [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( h ) ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> import string <NEWLINE> <NL> def solve ( s ) : <NEWLINE> <INDENT> s = s . lower ( ) <NEWLINE> counter = collections . Counter ( s ) <NEWLINE> lows = string . ascii_lowercase <NEWLINE> cnt = [ counter [ ch ] for ch in lows ] <NEWLINE> for ( ch , n ) in zip ( lows , cnt ) : <NEWLINE> <INDENT> print ( <STRING> . format ( ch , n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s += input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> solve ( s ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ma = A [ - 1 ] <NEWLINE> half = ma / 2 <NEWLINE> index = bisect . bisect_left ( A , half ) <NEWLINE> <NL> if index != 0 : <NEWLINE> <INDENT> ans = A [ index - 1 ] if half - A [ index - 1 ] <= A [ index ] - half else A [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> <NL> <DEDENT> print ( ma , ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> print ( 9 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> b = math . gcd ( a , k ) <NEWLINE> t += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tw = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> c = math . gcd ( i , j ) <NEWLINE> tw += c <NEWLINE> <NL> <DEDENT> <DEDENT> on = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> on += i <NEWLINE> <DEDENT> print ( t * 6 + tw * 6 + on ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class Edge : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . w = w <NEWLINE> <NL> <DEDENT> def either ( self ) : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <DEDENT> def other ( self , v ) : <NEWLINE> <INDENT> if v == self . v : <NEWLINE> <INDENT> return self . w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class WeightedEdge ( Edge ) : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w , weight ) : <NEWLINE> <INDENT> super ( ) . __init__ ( v , w ) <NEWLINE> self . weight = weight <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . _edges = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> <DEDENT> def add ( self , e ) : <NEWLINE> <INDENT> self . _edges [ e . v ] . append ( e ) <NEWLINE> self . _edges [ e . w ] . append ( e ) <NEWLINE> <NL> <DEDENT> def adj ( self , v ) : <NEWLINE> <INDENT> return self . _edges [ v ] <NEWLINE> <NL> <DEDENT> def edges ( self ) : <NEWLINE> <INDENT> for es in self . _edges : <NEWLINE> <INDENT> for e in es : <NEWLINE> <INDENT> yield e <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def diameter ( graph ) : <NEWLINE> <INDENT> def dfs ( s ) : <NEWLINE> <INDENT> visited = [ False ] * graph . v <NEWLINE> weights = [ 0 ] * graph . v <NEWLINE> stack = [ ( s , 0 ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> v , weight = stack . pop ( ) <NEWLINE> if not visited [ v ] : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> weights [ v ] = weight <NEWLINE> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if not visited [ w ] : <NEWLINE> <INDENT> stack . append ( ( w , weight + e . weight ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return weights <NEWLINE> <NL> <DEDENT> v0 = 0 <NEWLINE> ws0 = dfs ( v0 ) <NEWLINE> v1 = max ( ( wg , v ) for v , wg in enumerate ( ws0 ) ) [ 1 ] <NEWLINE> ws1 = dfs ( v1 ) <NEWLINE> v2 = max ( ( wg , v ) for v , wg in enumerate ( ws1 ) ) [ 1 ] <NEWLINE> <NL> return max ( ws0 [ v2 ] , ws1 [ v2 ] ) <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> g = Graph ( n ) <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , t , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> g . add ( WeightedEdge ( s , t , w ) ) <NEWLINE> <NL> <DEDENT> print ( diameter ( g ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( 10 ** n - 9 ** n * 2 + 8 ** n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import collections <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_li = [ ] <NEWLINE> w_li = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> _h , _w = map ( int , input ( ) . split ( ) ) <NEWLINE> h_li . append ( _h ) <NEWLINE> w_li . append ( _w ) <NEWLINE> <NL> <DEDENT> h_bomb = [ 0 ] * ( h + 1 ) <NEWLINE> w_bomb = [ 0 ] * ( w + 1 ) <NEWLINE> <NL> h_counter = collections . Counter ( h_li ) <NEWLINE> w_counter = collections . Counter ( w_li ) <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> h_bomb [ i ] = h_counter . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> w_bomb [ i ] = w_counter . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> ans = max ( h_bomb ) + max ( w_bomb ) <NEWLINE> allow_count = h_bomb . count ( max ( h_bomb ) ) * w_bomb . count ( max ( w_bomb ) ) <NEWLINE> <NL> s = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> _h , _w = h_li [ i ] , w_li [ i ] <NEWLINE> if h_bomb [ _h ] + w_bomb [ _w ] == ans : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt < allow_count : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Query = list ( input ( ) . split ( ) for _ in range ( Q ) ) <NEWLINE> <NL> count = 0 <NEWLINE> L , R = <STRING> , <STRING> <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> if Query [ i ] [ 0 ] == <STRING> : count += 1 <NEWLINE> else : <NEWLINE> <INDENT> if Query [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> if count % 2 == 0 : L = Query [ i ] [ 2 ] + L <NEWLINE> else : R += Query [ i ] [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count % 2 == 0 : R += Query [ i ] [ 2 ] <NEWLINE> else : L = Query [ i ] [ 2 ] + L <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if count % 2 == 0 : print ( L + S + R ) <NEWLINE> else : print ( R [ : : - 1 ] + S [ : : - 1 ] + L [ : : - 1 ] ) <NEWLINE>
s = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> th = int ( s [ 0 ] ) <NEWLINE> tss = int ( s [ 1 ] ) <NEWLINE> ah = int ( s [ 2 ] ) <NEWLINE> ass = int ( s [ 3 ] ) <NEWLINE> I = 0 ; <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if ah > 0 and th > 0 : <NEWLINE> <INDENT> if I % 2 == 0 : <NEWLINE> <INDENT> I += 1 ; <NEWLINE> ah -= tss ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> th -= ass <NEWLINE> I += 1 ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> if I % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> V = set ( ) <NEWLINE> <NL> def dfs ( n ) : <NEWLINE> <INDENT> for e in G [ n ] : <NEWLINE> <INDENT> if e not in V : <NEWLINE> <INDENT> dfs ( e ) <NEWLINE> <DEDENT> <DEDENT> if n not in V : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> V . add ( n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i not in V : <NEWLINE> <INDENT> if i not in V : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ : : - 1 ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> b1 = [ ] <NEWLINE> b2 = [ ] <NEWLINE> ans = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b1 . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b2 . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> b2 . reverse ( ) <NEWLINE> ans = b2 + b1 <NEWLINE> print ( <STRING> . join ( str ( i ) for i in ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b1 . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b2 . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> b1 . reverse ( ) <NEWLINE> ans = b1 + b2 <NEWLINE> print ( <STRING> . join ( str ( i ) for i in ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * ( 10 ** 5 + 5 ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> A [ ai - 1 ] += 1 <NEWLINE> A [ ai ] += 1 <NEWLINE> A [ ai + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( A ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> t = min ( b , n ) <NEWLINE> for i in range ( t , max ( t - 3 , - 1 ) , - 1 ) : <NEWLINE> <INDENT> ans = max ( ans , ( ( a * i ) // b - ( a * ( i // b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def Graph ( ab ) : <NEWLINE> <INDENT> G = [ [ ] for i in range ( n ) ] <NEWLINE> for a , b , c in ab : <NEWLINE> <INDENT> G [ a - 1 ] . append ( [ b , c ] ) <NEWLINE> G [ b - 1 ] . append ( [ a , c ] ) <NEWLINE> <DEDENT> return G <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> def bfs ( k ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( ( k , - 1 , 0 ) ) <NEWLINE> dis = [ 0 ] * n <NEWLINE> while q : <NEWLINE> <INDENT> V , P , cnt = q . popleft ( ) <NEWLINE> for nv , d in G [ V - 1 ] : <NEWLINE> <INDENT> if nv == P : continue <NEWLINE> dis [ nv - 1 ] = cnt + d <NEWLINE> q . append ( ( nv , V , cnt + d ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return dis <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> abc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> G = Graph ( abc ) <NEWLINE> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dis = bfs ( k ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dis [ x - 1 ] + dis [ y - 1 ] ) <NEWLINE> <DEDENT>
def product ( list ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> <NL> if any ( [ i == 0 for i in num_list ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in num_list : <NEWLINE> <INDENT> num *= i <NEWLINE> if num > 1000000000000000000 : <NEWLINE> <INDENT> num = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> product ( num_list ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = [ i + 1 for i in range ( n ) ] <NEWLINE> rank = [ 1 ] * n <NEWLINE> size = [ 1 ] * n <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x - 1 ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( par [ x - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if rank [ x - 1 ] < rank [ y - 1 ] : <NEWLINE> <INDENT> par [ x - 1 ] = y <NEWLINE> size [ y - 1 ] += size [ x - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ y - 1 ] = x <NEWLINE> size [ x - 1 ] += size [ y - 1 ] <NEWLINE> if rank [ x - 1 ] == rank [ y - 1 ] : <NEWLINE> <INDENT> rank [ x - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( max ( size ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in l : print ( 0 ) ; exit ( ) <NEWLINE> <NL> a = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > a : print ( - 1 ) ; exit ( ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : return 0 <NEWLINE> return f ( n % bin ( n ) . count ( <STRING> ) ) + 1 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> X = list ( input ( ) ) <NEWLINE> c = sum ( list ( map ( int , X ) ) ) <NEWLINE> m = int ( <STRING> . join ( X ) , 2 ) <NEWLINE> mp , mm = m % ( c + 1 ) , m % ( c - 1 ) if c - 1 != 0 else 0 <NEWLINE> jp , jm = 1 , 1 <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> mod = c + 1 <NEWLINE> ans [ i ] = f ( ( mp + jp ) % mod ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = f ( ( mm - jm + mod ) % mod ) + 1 if ( mod : = c - 1 ) != 0 else 0 <NEWLINE> <DEDENT> jp , jm = ( jp << 1 ) % ( c + 1 ) , ( jm << 1 ) % ( c - 1 ) if c - 1 != 0 else 0 <NEWLINE> <DEDENT> [ print ( a ) for a in ans ] <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> l = list ( input ( ) . split ( ) ) <NEWLINE> a = int ( l [ 0 ] ) <NEWLINE> b = Decimal ( l [ 1 ] ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
<COMMENT> <NL> r , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = [ ] <NEWLINE> sumr = [ 0 ] * c <NEWLINE> tempr = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> col = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> sumr [ j ] += col [ j ] <NEWLINE> <DEDENT> col . append ( sum ( col ) ) <NEWLINE> q . append ( col ) <NEWLINE> <DEDENT> sumr . append ( sum ( sumr ) ) <NEWLINE> q . append ( sumr ) <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> print ( q [ i ] [ j ] , end = <STRING> ) <NEWLINE> if ( j != ( c ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Sum = sum ( A ) <NEWLINE> <COMMENT> <NL> coun = Counter ( A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> Sum += ( c - b ) * coun [ b ] <NEWLINE> coun [ c ] += coun [ b ] <NEWLINE> coun [ b ] = 0 <NEWLINE> print ( Sum ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <NL> S = [ 0 , ] <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num += int ( s [ i ] ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <COMMENT> <NL> cnt [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
nums = [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ] <NEWLINE> print ( nums [ int ( input ( ) ) - 1 ] ) <NEWLINE>
<STRING> <NEWLINE> from copy import deepcopy <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> def getMinSteps ( ) : <NEWLINE> <INDENT> dp_2 = [ 0 , ] <NEWLINE> dp_1 = [ abs ( arr [ 1 ] - arr [ 0 ] ) , ] <NEWLINE> <NL> total_cost = 0 <NEWLINE> i = 2 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> diff1 = abs ( arr [ i ] - arr [ i - 1 ] ) <NEWLINE> diff2 = abs ( arr [ i ] - arr [ i - 2 ] ) <NEWLINE> temp = deepcopy ( dp_2 ) <NEWLINE> dp_2 = deepcopy ( dp_1 ) <NEWLINE> <NL> for j in range ( len ( dp_1 ) ) : <NEWLINE> <INDENT> dp_1 [ j ] += diff1 <NEWLINE> <NL> <DEDENT> for j in range ( len ( temp ) ) : <NEWLINE> <INDENT> dp_1 . append ( temp [ j ] + diff2 ) <NEWLINE> <NL> <DEDENT> dp_1 = sorted ( dp_1 ) [ 0 : 2 ] <NEWLINE> <NL> i += 1 <NEWLINE> <DEDENT> return min ( dp_1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( getMinSteps ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = False ) <NEWLINE> <NL> ret = 0 <NEWLINE> c_pointer = 0 <NEWLINE> comfort = [ ] <NEWLINE> tmp = A . pop ( ) <NEWLINE> comfort . append ( tmp ) <NEWLINE> <NL> while len ( A ) > 0 : <NEWLINE> <INDENT> tmp = A . pop ( ) <NEWLINE> c_pointer += 1 <NEWLINE> comfort . append ( tmp ) <NEWLINE> comfort . append ( tmp ) <NEWLINE> <NL> <DEDENT> print ( sum ( comfort [ : c_pointer ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( v , seen ) : <NEWLINE> <INDENT> if all ( seen ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for vv in graph [ v ] : <NEWLINE> <INDENT> if seen [ vv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ vv ] = True <NEWLINE> ans += dfs ( vv , seen ) <NEWLINE> seen [ vv ] = False <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> seen [ 0 ] = True <NEWLINE> print ( dfs ( 0 , seen ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> S = deque ( list ( input ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> q = [ list ( input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> r = 0 <NEWLINE> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> if q [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( q [ i ] [ 1 ] == <STRING> and r % 2 == 0 ) or ( q [ i ] [ 1 ] == <STRING> and r % 2 == 1 ) : <NEWLINE> <INDENT> S . appendleft ( q [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( q [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = <STRING> . join ( S ) <NEWLINE> if r % 2 == 1 : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sum ( a ) <NEWLINE> count = Counter ( a ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> b , c = [ ] , [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( bi ) , c . append ( ci ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> bi , ci = b [ i ] , c [ i ] <NEWLINE> x -= bi * count [ bi ] <NEWLINE> x += ci * count [ bi ] <NEWLINE> count [ ci ] += count [ bi ] <NEWLINE> count [ bi ] = 0 <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ k - q ] * n ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> d0 = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g = math . gcd ( a , b ) <NEWLINE> if g == 0 : <NEWLINE> <INDENT> d0 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a //= g <NEWLINE> b //= g <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> elif a == 0 and b < 0 : <NEWLINE> <INDENT> b = - b <NEWLINE> <DEDENT> if ( a , b ) in d : <NEWLINE> <INDENT> d [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( a , b ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( a , b ) in d . keys ( ) : <NEWLINE> <INDENT> if d [ ( a , b ) ] > 0 : <NEWLINE> <INDENT> t = 2 ** d [ ( a , b ) ] <NEWLINE> if b <= 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> if ( b , - a ) in d : <NEWLINE> <INDENT> t += 2 ** d [ ( b , - a ) ] - 1 <NEWLINE> d [ ( b , - a ) ] = 0 <NEWLINE> <DEDENT> ans *= t <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ( ans + d0 - 1 ) % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> reached = [ ] <NEWLINE> <NL> check = [ 0 ] * ( N + 1 ) <NEWLINE> now = 1 <NEWLINE> <NL> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> check [ now ] += 1 <NEWLINE> if check [ now ] == 1 : <NEWLINE> <INDENT> reached . append ( now ) <NEWLINE> now = A [ now - 1 ] <NEWLINE> <NL> <DEDENT> if check [ now ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( reached ) ) : <NEWLINE> <INDENT> if reached [ i ] == now : <NEWLINE> <INDENT> cnt = i <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> roop = len ( reached ) - cnt <NEWLINE> init = len ( reached ) <NEWLINE> <NL> if K < init : <NEWLINE> <INDENT> print ( reached [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( reached [ ( K - init ) % roop + cnt ] ) <NEWLINE> <DEDENT>
N , M = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> H = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> no_good = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if H [ a ] == H [ b ] : <NEWLINE> <INDENT> no_good += [ a , b ] <NEWLINE> <DEDENT> elif H [ a ] < H [ b ] : <NEWLINE> <INDENT> no_good . append ( a ) <NEWLINE> <DEDENT> elif H [ a ] > H [ b ] : <NEWLINE> <INDENT> no_good . append ( b ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( set ( no_good ) ) ) <NEWLINE>
import sys <NEWLINE> import string <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> array = string . ascii_uppercase <NEWLINE> <NL> if not ( 0 <= N <= 26 ) : sys . exit ( ) <NEWLINE> if not ( 1 <= len ( s ) <= 10 ** 4 ) : sys . exit ( ) <NEWLINE> if not S . isupper ( ) : sys . exit ( ) <NEWLINE> <NL> for I in s : <NEWLINE> <INDENT> if array . index ( I ) + N <= 25 : <NEWLINE> <INDENT> print ( array [ array . index ( I ) + N ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( array [ ( array . index ( I ) + N ) - 26 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> def sympy ( num ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if ( i % 2 != 0 ) and ( i * j == num ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l = sympy ( i ) <NEWLINE> if ( i % 2 != 0 ) and ( len ( l ) == 8 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def p ( length ) : <COMMENT> <NEWLINE> <INDENT> if length == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % length == 0 : <NEWLINE> <INDENT> tmp += ( a // length ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += a // length <NEWLINE> <DEDENT> if tmp > K : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <NL> <DEDENT> def bin_search ( arr ) : <COMMENT> <NEWLINE> <INDENT> lb = 0 <NEWLINE> ub = 1000000000 <NEWLINE> <NL> while ub - lb > 1 : <NEWLINE> <INDENT> mid = ( ub + lb ) // 2 <NEWLINE> if p ( mid ) == 1 : <NEWLINE> <INDENT> ub = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return lb <NEWLINE> <NL> <DEDENT> def just ( num ) : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % num != 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += a // num <NEWLINE> <DEDENT> <DEDENT> if tmp != K : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_tmp = bin_search ( A ) <NEWLINE> if just ( ans_tmp ) == 1 : <NEWLINE> <INDENT> print ( ans_tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_tmp + 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 7 == 0 : <NEWLINE> <INDENT> L = 9 * k // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * k <NEWLINE> <DEDENT> out = - 1 <NEWLINE> s = 10 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> if s % L == 1 : <NEWLINE> <INDENT> out = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( s % L ) * 10 <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ i for i in range ( - 110 , 210 ) ] <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in p : <NEWLINE> <INDENT> q [ i + 110 ] = - 500 <NEWLINE> <NL> <DEDENT> <DEDENT> if x in q : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> if x + i in q : <NEWLINE> <INDENT> l . append ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if x - j in q : <NEWLINE> <INDENT> l . append ( x - j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( l [ 0 ] - x ) < abs ( l [ 1 ] - x ) : <NEWLINE> <INDENT> print ( l [ 0 ] ) <NEWLINE> <DEDENT> elif abs ( l [ 0 ] - x ) > abs ( l [ 1 ] - x ) : <NEWLINE> <INDENT> print ( l [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ 1 ] ) <NEWLINE> <DEDENT>
import collections as c <NEWLINE> n , a1 = int ( input ( ) ) , [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> a2 , a3 , b = set ( a1 ) , c . Counter ( a1 ) , [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in a2 : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> b [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( b [ i ] == 1 and a3 [ i ] == 1 for i in a2 ) ) <NEWLINE>
import sys <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = X + s * d <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 1 <NEWLINE> g = 0 <NEWLINE> i = 1 <NEWLINE> history = [ s ] <NEWLINE> flag = [ False ] * n <NEWLINE> flag [ 0 ] = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> g = a [ s - 1 ] <NEWLINE> if flag [ g - 1 ] == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ g - 1 ] = True <NEWLINE> history . append ( g ) <NEWLINE> s = g <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x = history . index ( g ) <NEWLINE> <NL> if k < i : <NEWLINE> <INDENT> ans = history [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = ( k - x ) % ( i - x ) <NEWLINE> <NL> ans = history [ x + d ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
MX = 100005 <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * MX <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> <NL> for i in range ( MX ) : <NEWLINE> <INDENT> total += i * cnt [ i ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> B , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b . append ( B ) <NEWLINE> c . append ( C ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> total -= b [ i ] * cnt [ b [ i ] ] <NEWLINE> total -= c [ i ] * cnt [ c [ i ] ] <NEWLINE> cnt [ c [ i ] ] += cnt [ b [ i ] ] <NEWLINE> cnt [ b [ i ] ] = 0 <NEWLINE> total += c [ i ] * cnt [ c [ i ] ] <NEWLINE> print ( total ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
import time <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> num = [ 0 ] * 100010 <NEWLINE> for i in A : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <DEDENT> s = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p , n = BC [ i ] [ 0 ] , BC [ i ] [ 1 ] <NEWLINE> s += ( n - p ) * num [ p ] <NEWLINE> num [ n ] += num [ p ] <NEWLINE> num [ p ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def partition ( a , p , r ) : <NEWLINE> <INDENT> q = p <NEWLINE> for i in range ( p , r ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] <= a [ r ] [ 1 ] : <NEWLINE> <INDENT> a [ q ] , a [ i ] = a [ i ] , a [ q ] <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> a [ q ] , a [ r ] = a [ r ] , a [ q ] <NEWLINE> return q <NEWLINE> <NL> <DEDENT> def quicksort ( a , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( a , p , r ) <NEWLINE> quicksort ( a , p , q - 1 ) <NEWLINE> quicksort ( a , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def check_stable ( a ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i - 1 ] [ 1 ] == a [ i ] [ 1 ] : <NEWLINE> <INDENT> if a [ i - 1 ] [ 2 ] > a [ i ] [ 2 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> suit , num = sys . stdin . readline ( ) . split ( ) <NEWLINE> a += [ [ suit , int ( num ) , i ] ] <NEWLINE> <NL> <DEDENT> quicksort ( a , 0 , len ( a ) - 1 ) <NEWLINE> print ( check_stable ( a ) ) <NEWLINE> <NL> for line in a : <NEWLINE> <INDENT> print ( line [ 0 ] , line [ 1 ] ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 2018 <NEWLINE> <NL> if r - l > 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> res = min ( res , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> roots = uf . roots ( ) <NEWLINE> print ( len ( roots ) - 1 ) <NEWLINE>
L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( L , min ( R , L + 2019 ) ) : <NEWLINE> <INDENT> for j in range ( L + 1 , min ( R , L + 2019 ) + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> c = c * b [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = int ( input ( ) ) % 10 <NEWLINE> print ( <STRING> [ a ] + <STRING> ) <NEWLINE>
def merge_jibun ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] + [ 1000000 ] <NEWLINE> R = A [ mid : right ] + [ 1000000 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> global count <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_hoka ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> <COMMENT> <NL> merge_hoka ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( count ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r ** 2 * math . pi <NEWLINE> c = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( s , c ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for v in range ( N - K ) : <NEWLINE> <INDENT> if a [ v ] >= a [ K + v ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <NL> <INDENT> MAX_VALUE = 10 ** 6 + 5 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * MAX_VALUE <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <NL> <INDENT> if cnt [ x ] != 0 : <NEWLINE> <INDENT> cnt [ x ] = 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for i in range ( x , MAX_VALUE , x ) : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for x in a : <NEWLINE> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if X <= 50 : <NEWLINE> <INDENT> l = X <NEWLINE> d = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 101 - X <NEWLINE> d = 101 <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 100 : <NEWLINE> <INDENT> print ( d ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if i + 1 not in p : <NEWLINE> <INDENT> li = abs ( X - i - 1 ) <NEWLINE> if li < l : <NEWLINE> <INDENT> l = li <NEWLINE> d = i + 1 <NEWLINE> <DEDENT> elif li == l : <NEWLINE> <INDENT> if i + 1 < d : <NEWLINE> <INDENT> d = i + 1 <NEWLINE> <DEDENT> <DEDENT> elif li > l : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n < 7 : print ( n // 3 ) ; quit ( ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> ln , hn , dp = n - 6 , n - 5 , 2 <NEWLINE> s = n - 4 <NEWLINE> n , d = n - 5 , 1 <NEWLINE> while n : <NEWLINE> <INDENT> for i in range ( 3 ) : n = ( n * ln ) % M ; ln -= 1 <NEWLINE> for i in range ( 2 ) : n = ( n * pow ( hn , - 1 , M ) ) % M ; hn -= 1 <NEWLINE> d = ( d * pow ( dp , - 1 , M ) ) % M ; dp += 1 <NEWLINE> s = ( s + n * d ) % M <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> hc = [ 0 ] * H <NEWLINE> wc = [ 0 ] * W <NEWLINE> d = { } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> hc [ h ] += 1 <NEWLINE> wc [ w ] += 1 <NEWLINE> d . setdefault ( h , { } ) <NEWLINE> d [ h ] [ w ] = 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> hm = max ( hc ) <NEWLINE> wm = max ( wc ) <NEWLINE> hi = [ i for i in range ( H ) if hc [ i ] == hm ] <NEWLINE> wi = [ i for i in range ( W ) if wc [ i ] == wm ] <NEWLINE> <NL> for h in hi : <NEWLINE> <INDENT> for w in wi : <NEWLINE> <INDENT> if h in d and w in d [ h ] : <NEWLINE> <INDENT> result = max ( result , hm + wm - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = max ( result , hm + wm ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> numbers = int ( input ( ) ) <NEWLINE> array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> maximum = 1000001 <NEWLINE> counter = [ 0 ] * maximum <NEWLINE> <NL> for x in array : <NEWLINE> <INDENT> if counter [ x ] != 0 : <NEWLINE> <INDENT> counter [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for multiple in range ( x , maximum , x ) : <NEWLINE> <INDENT> counter [ multiple ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in array : <NEWLINE> <INDENT> if counter [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if ( 0 <= z < K + 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import OrderedDict <NEWLINE> from itertools import cycle , islice <NEWLINE> <NL> d = OrderedDict ( ( <STRING> . format ( b , f , r ) , 0 ) for b in range ( 1 , 5 ) <NEWLINE> <INDENT> for f in range ( 1 , 4 ) <NEWLINE> for r in range ( 1 , 11 ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> idx = s . rfind ( <STRING> ) <NEWLINE> d [ s [ : idx ] ] += int ( s [ idx + 1 : ] ) <NEWLINE> <NL> <DEDENT> data = d . values ( ) <NEWLINE> delim = <STRING> * 20 <NEWLINE> for i in range ( 0 , 120 , 10 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , islice ( cycle ( data ) , i , i + 10 ) ) ) ) <NEWLINE> if i in ( 20 , 50 , 80 ) : <NEWLINE> <INDENT> print ( delim ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> [ h , w ] = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * w + <STRING> + ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) + <STRING> * w + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> ans = b [ a [ 0 ] - 1 ] <NEWLINE> y = a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> if ( x - y == 1 ) : <NEWLINE> <INDENT> ans = ans + b [ x - 1 ] + c [ y - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + b [ x - 1 ] <NEWLINE> <DEDENT> y = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> RList = [ ] <NEWLINE> tmp = 0 <NEWLINE> tmppoint = 0 <NEWLINE> for i in range ( 1 , len ( AList ) ) : <NEWLINE> <INDENT> tmp = tmp ^ AList [ i ] <NEWLINE> <NL> <DEDENT> RList . append ( tmp ) <NEWLINE> for p in range ( 1 , len ( AList ) ) : <NEWLINE> <INDENT> tmp = tmp ^ AList [ tmppoint ] <NEWLINE> tmp = tmp ^ AList [ p ] <NEWLINE> tmppoint = p <NEWLINE> <NL> RList . append ( tmp ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( RList ) ) : <NEWLINE> <INDENT> print ( RList [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> substrings = set ( [ ] ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) - i ) : <NEWLINE> <COMMENT> <NL> <INDENT> substrings . add ( s [ j : j + i + 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sorted ( substrings ) [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( x + y ) <NEWLINE> B . append ( x - y ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> <NL> print ( max ( A [ - 1 ] - A [ 0 ] , B [ - 1 ] - A [ 0 ] , A [ - 1 ] - A [ 0 ] , B [ - 1 ] - B [ 0 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> lst = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for A in As : <NEWLINE> <INDENT> lst [ A ] += 1 <NEWLINE> <NL> <DEDENT> val = sum ( As ) <NEWLINE> <NL> vals = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> val += ( C - B ) * lst [ B ] <NEWLINE> lst [ C ] += lst [ B ] <NEWLINE> lst [ B ] = 0 <NEWLINE> vals . append ( val ) <NEWLINE> <DEDENT> for val in vals : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = sum ( A ) % ( 1000000007 ) <NEWLINE> sumA2 = ( sumA * sumA ) % ( 1000000007 ) <NEWLINE> square = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> square += ( A [ i ] ** 2 ) % ( 1000000007 ) <NEWLINE> square = square % ( 1000000007 ) <NEWLINE> <DEDENT> buf = sumA2 - square <NEWLINE> if buf < 0 : <NEWLINE> <INDENT> buf = buf + ( 1000000007 ) <NEWLINE> <DEDENT> res = ( buf * ( ( 1000000007 + 1 ) // 2 ) ) % 1000000007 <NEWLINE> print ( int ( res ) ) <NEWLINE>
import numpy as np <NEWLINE> from numpy . fft import rfft , irfft <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> class Polynomial : <NEWLINE> <INDENT> def __init__ ( self , dim = 0 , const = 1 ) : <NEWLINE> <INDENT> self . values = [ ( dim , const ) ] <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return self . values + other . values <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class PolySolver : <NEWLINE> <INDENT> def __init__ ( self , size , init_val = 1 ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . f = np . zeros ( size , np . int64 ) <NEWLINE> self . f [ 0 ] = init_val <NEWLINE> <NL> <NL> <DEDENT> def multiple ( self , polynomial , MOD ) : <COMMENT> <NEWLINE> <INDENT> new_F = np . zeros ( self . size , np . int64 ) <NEWLINE> for dim , const in polynomial : <NEWLINE> <INDENT> if dim != 0 : <NEWLINE> <INDENT> g = np . zeros ( self . size , np . int64 ) <NEWLINE> g [ dim : ] += self . f [ : - dim ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = const * self . f . copy ( ) <NEWLINE> <NL> <DEDENT> new_F += g <NEWLINE> <NL> <DEDENT> self . f = new_F <NEWLINE> <NL> <NL> <DEDENT> def add ( self , polynomial ) : <COMMENT> <NEWLINE> <INDENT> for dim , const in polynomial : <NEWLINE> <INDENT> self . f [ dim ] += const <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_coefficient ( self , dim ) : <NEWLINE> <INDENT> return self . f [ dim ] <NEWLINE> <NL> <DEDENT> def fft ( self , A , B , fft_len = 1 << 18 ) : <NEWLINE> <INDENT> x = irfft ( rfft ( A , fft_len ) * rfft ( B , fft_len ) ) <NEWLINE> return np . rint ( x ) . astype ( np . int64 ) <NEWLINE> <NL> <DEDENT> def convolve ( self , g ) : <NEWLINE> <INDENT> h = self . fft ( self . f , g ) [ : len ( self . f ) + len ( g ) - 1 ] <NEWLINE> self . f = h <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> <NL> mx = 2 * 10 ** 5 + 10 <NEWLINE> F = PolySolver ( mx , init_val = 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> F . add ( Polynomial ( dim = a ) . values ) <NEWLINE> <NL> <DEDENT> g = F . f <NEWLINE> F . convolve ( g ) <NEWLINE> <NL> ans = 0 <NEWLINE> handshake = M <NEWLINE> for x in range ( mx - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> count = F . get_coefficient ( x ) <NEWLINE> if count <= 0 : continue <NEWLINE> <NL> if count > handshake : <NEWLINE> <INDENT> ans += handshake * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += count * x <NEWLINE> <NL> <DEDENT> handshake = max ( handshake - count , 0 ) <NEWLINE> if handshake == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nyukyo = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> bld = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for ny in nyukyo : <NEWLINE> <INDENT> bld [ ny [ 0 ] - 1 ] [ ny [ 1 ] - 1 ] [ ny [ 2 ] - 1 ] += ny [ 3 ] <NEWLINE> <NL> <DEDENT> for i , b in enumerate ( bld ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> print ( <STRING> , * f ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for e in num_list : <NEWLINE> <INDENT> if e == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for e in num_list : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sm = 0 <NEWLINE> p . sort ( ) <NEWLINE> q . sort ( ) <NEWLINE> r . sort ( reverse = True ) <NEWLINE> <NL> p = p [ ( a - x ) : ] <NEWLINE> q = q [ ( b - y ) : ] <NEWLINE> p . extend ( q ) <NEWLINE> p . sort ( ) <NEWLINE> <NL> idx = 0 <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] > r [ idx ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ i ] = r [ idx ] <NEWLINE> idx += 1 <NEWLINE> if c == idx : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( p ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = [ 0 ] * K , [ 0 ] * K <NEWLINE> <NL> count = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for _1 in range ( _ ) : <NEWLINE> <INDENT> x , y = L [ _1 ] , R [ _1 ] <NEWLINE> if x <= a <= y or x <= b <= y : <NEWLINE> <INDENT> L [ _1 ] = min ( a , x ) <NEWLINE> R [ _1 ] = max ( b , y ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ _ ] , R [ _ ] = a , b <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> L , R = L [ 0 : count + 1 ] , R [ 0 : count + 1 ] <NEWLINE> <NL> MOD = 998244353 <NEWLINE> dp = [ 0 ] * ( 4 * 10 ** 5 + 100 ) <NEWLINE> for l , r in zip ( L , R ) : <NEWLINE> <INDENT> dp [ min ( N + 1 , 1 + l ) ] += 1 <NEWLINE> dp [ min ( N + 1 , 1 + r + 1 ) ] -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> number = dp [ i - 1 ] + dp [ i ] <NEWLINE> if number > MOD : <NEWLINE> <INDENT> number -= MOD <NEWLINE> <DEDENT> dp [ i ] = number <NEWLINE> for l , r in zip ( L , R ) : <NEWLINE> <INDENT> dp [ i + l ] += number <NEWLINE> dp [ i + l ] %= MOD <NEWLINE> dp [ i + r + 1 ] -= number <NEWLINE> dp [ i + r + 1 ] %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] % MOD ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( t [ lr [ i ] [ 1 ] - 1 ] - t [ lr [ i ] [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> import bisect <NEWLINE> def isin ( arr , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return arr [ min ( bisect . bisect_left ( arr , x ) , len ( arr ) - 1 ) ] == x <NEWLINE> <NL> <DEDENT> n , m = readInts ( ) <NEWLINE> ab = [ readInts ( ) for i in range ( m ) ] <NEWLINE> go1 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ab [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> go1 . append ( ab [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> go1 . sort ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if isin ( go1 , ab [ i ] [ 0 ] ) and ab [ i ] [ 1 ] == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> n_i_to_j_mod = [ 0 ] * ( 2019 + 1 ) <COMMENT> <NEWLINE> i_to_end_mod = [ 0 ] * ( len ( S ) + 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> i_to_end_mod [ 1 ] = int ( S [ - 1 ] ) % 2019 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i_to_end_mod [ i ] = ( i_to_end_mod [ i - 1 ] + int ( S [ - i ] ) * pow ( 10 , i - 1 , 2019 ) ) % 2019 <NEWLINE> <DEDENT> n_i_to_j_mod [ i_to_end_mod [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = n_i_to_j_mod [ 0 ] + ( n_i_to_j_mod [ 0 ] * ( n_i_to_j_mod [ 0 ] - 1 ) ) // 2 <NEWLINE> for i in range ( 1 , 2019 ) : <NEWLINE> <INDENT> if n_i_to_j_mod [ i ] >= 2 : <NEWLINE> <INDENT> ans += ( n_i_to_j_mod [ i ] * ( n_i_to_j_mod [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d1d2 = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> d1 , d2 = [ list ( i ) for i in zip ( * d1d2 ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if d1 [ i ] == d2 [ i ] and d1 [ i + 1 ] == d2 [ i + 1 ] and d1 [ i + 2 ] == d2 [ i + 2 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans_list = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for x in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> f = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ( f <= N ) : <NEWLINE> <INDENT> ans_list [ f ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> r = c . count ( <STRING> ) <NEWLINE> g = c . count ( <STRING> ) <NEWLINE> b = c . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> count = 0 <NEWLINE> sub1 = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i >= n or 2 * j - i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif c [ 2 * j - i ] != c [ i ] and c [ i ] != c [ j ] and c [ 2 * j - i ] != c [ j ] : <NEWLINE> <INDENT> sub1 += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans - sub1 ) <NEWLINE>
_ = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> for num in nums : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE>
l1 = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> idx = 0 <NEWLINE> for i in l1 : <NEWLINE> <INDENT> l1 [ idx ] = int ( i ) <NEWLINE> idx += 1 <NEWLINE> <DEDENT> l1 . sort ( ) <NEWLINE> print ( l1 [ 0 ] , l1 [ 1 ] , l1 [ 2 ] ) <NEWLINE>
import math <NEWLINE> <NL> mod = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> zero = 0 <NEWLINE> dic = { } <NEWLINE> dic [ ( 0 , 1.5 ) ] = 0 <NEWLINE> dic [ ( 1.5 , 0 ) ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> idx = ( ai , bi ) <NEWLINE> if ai < 0 : <NEWLINE> <INDENT> ai , bi = - ai , - bi <NEWLINE> <DEDENT> if idx == ( 0 , 0 ) : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> elif idx [ 0 ] == 0 : <NEWLINE> <INDENT> dic [ ( 0 , 1.5 ) ] += 1 <NEWLINE> <DEDENT> elif idx [ 1 ] == 0 : <NEWLINE> <INDENT> dic [ ( 1.5 , 0 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( abs ( ai ) , abs ( bi ) ) <NEWLINE> ai = ai // g <NEWLINE> bi = bi // g <NEWLINE> idx = ( ai , bi ) <NEWLINE> if idx in dic : <NEWLINE> <INDENT> dic [ idx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ idx ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> already = set ( [ ] ) <NEWLINE> for key , value in dic . items ( ) : <NEWLINE> <INDENT> if key in already : continue <NEWLINE> a , b = key <NEWLINE> if a == 1.5 or b == 1.5 : <NEWLINE> <INDENT> pair1 = dic [ ( 0 , 1.5 ) ] <NEWLINE> pair2 = dic [ ( 1.5 , 0 ) ] <NEWLINE> ans = ( ans * ( pow ( 2 , pair1 , mod ) + pow ( 2 , pair2 , mod ) - 1 ) ) % mod <NEWLINE> already . add ( ( 0 , 1.5 ) ) <NEWLINE> already . add ( ( 1.5 , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b > 0 : idx = ( b , - a ) <NEWLINE> else : idx = ( - b , a ) <NEWLINE> if idx in dic : <NEWLINE> <INDENT> pair1 = dic [ key ] <NEWLINE> pair2 = dic [ idx ] <NEWLINE> ans = ( ans * ( pow ( 2 , pair1 , mod ) + pow ( 2 , pair2 , mod ) - 1 ) ) % mod <NEWLINE> already . add ( key ) <NEWLINE> already . add ( idx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pair1 = dic [ key ] <NEWLINE> ans = ( ans * pow ( 2 , pair1 , mod ) ) % mod <NEWLINE> already . add ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = ( ans + zero - 1 ) % mod <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> if min ( a ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n , 1 ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 1e+18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , k ) : <NEWLINE> <INDENT> if s [ i ] != 1 : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Alist = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> c = collections . Counter ( Alist ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> cnt += bisect_left ( A , b ) * ( N - bisect_right ( C , b ) ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import numba <NEWLINE> from numba import jit <NEWLINE> import numpy as np <NEWLINE> <NL> @ jit <NEWLINE> def main ( r , c ) : <NEWLINE> <INDENT> dp = np . zeros ( ( c + 1 , 4 ) , np . int64 ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> new_dp = np . zeros ( ( c + 1 , 4 ) , np . int64 ) <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> new_dp [ : , 0 ] = np . maximum ( new_dp [ : , 0 ] , dp [ : , j ] ) <NEWLINE> <DEDENT> dp = new_dp <NEWLINE> for k in range ( c ) : <NEWLINE> <INDENT> for l in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ k , l + 1 ] = max ( dp [ k , l + 1 ] , dp [ k , l ] + item_map [ i , k ] ) <NEWLINE> <DEDENT> for m in range ( 1 , 4 ) : <NEWLINE> <INDENT> dp [ k + 1 , m ] = max ( dp [ k + 1 , m ] , dp [ k , m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return max ( dp [ c - 1 , : ] ) <NEWLINE> <NL> <NL> <DEDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> item_lis = list ( list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ) <NEWLINE> item_map = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for i , j , k in item_lis : <NEWLINE> <INDENT> item_map [ i - 1 , j - 1 ] = k <NEWLINE> <NL> <DEDENT> print ( main ( R , C ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = 0 <NEWLINE> visit = [ 0 ] * N <NEWLINE> move = [ ] <NEWLINE> roop = [ ] <NEWLINE> while visit [ pos ] != 2 : <NEWLINE> <INDENT> if visit [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( pos ) <NEWLINE> <DEDENT> visit [ pos ] += 1 <NEWLINE> pos = A [ pos ] - 1 <NEWLINE> <DEDENT> if len ( move ) > K : <NEWLINE> <INDENT> print ( move [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( K - ( len ( move ) - len ( roop ) ) ) % len ( roop ) ] + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import itertools <NEWLINE> sum_a = list ( itertools . accumulate ( a ) ) <NEWLINE> sum_b = list ( itertools . accumulate ( b ) ) <NEWLINE> if sum_a [ - 1 ] + sum_b [ - 1 ] <= k : <NEWLINE> <INDENT> print ( n + m ) <NEWLINE> return <NEWLINE> <DEDENT> if a [ 0 ] > k and b [ 0 ] > k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if sum_a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> s_a = i - 1 <NEWLINE> if sum_a [ - 1 ] <= k : <NEWLINE> <INDENT> s_a = n - 1 <NEWLINE> <DEDENT> now_sum = 0 <NEWLINE> if s_a >= 0 : <NEWLINE> <INDENT> now_sum = sum_a [ s_a ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if now_sum + sum_b [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s_b = i - 1 <NEWLINE> ans = s_a + 1 + s_b + 1 <NEWLINE> now_sum = 0 <NEWLINE> for a_i in range ( s_a - 1 , - 2 , - 1 ) : <NEWLINE> <INDENT> for b_i in range ( s_b + 1 , m ) : <NEWLINE> <INDENT> if a_i < 0 : <NEWLINE> <INDENT> now_sumtime = sum_b [ b_i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_sumtime = sum_a [ a_i ] + sum_b [ b_i ] <NEWLINE> <NL> <DEDENT> if b_i == m - 1 and now_sumtime <= k : <NEWLINE> <INDENT> now_sum = a_i + m + 1 <NEWLINE> break <NEWLINE> <DEDENT> if now_sumtime > k : <NEWLINE> <INDENT> now_sum = a_i + b_i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> s_b = b_i - 1 <NEWLINE> ans = max ( ans , now_sum ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> re = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> re [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in re : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<NL> from functools import reduce <NEWLINE> def comb ( n , max_k , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = [ 1 ] * ( max_k + 1 ) <NEWLINE> t = 1 <NEWLINE> for i in range ( max_k + 1 ) : <NEWLINE> <INDENT> res [ i ] *= t <NEWLINE> t *= n - i <NEWLINE> t %= mod <NEWLINE> <NL> <DEDENT> n = reduce ( lambda x , y : ( x * y ) % mod , range ( 1 , max_k + 1 ) , 1 ) <NEWLINE> n = pow ( n , mod - 2 , mod ) <NEWLINE> <NL> for i in reversed ( range ( max_k + 1 ) ) : <NEWLINE> <INDENT> res [ i ] *= n <NEWLINE> res [ i ] %= mod <NEWLINE> n *= i <NEWLINE> n %= mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = X + Y <NEWLINE> <NL> if d % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = d // 3 <NEWLINE> if X < n or 2 * n < X : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = comb ( n , X - n , 10 ** 9 + 7 ) [ X - n ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> from collections import deque <NEWLINE> def dijkstra ( xs , ys , xg , yg , h , w , k , field ) : <NEWLINE> <COMMENT> <NL> <INDENT> inf = 1e18 <NEWLINE> dist = [ [ inf ] * w for _ in range ( h ) ] <NEWLINE> dist [ xs ] [ ys ] = 0 <NEWLINE> que = deque ( [ ( 0 , xs , ys ) ] ) <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> while que : <NEWLINE> <INDENT> cost , x , y = que . popleft ( ) <NEWLINE> if cost > dist [ x ] [ y ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v in range ( 4 ) : <NEWLINE> <INDENT> nx , ny = x , y <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> nx += dx [ v ] <NEWLINE> ny += dy [ v ] <NEWLINE> if not field [ nx ] [ ny ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nx ] [ ny ] <= dist [ x ] [ y ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nx ] [ ny ] > dist [ x ] [ y ] + 1 : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = dist [ x ] [ y ] + 1 <NEWLINE> que . append ( ( dist [ nx ] [ ny ] , nx , ny ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dist [ xg ] [ yg ] == inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ xg ] [ yg ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ [ False ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = [ True if _ == <STRING> else False for _ in input ( ) ] <NEWLINE> field [ i + 1 ] = [ False ] + s + [ False ] <NEWLINE> <DEDENT> h += 2 <NEWLINE> w += 2 <NEWLINE> dijkstra ( xs , ys , xg , yg , h , w , k , field ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 7 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def bpow ( x , y , z ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for b in format ( y , <STRING> ) : <NEWLINE> <INDENT> a = ( a * a ) % z <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> a = ( a * x ) % z <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n , m , k = map ( int , args [ 0 ] . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> if m == 1 and n - 1 == k : <NEWLINE> <INDENT> return str ( 1 ) <NEWLINE> <NL> <DEDENT> ncr = 1 <NEWLINE> p = m * bpow ( m - 1 , n - 1 , mod ) % mod <NEWLINE> ret = p <NEWLINE> inv = bpow ( m - 1 , mod - 2 , mod ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ncr = ( ncr * ( n - i ) * bpow ( i , mod - 2 , mod ) ) % mod <NEWLINE> p = ( p * inv ) % mod <NEWLINE> ret += p * ncr % mod <NEWLINE> <NL> <DEDENT> return str ( ret % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
N = map ( int , input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <NL> <INDENT> a = a * i <NEWLINE> <NL> if a > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
( h , n ) , * t = [ list ( map ( int , o . split ( ) ) ) for o in open ( 0 ) ] <NEWLINE> d = [ 0 ] * ( h + 9999 ) <NEWLINE> for i in range ( 1 , h + 1 ) : d [ i ] = min ( d [ i - a ] + b for a , b in t ) <NEWLINE> print ( d [ h ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ False for _ in range ( n + 1 ) ] <NEWLINE> pos = 1 <NEWLINE> x = [ ] <NEWLINE> flg = False <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if visited [ pos ] == False : <NEWLINE> <INDENT> x . append ( pos ) <NEWLINE> visited [ pos ] = True <NEWLINE> pos = A [ pos ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> pre = x . index ( pos ) <NEWLINE> loop = x [ pre : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( k - pre ) % len ( loop ) ] ) <NEWLINE> <DEDENT>
def get_prime_fact ( n ) : <NEWLINE> <INDENT> primes = [ ] <NEWLINE> append = primes . append <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> append ( n ) <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <NL> <DEDENT> def get_knu ( a ) : <NEWLINE> <INDENT> before = 1 <NEWLINE> n = 2 <NEWLINE> while True : <NEWLINE> <INDENT> knum = ( n * ( n + 1 ) ) // 2 <NEWLINE> if a == knum : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> elif knum > a > before : <NEWLINE> <INDENT> return n - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> before = knum <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> D = int ( input ( ) ) <NEWLINE> p = get_prime_fact ( D ) <NEWLINE> <NL> if len ( p ) != len ( set ( p ) ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for n in set ( p ) : <NEWLINE> <INDENT> count = p . count ( n ) <NEWLINE> if count == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = get_knu ( count ) <NEWLINE> res += add <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( p ) ) <NEWLINE> <DEDENT>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> dp = [ True ] * 3 * int ( 1e6 ) <NEWLINE> x = - 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == - 1 : continue <NEWLINE> x = a <NEWLINE> while x <= A [ - 1 ] : <NEWLINE> <INDENT> x += a <NEWLINE> dp [ x ] = False <NEWLINE> <DEDENT> x = a <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i > 0 and a == A [ i - 1 ] : continue <NEWLINE> if i < N - 1 and a == A [ i + 1 ] : continue <NEWLINE> if dp [ a ] : res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
c = int ( input ( ) ) <NEWLINE> n_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if min ( n_list ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> ERR = 10 ** 18 <NEWLINE> flag = False <NEWLINE> for n in n_list : <NEWLINE> <INDENT> i = i * n <NEWLINE> if i > ERR : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> X = input ( ) <NEWLINE> one = 0 <NEWLINE> intX = 0 <NEWLINE> bitnow = 1 <NEWLINE> for i in reversed ( range ( len ( X ) ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> one += 1 <NEWLINE> intX += bitnow <NEWLINE> <DEDENT> bitnow *= 2 <NEWLINE> <DEDENT> hi = one + 1 <NEWLINE> lo = one - 1 <NEWLINE> hirembase = intX % hi <NEWLINE> lorembase = 0 <NEWLINE> if lo != 0 : <NEWLINE> <INDENT> lorembase = intX % lo <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> bo = [ ] <NEWLINE> for i in range ( 200010 ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> while i != 0 : <NEWLINE> <INDENT> bit = bin ( i ) <NEWLINE> bitnum = 0 <NEWLINE> for j in range ( len ( bit ) ) : <NEWLINE> <INDENT> if j == 0 or j == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if bit [ j ] == <STRING> : <NEWLINE> <INDENT> bitnum += 1 <NEWLINE> <DEDENT> <DEDENT> i = i % bitnum <NEWLINE> num += 1 <NEWLINE> <DEDENT> bo . append ( num ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> hirem = 1 <NEWLINE> lorem = 1 <NEWLINE> for i in reversed ( range ( len ( X ) ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> num = ( hirembase + hirem + hi ) % hi <NEWLINE> ans . append ( bo [ num ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if one == 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( lorembase - lorem + lo ) % lo <NEWLINE> ans . append ( bo [ num ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> hirem = ( hirem * 2 ) % hi <NEWLINE> if one != 1 : <NEWLINE> <INDENT> lorem = ( lorem * 2 ) % lo <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in reversed ( range ( len ( ans ) ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> q = deque ( [ ] ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = 0 <NEWLINE> q . append ( i ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> s = g [ v ] <NEWLINE> for j in s : <NEWLINE> <INDENT> if dist [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ j ] = 0 <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt - 1 ) <NEWLINE>
temp1 = input ( ) <NEWLINE> n = int ( temp1 ) <NEWLINE> <NL> temp2 = input ( ) . split ( <STRING> ) <NEWLINE> <NL> nums = [ int ( a ) for a in temp2 ] <NEWLINE> <NL> <NL> temp = nums [ 0 ] <NEWLINE> <NL> limit = pow ( 10 , 18 ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> temp = temp * nums [ i ] <NEWLINE> if temp > limit : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> if temp <= limit : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
def binarySearch ( t ) : <NEWLINE> <INDENT> left , right = 0 , n <NEWLINE> while right > left + 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if S [ mid ] == t : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif S [ mid ] > t : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> print ( sum ( [ binarySearch ( t ) for t in T ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> S = int ( s ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S - ( h * 3600 + m * 60 ) <NEWLINE> str1 = str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) <NEWLINE> print ( str1 ) <NEWLINE>
num = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> b = 1 <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> b *= int ( i ) <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> a = [ 0 , 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( a [ i ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = [ int ( input ( ) ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> s . append ( max ( a , a + s [ i - 1 ] ) ) <NEWLINE> <DEDENT> print ( max ( s ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> import copy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . append ( s ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> count = N <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i - 1 ] == S [ i ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> flag = 0 <NEWLINE> zero_flag = False <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> if ( i [ x ] == 0 ) : <NEWLINE> <INDENT> zero_flag = True <NEWLINE> result = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( zero_flag == False ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> result *= i [ x ] <NEWLINE> if ( result > pow ( 10 , 18 ) ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( set ( A ) ) <NEWLINE> <NL> if len ( A ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> memo = np . zeros ( ( K , K ) , int ) <NEWLINE> s = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( i , K ) : <NEWLINE> <INDENT> for k in range ( j , K ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> rate = 1 <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> rate = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rate = 6 <NEWLINE> <DEDENT> s += math . gcd ( math . gcd ( i + 1 , j + 1 ) , k + 1 ) * rate <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> checked = [ False ] * ( n + 1 ) <NEWLINE> checked [ 1 ] = True <NEWLINE> stack = deque ( [ 1 ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> p = stack . popleft ( ) <NEWLINE> for i in tree [ p ] : <NEWLINE> <INDENT> if checked [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i - 1 ] = p <NEWLINE> checked [ i ] = True <NEWLINE> stack . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> line = [ 0 ] * 1010 <NEWLINE> line [ a ] += 1 <NEWLINE> line [ b ] -= 1 <NEWLINE> for a , b in l : <NEWLINE> <INDENT> line [ a ] += 1 <NEWLINE> line [ b ] -= 1 <NEWLINE> <DEDENT> for i in range ( 1006 ) : <NEWLINE> <INDENT> line [ i + 1 ] += line [ i ] <NEWLINE> <DEDENT> if line . count ( 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp_min = p [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= tmp_min : <NEWLINE> <INDENT> tmp_min = p [ i ] <COMMENT> <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import namedtuple <NEWLINE> Node = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> <NL> class my_tree : <NEWLINE> <INDENT> def __init__ ( self , N = [ ] ) : <NEWLINE> <INDENT> self . T = { } <NEWLINE> for ni in N : self . addNode ( ni ) <NEWLINE> <NL> <DEDENT> def addNode ( self , n ) : <NEWLINE> <INDENT> p = self . T . get ( n [ 0 ] , Node ( - 1 , [ None ] ) ) . parent <NEWLINE> self . T [ n [ 0 ] ] = Node ( p , n [ 2 : ] ) <NEWLINE> for c in n [ 2 : ] : <NEWLINE> <INDENT> cc = self . T . get ( c , Node ( - 1 , [ None ] ) ) . children <NEWLINE> self . T [ c ] = Node ( n [ 0 ] , cc ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getParent ( self , i ) : return self . T [ i ] . parent <NEWLINE> <NL> def getChildren ( self , i ) : return self . T [ i ] . children <NEWLINE> <NL> def getDepth ( self , i ) : <NEWLINE> <INDENT> if self . T [ i ] . parent == - 1 : return 0 <NEWLINE> return self . getDepth ( self . T [ i ] . parent ) + 1 <NEWLINE> <NL> <DEDENT> def getNodeType ( self , i ) : <NEWLINE> <INDENT> if self . T [ i ] . parent == - 1 : return <STRING> <NEWLINE> if self . T [ i ] . children : return <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> def getIdList ( self ) : return sorted ( self . T . keys ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> N = [ None ] * n <NEWLINE> for i in range ( n ) : N [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tree = my_tree ( N ) <NEWLINE> <NL> for i in tree . getIdList ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , tree . getParent ( i ) , tree . getDepth ( i ) , tree . getNodeType ( i ) , tree . getChildren ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ int ( a [ i ] ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li . append ( 0 ) <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> li [ x - 1 ] += 1 <NEWLINE> <DEDENT> for s in li : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> a = a % k <NEWLINE> if a % k == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a * 10 + 7 <NEWLINE> ans = i + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 10 ** 10 <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> t += B [ i ] <NEWLINE> <DEDENT> j = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> while j > 0 and t > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> t -= B [ j ] <NEWLINE> <NL> <DEDENT> if t > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> if i == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t += A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
SENTINEL = 10 ** 9 + 1 <NEWLINE> cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> L = A [ left : mid ] + [ SENTINEL ] <NEWLINE> R = A [ mid : right ] + [ SENTINEL ] <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += mid - left - i <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( A , 0 , len ( A ) ) <NEWLINE> print ( cnt ) <NEWLINE>
for i in range ( 100000 ) : <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> h = int ( x [ 0 ] ) <NEWLINE> w = int ( x [ 1 ] ) <NEWLINE> if h + w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( h ) : <NEWLINE> <INDENT> for k in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> ans = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = l [ b ] <NEWLINE> ans += ( c - b ) * x <NEWLINE> l [ c ] += x <NEWLINE> l [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( int ( n ) + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( map ( str , l [ 1 : ] ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce , lru_cache <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 6 <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , A = MAP ( ) <NEWLINE> x = LIST ( ) <NEWLINE> <NL> big = [ ] <NEWLINE> small = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for y in x : <NEWLINE> <INDENT> if y == A : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif y < A : <NEWLINE> <INDENT> small . append ( A - y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> big . append ( y - A ) <NEWLINE> <NL> <DEDENT> <DEDENT> big_possible = [ 0 ] * 2501 <NEWLINE> small_possible = [ 0 ] * 2501 <NEWLINE> big_possible [ 0 ] = 1 <NEWLINE> small_possible [ 0 ] = 1 <NEWLINE> <NL> for a in big : <NEWLINE> <INDENT> for i in range ( 2500 - a , - 1 , - 1 ) : <NEWLINE> <INDENT> if big_possible [ i ] : <NEWLINE> <INDENT> big_possible [ i + a ] += big_possible [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for b in small : <NEWLINE> <INDENT> for i in range ( 2500 - b , - 1 , - 1 ) : <NEWLINE> <INDENT> if small_possible [ i ] : <NEWLINE> <INDENT> small_possible [ i + b ] += small_possible [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , 2501 ) : <NEWLINE> <INDENT> ans += small_possible [ i ] * big_possible [ i ] <NEWLINE> <NL> <NL> <DEDENT> ans *= 2 ** cnt <NEWLINE> print ( ans - 1 ) <NEWLINE>
<COMMENT> <NL> <NL> import fileinput <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> offiHouse = [ [ [ 0 for i3 in range ( 10 ) ] for i2 in range ( 3 ) ] for i1 in range ( 4 ) ] <COMMENT> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> offiHouse [ a - 1 ] [ b - 1 ] [ c - 1 ] += d <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , offiHouse [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if ( i != 3 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = max ( x , y ) <NEWLINE> b = min ( x , y ) <NEWLINE> <NL> while a % b != 0 : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp % b <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> h , a , * m = open ( 0 ) <NEWLINE> h , w , k , a , b , f , g = map ( int , ( h + a ) . split ( ) ) <NEWLINE> I = h * w <NEWLINE> d = [ I ] * I <NEWLINE> a = ~ w + a * w + b <NEWLINE> d [ a ] = 1 <NEWLINE> q = [ a ] <NEWLINE> for s in q : <NEWLINE> <INDENT> for y , x in ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) : <NEWLINE> <INDENT> for z in range ( k ) : <NEWLINE> <INDENT> i , j = s // w + y * ~ z , s % w + x * ~ z <NEWLINE> t = i * w + j <NEWLINE> if not h > i > - 1 < j < w or <STRING> < m [ i ] [ j ] or d [ t ] <= d [ s ] : break <NEWLINE> if d [ t ] == I : <NEWLINE> <INDENT> q += t , <NEWLINE> d [ t ] = d [ s ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d [ ~ w + f * w + g ] % I - 1 ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mapping = <STRING> <NEWLINE> res = [ ] <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> N , r = divmod ( N , 26 ) <NEWLINE> res . append ( mapping [ r ] ) <NEWLINE> if r : <NEWLINE> <INDENT> N += 1 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> res . reverse ( ) <NEWLINE> print ( <STRING> . join ( res ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a - k + b ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_acc = [ 0 ] + list ( accumulate ( a ) ) <COMMENT> <NEWLINE> b_acc = list ( accumulate ( b ) ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> for an in range ( n + 1 ) : <NEWLINE> <INDENT> rem = k - a_acc [ an ] <NEWLINE> if rem < 0 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> bn = bisect . bisect_right ( b_acc , rem ) <NEWLINE> ans = max ( ans , an + bn ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if abs ( ans ) > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> c = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans * c ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> S = r * r * math . pi <NEWLINE> L = 2 * r * math . pi <NEWLINE> print ( <STRING> % ( S , L ) ) <NEWLINE>
count = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( count , x ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sn = [ 0 for x in range ( n ) ] <NEWLINE> for kind in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a_lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in a_lis : <NEWLINE> <INDENT> sn [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sn . count ( 0 ) ) <NEWLINE>
import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> q . append ( [ a - 1 , b - 1 , c , d ] ) <NEWLINE> <DEDENT> A = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> aa = list ( itertools . combinations_with_replacement ( A , N ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , cc in enumerate ( aa ) : <NEWLINE> <INDENT> ans1 = 0 <NEWLINE> for j , qq in enumerate ( q ) : <NEWLINE> <INDENT> if cc [ qq [ 1 ] ] - cc [ qq [ 0 ] ] == qq [ 2 ] : <NEWLINE> <INDENT> ans1 += qq [ 3 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans , ans1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> num = int ( input ( ) ) <NEWLINE> max_value = float ( <STRING> ) <NEWLINE> min_value = float ( <STRING> ) <NEWLINE> <NL> for i in [ int ( input ( ) ) for x in range ( num ) ] : <NEWLINE> <NL> <INDENT> if max_value < ( i - min_value ) : <NEWLINE> <INDENT> max_value = i - min_value <NEWLINE> <NL> <DEDENT> if min_value > i : <NEWLINE> <INDENT> min_value = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_value ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> total = 0 <NEWLINE> <NL> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( x , k + 1 ) : <NEWLINE> <INDENT> for z in range ( y , k + 1 ) : <NEWLINE> <INDENT> if x == y == z : <NEWLINE> <INDENT> total += x <NEWLINE> <DEDENT> elif x == y or y == z : <NEWLINE> <INDENT> total += 3 * math . gcd ( math . gcd ( x , y ) , z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += 6 * math . gcd ( math . gcd ( x , y ) , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
s = input ( ) <NEWLINE> newS = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> newS += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> newS += s [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( newS ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if i * 1000 >= N : <NEWLINE> <INDENT> ans = i * 1000 - N <NEWLINE> break <NEWLINE> <DEDENT> if N < 1000 : <NEWLINE> <INDENT> ans = 1000 - N <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // x <NEWLINE> ans += y * ( y + 1 ) * x // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> chk_list = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> chk = math . gcd ( i , j ) <NEWLINE> chk_list . append ( chk ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for h in chk_list : <NEWLINE> <INDENT> ans += math . gcd ( l , h ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> import math <NEWLINE> <NL> r = sys . stdin . readlines ( ) <NEWLINE> <NL> <NL> n = [ [ float ( i ) for i in ( j . split ( ) ) ] for j in r ] <NEWLINE> <NL> for l in n : <NEWLINE> <INDENT> y = ( l [ 2 ] * l [ 3 ] - l [ 0 ] * l [ 5 ] ) / ( l [ 1 ] * l [ 3 ] - l [ 0 ] * l [ 4 ] ) + 0 <NEWLINE> <NL> x = ( l [ 2 ] * l [ 4 ] - l [ 5 ] * l [ 1 ] ) / ( l [ 0 ] * l [ 4 ] - l [ 3 ] * l [ 1 ] ) + 0 <NEWLINE> <NL> print ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> if a [ i - 1 ] < a [ k + i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> a = 10 * a + 7 <NEWLINE> a %= k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> count += r * g * b <NEWLINE> <COMMENT> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> from collections import deque <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def dfs ( current , prev ) : <NEWLINE> <INDENT> global time <NEWLINE> <COMMENT> <NL> ord [ current ] = time <NEWLINE> low [ current ] = time <NEWLINE> time += 1 <NEWLINE> color [ current ] = BLACK <NEWLINE> <NL> for next in G [ current ] : <NEWLINE> <INDENT> if color [ next ] == WHITE : <NEWLINE> <COMMENT> <NL> <INDENT> parent [ next ] = current <NEWLINE> dfs ( next , current ) <NEWLINE> <NL> <COMMENT> <NL> low [ current ] = min ( low [ current ] , low [ next ] ) <NEWLINE> <DEDENT> elif next != prev : <NEWLINE> <COMMENT> <NL> <INDENT> low [ current ] = min ( low [ current ] , ord [ next ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def art_points ( ) : <NEWLINE> <INDENT> global time <NEWLINE> time = 1 <NEWLINE> dfs ( 0 , - 1 ) <COMMENT> <NEWLINE> np = 0 <NEWLINE> for i in range ( 1 , v ) : <NEWLINE> <INDENT> p = parent [ i ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> np += 1 <NEWLINE> <DEDENT> elif ord [ p ] <= low [ i ] : <NEWLINE> <INDENT> ap . add ( p ) <NEWLINE> <DEDENT> <DEDENT> if np > 1 : <NEWLINE> <INDENT> ap . add ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> G = { } <NEWLINE> v , n = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , v ) : <NEWLINE> <INDENT> G [ i ] = [ ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> <DEDENT> WHITE = 0 <NEWLINE> BLACK = 2 <NEWLINE> <NL> color = [ WHITE ] * ( v ) <NEWLINE> parent = [ 0 ] * ( v ) <NEWLINE> ord = [ 0 ] * ( v ) <NEWLINE> low = [ 0 ] * ( v ) <NEWLINE> parent = [ 0 ] * ( v ) <NEWLINE> ap = set ( [ ] ) <NEWLINE> art_points ( ) <NEWLINE> if ap : <NEWLINE> <INDENT> print ( * sorted ( ap ) , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a // gcd ( a , b ) * b <NEWLINE> <DEDENT> t = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> while ( t != 0 ) : <NEWLINE> <INDENT> t -= 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = lcm ( ans , n ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> num = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> num *= i <NEWLINE> if 10 ** 18 < num : <NEWLINE> <INDENT> num = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
from collections import Counter <NEWLINE> n , * v = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> v1 = Counter ( v [ : : 2 ] ) <NEWLINE> v2 = Counter ( v [ 1 : : 2 ] ) <NEWLINE> v1 = sorted ( [ ( i , v1 [ i ] ) for i in v1 . keys ( ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> v2 = sorted ( [ ( i , v2 [ i ] ) for i in v2 . keys ( ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> if v1 [ 0 ] [ 0 ] != v2 [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - v1 [ 0 ] [ 1 ] - v2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e1 = n - v2 [ 0 ] [ 1 ] if len ( v1 ) == 1 else n - v1 [ 1 ] [ 1 ] - v2 [ 0 ] [ 1 ] <NEWLINE> e2 = n - v1 [ 0 ] [ 1 ] if len ( v2 ) == 1 else n - v1 [ 0 ] [ 1 ] - v2 [ 1 ] [ 1 ] <NEWLINE> print ( min ( e1 , e2 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 2019 <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> dic [ 0 ] += 1 <NEWLINE> <NL> ans = 0 <NEWLINE> x = 0 <NEWLINE> count = 0 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> x += int ( s ) * pow ( 10 , count , MOD ) <NEWLINE> x %= MOD <NEWLINE> ans += dic [ x ] <NEWLINE> dic [ x ] += 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> s = set ( s ) <NEWLINE> <NL> print ( len ( s ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = N % K <NEWLINE> print ( min ( N , K - N ) ) <NEWLINE>
from networkx import Graph , predecessor <NEWLINE> <NL> G = Graph ( ) <COMMENT> <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> G . add_edges_from ( ab ) <COMMENT> <NEWLINE> preds = predecessor ( G , source = 1 ) <COMMENT> <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( preds [ i ] [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r ** 2 * pi , 2 * r * pi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in b : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( A ) <NEWLINE> res = list ( np . cumsum ( a ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> idx = 1 <NEWLINE> for i in range ( len ( res ) ) : <NEWLINE> <INDENT> num = res [ i ] <NEWLINE> if ( idx <= i ) : <NEWLINE> <INDENT> idx = i + 1 <NEWLINE> <DEDENT> while ( num * 2 >= a [ idx ] ) : <NEWLINE> <INDENT> num += a [ idx ] <NEWLINE> idx += 1 <NEWLINE> <NL> if ( idx >= len ( res ) - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( idx >= len ( res ) - 1 ) : <NEWLINE> <INDENT> print ( N - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def check ( a ) : <NEWLINE> <INDENT> if a < 400 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif a < 800 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < 1200 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif a < 1600 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif a < 2000 : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif a < 2400 : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif a < 2800 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 8 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ratings = [ <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> d = { r : 0 for r in ratings } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> d [ ratings [ check ( a ) ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> if k != <STRING> and v != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> top = d [ <STRING> ] <NEWLINE> if top == 0 : <NEWLINE> <INDENT> print ( ans , ans ) <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> print ( 1 , top ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , ans + top ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = pow ( 2 , n , mod ) - 1 <NEWLINE> fa = 1 <NEWLINE> fb = 1 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> fa *= i <NEWLINE> fa %= mod <NEWLINE> <DEDENT> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> fb *= i <NEWLINE> fb %= mod <NEWLINE> <NL> <DEDENT> fa = pow ( fa , mod - 2 , mod ) <NEWLINE> fb = pow ( fb , mod - 2 , mod ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> fa *= n - i <NEWLINE> fa %= mod <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> fb *= n - i <NEWLINE> fb %= mod <NEWLINE> <NL> <DEDENT> print ( ( ans - fa - fb ) % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> <NL> for k in range ( K , N ) : <NEWLINE> <INDENT> if A_list [ k ] > A_list [ k - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict , deque <NEWLINE> from itertools import combinations <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> D = defaultdict ( dict ) <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> D [ b - 1 ] [ ( a - 1 , c ) ] = d <NEWLINE> <NL> <DEDENT> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for x , y in combinations ( D [ j ] , 2 ) : <NEWLINE> <INDENT> if x [ 0 ] == y [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x [ 0 ] > y [ 0 ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> if x [ 1 ] > y [ 1 ] : <NEWLINE> <INDENT> if ( x [ 0 ] , x [ 1 ] - y [ 1 ] ) not in D [ y [ 0 ] ] : <NEWLINE> <INDENT> D [ y [ 0 ] ] [ ( x [ 0 ] , x [ 1 ] - y [ 1 ] ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> if ( j - 1 , 0 ) not in D [ j ] : <NEWLINE> <INDENT> D [ j ] [ ( j - 1 , 0 ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> que = deque ( [ ( [ 1 ] , 0 ) ] ) <NEWLINE> memo = set ( [ ( 1 , ) ] ) <NEWLINE> ans = 0 <NEWLINE> while que : <NEWLINE> <INDENT> L , score = que . popleft ( ) <NEWLINE> if len ( L ) == N : <NEWLINE> <INDENT> if score > ans : <NEWLINE> <INDENT> ans = score <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for a , c in D [ len ( L ) ] : <NEWLINE> <INDENT> l = L [ a ] + c <NEWLINE> if L [ - 1 ] <= l <= M : <NEWLINE> <INDENT> x = tuple ( L + [ l ] ) <NEWLINE> if x not in memo : <NEWLINE> <INDENT> memo . add ( x ) <NEWLINE> que . append ( ( L + [ l ] , score + sum ( d for v , d in D [ len ( L ) ] . items ( ) if l - L [ v [ 0 ] ] == v [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> old = 0 <NEWLINE> <NL> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> new = 1 <NEWLINE> <DEDENT> elif i != k : <NEWLINE> <INDENT> new = a [ i - 1 ] / a [ i - k - 1 ] <NEWLINE> if new > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> old = new <NEWLINE> <DEDENT>
<COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> def is_ok ( arg ) : <NEWLINE> <COMMENT> <NL> <INDENT> return sum ( - ( - i // arg ) - 1 for i in a ) <= k <NEWLINE> <NL> <NL> <DEDENT> def meguru_bisect ( ng , ok ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <DEDENT> print ( meguru_bisect ( 0 , max ( a ) ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if i * i <= N : <NEWLINE> <INDENT> ans = i * i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( 1 * ( K ) ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( 1 * ( A ) ) <NEWLINE> <DEDENT> elif K > A + B : <NEWLINE> <INDENT> print ( 1 * ( A ) + ( - 1 ) * ( K - A - B ) ) <NEWLINE> <DEDENT>
array = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 1 , 6 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 6 , 0 , 0 , 0 , 3 , 0 , 0 , 1 , 6 , 0 , 6 , 6 , 0 , 0 , 6 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 3 , 3 , 9 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 0 , 0 , 0 , 0 , 6 , 1 , 6 , 0 , 6 , 6 , 0 , 3 , 12 , 0 , 6 , 0 , 0 , 3 , 6 , 0 , 0 , 0 , 3 , 3 , 12 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 9 , 0 , 6 , 0 , 0 , 0 , 3 , 6 , 3 , 3 , 6 , 0 , 6 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 1 , 6 , 3 , 12 , 6 , 0 , 0 , 12 , 0 , 6 , 0 , 6 , 6 , 12 , 0 , 0 , 6 , 0 , 0 , 6 , 0 , 12 , 3 , 6 , 0 , 6 , 3 , 9 , 6 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 0 , 15 , 6 , 0 , 0 , 6 , 0 , 3 , 3 , 12 , 0 , 12 , 6 , 6 , 0 , 3 , 6 , 6 , 3 , 12 , 0 , 6 , 0 , 9 , 6 , 0 , 0 , 6 , 3 , 12 , 1 , 6 , 6 , 6 , 6 , 0 , 0 , 18 , 0 , 12 , 0 , 3 , 6 , 12 , 0 , 0 , 6 , 3 , 6 , 12 , 0 , 12 , 0 , 0 , 0 , 9 , 3 , 9 , 6 , 12 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 12 , 0 , 12 , 0 , 9 , 9 , 0 , 0 , 6 , 3 , 6 , 3 , 12 , 6 , 9 , 3 , 6 , 0 , 12 , 3 , 6 , 3 , 9 , 6 , 12 , 6 , 6 , 0 , 6 , 0 , 9 , 6 , 6 , 0 , 12 , 3 , 6 , 0 , 9 , 6 , 6 , 1 , 6 , 0 , 21 , 12 , 6 , 0 , 12 , 0 , 12 , 0 , 0 , 6 , 15 , 6 , 0 , 6 , 12 , 0 , 12 , 0 , 12 , 0 , 0 , 0 , 12 , 0 , 12 , 12 , 3 , 3 , 18 , 3 , 6 , 3 , 6 , 6 , 9 , 9 , 18 , 0 , 6 , 0 , 12 , 0 , 9 , 6 , 0 , 3 , 12 , 3 , 6 , 6 , 12 , 6 , 6 , 0 , 0 , 0 , 15 , 3 , 18 , 3 , 18 , 3 , 12 , 6 , 3 , 6 , 9 , 0 , 12 , 0 , 12 , 0 , 18 , 12 , 0 , 0 , 12 , 3 , 6 , 0 , 6 , 6 , 9 , 6 , 0 , 0 , 18 , 1 , 18 , 3 , 12 , 6 , 6 , 6 , 12 , 0 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 6 , 0 , 9 , 12 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 12 , 0 , 0 , 12 , 0 , 3 , 6 , 12 , 6 , 18 , 9 , 18 , 0 , 9 , 6 , 18 , 0 , 6 , 0 , 6 , 3 , 27 , 6 , 6 , 6 , 6 , 3 , 6 , 0 , 12 , 6 , 9 , 0 , 6 , 0 , 18 , 0 , 9 , 9 , 15 , 3 , 12 , 6 , 6 , 3 , 9 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 6 , 21 , 6 , 0 , 0 , 6 , 3 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 0 , 12 , 6 , 6 , 3 , 6 , 4 , 18 , 6 , 12 , 6 , 3 , 9 , 30 , 0 , 18 , 0 , 6 , 6 , 12 , 6 , 6 , 9 , 12 , 0 , 18 , 6 , 18 , 0 , 6 , 0 , 12 , 0 , 6 , 12 , 6 , 3 , 18 , 0 , 6 , 6 , 6 , 6 , 15 , 3 , 24 , 0 , 6 , 3 , 18 , 0 , 12 , 6 , 12 , 6 , 24 , 0 , 15 , 18 , 9 , 6 , 0 , 0 , 18 , 3 , 6 , 0 , 15 , 12 , 12 , 6 , 6 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 6 , 6 , 9 , 9 , 6 , 24 , 3 , 24 , 0 , 9 , 12 , 6 , 6 , 12 , 0 , 12 , 0 , 21 , 9 , 15 , 6 , 12 , 3 , 18 , 3 , 12 , 6 , 12 , 6 , 0 , 0 , 12 , 0 , 12 , 6 , 24 , 0 , 6 , 12 , 6 , 1 , 9 , 6 , 12 , 6 , 24 , 0 , 18 , 3 , 12 , 6 , 6 , 12 , 24 , 0 , 12 , 6 , 15 , 6 , 18 , 0 , 18 , 0 , 0 , 0 , 18 , 9 , 21 , 12 , 0 , 6 , 18 , 0 , 9 , 6 , 6 , 6 , 12 , 0 , 12 , 0 , 9 , 9 , 27 , 6 , 6 , 3 , 18 , 6 , 21 , 6 , 6 , 12 , 12 , 0 , 12 , 0 , 24 , 12 , 0 , 0 , 24 , 3 , 24 , 6 , 12 , 12 , 18 , 0 , 0 , 0 , 12 , 0 , 18 , 3 , 15 , 6 , 12 , 9 , 6 , 0 , 15 , 6 , 9 , 12 , 24 , 0 , 12 , 3 , 6 , 6 , 21 , 6 , 18 , 3 , 18 , 0 , 21 , 12 , 15 , 6 , 6 , 0 , 12 , 3 , 12 , 9 , 18 , 9 , 12 , 6 , 6 , 6 , 24 , 0 , 18 , 3 , 24 , 0 , 6 , 6 , 0 , 6 , 9 , 6 , 6 , 4 , 30 , 0 , 18 , 12 , 9 , 6 , 24 , 0 , 18 , 0 , 9 , 12 , 21 , 6 , 6 , 12 , 12 , 0 , 18 , 0 , 21 , 15 , 12 , 0 , 12 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 0 , 9 , 12 , 18 , 6 , 30 , 0 , 0 , 0 , 24 , 6 , 9 , 3 , 12 , 6 , 30 , 3 , 6 , 12 , 6 , 12 , 12 , 0 , 36 , 0 , 6 , 3 , 27 , 12 , 12 , 6 , 6 , 6 , 24 , 0 , 12 , 6 , 12 , 0 , 18 , 0 , 18 , 15 , 18 , 3 , 18 , 6 , 12 , 6 , 6 , 12 , 3 , 6 , 6 , 0 , 12 , 3 , 39 , 3 , 12 , 12 , 12 , 3 , 18 , 0 , 21 , 12 , 21 , 6 , 18 , 0 , 12 , 0 , 9 , 9 , 12 , 9 , 24 , 9 , 12 , 6 , 12 , 6 , 33 , 0 , 6 , 0 , 18 , 0 , 9 , 15 , 12 , 6 , 24 , 6 , 6 , 3 , 15 , 6 , 15 , 12 , 18 , 0 , 18 , 1 , 18 , 6 , 12 , 6 , 6 , 0 , 24 , 6 , 24 , 12 , 18 , 6 , 24 , 0 , 6 , 6 , 12 , 15 , 24 , 0 , 24 , 6 , 6 , 0 , 18 , 0 , 15 , 18 , 12 , 0 , 24 , 0 , 12 , 6 , 12 , 12 , 18 , 6 , 24 , 0 , 0 , 6 , 24 , 3 , 12 , 0 , 12 , 6 , 30 , 9 , 6 , 12 , 24 , 12 , 12 , 0 , 15 , 18 , 12 , 0 , 18 , 0 , 24 , 6 , 15 , 6 , 18 , 3 , 18 , 3 , 12 , 6 , 24 , 12 , 12 , 12 , 6 , 0 , 36 , 0 , 18 , 3 , 6 , 12 , 6 , 9 , 12 , 0 , 3 , 12 , 36 , 0 , 30 , 0 , 12 , 0 , 18 , 6 , 12 , 9 , 12 , 6 , 24 , 3 , 18 , 12 , 15 , 9 , 24 , 0 , 18 , 6 , 18 , 9 , 18 , 12 , 6 , 6 , 24 , 3 , 24 , 0 , 12 , 12 , 12 , 0 , 6 , 0 , 27 , 12 , 18 , 3 , 30 , 3 , 18 , 6 , 0 , 12 , 15 , 6 , 18 , 0 , 24 , 0 , 9 , 6 , 9 , 12 , 18 , 7 , 24 , 0 , 24 , 12 , 15 , 12 , 24 , 0 , 24 , 0 , 6 , 9 , 30 , 9 , 6 , 6 , 0 , 9 , 33 , 12 , 36 , 0 , 12 , 0 , 18 , 0 , 6 , 21 , 12 , 6 , 36 , 6 , 0 , 3 , 18 , 6 , 12 , 6 , 24 , 0 , 12 , 3 , 24 , 6 , 9 , 12 , 6 , 6 , 30 , 6 , 18 , 12 , 9 , 9 , 12 , 0 , 30 , 3 , 18 , 3 , 27 , 6 , 30 , 12 , 12 , 0 , 24 , 0 , 27 , 12 , 6 , 0 , 24 , 3 , 18 , 18 , 9 , 6 , 18 , 0 , 12 , 3 , 33 , 18 , 12 , 9 , 6 , 0 , 12 , 6 , 30 , 0 , 24 , 12 , 12 , 0 , 30 , 6 , 6 , 6 , 0 , 6 , 24 , 0 , 12 , 0 , 18 , 15 , 33 , 6 , 30 , 15 , 18 , 0 , 9 , 12 , 24 , 9 , 12 , 0 , 18 , 6 , 27 , 18 , 15 , 6 , 18 , 3 , 24 , 0 , 6 , 6 , 36 , 12 , 18 , 0 , 12 , 3 , 30 , 3 , 12 , 6 , 12 , 15 , 6 , 0 , 18 , 12 , 15 , 9 , 30 , 0 , 18 , 6 , 12 , 12 , 18 , 6 , 6 , 3 , 24 , 1 , 27 , 12 , 18 , 6 , 18 , 0 , 24 , 0 , 18 , 15 , 15 , 21 , 30 , 6 , 12 , 12 , 18 , 0 , 30 , 6 , 24 , 0 , 6 , 0 , 18 , 6 , 36 , 12 , 6 , 6 , 36 , 0 , 6 , 12 , 12 , 12 , 24 , 0 , 30 , 0 , 9 , 6 , 18 , 0 , 18 , 12 , 12 , 6 , 24 , 6 , 9 , 15 , 12 , 0 , 12 , 6 , 30 , 9 , 18 , 0 , 42 , 3 , 18 , 6 , 12 , 18 , 33 , 12 , 12 , 0 , 18 , 0 , 21 , 12 , 12 , 12 , 24 , 6 , 30 , 0 , 27 , 18 , 6 , 12 , 6 , 0 , 24 , 0 , 18 , 15 , 30 , 0 , 18 , 12 , 6 , 0 , 21 , 6 , 21 , 12 , 24 , 0 , 30 , 0 , 6 , 6 , 6 , 12 , 24 , 0 , 30 , 12 , 9 , 12 , 21 , 3 , 24 , 0 , 12 , 3 , 21 , 18 , 9 , 18 , 18 , 6 , 30 , 3 , 42 , 6 , 21 , 6 , 30 , 0 , 6 , 3 , 24 , 9 , 36 , 6 , 6 , 9 , 12 , 6 , 18 , 12 , 33 , 9 , 12 , 0 , 24 , 9 , 9 , 6 , 3 , 18 , 36 , 6 , 18 , 0 , 24 , 6 , 6 , 6 , 18 , 0 , 12 , 0 , 30 , 3 , 39 , 12 , 12 , 7 , 18 , 0 , 15 , 18 , 18 , 9 , 36 , 0 , 24 , 6 , 6 , 18 , 30 , 0 , 18 , 9 , 18 , 3 , 24 , 6 , 21 , 12 , 24 , 0 , 30 , 3 , 33 , 24 , 12 , 6 , 18 , 6 , 6 , 6 , 18 , 6 , 18 , 12 , 18 , 0 , 24 , 6 , 36 , 3 , 18 , 6 , 0 , 12 , 30 , 0 , 9 , 24 , 18 , 0 , 24 , 0 , 18 , 0 , 0 , 12 , 30 , 15 , 30 , 6 , 18 , 3 , 30 , 0 , 24 , 18 , 12 , 0 , 36 , 3 , 24 , 12 , 15 , 18 , 18 , 6 , 24 , 3 , 24 , 12 , 18 , 12 , 24 , 0 , 0 , 6 , 39 , 6 , 24 , 3 , 18 , 3 , 42 , 6 , 12 , 12 , 15 , 9 , 30 , 0 , 12 , 0 , 18 , 6 , 18 , 12 , 24 , 15 , 12 , 0 , 12 , 12 , 30 , 12 , 12 , 0 , 18 , 0 , 15 , 15 , 18 , 18 , 30 , 3 , 24 , 12 , 9 , 6 , 48 , 0 , 18 , 0 , 30 , 0 , 21 , 6 , 12 , 12 , 24 , 12 , 18 , 3 , 48 , 24 , 6 , 6 , 18 , 0 , 36 , 0 , 12 , 15 , 27 , 6 , 12 , 12 , 18 , 6 , 27 , 6 , 12 , 9 , 18 , 0 , 24 , 6 , 18 , 18 , 21 , 0 , 36 , 0 , 12 , 0 , 18 , 12 , 21 , 18 , 24 , 0 , 12 , 1 , 18 , 9 , 21 , 18 , 6 , 9 , 42 , 3 , 36 , 12 , 12 , 12 , 30 , 0 , 12 , 6 , 21 , 12 , 36 , 6 , 24 , 9 , 12 , 6 , 12 , 12 , 24 , 12 , 18 , 0 , 42 , 0 , 15 , 6 , 15 , 15 , 42 , 6 , 30 , 6 , 12 , 12 , 18 , 12 , 18 , 0 , 6 , 6 , 36 , 0 , 30 , 18 , 6 , 0 , 6 , 0 , 30 , 18 , 18 , 0 , 42 , 0 , 18 , 6 , 15 , 18 , 24 , 0 , 12 , 6 , 36 , 9 , 33 , 12 , 12 , 12 , 18 , 0 , 36 , 0 , 21 , 21 , 15 , 18 , 18 , 15 , 18 , 0 , 18 , 6 , 42 , 6 , 24 , 0 , 18 , 3 , 42 , 6 , 18 , 12 , 12 , 12 , 18 , 0 , 15 , 12 , 18 , 12 , 36 , 0 , 30 , 12 , 3 , 21 , 18 , 0 , 30 , 6 , 24 , 0 , 27 , 12 , 18 , 12 , 6 , 0 , 12 , 0 , 36 , 15 , 15 , 3 , 36 , 12 , 18 , 6 , 30 , 6 , 33 , 12 , 12 , 0 , 12 , 6 , 24 , 6 , 54 , 18 , 12 , 3 , 36 , 9 , 9 , 12 , 12 , 18 , 36 , 0 , 6 , 0 , 21 , 15 , 27 , 9 , 24 , 12 , 30 , 6 , 24 , 6 , 27 , 18 , 12 , 0 , 30 , 0 , 21 , 12 , 18 , 6 , 30 , 0 , 18 , 0 , 21 , 18 , 21 , 6 , 30 , 0 , 24 , 3 , 6 , 6 , 15 , 27 , 12 , 10 , 42 , 6 , 36 , 12 , 12 , 6 , 24 , 0 , 24 , 6 , 12 , 12 , 48 , 6 , 18 , 12 , 0 , 3 , 51 , 6 , 30 , 6 , 24 , 0 , 24 , 0 , 30 , 21 , 15 , 12 , 24 , 9 , 18 , 6 , 18 , 12 , 30 , 9 , 24 , 0 , 18 , 0 , 27 , 18 , 9 , 6 , 18 , 9 , 54 , 0 , 18 , 24 , 21 , 18 , 12 , 0 , 24 , 0 , 12 , 0 , 30 , 9 , 30 , 12 , 6 , 9 , 24 , 6 , 15 , 15 , 18 , 0 , 30 , 3 , 33 , 18 , 21 , 12 , 42 , 3 , 30 , 6 , 6 , 24 , 27 , 6 , 12 , 0 , 24 , 3 , 42 , 6 , 42 , 9 , 12 , 6 , 18 , 6 , 24 , 12 , 12 , 12 , 54 , 0 , 6 , 12 , 18 , 6 , 18 , 18 , 30 , 12 , 30 , 0 , 18 , 0 , 27 , 18 , 24 , 0 , 18 , 0 , 15 , 24 , 21 , 6 , 24 , 3 , 36 , 6 , 6 , 6 , 45 , 21 , 18 , 0 , 18 , 6 , 33 , 3 , 18 , 0 , 24 , 15 , 30 , 0 , 30 , 24 , 12 , 6 , 36 , 0 , 24 , 3 , 21 , 24 , 18 , 15 , 30 , 3 , 12 , 6 , 42 , 12 , 12 , 12 , 6 , 0 , 54 , 6 , 30 , 15 , 24 , 18 , 24 , 6 , 12 , 0 , 9 , 6 , 30 , 0 , 48 , 0 , 24 , 0 , 15 , 12 , 39 , 12 , 24 , 6 , 24 , 6 , 15 , 30 , 12 , 6 , 24 , 0 , 24 , 3 , 24 , 12 , 24 , 6 , 6 , 18 , 12 , 4 , 54 , 6 , 21 , 18 , 18 , 0 , 36 , 6 , 24 , 9 , 30 , 12 , 24 , 9 , 36 , 6 , 12 , 18 , 42 , 3 , 30 , 0 , 6 , 9 , 21 , 6 , 12 , 30 , 30 , 6 , 30 , 0 , 27 , 12 , 9 , 18 , 30 , 0 , 36 , 0 , 18 , 9 , 42 , 6 , 24 , 12 , 0 , 6 , 51 , 12 , 24 , 12 , 12 , 0 , 18 , 6 , 12 , 18 , 6 , 6 , 36 , 3 , 54 , 9 , 18 , 6 , 27 , 12 , 18 , 0 , 30 , 0 , 39 , 9 , 18 , 18 , 12 , 9 , 30 , 6 , 21 , 12 , 27 , 18 , 24 , 0 , 12 , 0 , 42 , 18 , 42 , 6 , 24 , 15 , 18 , 0 , 24 , 12 , 45 , 12 , 6 , 0 , 54 , 0 , 15 , 21 , 6 , 6 , 30 , 6 , 18 , 12 , 24 , 18 , 30 , 6 , 36 , 0 , 12 , 3 , 24 , 12 , 18 , 18 , 18 , 12 , 24 , 0 , 33 , 12 , 27 , 6 , 42 , 0 , 18 , 6 , 9 , 15 , 30 , 6 , 30 , 6 , 12 , 6 , 18 , 6 , 33 , 15 , 30 , 0 , 36 , 3 , 27 , 21 , 33 , 24 , 30 , 9 , 24 , 0 , 12 , 18 , 33 , 6 , 6 , 0 , 18 , 3 , 57 , 12 , 24 , 18 , 30 , 9 , 18 , 0 , 18 , 12 , 27 , 12 , 36 , 0 , 36 , 6 , 12 , 6 , 27 , 12 , 30 , 9 , 24 , 6 , 39 , 18 , 12 , 24 , 12 , 0 , 30 , 0 , 30 , 6 , 15 , 15 , 18 , 3 , 24 , 18 , 9 , 12 , 30 , 9 , 30 , 0 , 18 , 6 , 42 , 18 , 30 , 0 , 6 , 10 , 48 , 0 , 24 , 12 , 12 , 18 , 48 , 0 , 30 , 3 , 30 , 15 , 18 , 6 , 24 , 18 , 18 , 0 , 42 , 6 , 36 , 15 , 24 , 0 , 42 , 12 , 21 , 24 , 12 , 12 , 24 , 0 , 12 , 6 , 18 , 18 , 60 , 6 , 30 , 0 , 12 , 0 , 24 , 0 , 12 , 18 , 30 , 15 , 42 , 0 , 33 , 30 , 6 , 6 , 12 , 0 , 42 , 3 , 27 , 6 , 33 , 12 , 36 , 12 , 18 , 0 , 30 , 6 , 18 , 12 , 12 , 0 , 18 , 6 , 15 , 27 , 27 , 6 , 42 , 6 , 36 , 9 , 18 , 30 , 33 , 9 , 30 , 0 , 6 , 6 , 54 , 6 , 36 , 24 , 24 , 0 , 30 , 3 , 12 , 6 , 21 , 24 , 30 , 0 , 24 , 0 , 24 , 12 , 42 , 9 , 42 , 21 , 12 , 12 , 27 , 12 , 27 , 6 , 12 , 0 , 48 , 6 , 12 , 18 , 12 , 12 , 36 , 6 , 30 , 0 , 24 , 0 , 42 , 12 , 12 , 0 , 36 , 0 , 24 , 15 , 21 , 21 , 18 , 6 , 12 , 9 , 36 , 18 , 18 , 15 , 42 , 0 , 18 , 6 , 9 , 18 , 48 , 12 , 30 , 9 , 24 , 3 , 33 , 6 , 18 , 18 , 18 , 0 , 36 , 3 , 54 , 24 , 3 , 12 , 36 , 9 , 36 , 6 , 30 , 12 , 36 , 12 , 24 , 0 , 18 , 6 , 24 , 6 , 42 , 0 , 24 , 18 , 18 , 0 , 9 , 30 , 39 , 12 , 42 , 0 , 36 , 0 , 12 , 12 , 21 , 12 , 18 , 12 , 24 , 6 , 45 , 6 , 18 , 24 , 18 , 0 , 36 , 0 , 42 , 15 , 18 , 6 , 24 , 6 , 12 , 12 , 18 , 12 , 30 , 6 , 18 , 0 , 30 , 1 , 30 , 9 , 57 , 9 , 12 , 9 , 48 , 6 , 21 , 24 , 18 , 12 , 66 , 0 , 18 , 6 , 9 , 24 , 24 , 24 , 30 , 12 , 18 , 0 , 48 , 6 , 24 , 18 , 18 , 0 , 24 , 3 , 27 , 18 , 24 , 12 , 36 , 6 , 48 , 6 , 15 , 18 , 42 , 6 , 24 , 0 , 12 , 12 , 36 , 6 , 6 , 24 , 12 , 3 , 48 , 0 , 48 , 18 , 0 , 12 , 18 , 0 , 36 , 6 , 18 , 9 , 54 , 15 , 12 , 12 , 6 , 6 , 39 , 6 , 24 , 18 , 42 , 0 , 30 , 0 , 33 , 18 , 24 , 18 , 18 , 9 , 18 , 0 , 15 , 18 , 54 , 0 , 36 , 0 , 24 , 0 , 48 , 24 , 15 , 18 , 18 , 12 , 42 , 9 , 24 , 12 , 36 , 21 , 30 , 0 , 36 , 12 , 24 , 3 , 30 , 0 , 48 , 15 , 12 , 6 , 15 , 18 , 18 , 18 , 24 , 0 , 30 , 0 , 24 , 24 , 18 , 9 , 72 , 0 , 30 , 6 , 21 , 18 , 30 , 6 , 24 , 0 , 0 , 6 , 24 , 18 , 42 , 12 , 6 , 15 , 36 , 0 , 30 , 18 , 30 , 12 , 24 , 0 , 6 , 0 , 18 , 12 , 54 , 9 , 36 , 9 , 36 , 9 , 30 , 6 , 27 , 27 , 24 , 0 , 54 , 6 , 21 , 18 , 21 , 6 , 36 , 15 , 36 , 3 , 30 , 12 , 6 , 18 , 30 , 0 , 18 , 6 , 54 , 0 , 30 , 21 , 36 , 9 , 30 , 6 , 30 , 24 , 24 , 6 , 30 , 0 , 36 , 12 , 9 , 24 , 24 , 12 , 18 , 9 , 30 , 0 , 48 , 12 , 24 , 12 , 12 , 0 , 48 , 0 , 18 , 12 , 24 , 24 , 30 , 6 , 18 , 12 , 21 , 12 , 24 , 0 , 66 , 0 , 12 , 0 , 30 , 9 , 24 , 24 , 18 , 13 , 42 , 3 , 18 , 18 , 27 , 24 , 24 , 0 , 30 , 6 , 15 , 18 , 39 , 12 , 12 , 9 , 36 , 12 , 54 , 12 , 42 , 18 , 6 , 0 , 36 , 0 , 51 , 18 , 12 , 0 , 66 , 12 , 24 , 0 , 6 , 24 , 51 , 12 , 24 , 0 , 24 , 0 , 33 , 6 , 18 , 18 , 30 , 6 , 42 , 3 , 18 , 30 , 15 , 15 , 30 , 0 , 30 , 6 , 30 , 12 , 48 , 12 , 24 , 12 , 12 , 9 , 36 , 6 , 36 , 6 , 12 , 0 , 30 , 0 , 24 , 21 , 24 , 15 , 42 , 12 , 24 , 6 , 9 , 18 , 15 , 9 , 42 , 0 , 24 , 12 , 66 , 12 , 30 , 24 , 6 , 9 , 54 , 0 , 36 , 12 , 21 , 12 , 36 , 0 , 24 , 3 , 24 , 15 , 36 , 6 , 30 , 24 , 12 , 6 , 33 , 6 , 39 , 21 , 30 , 0 , 42 , 6 , 12 , 30 , 30 , 18 , 36 , 0 , 48 , 3 , 36 , 12 , 30 , 18 , 18 , 0 , 24 , 0 , 30 , 6 , 33 , 21 , 24 , 6 , 18 , 12 , 24 , 12 , 12 , 15 , 48 , 0 , 24 , 6 , 21 , 21 , 60 , 6 , 24 , 12 , 18 , 0 , 30 , 12 , 15 , 12 , 24 , 0 , 24 , 3 , 60 , 27 , 18 , 12 , 30 , 3 , 24 , 9 , 21 , 12 , 60 , 18 , 24 , 0 , 24 , 9 , 33 , 6 , 36 , 12 , 24 , 15 , 42 , 6 , 27 , 36 , 27 , 6 , 42 , 0 , 42 , 6 , 12 , 15 , 15 , 24 , 42 , 18 , 12 , 0 , 33 , 6 , 21 , 18 , 24 , 0 , 48 , 3 , 36 , 9 , 24 , 24 , 30 , 6 , 36 , 0 , 39 , 18 , 60 , 6 , 18 , 0 , 12 , 6 , 21 , 27 , 30 , 0 , 18 , 6 , 42 , 6 , 42 , 18 , 24 , 9 , 48 , 0 , 6 , 6 , 18 , 18 , 18 , 6 , 18 , 15 , 30 , 4 , 60 , 12 , 30 , 30 , 18 , 0 , 36 , 0 , 27 , 18 , 30 , 18 , 48 , 9 , 30 , 12 , 18 , 6 , 42 , 9 , 48 , 0 , 18 , 6 , 42 , 6 , 30 , 24 , 12 , 3 , 36 , 0 , 36 , 36 , 15 , 18 , 30 , 0 , 66 , 0 , 12 , 18 , 42 , 9 , 24 , 15 , 18 , 12 , 54 , 6 , 18 , 21 , 36 , 0 , 30 , 6 , 24 , 24 , 12 , 6 , 24 , 9 , 36 , 12 , 6 , 12 , 45 , 12 , 36 , 0 , 36 , 0 , 48 , 3 , 24 , 18 , 12 , 24 , 36 , 0 , 30 , 12 , 30 , 21 , 30 , 0 , 6 , 15 , 18 , 15 , 66 , 12 , 42 , 3 , 12 , 0 , 39 , 12 , 30 , 12 , 18 , 0 , 54 , 6 , 30 , 24 , 9 , 12 , 60 , 12 , 30 , 12 , 30 , 24 , 24 , 18 , 30 , 0 , 36 , 0 , 27 , 9 , 45 , 18 , 24 , 12 , 24 , 0 , 36 , 24 , 12 , 6 , 60 , 0 , 18 , 0 , 24 , 15 , 51 , 9 , 24 , 12 , 30 , 12 , 27 , 18 , 51 , 18 , 24 , 0 , 36 , 6 , 27 , 27 , 12 , 30 , 36 , 6 , 30 , 0 , 12 , 6 , 42 , 0 , 18 , 0 , 18 , 0 , 48 , 12 , 45 , 24 , 6 , 15 , 42 , 6 , 12 , 18 , 27 , 9 , 54 , 0 , 42 , 3 , 33 , 12 , 15 , 12 , 54 , 18 , 30 , 6 , 36 , 18 , 21 , 30 , 18 , 0 , 48 , 3 , 30 , 18 , 36 , 6 , 18 , 0 , 18 , 12 , 57 , 24 , 42 , 6 , 24 , 0 , 18 , 12 , 36 , 18 , 30 , 12 , 36 , 3 , 78 , 0 , 24 , 6 , 6 , 36 , 42 , 0 , 24 , 0 , 21 , 15 , 33 , 6 , 42 , 18 , 12 , 3 , 30 , 12 , 30 , 27 , 24 , 0 , 42 , 12 , 39 , 12 , 30 , 12 , 30 , 15 , 30 , 6 , 12 , 24 , 54 , 6 , 24 , 0 , 18 , 6 , 33 , 12 , 18 , 24 , 24 , 7 , 30 , 0 , 60 , 24 , 21 , 12 , 30 , 0 , 48 , 6 , 18 , 15 , 39 , 12 , 18 , 18 , 18 , 0 , 48 , 12 , 54 , 18 , 42 , 0 , 30 , 0 , 15 , 30 , 27 , 18 , 72 , 0 , 30 , 15 , 12 , 12 , 30 , 18 , 36 , 0 , 6 , 3 , 60 , 15 , 24 , 18 , 6 , 18 , 54 , 6 , 21 , 24 , 24 , 12 , 30 , 0 , 30 , 6 , 30 , 15 , 54 , 6 , 48 , 12 , 30 , 12 , 36 , 0 , 24 , 3 , 24 , 0 , 54 , 6 , 18 , 30 , 15 , 6 , 42 , 9 , 36 , 0 , 21 , 30 , 15 , 12 , 12 , 0 , 24 , 3 , 72 , 0 , 51 , 39 , 24 , 12 , 30 , 3 , 33 , 18 , 15 , 12 , 42 , 0 , 30 , 12 , 27 , 24 , 51 , 12 , 42 , 12 , 18 , 3 , 42 , 12 , 39 , 18 , 12 , 0 , 30 , 0 , 24 , 21 , 21 , 21 , 30 , 6 , 66 , 12 , 12 , 6 , 69 , 21 , 30 , 0 , 24 , 6 , 45 , 12 , 12 , 18 , 42 , 12 , 18 , 0 , 39 , 30 , 33 , 12 , 54 , 0 , 12 , 0 , 12 , 18 , 36 , 9 , 30 , 9 , 24 , 9 , 60 , 12 , 30 , 12 , 12 , 0 , 42 , 9 , 42 , 18 , 45 , 24 , 42 , 6 , 12 , 9 , 24 , 6 , 30 , 12 , 42 , 0 , 30 , 6 , 15 , 15 , 30 , 12 , 18 , 12 , 54 , 6 , 21 , 30 , 12 , 33 , 60 , 0 , 48 , 0 , 30 , 15 , 42 , 6 , 24 , 24 , 30 , 0 , 36 , 18 , 33 , 18 , 12 , 0 , 60 , 0 , 72 , 15 , 12 , 9 , 30 , 12 , 24 , 15 , 21 , 24 , 51 , 12 , 24 , 0 , 24 , 6 , 12 , 6 , 33 , 24 , 36 , 9 , 54 , 6 , 27 , 24 , 30 , 6 , 48 , 0 , 24 , 3 , 36 , 27 , 42 , 15 , 18 , 18 , 12 , 6 , 54 , 6 , 30 , 15 , 36 , 0 , 12 , 12 , 18 , 24 , 21 , 18 , 30 , 3 , 60 , 0 , 33 , 12 , 36 , 18 , 48 , 0 , 24 , 1 , 39 , 12 , 24 , 18 , 24 , 9 , 66 , 6 , 48 , 24 , 12 , 12 , 42 , 0 , 24 , 6 , 18 , 12 , 63 , 6 , 36 , 24 , 18 , 0 , 39 , 12 , 39 , 24 , 24 , 0 , 54 , 6 , 15 , 24 , 15 , 24 , 48 , 3 , 36 , 12 , 12 , 24 , 39 , 18 , 36 , 0 , 42 , 6 , 42 , 6 , 60 , 24 , 12 , 18 , 18 , 0 , 45 , 6 , 6 , 6 , 72 , 0 , 30 , 6 , 24 , 9 , 36 , 12 , 24 , 9 , 30 , 15 , 36 , 18 , 33 , 24 , 6 , 0 , 54 , 0 , 33 , 36 , 18 , 24 , 36 , 6 , 18 , 6 , 24 , 18 , 75 , 6 , 18 , 0 , 18 , 0 , 48 , 9 , 36 , 18 , 42 , 9 , 30 , 0 , 27 , 36 , 24 , 15 , 42 , 0 , 42 , 18 , 36 , 12 , 18 , 12 , 72 , 9 , 24 , 0 , 54 , 18 , 21 , 24 , 12 , 0 , 60 , 0 , 24 , 24 , 39 , 12 , 42 , 18 , 30 , 6 , 9 , 12 , 48 , 12 , 30 , 0 , 18 , 12 , 36 , 15 , 48 , 18 , 18 , 3 , 42 , 6 , 42 , 18 , 18 , 24 , 54 , 0 , 36 , 0 , 24 , 36 , 42 , 0 , 12 , 27 , 30 , 6 , 60 , 6 , 30 , 24 , 12 , 0 , 36 , 3 , 42 , 12 , 18 , 12 , 36 , 9 , 30 , 0 , 15 , 18 , 33 , 12 , 54 , 0 , 30 , 6 , 33 , 21 , 27 , 30 , 42 , 12 , 54 , 9 , 42 , 24 , 27 , 6 , 36 , 0 , 24 , 12 , 24 , 12 , 45 , 24 , 12 , 6 , 30 , 12 , 69 , 12 , 42 , 12 , 30 , 0 , 24 , 0 , 42 , 18 , 24 , 15 , 60 , 9 , 48 , 18 , 18 , 24 , 27 , 12 , 36 , 0 , 30 , 0 , 54 , 9 , 30 , 18 , 24 , 15 , 48 , 0 , 24 , 24 , 45 , 24 , 24 , 0 , 18 , 6 , 36 , 9 , 54 , 15 , 24 , 12 , 12 , 6 , 18 , 12 , 54 , 18 , 12 , 0 , 60 , 3 , 48 , 30 , 12 , 18 , 60 , 6 , 24 , 3 , 36 , 12 , 33 , 12 , 36 , 0 , 36 , 6 , 36 , 3 , 33 , 24 , 12 , 13 , 42 , 12 , 27 , 18 , 30 , 12 , 54 , 0 , 30 , 12 , 21 , 39 , 54 , 6 , 54 , 18 , 18 , 0 , 33 , 12 , 36 , 36 , 36 , 0 , 30 , 0 , 42 , 33 , 18 , 18 , 36 , 12 , 30 , 3 , 30 , 12 , 66 , 6 , 30 , 0 , 18 , 12 , 63 , 18 , 24 , 6 , 30 , 12 , 48 , 9 , 6 , 24 , 30 , 12 , 42 , 0 , 72 , 0 , 30 , 12 , 48 , 3 , 24 , 15 , 12 , 12 , 66 , 18 , 9 , 36 , 12 , 0 , 54 , 0 , 54 , 18 , 15 , 30 , 36 , 6 , 12 , 0 , 21 , 18 , 54 , 12 , 30 , 0 , 6 , 0 , 36 , 15 , 60 , 18 , 18 , 15 , 48 , 6 , 27 , 24 , 21 , 12 , 54 , 0 , 54 , 9 , 12 , 24 , 48 , 12 , 48 , 15 , 54 , 6 , 36 , 6 , 39 , 24 , 24 , 0 , 24 , 3 , 33 , 24 , 18 , 18 , 66 , 12 , 18 , 12 , 30 , 12 , 75 , 15 , 36 , 0 , 30 , 9 , 24 , 6 , 21 , 24 , 24 , 12 , 60 , 0 , 66 , 36 , 12 , 18 , 36 , 0 , 24 , 6 , 30 , 18 , 39 , 18 , 30 , 12 , 24 , 9 , 30 , 6 , 36 , 18 , 18 , 0 , 54 , 12 , 33 , 24 , 36 , 6 , 66 , 0 , 30 , 6 , 12 , 12 , 33 , 24 , 54 , 0 , 18 , 3 , 60 , 3 , 30 , 24 , 24 , 21 , 48 , 0 , 18 , 30 , 51 , 12 , 18 , 0 , 30 , 12 , 33 , 15 , 18 , 12 , 30 , 27 , 24 , 0 , 48 , 12 , 45 , 6 , 30 , 0 , 72 , 0 , 51 , 18 , 27 , 27 , 54 , 9 , 48 , 12 , 27 , 30 , 36 , 18 , 18 , 0 , 42 , 3 , 36 , 9 , 45 , 30 , 6 , 6 , 36 , 3 , 51 , 24 , 24 , 18 , 72 , 0 , 18 , 6 , 9 , 36 , 42 , 0 , 36 , 9 , 30 , 12 , 60 , 30 , 24 , 15 , 24 , 0 , 36 , 6 , 30 , 27 , 27 , 18 , 42 , 12 , 48 , 0 , 42 , 0 , 33 , 24 , 24 , 0 , 30 , 0 , 42 , 12 , 48 , 9 , 36 , 9 , 24 , 6 , 27 , 36 , 12 , 9 , 60 , 0 , 30 , 12 , 15 , 18 , 42 , 18 , 36 , 18 , 24 , 7 , 48 , 12 , 54 , 24 , 30 , 0 , 78 , 0 , 18 , 18 , 27 , 24 , 24 , 6 , 30 , 12 , 33 , 18 , 60 , 15 , 54 , 0 , 12 , 12 , 36 , 12 , 36 , 24 , 30 , 18 , 54 , 0 , 18 , 18 , 18 , 24 , 84 , 0 , 54 , 0 , 27 , 15 , 42 , 6 , 36 , 12 , 18 , 9 , 54 , 6 , 30 , 30 , 24 , 0 , 30 , 9 , 60 , 30 , 36 , 6 , 42 , 12 , 30 , 6 , 6 , 30 , 60 , 0 , 18 , 0 , 24 , 9 , 51 , 18 , 24 , 33 , 30 , 0 , 42 , 12 , 60 , 18 , 18 , 36 , 18 , 0 , 24 , 0 , 18 , 9 , 78 , 12 , 48 , 24 , 12 , 0 , 48 , 6 , 12 , 18 , 42 , 0 , 48 , 0 , 30 , 27 , 18 , 6 , 48 , 3 , 66 , 21 , 18 , 18 , 33 , 12 , 48 , 0 , 30 , 6 , 63 , 21 , 18 , 36 , 24 , 15 , 60 , 6 , 36 , 30 , 36 , 0 , 48 , 0 , 48 , 3 , 36 , 30 , 42 , 18 , 24 , 24 , 12 , 6 , 21 , 6 , 72 , 12 , 36 , 0 , 60 , 6 , 12 , 18 , 15 , 24 , 60 , 9 , 30 , 0 , 39 , 30 , 54 , 12 , 18 , 0 , 18 , 3 , 60 , 9 , 57 , 24 , 6 , 18 , 48 , 6 , 60 , 18 , 18 , 9 , 48 , 0 , 24 , 12 , 18 , 18 , 39 , 6 , 42 , 15 , 36 , 6 , 36 , 18 , 18 , 30 , 18 , 0 , 42 , 6 , 39 , 27 , 27 , 18 , 48 , 12 , 42 , 12 , 24 , 18 , 27 , 9 , 30 , 0 , 24 , 9 , 81 , 12 , 72 , 12 , 30 , 6 , 36 , 0 , 33 , 42 , 39 , 30 , 42 , 0 , 12 , 3 , 12 , 6 , 24 , 18 , 48 , 12 , 48 , 3 , 63 , 24 , 24 , 27 , 30 , 0 , 78 , 6 , 36 , 18 , 36 , 30 , 30 , 12 , 36 , 12 , 30 , 6 , 60 , 12 , 48 , 0 , 24 , 0 , 36 , 21 , 30 , 24 , 30 , 12 , 48 , 0 , 36 , 12 , 24 , 27 , 36 , 0 , 42 , 12 , 27 , 24 , 54 , 6 , 18 , 12 , 48 , 0 , 30 , 6 , 72 , 24 , 12 , 0 , 30 , 3 , 45 , 24 , 0 , 18 , 78 , 15 , 18 , 18 , 39 , 18 , 39 , 9 , 36 , 0 , 24 , 6 , 39 , 12 , 30 , 18 , 30 , 16 , 48 , 0 , 36 , 30 , 12 , 12 , 60 , 0 , 42 , 3 , 24 , 21 , 84 , 33 , 30 , 12 , 18 , 18 , 48 , 12 , 36 , 12 , 30 , 0 , 48 , 9 , 42 , 36 , 42 , 6 , 48 , 3 , 42 , 0 , 33 , 24 , 30 , 12 , 36 , 0 , 36 , 6 , 54 , 12 , 30 , 30 , 6 , 21 , 66 , 0 , 39 , 24 , 36 , 24 , 36 , 0 , 24 , 12 , 30 , 15 , 54 , 12 , 78 , 30 , 6 , 0 , 33 , 12 , 27 , 30 , 30 , 0 , 36 , 6 , 18 , 36 , 36 , 6 , 66 , 3 , 60 , 6 , 18 , 30 , 42 , 0 , 12 , 0 , 36 , 6 , 54 , 6 , 33 , 24 , 24 , 12 , 54 , 0 , 42 , 12 , 15 , 12 , 60 , 0 , 30 , 0 , 21 , 18 , 75 , 18 , 48 , 18 , 18 , 15 , 30 , 24 , 42 , 33 , 36 , 0 , 30 , 6 , 45 , 24 , 9 , 30 , 36 , 3 , 54 , 15 , 24 , 18 , 63 , 18 , 42 , 0 , 24 , 0 , 75 , 6 , 30 , 9 , 30 , 15 , 42 , 12 , 33 , 36 , 21 , 24 , 60 , 0 , 54 , 9 , 30 , 30 , 48 , 12 , 18 , 12 , 24 , 0 , 66 , 12 , 24 , 18 , 36 , 0 , 72 , 6 , 36 , 15 , 27 , 27 , 30 , 6 , 12 , 18 , 24 , 6 , 78 , 15 , 42 , 0 , 12 , 6 , 27 , 24 , 51 , 18 , 36 , 12 , 60 , 3 , 51 , 30 , 12 , 24 , 36 , 0 , 30 , 0 , 48 , 12 , 21 , 6 , 36 , 24 , 54 , 6 , 42 , 6 , 36 , 36 , 6 , 0 , 54 , 12 , 27 , 15 , 18 , 18 , 66 , 6 , 42 , 0 , 15 , 30 , 63 , 12 , 48 , 0 , 36 , 3 , 63 , 12 , 36 , 30 , 18 , 9 , 48 , 3 , 48 , 36 , 30 , 12 , 42 , 0 , 72 , 6 , 36 , 30 , 30 , 12 , 24 , 12 , 6 , 15 , 75 , 18 , 30 , 6 , 36 , 0 , 24 , 0 , 18 , 36 , 48 , 18 , 60 , 18 , 60 , 12 , 33 , 12 , 33 , 15 , 72 , 0 , 18 , 9 , 54 , 15 , 21 , 30 , 36 , 12 , 30 , 0 , 42 , 24 , 48 , 18 , 36 , 0 , 24 , 6 , 18 , 15 , 81 , 12 , 12 , 27 , 36 , 12 , 30 , 6 , 36 , 18 , 24 , 0 , 48 , 6 , 36 , 36 , 27 , 6 , 48 , 9 , 36 , 3 , 36 , 36 , 36 , 24 , 30 , 0 , 24 , 1 , 42 , 6 , 66 , 27 , 24 , 18 , 48 , 12 , 51 , 18 , 24 , 18 , 84 , 0 , 24 , 6 , 12 , 9 , 63 , 18 , 48 , 9 , 30 , 0 , 36 , 12 , 33 , 24 , 30 , 0 , 72 , 0 , 42 , 48 , 36 , 18 , 42 , 12 , 42 , 15 , 24 , 12 , 60 , 15 , 24 , 0 , 12 , 21 , 72 , 3 , 42 , 30 , 24 , 18 , 36 , 6 , 42 , 18 , 30 , 12 , 42 , 0 , 48 , 12 , 12 , 24 , 24 , 18 , 66 , 6 , 24 , 0 , 93 , 12 , 51 , 30 , 12 , 0 , 54 , 6 , 18 , 27 , 24 , 24 , 36 , 12 , 30 , 0 , 45 , 18 , 60 , 6 , 54 , 0 , 24 , 0 , 51 , 24 , 21 , 18 , 30 , 6 , 72 , 6 , 6 , 18 , 21 , 36 , 42 , 0 , 48 , 12 , 27 , 24 , 36 , 6 , 30 , 27 , 30 , 6 , 39 , 18 , 51 , 36 , 30 , 0 , 42 , 0 , 66 , 18 , 36 , 6 , 66 , 9 , 24 , 12 , 24 , 24 , 78 , 12 , 36 , 0 , 36 , 12 , 60 , 15 , 42 , 24 , 6 , 15 , 54 , 0 , 33 , 30 , 21 , 30 , 42 , 0 , 54 , 0 , 24 , 9 , 60 , 9 , 36 , 24 , 24 , 6 , 66 , 12 , 48 , 18 , 54 , 0 , 30 , 0 , 30 , 39 , 30 , 18 , 48 , 6 , 42 , 12 , 33 , 24 , 33 , 12 , 60 , 0 , 18 , 6 , 42 , 24 , 42 , 24 , 6 , 12 , 72 , 6 , 42 , 30 , 18 , 9 , 30 , 0 , 24 , 15 , 30 , 18 , 60 , 12 , 54 , 15 , 24 , 0 , 48 , 24 , 33 , 12 , 36 , 0 , 66 , 6 , 36 , 18 , 21 , 30 , 72 , 3 , 24 , 9 , 27 , 30 , 30 , 18 , 42 , 0 , 42 , 0 , 72 , 6 , 39 , 42 , 24 , 18 , 60 , 3 , 24 , 18 , 36 , 18 , 30 , 0 , 54 , 6 , 27 , 33 , 60 , 12 , 24 , 24 , 18 , 18 , 30 , 12 , 21 , 33 , 48 , 0 , 78 , 12 , 78 , 12 , 30 , 12 , 42 , 12 , 48 , 0 , 24 , 12 , 75 , 18 , 24 , 0 , 18 , 0 , 33 , 24 , 30 , 21 , 42 , 15 , 30 , 12 , 39 , 30 , 51 , 12 , 54 , 0 , 36 , 12 , 18 , 12 , 48 , 24 , 78 , 18 , 18 , 6 , 78 , 6 , 24 , 30 , 12 , 0 , 42 , 0 , 45 , 18 , 15 , 27 , 42 , 0 , 54 , 18 , 36 , 18 , 36 , 6 , 48 , 0 , 30 , 12 , 36 , 21 , 45 , 6 , 24 , 7 , 54 , 0 , 27 , 42 , 33 , 24 , 72 , 0 , 42 , 0 , 48 , 24 , 45 , 18 , 18 , 15 , 36 , 15 , 66 , 6 , 66 , 30 , 18 , 0 , 48 , 0 , 27 , 39 , 30 , 18 , 66 , 27 , 12 , 12 , 18 , 24 , 60 , 6 , 66 , 0 , 42 , 0 , 42 , 6 , 33 , 21 , 36 , 12 , 42 , 6 , 21 , 36 , 33 , 21 , 48 , 0 , 66 , 12 , 6 , 18 , 75 , 24 , 36 , 12 , 18 , 0 , 81 , 12 , 42 , 30 , 36 , 0 , 24 , 0 , 30 , 30 , 30 , 6 , 60 , 9 , 60 , 6 , 24 , 30 , 30 , 6 , 30 , 0 , 30 , 12 , 75 , 18 , 30 , 24 , 24 , 15 , 78 , 0 , 42 , 24 , 18 , 30 , 42 , 0 , 30 , 12 , 21 , 12 , 48 , 9 , 60 , 21 , 30 , 12 , 24 , 24 , 39 , 21 , 24 , 0 , 54 , 3 , 39 , 30 , 33 , 24 , 72 , 12 , 60 , 0 , 18 , 24 , 57 , 12 , 24 , 0 , 24 , 3 , 90 , 9 , 12 , 21 , 36 , 12 , 30 , 18 , 84 , 24 , 30 , 9 , 60 , 0 , 36 , 18 , 18 , 24 , 78 , 18 , 24 , 18 , 48 , 6 , 24 , 0 , 45 , 30 , 24 , 0 , 66 , 3 , 60 , 36 , 21 , 42 , 42 , 6 , 30 , 6 , 33 , 12 , 60 , 21 , 36 , 0 , 6 , 6 , 36 , 15 , 36 , 30 , 48 , 21 , 48 , 0 , 39 , 36 , 36 , 6 , 54 , 0 , 66 , 3 , 18 , 18 , 33 , 24 , 36 , 18 , 30 , 9 , 66 , 6 , 15 , 36 , 24 , 0 , 96 , 6 , 30 , 12 , 42 , 6 , 36 , 6 , 36 , 9 , 27 , 36 , 42 , 12 , 42 , 0 , 18 , 6 , 51 , 12 , 78 , 18 , 30 , 9 , 54 , 12 , 39 , 24 , 24 , 33 , 66 , 0 , 36 , 9 , 45 , 33 , 36 , 12 , 18 , 27 , 36 , 0 , 78 , 12 , 48 , 24 , 30 , 0 , 42 , 9 , 48 , 21 , 18 , 9 , 60 , 12 , 54 , 6 , 21 , 24 , 72 , 3 , 66 , 0 , 18 , 18 , 33 , 12 , 21 , 36 , 36 , 6 , 36 , 6 , 60 , 36 , 36 , 18 , 48 , 0 , 24 , 0 , 30 , 24 , 87 , 24 , 24 , 27 , 42 , 6 , 60 , 18 , 66 , 6 , 18 , 0 , 36 , 6 , 39 , 36 , 30 , 18 , 36 , 9 , 30 , 0 , 18 , 18 , 51 , 12 , 48 , 0 , 54 , 0 , 48 , 18 , 36 , 30 , 36 , 30 , 66 , 3 , 12 , 18 , 15 , 39 , 60 , 0 , 24 , 12 , 66 , 6 , 54 , 12 , 48 , 6 , 18 , 7 , 30 , 24 , 48 , 18 , 30 , 0 , 84 , 0 , 30 , 48 , 12 , 15 , 60 , 9 , 42 , 18 , 42 , 18 , 42 , 18 , 48 , 0 , 30 , 9 , 48 , 21 , 69 , 36 , 12 , 12 , 48 , 0 , 57 , 18 , 24 , 24 , 66 , 0 , 36 , 6 , 24 , 21 , 69 , 6 , 54 , 12 , 30 , 18 , 72 , 18 , 30 , 30 , 18 , 0 , 42 , 0 , 42 , 42 , 12 , 18 , 42 , 6 , 54 , 9 , 42 , 12 , 72 , 18 , 24 , 0 , 24 , 3 , 78 , 0 , 24 , 24 , 30 , 15 , 60 , 6 , 42 , 30 , 39 , 21 , 36 , 0 , 54 , 12 , 27 , 24 , 42 , 24 , 72 , 21 , 30 , 0 , 48 , 18 , 24 , 30 , 12 , 0 , 30 , 3 , 24 , 15 , 72 , 33 , 42 , 6 , 24 , 24 , 12 , 24 , 66 , 12 , 60 , 0 , 24 , 6 , 63 , 12 , 42 , 18 , 24 , 18 , 84 , 6 , 30 , 24 , 24 , 6 , 90 , 0 , 72 , 6 , 21 , 24 , 30 , 18 , 18 , 30 , 24 , 6 , 66 , 18 , 54 , 18 , 36 , 0 , 36 , 12 , 60 , 27 , 30 , 18 , 90 , 18 , 18 , 0 , 18 , 24 , 48 , 24 , 30 , 0 , 36 , 6 , 36 , 18 , 66 , 36 , 30 , 3 , 66 , 3 , 57 , 48 , 12 , 18 , 36 , 0 , 48 , 6 , 36 , 21 , 48 , 0 , 60 , 12 , 36 , 12 , 72 , 0 , 36 , 30 , 30 , 0 , 48 , 0 , 33 , 30 , 48 , 9 , 54 , 9 , 36 , 24 , 18 , 30 , 42 , 18 , 54 , 0 , 12 , 0 , 54 , 12 , 21 , 24 , 30 , 21 , 72 , 0 , 66 , 24 , 27 , 18 , 36 , 0 , 24 , 0 , 45 , 24 , 78 , 0 , 42 , 21 , 24 , 12 , 39 , 30 , 54 , 30 , 24 , 0 , 84 , 15 , 24 , 24 , 9 , 30 , 54 , 9 , 48 , 6 , 33 , 18 , 57 , 18 , 30 , 0 , 60 , 3 , 54 , 27 , 33 , 30 , 36 , 24 , 42 , 0 , 54 , 18 , 39 , 24 , 54 , 0 , 60 , 18 , 24 , 15 , 75 , 12 , 24 , 12 , 42 , 0 , 39 , 12 , 36 , 36 , 36 , 0 , 30 , 3 , 66 , 42 , 15 , 24 , 72 , 12 , 48 , 12 , 42 , 12 , 48 , 15 , 24 , 0 , 18 , 18 , 60 , 6 , 60 , 18 , 36 , 9 , 24 , 6 , 27 , 36 , 30 , 24 , 90 , 0 , 60 , 3 , 21 , 18 , 54 , 24 , 48 , 18 , 18 , 12 , 51 , 24 , 39 , 18 , 18 , 0 , 72 , 12 , 42 , 21 , 36 , 24 , 36 , 6 , 36 , 0 , 33 , 18 , 42 , 0 , 60 , 0 , 18 , 6 , 42 , 21 , 39 , 39 , 36 , 13 , 84 , 6 , 24 , 18 , 30 , 24 , 78 , 0 , 36 , 3 , 54 , 39 , 51 , 18 , 30 , 21 , 24 , 3 , 60 , 12 , 87 , 42 , 30 , 0 , 36 , 6 , 30 , 15 , 36 , 12 , 54 , 18 , 42 , 12 , 27 , 24 , 84 , 15 , 42 , 0 , 18 , 9 , 54 , 18 , 30 , 30 , 48 , 12 , 72 , 0 , 54 , 42 , 9 , 12 , 36 , 0 , 60 , 0 , 27 , 21 , 78 , 18 , 42 , 30 , 30 , 6 , 54 , 6 , 30 , 18 , 24 , 0 , 60 , 12 , 42 , 36 , 48 , 24 , 54 , 6 , 36 , 15 , 12 , 48 , 21 , 12 , 30 , 0 , 36 , 0 , 102 , 6 , 18 , 12 , 24 , 9 , 60 , 12 , 48 , 24 , 33 , 30 , 66 , 0 , 30 , 12 , 30 , 15 , 60 , 12 , 54 , 36 , 30 , 0 , 36 , 6 , 72 , 18 , 36 , 0 , 54 , 0 , 30 , 36 , 9 , 15 , 60 , 0 , 60 , 15 , 39 , 12 , 63 , 18 , 42 , 0 , 30 , 18 , 60 , 21 , 57 , 30 , 0 , 18 , 54 , 3 , 75 , 30 , 48 , 24 , 42 , 0 , 24 , 12 , 36 , 42 , 57 , 9 , 48 , 9 , 36 , 6 , 45 , 12 , 24 , 48 , 54 , 0 , 66 , 0 , 45 , 33 , 30 , 18 , 54 , 18 , 36 , 0 , 36 , 6 , 54 , 30 , 54 , 0 , 36 , 0 , 66 , 12 , 42 , 21 , 24 , 18 , 48 , 6 , 21 , 48 , 42 , 12 , 60 , 0 , 84 , 12 , 0 , 12 , 54 , 24 , 36 , 18 , 18 , 12 , 81 , 18 , 33 , 18 , 12 , 0 , 66 , 3 , 66 , 6 , 33 , 48 , 48 , 6 , 24 , 24 , 36 , 18 , 60 , 6 , 36 , 0 , 24 , 6 , 39 , 21 , 42 , 18 , 42 , 12 , 60 , 0 , 24 , 30 , 33 , 36 , 72 , 0 , 30 , 0 , 36 , 36 , 42 , 12 , 36 , 15 , 24 , 15 , 75 , 30 , 63 , 27 , 24 , 0 , 42 , 6 , 63 , 30 , 18 , 12 , 108 , 9 , 48 , 12 , 24 , 12 , 72 , 18 , 30 , 0 , 54 , 6 , 30 , 9 , 63 , 27 , 48 , 15 , 36 , 6 , 48 , 36 , 18 , 12 , 54 , 0 , 42 , 9 , 36 , 36 , 63 , 18 , 36 , 24 , 36 , 0 , 75 , 6 , 63 , 24 , 36 , 0 , 48 , 6 , 27 , 39 , 30 , 18 , 30 , 9 , 54 , 18 , 36 , 18 , 39 , 21 , 66 , 0 , 30 , 0 , 54 , 18 , 42 , 36 , 12 , 24 , 108 , 0 , 30 , 24 , 42 , 12 , 48 , 0 , 24 , 0 , 15 , 9 , 48 , 18 , 66 , 24 , 24 , 12 , 54 , 12 , 36 , 21 , 54 , 0 , 54 , 18 , 45 , 42 , 36 , 24 , 42 , 3 , 36 , 0 , 42 , 48 , 42 , 12 , 36 , 0 , 36 , 1 , 60 , 18 , 36 , 18 , 36 , 15 , 54 , 9 , 60 , 30 , 24 , 21 , 48 , 0 , 24 , 18 , 24 , 18 , 90 , 6 , 72 , 15 , 36 , 9 , 48 , 6 , 36 , 42 , 48 , 0 , 78 , 3 , 54 , 27 , 18 , 36 , 48 , 15 , 54 , 12 , 30 , 24 , 84 , 12 , 18 , 0 , 18 , 12 , 105 , 12 , 24 , 30 , 30 , 18 , 36 , 0 , 60 , 30 , 27 , 12 , 48 , 0 , 90 , 6 , 18 , 18 , 33 , 21 , 42 , 24 , 24 , 12 , 45 , 24 , 60 , 36 , 36 , 0 , 66 , 6 , 27 , 15 , 42 , 24 , 60 , 12 , 18 , 9 , 30 , 18 , 84 , 12 , 72 , 0 , 12 , 6 , 42 , 21 , 45 , 12 , 18 , 9 , 96 , 12 , 21 , 30 , 30 , 24 , 66 , 0 , 48 , 12 , 42 , 18 , 36 , 18 , 24 , 24 , 24 , 0 , 30 , 12 , 27 , 42 , 18 , 0 , 72 , 0 , 84 , 27 , 54 , 15 , 102 , 12 , 36 , 6 , 39 , 36 , 36 , 15 , 36 , 0 , 30 , 15 , 57 , 12 , 57 , 42 , 30 , 9 , 60 , 6 , 27 , 42 , 27 , 30 , 36 , 0 , 54 , 6 , 24 , 21 , 78 , 12 , 42 , 18 , 18 , 12 , 84 , 18 , 54 , 18 , 48 , 0 , 66 , 12 , 15 , 36 , 30 , 18 , 72 , 9 , 66 , 0 , 27 , 18 , 24 , 6 , 78 , 0 , 42 , 6 , 81 , 27 , 27 , 36 , 24 , 24 , 48 , 0 , 72 , 18 , 39 , 30 , 42 , 0 , 18 , 18 , 30 , 24 , 78 , 6 , 18 , 18 , 36 , 0 , 48 , 30 , 84 , 6 , 18 , 0 , 54 , 0 , 42 , 36 , 12 , 30 , 90 , 12 , 48 , 18 , 24 , 18 , 21 , 18 , 48 , 0 , 60 , 0 , 60 , 6 , 30 , 42 , 24 , 18 , 66 , 0 , 27 , 36 , 24 , 18 , 54 , 0 , 48 , 6 , 30 , 18 , 90 , 15 , 42 , 9 , 48 , 18 , 42 , 6 , 45 , 24 , 36 , 0 , 48 , 0 , 78 , 39 , 27 , 12 , 42 , 27 , 48 , 6 , 45 , 18 , 72 , 36 , 48 , 0 , 18 , 9 , 66 , 9 , 54 , 33 , 18 , 18 , 66 , 12 , 39 , 36 , 45 , 12 , 72 , 0 , 48 , 12 , 21 , 39 , 33 , 18 , 60 , 18 , 36 , 0 , 78 , 18 , 39 , 36 , 24 , 0 , 30 , 0 , 30 , 30 , 54 , 21 , 66 , 6 , 30 , 21 , 39 , 18 , 60 , 15 , 72 , 0 , 30 , 18 , 45 , 12 , 39 , 18 , 60 , 6 , 66 , 15 , 36 , 30 , 12 , 18 , 60 , 0 , 60 , 0 , 18 , 33 , 57 , 18 , 24 , 24 , 42 , 6 , 66 , 12 , 81 , 42 , 18 , 0 , 36 , 6 , 42 , 18 , 24 , 24 , 72 , 0 , 18 , 0 , 30 , 30 , 87 , 18 , 36 , 0 , 42 , 3 , 45 , 12 , 36 , 42 , 24 , 25 , 30 , 6 , 72 , 24 , 18 , 18 , 60 , 0 , 102 , 12 , 42 , 12 , 90 , 12 , 24 , 27 , 24 , 12 , 69 , 24 , 30 , 18 , 42 , 0 , 48 , 0 , 42 , 45 , 39 , 15 , 60 , 18 , 30 , 12 , 33 , 24 , 72 , 18 , 36 , 0 , 24 , 12 , 51 , 24 , 39 , 36 , 24 , 6 , 120 , 0 , 72 , 24 , 30 , 30 , 30 , 0 , 24 , 12 , 72 , 18 , 54 , 3 , 84 , 30 , 30 , 21 , 42 , 24 , 30 , 18 , 30 , 0 , 54 , 0 , 36 , 30 , 24 , 30 , 72 , 9 , 72 , 6 , 30 , 24 , 36 , 24 , 30 , 0 , 30 , 0 , 90 , 12 , 48 , 27 , 24 , 6 , 54 , 12 , 39 , 36 , 18 , 18 , 78 , 0 , 36 , 12 , 18 , 39 , 66 , 6 , 54 , 18 , 36 , 0 , 54 , 18 , 42 , 12 , 30 , 0 , 78 , 0 , 48 , 45 , 27 , 36 , 36 , 9 , 54 , 15 , 6 , 12 , 99 , 15 , 48 , 0 , 24 , 3 , 60 , 12 , 45 , 36 , 36 , 30 , 24 , 12 , 57 , 30 , 42 , 18 , 54 , 0 , 36 , 6 , 45 , 24 , 63 , 30 , 60 , 12 , 42 , 6 , 102 , 18 , 30 , 33 , 18 , 0 , 84 , 12 , 54 , 24 , 39 , 12 , 42 , 0 , 36 , 0 , 54 , 24 , 60 , 12 , 42 , 0 , 48 , 6 , 30 , 9 , 93 , 24 , 18 , 21 , 60 , 6 , 21 , 36 , 18 , 54 , 102 , 0 , 30 , 18 , 36 , 21 , 48 , 12 , 30 , 27 , 42 , 3 , 54 , 12 , 66 , 36 , 36 , 0 , 48 , 9 , 45 , 33 , 30 , 9 , 84 , 18 , 30 , 12 , 33 , 36 , 51 , 12 , 54 , 0 , 36 , 18 , 42 , 12 , 30 , 36 , 24 , 9 , 72 , 0 , 48 , 30 , 36 , 6 , 78 , 0 , 42 , 0 , 18 , 24 , 63 , 21 , 36 , 18 , 24 , 15 , 66 , 0 , 42 , 27 , 54 , 0 , 30 , 9 , 51 , 45 , 45 , 24 , 48 , 12 , 72 , 12 , 33 , 24 , 39 , 30 , 66 , 0 , 18 , 6 , 69 , 12 , 36 , 24 , 36 , 18 , 90 , 6 , 60 , 24 , 36 , 27 , 36 , 0 , 60 , 18 , 33 , 21 , 84 , 12 , 36 , 30 , 18 , 0 , 33 , 24 , 51 , 30 , 24 , 0 , 84 , 0 , 57 , 33 , 36 , 21 , 84 , 12 , 30 , 12 , 33 , 36 , 63 , 18 , 24 , 0 , 30 , 6 , 90 , 21 , 66 , 30 , 30 , 24 , 36 , 0 , 54 , 12 , 51 , 18 , 78 , 0 , 36 , 0 , 18 , 18 , 54 , 21 , 48 , 12 , 66 , 18 , 21 , 18 , 33 , 21 , 42 , 0 , 66 , 6 , 48 , 54 , 21 , 30 , 66 , 12 , 66 , 0 , 24 , 24 , 63 , 24 , 36 , 0 , 42 , 3 , 60 , 18 , 30 , 6 , 36 , 9 , 54 , 6 , 72 , 48 , 36 , 15 , 54 , 0 , 30 , 27 , 12 , 18 , 60 , 12 , 66 , 15 , 48 , 10 , 84 , 12 , 39 , 42 , 12 , 0 , 66 , 6 , 24 , 18 , 21 , 36 , 54 , 24 , 24 , 12 , 51 , 18 , 66 , 12 , 90 , 0 , 18 , 6 , 87 , 15 , 75 , 24 , 30 , 15 , 60 , 0 , 24 , 42 , 24 , 24 , 48 , 0 , 84 , 6 , 51 , 39 , 60 , 12 , 18 , 30 , 36 , 12 , 60 , 12 , 60 , 48 , 36 , 0 , 54 , 6 , 42 , 12 , 6 , 18 , 78 , 6 , 48 , 12 , 12 , 36 , 84 , 0 , 48 , 0 , 54 , 3 , 48 , 18 , 45 , 51 , 54 , 6 , 72 , 6 , 51 , 30 , 45 , 30 , 48 , 0 , 36 , 6 , 36 , 15 , 78 , 24 , 42 , 24 , 24 , 0 , 90 , 18 , 36 , 24 , 24 , 0 , 36 , 0 , 36 , 30 , 30 , 30 , 66 , 6 , 78 , 21 , 30 , 12 , 21 , 15 , 60 , 0 , 36 , 12 , 66 , 21 , 36 , 24 , 30 , 18 , 60 , 9 , 54 , 48 , 24 , 18 , 48 , 0 , 30 , 6 , 42 , 18 , 81 , 18 , 54 , 27 , 24 , 12 , 30 , 18 , 84 , 30 , 24 , 0 , 102 , 9 , 42 , 42 , 36 , 24 , 90 , 3 , 30 , 0 , 60 , 30 , 42 , 18 , 24 , 0 , 18 , 0 , 78 , 12 , 42 , 27 , 42 , 18 , 66 , 18 , 45 , 18 , 42 , 9 , 84 , 0 , 54 , 6 , 15 , 54 , 63 , 18 , 54 , 24 , 24 , 9 , 57 , 24 , 45 , 54 , 36 , 0 , 60 , 0 , 66 , 27 , 33 , 18 , 30 , 9 , 60 , 24 , 30 , 12 , 54 , 21 , 24 , 0 , 12 , 18 , 108 , 15 , 66 , 12 , 30 , 27 , 66 , 0 , 36 , 30 , 36 , 24 , 66 , 0 , 60 , 0 , 9 , 24 , 54 , 12 , 90 , 15 , 42 , 0 , 51 , 30 , 18 , 30 , 48 , 0 , 84 , 9 , 48 , 21 , 54 , 30 , 24 , 18 , 36 , 12 , 45 , 18 , 96 , 6 , 30 , 0 , 30 , 9 , 30 , 24 , 42 , 24 , 24 , 15 , 66 , 6 , 69 , 36 , 15 , 15 , 84 , 0 , 36 , 15 , 48 , 27 , 45 , 18 , 42 , 30 , 36 , 0 , 66 , 6 , 72 , 30 , 48 , 0 , 42 , 3 , 51 , 39 , 30 , 33 , 78 , 12 , 24 , 18 , 30 , 18 , 105 , 21 , 72 , 0 , 42 , 12 , 39 , 18 , 27 , 42 , 24 , 6 , 66 , 3 , 60 , 42 , 30 , 30 , 60 , 0 , 54 , 6 , 54 , 24 , 57 , 6 , 54 , 6 , 24 , 24 , 54 , 12 , 57 , 27 , 42 , 0 , 48 , 6 , 36 , 27 , 57 , 12 , 84 , 12 , 60 , 0 , 12 , 30 , 54 , 24 , 48 , 0 , 18 , 3 , 105 , 36 , 48 , 42 , 24 , 18 , 48 , 6 , 30 , 36 , 45 , 42 , 42 , 0 , 54 , 9 , 36 , 12 , 48 , 12 , 54 , 30 , 30 , 6 , 48 , 6 , 51 , 18 , 36 , 0 , 102 , 6 , 18 , 30 , 33 , 24 , 48 , 18 , 60 , 12 , 60 , 30 , 45 , 12 , 36 , 0 , 54 , 12 , 60 , 6 , 48 , 54 , 12 , 13 , 60 , 0 , 72 , 18 , 24 , 6 , 90 , 0 , 48 , 12 , 15 , 42 , 96 , 18 , 36 , 18 , 36 , 6 , 78 , 24 , 48 , 18 , 30 , 0 , 48 , 18 , 78 , 42 , 24 , 30 , 60 , 6 , 60 , 12 , 18 , 12 , 42 , 30 , 42 , 0 , 24 , 0 , 81 , 9 , 54 , 18 , 60 , 33 , 48 , 0 , 27 , 54 , 51 , 27 , 90 , 0 , 60 , 18 , 24 , 18 , 54 , 24 , 36 , 12 , 42 , 0 , 87 , 24 , 33 , 18 , 24 , 0 , 96 , 0 , 87 , 36 , 30 , 15 , 42 , 12 , 36 , 24 , 24 , 36 , 42 , 21 , 48 , 0 , 30 , 6 , 42 , 18 , 48 , 24 , 24 , 18 , 84 , 3 , 36 , 42 , 42 , 36 , 72 , 0 , 54 , 6 , 30 , 15 , 60 , 6 , 78 , 30 , 24 , 6 , 72 , 6 , 66 , 45 , 24 , 0 , 42 , 21 , 36 , 30 , 36 , 18 , 48 , 12 , 30 , 0 , 39 , 24 , 102 , 18 , 36 , 0 , 12 , 6 , 54 , 6 , 30 , 33 , 66 , 21 , 90 , 3 , 78 , 36 , 9 , 18 , 36 , 0 , 84 , 0 , 30 , 30 , 93 , 24 , 30 , 24 , 30 , 15 , 63 , 12 , 48 , 30 , 54 , 0 , 48 , 0 , 54 , 42 , 42 , 30 , 78 , 0 , 36 , 24 , 39 , 24 , 60 , 12 , 78 , 0 , 60 , 6 , 51 , 30 , 36 , 36 , 30 , 18 , 60 , 0 , 30 , 30 , 51 , 24 , 60 , 0 , 42 , 3 , 24 , 9 , 54 , 21 , 24 , 33 , 30 , 24 , 66 , 24 , 69 , 18 , 30 , 0 , 102 , 15 , 54 , 24 , 15 , 30 , 120 , 6 , 30 , 3 , 51 , 24 , 54 , 12 , 30 , 0 , 36 , 6 , 36 , 12 , 90 , 42 , 12 , 12 , 60 , 12 , 60 , 24 , 42 , 12 , 90 , 0 , 24 , 12 , 42 , 30 , 30 , 6 , 78 , 21 , 42 , 0 , 54 , 24 , 27 , 54 , 24 , 0 , 66 , 6 , 45 , 30 , 12 , 30 , 42 , 12 , 84 , 15 , 36 , 18 , 84 , 24 , 36 , 0 , 30 , 18 , 72 , 18 , 60 , 24 , 48 , 12 , 54 , 6 , 36 , 54 , 42 , 12 , 42 , 0 , 60 , 0 , 51 , 48 , 54 , 9 , 36 , 27 , 24 , 6 , 84 , 18 , 48 , 30 , 42 , 0 , 78 , 0 , 48 , 27 , 27 , 48 , 42 , 18 , 36 , 0 , 39 , 18 , 99 , 24 , 102 , 0 , 18 , 0 , 48 , 18 , 72 , 15 , 36 , 12 , 84 , 12 , 24 , 12 , 30 , 39 , 84 , 0 , 36 , 12 , 39 , 39 , 63 , 24 , 42 , 24 , 66 , 6 , 72 , 18 , 18 , 24 , 30 , 0 , 60 , 6 , 48 , 42 , 36 , 15 , 78 , 6 , 48 , 30 , 12 , 36 , 54 , 12 , 36 , 0 , 42 , 6 , 45 , 6 , 69 , 24 , 72 , 21 , 48 , 0 , 57 , 48 , 12 , 24 , 48 , 0 , 48 , 3 , 48 , 15 , 78 , 24 , 60 , 18 , 12 , 12 , 111 , 24 , 54 , 24 , 24 , 0 , 48 , 6 , 36 , 33 , 42 , 6 , 54 , 9 , 72 , 18 , 27 , 30 , 30 , 12 , 54 , 0 , 66 , 4 , 78 , 21 , 24 , 54 , 18 , 24 , 54 , 6 , 60 , 24 , 54 , 21 , 78 , 0 , 36 , 18 , 54 , 30 , 66 , 18 , 48 , 30 , 24 , 0 , 42 , 12 , 99 , 36 , 30 , 0 , 90 , 6 , 18 , 30 , 30 , 24 , 78 , 6 , 66 , 9 , 24 , 42 , 78 , 30 , 42 , 0 , 18 , 12 , 102 , 6 , 33 , 24 , 18 , 12 , 66 , 9 , 54 , 24 , 24 , 36 , 84 , 0 , 60 , 6 , 39 , 15 , 78 , 12 , 42 , 21 , 42 , 18 , 42 , 18 , 18 , 42 , 24 , 0 , 48 , 3 , 105 , 51 , 42 , 30 , 42 , 18 , 72 , 0 , 24 , 24 , 102 , 6 , 36 , 0 , 36 , 9 , 99 , 12 , 48 , 21 , 48 , 18 , 42 , 6 , 36 , 42 , 18 , 12 , 78 , 0 , 48 , 30 , 30 , 18 , 36 , 30 , 42 , 9 , 42 , 6 , 60 , 12 , 39 , 30 , 24 , 0 , 78 , 0 , 48 , 30 , 39 , 27 , 102 , 24 , 30 , 12 , 51 , 12 , 66 , 9 , 48 , 0 , 30 , 18 , 45 , 39 , 87 , 30 , 36 , 9 , 72 , 0 , 60 , 24 , 30 , 36 , 54 , 0 , 48 , 0 , 45 , 36 , 45 , 18 , 42 , 27 , 60 , 9 , 66 , 12 , 78 , 42 , 18 , 0 , 60 , 6 , 60 , 33 , 36 , 24 , 96 , 12 , 18 , 12 , 12 , 36 , 72 , 0 , 78 , 0 , 36 , 6 , 60 , 24 , 27 , 51 , 42 , 24 , 84 , 12 , 57 , 48 , 30 , 24 , 42 , 0 , 60 , 12 , 24 , 18 , 96 , 12 , 30 , 30 , 30 , 0 , 93 , 18 , 48 , 18 , 60 , 0 , 48 , 6 , 54 , 36 , 30 , 12 , 42 , 9 , 60 , 18 , 12 , 24 , 69 , 6 , 60 , 0 , 54 , 6 , 33 , 15 , 60 , 36 , 30 , 18 , 90 , 3 , 72 , 24 , 54 , 54 , 42 , 0 , 18 , 9 , 60 , 30 , 84 , 18 , 48 , 24 , 12 , 6 , 66 , 36 , 24 , 27 , 24 , 0 , 42 , 12 , 39 , 42 , 27 , 18 , 108 , 9 , 78 , 0 , 48 , 12 , 54 , 30 , 30 , 0 , 36 , 0 , 48 , 12 , 75 , 39 , 30 , 6 , 42 , 9 , 66 , 30 , 33 , 18 , 96 , 0 , 48 , 18 , 39 , 36 , 102 , 12 , 54 , 18 , 24 , 9 , 45 , 24 , 72 , 30 , 36 , 0 , 78 , 6 , 63 , 36 , 36 , 21 , 60 , 9 , 36 , 12 , 54 , 24 , 78 , 27 , 42 , 0 , 42 , 18 , 60 , 9 , 24 , 24 , 54 , 39 , 84 , 0 , 27 , 36 , 39 , 12 , 84 , 0 , 66 , 0 , 21 , 30 , 30 , 42 , 66 , 18 , 18 , 18 , 78 , 12 , 48 , 42 , 36 , 0 , 90 , 6 , 48 , 33 , 39 , 24 , 48 , 15 , 54 , 15 , 54 , 24 , 48 , 18 , 60 , 0 , 24 , 0 , 48 , 24 , 78 , 24 , 36 , 9 , 90 , 12 , 42 , 24 , 30 , 45 , 54 , 0 , 66 , 12 , 24 , 12 , 60 , 6 , 48 , 33 , 48 , 0 , 60 , 6 , 51 , 54 , 12 , 0 , 30 , 0 , 69 , 21 , 42 , 15 , 72 , 15 , 48 , 21 , 33 , 36 , 96 , 6 , 30 , 0 , 54 , 6 , 87 , 30 , 42 , 30 , 36 , 13 , 42 , 6 , 84 , 48 , 18 , 18 , 72 , 0 , 54 , 12 , 30 , 30 , 75 , 24 , 36 , 24 , 42 , 18 , 78 , 12 , 36 , 30 , 72 , 0 , 48 , 6 , 33 , 36 , 57 , 36 , 66 , 6 , 54 , 0 , 27 , 36 , 66 , 12 , 90 , 0 , 24 , 3 , 96 , 24 , 27 , 24 , 18 , 24 , 108 , 12 , 42 , 48 , 24 , 18 , 30 , 0 , 54 , 18 , 48 , 12 , 75 , 18 , 90 , 21 , 36 , 12 , 72 , 12 , 45 , 24 , 24 , 0 , 114 , 0 , 27 , 30 , 39 , 33 , 48 , 12 , 54 , 12 , 18 , 42 , 45 , 27 , 48 , 0 , 48 , 6 , 90 , 9 , 60 , 42 , 36 , 12 , 48 , 0 , 36 , 42 , 42 , 18 , 78 , 0 , 30 , 6 , 24 , 33 , 78 , 9 , 84 , 30 , 18 , 15 , 63 , 18 , 51 , 30 , 48 , 0 , 72 , 6 , 36 , 51 , 24 , 30 , 48 , 21 , 96 , 6 , 24 , 6 , 93 , 12 , 48 , 0 , 18 , 6 , 69 , 18 , 36 , 18 , 24 , 18 , 24 , 6 , 54 , 36 , 51 , 33 , 96 , 0 , 36 , 15 , 27 , 30 , 54 , 30 , 42 , 12 , 36 , 0 , 117 , 36 , 54 , 36 , 24 , 0 , 96 , 3 , 72 , 36 , 57 , 27 , 54 , 6 , 54 , 21 , 36 , 12 , 66 , 33 , 60 , 0 , 30 , 24 , 24 , 15 , 63 , 30 , 42 , 24 , 78 , 9 , 39 , 30 , 24 , 24 , 138 , 0 , 42 , 0 , 54 , 24 , 57 , 12 , 30 , 24 , 42 , 18 , 54 , 6 , 60 , 33 , 24 , 0 , 72 , 6 , 84 , 24 , 42 , 6 , 66 , 15 , 36 , 0 , 42 , 48 , 51 , 18 , 66 , 0 , 60 , 3 , 60 , 12 , 60 , 57 , 42 , 9 , 72 , 12 , 60 , 42 , 27 , 24 , 60 , 0 , 42 , 18 , 24 , 30 , 48 , 30 , 36 , 18 , 30 , 9 , 78 , 12 , 51 , 18 , 30 , 0 , 60 , 0 , 12 , 57 , 51 , 18 , 78 , 6 , 102 , 12 , 30 , 24 , 48 , 27 , 36 , 0 , 30 , 12 , 126 , 6 , 27 , 36 , 30 , 18 , 66 , 0 , 60 , 30 , 48 , 36 , 48 , 0 , 24 , 6 , 39 , 24 , 96 , 12 , 90 , 33 , 36 , 6 , 39 , 6 , 90 , 27 , 36 , 0 , 60 , 12 , 45 , 42 , 30 , 30 , 72 , 12 , 36 , 9 , 39 , 36 , 69 , 24 , 48 , 0 , 36 , 6 , 66 , 15 , 72 , 39 , 36 , 27 , 54 , 18 , 57 , 30 , 42 , 12 , 60 , 0 , 84 , 24 , 36 , 27 , 72 , 12 , 48 , 21 , 60 , 0 , 51 , 30 , 27 , 30 , 90 , 0 , 78 , 0 , 42 , 57 , 12 , 30 , 48 , 18 , 42 , 6 , 48 , 24 , 90 , 15 , 42 , 0 , 12 , 15 , 84 , 24 , 72 , 18 , 48 , 21 , 66 , 3 , 54 , 42 , 30 , 24 , 48 , 0 , 36 , 18 , 27 , 12 , 42 , 9 , 108 , 18 , 36 , 12 , 96 , 24 , 21 , 30 , 24 , 0 , 96 , 9 , 54 , 18 , 75 , 30 , 54 , 18 , 36 , 0 , 39 , 18 , 84 , 18 , 42 , 0 , 24 , 6 , 54 , 18 , 57 , 42 , 24 , 9 , 84 , 18 , 48 , 42 , 27 , 30 , 78 , 0 , 60 , 0 , 30 , 48 , 36 , 6 , 30 , 36 , 6 , 10 , 78 , 12 , 51 , 48 , 48 , 0 , 90 , 0 , 75 , 9 , 42 , 24 , 48 , 15 , 72 , 12 , 33 , 42 , 108 , 12 , 54 , 0 , 54 , 18 , 51 , 42 , 36 , 48 , 48 , 12 , 72 , 0 , 42 , 18 , 45 , 30 , 66 , 0 , 78 , 3 , 36 , 15 , 78 , 30 , 30 , 30 , 30 , 15 , 102 , 12 , 54 , 18 , 30 , 0 , 36 , 6 , 81 , 48 , 12 , 24 , 108 , 6 , 78 , 18 , 24 , 36 , 33 , 18 , 30 , 0 , 30 , 0 , 108 , 21 , 54 , 42 , 18 , 18 , 90 , 6 , 30 , 48 , 69 , 36 , 48 , 0 , 24 , 15 , 24 , 15 , 84 , 24 , 114 , 6 , 30 , 0 , 48 , 6 , 60 , 42 , 24 , 0 , 102 , 12 , 42 , 42 , 27 , 21 , 78 , 9 , 42 , 24 , 51 , 24 , 42 , 12 , 48 , 0 , 60 , 12 , 66 , 6 , 42 , 24 , 30 , 24 , 42 , 0 , 78 , 24 , 54 , 12 , 66 , 0 , 30 , 6 , 24 , 51 , 99 , 18 , 60 , 24 , 42 , 18 , 54 , 6 , 45 , 60 , 36 , 0 , 54 , 6 , 39 , 39 , 39 , 30 , 66 , 18 , 72 , 0 , 51 , 24 , 102 , 12 , 54 , 0 , 24 , 0 , 102 , 12 , 48 , 24 , 42 , 36 , 60 , 0 , 12 , 48 , 18 , 12 , 54 , 0 , 84 , 18 , 39 , 9 , 84 , 30 , 66 , 18 , 48 , 15 , 72 , 48 , 39 , 42 , 48 , 0 , 60 , 0 , 84 , 30 , 45 , 33 , 54 , 6 , 54 , 30 , 33 , 30 , 90 , 6 , 54 , 0 , 24 , 6 , 72 , 27 , 78 , 12 , 24 , 15 , 66 , 0 , 54 , 36 , 21 , 42 , 114 , 0 , 60 , 3 , 30 , 33 , 54 , 27 , 30 , 33 , 60 , 6 , 54 , 12 , 48 , 33 , 36 , 0 , 42 , 12 , 45 , 39 , 24 , 36 , 96 , 18 , 24 , 12 , 33 , 18 , 99 , 18 , 66 , 0 , 36 , 0 , 51 , 24 , 30 , 30 , 36 , 15 , 84 , 6 , 102 , 48 , 48 , 18 , 60 , 0 , 72 , 12 , 36 , 42 , 60 , 12 , 24 , 21 , 30 , 0 , 54 , 18 , 60 , 18 , 42 , 0 , 66 , 6 , 24 , 24 , 54 , 15 , 78 , 12 , 42 , 27 , 27 , 30 , 51 , 27 , 78 , 0 , 48 , 6 , 120 , 27 , 48 , 42 , 24 , 12 , 54 , 6 , 54 , 24 , 48 , 36 , 66 , 0 , 78 , 9 , 57 , 21 , 48 , 18 , 54 , 33 , 24 , 30 , 84 , 18 , 45 , 33 , 30 , 0 , 126 , 9 , 36 , 30 , 27 , 30 , 66 , 18 , 54 , 0 , 36 , 42 , 48 , 6 , 42 , 0 , 54 , 6 , 57 , 12 , 84 , 54 , 48 , 6 , 60 , 6 , 63 , 18 , 42 , 36 , 78 , 0 , 24 , 24 , 33 , 24 , 105 , 24 , 66 , 27 , 48 , 0 , 48 , 30 , 60 , 30 , 54 , 0 , 42 , 3 , 75 , 48 , 24 , 12 , 66 , 12 , 96 , 6 , 30 , 12 , 87 , 21 , 36 , 0 , 30 , 24 , 69 , 12 , 57 , 30 , 48 , 24 , 54 , 0 , 42 , 54 , 24 , 24 , 72 , 0 , 60 , 0 , 48 , 24 , 69 , 24 , 42 , 18 , 36 , 12 , 66 , 24 , 36 , 42 , 18 , 0 , 78 , 9 , 48 , 36 , 42 , 42 , 36 , 12 , 36 , 21 , 78 , 18 , 48 , 12 , 102 , 0 , 18 , 12 , 54 , 24 , 45 , 27 , 42 , 13 , 108 , 12 , 39 , 24 , 42 , 27 , 102 , 0 , 60 , 6 , 39 , 24 , 54 , 12 , 54 , 24 , 24 , 0 , 114 , 24 , 63 , 48 , 30 , 0 , 48 , 6 , 69 , 36 , 18 , 12 , 72 , 6 , 48 , 18 , 33 , 54 , 117 , 12 , 42 , 0 , 66 , 12 , 48 , 6 , 54 , 36 , 42 , 21 , 102 , 6 , 48 , 54 , 33 , 30 , 48 , 0 , 72 , 0 , 30 , 24 , 75 , 24 , 84 , 30 , 30 , 0 , 72 , 18 , 30 , 42 , 54 , 0 , 60 , 12 , 36 , 45 , 42 , 12 , 96 , 6 , 66 , 0 , 12 , 36 , 78 , 36 , 42 , 0 , 36 , 0 , 78 , 24 , 48 , 24 , 18 , 30 , 90 , 15 , 96 , 18 , 27 , 21 , 54 , 0 , 24 , 21 , 48 , 27 , 84 , 18 , 48 , 42 , 36 , 6 , 66 , 12 , 108 , 12 , 42 , 0 , 48 , 9 , 27 , 60 , 21 , 36 , 84 , 6 , 36 , 18 , 42 , 18 , 54 , 18 , 60 , 0 , 60 , 15 , 72 , 9 , 99 , 42 , 12 , 12 , 60 , 0 , 57 , 42 , 18 , 18 , 78 , 0 , 42 , 6 , 36 , 36 , 63 , 9 , 42 , 15 , 30 , 18 , 78 , 6 , 24 , 48 , 42 , 0 , 102 , 12 , 75 , 45 , 42 , 30 , 84 , 24 , 66 , 9 , 24 , 30 , 90 , 24 , 42 , 0 , 24 , 3 , 84 , 21 , 84 , 33 , 66 , 24 , 36 , 6 , 36 , 48 , 51 , 18 , 72 , 0 , 66 , 18 , 54 , 30 , 24 , 18 , 48 , 18 , 30 , 0 , 102 , 12 , 45 , 36 , 24 , 0 , 102 , 3 , 42 , 15 , 42 , 54 , 54 , 21 , 66 , 24 , 66 , 30 , 102 , 3 , 66 , 0 , 48 , 12 , 24 , 30 , 45 , 36 , 54 , 6 , 78 , 9 , 48 , 24 , 39 , 36 , 96 , 0 , 66 , 6 , 27 , 27 , 60 , 30 , 18 , 30 , 48 , 12 , 90 , 24 , 60 , 36 , 6 , 0 , 42 , 12 , 78 , 36 , 36 , 24 , 114 , 6 , 60 , 0 , 18 , 6 , 69 , 18 , 84 , 0 , 36 , 6 , 48 , 6 , 39 , 24 , 42 , 24 , 54 , 6 , 72 , 48 , 36 , 42 , 60 , 0 , 48 , 0 , 36 , 18 , 138 , 24 , 30 , 30 , 42 , 18 , 75 , 18 , 48 , 18 , 24 , 0 , 78 , 0 , 78 , 57 , 60 , 9 , 48 , 9 , 36 , 30 , 30 , 42 , 42 , 39 , 84 , 0 , 24 , 12 , 87 , 27 , 30 , 42 , 24 , 24 , 90 , 0 , 36 , 24 , 60 , 36 , 84 , 0 , 42 , 0 , 30 , 21 , 87 , 12 , 72 , 24 , 42 , 12 , 60 , 30 , 72 , 21 , 60 , 0 , 96 , 12 , 30 , 42 , 39 , 18 , 66 , 12 , 84 , 12 , 63 , 42 , 42 , 24 , 42 , 0 , 18 , 6 , 78 , 15 , 75 , 45 , 54 , 12 , 54 , 6 , 84 , 30 , 30 , 18 , 54 , 0 , 42 , 24 , 39 , 27 , 96 , 18 , 42 , 21 , 48 , 0 , 54 , 18 , 33 , 36 , 66 , 0 , 84 , 0 , 75 , 48 , 30 , 42 , 54 , 12 , 54 , 15 , 42 , 30 , 96 , 18 , 42 , 0 , 18 , 6 , 123 , 15 , 48 , 24 , 48 , 39 , 42 , 6 , 21 , 54 , 45 , 12 , 60 , 0 , 90 , 12 , 30 , 36 , 45 , 18 , 72 , 21 , 78 , 12 , 30 , 12 , 60 , 30 , 18 , 0 , 78 , 6 , 60 , 36 , 33 , 18 , 60 , 12 , 30 , 0 , 60 , 18 , 90 , 30 , 54 , 0 , 36 , 1 , 78 , 27 , 84 , 30 , 18 , 15 , 102 , 9 , 27 , 30 , 24 , 57 , 90 , 0 , 42 , 9 , 48 , 42 , 42 , 12 , 72 , 27 , 48 , 9 , 108 , 18 , 48 , 48 , 18 , 0 , 84 , 6 , 66 , 24 , 48 , 21 , 114 , 6 , 78 , 24 , 30 , 30 , 42 , 18 , 60 , 0 , 18 , 12 , 63 , 9 , 51 , 66 , 48 , 15 , 54 , 0 , 66 , 60 , 36 , 18 , 48 , 0 , 66 , 6 , 36 , 30 , 96 , 9 , 36 , 30 , 30 , 24 , 93 , 24 , 72 , 24 , 66 , 0 , 60 , 24 , 48 , 30 , 24 , 30 , 72 , 6 , 60 , 12 , 30 , 12 , 93 , 18 , 72 , 0 , 30 , 0 , 81 , 30 , 36 , 48 , 36 , 30 , 90 , 6 , 54 , 24 , 57 , 24 , 36 , 0 , 54 , 18 , 36 , 24 , 78 , 18 , 72 , 33 , 12 , 0 , 51 , 30 , 48 , 24 , 42 , 0 , 90 , 3 , 78 , 30 , 30 , 27 , 138 , 6 , 30 , 18 , 36 , 24 , 75 , 24 , 12 , 0 , 54 , 12 , 42 , 18 , 84 , 36 , 30 , 18 , 66 , 6 , 45 , 36 , 36 , 48 , 114 , 0 , 24 , 6 , 30 , 21 , 108 , 15 , 48 , 18 , 36 , 18 , 57 , 24 , 63 , 42 , 54 , 0 , 78 , 6 , 81 , 36 , 18 , 24 , 42 , 18 , 120 , 0 , 24 , 24 , 66 , 12 , 54 , 0 , 48 , 12 , 66 , 18 , 42 , 36 , 48 , 18 , 72 , 6 , 48 , 48 , 33 , 6 , 102 , 0 , 54 , 24 , 39 , 54 , 60 , 12 , 90 , 18 , 36 , 3 , 111 , 24 , 51 , 48 , 42 , 0 , 90 , 0 , 45 , 36 , 54 , 48 , 54 , 24 , 18 , 18 , 51 , 18 , 72 , 0 , 54 , 0 , 18 , 12 , 54 , 36 , 57 , 18 , 42 , 18 , 120 , 0 , 63 , 42 , 27 , 36 , 48 , 0 , 54 , 6 , 39 , 30 , 81 , 18 , 72 , 33 , 54 , 9 , 72 , 12 , 54 , 54 , 24 , 0 , 54 , 15 , 75 , 24 , 60 , 12 , 78 , 6 , 30 , 12 , 39 , 54 , 72 , 6 , 54 , 0 , 72 , 6 , 78 , 12 , 54 , 39 , 30 , 15 , 48 , 6 , 57 , 48 , 18 , 24 , 90 , 0 , 90 , 18 , 42 , 24 , 39 , 42 , 24 , 30 , 42 , 0 , 84 , 6 , 66 , 30 , 30 , 0 , 30 , 0 , 27 , 42 , 39 , 33 , 90 , 24 , 84 , 18 , 51 , 36 , 69 , 24 , 54 , 0 , 42 , 18 , 87 , 33 , 51 , 18 , 42 , 9 , 126 , 9 , 84 , 36 , 66 , 18 , 54 , 0 , 36 , 0 , 66 , 12 , 48 , 15 , 54 , 30 , 18 , 18 , 60 , 18 , 96 , 54 , 42 , 0 , 102 , 0 , 27 , 36 , 30 , 36 , 108 , 15 , 54 , 0 , 24 , 36 , 60 , 24 , 66 , 0 , 30 , 0 , 54 , 15 , 75 , 48 , 36 , 18 , 48 , 24 , 36 , 36 , 54 , 15 , 108 , 0 , 84 , 18 , 18 , 45 , 114 , 18 , 48 , 12 , 30 , 12 , 66 ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( array [ i ] ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> c = 0 <NEWLINE> while i <= n : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> x //= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * a ) <NEWLINE>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> if ( hc + wc ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> m = 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < m : <NEWLINE> <INDENT> m = p [ i ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> jougesayuu = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> <NL> check = True <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> for ( n , m ) in jougesayuu : <NEWLINE> <INDENT> ni , nj = i + n , j + m <NEWLINE> if ni < 0 or H <= ni or nj < 0 or W <= nj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if check else <STRING> ) <NEWLINE>
import os , sys , re , math <NEWLINE> <NL> <NL> def get_exp_value ( number ) : <NEWLINE> <INDENT> if number == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> a = ( number + 1 ) / number <NEWLINE> exp = a * ( number // 2 ) <NEWLINE> if number % 2 != 0 : <NEWLINE> <INDENT> exp += a / 2 <NEWLINE> <NL> <DEDENT> return exp <NEWLINE> <NL> <NL> <DEDENT> ( N , K ) = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> P = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> exps = [ get_exp_value ( i ) for i in range ( 200001 ) ] <NEWLINE> <NL> s = sum ( P [ 0 : K ] ) <NEWLINE> max_sum = 0 <NEWLINE> max_pos = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> s = s - P [ i - K ] + P [ i ] <NEWLINE> if s > max_sum : <NEWLINE> <INDENT> max_sum = s <NEWLINE> max_pos = i <NEWLINE> <NL> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for i in range ( max_pos - K , max_pos ) : <NEWLINE> <INDENT> answer += exps [ P [ i + 1 ] ] <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> <NL> <NL> a = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> a += int ( N [ i ] ) <NEWLINE> <NL> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p . sort ( ) <NEWLINE> <NL> for i in range ( p [ 0 ] - x , p [ n - 1 ] + x ) : <NEWLINE> <INDENT> if ( i not in p ) and abs ( x - i ) < abs ( ans - x ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def stdinput ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> from itertools import combinations <NEWLINE> n = int ( stdinput ( ) ) <NEWLINE> * A , = map ( int , stdinput ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( stdinput ( ) ) <NEWLINE> * M , = map ( int , stdinput ( ) . split ( <STRING> ) ) <NEWLINE> <NL> all_canditee = set ( [ sum ( c ) for i in range ( 1 , n + 1 ) for c in combinations ( A , i ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for m in M : <NEWLINE> <INDENT> if m in all_canditee : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def check ( m , a , A ) : <NEWLINE> <INDENT> for i , next_a in enumerate ( A ) : <NEWLINE> <INDENT> this_a = a + next_a <NEWLINE> if this_a == m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif this_a < m : <NEWLINE> <INDENT> if check ( m , this_a , A [ i + 1 : ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import collections <NEWLINE> def solve ( a , b , ab_list ) : <NEWLINE> <NL> <INDENT> route = { } <NEWLINE> <NL> for a , b in ab_list : <NEWLINE> <INDENT> if a not in route : <NEWLINE> <INDENT> route [ a ] = [ ] <NEWLINE> <DEDENT> if b not in route : <NEWLINE> <INDENT> route [ b ] = [ ] <NEWLINE> <NL> <DEDENT> route [ a ] . append ( b ) <NEWLINE> route [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> deque = collections . deque ( ) <NEWLINE> deque . extend ( route [ 1 ] ) <NEWLINE> route_memo = { i : 1 for i in route [ 1 ] } <NEWLINE> while len ( deque ) > 0 : <NEWLINE> <INDENT> room = deque . popleft ( ) <NEWLINE> for i in route [ room ] : <NEWLINE> <INDENT> if i != 1 and i not in route_memo : <NEWLINE> <INDENT> route_memo [ i ] = room <NEWLINE> deque . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( route_memo . keys ( ) ) == n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> tmp = sorted ( route_memo . items ( ) ) <NEWLINE> for i in tmp : <NEWLINE> <INDENT> print ( i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ab_list = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( m ) ] <NEWLINE> solve ( n , m , ab_list ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> an = x <NEWLINE> <NL> if x < 0 : <NEWLINE> <INDENT> x = - x <NEWLINE> <NL> <DEDENT> if k <= x / d : <NEWLINE> <INDENT> an = x - d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - x // d ) % 2 == 0 : <NEWLINE> <INDENT> an = x - d * ( x // d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an = x - d * ( x // d ) - d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( an ) ) <NEWLINE>
x , y , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = set ( ) <NEWLINE> r = [ 0 ] * x <NEWLINE> c = [ 0 ] * y <NEWLINE> smx = 0 <NEWLINE> smy = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> q -= 1 <NEWLINE> mat . add ( ( p , q ) ) <NEWLINE> r [ p ] += 1 <NEWLINE> c [ q ] += 1 <NEWLINE> smx = max ( smx , r [ p ] ) <NEWLINE> smy = max ( smy , c [ q ] ) <NEWLINE> <DEDENT> xs = [ ] <NEWLINE> ys = [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if smx == r [ i ] : xs . append ( i ) <NEWLINE> <DEDENT> for i in range ( y ) : <NEWLINE> <INDENT> if smy == c [ i ] : ys . append ( i ) <NEWLINE> <NL> <DEDENT> ans = smx + smy - 1 <NEWLINE> <NL> for h in xs : <NEWLINE> <INDENT> for w in ys : <NEWLINE> <INDENT> if ( h , w ) in mat : continue <NEWLINE> print ( ans + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> temp = A [ 0 ] <NEWLINE> while count < N : <NEWLINE> <INDENT> if A [ count ] > temp : <NEWLINE> <INDENT> kabu = money // temp <NEWLINE> money = money % temp <NEWLINE> money += kabu * A [ count ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> temp = A [ count ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( money ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> list . append ( s ) <NEWLINE> <DEDENT> c = collections . Counter ( list ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
def find ( x ) : <NEWLINE> <INDENT> if parent [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ x ] = find ( parent [ x ] ) <NEWLINE> return parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> root_x = find ( x ) <NEWLINE> root_y = find ( y ) <NEWLINE> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if parent [ root_x ] > parent [ root_y ] : <NEWLINE> <INDENT> root_x , root_y = root_y , root_x <NEWLINE> <DEDENT> parent [ root_x ] += parent [ root_y ] <NEWLINE> parent [ root_y ] = root_x <NEWLINE> <NL> <DEDENT> def members ( n , x ) : <NEWLINE> <INDENT> root = find ( x ) <NEWLINE> return [ i for i in range ( n ) if find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def get_size ( x ) : <NEWLINE> <INDENT> return - parent [ find ( x ) ] <NEWLINE> <NL> <DEDENT> def get_root ( ) : <NEWLINE> <INDENT> return [ i for i , root in enumerate ( parent ) if root < 0 ] <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> parent = [ - 1 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> b = b - 1 <NEWLINE> union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in parent : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> ans = ( a * ( b - 1 ) ) // b - a * ( ( b - 1 ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( a * n ) // b - a * ( n // b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def find ( x ) : <NEWLINE> <INDENT> global set_list <NEWLINE> if set_list [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> result = set_list [ x ] = find ( set_list [ x ] ) <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> set_list = list ( range ( n ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> op , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if op : <NEWLINE> <INDENT> print ( 1 if find ( x ) == find ( y ) else 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> set_list [ find ( y ) ] = find ( x ) <NEWLINE> <DEDENT> q -= 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> s = [ ] <NEWLINE> sum_a = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_a += A [ i ] <NEWLINE> ans += sum_a * A [ i + 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = - 1 <NEWLINE> A = sorted ( A ) + [ 0 ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while ( A [ i + 1 ] == n + 1 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> primes = [ 1 ] * 500000 <NEWLINE> primes [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 3 , 1000 , 2 ) : <NEWLINE> <INDENT> if primes [ i // 2 ] : <NEWLINE> <INDENT> primes [ ( i * i ) // 2 : : i ] = [ 0 ] * len ( primes [ ( i * i ) // 2 : : i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in sys . stdin : <NEWLINE> <INDENT> n = int ( i ) <NEWLINE> if n < 4 : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( primes [ : ( n + 1 ) // 2 ] ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > ma : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
judge = True <NEWLINE> while judge : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H + W == 0 : <NEWLINE> <INDENT> judge = False <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , H ) : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if i == 0 or i == ( H - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - i - j <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> x = input ( ) <NEWLINE> <NL> split_x = x . split ( sep = <STRING> ) <NEWLINE> <NL> a = split_x [ 0 ] <NEWLINE> b = split_x [ 1 ] <NEWLINE> <NL> if int ( a ) < int ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if int ( a ) == int ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if int ( a ) > int ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 1 , math . ceil ( math . sqrt ( m ) ) ) : <NEWLINE> <INDENT> if m % n == 0 : <NEWLINE> <INDENT> print ( m // n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m % i == 0 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> b . append ( m // i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ i ] * n <= m : <NEWLINE> <INDENT> a . append ( b [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if len ( b ) == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = list ( ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = Counter ( A ) <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> count [ c ] += k <NEWLINE> S += ( c - b ) * k <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
ans = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> ans . append ( <STRING> [ i ] + <STRING> + str ( j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> ans . remove ( a ) <NEWLINE> <NL> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , a : list , default : int ) : <NEWLINE> <INDENT> real_size = len ( a ) <NEWLINE> self . elem_size = 1 << math . ceil ( math . log2 ( real_size ) ) <NEWLINE> self . tree_size = 2 * self . elem_size <NEWLINE> self . tree = [ default ] * self . elem_size + a + [ default ] * ( self . elem_size - real_size ) <NEWLINE> self . lazy = [ None ] * self . tree_size <NEWLINE> self . init_tree ( ) <NEWLINE> <NL> <DEDENT> def init_tree ( self ) : <NEWLINE> <INDENT> tree = self . tree <NEWLINE> for i in range ( self . elem_size - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> left , right = tree [ i << 1 ] , tree [ ( i << 1 ) + 1 ] <NEWLINE> <COMMENT> <NL> tree [ i ] = left if left < right else right <NEWLINE> <NL> <DEDENT> <DEDENT> def get_indexes ( self , l : int , r : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> l , r , targets , path , p_l , p_r , = l + self . elem_size , r + self . elem_size , deque ( ) , deque ( ) , 0 , 0 <NEWLINE> t_ap , p_ap = targets . append , path . appendleft <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> t_ap ( l ) <NEWLINE> p_l = p_l or l >> 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> t_ap ( r ) <NEWLINE> p_r = p_r or r >> 1 <NEWLINE> <DEDENT> l , r = l >> 1 , r >> 1 <NEWLINE> <NL> <DEDENT> deepest = ( p_l , p_r ) <NEWLINE> <NL> while p_l > 1 or p_r > 1 : <NEWLINE> <INDENT> if p_l > 1 : <NEWLINE> <INDENT> p_ap ( p_l ) <NEWLINE> <DEDENT> if p_l != p_r > 1 : <NEWLINE> <INDENT> p_ap ( p_r ) <NEWLINE> <DEDENT> p_l >>= 1 <NEWLINE> p_r >>= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return targets , path , deepest <NEWLINE> <NL> <DEDENT> def propagate ( self , indexes : list , value : int = None ) : <NEWLINE> <INDENT> tree , lazy , elem_size = self . tree , self . lazy , self . elem_size <NEWLINE> if value is None : <NEWLINE> <INDENT> for n in indexes : <NEWLINE> <INDENT> if lazy [ n ] is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tree [ n ] = lazy [ n ] <NEWLINE> if n < elem_size : <NEWLINE> <INDENT> lazy [ n << 1 ] = lazy [ ( n << 1 ) + 1 ] = lazy [ n ] <NEWLINE> <DEDENT> lazy [ n ] = None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for n in indexes : <NEWLINE> <INDENT> if n < elem_size : <NEWLINE> <INDENT> lazy [ n << 1 ] = lazy [ ( n << 1 ) + 1 ] = value <NEWLINE> <DEDENT> tree [ n ] = value <NEWLINE> lazy [ n ] = None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get_indexes_with_propagation ( self , l : int , r : int , current_node : int , l_end : int , r_end : int ) : <NEWLINE> <COMMENT> <NL> <INDENT> indexes = [ ] <NEWLINE> tree , lazy = self . tree , self . lazy <NEWLINE> lazy_value , lazy [ current_node ] = lazy [ current_node ] , None <NEWLINE> left_child , right_child = current_node << 1 , ( current_node << 1 ) + 1 <NEWLINE> <NL> if lazy_value is not None : <NEWLINE> <INDENT> tree [ current_node ] = lazy_value <NEWLINE> if left_child < self . tree_size : <NEWLINE> <INDENT> lazy [ left_child ] = lazy [ right_child ] = lazy_value <NEWLINE> <NL> <DEDENT> <DEDENT> if l == l_end and r == r_end : <NEWLINE> <INDENT> return [ current_node ] <NEWLINE> <NL> <DEDENT> mid = ( l_end + r_end ) // 2 <NEWLINE> <NL> if l < mid : <NEWLINE> <INDENT> l_r = r if r < mid else mid <NEWLINE> indexes += self . get_indexes_with_propagation ( l , l_r , left_child , l_end , mid ) <NEWLINE> <DEDENT> if r > mid : <NEWLINE> <INDENT> r_l = l if mid < l else mid <NEWLINE> indexes += self . get_indexes_with_propagation ( r_l , r , right_child , mid , r_end ) <NEWLINE> <NL> <DEDENT> return indexes <NEWLINE> <NL> <DEDENT> def update_lazy ( self , l , r , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> targets , paths , deepest = self . get_indexes ( l , r ) <NEWLINE> self . propagate ( paths ) <NEWLINE> self . propagate ( targets , value ) <NEWLINE> self . update_tree ( deepest [ 0 ] ) <NEWLINE> self . update_tree ( deepest [ 1 ] ) <NEWLINE> <NL> <DEDENT> def get_value ( self , l : int , r : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> tree = self . tree <NEWLINE> targets , paths , deepest = self . get_indexes ( l , r ) <NEWLINE> self . propagate ( paths ) <NEWLINE> self . propagate ( targets ) <NEWLINE> self . update_tree ( deepest [ 0 ] ) <NEWLINE> self . update_tree ( deepest [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> return min ( tree [ n ] for n in targets ) <NEWLINE> <NL> <DEDENT> def update_tree ( self , k : int ) : <NEWLINE> <INDENT> tree , lazy = self . tree , self . lazy <NEWLINE> if k >= self . elem_size : <NEWLINE> <INDENT> k >>= 1 <NEWLINE> <NL> <DEDENT> while k > 0 : <NEWLINE> <INDENT> left , right = k << 1 , ( k << 1 ) + 1 <NEWLINE> if lazy [ k ] is None : <NEWLINE> <INDENT> if lazy [ left ] is not None : <NEWLINE> <INDENT> tree [ left ] = lazy [ left ] <NEWLINE> <DEDENT> if lazy [ right ] is not None : <NEWLINE> <INDENT> tree [ right ] = lazy [ right ] <NEWLINE> <DEDENT> tree [ k ] = tree [ left ] if tree [ left ] < tree [ right ] else tree [ right ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ left ] = tree [ right ] = tree [ k ] = lazy [ k ] <NEWLINE> lazy [ left ] = lazy [ right ] = lazy [ k ] = None <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> k >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def set_value ( self , i : int , value : int , op : str ) : <NEWLINE> <INDENT> k = self . elem_size + i <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> self . tree [ k ] = value <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> self . tree [ k ] += value <NEWLINE> <DEDENT> self . update_tree ( k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> rmq = SegmentTree ( [ 2 ** 31 - 1 ] * n , 2 ** 31 - 1 ) <NEWLINE> ans = [ ] <NEWLINE> append = ans . append <NEWLINE> for _ in [ 0 ] * q : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if l [ 0 ] == 0 : <NEWLINE> <INDENT> rmq . update_lazy ( l [ 1 ] , l [ 2 ] + 1 , l [ 3 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = rmq . get_value ( l [ 1 ] , l [ 2 ] + 1 ) <NEWLINE> <COMMENT> <NL> append ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( n ) for n in ans ] ) ) <NEWLINE>
import math <NEWLINE> def LCM ( a , b ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> return a * b // g <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( set ( A ) ) <NEWLINE> N = len ( A ) <NEWLINE> a0 = A [ 0 ] <NEWLINE> div = 1 <NEWLINE> while a0 % 2 == 0 : <NEWLINE> <INDENT> div *= 2 <NEWLINE> a0 //= 2 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i ] % div <NEWLINE> b = A [ i ] // div <NEWLINE> if ( b % 2 == 0 ) or ( a != 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] //= 2 <NEWLINE> <NL> <DEDENT> if N > 1 : <NEWLINE> <INDENT> lcm = LCM ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> lcm = LCM ( lcm , A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> lcm = A [ 0 ] <NEWLINE> <NL> <DEDENT> ans = M // lcm <NEWLINE> if ans % 2 == 1 : <NEWLINE> <INDENT> print ( ans // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans // 2 ) <NEWLINE> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> y . append ( i ** 5 ) <NEWLINE> <DEDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> for k in range ( j , 1000 ) : <NEWLINE> <INDENT> if y [ k ] + y [ j ] == x : <NEWLINE> <INDENT> a = k <NEWLINE> b = - j <NEWLINE> <DEDENT> if y [ k ] - y [ j ] == x : <NEWLINE> <INDENT> a = k <NEWLINE> b = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
T = input ( ) <NEWLINE> T = T . replace ( <STRING> , <STRING> ) <NEWLINE> print ( T ) <NEWLINE>
def f ( ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> i9 = 10 ** 9 <NEWLINE> if s == i9 ** 2 : <NEWLINE> <INDENT> print ( i9 , 0 , 0 , i9 , 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i9 - ( s % i9 ) , s // i9 + 1 , i9 , 1 , 0 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> f ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( str , input ( ) ) ) <NEWLINE> L = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ 0 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ 1 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = L [ 0 ] * L [ 1 ] * L [ 2 ] <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( int ( ( N - i - 1 ) / 2 ) ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + j + 1 ] and S [ i ] != S [ i + 2 * j + 2 ] and S [ i + j + 1 ] != S [ i + 2 * j + 2 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N , M = inpl ( ) <NEWLINE> H = inpl ( ) <NEWLINE> dp = [ True ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = inpl ( ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> dp [ B - 1 ] = False <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> dp [ A - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ A - 1 ] = False <NEWLINE> dp [ B - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in dp : <NEWLINE> <INDENT> if i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
import numpy as np <NEWLINE> <NL> ABN = np . array ( input ( ) . split ( <STRING> ) , dtype = np . int64 ) <NEWLINE> A = ABN [ 0 ] <NEWLINE> B = ABN [ 1 ] <NEWLINE> N = ABN [ 2 ] <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> calc = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> print ( calc ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <NL> <DEDENT> print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = dict ( ) <NEWLINE> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> cnt [ a ] = cnt . setdefault ( a , 0 ) + 1 <NEWLINE> cnt [ a - 1 ] = cnt . setdefault ( a - 1 , 0 ) + 1 <NEWLINE> cnt [ a + 1 ] = cnt . setdefault ( a + 1 , 0 ) + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> cnt_sort = sorted ( cnt . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> cnt_sort . reverse ( ) <NEWLINE> <NL> print ( cnt_sort [ 0 ] [ 1 ] ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k & 1 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif 7 % k == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m = 7 <NEWLINE> a = b = 1 <NEWLINE> while ( m > 0 ) : <NEWLINE> <INDENT> a = a * 10 % k <NEWLINE> m = ( m + 7 * a ) % k <NEWLINE> b += 1 <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> d_num = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( d_num + 1 ) ] <NEWLINE> for _ in range ( d_num ) : <NEWLINE> <INDENT> u , k , * neighbors = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> for v in neighbors : <NEWLINE> <INDENT> graph [ u ] . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited = set ( ) <NEWLINE> timestamps = [ None for _ in range ( d_num + 1 ) ] <NEWLINE> <NL> def dfs ( u , stmp ) : <NEWLINE> <INDENT> visited . add ( u ) <NEWLINE> entry = stmp <NEWLINE> <NL> stmp += 1 <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> if v not in visited : <NEWLINE> <INDENT> stmp = dfs ( v , stmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> timestamps [ u ] = entry , stmp <NEWLINE> return stmp + 1 <NEWLINE> <NL> <DEDENT> stmp = 1 <NEWLINE> for v in range ( 1 , d_num + 1 ) : <NEWLINE> <INDENT> if v not in visited : stmp = dfs ( v , stmp ) <NEWLINE> <NL> <DEDENT> for num , ( entry , leave ) in enumerate ( timestamps [ 1 : ] , 1 ) : <NEWLINE> <INDENT> print ( num , entry , leave ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> comb = set ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i == j or j == k or i == k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i + j + k == x : <NEWLINE> <INDENT> sort_9 = sorted ( ( i , j , k ) ) <NEWLINE> comb . add ( tuple ( sort_9 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( comb ) ) <NEWLINE> <NL> <DEDENT>
N , Q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> S = input ( ) <NEWLINE> <NL> cs = [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] + S [ i ] == <STRING> : <NEWLINE> <INDENT> cs . append ( cs [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cs . append ( cs [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l , r in ( [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( Q ) ) : <NEWLINE> <INDENT> print ( cs [ r - 1 ] - cs [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from queue import Queue <NEWLINE> <NL> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> root = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> check = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> check [ 1 ] = 1 <NEWLINE> <NL> q = Queue ( ) <NEWLINE> q . put ( 1 ) <NEWLINE> <NL> while ( not q . empty ( ) ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> for i in root [ now ] : <NEWLINE> <INDENT> if ( check [ i ] == 0 ) : <NEWLINE> <INDENT> check [ i ] = now <NEWLINE> q . put ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> flag = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if ( check [ i ] == 0 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( check [ j ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> mod = 2019 <NEWLINE> s = str ( input ( ) ) [ : : - 1 ] <NEWLINE> <NL> ssum = 0 <NEWLINE> d [ 0 ] = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> ssum = ( ssum + int ( s [ i ] ) * pow ( 10 , i , mod ) ) % mod <NEWLINE> d [ ssum ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n in d . values ( ) : <NEWLINE> <INDENT> ans += n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> suji = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> wa = sum ( suji ) <NEWLINE> goukei = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> goukei += suji [ i ] * ( wa - suji [ i ] ) <NEWLINE> wa -= suji [ i ] <NEWLINE> <NL> <DEDENT> print ( goukei % ( 10 ** 9 + 7 ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_after = 0 <NEWLINE> B_after = 0 <NEWLINE> <NL> if A - K >= 0 : <NEWLINE> <INDENT> A_after = A - K <NEWLINE> B_after = B <NEWLINE> <NL> <DEDENT> elif A + B - K >= 0 : <NEWLINE> <INDENT> B_after = B - ( K - A ) <NEWLINE> <NL> <DEDENT> print ( A_after , B_after ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul , add <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( abs ( A [ 1 ] - A [ 0 ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> t = list ( accumulate ( A , add ) ) <NEWLINE> r = list ( accumulate ( reversed ( A ) , add ) ) <NEWLINE> <NL> ans = INF <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( t [ i ] - r [ - 2 - i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> p = [ ] <NEWLINE> m = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= 0 : p . append ( i ) <NEWLINE> elif i < 0 : m . append ( i ) <NEWLINE> <NL> <DEDENT> p . sort ( reverse = True ) <NEWLINE> m . sort ( ) <NEWLINE> res = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> res = ( res * i ) % mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( p ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> res = ( res * m [ - ( i + 1 ) ] ) % mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> p_ind = 0 <NEWLINE> m_ind = 0 <NEWLINE> while k : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> res = ( res * p [ p_ind ] ) % mod <NEWLINE> break <NEWLINE> <NL> <DEDENT> temp = p [ p_ind ] * p [ p_ind + 1 ] if p_ind + 1 < len ( p ) else 0 <NEWLINE> temp1 = m [ m_ind ] * m [ m_ind + 1 ] if m_ind + 1 < len ( m ) else 0 <NEWLINE> if temp > temp1 : <NEWLINE> <INDENT> res = ( res * p [ p_ind ] ) % mod <NEWLINE> p_ind += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = ( res * temp1 ) % mod <NEWLINE> m_ind += 2 <NEWLINE> k -= 2 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = 1 <NEWLINE> <NL> for i in range ( len ( bin ( k ) ) - 2 ) : <NEWLINE> <INDENT> if ( k >> i ) & 1 : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> <DEDENT> A = [ A [ a - 1 ] for a in A ] <NEWLINE> <DEDENT> print ( now ) <NEWLINE>
<COMMENT> <NL> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> r = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> r . append ( r [ i - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> print ( min ( abs ( 2 * i - s ) for i in r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
class square ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> def draw ( self ) : <NEWLINE> <NL> <INDENT> for i in range ( 0 , self . x ) : <NEWLINE> <INDENT> for i in range ( 0 , self . y ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = square ( H , W ) <NEWLINE> s . draw ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += gcd ( a , z ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <NL> import heapq <NEWLINE> <NL> n , m , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> a = [ * map ( lambda x : - x , a ) ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> heapq . heappush ( a , - ( - heapq . heappop ( a ) >> 1 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> r = np . array ( range ( N ) ) <NEWLINE> X = r + A <NEWLINE> Y = r - A <NEWLINE> ans = 0 <NEWLINE> x_dic = { } <NEWLINE> y_dic = { } <NEWLINE> for x in X : <NEWLINE> <INDENT> if x in x_dic : <NEWLINE> <INDENT> x_dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_dic [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in Y : <NEWLINE> <INDENT> if y in y_dic : <NEWLINE> <INDENT> y_dic [ y ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y_dic [ y ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for x in x_dic : <NEWLINE> <INDENT> if x in y_dic : <NEWLINE> <INDENT> ans += x_dic [ x ] * y_dic [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = [ ] , [ ] , [ ] <NEWLINE> if n <= 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> for j in range ( len ( g ) ) : <NEWLINE> <INDENT> if ( r [ i ] + g [ j ] ) % 2 == 0 and s [ ( r [ i ] + g [ j ] ) // 2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( g ) ) : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if ( g [ i ] + b [ j ] ) % 2 == 0 and s [ ( g [ i ] + b [ j ] ) // 2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if ( r [ i ] + b [ j ] ) % 2 == 0 and s [ ( r [ i ] + b [ j ] ) // 2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> number = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> number *= i <NEWLINE> if number > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( number ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> roads = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( M ) ] <NEWLINE> roads2 = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for spots in roads : <NEWLINE> <INDENT> roads2 [ spots [ 0 ] - 1 ] . append ( spots [ 1 ] ) <NEWLINE> roads2 [ spots [ 1 ] - 1 ] . append ( spots [ 0 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for spot in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> good = True <NEWLINE> for i in roads2 [ spot - 1 ] : <NEWLINE> <INDENT> if H [ spot - 1 ] <= H [ i - 1 ] : <NEWLINE> <INDENT> good = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if good : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_ = 10 ** 18 <NEWLINE> <NL> if 0 in a_lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = a_lst [ 0 ] <NEWLINE> for a in a_lst [ 1 : ] : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > max_ : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : a += 1 <NEWLINE> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> ans = max ( ans , a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ARR = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ARR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def calculate ( n , m , arr ) : <NEWLINE> <INDENT> unionFind = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> unionFind . union ( startNode , endNode ) <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result = max ( result , unionFind . size ( i ) ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL> <DEDENT> calculate ( N , M , ARR ) <NEWLINE>
import numpy as np <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> t = np . arange ( 0 , 2000001 , 1 ) <NEWLINE> t = t ** 5 <NEWLINE> S = set ( t ) <NEWLINE> <NL> for B in range ( 0 , 200001 , 1 ) : <NEWLINE> <INDENT> if X + B ** 5 in S : <NEWLINE> <INDENT> print ( <STRING> % ( ( X + B ** 5 ) ** 0.2 , B ) ) <NEWLINE> break <NEWLINE> <DEDENT> if X - B ** 5 in S : <NEWLINE> <INDENT> print ( <STRING> % ( ( X - B ** 5 ) ** 0.2 , - B ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
array = [ ] <NEWLINE> x = input ( ) <NEWLINE> <NL> while x != <STRING> : <NEWLINE> <INDENT> array . append ( x ) <NEWLINE> x = input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) + <STRING> + array [ i ] ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> i = 1 <NEWLINE> while a > 0 and c > 0 : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> c -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> <DEDENT> i = 0 if i == 1 else 1 <NEWLINE> <NL> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ <STRING> ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : a . append ( i ) <NEWLINE> elif <STRING> in list ( str ( i ) ) : a . append ( i ) <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
from math import gcd <NEWLINE> <NL> A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N = 0 ; max_SW = A * 100 ; max_S = 0 <NEWLINE> f = F // 100 ; a = f // A ; b = f // B <NEWLINE> cn = D // gcd ( C , D ) <NEWLINE> <NL> for j in range ( b + 1 ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( a + 1 ) : <COMMENT> <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif A * i + B * j > f : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = ( A * i + B * j ) * 100 <COMMENT> <NEWLINE> e = ( A * i + B * j ) * E <COMMENT> <NEWLINE> S = min ( e , F - w ) <COMMENT> <NEWLINE> s = 0 <NEWLINE> for ci in range ( min ( S // C , cn ) + 1 ) : <NEWLINE> <INDENT> s = max ( s , S - ( S - C * ci ) % D ) <NEWLINE> <DEDENT> if s / ( w + s ) > N : <NEWLINE> <INDENT> N = s / ( w + s ) <NEWLINE> max_SW = s + w <NEWLINE> max_S = s <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_SW , max_S ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> x = 3.141592653589793238462643383279 <NEWLINE> print ( <STRING> . format ( r * r * x ) , <STRING> . format ( 2 * r * x ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( ) <NEWLINE> prev = 0 <NEWLINE> for i in v : <NEWLINE> <INDENT> if prev != i : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> prev = i <NEWLINE> <DEDENT> <DEDENT> n = len ( l ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = list ( ) <NEWLINE> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> d . append ( l [ 0 ] ) <NEWLINE> <DEDENT> if l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> d . append ( l [ 0 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if l [ i - 1 ] < l [ i ] and l [ i + 1 ] < l [ i ] : <NEWLINE> <INDENT> d . append ( l [ i ] ) <NEWLINE> <DEDENT> if l [ i - 1 ] > l [ i ] and l [ i + 1 ] > l [ i ] : <NEWLINE> <INDENT> d . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if l [ - 1 ] > l [ - 2 ] : <NEWLINE> <INDENT> d . append ( l [ - 1 ] ) <NEWLINE> <DEDENT> if l [ - 1 ] < l [ - 2 ] : <NEWLINE> <INDENT> d . append ( l [ - 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> n = len ( d ) <NEWLINE> p = 1000 <NEWLINE> if n > 1 : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> if d [ i - 1 ] < d [ i ] : <NEWLINE> <INDENT> z = ( p // d [ i - 1 ] ) * d [ i ] <NEWLINE> r = p % d [ i - 1 ] <NEWLINE> i += 2 <NEWLINE> if z + r > p : <NEWLINE> <INDENT> p = z + r <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> add = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> pp , xx = map ( int , input ( ) . split ( ) ) <NEWLINE> add [ pp - 1 ] += xx <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , p , value ) : <NEWLINE> <INDENT> value += add [ v ] <NEWLINE> ans [ v ] = value <NEWLINE> for c in ab [ v ] : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( c , v , value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = [ 0 ] * n <NEWLINE> dfs ( 0 , - 1 , 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> INF = 1 << 50 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = readInt ( ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a , b = readInt ( ) <NEWLINE> l . append ( a ) <NEWLINE> r . append ( b ) <NEWLINE> <DEDENT> dp = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpsum = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> lj = max ( 1 , i - r [ j ] ) <NEWLINE> rj = i - l [ j ] <NEWLINE> if rj < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += dpsum [ rj ] - dpsum [ lj - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> dpsum [ i ] = dpsum [ i - 1 ] + dp [ i ] <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def combination ( n , r , p ) : <NEWLINE> <INDENT> if r < 0 or r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return ( f [ n ] * f_inverse [ r ] * f_inverse [ n - r ] ) % p <NEWLINE> <NL> <DEDENT> f = [ 1 , 1 ] <COMMENT> <NEWLINE> f_inverse = [ 1 , 1 ] <COMMENT> <NEWLINE> n_inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> f . append ( ( f [ i - 1 ] * i ) % mod ) <NEWLINE> n_inverse . append ( ( - 1 * ( mod // i ) * n_inverse [ mod % i ] ) % mod ) <NEWLINE> f_inverse . append ( ( f_inverse [ i - 1 ] * n_inverse [ i ] ) % mod ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def pow_m ( k ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> return ( pow_m ( k // 2 ) ** 2 ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( m - 1 ) * ( pow_m ( k // 2 ) ** 2 ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> count += combination ( n - 1 , i , mod ) * m * pow_m ( n - 1 - i ) <COMMENT> <NEWLINE> count %= mod <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = Counter ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ c ] += b <NEWLINE> <NL> <DEDENT> A = sorted ( A . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for key , value in A : <NEWLINE> <INDENT> if N - value >= 0 : <NEWLINE> <INDENT> ans += key * value <NEWLINE> N -= value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += N * key <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> return ( gcd ( gcd ( a , b ) , c ) ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> print ( sum ( [ gcd3 ( a , b , c ) for a in range ( 1 , k + 1 ) <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) <NEWLINE> for c in range ( 1 , k + 1 ) ] ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( i + j ) <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LA = len ( A ) <NEWLINE> ans = A [ 0 ] <NEWLINE> for j in range ( LA ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( LA - 1 ) : <NEWLINE> <INDENT> ans = ans * A [ i + 1 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> C = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <COMMENT> <NEWLINE> <NL> E = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a - 1 ] . append ( b - 1 ) <NEWLINE> E [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( u , p = - 1 ) : <NEWLINE> <NL> <INDENT> color = C [ u ] <COMMENT> <NEWLINE> VC [ color ] . append ( u ) <COMMENT> <NEWLINE> <NL> s = 1 <COMMENT> <NEWLINE> for v in E [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> child [ u ] = 0 <COMMENT> <NEWLINE> ret = dfs ( v , u ) <NEWLINE> <NL> s += ret <COMMENT> <NEWLINE> child [ u ] += ret <COMMENT> <NEWLINE> <NL> ans [ color ] -= child [ u ] * ( child [ u ] + 1 ) // 2 <NEWLINE> <NL> <DEDENT> VC [ color ] . pop ( ) <NEWLINE> if VC [ color ] : <COMMENT> <NEWLINE> <INDENT> child [ VC [ color ] [ - 1 ] ] -= s <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> root_size [ color ] -= s <COMMENT> <NEWLINE> <NL> <DEDENT> return s <NEWLINE> <NL> <DEDENT> child = [ 0 ] * N <COMMENT> <NEWLINE> root_size = [ N ] * N <COMMENT> <NEWLINE> VC = [ [ ] for _ in range ( N ) ] <COMMENT> <NEWLINE> ans = [ N * ( N + 1 ) // 2 ] * N <COMMENT> <NEWLINE> <NL> dfs ( 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] - root_size [ i ] * ( root_size [ i ] + 1 ) // 2 ) <NEWLINE> <DEDENT>
na , nb , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ta = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tb = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> for i in range ( na ) : <NEWLINE> <INDENT> a . append ( a [ i ] + ta [ i ] ) <NEWLINE> <DEDENT> b = [ 0 ] <NEWLINE> for i in range ( nb ) : <NEWLINE> <INDENT> b . append ( b [ i ] + tb [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , nb <NEWLINE> for i in range ( na + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if a [ i ] + b [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from sklearn . utils . extmath import cartesian <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ls = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> arr = cartesian ( [ ls , ls , ls ] ) <NEWLINE> <NL> print ( np . gcd ( np . gcd ( arr [ : , 0 ] , arr [ : , 1 ] ) , arr [ : , 2 ] ) . sum ( ) ) <NEWLINE>
import collections <NEWLINE> A = input ( ) <NEWLINE> Ac = collections . Counter ( A ) <NEWLINE> cnt = 0 <NEWLINE> for val in Ac . values ( ) : <NEWLINE> <INDENT> cnt += val * ( val - 1 ) // 2 <NEWLINE> <DEDENT> print ( len ( A ) * ( len ( A ) - 1 ) // 2 - cnt + 1 ) <NEWLINE>
import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <COMMENT> <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <COMMENT> <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> n = ni ( ) <NEWLINE> a = sorted ( nl ( ) ) <NEWLINE> ans = 1 <NEWLINE> for ele in a : <NEWLINE> <INDENT> ans *= ele <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> result [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for v in result : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c *= A [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import collections as cl <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> dic = cl . Counter ( A ) <NEWLINE> <NL> l = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = dic . get ( b ) <NEWLINE> if x == None : <NEWLINE> <INDENT> l . append ( sum ) <NEWLINE> continue <NEWLINE> <DEDENT> if b < c : <NEWLINE> <INDENT> sum += ( c - b ) * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= ( b - c ) * x <NEWLINE> <DEDENT> l . append ( sum ) <NEWLINE> if c not in dic : <NEWLINE> <INDENT> dic [ c ] = dic . pop ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = dic . pop ( b ) + dic [ c ] <NEWLINE> <NL> <DEDENT> <DEDENT> for s in l : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> q = ii ( ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> <NL> m = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = mi ( ) <NEWLINE> <NL> if m [ b ] == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = m [ b ] <NEWLINE> <NL> s = s + ( c - b ) * count <NEWLINE> print ( s ) <NEWLINE> <NL> m [ c ] += count <NEWLINE> m [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // j <NEWLINE> ans += y * ( y + 1 ) * j / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> unko = A [ i ] <NEWLINE> if i + K < N : <NEWLINE> <INDENT> S = A [ i + K ] <NEWLINE> if S > unko : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> exit <NEWLINE> <DEDENT> <DEDENT>
def test ( N , A ) : <NEWLINE> <INDENT> B = 0 <NEWLINE> mx = A [ 0 ] <NEWLINE> if N != 1 : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] - mx < 0 : <NEWLINE> <INDENT> B = B + mx - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mx = A [ i ] ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return B <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = test ( N , A ) <NEWLINE> <NL> print ( B ) <NEWLINE>
s = input ( ) <NEWLINE> s_list = list ( s ) <NEWLINE> <NL> x = len ( s_list ) <NEWLINE> <NL> if s_list [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> s_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_list . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( s_list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sorted = sorted ( a ) <NEWLINE> divisible_list = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for j in range ( 0 , len ( divisible_list ) , a [ i ] ) : <NEWLINE> <INDENT> divisible_list [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if divisible_list [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> ACGT = { <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if set ( s [ i : j ] ) <= ACGT : <NEWLINE> <INDENT> ans = max ( ans , len ( s [ i : j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if ( j + ( j - i ) >= N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( ( S [ j + ( j - i ) ] != S [ i ] ) and ( S [ j + ( j - i ) ] != S [ j ] ) and ( S [ i ] != S [ j ] ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
def get_subordinate ( n , members ) : <NEWLINE> <INDENT> new_dict = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> new_dict [ i ] = 0 <NEWLINE> <NL> <DEDENT> for member in members : <NEWLINE> <INDENT> if member in new_dict : <NEWLINE> <INDENT> new_dict [ member ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * new_dict . values ( ) , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> members = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> get_subordinate ( n , members ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = ( h * 60 * 0.5 ) + ( m * 0.5 ) <NEWLINE> d = m * 6 <NEWLINE> <NL> if c > d : <NEWLINE> <INDENT> e = c - d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = d - c <NEWLINE> <NL> <DEDENT> ans = ( a * a ) + ( b * b ) - 2 * a * b * math . cos ( math . radians ( e ) ) <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE>
from copy import deepcopy <NEWLINE> from itertools import groupby <NEWLINE> import queue <NEWLINE> import sys <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , nums ) : <NEWLINE> <INDENT> self . labels = [ None ] + [ nums [ i ] for i in range ( 6 ) ] <NEWLINE> self . pos = { <NEWLINE> <INDENT> <STRING> : 3 , <NEWLINE> <STRING> : 4 , <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 5 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 6 <NEWLINE> <DEDENT> } <NEWLINE> <NL> <DEDENT> def rolled ( dice , queries ) : <NEWLINE> <INDENT> d = deepcopy ( dice ) <NEWLINE> for q in queries : <NEWLINE> <INDENT> if q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return d <NEWLINE> <NL> <DEDENT> <DEDENT> def isDiceSame ( d1 , d2 ) : <NEWLINE> <INDENT> if not isinstance ( d1 , Dice ) or not isinstance ( d2 , Dice ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if set ( d1 . labels [ 1 : ] ) != set ( d2 . labels [ 1 : ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> q = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> memo = [ [ False ] * 7 for i in range ( 7 ) ] <NEWLINE> memo [ d1 . pos [ <STRING> ] ] [ d1 . pos [ <STRING> ] ] = <STRING> <NEWLINE> res = { } <NEWLINE> for i in q [ : 3 ] : <NEWLINE> <INDENT> if d1 . labels [ d1 . pos [ i ] ] != d2 . labels [ d2 . pos [ i ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res [ memo [ d1 . pos [ <STRING> ] ] [ d1 . pos [ <STRING> ] ] ] = d1 <NEWLINE> <NL> <DEDENT> def bfs_isDiceSame ( ) : <NEWLINE> <INDENT> que = queue . Queue ( ) <NEWLINE> que . put ( d1 ) <NEWLINE> <NL> while not que . empty ( ) : <NEWLINE> <INDENT> d = que . get ( ) <NEWLINE> for i in q [ 1 : 5 ] : <NEWLINE> <INDENT> d_next = Dice . rolled ( d , i ) <NEWLINE> if memo [ d_next . pos [ <STRING> ] ] [ d_next . pos [ <STRING> ] ] == False : <NEWLINE> <INDENT> que . put ( d_next ) <NEWLINE> memo [ d_next . pos [ <STRING> ] ] [ d_next . pos [ <STRING> ] ] = memo [ d . pos [ <STRING> ] ] [ d . pos [ <STRING> ] ] + i <NEWLINE> for j in q [ : 3 ] : <NEWLINE> <INDENT> if d_next . labels [ d_next . pos [ j ] ] != d2 . labels [ d2 . pos [ j ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res [ memo [ d_next . pos [ <STRING> ] ] [ d_next . pos [ <STRING> ] ] ] = d_next <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs_isDiceSame ( ) <NEWLINE> if len ( res ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k , v in res . items ( ) : <NEWLINE> <INDENT> for i in q [ 3 : ] : <NEWLINE> <INDENT> if v . labels [ v . pos [ i ] ] != d2 . labels [ d2 . pos [ i ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> d_nums = [ tuple ( [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ] ) for _ in range ( n ) ] <NEWLINE> <NL> if len ( d_nums ) != len ( set ( d_nums ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> def var ( data ) : <NEWLINE> <INDENT> ava = sum ( data ) / len ( data ) <NEWLINE> return sum ( [ ( ava - data [ i ] ) ** 2 for i in range ( len ( data ) ) ] ) / len ( data ) <NEWLINE> <NL> <DEDENT> d_nums . sort ( key = lambda t : sum ( t ) ) <NEWLINE> d_nums . sort ( key = lambda t : var ( t ) ) <NEWLINE> for ( _ , g ) in groupby ( d_nums , key = lambda t : var ( t ) ) : <NEWLINE> <INDENT> gl = list ( g ) <NEWLINE> if len ( gl ) == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( gl ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( gl ) ) : <NEWLINE> <INDENT> if Dice . isDiceSame ( Dice ( gl [ i ] ) , Dice ( gl [ j ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> k = { } <NEWLINE> def y ( p ) : <NEWLINE> <INDENT> if p in k . keys ( ) : <NEWLINE> <INDENT> return k [ p ] <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k [ p ] = y ( p - 2 ) + y ( p - 1 ) <NEWLINE> return k [ p ] <NEWLINE> <DEDENT> <DEDENT> print ( y ( N ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> ans = 1000000000000 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if ( n % i == 0 ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = n // a <NEWLINE> a_keta = len ( str ( a ) ) <NEWLINE> b_keta = len ( str ( b ) ) <NEWLINE> m_keta = max ( a_keta , b_keta ) <NEWLINE> ans = min ( ans , m_keta ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> city = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> city . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> city . sort ( key = lambda city : ( city [ 0 ] , - city [ 1 ] ) ) <NEWLINE> <NL> for i in city : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += ( n // i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = n // k <NEWLINE> s += k * m * ( m + 1 ) // 2 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def dfs ( n ) : <NEWLINE> <INDENT> if n == 0 : return 0 <NEWLINE> return dfs ( n % format ( n , <STRING> ) . count ( <STRING> ) ) + 1 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> c = x . count ( <STRING> ) <NEWLINE> a = int ( x , 2 ) <NEWLINE> if c == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j , k = a % ( c + 1 ) , a % ( c - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : print ( dfs ( ( k - pow ( 2 , n - i - 1 , c - 1 ) ) % ( c - 1 ) ) + 1 ) <NEWLINE> else : print ( dfs ( ( j + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import copy <NEWLINE> <NL> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r - 1 ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r - 1 ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> tmp = A [ i ] <NEWLINE> A [ i ] = A [ j ] <NEWLINE> A [ j ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ r - 1 ] <NEWLINE> A [ r - 1 ] = tmp <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quicksort ( A , p , q ) <NEWLINE> quicksort ( A , q + 1 , r ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def babble_sort ( A , n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] [ 1 ] < A [ i ] [ 1 ] : <NEWLINE> <INDENT> tmp = A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ i ] <NEWLINE> A [ i ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def stable ( A , B ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] [ 0 ] != B [ i ] [ 0 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> A = [ [ x [ 0 ] , int ( x [ 1 ] ) ] for x in [ y . split ( ) for y in sys . stdin . read ( ) . split ( <STRING> ) [ : - 1 ] ] ] <NEWLINE> <NL> B = sorted ( copy . deepcopy ( A ) , key = lambda x : x [ 1 ] ) <NEWLINE> C = quicksort ( copy . deepcopy ( A ) , 0 , n ) <NEWLINE> <NL> if stable ( C , B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in C : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> c = [ 0 ] * n <NEWLINE> c [ 0 ] = 1 <NEWLINE> m = 0 <NEWLINE> while c [ b - 1 ] < 2 and k > 0 : <NEWLINE> <INDENT> b = a [ b - 1 ] <NEWLINE> c [ b - 1 ] += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> while c [ b - 1 ] < 3 and k > 0 : <NEWLINE> <INDENT> b = a [ b - 1 ] <NEWLINE> c [ b - 1 ] += 1 <NEWLINE> m += 1 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o = k % m <NEWLINE> for i in range ( o ) : <NEWLINE> <INDENT> b = a [ b - 1 ] <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> <NL> def dijkstra ( ) : <NEWLINE> <INDENT> g = n - 1 <NEWLINE> heap = [ ( - x , 0 , 0 ) ] <COMMENT> <NEWLINE> visited = [ float ( <STRING> ) ] * n <NEWLINE> while heap : <NEWLINE> <INDENT> est , cost , tree = heappop ( heap ) <NEWLINE> h = cost - est <NEWLINE> if tree == g : <NEWLINE> <INDENT> return cost + trees [ tree ] [ 0 ] - h <NEWLINE> <DEDENT> if visited [ tree ] <= est : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ tree ] = est <NEWLINE> for t , tree2 in trees [ tree ] [ 1 ] : <NEWLINE> <INDENT> ht = trees [ tree2 ] [ 0 ] <NEWLINE> if t > h : <NEWLINE> <INDENT> new_cost = cost + t + t - h <NEWLINE> new_h = 0 <NEWLINE> <DEDENT> elif h - t > ht : <NEWLINE> <INDENT> new_cost = cost + h - ht <NEWLINE> new_h = ht <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_cost = cost + t <NEWLINE> new_h = h - t <NEWLINE> <DEDENT> new_est = new_cost - new_h <NEWLINE> if visited [ tree2 ] >= new_est : <NEWLINE> <INDENT> heappush ( heap , ( new_est , new_cost , tree2 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> trees = [ [ int ( input ( ) ) , set ( ) ] for i in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if trees [ a ] [ 0 ] >= t : <NEWLINE> <INDENT> trees [ a ] [ 1 ] . add ( ( t , b ) ) <NEWLINE> <DEDENT> if trees [ b ] [ 0 ] >= t : <NEWLINE> <INDENT> trees [ b ] [ 1 ] . add ( ( t , a ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dijkstra ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S_ba = [ ] <NEWLINE> S_ab = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] < B [ i ] : S_ba . append ( B [ i ] - A [ i ] ) <NEWLINE> elif A [ i ] > B [ i ] : S_ab . append ( A [ i ] - B [ i ] ) <NEWLINE> <NL> <DEDENT> if sum ( S_ba ) > sum ( S_ab ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = len ( S_ba ) <NEWLINE> now = 0 <NEWLINE> rem = sum ( S_ba ) <NEWLINE> S_ab . sort ( reverse = True ) <NEWLINE> for i in range ( len ( S_ab ) ) : <NEWLINE> <INDENT> if rem <= now : break <NEWLINE> now += S_ab [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K % 2 == 1 : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT> elif K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> l [ a [ i ] - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( l [ j ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> sum_a = sum ( A ) <NEWLINE> sum_squares = sum ( [ a * a for a in A ] ) <NEWLINE> <NL> ans = ( sum_a ** 2 - sum_squares ) // 2 <NEWLINE> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
H = [ ] <NEWLINE> W = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> H . append ( h ) <NEWLINE> W . append ( w ) <NEWLINE> if H [ i ] == 0 and W [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if H [ i ] == 0 and W [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( H [ i ] ) : <NEWLINE> <INDENT> for k in range ( W [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
target = input ( ) <NEWLINE> list_abc = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> old = [ ] <NEWLINE> new = [ ] <NEWLINE> check = [ ] <NEWLINE> flag = False <NEWLINE> if <STRING> in target : <NEWLINE> <INDENT> old . append ( [ target , [ ] ] ) <NEWLINE> <DEDENT> while old != [ ] and flag == False : <NEWLINE> <INDENT> for i in old : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> check . append ( i [ 1 ] ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> for j in list_abc : <NEWLINE> <INDENT> element = i [ 0 ] . replace ( <STRING> , j ) <NEWLINE> if <STRING> in element : <NEWLINE> <INDENT> new . append ( [ element , i [ 1 ] + [ j ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> old = new [ : ] <NEWLINE> new = [ ] <NEWLINE> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in check : <NEWLINE> <INDENT> abc = <STRING> <NEWLINE> li = i <NEWLINE> li . reverse ( ) <NEWLINE> for j in li : <NEWLINE> <INDENT> abc = abc . replace ( j , <STRING> ) <NEWLINE> <DEDENT> if abc == target : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if flag == True else <STRING> ) <NEWLINE>
s = input ( ) ; a = [ ] ; b = [ 0 ] * 27 ; t = <STRING> <NEWLINE> for i in range ( len ( s ) ) : a . append ( ord ( s [ i ] ) ) ; b [ a [ i ] - 97 ] = 1 <NEWLINE> if s == <STRING> : print ( - 1 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( 27 ) : <NEWLINE> <INDENT> if b [ i ] == 0 : c = i ; break <NEWLINE> <DEDENT> if c != 26 : <NEWLINE> <INDENT> a . append ( c + 97 ) <NEWLINE> for i in range ( len ( a ) ) : t += chr ( a [ i ] ) <NEWLINE> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = [ ] <NEWLINE> for _ in range ( 24 ) : <NEWLINE> <INDENT> if a [ - 2 ] > a [ - 1 ] : d . append ( a . pop ( ) ) <NEWLINE> else : <NEWLINE> <INDENT> d . append ( a . pop ( ) ) ; d . sort ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : d . append ( a . pop ( ) ) ; d . sort ( ) <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if a [ - 1 ] < d [ i ] : a . pop ( ) ; a . append ( d [ i ] ) ; break <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : t += chr ( a [ i ] ) <NEWLINE> print ( t ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if b <= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( a * c , a * d , b * c , b * d ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> List = [ ( input ( ) ) for i in range ( a ) ] <NEWLINE> <NL> <NL> import collections <NEWLINE> <NL> c = collections . Counter ( List ) <NEWLINE> <NL> print ( len ( c ) ) <NEWLINE>
from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import product , combinations , permutations <NEWLINE> from copy import deepcopy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S_list = [ ] <NEWLINE> <NL> s_hash = dict ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S_list . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for s in S_list : <NEWLINE> <INDENT> if s not in s_hash : <NEWLINE> <INDENT> s_hash [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_hash [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> max_p = 0 <NEWLINE> max_p_name = [ ] <NEWLINE> for k , v in s_hash . items ( ) : <NEWLINE> <INDENT> if max_p < v : <NEWLINE> <INDENT> max_p_name = [ ] <NEWLINE> max_p = v <NEWLINE> <DEDENT> if max_p == v : <NEWLINE> <INDENT> max_p_name . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> for p in sorted ( max_p_name ) : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( 1000 - n % 1000 ) % 1000 ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2019 <NEWLINE> <NL> for i in range ( l , min ( l + 2019 , r ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( l + 2019 , r + 1 ) ) : <NEWLINE> <INDENT> a = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ 0 ] * m <NEWLINE> skill = np . array ( [ b ] ) <NEWLINE> ans = [ ] <NEWLINE> money = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in itertools . combinations ( range ( 1 , n + 1 ) , i ) : <NEWLINE> <INDENT> for k in range ( len ( j ) ) : <NEWLINE> <INDENT> money += a [ j [ k ] - 1 ] [ 0 ] <NEWLINE> skill += np . array ( [ a [ j [ k ] - 1 ] [ 1 : m + 1 ] ] ) <NEWLINE> <DEDENT> if all ( [ i >= x for i in skill [ 0 ] ] ) : <NEWLINE> <INDENT> ans . append ( money ) <NEWLINE> <DEDENT> money = 0 <NEWLINE> skill = np . array ( [ b ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( ( N - 1 ) * N // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> B = deque ( [ ] ) <NEWLINE> <NL> rev = False <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if not rev : <NEWLINE> <INDENT> B . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . appendleft ( A [ i ] ) <NEWLINE> <DEDENT> rev ^= True <NEWLINE> <NL> <DEDENT> if rev : <NEWLINE> <INDENT> B = list ( B ) [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( * B ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> y = min ( b - 1 , n ) <NEWLINE> ans = a * y // b - y // b * a <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> M = [ 0 ] <NEWLINE> mod = 2019 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = ( M [ - 1 ] + int ( s [ n - 1 - i ] ) % mod * pow ( 10 , i , mod ) ) % mod <NEWLINE> M . append ( m ) <NEWLINE> <DEDENT> MC = Counter ( M ) <NEWLINE> r = 0 <NEWLINE> for v in MC . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> r += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> o = B - A <NEWLINE> e = A - B <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> r = e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = o <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = in_n ( ) <NEWLINE> A = list ( in_nn ( ) ) <NEWLINE> Q = in_n ( ) <NEWLINE> t = in_na ( ) <NEWLINE> BC = list ( zip ( t , t ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> s += k * v <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = BC [ i ] <NEWLINE> s += d [ b ] * ( c - b ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d . pop ( b ) <NEWLINE> <NL> print ( s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ - 1 ] * n <NEWLINE> now = 0 <NEWLINE> order = 0 <NEWLINE> l [ 0 ] = 0 <NEWLINE> s = { } <NEWLINE> ans = - 100 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <NL> <DEDENT> while k > 0 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> now = a [ now ] <NEWLINE> order += 1 <NEWLINE> if l [ now ] != - 1 : <COMMENT> <NEWLINE> <INDENT> loop = order - l [ now ] <NEWLINE> k %= loop <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> ans = now + 1 <NEWLINE> break <NEWLINE> <DEDENT> l [ now ] = order <COMMENT> <NEWLINE> <NL> <DEDENT> print ( max ( ans , - 1 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> lis = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mozi = input ( ) <NEWLINE> lis [ i ] = mozi <NEWLINE> <DEDENT> print ( len ( set ( lis ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = ri ( ) <NEWLINE> a = rl ( ) <NEWLINE> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> ans = ( ans + s * i ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nn = lambda : list ( stdin . readline ( ) . split ( ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n , m , k = na ( ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> <NL> fact = [ 0 ] * 220000 <NEWLINE> invfact = [ 0 ] * 220000 <NEWLINE> <NL> fact [ 0 ] = 1 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % mod <NEWLINE> <NL> <DEDENT> invfact [ 220000 - 1 ] = pow ( fact [ 220000 - 1 ] , mod - 2 , mod ) <NEWLINE> <NL> for i in range ( 220000 - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> invfact [ i ] = invfact [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> def nCk ( n , k ) : <NEWLINE> <INDENT> if k < 0 or n < k : return 0 <NEWLINE> return fact [ n ] * invfact [ k ] * invfact [ n - k ] % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += pow ( m - 1 , n - i - 1 , mod ) * nCk ( n - 1 , i ) <NEWLINE> <NL> <DEDENT> print ( ans * m % mod ) <NEWLINE>
<NL> <NL> L = [ ] <NEWLINE> L . append ( input ( ) ) <NEWLINE> <NL> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif L [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif L [ 0 ] == <STRING> or L [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif L [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif L [ 0 ] == <STRING> or L [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif L [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
def ndt ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( sum ( ndt ( N - 1 ) ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H . insert ( 0 , 0 ) <NEWLINE> A = [ 0 ] * ( M ) <NEWLINE> B = [ 0 ] * ( M ) <NEWLINE> TOP = [ 0 ] * len ( H ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for index in range ( M ) : <NEWLINE> <INDENT> A [ index ] , B [ index ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for jn in range ( M ) : <NEWLINE> <INDENT> if H [ A [ jn ] ] <= H [ B [ jn ] ] : <NEWLINE> <INDENT> TOP [ A [ jn ] ] = 1 <NEWLINE> <DEDENT> if H [ B [ jn ] ] <= H [ A [ jn ] ] : <NEWLINE> <INDENT> TOP [ B [ jn ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = TOP . count ( 0 ) - 1 <NEWLINE> <NL> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> N , K = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> queries = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> queries . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> temp_que = [ ] <NEWLINE> for num , val in queries : <NEWLINE> <INDENT> temp_que = num <NEWLINE> K -= val <NEWLINE> if K <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( temp_que ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> graph [ int ( input ( ) ) - 1 ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( x ) : <NEWLINE> <INDENT> arr = [ dfs ( y ) for y in graph [ x ] ] <NEWLINE> if not ( arr ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> arr . sort ( reverse = True ) <NEWLINE> return max ( i + a for i , a in enumerate ( arr , 1 ) ) <NEWLINE> <NL> <DEDENT> print ( dfs ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> f = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if f <= n : <NEWLINE> <INDENT> ans [ f ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
data_num = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> deff_price = - 999999999 <NEWLINE> min_price = 0 <NEWLINE> tmp_price = 0 <NEWLINE> <NL> for i in range ( data_num ) : <NEWLINE> <INDENT> price = int ( input ( ) ) <NEWLINE> <NL> if i == 0 : <NEWLINE> <INDENT> min_price = price <NEWLINE> <DEDENT> elif price - min_price > deff_price : <NEWLINE> <INDENT> deff_price = price - min_price <NEWLINE> <NL> <DEDENT> if price < min_price : <NEWLINE> <INDENT> min_price = price <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( deff_price ) ) <NEWLINE>
import collections <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def com ( n , r ) : <NEWLINE> <INDENT> if n > 1 : <NEWLINE> <INDENT> ann = math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ann = 0 <NEWLINE> <DEDENT> return ann <NEWLINE> <NL> <DEDENT> b = collections . Counter ( a ) <NEWLINE> ans = [ ] <NEWLINE> for i in b : <NEWLINE> <INDENT> ans . append ( com ( b [ i ] , 2 ) ) <NEWLINE> <DEDENT> anss = sum ( ans ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t = b [ a [ i ] ] <NEWLINE> print ( anss - ( t - 1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def sum_of ( num ) : <NEWLINE> <INDENT> list_b = [ ] <NEWLINE> k = 0 <NEWLINE> while num > 0 : <NEWLINE> <INDENT> list_b . append ( num % 10 ) <NEWLINE> num //= 10 <NEWLINE> <DEDENT> for i in range ( len ( list_b ) ) : <NEWLINE> <INDENT> k += list_b [ i ] <NEWLINE> <DEDENT> return k <NEWLINE> <NL> <DEDENT> list_a = [ ] <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( str ( 2 ) ) <NEWLINE> <DEDENT> if N == 3 : <NEWLINE> <INDENT> print ( str ( 3 ) ) <NEWLINE> <DEDENT> if N >= 4 : <NEWLINE> <INDENT> for i in range ( 2 , N - 1 ) : <NEWLINE> <INDENT> A = i <NEWLINE> B = N - i <NEWLINE> list_a . append ( sum_of ( A ) + sum_of ( B ) ) <NEWLINE> <DEDENT> print ( min ( list_a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> min1 = 10000000000 <NEWLINE> max1 = - 10000000000 <NEWLINE> min2 = 10000000000 <NEWLINE> max2 = - 10000000000 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x + y > max1 : <NEWLINE> <INDENT> r1 = [ x , y ] <NEWLINE> max1 = x + y <NEWLINE> <DEDENT> if x + y < min1 : <NEWLINE> <INDENT> l1 = [ x , y ] <NEWLINE> min1 = x + y <NEWLINE> <DEDENT> if x - y > max2 : <NEWLINE> <INDENT> r2 = [ x , y ] <NEWLINE> max2 = x - y <NEWLINE> <DEDENT> if x - y < min2 : <NEWLINE> <INDENT> l2 = [ x , y ] <NEWLINE> min2 = x - y <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( max ( max1 - min1 , max2 - min2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 1 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> r = r * l [ x ] <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ False ] * ( 2 * 10 ** 5 + 10 ) <NEWLINE> val = 1 <NEWLINE> count = 0 <NEWLINE> hold = k <NEWLINE> while hold > 0 : <NEWLINE> <INDENT> if visited [ val - 1 ] or val == t [ val - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited [ val - 1 ] = True <NEWLINE> val = t [ val - 1 ] <NEWLINE> <COMMENT> <NL> count += 1 <NEWLINE> hold -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if hold == 0 : <NEWLINE> <INDENT> print ( val ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if val == t [ val - 1 ] : <NEWLINE> <INDENT> print ( val ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> count0 = count <NEWLINE> count = 1 <NEWLINE> newval = val <NEWLINE> start = t [ newval - 1 ] <NEWLINE> while start != newval : <NEWLINE> <INDENT> count += 1 <NEWLINE> start = t [ start - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> if t [ val - 1 ] == t [ 0 ] : <NEWLINE> <INDENT> temp = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = k - count0 <NEWLINE> <COMMENT> <NL> <DEDENT> jump = ( temp ) % ( count ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = val <NEWLINE> for i in range ( jump ) : <NEWLINE> <INDENT> ans = t [ ans - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin , setrecursionlimit <NEWLINE> input = stdin . readline <NEWLINE> setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parent = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if self . parent [ x ] < self . parent [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> total_unite_island = self . parent [ x ] * self . parent [ y ] <NEWLINE> self . parent [ x ] += self . parent [ y ] <NEWLINE> self . parent [ y ] = x <NEWLINE> return total_unite_island <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M ; B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> uf = Unionfind ( N ) <NEWLINE> inconvenience = N * ( N - 1 ) // 2 <NEWLINE> inconvenience_list = [ 0 ] * M <NEWLINE> inconvenience_list [ M - 1 ] = inconvenience <NEWLINE> for i in range ( M - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> inconvenience -= uf . union ( A [ i ] , B [ i ] ) <NEWLINE> inconvenience_list [ i - 1 ] = inconvenience <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( inconvenience_list [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> linked_list = deque ( [ ] ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> <NL> if <STRING> in command : <NEWLINE> <INDENT> x = command . split ( ) [ - 1 ] <NEWLINE> linked_list . appendleft ( x ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> linked_list . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> linked_list . pop ( ) <NEWLINE> <DEDENT> elif <STRING> in command : <NEWLINE> <INDENT> x = command . split ( ) [ - 1 ] <NEWLINE> if x in linked_list : <NEWLINE> <INDENT> linked_list . remove ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * linked_list ) <NEWLINE> <NL>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> INF = 10 ** 18 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> if i * j < n : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if j * j < n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> s = input ( ) . split ( <STRING> ) <NEWLINE> n = list ( map ( float , s ) ) <NEWLINE> d = math . sqrt ( ( n [ 0 ] - n [ 2 ] ) ** 2 + ( n [ 1 ] - n [ 3 ] ) ** 2 ) <NEWLINE> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> S = { } <NEWLINE> maxr = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in S : <NEWLINE> <INDENT> S [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> maxc = max ( S . values ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if S [ s ] == maxc : <NEWLINE> <INDENT> ans . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> for s in ans : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> C = [ [ sum ( [ A [ i ] [ k ] * B [ k ] [ j ] for k in range ( m ) ] ) for j in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for row in C : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , row ) ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> counter = collections . Counter ( al ) <NEWLINE> <NL> total = 0 <NEWLINE> for ( v , c ) in counter . most_common ( ) : <NEWLINE> <INDENT> total += v * c <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> count = counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> counter [ c ] += count <NEWLINE> total = total + ( c - b ) * count <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bridge = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bridge [ a - 1 ] . append ( b - 1 ) <NEWLINE> bridge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> queue = deque ( [ 0 ] ) <NEWLINE> ans = [ [ ] for i in range ( n ) ] <NEWLINE> ans [ 0 ] . append ( <STRING> ) <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> for factor in bridge [ now ] : <NEWLINE> <INDENT> if not ( ans [ factor ] ) : <NEWLINE> <INDENT> ans [ factor ] . append ( now ) <NEWLINE> queue . append ( factor ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] [ 0 ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> l = { } <NEWLINE> for _a in a : <NEWLINE> <INDENT> if _a in l : <NEWLINE> <INDENT> l . pop ( _a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . update ( <NEWLINE> <INDENT> { _a : True } <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sorted ( h , reverse = True ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> q = sum ( m [ k : n ] ) <NEWLINE> print ( q ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> if ( n < 4 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( s [ i ] == s [ j ] or s [ i ] == s [ k ] or s [ j ] == s [ k ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys , math <NEWLINE> from itertools import permutations , combinations <NEWLINE> from collections import defaultdict , Counter , deque <NEWLINE> from math import factorial , gcd <NEWLINE> from bisect import bisect_left <COMMENT> <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> enu = enumerate <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> def input ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> pl = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> AB = np . array ( AB ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> tAB = AB . T <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> A = tAB [ 0 ] <NEWLINE> B = tAB [ 1 ] <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> midA1 = A [ N // 2 - 1 ] <NEWLINE> midA2 = A [ N // 2 ] <NEWLINE> midB1 = B [ N // 2 - 1 ] <NEWLINE> midB2 = B [ N // 2 ] <NEWLINE> <NL> midmidA = ( midA1 + midA2 ) / 2 <NEWLINE> midmidB = ( midB1 + midB2 ) / 2 <NEWLINE> res = int ( ( midmidB - midmidA ) / ( 0.5 ) + 1 ) <NEWLINE> print ( res ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> midA = A [ N // 2 ] <NEWLINE> midB = B [ N // 2 ] <NEWLINE> print ( midB - midA + 1 ) <NEWLINE> <DEDENT>
from bisect import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> * B , = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> b = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + A [ i ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + B [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> tmp = K - a [ i ] <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + bisect ( b , tmp ) - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> mxCost = 0 <NEWLINE> <NL> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> fr , to , cost , dist = map ( int , input ( ) . split ( ) ) <NEWLINE> mxCost = max ( mxCost , cost ) <NEWLINE> fr -= 1 <NEWLINE> to -= 1 <NEWLINE> edges [ fr ] . append ( ( to , dist , cost ) ) <NEWLINE> edges [ to ] . append ( ( fr , dist , cost ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ i ] . append ( ( i , D , - C ) ) <NEWLINE> <NL> <DEDENT> que = [ ( 0 , S , 0 ) ] <NEWLINE> mxCost *= ( N - 1 ) <NEWLINE> minDsit = [ [ 10 ** 18 ] * ( mxCost + 1 ) for _ in range ( N ) ] <NEWLINE> minDsit [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> dist , s , now = heappop ( que ) <NEWLINE> <NL> for to , d , c in edges [ now ] : <NEWLINE> <INDENT> cost = min ( mxCost , s - c ) <NEWLINE> if cost < 0 or minDsit [ to ] [ cost ] <= dist + d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> minDsit [ to ] [ cost ] = dist + d <NEWLINE> heappush ( que , ( dist + d , cost , to ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for dist in minDsit [ 1 : ] : <NEWLINE> <INDENT> print ( min ( dist ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Asum . append ( Asum [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> Bsum = [ 0 ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> Bsum . append ( Bsum [ j ] + B [ j ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if Asum [ i ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp = K - Asum [ i ] <NEWLINE> j = bisect . bisect_right ( Bsum , tmp ) - 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
def s ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) + 1 <NEWLINE> e = [ input ( ) . split ( ) for _ in [ 0 ] * ~ - n ] <NEWLINE> p = [ int ( e [ 0 ] [ 0 ] ) ] + list ( int ( x [ 1 ] ) for x in e ) <NEWLINE> m = [ [ 0 ] * n for _ in [ 0 ] * n ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for r in range ( n - i - 1 ) : <NEWLINE> <INDENT> c = r + i + 1 <NEWLINE> for j in range ( r + 1 , c ) : <NEWLINE> <INDENT> x = m [ r ] [ j ] + m [ j ] [ c ] + p [ r ] * p [ j ] * p [ c ] <NEWLINE> if 1 > m [ r ] [ c ] or m [ r ] [ c ] > x : m [ r ] [ c ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m [ r ] [ c ] ) <NEWLINE> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> x += 1 & j >> i <NEWLINE> <NL> <DEDENT> tmp = x * ( N - x ) % m <NEWLINE> tmp *= 2 ** i % m <NEWLINE> ans += tmp <NEWLINE> ans %= m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> cnti = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while ( j >= 0 and A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnti += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnti <NEWLINE> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ 1 ] <NEWLINE> h = 1 <NEWLINE> for k in range ( int ( n ** 0.33333333 ) + 1 ) : <NEWLINE> <INDENT> h = 3 * h + 1 <NEWLINE> if ( h <= n and len ( G ) < 100 ) : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> <DEDENT> elif ( len ( G ) == 100 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> G . reverse ( ) <NEWLINE> m = len ( G ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertionSort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( i == m - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( G [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( G [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> nlist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> nlist . append ( x ) <NEWLINE> <NL> <DEDENT> c = shellSort ( nlist , n ) <NEWLINE> print ( ) <NEWLINE> print ( c ) <NEWLINE> for i in nlist : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import fileinput <NEWLINE> <NL> for line in fileinput . input ( ) : <NEWLINE> <INDENT> tokens = list ( map ( int , line . strip ( ) . split ( ) ) ) <NEWLINE> a , b = tokens [ 0 ] , tokens [ 1 ] <NEWLINE> d = a * b <NEWLINE> if a < b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <NL> <DEDENT> c = a % b <NEWLINE> while ( c != 0 ) : <NEWLINE> <INDENT> a = b <NEWLINE> b = c <NEWLINE> c = a % b <NEWLINE> <NL> <DEDENT> g = b <NEWLINE> l = d / g <NEWLINE> <NL> print ( str ( g ) + <STRING> + str ( int ( l ) ) ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect_left ( L , L [ i ] + L [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> b = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> ans = a * x // b - a * ( x // b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> L = abs ( S . count ( <STRING> ) - S . count ( <STRING> ) ) <NEWLINE> <NL> print ( N - L ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ls = sorted ( ls ) <NEWLINE> d = 10 ** 3 <NEWLINE> ans = 0 <NEWLINE> for i in range ( ls [ 0 ] - 1 , ls [ - 1 ] + 2 ) : <NEWLINE> <INDENT> if i in ls : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d > abs ( i - x ) : <NEWLINE> <INDENT> d = abs ( i - x ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> goukei = 1 <NEWLINE> ok = 0 <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in arr : <NEWLINE> <INDENT> goukei *= int ( i ) <NEWLINE> if goukei > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> ok = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok == 0 : <NEWLINE> <INDENT> print ( goukei ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> S = <STRING> <NEWLINE> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += S [ N % 26 ] <NEWLINE> N //= 26 <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> absX = abs ( X ) <NEWLINE> t = abs ( X // D ) <NEWLINE> remain_K = K - t <NEWLINE> l = X % D <NEWLINE> if remain_K < 0 : <NEWLINE> <INDENT> a = abs ( X - ( K * D ) ) <NEWLINE> b = abs ( X + ( K * D ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if remain_K % 2 == 0 : <NEWLINE> <INDENT> a = abs ( l - ( D * 2 ) ) <NEWLINE> b = abs ( l + ( D * 2 ) ) <NEWLINE> if a < b and a < l : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> elif a > b and b < l : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = l <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = abs ( l - D ) <NEWLINE> b = abs ( l + D ) <NEWLINE> if a < b : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <DEDENT> print ( len ( np . unique ( S ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> List = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> res = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S == List [ i ] : <NEWLINE> <INDENT> res = i + 1 <NEWLINE> <DEDENT> <DEDENT> if res == 3 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> print ( List [ res ] ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = <STRING> + input ( ) <NEWLINE> <NL> <NL> rgb_count = [ [ 0 for i in range ( 3 ) ] for j in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> rgb_count [ 1 ] [ 0 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> rgb_count [ 1 ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rgb_count [ 1 ] [ 2 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dict = { <STRING> : 1 , <STRING> : 2 , <STRING> : 4 } <NEWLINE> d = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> dic = { <STRING> : [ 1 , 2 ] , <STRING> : [ 0 , 2 ] , <STRING> : [ 0 , 1 ] } <NEWLINE> ret = rgb_count [ 1 ] [ 0 ] * rgb_count [ 1 ] [ 1 ] * rgb_count [ 1 ] [ 2 ] <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> ran = min ( [ i - 1 , N - i ] ) <NEWLINE> if ran < 1 : continue <NEWLINE> for k in range ( 1 , ran + 1 ) : <NEWLINE> <INDENT> if dict [ S [ i - k ] ] + dict [ S [ i ] ] + dict [ S [ i + k ] ] == 7 : <NEWLINE> <INDENT> ret -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> history = [ - 1 ] * n <NEWLINE> cur = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if history [ cur ] != - 1 : <NEWLINE> <INDENT> init_cnt = history [ cur ] <NEWLINE> loop_cnt = i - history [ cur ] <NEWLINE> break <NEWLINE> <DEDENT> history [ cur ] = i <NEWLINE> cur = A [ cur ] <NEWLINE> <NL> <DEDENT> loop = k if k <= init_cnt else init_cnt + ( ( k - init_cnt ) % loop_cnt ) <NEWLINE> print ( history . index ( loop ) + 1 ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_pos = [ a [ i ] + i for i in range ( 1 , n + 1 ) ] <NEWLINE> a_neg = [ - a [ i ] + i for i in range ( 1 , n + 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> c_pos = collections . Counter ( a_pos ) <NEWLINE> c_neg = collections . Counter ( a_neg ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for c in c_pos : <NEWLINE> <INDENT> ans += c_pos [ c ] * c_neg [ c ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> _ = int ( input ( ) ) <NEWLINE> lst = [ 0 for _ in [ 0 ] * ( 10 ** 5 + 1 ) ] <NEWLINE> sum_lst = 0 <NEWLINE> for a in [ int ( x ) for x in input ( ) . split ( ) ] : <NEWLINE> <INDENT> sum_lst += a <NEWLINE> lst [ a ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum_lst += ( C - B ) * lst [ B ] <NEWLINE> print ( sum_lst ) <NEWLINE> lst [ C ] += lst [ B ] <NEWLINE> lst [ B ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> zero_cnt = 0 <NEWLINE> L = defaultdict ( int ) <NEWLINE> L2 = defaultdict ( int ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> zero_cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> d = math . gcd ( x , y ) <NEWLINE> x //= d <NEWLINE> y //= d <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> zero_cnt += 1 <NEWLINE> <DEDENT> if y < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> y *= - 1 <NEWLINE> <DEDENT> elif ｙ == 0 and ｘ < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> y *= - 1 <NEWLINE> <DEDENT> rot90 = ( x <= 0 ) <NEWLINE> if rot90 : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = - tmp <NEWLINE> <DEDENT> if rot90 : <NEWLINE> <INDENT> L [ ( x , y ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L2 [ ( x , y ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> keys = set ( list ( L . keys ( ) ) + list ( L2 . keys ( ) ) ) <NEWLINE> for k in keys : <NEWLINE> <INDENT> now = 1 <NEWLINE> s = L [ k ] <NEWLINE> t = L2 [ k ] <NEWLINE> now += pow ( 2 , s , MOD ) - 1 <NEWLINE> now += pow ( 2 , t , MOD ) - 1 <NEWLINE> ans *= now <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> ans += zero_cnt <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , M , Q = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> pattern_list = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> pattern = tuple ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> pattern_list . append ( pattern ) <NEWLINE> <NL> <DEDENT> def create ( N , M ) : <NEWLINE> <INDENT> S = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for m in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> S [ 1 ] . append ( [ m ] ) <NEWLINE> <DEDENT> for n in range ( 1 , N ) : <NEWLINE> <INDENT> for s in S [ n ] : <NEWLINE> <INDENT> Max = s [ - 1 ] <NEWLINE> for i in range ( Max , M + 1 ) : <NEWLINE> <INDENT> S [ n + 1 ] . append ( s + [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return S <NEWLINE> <NL> <DEDENT> highest = 0 <NEWLINE> for letters in create ( N , M ) [ N ] : <NEWLINE> <INDENT> point = 0 <NEWLINE> for a , b , c , d in pattern_list : <NEWLINE> <INDENT> if c == letters [ b - 1 ] - letters [ a - 1 ] : <NEWLINE> <INDENT> point += d <NEWLINE> <DEDENT> <DEDENT> highest = max ( [ highest , point ] ) <NEWLINE> <NL> <DEDENT> print ( highest ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> print ( S // 3600 , ( S % 3600 ) // 60 , S % 60 , sep = <STRING> ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> sum = sum ( a ) % MOD <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> sum -= a [ i ] <NEWLINE> sum %= MOD <NEWLINE> ans += a [ i ] * sum <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> line = readline ( ) . split ( ) <NEWLINE> R = { } <NEWLINE> L = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r = int ( line [ i ] ) + i + 1 <NEWLINE> l = i + 1 - int ( line [ i ] ) <NEWLINE> if r in R : <NEWLINE> <INDENT> R [ r ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ r ] = 1 <NEWLINE> <DEDENT> if l in L : <NEWLINE> <INDENT> L [ l ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ l ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in R : <NEWLINE> <INDENT> if i in L : <NEWLINE> <INDENT> cnt += R [ i ] * L [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = n // ( a + b ) * a <NEWLINE> rem = n % ( a + b ) <NEWLINE> print ( ans + min ( rem , a ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> def divisor_count ( n : int ) -> int : <NEWLINE> <INDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i != n // i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> if divisor_count ( n ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( a ) <NEWLINE> c = 0 <NEWLINE> for v in range ( n - 1 ) : <NEWLINE> <INDENT> b -= a [ v ] <NEWLINE> c += a [ v ] * b <NEWLINE> <DEDENT> print ( c % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from decimal import * <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , k , m , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> setcontext ( Context ( prec = r , rounding = ROUND_HALF_UP ) ) <NEWLINE> one = Decimal ( 1 ) <NEWLINE> <NL> ans = one / Decimal ( n ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( 1 , n ) : s += one / Decimal ( i ) <NEWLINE> ans *= 1 + s <NEWLINE> <DEDENT> ans = str ( ans ) [ : r + 2 ] <NEWLINE> if len ( ans ) < r + 2 : ans += <STRING> * ( r + 2 - len ( ans ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum , bsum = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k < a [ i ] + asum [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> asum . append ( a [ i ] + asum [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if k < b [ i ] + bsum [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> bsum . append ( b [ i ] + bsum [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( asum ) ) : <NEWLINE> <INDENT> tmp = i + bisect . bisect ( bsum , k - asum [ i ] ) - 1 <NEWLINE> if ans < tmp : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
( n , _ ) , * s = [ [ * map ( int , t . split ( ) ) ] for t in open ( 0 ) ] <NEWLINE> d = [ 1 , - 1 ] + [ 0 ] * 2 * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] = ( d [ i - 1 ] + d [ i ] ) % 998244353 <NEWLINE> for l , r in s : <NEWLINE> <INDENT> d [ i + l ] += d [ i ] <NEWLINE> d [ i - ~ r ] -= d [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( d [ n - 1 ] ) <NEWLINE>
b = False <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dataset = [ ] <NEWLINE> if b : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> b = True <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> name , w , l , d = input ( ) . split ( ) <NEWLINE> dataset . append ( ( name , 3 * int ( w ) + int ( d ) , n - len ( dataset ) ) ) <NEWLINE> <DEDENT> for name , score , _ in sorted ( dataset , key = lambda x : ( x [ 1 ] , x [ 2 ] ) ) [ : : - 1 ] : <NEWLINE> <INDENT> print ( name + <STRING> + str ( score ) ) <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n [ 1 ] , n [ 0 ] ) : <NEWLINE> <INDENT> if a [ i - n [ 1 ] ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for x in range ( 2 * ( 10 ** 5 ) ) ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans [ ( a [ i ] - 1 ) ] += 1 <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> file_input = stdin <NEWLINE> <NL> N = int ( file_input . readline ( ) ) <NEWLINE> img = tuple ( tuple ( map ( int , line . split ( ) ) ) for line in file_input ) <NEWLINE> <NL> acc_row = ( tuple ( accumulate ( line ) ) + ( 0 , ) for line in img ) <NEWLINE> <NL> acc_col = ( tuple ( accumulate ( line ) ) + ( 0 , ) for line in zip ( * img ) ) <NEWLINE> acc_col_1 = next ( acc_col ) <NEWLINE> acc_col = tuple ( zip ( * acc_col ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , tpl_1 in enumerate ( zip ( img , acc_row ) ) : <NEWLINE> <INDENT> img_i , acc_row_i = tpl_1 <NEWLINE> for j , img_j in enumerate ( img [ i : ] , start = i ) : <NEWLINE> <INDENT> if acc_row_i [ j ] - acc_row_i [ i - 1 ] > ans : <NEWLINE> <INDENT> ans = acc_row_i [ j ] - acc_row_i [ i - 1 ] <NEWLINE> <NL> <DEDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> col_max = acc_col_1 [ j ] - acc_col_1 [ i - 1 ] <NEWLINE> <NL> for acc_col_j_k , acc_col_i_k , img_i_k , img_j_k in zip ( acc_col [ j ] , acc_col [ i - 1 ] , img_i [ 1 : ] , img_j [ 1 : ] ) : <NEWLINE> <INDENT> col = acc_col_j_k - acc_col_i_k <NEWLINE> <NL> if col_max > 0 : <NEWLINE> <INDENT> c_ans = col_max + col <NEWLINE> if c_ans > ans : <NEWLINE> <INDENT> ans = c_ans <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if col > ans : <NEWLINE> <INDENT> ans = col <NEWLINE> <NL> <DEDENT> <DEDENT> t_col_max = col_max + img_i_k + img_j_k <NEWLINE> if t_col_max > col : <NEWLINE> <INDENT> col_max = t_col_max <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> col_max = col <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i - 1 ] == <STRING> and S [ i - 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> flag = 1 <NEWLINE> upper = pow ( 10 , 18 ) <NEWLINE> for num in nums : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> sum = sum * num <NEWLINE> if sum > upper : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> <DEDENT> if num == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum * flag ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> V = list ( ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> s . reverse ( ) <NEWLINE> MOD = 2019 <NEWLINE> tot = 0 <NEWLINE> ans = 0 <NEWLINE> d = [ 0 for _ in range ( MOD ) ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> d [ tot ] += 1 <NEWLINE> x = pow ( 10 , i , MOD ) <NEWLINE> p = int ( s [ i ] ) * x <NEWLINE> p %= MOD <NEWLINE> tot = ( tot + p ) % MOD <NEWLINE> ans += d [ tot ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = [ 0 ] <NEWLINE> sum_b = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> sum_b . append ( sum_b [ j ] + b [ j ] ) <NEWLINE> <NL> <DEDENT> temp = 0 <NEWLINE> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] > k : <NEWLINE> <INDENT> temp = i - 1 <NEWLINE> if temp > ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while k - sum_a [ i ] < sum_b [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> temp = i + j <NEWLINE> if temp > ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> count = 0 <NEWLINE> l = [ 0 ] * 2019 <COMMENT> <NEWLINE> l [ 0 ] = 1 <NEWLINE> mod = 2019 <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> tmp = ( tmp + int ( S [ len ( S ) - i ] ) * pow ( 10 , i - 1 , mod ) ) % mod <NEWLINE> <COMMENT> <NL> l [ tmp ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for j in range ( 2019 ) : <NEWLINE> <INDENT> if l [ j ] >= 2 : <NEWLINE> <INDENT> count += l [ j ] * ( l [ j ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * ( n + 1 ) <NEWLINE> d = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ i + 1 ] = a [ i ] + c [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> d [ i + 1 ] = b [ i ] + d [ i ] <NEWLINE> <DEDENT> for i in range ( m + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> if d [ i ] <= k : <NEWLINE> <INDENT> x = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = x <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> while c [ i ] + d [ x ] > k : <NEWLINE> <INDENT> if x >= 1 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c [ i ] + d [ x ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = N <NEWLINE> m = N ** 0.5 <NEWLINE> L = [ ] <NEWLINE> i = 3 <NEWLINE> <NL> print ( str ( N ) + <STRING> , end = <STRING> ) <NEWLINE> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> n = n / 2 <NEWLINE> L . append ( 2 ) <NEWLINE> <NL> <DEDENT> while i <= m : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n = n / i <NEWLINE> L . append ( i ) <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> if n not in L : <NEWLINE> <INDENT> L . append ( int ( n ) ) <NEWLINE> <NL> <DEDENT> if 1 in L : <NEWLINE> <INDENT> L . remove ( 1 ) <NEWLINE> <NL> <DEDENT> if len ( L ) == 0 : <NEWLINE> <INDENT> L . append ( N ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , L ) ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> from math import floor <NEWLINE> a = floor ( N ** ( 1 / 2 ) ) <NEWLINE> i = 1 <NEWLINE> summ = 0 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> b = N // i <NEWLINE> if b > i : <NEWLINE> <INDENT> summ = summ + ( b - i ) * 2 - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b = N // i <NEWLINE> summ = summ + ( b - i + 1 ) * 2 - 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( summ ) <NEWLINE>
import networkx as nx <NEWLINE> <NL> R , C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> grid = [ list ( input ( ) ) for r in range ( R ) ] <NEWLINE> <NL> <NL> def pack ( r , c ) : <NEWLINE> <INDENT> return r * C + c <NEWLINE> <NL> <NL> <DEDENT> graph = nx . Graph ( ) <NEWLINE> top_nodes = set ( ) <COMMENT> <NEWLINE> for r in range ( R ) : <NEWLINE> <INDENT> for c in range ( C ) : <NEWLINE> <INDENT> if r + 1 < R and grid [ r ] [ c ] == grid [ r + 1 ] [ c ] == <STRING> : <NEWLINE> <INDENT> u , v = pack ( r , c ) , pack ( r + 1 , c ) <NEWLINE> graph . add_edge ( u , v ) <NEWLINE> if ( r + c ) % 2 == 0 : <NEWLINE> <INDENT> top_nodes . add ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> top_nodes . add ( u ) <NEWLINE> <DEDENT> <DEDENT> if c + 1 < C and grid [ r ] [ c ] == grid [ r ] [ c + 1 ] == <STRING> : <NEWLINE> <INDENT> u , v = pack ( r , c ) , pack ( r , c + 1 ) <NEWLINE> graph . add_edge ( u , v ) <NEWLINE> if ( r + c ) % 2 == 0 : <NEWLINE> <INDENT> top_nodes . add ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> top_nodes . add ( u ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> matching = nx . bipartite . maximum_matching ( graph , top_nodes = top_nodes ) <NEWLINE> <NL> count = 0 <NEWLINE> for u , v in matching . items ( ) : <NEWLINE> <INDENT> if u > v : <NEWLINE> <INDENT> assert matching [ v ] == u <NEWLINE> r1 , c1 = divmod ( u , C ) <NEWLINE> r2 , c2 = divmod ( v , C ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> if c1 > c2 : <NEWLINE> <INDENT> c1 , c2 = c2 , c1 <NEWLINE> <DEDENT> grid [ r1 ] [ c1 ] , grid [ r2 ] [ c2 ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif c1 == c2 : <NEWLINE> <INDENT> if r1 > r2 : <NEWLINE> <INDENT> r1 , r2 = r2 , r1 <NEWLINE> <DEDENT> grid [ r1 ] [ c1 ] = <STRING> <NEWLINE> grid [ r2 ] [ c2 ] = <STRING> <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> for row in grid : <NEWLINE> <INDENT> print ( <STRING> . join ( row ) ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> for s in range ( 0 , H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> An = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> An . sort ( reverse = True ) <NEWLINE> <NL> if 0 in An : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> j = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans > j : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ans *= An [ i ] <NEWLINE> <NL> <DEDENT> if ans > j : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> ab = [ ] <NEWLINE> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab . append ( math . gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for i in ab : <NEWLINE> <INDENT> ans += math . gcd ( c , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kouho = list ( range ( ( x - n // 2 - 1 ) , ( x + n // 2 + 1 ) ) ) <NEWLINE> kouho2 = list ( set ( kouho ) - set ( p_list ) ) <NEWLINE> ans = [ j for i , j in enumerate ( kouho2 ) if abs ( j - x ) == min ( abs ( np . array ( kouho2 ) - x ) ) ] <NEWLINE> ans = min ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> count = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> count = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if count % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> from math import * <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> arr [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * arr , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> num = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cheby = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = [ xy [ i ] [ 0 ] - xy [ i ] [ 1 ] , xy [ i ] [ 0 ] + xy [ i ] [ 1 ] ] <NEWLINE> cheby . append ( l ) <NEWLINE> <NL> <DEDENT> xmax = - 10 ** 10 <NEWLINE> xmin = 10 ** 10 <NEWLINE> ymax = - 10 ** 10 <NEWLINE> ymin = 10 ** 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cheby [ i ] [ 0 ] > xmax : <NEWLINE> <INDENT> xmax = cheby [ i ] [ 0 ] <NEWLINE> xa = i <NEWLINE> <DEDENT> if cheby [ i ] [ 0 ] < xmin : <NEWLINE> <INDENT> xmin = cheby [ i ] [ 0 ] <NEWLINE> xi = i <NEWLINE> <DEDENT> if cheby [ i ] [ 1 ] > ymax : <NEWLINE> <INDENT> ymax = cheby [ i ] [ 1 ] <NEWLINE> ya = i <NEWLINE> <DEDENT> if cheby [ i ] [ 1 ] < ymin : <NEWLINE> <INDENT> ymin = cheby [ i ] [ 1 ] <NEWLINE> yi = i <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( xmax - xmin ) > abs ( ymax - ymin ) : <NEWLINE> <INDENT> print ( abs ( xy [ xa ] [ 0 ] - xy [ xi ] [ 0 ] ) + abs ( xy [ xa ] [ 1 ] - xy [ xi ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( xy [ ya ] [ 0 ] - xy [ yi ] [ 0 ] ) + abs ( xy [ ya ] [ 1 ] - xy [ yi ] [ 1 ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += b [ n - 1 - ( math . ceil ( i / 2 ) ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def valid ( value1 , value2 , diff ) : <NEWLINE> <INDENT> if diff % 2 == 0 : <NEWLINE> <INDENT> return value1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return value2 <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( X ) > K : <NEWLINE> <INDENT> tmp = abs ( X ) // D <NEWLINE> if tmp > K : <NEWLINE> <INDENT> tmp = K <NEWLINE> <DEDENT> if X < 0 : <NEWLINE> <INDENT> X += tmp * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X -= tmp * D <NEWLINE> <DEDENT> K -= tmp <NEWLINE> <NL> <DEDENT> min_score = abs ( X ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if abs ( X - D ) > abs ( X + D ) : <NEWLINE> <INDENT> X = X + D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = X - D <NEWLINE> <DEDENT> if min_score > abs ( X ) : <NEWLINE> <INDENT> min_score = abs ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = min ( [ abs ( X - D ) , abs ( X + D ) ] ) <NEWLINE> min_score = valid ( a , abs ( X ) , K - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( min_score ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> H , W , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> S = np . zeros ( ( H + 1 , W + 1 ) , dtype = int ) <NEWLINE> S [ 1 : , 1 : ] = [ [ int ( _ ) for _ in input ( ) ] for _ in range ( H ) ] <NEWLINE> cum = S . cumsum ( axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 10 ** 10 <NEWLINE> for bs in itertools . product ( [ True , False ] , repeat = H - 1 ) : <NEWLINE> <INDENT> bs = [ True ] + list ( bs ) + [ True ] <NEWLINE> idxs = [ ] <NEWLINE> for i , b in enumerate ( bs ) : <NEWLINE> <INDENT> if b : <NEWLINE> <INDENT> idxs += [ i ] <NEWLINE> <DEDENT> <DEDENT> cum2 = np . array ( [ cum [ i2 ] - cum [ i1 ] for i1 , i2 in zip ( idxs , idxs [ 1 : ] ) ] ) <NEWLINE> i = 0 <NEWLINE> cnt = sum ( bs ) - 3 <NEWLINE> while i < W : <NEWLINE> <INDENT> di = min ( <NEWLINE> <INDENT> np . searchsorted ( c [ i + 1 : ] - c [ i ] , K , side = <STRING> ) for c in cum2 ) <NEWLINE> <DEDENT> if di == 0 : <NEWLINE> <INDENT> cnt = 10 ** 10 <NEWLINE> break <NEWLINE> <DEDENT> i += di <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> unique = set ( range ( 0 , 102 ) ) - set ( p ) <NEWLINE> ans = { } <NEWLINE> ans2 = [ ] <NEWLINE> for i in unique : <NEWLINE> <INDENT> calc = abs ( x - i ) <NEWLINE> if calc in ans . keys ( ) : <NEWLINE> <INDENT> ans [ calc ] = min ( ans [ calc ] , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ calc ] = i <NEWLINE> <DEDENT> ans2 . append ( calc ) <NEWLINE> <DEDENT> print ( ans [ min ( ans2 ) ] ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> Ans = [ ] <NEWLINE> <NL> if len ( O ) - len ( E ) == 0 : <NEWLINE> <INDENT> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> Ans . append ( O [ i ] ) <NEWLINE> Ans . append ( E [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> Ans . append ( O [ i ] ) <NEWLINE> Ans . append ( E [ i ] ) <NEWLINE> <DEDENT> Ans . append ( O [ len ( O ) - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( Ans ) ) <NEWLINE>
L = [ 26 ** i for i in range ( 13 ) ] <NEWLINE> <COMMENT> <NL> gun = [ sum ( L [ 1 : i ] ) for i in range ( 2 , 13 ) ] <NEWLINE> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while N > gun [ i ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if i != 0 : <NEWLINE> <INDENT> N = N - gun [ i - 1 ] <COMMENT> <NEWLINE> <DEDENT> N -= 1 <NEWLINE> <COMMENT> <NL> L = [ ] <NEWLINE> for k in range ( 1 , i + 2 ) : <NEWLINE> <INDENT> L . append ( N // ( 26 ** ( i + 1 - k ) ) ) <NEWLINE> N = N % ( 26 ** ( i + 1 - k ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> L = [ chr ( i + 97 ) for i in L ] <NEWLINE> <COMMENT> <NL> print ( <STRING> . join ( L ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> c = math . gcd ( i , j ) <NEWLINE> d += 6 * ( math . gcd ( c , l ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> d += 6 * ( math . gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d += i <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( Q ) ] <NEWLINE> cnt = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> sum_a = sum ( A ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> cnt [ A [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for bc in BC : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> sum_a = sum_a + ( bc [ 1 ] - bc [ 0 ] ) * cnt [ bc [ 0 ] ] <NEWLINE> print ( sum_a ) <NEWLINE> cnt [ bc [ 1 ] ] += cnt [ bc [ 0 ] ] <NEWLINE> cnt [ bc [ 0 ] ] = 0 <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = min ( B - 1 , N ) <NEWLINE> <NL> <NL> tmp = ( A * i ) // B - A * ( i // B ) <NEWLINE> <NL> <NL> print ( tmp ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = [ x - 1 for x in a ] <NEWLINE> a2 = [ x + 1 for x in a ] <NEWLINE> b = a + a1 + a2 <NEWLINE> c = collections . Counter ( b ) <NEWLINE> <NL> print ( max ( c . values ( ) ) ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> <NL> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> tmpJ = int ( j // 10 ) <NEWLINE> isFinish = False <NEWLINE> <NL> if j % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( j ) , end = <STRING> ) <NEWLINE> <DEDENT> elif ( j % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( j ) , end = <STRING> ) <NEWLINE> <DEDENT> elif tmpJ % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( j ) , end = <STRING> ) <NEWLINE> <DEDENT> elif tmpJ != 0 : <NEWLINE> <INDENT> tmpJ //= 10 <NEWLINE> while tmpJ != 0 and ( not isFinish ) : <NEWLINE> <INDENT> if tmpJ % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( j ) , end = <STRING> ) <NEWLINE> isFinish = True <NEWLINE> <DEDENT> tmpJ //= 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 + 5 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for u in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u ] . append ( v ) <NEWLINE> adj [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> vis = [ False for u in range ( n + 1 ) ] <NEWLINE> def dfs ( u ) : <NEWLINE> <INDENT> if vis [ u ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> vis [ u ] = True <NEWLINE> <NL> sz = 1 <NEWLINE> for v in adj [ u ] : <NEWLINE> <INDENT> sz += dfs ( v ) <NEWLINE> <DEDENT> return sz <NEWLINE> <NL> <DEDENT> CCs = [ ] <NEWLINE> for u in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not vis [ u ] : <NEWLINE> <INDENT> CCs . append ( dfs ( u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( CCs ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> r = len ( [ s for s in S if s == <STRING> ] ) <NEWLINE> g = len ( [ s for s in S if s == <STRING> ] ) <NEWLINE> b = len ( [ s for s in S if s == <STRING> ] ) <NEWLINE> <NL> res = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def IslandsWar ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> a . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> removes = [ a [ 0 ] [ 1 ] ] <NEWLINE> <NL> for i , j in a [ 1 : ] : <NEWLINE> <INDENT> check = False <NEWLINE> for k in removes : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> check = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not check : <NEWLINE> <INDENT> removes . append ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( removes ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> IslandsWar ( ) <NEWLINE> <DEDENT>
spot_num = int ( input ( ) ) <NEWLINE> spot_place = [ int ( p ) for p in input ( ) . split ( <STRING> ) ] <NEWLINE> diff_table = [ ] <NEWLINE> max_num = 0 <NEWLINE> <NL> for i in range ( spot_num ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> max_num += abs ( spot_place [ 0 ] - 0 ) <NEWLINE> diff_table . append ( abs ( spot_place [ 1 ] - 0 ) - ( abs ( spot_place [ 0 ] - 0 ) + abs ( spot_place [ 1 ] - spot_place [ 0 ] ) ) ) <NEWLINE> <DEDENT> elif i == spot_num - 1 : <NEWLINE> <INDENT> diff_table . append ( abs ( 0 - spot_place [ i - 1 ] ) - ( abs ( spot_place [ i ] - spot_place [ i - 1 ] ) + abs ( 0 - spot_place [ i ] ) ) ) <NEWLINE> max_num += abs ( spot_place [ i ] - spot_place [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff_table . append ( abs ( spot_place [ i + 1 ] - spot_place [ i - 1 ] ) - ( abs ( spot_place [ i ] - spot_place [ i - 1 ] ) + abs ( spot_place [ i + 1 ] - spot_place [ i ] ) ) ) <NEWLINE> max_num += abs ( spot_place [ i ] - spot_place [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_num += abs ( 0 - spot_place [ spot_num - 1 ] ) <NEWLINE> <NL> for i in range ( spot_num ) : <NEWLINE> <INDENT> print ( max_num + diff_table [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 1 <NEWLINE> for i in range ( k , n , 1 ) : <NEWLINE> <INDENT> if a [ i - k ] >= a [ i ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . read <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> MOD = int ( 1e9 ) + 7 <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if A [ n - 1 ] == 0 and ( k & 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif A [ n - 1 ] <= 0 and ( k & 1 ) : <NEWLINE> <INDENT> for i in range ( n - 1 , n - k - 1 , - 1 ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = n - 1 <NEWLINE> if k & 1 : <NEWLINE> <INDENT> ans = ( ans * A [ j ] ) % MOD <NEWLINE> j -= 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> k >>= 1 <NEWLINE> for itr in range ( k ) : <NEWLINE> <INDENT> left_product = A [ i ] * A [ i + 1 ] <NEWLINE> right_product = A [ j ] * A [ j - 1 ] <NEWLINE> if left_product > right_product : <NEWLINE> <INDENT> ans = ( ans * left_product ) % MOD <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * right_product ) % MOD <NEWLINE> j -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = set ( sq ) <NEWLINE> if len ( sq ) == len ( st ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> <NL> class UnionFindTree : <NEWLINE> <INDENT> def __init__ ( self , n : int ) -> None : <NEWLINE> <INDENT> self . par = list ( range ( n ) ) <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x : int ) -> int : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x : int , y : int ) -> None : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x : int , y : int ) -> bool : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> N , M , K = map ( int , in_ . readline ( ) . split ( ) ) <NEWLINE> ab = tuple ( tuple ( map ( int , line . split ( ) ) ) for line in itertools . islice ( in_ , M ) ) <NEWLINE> cd = tuple ( tuple ( map ( int , line . split ( ) ) ) for line in itertools . islice ( in_ , K ) ) <NEWLINE> <NL> ng = [ set ( ) for _ in range ( N + 1 ) ] <NEWLINE> friends_tree = UnionFindTree ( N + 1 ) <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> friends_tree . unite ( a , b ) <NEWLINE> <DEDENT> for a , b in ab : <NEWLINE> <INDENT> if friends_tree . same ( a , b ) : <NEWLINE> <INDENT> ng [ a ] . add ( b ) <NEWLINE> ng [ b ] . add ( a ) <NEWLINE> <DEDENT> <DEDENT> for c , d in cd : <NEWLINE> <INDENT> if friends_tree . same ( c , d ) : <NEWLINE> <INDENT> ng [ c ] . add ( d ) <NEWLINE> ng [ d ] . add ( c ) <NEWLINE> <DEDENT> <DEDENT> ok = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ok [ friends_tree . find ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ok [ friends_tree . find ( i ) ] - len ( ng [ i ] ) - 1 <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , ans [ 1 : ] ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ( ai >> i ) & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( ( cnt * ( n - cnt ) ) * 2 ** i ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> l = 0 <NEWLINE> if k % 7 == 0 : <NEWLINE> <INDENT> l = 9 * k // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 9 * k <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def fun ( ) : <NEWLINE> <INDENT> m = 1 <NEWLINE> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> m = m * 10 % l <NEWLINE> if m == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> fun ( ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> color1 = - 1 <NEWLINE> color2 = - 1 <NEWLINE> color3 = - 1 <NEWLINE> <NL> m = 10 ** 9 + 7 <NEWLINE> patern = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if color1 == a - 1 and color2 == a - 1 and color3 == a - 1 : <NEWLINE> <INDENT> patern = ( patern * 3 ) % m <NEWLINE> color1 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 == a - 1 and color3 == a - 1 ) : <NEWLINE> <INDENT> patern = ( patern * 2 ) % m <NEWLINE> color2 = a <NEWLINE> <NL> <DEDENT> elif ( color1 == a - 1 and color2 == a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> patern = ( patern * 2 ) % m <NEWLINE> color1 = a <NEWLINE> <DEDENT> elif ( color1 == a - 1 and color2 != a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> color1 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 == a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> color2 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 != a - 1 and color3 == a - 1 ) : <NEWLINE> <INDENT> color3 = a <NEWLINE> <NL> <DEDENT> elif ( color1 != a - 1 and color2 != a - 1 and color3 != a - 1 ) : <NEWLINE> <INDENT> patern = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( patern ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( Q ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> point [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> point [ i ] -= ( Q - K ) <NEWLINE> <DEDENT> for p in range ( N ) : <NEWLINE> <INDENT> if point [ p ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ - 1 ] + As [ i ] ) <NEWLINE> <NL> <DEDENT> b_sum = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ - 1 ] + Bs [ i ] ) <NEWLINE> <NL> <DEDENT> j = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a_sum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b_sum [ j ] > K - a_sum [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> def f ( ) : <NEWLINE> <INDENT> for a in range ( 1 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , a ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> f ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ i - 1 for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> left , right = 0 , 10 ** 9 <NEWLINE> while left < right : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> if middle == 0 : <NEWLINE> <INDENT> left = 1 <NEWLINE> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> count += i // middle <NEWLINE> <NL> <DEDENT> if count <= k : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = middle + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( left ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = NMI ( ) <NEWLINE> ab = [ NLI ( ) for _ in range ( M ) ] <NEWLINE> <NL> ENDsorted_sections = sorted ( ab , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> dropped_bridge = ENDsorted_sections [ 0 ] [ 1 ] <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> if ENDsorted_sections [ m ] [ 0 ] >= dropped_bridge : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> dropped_bridge = ENDsorted_sections [ m ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> ans += a [ i ] * sum_a <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> d [ a ] += 1 <NEWLINE> <DEDENT> ans = sum ( [ v % 2 for v in d . values ( ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += a [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A = 7 % K <NEWLINE> X = 7 % K <NEWLINE> n = 1 <NEWLINE> f = 0 <NEWLINE> while A != 0 : <NEWLINE> <INDENT> X = ( X * 10 ) % K <NEWLINE> A = ( A + X ) % K <NEWLINE> n += 1 <NEWLINE> if n > K : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adjacent_list = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacent_list [ a ] . append ( b ) <NEWLINE> adjacent_list [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> signs = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( 1 ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> for i in adjacent_list [ node ] : <NEWLINE> <INDENT> if signs [ i ] == - 1 : <NEWLINE> <INDENT> que . append ( i ) <NEWLINE> signs [ i ] = node <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( signs [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> B = [ 0 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B . append ( A [ i - 1 ] + B [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( B [ N ] - B [ i + 1 ] ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> MAX = 1000005 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> factor = [ 0 ] * ( MAX + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def generatePrimeFactors ( ) : <NEWLINE> <INDENT> factor [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> factor [ i ] = i <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 4 , MAX , 2 ) : <NEWLINE> <INDENT> factor [ i ] = 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> i = 3 <NEWLINE> while ( i * i < MAX ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( factor [ i ] == i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> j = i * i <NEWLINE> while ( j < MAX ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( factor [ j ] == j ) : <NEWLINE> <INDENT> factor [ j ] = i <NEWLINE> <DEDENT> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> def calculateNoOFactors ( n ) : <NEWLINE> <INDENT> if ( n == 1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dup = factor [ n ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> c = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> j = int ( n / factor [ n ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> while ( j > 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( factor [ j ] == dup ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> dup = factor [ j ] <NEWLINE> ans = ans * ( c + 1 ) <NEWLINE> c = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> j = int ( j / factor [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = ans * ( c + 1 ) <NEWLINE> <NL> return ans <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> generatePrimeFactors ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> s = 0 <NEWLINE> for i in range ( 1 , int ( input ( ) ) ) : <NEWLINE> <INDENT> s += ( calculateNoOFactors ( i ) ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = P . copy ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> P [ i ] = abs ( P [ i ] - x ) <NEWLINE> <DEDENT> P . sort ( ) <NEWLINE> count = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) // 2 == P [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = ( i + 1 ) // 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 0 and count == - 1 : <NEWLINE> <INDENT> count = n // 2 <NEWLINE> <DEDENT> elif n % 2 == 1 and count == - 1 : <NEWLINE> <INDENT> count = ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x - count in Q : <NEWLINE> <INDENT> print ( x + count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - count ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s_cnt = Counter ( s ) <NEWLINE> t_cnt = Counter ( t ) <NEWLINE> if all ( sv == tv for sv , tv in zip ( sorted ( s_cnt . values ( ) ) , sorted ( t_cnt . values ( ) ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> imput = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> n_ = 5 * pow ( 10 , 5 ) + 5 <NEWLINE> fun = [ 1 ] * ( n_ + 1 ) <NEWLINE> for i in range ( 1 , n_ + 1 ) : <NEWLINE> <INDENT> fun [ i ] = fun [ i - 1 ] * i % mod <NEWLINE> <DEDENT> rev = [ 1 ] * ( n_ + 1 ) <NEWLINE> rev [ n_ ] = pow ( fun [ n_ ] , mod - 2 , mod ) <NEWLINE> for i in range ( n_ - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> rev [ i ] = rev [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> def cmb ( n , r ) : <NEWLINE> <INDENT> if n < 0 or r < 0 or r > n : return 0 <NEWLINE> return fun [ n ] * rev [ r ] % mod * rev [ n - r ] % mod <NEWLINE> <DEDENT> def perm ( n , r ) : <NEWLINE> <INDENT> if n < 0 or r < 0 or r > n : return 0 <NEWLINE> return fun [ n ] * rev [ n - r ] % mod <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> import math <NEWLINE> answer = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> temp = perm ( n , i ) * cmb ( m , i ) * pow ( perm ( m - i , n - i ) , 2 ) <NEWLINE> temp %= mod <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> answer += temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer -= temp <NEWLINE> <DEDENT> <DEDENT> print ( answer % mod ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> AB = list ( zip ( m , m ) ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> root = 1 <NEWLINE> q = [ root ] <NEWLINE> checked = [ 0 ] * ( N + 1 ) <NEWLINE> checked [ root ] = 1 <NEWLINE> order = [ ] <NEWLINE> D = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> d = 0 <NEWLINE> while q : <NEWLINE> <INDENT> x = q . pop ( 0 ) <NEWLINE> d = D [ x ] <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if checked [ y ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> D [ y ] = d + 1 <NEWLINE> checked [ y ] = 1 <NEWLINE> q . append ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> d_a , d_b = D [ a ] , D [ b ] <NEWLINE> if d_a < d_b : <NEWLINE> <INDENT> ans [ b ] = a <NEWLINE> <DEDENT> elif d_a > d_b : <NEWLINE> <INDENT> ans [ a ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 2 : ] ) ) ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> string = input ( ) <NEWLINE> n = len ( string ) <NEWLINE> <NL> <COMMENT> <NL> string = string [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> S = [ 0 ] <NEWLINE> d = 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = int ( string [ i ] ) * d + S [ i ] <NEWLINE> t = t % 2019 <NEWLINE> S . append ( t ) <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> for key in S : <NEWLINE> <INDENT> d [ key ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for j in d . values ( ) : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> count += j * ( j - 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> l = [ 0 ] + [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if l [ i ] == l [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + count [ l [ i ] ] ) % mod <NEWLINE> count [ l [ i ] ] = dp [ i ] <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for s in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> y = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ones = 0 <NEWLINE> for i in y : <NEWLINE> <INDENT> if i == <STRING> : ones += 1 <NEWLINE> <DEDENT> x = int ( y , 2 ) <NEWLINE> <NL> def get ( z ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while z > 0 : <NEWLINE> <INDENT> if z % 2 == 1 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> z //= 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> out = [ ] <NEWLINE> rem1 = - 1 <NEWLINE> rem2 = - 1 <NEWLINE> if ones > 1 : <NEWLINE> <INDENT> rem1 = x % ( ones - 1 ) <NEWLINE> <DEDENT> if ones < n : <NEWLINE> <INDENT> rem2 = x % ( ones + 1 ) <NEWLINE> <NL> <DEDENT> def calc ( p , m ) : <NEWLINE> <INDENT> if p <= 2 : <NEWLINE> <INDENT> return ( 1 << p ) % m <NEWLINE> <DEDENT> a = p // 2 <NEWLINE> ret = calc ( a , m ) <NEWLINE> ret = ( ret * ret ) % m <NEWLINE> if p % 2 == 1 : <NEWLINE> <INDENT> ret = ( ret * 2 ) % m <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> o = ones - 1 <NEWLINE> if y [ n - i - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> o = ones + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if o == 0 : <NEWLINE> <INDENT> out . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if o == 1 : <NEWLINE> <INDENT> out . append ( 1 ) <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> if o > ones : <NEWLINE> <INDENT> tmp = ( rem2 % o + calc ( i , o ) ) % o <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( rem1 % o - calc ( i , o ) + o ) % o <NEWLINE> <NL> <NL> <DEDENT> cnt = 1 <NEWLINE> while tmp > 0 : <NEWLINE> <INDENT> tmp %= get ( tmp ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> out . append ( cnt ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( out [ n - i - 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> def calculate ( n , k , s ) : <NEWLINE> <INDENT> s = list ( s ) <NEWLINE> <NL> result = [ { <STRING> : 0 , <STRING> : 0 } ] <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> previous = s [ i - 1 ] <NEWLINE> current = s [ i ] <NEWLINE> <NL> if i == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> result . append ( { <STRING> : 0 } ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( current == <STRING> ) and ( previous == <STRING> ) : <NEWLINE> <INDENT> res = result [ - 1 ] <NEWLINE> res . __setitem__ ( <STRING> , i ) <NEWLINE> result [ - 1 ] = res <NEWLINE> <NL> <DEDENT> if ( current == <STRING> ) and ( previous == <STRING> ) : <NEWLINE> <INDENT> result . append ( { <STRING> : i } ) <NEWLINE> <NL> <DEDENT> <DEDENT> if i == n - 1 and s [ i ] == <STRING> : <NEWLINE> <INDENT> res = result [ - 1 ] <NEWLINE> res . __setitem__ ( <STRING> , i + 1 ) <NEWLINE> result [ - 1 ] = res <NEWLINE> <NL> <DEDENT> <DEDENT> result . append ( { <STRING> : n , <STRING> : n } ) <NEWLINE> <NL> <NL> <COMMENT> <NL> maxValue = 0 <NEWLINE> if len ( result ) > k : <NEWLINE> <INDENT> for i in range ( len ( result ) - k ) : <NEWLINE> <INDENT> val = result [ i + k ] [ <STRING> ] - result [ i ] [ <STRING> ] <NEWLINE> maxValue = max ( val , maxValue ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> maxValue = max ( maxValue , result [ - 1 ] [ <STRING> ] - result [ 0 ] [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( maxValue ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , K , S ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> ans1 = [ 0 ] * 2019 <NEWLINE> ans2 = 0 <NEWLINE> <NL> T = [ 0 ] * ( N + 1 ) <NEWLINE> T [ N ] = 0 <NEWLINE> ans1 [ 0 ] += 1 <NEWLINE> <NL> P = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> T [ i ] = ( T [ i + 1 ] + P * int ( S [ i ] ) ) % 2019 <NEWLINE> ans1 [ T [ i ] ] += 1 <NEWLINE> P = 10 * P % 2019 <NEWLINE> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> x = ans1 [ i ] <NEWLINE> ans2 += x * ( x - 1 ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( int ( ans2 ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> <NL> q = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for s in range ( 2 ** n ) : <NEWLINE> <INDENT> judge = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , len ( q [ i ] ) ) : <NEWLINE> <INDENT> w = q [ i ] [ j ] <NEWLINE> if s >> ( w - 1 ) & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 != p [ i ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alst . sort ( ) <NEWLINE> tmp = [ 0 for _ in range ( 10 ** 6 + 10 ) ] <NEWLINE> ans = 0 <NEWLINE> flg = True <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if alst [ 0 ] == 1 : <NEWLINE> <INDENT> if alst [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> for num in alst : <NEWLINE> <INDENT> if tmp [ num ] == 2 : <NEWLINE> <INDENT> if flg : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> flg = False <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> flg = True <NEWLINE> if tmp [ num ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> tmp [ num ] = 2 <NEWLINE> xx = num * 2 <NEWLINE> while xx < 10 ** 6 + 1 : <NEWLINE> <INDENT> tmp [ xx ] = 1 <NEWLINE> xx += num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> sum = 0 <NEWLINE> f = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> f = f + a [ i ] <NEWLINE> sum += f * a [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( sum % mod ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : return a <NEWLINE> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def interval ( a , m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> x = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = ( a * x ) % m <NEWLINE> cnt += 1 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> a1 , m1 , a2 , m2 , a3 , m3 = map ( int , s . split ( ) ) <NEWLINE> if sum ( [ a1 , m1 , a2 , m2 , a3 , m3 ] ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> x_num = interval ( a1 , m1 ) <NEWLINE> y_num = interval ( a2 , m2 ) <NEWLINE> z_num = interval ( a3 , m3 ) <NEWLINE> <NL> a = lcm ( x_num , y_num ) <NEWLINE> b = lcm ( a , z_num ) <NEWLINE> print ( b ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class UnionFindTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , n : int ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . n = n <NEWLINE> self . rank = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find_root ( self , x : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if self . rank [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> self . rank [ x ] = self . find_root ( self . rank [ x ] ) <NEWLINE> return self . rank [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x : int , y : int ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> x_root = self . find_root ( x ) <NEWLINE> y_root = self . find_root ( y ) <NEWLINE> <NL> if x_root == y_root : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if x_root > y_root : <NEWLINE> <INDENT> x_root , y_root = y_root , x_root <NEWLINE> <NL> <DEDENT> self . rank [ x_root ] += self . rank [ y_root ] <NEWLINE> self . rank [ y_root ] = x_root <NEWLINE> <NL> <DEDENT> def get_size ( self , x : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . rank [ self . find_root ( x ) ] * - 1 <NEWLINE> <NL> <DEDENT> def is_same ( self , x : int , y : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . find_root ( x ) == self . find_root ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> tree = UnionFindTree ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> tree . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , tree . get_size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def prime ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> n = int ( input ( <STRING> ) ) <NEWLINE> s = 0 <NEWLINE> if ( n != 1 ) : <NEWLINE> <NL> <NL> <NL> <NL> <INDENT> t = 0 <NEWLINE> lista = prime ( n ) <NEWLINE> <COMMENT> <NL> <NL> c = lista [ 0 ] <NEWLINE> for i in lista : <NEWLINE> <INDENT> if ( c == i ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 1 <NEWLINE> while ( t >= k ) : <NEWLINE> <INDENT> t -= k <NEWLINE> s += 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> t = 1 <NEWLINE> c = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> k = 1 <NEWLINE> while ( t >= k ) : <NEWLINE> <INDENT> t -= k <NEWLINE> s += 1 <NEWLINE> k += 1 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q1 = [ ] <NEWLINE> q2 = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q1 . append ( i + a [ i ] ) <NEWLINE> q2 . append ( i - a [ i ] ) <NEWLINE> <NL> <DEDENT> c1 = Counter ( q1 ) <NEWLINE> c2 = Counter ( q2 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in c1 . keys ( ) : <NEWLINE> <INDENT> num1 = c1 [ i ] <NEWLINE> num2 = c2 [ i ] <NEWLINE> ans += num1 * num2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> v = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> a_list . sort ( reverse = True ) <NEWLINE> <NL> from heapq import heappush , heappop <NEWLINE> <NL> hq = [ ] <NEWLINE> joined = set ( ) <NEWLINE> joined . add ( 0 ) <NEWLINE> heappush ( hq , ( - a_list [ 0 ] , 0 , 0 ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <NL> <INDENT> comfort , left , right = heappop ( hq ) <NEWLINE> comfort = - comfort <NEWLINE> <NL> result += comfort <NEWLINE> <NL> heappush ( hq , ( - ( a_list [ left ] if a_list [ left ] < a_list [ i ] else a_list [ i ] ) , left , i ) ) <NEWLINE> heappush ( hq , ( - ( a_list [ right ] if a_list [ right ] < a_list [ i ] else a_list [ i ] ) , i , right ) ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> a . append ( [ s [ 0 ] , int ( s [ 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> a_in = a . copy ( ) <NEWLINE> <NL> def is_stable ( a , b ) : <NEWLINE> <INDENT> s = True <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if b [ i + 1 ] [ 1 ] == b [ i ] [ 1 ] : <NEWLINE> <INDENT> j = a . index ( b [ i ] ) <NEWLINE> k = a . index ( b [ i + 1 ] ) <NEWLINE> if j > k : <NEWLINE> <INDENT> s = False <NEWLINE> return s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> def partition ( a , p , r ) : <NEWLINE> <INDENT> x = a [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if a [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> temp = a [ i ] <NEWLINE> a [ i ] = a [ j ] <NEWLINE> a [ j ] = temp <NEWLINE> <DEDENT> <DEDENT> temp = a [ i + 1 ] <NEWLINE> a [ i + 1 ] = a [ r ] <NEWLINE> a [ r ] = temp <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quick_sort ( a , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( a , p , r ) <NEWLINE> quick_sort ( a , p , q - 1 ) <NEWLINE> quick_sort ( a , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> quick_sort ( a , 0 , len ( a ) - 1 ) <NEWLINE> if is_stable ( a_in , a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] [ 0 ] , a [ i ] [ 1 ] ) ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> max_ = 10 ** 6 + 1 <NEWLINE> ans = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ True ] * ( max_ + 1 ) <NEWLINE> data . sort ( ) <NEWLINE> c = Counter ( data ) <NEWLINE> <COMMENT> <NL> <NL> for d in data : <NEWLINE> <INDENT> if b [ d ] : <NEWLINE> <INDENT> for j in range ( d , max_ , d ) : <NEWLINE> <INDENT> b [ j ] = False <NEWLINE> <DEDENT> if c [ d ] == 1 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> if ( 0 in x ) : <NEWLINE> <INDENT> K = K - 1 <NEWLINE> x . remove ( 0 ) <NEWLINE> if ( K == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , N - K + 1 ) : <NEWLINE> <INDENT> if ( ( x [ i ] < 0 ) ) : <NEWLINE> <INDENT> if ( x [ i + K - 1 ] > 0 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( x [ i ] ) * 2 + x [ i + K - 1 ] , abs ( x [ i ] ) + x [ i + K - 1 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , abs ( x [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , x [ i + K - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> t = [ 0 ] * 110000 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> t [ a ] += 1 <NEWLINE> <NL> <DEDENT> a = sum ( A ) <NEWLINE> <NL> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> a = a + ( C [ i ] - B [ i ] ) * t [ B [ i ] ] <NEWLINE> t [ C [ i ] ] = t [ C [ i ] ] + t [ B [ i ] ] <NEWLINE> t [ B [ i ] ] = 0 <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if t % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> t = ( t * 10 + 7 ) % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n_gram = lambda t , n : [ t [ i : i + n ] for i in range ( len ( t ) - n + 1 ) ] <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> t_len = len ( T ) <NEWLINE> count = t_len <NEWLINE> <NL> s_list = n_gram ( S , t_len ) <NEWLINE> <NL> for s in s_list : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != T [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> count = min ( count , c ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
<NL> S = list ( input ( ) ) <NEWLINE> mod = 2019 <NEWLINE> S = list ( reversed ( S ) ) <NEWLINE> N = len ( S ) <NEWLINE> A = [ 0 ] * ( N ) <NEWLINE> p = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p *= 10 <NEWLINE> p %= mod <NEWLINE> <DEDENT> now = ( int ( S [ i ] ) * p ) % mod <NEWLINE> A [ i ] = now <NEWLINE> <COMMENT> <NL> <DEDENT> rui = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> rui [ i ] = ( rui [ i - 1 ] + A [ i - 1 ] ) % mod <NEWLINE> <DEDENT> total = [ 0 ] * 2019 <NEWLINE> for r in rui : <NEWLINE> <INDENT> total [ r ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for t in total : <NEWLINE> <INDENT> ans += t * ( t - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> num = 0 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> num += p [ j ] <NEWLINE> <DEDENT> l . append ( num ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> l . append ( l [ i ] - p [ i ] + p [ i + k ] ) <NEWLINE> <NL> <DEDENT> print ( ( max ( l ) + k ) / 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> la = [ 0 ] <NEWLINE> lb = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> la += [ a [ i ] + la [ i ] ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> lb += [ b [ i ] + lb [ i ] ] <NEWLINE> <DEDENT> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if la [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while lb [ j ] > k - la [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> x = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> x1 = x [ 2 ] - x [ 0 ] <NEWLINE> y1 = x [ 3 ] - x [ 1 ] <NEWLINE> x2 = x [ 6 ] - x [ 4 ] <NEWLINE> y2 = x [ 7 ] - x [ 5 ] <NEWLINE> if abs ( x1 * y2 - x2 * y1 ) <= 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> prev = 0 <NEWLINE> s = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> now = prev + a <NEWLINE> s . append ( now ) <NEWLINE> prev = now <NEWLINE> <NL> <DEDENT> start = 0 <NEWLINE> last = s [ - 1 ] <NEWLINE> for i in s [ : - 1 ] : <NEWLINE> <INDENT> ans += ( i - start ) * ( last - i ) <NEWLINE> start = i <NEWLINE> <NL> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> import bisect <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inda = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> indc = bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += inda * ( n - indc ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum_ans = 0 <NEWLINE> gcd_list = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> gcd_list . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for g in gcd_list : <NEWLINE> <INDENT> tmp = math . gcd ( k , g ) <NEWLINE> sum_ans += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import math <NEWLINE> k1 = 0 <NEWLINE> k2 = 0 <NEWLINE> k3 = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> k1 = k1 + 1 <NEWLINE> k2 = 0 <NEWLINE> for j in range ( 0 , k1 ) : <NEWLINE> <INDENT> k3 = 0 <NEWLINE> k2 = k2 + 1 <NEWLINE> for k in range ( 0 , k2 ) : <NEWLINE> <INDENT> k3 = k3 + 1 <NEWLINE> if k1 == k2 == k3 : <NEWLINE> <INDENT> count = count + k1 <NEWLINE> <DEDENT> elif k1 == k2 : <NEWLINE> <INDENT> count = count + 3 * math . gcd ( k1 , k3 ) <NEWLINE> <DEDENT> elif k2 == k3 : <NEWLINE> <INDENT> count = count + 3 * math . gcd ( k1 , k2 ) <NEWLINE> <DEDENT> elif k3 == k1 : <NEWLINE> <INDENT> count = count + 3 * math . gcd ( k1 , k2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k4 = math . gcd ( k1 , k2 ) <NEWLINE> count = count + 6 * math . gcd ( k3 , k4 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> base = [ mark + str ( rank ) for mark in [ <STRING> , <STRING> , <STRING> , <STRING> ] for rank in range ( 1 , 14 ) ] <NEWLINE> for card in [ input ( ) for i in range ( n ) ] : <NEWLINE> <INDENT> base . remove ( card ) <NEWLINE> <DEDENT> for elem in base : <NEWLINE> <INDENT> print ( elem ) <NEWLINE> <DEDENT>
from collections import Counter as cnt <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = sum ( A ) <NEWLINE> D = cnt ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = S + ( C - B ) * D [ B ] <NEWLINE> print ( S ) <NEWLINE> D [ C ] += D [ B ] <NEWLINE> D [ B ] = 0 <NEWLINE> <DEDENT>
