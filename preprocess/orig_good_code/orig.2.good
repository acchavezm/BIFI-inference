N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> left . append ( b ) <NEWLINE> <DEDENT> elif b == N : <NEWLINE> <INDENT> right . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> left = set ( left ) <NEWLINE> for r in right : <NEWLINE> <INDENT> if r in left : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> <NL> def dfs ( now ) : <NEWLINE> <INDENT> seen [ now ] = True <NEWLINE> score [ now ] += operation [ now ] <NEWLINE> for next in branch [ now ] : <NEWLINE> <INDENT> if seen [ next ] is False : <NEWLINE> <INDENT> score [ next ] += score [ now ] <NEWLINE> dfs ( next ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> branch = [ set ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> branch [ a - 1 ] . add ( b - 1 ) <NEWLINE> branch [ b - 1 ] . add ( a - 1 ) <NEWLINE> <DEDENT> operation = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> operation [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * N <NEWLINE> score = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] is False : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in score : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> from fractions import Fraction <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if b * ( a ** 2 ) <= x * 2 : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( Fraction ( 2 * ( a * a * b - x ) , a ** 3 ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( Fraction ( a * b * b , 2 * x ) ) ) ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> import copy <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> G [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> ls = list ( permutations ( range ( 1 , N ) ) ) <NEWLINE> ans = 0 <NEWLINE> for l in ls : <NEWLINE> <INDENT> h = copy . deepcopy ( G ) <NEWLINE> cnt = 1 <NEWLINE> p = 0 <NEWLINE> for k in l : <NEWLINE> <INDENT> if h [ p ] [ k ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> p = k <NEWLINE> <DEDENT> <DEDENT> if cnt == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans_ = 0 <NEWLINE> count = 0 <NEWLINE> sum_list = list ( permutations ( range ( N ) , N ) ) <NEWLINE> for nums in sum_list : <NEWLINE> <INDENT> for i in range ( len ( nums ) - 1 ) : <NEWLINE> <INDENT> x1 , y1 = xy [ nums [ i ] ] <NEWLINE> x2 , y2 = xy [ nums [ i + 1 ] ] <NEWLINE> ans_ += math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( ans_ / count ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> p = l ( ) <NEWLINE> x = list ( itertools . accumulate ( p ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( ( p [ 0 ] + 1 ) / 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( ( x [ - 1 ] + k ) / 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , x [ i + k - 1 ] - x [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ( ans + k ) / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> ab = 0 <NEWLINE> ac = 0 <NEWLINE> b = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> c = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> d = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> e = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if v [ i ] == v [ i + 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if ( a == n - 1 ) : <NEWLINE> <INDENT> print ( int ( n / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> b [ v [ i ] ] = b [ v [ i ] ] + 1 <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> c [ v [ j ] ] = c [ v [ j ] ] + 1 <NEWLINE> <DEDENT> d = sorted ( b , reverse = True ) <NEWLINE> e = sorted ( c , reverse = True ) <NEWLINE> for s in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if ( d [ 0 ] == b [ s ] ) : <NEWLINE> <INDENT> ab = s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for t in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if ( e [ 0 ] == c [ t ] ) : <NEWLINE> <INDENT> ac = t <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( s == t ) : <NEWLINE> <INDENT> print ( min ( 2 * int ( n / 2 ) - d [ 0 ] - e [ 1 ] , 2 * int ( n / 2 ) - d [ 1 ] - e [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( n / 2 ) - d [ 0 ] <NEWLINE> g = int ( n / 2 ) - e [ 0 ] <NEWLINE> print ( f + g ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while N > i : <NEWLINE> <INDENT> if p [ i ] - 1 == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> from typing import List <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> r = list ( input ( ) ) <NEWLINE> g . append ( r ) <NEWLINE> <DEDENT> print ( mm ( h , w , g ) ) <NEWLINE> <NL> <NL> <DEDENT> def mm ( h : int , w : int , g : List [ List [ str ] ] ) -> int : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( g [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = set ( ) <NEWLINE> q = deque ( [ ( i , j , 0 ) ] ) <NEWLINE> v . add ( ( i , j ) ) <NEWLINE> while q : <NEWLINE> <INDENT> ii , jj , cnt = q . popleft ( ) <NEWLINE> ret = max ( ret , cnt ) <NEWLINE> <COMMENT> <NL> if ii < h - 1 and g [ ii + 1 ] [ jj ] == <STRING> and ( ii + 1 , jj ) not in v : <NEWLINE> <INDENT> q . append ( ( ii + 1 , jj , cnt + 1 ) ) <NEWLINE> v . add ( ( ii + 1 , jj ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if jj < w - 1 and g [ ii ] [ jj + 1 ] == <STRING> and ( ii , jj + 1 ) not in v : <NEWLINE> <INDENT> q . append ( ( ii , jj + 1 , cnt + 1 ) ) <NEWLINE> v . add ( ( ii , jj + 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if ii > 0 and g [ ii - 1 ] [ jj ] == <STRING> and ( ii - 1 , jj ) not in v : <NEWLINE> <INDENT> q . append ( ( ii - 1 , jj , cnt + 1 ) ) <NEWLINE> v . add ( ( ii - 1 , jj ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if jj > 0 and g [ ii ] [ jj - 1 ] == <STRING> and ( ii , jj - 1 ) not in v : <NEWLINE> <INDENT> q . append ( ( ii , jj - 1 , cnt + 1 ) ) <NEWLINE> v . add ( ( ii , jj - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> s = str ( input ( ) ) <NEWLINE> low = string . ascii_lowercase <NEWLINE> fin = <STRING> <NEWLINE> for i in range ( len ( low ) ) : <NEWLINE> <INDENT> if low [ i ] not in s : <NEWLINE> <INDENT> fin += low [ i ] <NEWLINE> <DEDENT> <DEDENT> if len ( fin ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fin [ 0 ] ) <NEWLINE> <DEDENT>
import bisect , copy , heapq , itertools , math , string <NEWLINE> from collections import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> a = LIST ( ) <NEWLINE> b = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <DEDENT> c = [ a [ b [ i ] ] for i in range ( n ) ] <NEWLINE> print ( * c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> L_0 = 2 <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> L_1 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L_2 = L_0 + L_1 <NEWLINE> L_0 = L_1 <NEWLINE> L_1 = L_2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( L_2 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = True <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= L and b <= R : <NEWLINE> <INDENT> L = a <NEWLINE> R = b <NEWLINE> <DEDENT> elif L <= b and R >= b : <NEWLINE> <INDENT> R = b <NEWLINE> <DEDENT> elif L <= a and R >= a : <NEWLINE> <INDENT> L = a <NEWLINE> <DEDENT> elif a < L and R < b : <NEWLINE> <INDENT> L = L <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( R - L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( make_divisors ( i ) ) == 8 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += str ( b [ i ] ) + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al , bl = [ ] , [ ] <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( min ( b - a , k ) ) : <NEWLINE> <INDENT> al . append ( a + i ) <NEWLINE> bl . append ( b - i ) <NEWLINE> ans = list ( set ( al ) | set ( bl ) ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
def opt ( N , W ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( W + 1 ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = dp [ i - w ] + v <NEWLINE> if tmp > dp [ i ] : <NEWLINE> <INDENT> dp [ i ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ W ] ) <NEWLINE> <NL> <DEDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> opt ( N , W ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> sq = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> ans = False <NEWLINE> c = H * W <NEWLINE> pos = [ [ 0 , 0 , 0 ] ] <NEWLINE> <NL> while pos != [ ] : <NEWLINE> <INDENT> y , x , depth = pos . pop ( 0 ) <NEWLINE> <NL> if x == W - 1 and y == H - 1 : <NEWLINE> <INDENT> ans = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> if 0 <= x + 1 <= W - 1 : <NEWLINE> <INDENT> if sq [ y ] [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x + 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 <= x - 1 <= W - 1 : <NEWLINE> <INDENT> if sq [ y ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x - 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 <= y + 1 <= H - 1 : <NEWLINE> <INDENT> if sq [ y + 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y + 1 , x , depth + 1 ] ) <NEWLINE> sq [ y + 1 ] [ x ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 <= y - 1 <= H - 1 : <NEWLINE> <INDENT> if sq [ y - 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y - 1 , x , depth + 1 ] ) <NEWLINE> sq [ y - 1 ] [ x ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if sq [ j ] [ k ] == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == True : <NEWLINE> <INDENT> print ( c - depth - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> ls = deque ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ls . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * reversed ( ls ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * ls ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> if n & 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( a [ : : - 2 ] + a [ 1 : : 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( a [ - 1 : 0 : - 2 ] + a [ : : 2 ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = b - b // c - b // d + b // ( c * d // math . gcd ( c , d ) ) <NEWLINE> y = ( a - 1 ) - ( a - 1 ) // c - ( a - 1 ) // d + ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) <NEWLINE> print ( x - y ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> result = N <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) + 2 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> result = min ( result , i - 1 + N // i - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
li = input ( ) . split ( ) <NEWLINE> <NL> if li [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( li [ 0 ] ) + int ( li [ 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( li [ 0 ] ) - int ( li [ 2 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ <STRING> ] <NEWLINE> for i in b : <NEWLINE> <INDENT> l . insert ( i - 1 , i ) <NEWLINE> <DEDENT> print ( * l [ - 1 ] and [ - 1 ] or l , sep = <STRING> ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A > 200 : <NEWLINE> <INDENT> k = range ( A , A + K ) <NEWLINE> l = range ( B - K + 1 , B + 1 ) <NEWLINE> for i in k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = range ( A , B + 1 ) <NEWLINE> t = [ x for x in s if A <= x <= A + K - 1 or B - K + 1 <= x <= B ] <NEWLINE> t . sort ( ) <NEWLINE> for i in t : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> p = math . factorial ( n ) <NEWLINE> print ( p % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> table = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in table : <NEWLINE> <INDENT> table [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k in table : <NEWLINE> <INDENT> ans += table [ k ] * ( table [ k ] - 1 ) <NEWLINE> <NL> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> count_dict = { s : 0 for s in range ( 1 , n + 1 ) } <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> seikaisha = int ( input ( ) ) <NEWLINE> if seikaisha in count_dict : <NEWLINE> <INDENT> count_dict [ seikaisha ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_dict [ seikaisha ] = 0 <NEWLINE> <DEDENT> <DEDENT> count_dict_sorted = sorted ( count_dict . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i , j in count_dict_sorted : <NEWLINE> <INDENT> if k + j - q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> l = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> if len ( s ) == 26 : <NEWLINE> <INDENT> if s == l [ - 1 : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 26 ) [ - 2 : : - 1 ] : <NEWLINE> <INDENT> for j in range ( 25 , i , - 1 ) : <NEWLINE> <INDENT> if s [ i ] < s [ j ] : <NEWLINE> <INDENT> s [ i ] = s [ j ] <NEWLINE> print ( <STRING> . join ( s [ : i + 1 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) [ - 1 : : - 1 ] : <NEWLINE> <INDENT> if l [ i ] in s : <NEWLINE> <INDENT> del l [ i ] <NEWLINE> <DEDENT> <DEDENT> s . append ( l [ 0 ] ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> d = { 0 : 1 , 1 : 1 , 2 : 2 } <NEWLINE> def countcombi ( n ) : <NEWLINE> <INDENT> if n in d : <NEWLINE> <INDENT> return d [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ n ] = countcombi ( n - 1 ) + countcombi ( n - 2 ) <NEWLINE> return d [ n ] <NEWLINE> <DEDENT> <DEDENT> N , M = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> a_now = 0 <NEWLINE> a_before = 0 <NEWLINE> ans = 1 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a_now = int ( input ( ) . rstrip ( ) ) <NEWLINE> if a_now - a_before == 0 and a_before != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> ans = ( ans * countcombi ( a_now - a_before - 1 ) ) % 1_000_000_007 <NEWLINE> a_before = a_now + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_now = N <NEWLINE> ans = ( ans * countcombi ( a_now - a_before ) ) % 1_000_000_007 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<NL> def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> sub = <STRING> <NEWLINE> cnt = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> st = 0 <NEWLINE> end = 0 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> S = S [ st : len ( S ) - end ] <NEWLINE> <COMMENT> <NL> <NL> foundB = False <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> foundB = True <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> sum += cnt <NEWLINE> foundB = False <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> u = [ 0 ] <NEWLINE> v = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> u . append ( u [ i ] + p [ i ] ) <NEWLINE> <DEDENT> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> w . append ( u [ k + i ] - u [ i ] ) <NEWLINE> <DEDENT> x = w . index ( max ( w ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> v . append ( p [ x + i ] ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a += 1 + 0.5 * ( v [ i ] - 1 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> arr = make_divisors ( n ) <NEWLINE> arr = [ x - 1 for x in arr if x >= 2 ] <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for x in arr [ : : - 1 ] : <NEWLINE> <INDENT> if n // x != n % x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> n = int ( pin ( ) ) <NEWLINE> a = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> b = deque ( [ ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> b . appendleft ( a [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> pout ( str ( b [ k ] ) ) <NEWLINE> if k != n - 1 : <NEWLINE> <INDENT> pout ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> pout ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def test ( ) : <NEWLINE> <INDENT> from itertools import combinations <NEWLINE> <NL> s = <STRING> <NEWLINE> result = 0 <NEWLINE> for k in range ( 1 , len ( s ) // 2 + 1 ) : <NEWLINE> <INDENT> for idx in combinations ( range ( len ( s ) ) , 2 * k ) : <NEWLINE> <INDENT> success = True <NEWLINE> for ii in range ( k ) : <NEWLINE> <INDENT> if s [ idx [ ii ] ] != s [ idx [ ii + k ] ] : <NEWLINE> <INDENT> success = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if success : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> factorials = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , 40 ) : <NEWLINE> <INDENT> factorials . append ( factorials [ - 1 ] * i ) <NEWLINE> <NL> <DEDENT> patterns = { } <NEWLINE> for i in range ( 2 , 40 ) : <NEWLINE> <INDENT> base = ( 1 << ( i - 1 ) ) - 1 <NEWLINE> gain = base <NEWLINE> chars = i <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( i , ) ) <NEWLINE> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> a = i // 2 <NEWLINE> ncr1 = factorials [ i ] // factorials [ a ] // factorials [ a ] - 1 <NEWLINE> <NL> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> base2 = ( 1 << ( 2 * b - 1 ) ) - 1 <NEWLINE> ncr2 = factorials [ 2 * b ] // factorials [ b ] // factorials [ b ] - 1 <NEWLINE> gain = base + base2 + ncr1 * ncr2 <NEWLINE> chars = i + 2 * b <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( a , b ) ) <NEWLINE> <NL> <DEDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> base3 = ( 1 << ( 2 * c - 1 ) ) - 1 <NEWLINE> ncr3 = factorials [ 2 * c ] // factorials [ c ] // factorials [ c ] - 1 <NEWLINE> gain = base + base2 + base3 + ncr1 * ncr2 * ncr3 + ncr1 * ncr2 + ncr2 * ncr3 + ncr3 * ncr1 <NEWLINE> chars = i + 2 * b + 2 * c <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( a , b , c ) ) <NEWLINE> <NL> <DEDENT> for d in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> base4 = ( 1 << ( 2 * d - 1 ) ) - 1 <NEWLINE> ncr4 = factorials [ 2 * d ] // factorials [ d ] // factorials [ d ] - 1 <NEWLINE> gain = base + base2 + base3 + base4 + ncr1 * ncr2 * ncr3 * ncr4 <NEWLINE> gain += ncr1 * ncr2 * ncr3 + ncr1 * ncr2 * ncr4 + ncr1 * ncr3 * ncr4 + ncr2 * ncr3 * ncr4 <NEWLINE> gain += ncr1 * ncr2 + ncr1 * ncr3 + ncr1 * ncr4 + ncr2 * ncr3 + ncr2 * ncr4 + ncr3 * ncr4 <NEWLINE> chars = i + 2 * b + 2 * c + 2 * d <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( a , b , c , d ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( use , i , remaining , total_char ) : <NEWLINE> <INDENT> if remaining == 0 : <NEWLINE> <INDENT> return total_char <= 200 <NEWLINE> <NL> <DEDENT> for j in range ( i , len ( patterns ) ) : <NEWLINE> <INDENT> gain , ( chars , lengths ) = patterns [ j ] <NEWLINE> if total_char + remaining * chars / gain > 200 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain > remaining : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> use . append ( lengths ) <NEWLINE> result = dfs ( use , j , remaining - gain , total_char + chars ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> use . pop ( ) <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> patterns = sorted ( patterns . items ( ) , key = lambda item : item [ 0 ] / item [ 1 ] [ 0 ] , reverse = True ) <NEWLINE> <NL> use = [ ] <NEWLINE> result = dfs ( use , 0 , n , 0 ) <NEWLINE> assert result <NEWLINE> <NL> ans = [ ] <NEWLINE> c = 1 <NEWLINE> for lengths in use : <NEWLINE> <INDENT> if len ( lengths ) == 1 : <NEWLINE> <INDENT> ans . extend ( [ c ] * lengths [ 0 ] ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( 2 ) : <NEWLINE> <INDENT> for i , l in enumerate ( lengths ) : <NEWLINE> <INDENT> ans . extend ( [ c + i ] * l ) <NEWLINE> <DEDENT> <DEDENT> c += len ( lengths ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> print ( * ans ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> b . append ( a [ i ] [ 0 ] . upper ( ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( b [ 0 ] + b [ 1 ] + b [ 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> rst , min_val = 0 , 10 ** 6 <NEWLINE> for i in P_ls : <NEWLINE> <INDENT> if min_val >= i : <NEWLINE> <INDENT> rst += 1 <NEWLINE> min_val = i <NEWLINE> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> s += 1 <NEWLINE> if j != i // j : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a . append ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 8 and i % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def digit_sum ( num ) : <NEWLINE> <INDENT> digit_sum = 0 <NEWLINE> while ( num > 0 ) : <NEWLINE> <INDENT> digit_sum += num % 10 <NEWLINE> num = int ( num / 10 ) <NEWLINE> <DEDENT> return digit_sum <NEWLINE> <NL> <DEDENT> min_num = 100000 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> B = N - A <NEWLINE> digit_num = digit_sum ( A ) <NEWLINE> digit_num += digit_sum ( B ) <NEWLINE> if digit_num < min_num : <NEWLINE> <INDENT> min_num = digit_num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * L , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> from bisect import * <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += bisect_left ( L , L [ i ] + L [ j ] ) - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> mls = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> mls [ i ] = max ( mls [ i - 1 ] , a ) <NEWLINE> <NL> <DEDENT> mrs = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> for i , a in enumerate ( A [ : : - 1 ] , 1 ) : <NEWLINE> <INDENT> mrs [ i ] = max ( mrs [ i - 1 ] , a ) <NEWLINE> <DEDENT> mrs = mrs [ : : - 1 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( max ( mls [ i ] , mrs [ i + 1 ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import bisect <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> an = bisect . bisect_left ( A , b ) <NEWLINE> cn = N - bisect . bisect_right ( C , b ) <NEWLINE> ans += an * cn <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import collections as c <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = c . Counter ( x ) <NEWLINE> s = [ ] <NEWLINE> for i in y . items ( ) : <NEWLINE> <INDENT> s . append ( [ i [ 1 ] , i [ 0 ] ] ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) - k ) : <NEWLINE> <INDENT> ans += s [ i ] [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if S_list [ 1 ] - S_list [ 0 ] == S_list [ 2 ] - S_list [ 1 ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> ans = dp [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> begin = 0 <NEWLINE> end = a [ 0 ] - 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> end = a [ i ] - 1 <NEWLINE> ans *= dp [ end - begin ] <NEWLINE> <NL> if ( i + 1 < m and a [ i + 1 ] == a [ i ] + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> begin = end + 2 <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= dp [ n - a [ m - 1 ] - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rate = [ 0 ] * 8 <NEWLINE> cnt = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> r = x // 400 <NEWLINE> if r > 7 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif not rate [ r ] : <NEWLINE> <INDENT> rate [ r ] = 1 <NEWLINE> <DEDENT> <DEDENT> s = sum ( rate ) <NEWLINE> mins = s <NEWLINE> if cnt > 0 : <NEWLINE> <INDENT> mins += 1 <NEWLINE> if s > 0 : <NEWLINE> <INDENT> mins -= 1 <NEWLINE> <DEDENT> <DEDENT> maxs = s + cnt <NEWLINE> print ( mins , maxs ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def ans120 ( A : int , B : int , K : int ) : <NEWLINE> <INDENT> l = sorted ( [ A , B ] ) <NEWLINE> ans_list = [ ] <NEWLINE> for i in range ( 1 , l [ 1 ] + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> ans_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans_list [ - K ] <NEWLINE> <NL> <DEDENT> print ( ans120 ( A , B , K ) ) <NEWLINE>
import math <NEWLINE> N , M = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> Length = N * M // math . gcd ( N , M ) <NEWLINE> Flag = True <NEWLINE> SIndex = [ Nk * ( Length // N ) for Nk in range ( 0 , N ) ] <NEWLINE> SList = list ( S ) <NEWLINE> <NL> for Mk in range ( 0 , M ) : <NEWLINE> <INDENT> if Mk % ( Length // N ) == 0 : <NEWLINE> <INDENT> MInd = SIndex . index ( Mk * ( Length // M ) ) <NEWLINE> if SList [ MInd ] != T [ Mk ] : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( Length ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> P = 10 ** 9 + 7 <NEWLINE> Q = 13 <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> dp = [ [ 0 ] * Q for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D = S [ i ] <NEWLINE> if D == - 1 : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( Q ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ ( 10 * j + d ) % Q ] += dp [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = int ( D ) <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ ( 10 * j + d ) % Q ] += dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] %= P <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ N ] [ 5 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . rstrip ( ) <NEWLINE> <NL> S = np . array ( [ int ( s ) if s != <STRING> else - 1 for s in S ] , dtype = np . int64 ) <NEWLINE> ans = solve ( S ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K % 2 == 1 : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT> elif K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H . sort ( ) <NEWLINE> if ( N < K ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> H [ N - i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( H ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> cnt = [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = LI_ ( ) <NEWLINE> cnt [ a ] += 1 <NEWLINE> cnt [ b ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( [ i for i in cnt if i % 2 == 0 ] ) == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
ABCD = input ( ) . strip ( ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> ope = [ { 0 : <STRING> , 1 : <STRING> } [ ( i >> j ) & 1 ] for j in range ( 3 ) ] <NEWLINE> fomula = ABCD [ 0 ] + ope [ 0 ] + ABCD [ 1 ] + ope [ 1 ] + ABCD [ 2 ] + ope [ 2 ] + ABCD [ 3 ] <NEWLINE> if eval ( fomula ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for edge in edges : <NEWLINE> <INDENT> tree [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> tree [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <NL> <DEDENT> depth = [ - 1 ] * ( N + 1 ) <NEWLINE> depth [ 1 ] = 0 <NEWLINE> count = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p ] += x <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( tree , s ) : <NEWLINE> <INDENT> for l in tree [ s ] : <NEWLINE> <INDENT> if depth [ l ] == - 1 : <NEWLINE> <INDENT> depth [ l ] = 0 <NEWLINE> count [ l ] += count [ s ] <NEWLINE> dfs ( tree , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( tree , 1 ) <NEWLINE> <NL> <NL> for i in count [ 1 : ] : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s [ 0 ] == s [ n - 1 ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] and d == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> d = 0 <NEWLINE> <DEDENT> elif s [ i - 1 ] == s [ i ] and d == 0 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> <DEDENT> if d == 0 : <NEWLINE> <INDENT> print ( ans * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] and d == 1 : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> d = 0 <NEWLINE> <DEDENT> elif s [ i - 1 ] == s [ i ] and d == 0 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> <DEDENT> if d == 1 : <NEWLINE> <INDENT> print ( ans + ans2 * ( k - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( ( ans + ans2 ) * k // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ans + ans2 ) * ( k // 2 ) + ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif s [ 0 ] != s [ n - 1 ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] and d == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> d = 0 <NEWLINE> <DEDENT> elif s [ i - 1 ] == s [ i ] and d == 0 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * k ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def calc_counts ( n , edges ) : <NEWLINE> <INDENT> counts = [ 0 ] * n <NEWLINE> seen = [ False ] * n <NEWLINE> dfs ( 0 , edges , seen , counts ) <NEWLINE> return counts <NEWLINE> <NL> <NL> <DEDENT> def dfs ( node , edges , seen , counts ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> seen [ node ] = True <NEWLINE> for to in edges [ node ] : <NEWLINE> <INDENT> if seen [ to ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += dfs ( to , edges , seen , counts ) <NEWLINE> <DEDENT> counts [ node ] = count <NEWLINE> return count <NEWLINE> <NL> <NL> <DEDENT> def calc_blank ( node , counts : list , edges , all , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> n = len ( counts ) <NEWLINE> paths = edges [ node ] <NEWLINE> if len ( paths ) <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> base = counts [ node ] <NEWLINE> result = all - 1 <NEWLINE> for v in paths : <NEWLINE> <INDENT> count = counts [ v ] <NEWLINE> if count > base : <NEWLINE> <INDENT> count = n - base <NEWLINE> <DEDENT> result -= pow ( 2 , count , mod ) - 1 <NEWLINE> result %= mod <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> counts = calc_counts ( n , edges ) <NEWLINE> all = pow ( 2 , n - 1 , mod ) <NEWLINE> blanks = 0 <NEWLINE> for node in range ( n ) : <NEWLINE> <INDENT> blank = calc_blank ( node , counts , edges , all ) <NEWLINE> blanks += blank <NEWLINE> blanks %= mod <NEWLINE> <NL> <DEDENT> inv_denominator = pow ( pow ( 2 , n , mod ) , mod - 2 , mod ) <NEWLINE> ans = blanks * inv_denominator % mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> A . append ( ( X [ i ] [ 0 ] - X [ j ] [ 0 ] , X [ i ] [ 1 ] - X [ j ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> C = Counter ( A ) <NEWLINE> print ( N - C . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> [ print ( x , end = <STRING> ) for x in B ] <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ARR = [ ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ARR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> BRR = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> BRR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def prepare ( n , q , arr , brr ) : <NEWLINE> <INDENT> nodePoints = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> nodeIndex = brr [ i ] [ 0 ] - 1 <NEWLINE> nodePoints [ nodeIndex ] += brr [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> nodes = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> <NL> nodes [ startNode ] . append ( endNode ) <NEWLINE> nodes [ endNode ] . append ( startNode ) <NEWLINE> <NL> <DEDENT> return nodes , nodePoints <NEWLINE> <NL> <NL> <DEDENT> nodes , nodePoints = prepare ( N , Q , ARR , BRR ) <NEWLINE> <NL> <NL> def dfs ( currentNode , nodes , parentNode = - 1 , parentPoint = 0 ) : <NEWLINE> <INDENT> nodePoints [ currentNode ] = nodePoints [ currentNode ] + parentPoint <NEWLINE> childNodes = nodes [ currentNode ] <NEWLINE> for childNode in childNodes : <NEWLINE> <INDENT> if childNode == parentNode : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( childNode , nodes , currentNode , nodePoints [ currentNode ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , nodes ) <NEWLINE> <NL> print ( <STRING> . join ( [ str ( nodePoints [ i ] ) for i in range ( N ) ] ) ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> cntb = 0 <NEWLINE> cntw = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cntb += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cntw += cntb <NEWLINE> <DEDENT> <DEDENT> print ( cntw ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] += 11 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if W == 1 : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if ans [ i ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> ans [ i ] = map ( str , ans [ i ] ) <NEWLINE> ans [ i ] = <STRING> . join ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if ans [ i ] [ j + 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> if ans [ i ] [ j - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ j - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ j ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ j + 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ j - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ j ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ j + 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ W - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ W - 2 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ W - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ W - 2 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ans [ i ] [ j ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = map ( str , ans [ i ] ) <NEWLINE> ans [ i ] = <STRING> . join ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> cards = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> integers = [ x - a for x in cards ] <NEWLINE> cards . append ( a ) <NEWLINE> f = max ( cards ) * n <NEWLINE> <NL> <NL> dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 * f + 1 ) ] <NEWLINE> <NL> for y in range ( n + 1 ) : <NEWLINE> <INDENT> for x in range ( 2 * f + 1 ) : <NEWLINE> <INDENT> if y == 0 and x == f : <NEWLINE> <INDENT> dp [ x ] [ y ] = 1 <NEWLINE> <DEDENT> elif y > 0 and ( x - integers [ y - 1 ] < 0 or x - integers [ y - 1 ] > 2 * f ) : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x ] [ y - 1 ] <NEWLINE> <DEDENT> elif y > 0 and x - integers [ y - 1 ] >= 0 and x - integers [ y - 1 ] <= 2 * f : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x - integers [ y - 1 ] ] [ y - 1 ] + dp [ x ] [ y - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] [ y ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ f ] [ n ] - 1 ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> colors = [ 0 ] * 9 <NEWLINE> for a in A : <NEWLINE> <INDENT> idx = a // 400 <NEWLINE> if idx >= 8 : <NEWLINE> <INDENT> idx = 8 <NEWLINE> <DEDENT> colors [ idx ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if colors [ i ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> max_ans = ans <NEWLINE> if colors [ 8 ] > 0 : <NEWLINE> <INDENT> max_ans += colors [ 8 ] <NEWLINE> <NL> <DEDENT> if ans == 0 and max_ans > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans , max_ans ) <NEWLINE>
import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> if s [ a ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> s [ a ] = 1 <NEWLINE> if not <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = input ( ) <NEWLINE> my_list = [ ] <NEWLINE> j = 0 <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> my_list . append ( i ) <NEWLINE> <NL> <DEDENT> if my_list [ 0 ] == my_list [ 1 ] == my_list [ 2 ] or my_list [ 1 ] == my_list [ 2 ] == my_list [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> node = [ [ ] for _ in range ( n ) ] <NEWLINE> looked = [ 1 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> node [ b - 1 ] . append ( a - 1 ) <NEWLINE> node [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> counter = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <DEDENT> queue = deque ( [ 0 ] ) <NEWLINE> looked [ 0 ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . pop ( ) <NEWLINE> for i in node [ now ] : <NEWLINE> <INDENT> if looked [ i ] : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> counter [ i ] += counter [ now ] <NEWLINE> looked [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * counter ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> ans = 2 * ( sum ( a [ n // 2 : ] ) - sum ( a [ : n // 2 ] ) ) <NEWLINE> ans += a [ n // 2 - 1 ] - a [ n // 2 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif n % 2 == 1 : <NEWLINE> <INDENT> ans = 2 * ( sum ( a [ n // 2 + 1 : ] ) - sum ( a [ : n // 2 ] ) ) <NEWLINE> print ( max ( ans + a [ n // 2 ] - a [ n // 2 + 1 ] , <NEWLINE> <INDENT> ans - a [ n // 2 ] + a [ n // 2 - 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> kotae = 0 <NEWLINE> for Z in range ( K + 1 ) : <NEWLINE> <INDENT> X_plus_Y = S - Z <NEWLINE> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> X = X_plus_Y - Y <NEWLINE> if 0 <= X <= K : <NEWLINE> <INDENT> kotae += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( n , a , b ) : <NEWLINE> <INDENT> delta = [ b [ i ] - a [ i ] for i in range ( n ) ] <NEWLINE> need = list ( x for x in delta if x > 0 ) <NEWLINE> amari = list ( sorted ( ( abs ( x ) for x in delta if x < 0 ) , reverse = True ) ) <NEWLINE> needScore = sum ( need ) <NEWLINE> if needScore > sum ( amari ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> k = 0 <NEWLINE> s = 0 <NEWLINE> while s < needScore : <NEWLINE> <INDENT> s += amari [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> return k + len ( need ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( N , a , b ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> cnt_ac = 0 <NEWLINE> cnt_wa = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if p not in d : <NEWLINE> <INDENT> d [ p ] = [ s ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ p ] . append ( s ) <NEWLINE> <DEDENT> <DEDENT> for i in d : <NEWLINE> <INDENT> if <STRING> in d [ i ] : <NEWLINE> <INDENT> cnt_ac += 1 <NEWLINE> cnt_wa += d [ i ] . index ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt_ac , cnt_wa ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> vertex = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> p -= 1 <NEWLINE> vertex [ p ] += x <NEWLINE> <NL> <NL> <DEDENT> def dfs ( n , parent ) : <NEWLINE> <INDENT> for to in edge [ n ] : <NEWLINE> <INDENT> if to == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> vertex [ to ] += vertex [ n ] <NEWLINE> dfs ( to , n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * vertex ) <NEWLINE>
L , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * L <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( b ) <NEWLINE> y . append ( c ) <NEWLINE> <DEDENT> if max ( x ) <= min ( y ) : <NEWLINE> <INDENT> print ( - max ( x ) + min ( y ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = input ( ) <NEWLINE> num = len ( s ) <NEWLINE> l , r = 0 , num - 1 <NEWLINE> ans = 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if s [ l ] == s [ r ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> dl = [ ] <NEWLINE> dr = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dl . append ( line [ 0 ] ) <NEWLINE> dr . append ( line [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp_S = S [ i : i + 2 ] <NEWLINE> if tmp_S == <STRING> : <NEWLINE> <INDENT> a . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> s = [ 0 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s . append ( s [ i ] + a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = [ ] <NEWLINE> for l , r in zip ( dl , dr ) : <NEWLINE> <INDENT> ans . append ( s [ r - 1 ] - s [ l - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> def abc ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) / 2 <NEWLINE> <NL> <DEDENT> cb = list ( map ( abc , c ) ) <NEWLINE> <NL> s = sum ( cb [ : b ] ) <NEWLINE> l . append ( s ) <NEWLINE> <NL> for i in range ( b , a ) : <NEWLINE> <INDENT> s = s - cb [ i - b ] + cb [ i ] <NEWLINE> l . append ( s ) <NEWLINE> <NL> <DEDENT> L = sorted ( l ) <NEWLINE> print ( L [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> AB = [ LI ( ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> link = [ [ ] for _ in range ( N ) ] <NEWLINE> children = [ [ ] for _ in range ( N ) ] <NEWLINE> w = [ 1 ] * N <NEWLINE> visit = [ False ] * N <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def create_link ( ) : <NEWLINE> <INDENT> for a , b in AB : <NEWLINE> <INDENT> link [ a - 1 ] . append ( b - 1 ) <NEWLINE> link [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> visit [ s ] = True <NEWLINE> for t in link [ s ] : <NEWLINE> <INDENT> if visit [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> children [ s ] . append ( t ) <NEWLINE> dfs ( t ) <NEWLINE> w [ s ] += w [ t ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def modinv ( x ) : <NEWLINE> <INDENT> return pow ( x , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> create_link ( ) <NEWLINE> dfs ( 0 ) <NEWLINE> p2 = [ None ] * ( N + 1 ) <NEWLINE> p2 [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p2 [ i + 1 ] = 2 * p2 [ i ] % MOD <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = p2 [ N - w [ i ] ] <NEWLINE> for j in children [ i ] : <NEWLINE> <INDENT> s = ( s + p2 [ w [ j ] ] - 1 ) % MOD <NEWLINE> <DEDENT> x = ( x + p2 [ N - 1 ] - s ) % MOD <NEWLINE> <DEDENT> y = p2 [ N ] <NEWLINE> <NL> ans = x * modinv ( y ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> counter = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( now , prev ) : <NEWLINE> <INDENT> for next in edges [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ next ] += counter [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * counter ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT> if b [ i ] < i : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> d = sum ( c ) <NEWLINE> e = 0 <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> e = e + c [ - i ] <NEWLINE> <DEDENT> print ( d - e ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> d = [ <STRING> * 5010 ] * 5 <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i , i + k ) : <NEWLINE> <INDENT> x = s [ i : j + 1 ] <NEWLINE> if x in d or x == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l = 0 <NEWLINE> while l < 5 and x > d [ l ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if l < 5 : <NEWLINE> <INDENT> d = d [ 0 : l ] + [ x ] + d [ l : ] <NEWLINE> d = d [ 0 : 5 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( d [ k - 1 ] ) <NEWLINE>
N = input ( ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> num_count = [ False ] * 10 <NEWLINE> for i in range ( len ( S ) - 2 ) : <NEWLINE> <INDENT> s_i = int ( S [ i ] ) <NEWLINE> if num_count [ s_i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_count [ s_i ] = True <NEWLINE> num_count_2 = [ False ] * 10 <NEWLINE> for j in range ( i + 1 , len ( S ) - 1 ) : <NEWLINE> <INDENT> s_j = int ( S [ j ] ) <NEWLINE> if num_count_2 [ s_j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_count_2 [ s_j ] = True <NEWLINE> num_count_3 = [ False ] * 10 <NEWLINE> for k in range ( j + 1 , len ( S ) ) : <NEWLINE> <INDENT> s_k = int ( S [ k ] ) <NEWLINE> if num_count_3 [ s_k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_count_3 [ s_k ] = True <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lo_d , up_d = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lo_d . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> up_d . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lo_d + up_d [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> List = make_divisors ( N ) <NEWLINE> len_a = len ( List ) <NEWLINE> ans = List [ len_a // 2 ] <NEWLINE> print ( math . floor ( math . log ( ans , 10 ) ) + 1 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = Counter ( a ) . most_common ( ) <NEWLINE> num = 0 <NEWLINE> for i , j in a : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> num += ( j - i ) <NEWLINE> <DEDENT> elif j < i : <NEWLINE> <INDENT> num += j <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> import math <NEWLINE> <NL> @ numba . njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> dpt = np . array ( [ math . inf ] * ( 10 ** 3 * N + 1 ) ) <NEWLINE> dpt [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( dpt ) - 1 , items [ i ] [ 1 ] - 1 , - 1 ) : <NEWLINE> <INDENT> dpt [ j ] = min ( dpt [ j ] , dpt [ j - items [ i ] [ 1 ] ] + items [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( dpt ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if dpt [ i ] <= W : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> items = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in product ( range ( 10 ) , repeat = 3 ) : <NEWLINE> <INDENT> a = s . find ( str ( i [ 0 ] ) ) <NEWLINE> if a != - 1 and a != n - 1 : <NEWLINE> <INDENT> b = s [ a + 1 : ] . find ( str ( i [ 1 ] ) ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> b += a + 1 <NEWLINE> if b != n - 1 : <NEWLINE> <INDENT> c = s [ b + 1 : ] . find ( str ( i [ 2 ] ) ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> s_list = list ( s ) <NEWLINE> length = len ( s ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> o = [ ] <NEWLINE> x = deque ( sorted ( set ( s ) ) ) <NEWLINE> <NL> while len ( o ) < K : <NEWLINE> <INDENT> letter = x . popleft ( ) <NEWLINE> X = [ i for i , x in enumerate ( s_list ) if x == letter ] <NEWLINE> for i in X : <NEWLINE> <INDENT> for j in range ( i + 1 , length + 1 ) : <NEWLINE> <INDENT> if not s [ i : j ] in o : <NEWLINE> <INDENT> o . append ( s [ i : j ] ) <NEWLINE> <DEDENT> if j - 1 - i == 5 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> o . sort ( ) <NEWLINE> print ( o [ K - 1 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> N = i ( ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if 2 * N <= ( i + 1 ) * i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if 0 <= z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> candi = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> : <NEWLINE> <INDENT> candi . append ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> col_s = collections . Counter ( candi ) <NEWLINE> combi_s = itertools . combinations ( list ( col_s ) , 3 ) <NEWLINE> counter = 0 <NEWLINE> for i in combi_s : <NEWLINE> <INDENT> counter += col_s [ i [ 0 ] ] * col_s [ i [ 1 ] ] * col_s [ i [ 2 ] ] <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> c0 , c1 = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ c0 - c1 , c0 + c1 ] ) <NEWLINE> <DEDENT> a . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> ans , b = 1 , a [ 0 ] [ 1 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> if b <= i [ 0 ] : <NEWLINE> <INDENT> b = i [ 1 ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , itertools , collections , bisect <NEWLINE> input = lambda : sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> inf = float ( <STRING> ) ; mod = 10 ** 9 + 7 <NEWLINE> mans = inf ; ans = 0 ; count = 0 ; pro = 1 <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> nn = [ a , b , c , d , e ] <NEWLINE> s = False <NEWLINE> for i in nn : <NEWLINE> <INDENT> if s == False and i % 10 != 0 : <NEWLINE> <INDENT> chk = i % 10 <NEWLINE> last = i <NEWLINE> s = True <NEWLINE> <DEDENT> elif s == False and i % 10 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s == True and i % 10 != 0 : <NEWLINE> <INDENT> if chk > i % 10 : <NEWLINE> <INDENT> chk = i % 10 <NEWLINE> last = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s == False : <NEWLINE> <INDENT> last = a <NEWLINE> <COMMENT> <NL> <DEDENT> s = False <NEWLINE> for i in nn : <NEWLINE> <INDENT> if s == False and i == last : <NEWLINE> <INDENT> ans += i <NEWLINE> s = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 10 == 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i + ( 10 - i % 10 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li_X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> li_X . sort ( ) <NEWLINE> li_X_delta = [ ] <NEWLINE> for i in range ( len ( li_X ) - 1 ) : <NEWLINE> <INDENT> li_X_delta . append ( li_X [ i + 1 ] - li_X [ i ] ) <NEWLINE> <DEDENT> li_X_delta . sort ( reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> <NL> ans = li_X [ - 1 ] - li_X [ 0 ] <NEWLINE> for i in range ( min ( n - 1 , len ( li_X_delta ) ) ) : <NEWLINE> <INDENT> ans -= li_X_delta [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 2 * x and h == 2 * y : <NEWLINE> <INDENT> print ( w * h / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> al = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> al [ i ] = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> n = 1 <NEWLINE> cnt = 1 <NEWLINE> visited = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> visited [ 1 ] = 1 <NEWLINE> while al [ n ] != 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n = al [ n ] <NEWLINE> if visited [ n ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ n ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> dp = np . zeros ( n , dtype = int ) <NEWLINE> <COMMENT> <NL> h = np . array ( h ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = max ( 0 , i - k ) <NEWLINE> <COMMENT> <NL> dp [ i ] = min ( dp [ start : i ] + np . abs ( h [ i ] - h [ start : i ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
count = 0 <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( a + 1 ) : <NEWLINE> <INDENT> z = b - i - j <NEWLINE> if 0 <= z <= a : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> B = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> C = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> def isok_A ( index , key , arr ) : <NEWLINE> <INDENT> if arr [ index ] >= key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def Binary_search_A ( key , arr ) : <NEWLINE> <NL> <INDENT> ng = - 1 <NEWLINE> ok = len ( arr ) <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isok_A ( mid , key , arr ) is True : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ng , ok <NEWLINE> <NL> <DEDENT> def isok_B ( index , key , arr ) : <NEWLINE> <INDENT> if arr [ index ] > key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def Binary_search_B ( key , arr ) : <NEWLINE> <NL> <INDENT> ng = - 1 <NEWLINE> ok = len ( arr ) <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isok_B ( mid , key , arr ) is True : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ng , ok <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> ng_a , ok_b = Binary_search_A ( i , A ) <NEWLINE> ng_c , ok_c = Binary_search_B ( i , C ) <NEWLINE> cnt += ( ng_a + 1 ) * ( N - ok_c ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , min ( b , a + k - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a + k ) , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * P , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mi = P [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < mi : mi = P [ i ] <NEWLINE> if P [ i ] <= mi : cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cyaku = b // c <NEWLINE> dyaku = b // d <NEWLINE> <NL> <NL> cds = b // ( ( c * d ) // ( math . gcd ( c , d ) ) ) <NEWLINE> <NL> x = b - ( cyaku + dyaku - cds ) <NEWLINE> <NL> cyaku2 = ( a - 1 ) // c <NEWLINE> dyaku2 = ( a - 1 ) // d <NEWLINE> <NL> cds2 = ( a - 1 ) // ( ( c * d ) // ( math . gcd ( c , d ) ) ) <NEWLINE> <NL> y = ( a - 1 ) - ( cyaku2 + dyaku2 - cds2 ) <NEWLINE> <NL> print ( x - y ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> sumn = 0 <NEWLINE> i , k = 0 , 1 <NEWLINE> while k <= h : <NEWLINE> <INDENT> sumn += k <NEWLINE> i += 1 <NEWLINE> k = 2 ** i <NEWLINE> <NL> <DEDENT> print ( sumn ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> ans += bisect_left ( l , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> dp = [ 0 ] * 20001 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( dp [ h - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for a in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> b = N // a <NEWLINE> s = max ( len ( str ( a ) ) , len ( str ( b ) ) ) <NEWLINE> l . append ( int ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE>
MAX = 10 ** 5 + 1 <NEWLINE> f = [ True ] * ( MAX ) <NEWLINE> c = [ 0 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> if f [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , MAX , i ) : <NEWLINE> <INDENT> f [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 , MAX , 2 ) : <NEWLINE> <INDENT> if f [ i ] and f [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 , MAX ) : <NEWLINE> <INDENT> c [ i ] += c [ i - 1 ] <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( c [ r ] - c [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
s = str ( input ( ) ) <NEWLINE> x = s . count ( <STRING> ) <NEWLINE> y = s . count ( <STRING> ) <NEWLINE> print ( min ( x , y ) * 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> from itertools import groupby <NEWLINE> <NL> gr = groupby ( s ) <NEWLINE> <COMMENT> <NL> flg = 0 <NEWLINE> black = [ ] <NEWLINE> white = [ ] <NEWLINE> for k , v in gr : <NEWLINE> <INDENT> if flg == 0 and k == <STRING> : <NEWLINE> <INDENT> flg = 1 <NEWLINE> black . append ( len ( list ( v ) ) ) <NEWLINE> <DEDENT> elif flg == 1 : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> black . append ( len ( list ( v ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white . append ( len ( list ( v ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( black ) == 0 or len ( white ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> cnt = sum ( white ) <NEWLINE> ans = [ cnt ] <NEWLINE> for i in range ( len ( white ) ) : <NEWLINE> <INDENT> cnt += ( black [ i ] - white [ i ] ) <NEWLINE> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE> <NL> <NL> <NL>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ i + 1 ] = A [ i ] <NEWLINE> <DEDENT> C = [ ] <NEWLINE> for k , v in D . items ( ) : <NEWLINE> <INDENT> [ C . append ( k ) for _ in range ( v ) ] <NEWLINE> <DEDENT> h = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h += 1 <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> print ( C [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> [ C . pop ( 0 ) for _ in range ( W ) ] <NEWLINE> if h == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h += 1 <NEWLINE> for i in reversed ( range ( W ) ) : <NEWLINE> <INDENT> print ( C [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> [ C . pop ( 0 ) for _ in range ( W ) ] <NEWLINE> if h == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> now = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> ans = [ now ] <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> now = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> if now > ans [ 0 ] : <NEWLINE> <INDENT> ans [ 0 ] = now <NEWLINE> <DEDENT> elif ans [ - 1 ] >= now : <NEWLINE> <INDENT> ans . append ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> left = 0 <COMMENT> <NEWLINE> right = len ( ans ) - 1 <COMMENT> <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if now > ans [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ right ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( max ( a ) + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , c [ i ] + c [ i - 1 ] + c [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def soinsu_bunkai ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> <NL> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> pf [ m ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> def cmb ( n , r , p ) : <NEWLINE> <NL> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = mod <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = soinsu_bunkai ( M ) <NEWLINE> ans = 1 <NEWLINE> <NL> n = 10 ** 5 + 100 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> for i in a . values ( ) : <NEWLINE> <INDENT> x = cmb ( N + i - 1 , i , mod ) <NEWLINE> ans *= x <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
<STRING> <NEWLINE> from copy import deepcopy <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> def getMinSteps ( ) : <NEWLINE> <INDENT> dp_2 = [ 0 , ] <NEWLINE> dp_1 = [ abs ( arr [ 1 ] - arr [ 0 ] ) , ] <NEWLINE> <NL> total_cost = 0 <NEWLINE> i = 2 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> diff1 = abs ( arr [ i ] - arr [ i - 1 ] ) <NEWLINE> diff2 = abs ( arr [ i ] - arr [ i - 2 ] ) <NEWLINE> temp = deepcopy ( dp_2 ) <NEWLINE> dp_2 = deepcopy ( dp_1 ) <NEWLINE> <NL> for j in range ( len ( dp_1 ) ) : <NEWLINE> <INDENT> dp_1 [ j ] += diff1 <NEWLINE> <NL> <DEDENT> for j in range ( len ( temp ) ) : <NEWLINE> <INDENT> dp_1 . append ( temp [ j ] + diff2 ) <NEWLINE> <NL> <DEDENT> dp_1 = sorted ( dp_1 ) [ 0 : 2 ] <NEWLINE> <NL> i += 1 <NEWLINE> <DEDENT> return min ( dp_1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( getMinSteps ( ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> def dist ( x , s , t ) : <NEWLINE> <INDENT> if s < x and t < x : <NEWLINE> <INDENT> return x - min ( s , t ) <NEWLINE> <DEDENT> elif s > x and t > x : <NEWLINE> <INDENT> return max ( s , t ) - x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ds : = abs ( x - s ) ) <= ( dt : = abs ( x - t ) ) : <NEWLINE> <INDENT> return 2 * ds + dt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ds + 2 * dt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def near ( A , x ) : <NEWLINE> <INDENT> if ( i : = bisect_left ( A , x ) ) == 0 : <NEWLINE> <INDENT> return [ A [ 0 ] , ] <NEWLINE> <DEDENT> elif 0 < i < len ( A ) : <NEWLINE> <INDENT> return [ A [ i - 1 ] , A [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ A [ - 1 ] , ] <NEWLINE> <DEDENT> <DEDENT> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( a ) ] <NEWLINE> T = [ int ( input ( ) ) for _ in range ( b ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = 100000000000 <NEWLINE> for s in near ( S , x ) : <NEWLINE> <INDENT> for t in near ( T , x ) : <NEWLINE> <INDENT> ans = min ( ans , dist ( x , s , t ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) <NEWLINE> list_A = A . split ( ) <NEWLINE> waza = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> waza = waza + int ( list_A [ i ] ) <NEWLINE> <DEDENT> if waza >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if any ( i % 2 != 0 for i in [ a , b , c ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if a == b and b == c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> a_list = [ 0 ] * ( 1001001 ) <NEWLINE> b_list = [ 0 ] * ( 1001001 ) <NEWLINE> c_list = [ 0 ] * ( 1001001 ) <NEWLINE> a_list [ 0 ] = a <NEWLINE> b_list [ 0 ] = b <NEWLINE> c_list [ 0 ] = c <NEWLINE> <NL> for i in range ( 1 , 1001001 ) : <NEWLINE> <INDENT> a_list [ i ] = ( b_list [ i - 1 ] + c_list [ i - 1 ] ) // 2 <NEWLINE> b_list [ i ] = ( c_list [ i - 1 ] + a_list [ i - 1 ] ) // 2 <NEWLINE> c_list [ i ] = ( a_list [ i - 1 ] + b_list [ i - 1 ] ) // 2 <NEWLINE> cnt += 1 <NEWLINE> if a_list [ i ] % 2 != 0 or b_list [ i ] % 2 != 0 or c_list [ i ] % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> <NL> v = [ 0 ] * 2 * 10 ** 5 <NEWLINE> seen = set ( [ 0 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v [ i + 1 ] = A [ i ] + v [ i ] <NEWLINE> v [ i + 1 ] %= M <NEWLINE> seen . add ( v [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> counts = { x : 0 for x in seen } <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> counts [ v [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for _ , count in counts . items ( ) : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , T = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N0 = 2 ** ( N - 1 ) . bit_length ( ) <NEWLINE> data = [ 0 ] * ( 2 * N0 ) <NEWLINE> <NL> <COMMENT> <NL> def init ( A ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> data [ i + N0 - 1 ] = A [ i ] <NEWLINE> <DEDENT> for i in range ( N0 - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> data [ i ] = max ( data [ 2 * i + 1 ] , data [ 2 * i + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def update ( k , x ) : <NEWLINE> <INDENT> k += N0 - 1 <NEWLINE> data [ k ] = x <NEWLINE> while k >= 0 : <NEWLINE> <INDENT> k = ( k - 1 ) // 2 <NEWLINE> data [ k ] = max ( data [ 2 * k + 1 ] , data [ 2 * k + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def query ( l , r ) : <NEWLINE> <INDENT> L = l + N0 ; R = r + N0 <NEWLINE> s = 0 <NEWLINE> while L < R : <NEWLINE> <INDENT> if R & 1 : <NEWLINE> <INDENT> R -= 1 <NEWLINE> s = max ( s , data [ R - 1 ] ) <NEWLINE> <NL> <DEDENT> if L & 1 : <NEWLINE> <INDENT> s = max ( s , data [ L - 1 ] ) <NEWLINE> L += 1 <NEWLINE> <DEDENT> L >>= 1 ; R >>= 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> init ( A ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> high = query ( i + 1 , N + 1 ) <NEWLINE> p = high - a <NEWLINE> d [ p ] += 1 <NEWLINE> <DEDENT> d = sorted ( d . items ( ) , reverse = True ) <NEWLINE> print ( d [ 0 ] [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( l [ i + 1 ] + l [ i ] ) <NEWLINE> <DEDENT> print ( l [ n ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> student = list ( range ( N ) ) <NEWLINE> <NL> student . sort ( key = lambda i : list_A [ i ] ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += str ( student [ i ] + 1 ) + <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> ans = ans . strip ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> node = [ [ ] * n for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> node [ b ] . append ( a ) <NEWLINE> node [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> ans [ p ] += x <NEWLINE> <NL> <DEDENT> root = [ 0 ] * n <NEWLINE> edge = [ [ ] * n for i in range ( n ) ] <NEWLINE> root [ 0 ] = 0 <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> while q : <NEWLINE> <INDENT> r = q . popleft ( ) <NEWLINE> for e in node [ r ] : <NEWLINE> <INDENT> if not visited [ e ] : <NEWLINE> <INDENT> visited [ e ] = True <NEWLINE> q . append ( e ) <NEWLINE> root [ e ] = r <NEWLINE> edge [ r ] . append ( e ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> p = [ 0 ] * n <NEWLINE> q = deque ( edge [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> while q : <NEWLINE> <INDENT> e = q . popleft ( ) <NEWLINE> p [ e ] = p [ root [ e ] ] + 1 <NEWLINE> for e2 in edge [ e ] : <NEWLINE> <INDENT> if not visited [ e2 ] : <NEWLINE> <INDENT> visited [ e2 ] = True <NEWLINE> q . append ( e2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> p = sorted ( enumerate ( p ) , key = lambda x : x [ 1 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> e = p [ i ] [ 0 ] <NEWLINE> r = root [ e ] <NEWLINE> ans [ e ] += ans [ r ] <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import copy <NEWLINE> def py ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def pn ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def iin ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> return x <NEWLINE> <NL> <DEDENT> neko = 0 <NEWLINE> nya = 0 <NEWLINE> nuko = 0 <NEWLINE> <NL> a = [ ] <NEWLINE> n = iin ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( iin ( ) ) <NEWLINE> if neko < a [ i ] : <NEWLINE> <INDENT> neko = a [ i ] <NEWLINE> <DEDENT> <DEDENT> b = copy . copy ( a ) <NEWLINE> a . remove ( neko ) <NEWLINE> nya = max ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] == neko : <NEWLINE> <INDENT> print ( nya ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( neko ) <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if i + j <= s and s <= k + i + j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> def get_count_list ( s ) : <NEWLINE> <INDENT> alphabets = <STRING> <NEWLINE> ans = { } <NEWLINE> for alphabet in alphabets : <NEWLINE> <INDENT> ans [ alphabet ] = [ ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ s [ i ] ] . append ( i ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def get_index2alpha ( s ) : <NEWLINE> <INDENT> ans = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = s [ i ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> s_count = get_count_list ( s ) <NEWLINE> t_count = get_count_list ( t ) <NEWLINE> s_index = get_index2alpha ( s ) <NEWLINE> t_index = get_index2alpha ( t ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> s_set = set ( s ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s_alpha = s_index [ i ] <NEWLINE> t_alpha = t_index [ i ] <NEWLINE> if s_alpha in s_set : <NEWLINE> <INDENT> s_set . remove ( s_alpha ) <NEWLINE> if not s_count [ s_alpha ] == t_count [ t_alpha ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n , * v = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> v1 = Counter ( v [ : : 2 ] ) <NEWLINE> v2 = Counter ( v [ 1 : : 2 ] ) <NEWLINE> v1 = sorted ( [ ( i , v1 [ i ] ) for i in v1 . keys ( ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> v2 = sorted ( [ ( i , v2 [ i ] ) for i in v2 . keys ( ) ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> if v1 [ 0 ] [ 0 ] != v2 [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - v1 [ 0 ] [ 1 ] - v2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e1 = n - v2 [ 0 ] [ 1 ] if len ( v1 ) == 1 else n - v1 [ 1 ] [ 1 ] - v2 [ 0 ] [ 1 ] <NEWLINE> e2 = n - v1 [ 0 ] [ 1 ] if len ( v2 ) == 1 else n - v1 [ 0 ] [ 1 ] - v2 [ 1 ] [ 1 ] <NEWLINE> print ( min ( e1 , e2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( c ) for c in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> c1 , c2 , c3 = [ 0 , 0 , 0 ] <NEWLINE> ma = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if a [ i ] == a [ i - 1 ] + 1 : <NEWLINE> <INDENT> c1 = c2 <NEWLINE> c2 = c3 <NEWLINE> c3 = i <NEWLINE> <DEDENT> elif a [ i ] != a [ i - 1 ] : <NEWLINE> <INDENT> c1 , c2 , c3 = [ i , i , i ] <NEWLINE> <DEDENT> <DEDENT> if ma < i - c1 + 1 : <NEWLINE> <INDENT> ma = i - c1 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 400000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> paths = [ list ( ) for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ a ] . append ( b ) <NEWLINE> paths [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> counters = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> for x in px : <NEWLINE> <INDENT> counters [ x [ 0 ] ] += x [ 1 ] <NEWLINE> <NL> <DEDENT> visit = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> def dfs ( node , score , ans ) : <NEWLINE> <INDENT> visit [ node ] = 1 <COMMENT> <NEWLINE> score += counters [ node ] <COMMENT> <NEWLINE> ans [ node ] = score <COMMENT> <NEWLINE> for loof in paths [ node ] : <COMMENT> <NEWLINE> <INDENT> if visit [ loof ] == 0 : <COMMENT> <NEWLINE> <INDENT> dfs ( loof , score , ans ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , 0 , ans ) <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if s [ i - 2 ] == <STRING> and s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ( int ( v ) + 1 ) / 2 for v in input ( ) . split ( ) ] <NEWLINE> e = [ sum ( p [ : k ] ) ] <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> e . append ( e [ - 1 ] - p [ i ] + p [ i + k ] ) <NEWLINE> <DEDENT> print ( max ( e ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> left = 0 <NEWLINE> right = S [ 1 : N ] . count ( <STRING> ) <NEWLINE> ans = left + right <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> ans = min ( ans , left + right ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class Max_Bit : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . size = n <NEWLINE> self . tree = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def get_max ( self , i = None ) : <NEWLINE> <INDENT> if i is None : <NEWLINE> <INDENT> i = self . size <NEWLINE> <DEDENT> m = 0 <COMMENT> <NEWLINE> while i > 0 : <NEWLINE> <INDENT> m = max ( m , self . tree [ i ] ) <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] = max ( x , self . tree [ i ] ) <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = Max_Bit ( N ) <NEWLINE> sort_H_i = sorted ( ( h , i ) for i , h in enumerate ( H ) ) <NEWLINE> for h , i in sort_H_i : <NEWLINE> <INDENT> dp . update ( i + 1 , dp . get_max ( i ) + A [ i ] ) <NEWLINE> <DEDENT> print ( dp . get_max ( ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pn_list = [ 0 ] * n <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> ans_ac = 0 <NEWLINE> ans_pn = 0 <NEWLINE> pn_list [ 0 ] == - 1 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = input ( ) . split ( ) <NEWLINE> a [ i ] = ( int ( a [ i ] ) ) <NEWLINE> <COMMENT> <NL> if pn_list [ a [ i ] - 1 ] != - 1 : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> ans_pn += pn_list [ a [ i ] - 1 ] <NEWLINE> ans_ac += 1 <NEWLINE> pn_list [ a [ i ] - 1 ] = - 1 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pn_list [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans_ac , ans_pn ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> if x == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> for i in range ( 3 , int ( math . sqrt ( ans ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if ans % i == 0 : <NEWLINE> <INDENT> ans += 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> S1 = 0 <NEWLINE> S2 = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S1 += A [ i ] <NEWLINE> S2 += A [ i ] <NEWLINE> if i & 1 : <NEWLINE> <INDENT> if S1 >= 0 : <NEWLINE> <INDENT> ans1 += S1 + 1 <NEWLINE> S1 = - 1 <NEWLINE> <DEDENT> if S2 <= 0 : <NEWLINE> <INDENT> ans2 += 1 - S2 <NEWLINE> S2 = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S1 <= 0 : <NEWLINE> <INDENT> ans1 += 1 - S1 <NEWLINE> S1 = 1 <NEWLINE> <DEDENT> if S2 >= 0 : <NEWLINE> <INDENT> ans2 += S2 + 1 <NEWLINE> S2 = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans1 , ans2 ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ [ ] for i in range ( 10 ** 5 ) ] <NEWLINE> ans = 0 <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> al [ a - 1 ] += [ - b ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in al [ i ] : <NEWLINE> <INDENT> heapq . heappush ( h , j ) <NEWLINE> <DEDENT> if h : <NEWLINE> <INDENT> ans -= heapq . heappop ( h ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.7 ) + 3 ) : <NEWLINE> <INDENT> if n > cnt : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> cnt += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt - n in ans : <NEWLINE> <INDENT> ans . remove ( cnt - n ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def a ( t , i ) : <NEWLINE> <INDENT> if i == l : <NEWLINE> <INDENT> if eval ( t ) == 7 : <NEWLINE> <INDENT> print ( t + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> a ( t + <STRING> + s [ i + 1 ] , i + 1 ) <NEWLINE> a ( t + <STRING> + s [ i + 1 ] , i + 1 ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> l = len ( s ) - 1 <NEWLINE> a ( s [ 0 ] , 0 ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> n , m = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ab = [ [ ] for i in range ( 10 ** 5 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if a <= m : <NEWLINE> <INDENT> ab [ m - a ] . append ( - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for b in ab [ i ] : <NEWLINE> <INDENT> heappush ( l , b ) <NEWLINE> <NL> <DEDENT> if l : <NEWLINE> <INDENT> ans -= heappop ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> import math <NEWLINE> minn = 100000000000000000000 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> j = n / i <NEWLINE> minn = min ( int ( i + j - 2 ) , minn ) <NEWLINE> <DEDENT> <DEDENT> print ( minn ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> satu = [ 1000 , 5000 , 10000 ] <NEWLINE> <NL> sen = [ 1000 * i for i in range ( n + 1 ) ] <NEWLINE> gsen = [ 5000 * i for i in range ( n + 1 ) ] <NEWLINE> man = [ 10000 * i for i in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> if man [ i ] + gsen [ j ] + sen [ n - i - j ] == y : <NEWLINE> <INDENT> print ( i , j , n - i - j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> most = max ( a ) <NEWLINE> most_idx = a . index ( most ) <NEWLINE> second = max ( a [ : most_idx ] + a [ most_idx + 1 : ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( second if a [ i ] == most else most ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> counter = 0 <NEWLINE> for a , b , c in itertools . product ( range ( 10 ) , repeat = 3 ) : <NEWLINE> <NL> <INDENT> a_ind = S . find ( str ( a ) ) <NEWLINE> if a_ind == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_ind = S [ a_ind + 1 : ] . find ( str ( b ) ) <NEWLINE> if b_ind == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_ind = S [ a_ind + 1 + b_ind + 1 : ] . find ( str ( c ) ) <NEWLINE> if c_ind == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
s = input ( ) <NEWLINE> sr = s [ : : - 1 ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> st = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if sr [ i ] == <STRING> : <NEWLINE> <INDENT> en = len ( s ) - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( en - st + 1 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ ] <NEWLINE> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> line = list ( input ( ) ) <NEWLINE> G . append ( line ) <NEWLINE> black += line . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> ls = deque ( [ [ 0 , 0 , 0 ] ] ) <NEWLINE> D = [ [ float ( <STRING> ) ] * W for i in range ( H ) ] <NEWLINE> direction = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> find = False <NEWLINE> while len ( ls ) > 0 : <NEWLINE> <INDENT> h , w , depth = ls . popleft ( ) <NEWLINE> <NL> if h == H - 1 and w == W - 1 : <NEWLINE> <INDENT> route = depth + 1 <NEWLINE> find = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> for dh , dw in direction : <NEWLINE> <INDENT> if h + dh < 0 or H - 1 < h + dh : continue <NEWLINE> if w + dw < 0 or W - 1 < w + dw : continue <NEWLINE> if depth + 1 < D [ h + dh ] [ w + dw ] and G [ h + dh ] [ w + dw ] != <STRING> : <NEWLINE> <INDENT> ls . append ( [ h + dh , w + dw , depth + 1 ] ) <NEWLINE> D [ h + dh ] [ w + dw ] = depth + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if find : <NEWLINE> <INDENT> ans = ( H * W ) - black - route <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> <NL> N = int ( N ) <NEWLINE> A = int ( A ) <NEWLINE> <NL> if N % 500 <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( a [ i ] + ans ) % b [ i ] != 0 : <NEWLINE> <INDENT> ans += b [ i ] - ( a [ i ] + ans ) % b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( ( b - a ) % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> l_gcd = [ ] <NEWLINE> r_gcd = [ ] <NEWLINE> <NL> c = a [ 0 ] <NEWLINE> for i in a [ : - 1 ] : <NEWLINE> <INDENT> c = math . gcd ( c , i ) <NEWLINE> l_gcd . append ( c ) <NEWLINE> <NL> <DEDENT> c = a [ - 1 ] <NEWLINE> for j in a [ 1 : ] [ : : - 1 ] : <NEWLINE> <INDENT> c = math . gcd ( c , j ) <NEWLINE> r_gcd . append ( c ) <NEWLINE> <NL> <DEDENT> ans = max ( r_gcd [ - 1 ] , l_gcd [ - 1 ] ) <NEWLINE> for r , l in zip ( r_gcd [ : - 1 ] , l_gcd [ : - 1 ] [ : : - 1 ] ) : <NEWLINE> <INDENT> c = math . gcd ( r , l ) <NEWLINE> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ <STRING> ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> _a = sorted ( a , reverse = 1 ) <NEWLINE> a_max = _a [ 0 ] <NEWLINE> a_second = _a [ 1 ] <NEWLINE> ans = [ a_max ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a_max : <NEWLINE> <INDENT> ans [ i ] = a_second <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> def Graph ( ab ) : <NEWLINE> <INDENT> G = [ [ ] for i in range ( n ) ] <NEWLINE> for a , b , c in ab : <NEWLINE> <INDENT> G [ a - 1 ] . append ( [ b , c ] ) <NEWLINE> G [ b - 1 ] . append ( [ a , c ] ) <NEWLINE> <DEDENT> return G <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> def bfs ( k ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( ( k , - 1 , 0 ) ) <NEWLINE> dis = [ 0 ] * n <NEWLINE> while q : <NEWLINE> <INDENT> V , P , cnt = q . popleft ( ) <NEWLINE> for nv , d in G [ V - 1 ] : <NEWLINE> <INDENT> if nv == P : continue <NEWLINE> dis [ nv - 1 ] = cnt + d <NEWLINE> q . append ( ( nv , V , cnt + d ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return dis <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> abc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> G = Graph ( abc ) <NEWLINE> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dis = bfs ( k ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dis [ x - 1 ] + dis [ y - 1 ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = [ 0 ] * ( h * w ) <NEWLINE> y = x . copy ( ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> x [ a [ j ] - 1 ] = i <NEWLINE> y [ a [ j ] - 1 ] = j <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cost = [ [ 0 ] for _ in range ( d ) ] <NEWLINE> for i in range ( d , h * w ) : <NEWLINE> <INDENT> cost [ i % d ] . append ( cost [ i % d ] [ - 1 ] + abs ( x [ i ] - x [ i - d ] ) + abs ( y [ i ] - y [ i - d ] ) ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> ans . append ( cost [ r % d ] [ r // d ] - cost [ l % d ] [ l // d ] ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ a - 1 ] . append ( b - 1 ) <NEWLINE> lst [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ s - 1 ] += t <NEWLINE> <NL> <DEDENT> Q = [ 0 ] <NEWLINE> <NL> flag = [ True ] + [ False ] * ( n - 1 ) <NEWLINE> <NL> <NL> while Q : <NEWLINE> <INDENT> v = Q . pop ( ) <NEWLINE> flag [ v ] = True <NEWLINE> for i in lst [ v ] : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag [ i ] = True <NEWLINE> ans [ i ] += ans [ v ] <NEWLINE> Q . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in ans ] ) ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> Ind_A = bisect . bisect_left ( A , B [ i ] ) <NEWLINE> if A [ Ind_A - 1 ] == B [ i ] : <NEWLINE> <INDENT> Ind_A -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Ind_C = bisect . bisect_right ( C , B [ i ] ) <NEWLINE> num_C = len ( C ) - Ind_C <NEWLINE> counter += round ( Ind_A * num_C ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( counter ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if ( z >= 0 and z <= y ) : <NEWLINE> <INDENT> if ( x == y and y == z ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif ( x == y or y == z or z == x ) : <NEWLINE> <INDENT> cnt += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> nums = [ 1000 for i in range ( 26 ) ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> nums [ i ] = min ( nums [ i ] , s [ j ] . count ( ( chr ) ( 97 + i ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> while nums [ i ] > 0 : <NEWLINE> <INDENT> print ( ( chr ) ( 97 + i ) , end = <STRING> ) <NEWLINE> nums [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = - 1 <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a = ( x * i ) % y <NEWLINE> if a != 0 : <NEWLINE> <INDENT> ans = x * i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL> first = a [ 0 : n : 2 ] <NEWLINE> last = a [ 1 : n : 2 ] <NEWLINE> last = last [ : : - 1 ] <NEWLINE> answer = last + first <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> answer = answer [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( * answer , sep = <STRING> ) <NEWLINE>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( h * w + 1 ) <NEWLINE> <NL> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> s = ab [ i ] [ j ] <NEWLINE> dp [ s ] = [ i , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> dpp = [ 0 ] * ( h * w + 1 ) <NEWLINE> <NL> for k in range ( d + 1 , h * w + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> dpp [ k ] = dpp [ k - d ] + abs ( dp [ k ] [ 0 ] - dp [ k - d ] [ 0 ] ) + abs ( dp [ k ] [ 1 ] - dp [ k - d ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for x in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dpp [ b ] - dpp [ a ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> def n_div ( n ) : <NEWLINE> <INDENT> div_list = [ ] <NEWLINE> import math <NEWLINE> for i in range ( 1 , math . ceil ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> div_list . append ( i ) <NEWLINE> if i * i == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> div_list . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> div_list . sort ( ) <NEWLINE> return div_list <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> lr = n_div ( n ) <NEWLINE> <COMMENT> <NL> if len ( lr ) % 2 == 0 : <NEWLINE> <INDENT> a = len ( lr ) / 2 <NEWLINE> a = int ( a ) <NEWLINE> ans = lr [ a ] + lr [ a - 1 ] - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = math . floor ( len ( lr ) / 2 ) <NEWLINE> <COMMENT> <NL> ans = lr [ a ] * 2 - 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> def checker ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> OK3 = False <NEWLINE> OK5 = False <NEWLINE> OK7 = False <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> OK3 = True <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> OK5 = True <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> OK7 = True <NEWLINE> <DEDENT> <DEDENT> if OK3 and OK5 and OK7 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n < 357 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> nxt = [ 3 , 5 , 7 ] <NEWLINE> nxt = deque ( nxt ) <NEWLINE> OK = True <NEWLINE> while OK : <NEWLINE> <INDENT> a = nxt . popleft ( ) <NEWLINE> if a > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nxt . append ( a * 10 + 3 ) <NEWLINE> nxt . append ( a * 10 + 5 ) <NEWLINE> nxt . append ( a * 10 + 7 ) <NEWLINE> if checker ( a ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
def f ( a , b ) : <NEWLINE> <INDENT> str_a = str ( a ) <NEWLINE> len_a = len ( str_a ) <NEWLINE> str_b = str ( b ) <NEWLINE> len_b = len ( str_b ) <NEWLINE> <NL> return len_a if len_a > len_b else len_b <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> min = 10 ** 10 <NEWLINE> max_iter = 10 ** ( len ( str ( N ) ) // 2 + 1 ) <NEWLINE> <NL> for i in range ( 1 , max_iter ) : <NEWLINE> <INDENT> a = i <NEWLINE> if N % a == 0 : <NEWLINE> <INDENT> b = int ( N / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ret = f ( a , b ) <NEWLINE> if min > ret : <NEWLINE> <INDENT> min = ret <NEWLINE> if min <= len ( str ( N ) ) // 2 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> eastNumber = S . count ( <STRING> ) <NEWLINE> westNumber = 0 <NEWLINE> minimum = N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> eastNumber -= 1 <NEWLINE> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> number = eastNumber + westNumber <NEWLINE> if minimum > number : <NEWLINE> <INDENT> minimum = number <NEWLINE> <DEDENT> westNumber += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> import numpy as np <NEWLINE> <NL> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> pq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> data = [ [ 0 ] * 500 for i in range ( 500 ) ] <NEWLINE> <COMMENT> <NL> <NL> for l , r in lr : <NEWLINE> <INDENT> data [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> data = np . array ( data ) <NEWLINE> <NL> data = np . cumsum ( data , axis = 1 ) <NEWLINE> data = np . cumsum ( data , axis = 0 ) <NEWLINE> <NL> <COMMENT> <NL> for p , q in pq : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if p == 1 : <NEWLINE> <INDENT> ans = data [ q - 1 ] [ q - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = data [ q - 1 ] [ q - 1 ] - data [ p - 1 - 1 ] [ q - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = set ( ) <NEWLINE> pena = 0 <NEWLINE> walen = [ 0 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p , S = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) - 1 <NEWLINE> if p in ac : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ac . add ( p ) <NEWLINE> pena += walen [ p ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> walen [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ac ) , pena ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = [ 0 ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> sum_a [ 0 ] += a [ i ] <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> <NL> max_v = sum_a [ 0 ] <NEWLINE> ele = K - 1 <NEWLINE> expected_value = 0 <NEWLINE> <COMMENT> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ j ] + ( a [ i ] - a [ i - K ] ) ) <NEWLINE> if max_v < sum_a [ j + 1 ] : <NEWLINE> <INDENT> max_v = sum_a [ j + 1 ] <NEWLINE> ele = i <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> s_ele = ele + 1 - K <NEWLINE> for n in range ( s_ele , ele + 1 ) : <NEWLINE> <INDENT> expected_value += ( a [ n ] * 0.5 ) + 0.5 <NEWLINE> <DEDENT> print ( expected_value ) <NEWLINE>
import sys <NEWLINE> import heapq , math <NEWLINE> from itertools import zip_longest , permutations , combinations , combinations_with_replacement <NEWLINE> from itertools import accumulate , dropwhile , takewhile , groupby <NEWLINE> from functools import lru_cache <NEWLINE> from copy import deepcopy <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = { } <NEWLINE> s = 0 <NEWLINE> ans = 0 <NEWLINE> B [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> s = ( s + a ) % M <NEWLINE> ans += B . get ( s , 0 ) <NEWLINE> B [ s ] = B . get ( s , 0 ) + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def prime_numbers ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> m = ( n + 1 ) // 2 <NEWLINE> p = [ True ] * m <NEWLINE> for i in range ( 1 , int ( ( n ** 0.5 - 1 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i * ( i + 1 ) , m , 2 * i + 1 ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> a = [ 2 * i + 1 for i in range ( m ) if p [ i ] ] <NEWLINE> a [ 0 ] = 2 <NEWLINE> return a <NEWLINE> <NL> <NL> <DEDENT> N = 10 ** 5 <NEWLINE> P = set ( prime_numbers ( N ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> P = [ n for n in P if ( n + 1 ) // 2 in P ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> for n in P : <NEWLINE> <COMMENT> <NL> <INDENT> a [ n ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> a = list ( accumulate ( a ) ) <NEWLINE> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ r ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> sosu = make_divisors ( n ) <NEWLINE> <COMMENT> <NL> kumi = [ ] <NEWLINE> for i in range ( len ( sosu ) ) : <NEWLINE> <INDENT> for j in range ( len ( sosu ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if sosu [ i ] * sosu [ j ] == n : <NEWLINE> <INDENT> kumi . append ( [ str ( sosu [ i ] ) , str ( sosu [ j ] ) ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> top = 10000000000 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in kumi [ : int ( len ( kumi ) / 2 ) + 2 ] : <NEWLINE> <INDENT> sums = max ( len ( i [ 0 ] ) , len ( i [ 1 ] ) ) <NEWLINE> if top > sums : <NEWLINE> <INDENT> top = sums <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( top ) <NEWLINE>
S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if all ( <STRING> . count ( c ) == 1 for c in S [ i : j + 1 ] ) : <NEWLINE> <INDENT> ans = max ( ans , j - i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mn = 10 ** 18 <NEWLINE> for B in combinations ( range ( 1 , N ) , K - 1 ) : <COMMENT> <NEWLINE> <INDENT> mx = A [ 0 ] <COMMENT> <NEWLINE> score = 0 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> if n in B : <COMMENT> <NEWLINE> <INDENT> if A [ n ] <= mx : <COMMENT> <NEWLINE> <INDENT> mx += 1 <NEWLINE> score += ( mx - A [ n ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> mx = A [ n ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mx = max ( mx , A [ n ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> mn = min ( mn , score ) <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import deque , defaultdict <NEWLINE> <NL> inp = lambda v , w : v [ 0 ] * w [ 0 ] + v [ 1 ] * w [ 1 ] <NEWLINE> isprop = lambda a , b : a [ 0 ] * b [ 1 ] == a [ 1 ] * b [ 0 ] <NEWLINE> cwsum = lambda l : [ sum ( [ x [ 0 ] for x in l ] ) , sum ( [ x [ 1 ] for x in l ] ) ] <NEWLINE> chmin = lambda a , b : ( a , b ) [ b < a ] <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> infty = 10 ** 9 <NEWLINE> ch = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> p = [ ( - 1 ) * Mb , Ma ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> pch = [ [ inp ( v [ : 2 ] , p ) , v [ 2 ] ] for v in ch ] <NEWLINE> X = N * max ( [ abs ( w [ 0 ] ) for w in pch ] ) <NEWLINE> dp = [ [ infty ] * ( 2 * X + 1 ) for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 2 * X + 1 ) : <NEWLINE> <INDENT> if i == 0 and j == X + pch [ 0 ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = pch [ 0 ] [ 1 ] <NEWLINE> <DEDENT> elif i > 0 and j == X + pch [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = chmin ( dp [ i - 1 ] [ j ] , pch [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif i > 0 and j >= pch [ i ] [ 0 ] and j <= 2 * X + pch [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = chmin ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - pch [ i ] [ 0 ] ] + pch [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ N - 1 ] [ X ] == infty : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ N - 1 ] [ X ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a . append ( l + i - 1 ) <NEWLINE> b . append ( abs ( l + i - 1 ) ) <NEWLINE> <DEDENT> x = b . index ( min ( b ) ) <NEWLINE> print ( sum ( a ) - a [ x ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> s = sum ( a ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res += a [ i ] <NEWLINE> s -= a [ i ] <NEWLINE> ans = min ( ans , abs ( s - res ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> pt = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> ans = collections . Counter ( pt ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if k - q + ans [ i + 1 ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= k : <NEWLINE> <INDENT> k -= a <NEWLINE> if b <= k : <NEWLINE> <INDENT> k -= b <NEWLINE> print ( 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , b - k ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> def binary_search1 ( list , item ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if low == high : <NEWLINE> <INDENT> if guess >= item : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return mid + 1 <NEWLINE> <DEDENT> <DEDENT> if guess >= item : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def binary_search2 ( list , item ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( list ) - 1 <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = list [ mid ] <NEWLINE> if low == high : <NEWLINE> <INDENT> if guess > item : <NEWLINE> <INDENT> return n - mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n - 1 - mid <NEWLINE> <DEDENT> <DEDENT> if guess > item : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += binary_search2 ( c , b [ i ] ) * binary_search1 ( a , b [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( x , 1000000 ) : <NEWLINE> <INDENT> for j in range ( 2 , i + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if j == i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> if i % j == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> K = 10 ** 9 <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> S = i * 2 * C + max ( 0 , X - i ) * A + max ( 0 , Y - i ) * B <NEWLINE> K = min ( K , S ) <NEWLINE> <DEDENT> print ( K ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 800 * N <NEWLINE> if N < 15 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> if 15 <= N < 30 : <NEWLINE> <INDENT> y = 200 <NEWLINE> <DEDENT> if 30 <= N < 45 : <NEWLINE> <INDENT> y = 400 <NEWLINE> <DEDENT> if 45 <= N < 60 : <NEWLINE> <INDENT> y = 600 <NEWLINE> <DEDENT> if 60 <= N < 75 : <NEWLINE> <INDENT> y = 800 <NEWLINE> <DEDENT> if 75 <= N < 90 : <NEWLINE> <INDENT> y = 1000 <NEWLINE> <DEDENT> if 90 <= N <= 100 : <NEWLINE> <INDENT> y = 1200 <NEWLINE> <DEDENT> print ( x - y ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( A ) == 0 : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if N % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic = { } <NEWLINE> for x in A : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> V = list ( dic . values ( ) ) <NEWLINE> if len ( V ) == 2 : <NEWLINE> <INDENT> K = list ( dic . keys ( ) ) <NEWLINE> if K [ 0 ] == 0 and dic [ K [ 1 ] ] == dic [ 0 ] * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif K [ 1 ] == 0 and dic [ K [ 0 ] ] == dic [ 0 ] * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if len ( V ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if V [ 0 ] == V [ 1 ] and V [ 1 ] == V [ 2 ] : <NEWLINE> <INDENT> K = list ( dic . keys ( ) ) <NEWLINE> if K [ 0 ] ^ K [ 1 ] == K [ 2 ] and K [ 1 ] ^ K [ 2 ] == K [ 0 ] and K [ 2 ] ^ K [ 0 ] == K [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> import numpy as np <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i <= P ** ( 1 / 2 ) : <NEWLINE> <INDENT> if P % i == 0 : <NEWLINE> <INDENT> P //= i <NEWLINE> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> d [ P ] += 1 <NEWLINE> g = np . prod ( [ k ** ( v // N ) for k , v in d . items ( ) ] ) <NEWLINE> print ( g ) <NEWLINE> <DEDENT>
al = list ( <STRING> ) <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in al : <NEWLINE> <INDENT> del al [ al . index ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( al ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( al [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( X ) <NEWLINE> <NL> res1 = x [ n // 2 ] <NEWLINE> res2 = x [ n // 2 - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] >= res1 : <NEWLINE> <INDENT> print ( res2 ) <NEWLINE> <DEDENT> elif X [ i ] <= res2 : <NEWLINE> <INDENT> print ( res1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ i ] = a <NEWLINE> y [ i ] = b <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( x [ i ] + ans ) % y [ i ] != 0 : <NEWLINE> <INDENT> ans += y [ i ] - ( x [ i ] + ans ) % y [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> lst = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> lst [ i ] = int ( lst [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> lst . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> def get_cost ( x , y ) : <NEWLINE> <INDENT> return ( x - y ) ** 2 <NEWLINE> <NL> <DEDENT> costs = [ ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( lst [ 0 ] , lst [ - 1 ] ) : <COMMENT> <NEWLINE> <INDENT> cost = 0 <NEWLINE> for j in lst : <NEWLINE> <INDENT> cost = cost + get_cost ( j , i ) <NEWLINE> <DEDENT> costs . append ( cost ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> costs . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if costs != [ ] : <NEWLINE> <INDENT> print ( costs [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> import networkx as nx <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( range ( m + n + 2 ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j , c in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add_edge ( i , m + j , capacity = 1 ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add_edge ( - 1 , i , capacity = INF ) <NEWLINE> G . add_edge ( - 1 , m + j , capacity = INF ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add_edge ( i , m + n , capacity = INF ) <NEWLINE> G . add_edge ( m + j , m + n , capacity = INF ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = nx . algorithms . flow . maximum_flow_value ( G , - 1 , m + n ) <NEWLINE> if ans >= INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
from math import gcd <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> L = N // gcd ( N , M ) * M <NEWLINE> <NL> ds = L // N <NEWLINE> dt = L // M <NEWLINE> S = S [ 0 : : dt ] <NEWLINE> T = T [ 0 : : ds ] <NEWLINE> <NL> if S == T : <NEWLINE> <INDENT> print ( L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b - a + 1 ) >= ( 2 * k ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> for i in reversed ( range ( 0 , k ) ) : <NEWLINE> <INDENT> print ( b - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> b = [ 9 - ( i - 1 ) % 10 for i in a ] <NEWLINE> print ( sum ( a ) + sum ( b ) - max ( b ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> d = deque ( A ) <NEWLINE> min_A = d . popleft ( ) <NEWLINE> max_A = d . pop ( ) <NEWLINE> ans = max_A - min_A <NEWLINE> v1 = min_A <NEWLINE> v2 = max_A <NEWLINE> while d : <NEWLINE> <INDENT> if len ( d ) == 1 : <NEWLINE> <INDENT> v = d . pop ( ) <NEWLINE> ans += max ( abs ( v1 - v ) , abs ( v2 - v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_min = d [ 0 ] <NEWLINE> v_max = d [ - 1 ] <NEWLINE> diff = 0 <NEWLINE> is_popleft = None <NEWLINE> if diff < abs ( v1 - v_min ) : <NEWLINE> <INDENT> diff = abs ( v1 - v_min ) <NEWLINE> next_v1 = v_min <NEWLINE> next_v2 = v2 <NEWLINE> is_popleft = True <NEWLINE> <DEDENT> if diff < abs ( v2 - v_min ) : <NEWLINE> <INDENT> diff = abs ( v2 - v_min ) <NEWLINE> next_v1 = v_min <NEWLINE> next_v2 = v1 <NEWLINE> is_popleft = True <NEWLINE> <DEDENT> if diff < abs ( v1 - v_max ) : <NEWLINE> <INDENT> diff = abs ( v1 - v_max ) <NEWLINE> next_v1 = v_max <NEWLINE> next_v2 = v2 <NEWLINE> is_popleft = False <NEWLINE> <DEDENT> if diff < abs ( v2 - v_max ) : <NEWLINE> <INDENT> diff = abs ( v2 - v_max ) <NEWLINE> next_v1 = v_max <NEWLINE> next_v2 = v1 <NEWLINE> is_popleft = False <NEWLINE> <DEDENT> if is_popleft is None : <NEWLINE> <INDENT> next_v1 = v_min <NEWLINE> next_v2 = v2 <NEWLINE> is_popleft = True <NEWLINE> <DEDENT> ans += diff <NEWLINE> v1 , v2 = next_v1 , next_v2 <NEWLINE> if is_popleft : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for r in range ( n + 1 ) : <NEWLINE> <INDENT> for g in range ( n + 1 ) : <NEWLINE> <INDENT> bb = n - r * R - g * G <NEWLINE> if bb < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif bb % B == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> a , b = 0 , 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( t ) - t [ a - 1 ] + b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1001000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minimum_jump = [ - 1 ] * N <NEWLINE> minimum_jump [ 0 ] = 0 <NEWLINE> minimum_jump [ 1 ] = abs ( height [ 0 ] - height [ 1 ] ) <NEWLINE> <NL> def frog_jump ( n ) : <COMMENT> <NEWLINE> <INDENT> if minimum_jump [ n ] != - 1 : <NEWLINE> <INDENT> return minimum_jump [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if minimum_jump [ n - 1 ] != - 1 : <NEWLINE> <INDENT> temp1 = minimum_jump [ n - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp1 = frog_jump ( n - 1 ) <NEWLINE> <DEDENT> if minimum_jump [ n - 2 ] != - 1 : <NEWLINE> <INDENT> temp2 = minimum_jump [ n - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp2 = frog_jump ( n - 2 ) <NEWLINE> <DEDENT> minimum_jump [ n ] = min ( temp1 + abs ( height [ n ] - height [ n - 1 ] ) , temp2 + abs ( height [ n ] - height [ n - 2 ] ) ) <NEWLINE> return minimum_jump [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( frog_jump ( N - 1 ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> L = sorted ( list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) ) <NEWLINE> for a in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> k = L [ a ] + L [ b ] <NEWLINE> index = bisect . bisect_left ( L , k ) <NEWLINE> cnt += index - b - 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> ans = max ( ans , d [ i - 1 ] + d [ i ] + d [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> r_max = N // R + 1 <NEWLINE> for r in range ( r_max + 1 ) : <NEWLINE> <INDENT> temp = N - R * r <NEWLINE> for g in range ( temp // G + 1 ) : <NEWLINE> <INDENT> now = temp - G * g <NEWLINE> if now % B == 0 and now // B >= 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> <NL> c . sort ( reverse = True ) <NEWLINE> <NL> def dfs ( x , par , index ) : <NEWLINE> <INDENT> L [ x ] = c [ index ] <NEWLINE> for u in edges [ x ] : <NEWLINE> <INDENT> if u != par : <NEWLINE> <INDENT> index += 1 <NEWLINE> index = dfs ( u , x , index ) <NEWLINE> <DEDENT> <DEDENT> return index <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( sum ( L [ 1 : ] ) ) <NEWLINE> print ( * L ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> s . sort ( ) <NEWLINE> t . sort ( reverse = True ) <NEWLINE> <NL> flg = False <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i >= len ( t ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ord ( s [ i ] ) > ord ( t [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ord ( s [ i ] ) < ord ( t [ i ] ) : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> if i == len ( s ) - 1 and i < len ( t ) - 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if flg else print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( w , v ) in enumerate ( wv , start = 1 ) : <NEWLINE> <INDENT> dp_i = dp [ i ] <NEWLINE> dp_im = dp [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp_i [ j ] = dp_im [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = dp_im [ j - w ] + v <NEWLINE> b = dp_im [ j ] <NEWLINE> if a > b : <NEWLINE> <INDENT> dp_i [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_i [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( ) <NEWLINE> b = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp_a , tmp_b = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( tmp_a ) <NEWLINE> b . append ( tmp_b ) <NEWLINE> <DEDENT> print ( min ( b ) - max ( a ) + 1 if min ( b ) - max ( a ) >= 0 else 0 ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> r = range ( a , b + 1 ) <NEWLINE> r = list ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) <NEWLINE> r . sort ( ) <NEWLINE> <NL> for _r in r : <NEWLINE> <INDENT> print ( _r ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( w , v ) in enumerate ( wv , start = 1 ) : <NEWLINE> <INDENT> dp_i = dp [ i ] <NEWLINE> dp_im = dp [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp_i [ j ] = dp_im [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = dp_im [ j - w ] + v <NEWLINE> b = dp_im [ j ] <NEWLINE> if a > b : <NEWLINE> <INDENT> dp_i [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_i [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> <NL> def solve ( N , L , edges , queries ) : <NEWLINE> <NL> <INDENT> graph = np . zeros ( ( N , N ) , dtype = int ) <NEWLINE> for a , b , c in edges : <NEWLINE> <INDENT> graph [ a - 1 , b - 1 ] = c <NEWLINE> graph [ b - 1 , a - 1 ] = c <NEWLINE> <NL> <DEDENT> dist = floyd_warshall ( graph , directed = False ) <NEWLINE> dist = ( dist <= L ) <NEWLINE> dist = floyd_warshall ( dist , directed = False ) <NEWLINE> res = [ ] <NEWLINE> for a , b in queries : <NEWLINE> <INDENT> d = dist [ a - 1 , b - 1 ] <NEWLINE> res . append ( int ( d - 1 ) if d != float ( <STRING> ) else - 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> t = read ( ) . split ( ) <NEWLINE> <NL> N , M , L = map ( int , t [ : 3 ] ) <NEWLINE> <NL> m = map ( int , t [ 3 : M * 3 + 3 ] ) <NEWLINE> edges = zip ( m , m , m ) <NEWLINE> <NL> Q = int ( t [ M * 3 + 3 ] ) <NEWLINE> m = map ( int , t [ M * 3 + 4 : ] ) <NEWLINE> queries = zip ( m , m ) <NEWLINE> <NL> print ( * solve ( N , L , edges , queries ) , sep = <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> plist = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 , 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 , 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 , 13513 , 13523 , 13537 , 13553 , 13567 , 13577 , 13591 , 13597 , 13613 , 13619 , 13627 , 13633 , 13649 , 13669 , 13679 , 13681 , 13687 , 13691 , 13693 , 13697 , 13709 , 13711 , 13721 , 13723 , 13729 , 13751 , 13757 , 13759 , 13763 , 13781 , 13789 , 13799 , 13807 , 13829 , 13831 , 13841 , 13859 , 13873 , 13877 , 13879 , 13883 , 13901 , 13903 , 13907 , 13913 , 13921 , 13931 , 13933 , 13963 , 13967 , 13997 , 13999 , 14009 , 14011 , 14029 , 14033 , 14051 , 14057 , 14071 , 14081 , 14083 , 14087 , 14107 , 14143 , 14149 , 14153 , 14159 , 14173 , 14177 , 14197 , 14207 , 14221 , 14243 , 14249 , 14251 , 14281 , 14293 , 14303 , 14321 , 14323 , 14327 , 14341 , 14347 , 14369 , 14387 , 14389 , 14401 , 14407 , 14411 , 14419 , 14423 , 14431 , 14437 , 14447 , 14449 , 14461 , 14479 , 14489 , 14503 , 14519 , 14533 , 14537 , 14543 , 14549 , 14551 , 14557 , 14561 , 14563 , 14591 , 14593 , 14621 , 14627 , 14629 , 14633 , 14639 , 14653 , 14657 , 14669 , 14683 , 14699 , 14713 , 14717 , 14723 , 14731 , 14737 , 14741 , 14747 , 14753 , 14759 , 14767 , 14771 , 14779 , 14783 , 14797 , 14813 , 14821 , 14827 , 14831 , 14843 , 14851 , 14867 , 14869 , 14879 , 14887 , 14891 , 14897 , 14923 , 14929 , 14939 , 14947 , 14951 , 14957 , 14969 , 14983 , 15013 , 15017 , 15031 , 15053 , 15061 , 15073 , 15077 , 15083 , 15091 , 15101 , 15107 , 15121 , 15131 , 15137 , 15139 , 15149 , 15161 , 15173 , 15187 , 15193 , 15199 , 15217 , 15227 , 15233 , 15241 , 15259 , 15263 , 15269 , 15271 , 15277 , 15287 , 15289 , 15299 , 15307 , 15313 , 15319 , 15329 , 15331 , 15349 , 15359 , 15361 , 15373 , 15377 , 15383 , 15391 , 15401 , 15413 , 15427 , 15439 , 15443 , 15451 , 15461 , 15467 , 15473 , 15493 , 15497 , 15511 , 15527 , 15541 , 15551 , 15559 , 15569 , 15581 , 15583 , 15601 , 15607 , 15619 , 15629 , 15641 , 15643 , 15647 , 15649 , 15661 , 15667 , 15671 , 15679 , 15683 , 15727 , 15731 , 15733 , 15737 , 15739 , 15749 , 15761 , 15767 , 15773 , 15787 , 15791 , 15797 , 15803 , 15809 , 15817 , 15823 , 15859 , 15877 , 15881 , 15887 , 15889 , 15901 , 15907 , 15913 , 15919 , 15923 , 15937 , 15959 , 15971 , 15973 , 15991 , 16001 , 16007 , 16033 , 16057 , 16061 , 16063 , 16067 , 16069 , 16073 , 16087 , 16091 , 16097 , 16103 , 16111 , 16127 , 16139 , 16141 , 16183 , 16187 , 16189 , 16193 , 16217 , 16223 , 16229 , 16231 , 16249 , 16253 , 16267 , 16273 , 16301 , 16319 , 16333 , 16339 , 16349 , 16361 , 16363 , 16369 , 16381 , 16411 , 16417 , 16421 , 16427 , 16433 , 16447 , 16451 , 16453 , 16477 , 16481 , 16487 , 16493 , 16519 , 16529 , 16547 , 16553 , 16561 , 16567 , 16573 , 16603 , 16607 , 16619 , 16631 , 16633 , 16649 , 16651 , 16657 , 16661 , 16673 , 16691 , 16693 , 16699 , 16703 , 16729 , 16741 , 16747 , 16759 , 16763 , 16787 , 16811 , 16823 , 16829 , 16831 , 16843 , 16871 , 16879 , 16883 , 16889 , 16901 , 16903 , 16921 , 16927 , 16931 , 16937 , 16943 , 16963 , 16979 , 16981 , 16987 , 16993 , 17011 , 17021 , 17027 , 17029 , 17033 , 17041 , 17047 , 17053 , 17077 , 17093 , 17099 , 17107 , 17117 , 17123 , 17137 , 17159 , 17167 , 17183 , 17189 , 17191 , 17203 , 17207 , 17209 , 17231 , 17239 , 17257 , 17291 , 17293 , 17299 , 17317 , 17321 , 17327 , 17333 , 17341 , 17351 , 17359 , 17377 , 17383 , 17387 , 17389 , 17393 , 17401 , 17417 , 17419 , 17431 , 17443 , 17449 , 17467 , 17471 , 17477 , 17483 , 17489 , 17491 , 17497 , 17509 , 17519 , 17539 , 17551 , 17569 , 17573 , 17579 , 17581 , 17597 , 17599 , 17609 , 17623 , 17627 , 17657 , 17659 , 17669 , 17681 , 17683 , 17707 , 17713 , 17729 , 17737 , 17747 , 17749 , 17761 , 17783 , 17789 , 17791 , 17807 , 17827 , 17837 , 17839 , 17851 , 17863 , 17881 , 17891 , 17903 , 17909 , 17911 , 17921 , 17923 , 17929 , 17939 , 17957 , 17959 , 17971 , 17977 , 17981 , 17987 , 17989 , 18013 , 18041 , 18043 , 18047 , 18049 , 18059 , 18061 , 18077 , 18089 , 18097 , 18119 , 18121 , 18127 , 18131 , 18133 , 18143 , 18149 , 18169 , 18181 , 18191 , 18199 , 18211 , 18217 , 18223 , 18229 , 18233 , 18251 , 18253 , 18257 , 18269 , 18287 , 18289 , 18301 , 18307 , 18311 , 18313 , 18329 , 18341 , 18353 , 18367 , 18371 , 18379 , 18397 , 18401 , 18413 , 18427 , 18433 , 18439 , 18443 , 18451 , 18457 , 18461 , 18481 , 18493 , 18503 , 18517 , 18521 , 18523 , 18539 , 18541 , 18553 , 18583 , 18587 , 18593 , 18617 , 18637 , 18661 , 18671 , 18679 , 18691 , 18701 , 18713 , 18719 , 18731 , 18743 , 18749 , 18757 , 18773 , 18787 , 18793 , 18797 , 18803 , 18839 , 18859 , 18869 , 18899 , 18911 , 18913 , 18917 , 18919 , 18947 , 18959 , 18973 , 18979 , 19001 , 19009 , 19013 , 19031 , 19037 , 19051 , 19069 , 19073 , 19079 , 19081 , 19087 , 19121 , 19139 , 19141 , 19157 , 19163 , 19181 , 19183 , 19207 , 19211 , 19213 , 19219 , 19231 , 19237 , 19249 , 19259 , 19267 , 19273 , 19289 , 19301 , 19309 , 19319 , 19333 , 19373 , 19379 , 19381 , 19387 , 19391 , 19403 , 19417 , 19421 , 19423 , 19427 , 19429 , 19433 , 19441 , 19447 , 19457 , 19463 , 19469 , 19471 , 19477 , 19483 , 19489 , 19501 , 19507 , 19531 , 19541 , 19543 , 19553 , 19559 , 19571 , 19577 , 19583 , 19597 , 19603 , 19609 , 19661 , 19681 , 19687 , 19697 , 19699 , 19709 , 19717 , 19727 , 19739 , 19751 , 19753 , 19759 , 19763 , 19777 , 19793 , 19801 , 19813 , 19819 , 19841 , 19843 , 19853 , 19861 , 19867 , 19889 , 19891 , 19913 , 19919 , 19927 , 19937 , 19949 , 19961 , 19963 , 19973 , 19979 , 19991 , 19993 , 19997 , 20011 , 20021 , 20023 , 20029 , 20047 , 20051 , 20063 , 20071 , 20089 , 20101 , 20107 , 20113 , 20117 , 20123 , 20129 , 20143 , 20147 , 20149 , 20161 , 20173 , 20177 , 20183 , 20201 , 20219 , 20231 , 20233 , 20249 , 20261 , 20269 , 20287 , 20297 , 20323 , 20327 , 20333 , 20341 , 20347 , 20353 , 20357 , 20359 , 20369 , 20389 , 20393 , 20399 , 20407 , 20411 , 20431 , 20441 , 20443 , 20477 , 20479 , 20483 , 20507 , 20509 , 20521 , 20533 , 20543 , 20549 , 20551 , 20563 , 20593 , 20599 , 20611 , 20627 , 20639 , 20641 , 20663 , 20681 , 20693 , 20707 , 20717 , 20719 , 20731 , 20743 , 20747 , 20749 , 20753 , 20759 , 20771 , 20773 , 20789 , 20807 , 20809 , 20849 , 20857 , 20873 , 20879 , 20887 , 20897 , 20899 , 20903 , 20921 , 20929 , 20939 , 20947 , 20959 , 20963 , 20981 , 20983 , 21001 , 21011 , 21013 , 21017 , 21019 , 21023 , 21031 , 21059 , 21061 , 21067 , 21089 , 21101 , 21107 , 21121 , 21139 , 21143 , 21149 , 21157 , 21163 , 21169 , 21179 , 21187 , 21191 , 21193 , 21211 , 21221 , 21227 , 21247 , 21269 , 21277 , 21283 , 21313 , 21317 , 21319 , 21323 , 21341 , 21347 , 21377 , 21379 , 21383 , 21391 , 21397 , 21401 , 21407 , 21419 , 21433 , 21467 , 21481 , 21487 , 21491 , 21493 , 21499 , 21503 , 21517 , 21521 , 21523 , 21529 , 21557 , 21559 , 21563 , 21569 , 21577 , 21587 , 21589 , 21599 , 21601 , 21611 , 21613 , 21617 , 21647 , 21649 , 21661 , 21673 , 21683 , 21701 , 21713 , 21727 , 21737 , 21739 , 21751 , 21757 , 21767 , 21773 , 21787 , 21799 , 21803 , 21817 , 21821 , 21839 , 21841 , 21851 , 21859 , 21863 , 21871 , 21881 , 21893 , 21911 , 21929 , 21937 , 21943 , 21961 , 21977 , 21991 , 21997 , 22003 , 22013 , 22027 , 22031 , 22037 , 22039 , 22051 , 22063 , 22067 , 22073 , 22079 , 22091 , 22093 , 22109 , 22111 , 22123 , 22129 , 22133 , 22147 , 22153 , 22157 , 22159 , 22171 , 22189 , 22193 , 22229 , 22247 , 22259 , 22271 , 22273 , 22277 , 22279 , 22283 , 22291 , 22303 , 22307 , 22343 , 22349 , 22367 , 22369 , 22381 , 22391 , 22397 , 22409 , 22433 , 22441 , 22447 , 22453 , 22469 , 22481 , 22483 , 22501 , 22511 , 22531 , 22541 , 22543 , 22549 , 22567 , 22571 , 22573 , 22613 , 22619 , 22621 , 22637 , 22639 , 22643 , 22651 , 22669 , 22679 , 22691 , 22697 , 22699 , 22709 , 22717 , 22721 , 22727 , 22739 , 22741 , 22751 , 22769 , 22777 , 22783 , 22787 , 22807 , 22811 , 22817 , 22853 , 22859 , 22861 , 22871 , 22877 , 22901 , 22907 , 22921 , 22937 , 22943 , 22961 , 22963 , 22973 , 22993 , 23003 , 23011 , 23017 , 23021 , 23027 , 23029 , 23039 , 23041 , 23053 , 23057 , 23059 , 23063 , 23071 , 23081 , 23087 , 23099 , 23117 , 23131 , 23143 , 23159 , 23167 , 23173 , 23189 , 23197 , 23201 , 23203 , 23209 , 23227 , 23251 , 23269 , 23279 , 23291 , 23293 , 23297 , 23311 , 23321 , 23327 , 23333 , 23339 , 23357 , 23369 , 23371 , 23399 , 23417 , 23431 , 23447 , 23459 , 23473 , 23497 , 23509 , 23531 , 23537 , 23539 , 23549 , 23557 , 23561 , 23563 , 23567 , 23581 , 23593 , 23599 , 23603 , 23609 , 23623 , 23627 , 23629 , 23633 , 23663 , 23669 , 23671 , 23677 , 23687 , 23689 , 23719 , 23741 , 23743 , 23747 , 23753 , 23761 , 23767 , 23773 , 23789 , 23801 , 23813 , 23819 , 23827 , 23831 , 23833 , 23857 , 23869 , 23873 , 23879 , 23887 , 23893 , 23899 , 23909 , 23911 , 23917 , 23929 , 23957 , 23971 , 23977 , 23981 , 23993 , 24001 , 24007 , 24019 , 24023 , 24029 , 24043 , 24049 , 24061 , 24071 , 24077 , 24083 , 24091 , 24097 , 24103 , 24107 , 24109 , 24113 , 24121 , 24133 , 24137 , 24151 , 24169 , 24179 , 24181 , 24197 , 24203 , 24223 , 24229 , 24239 , 24247 , 24251 , 24281 , 24317 , 24329 , 24337 , 24359 , 24371 , 24373 , 24379 , 24391 , 24407 , 24413 , 24419 , 24421 , 24439 , 24443 , 24469 , 24473 , 24481 , 24499 , 24509 , 24517 , 24527 , 24533 , 24547 , 24551 , 24571 , 24593 , 24611 , 24623 , 24631 , 24659 , 24671 , 24677 , 24683 , 24691 , 24697 , 24709 , 24733 , 24749 , 24763 , 24767 , 24781 , 24793 , 24799 , 24809 , 24821 , 24841 , 24847 , 24851 , 24859 , 24877 , 24889 , 24907 , 24917 , 24919 , 24923 , 24943 , 24953 , 24967 , 24971 , 24977 , 24979 , 24989 , 25013 , 25031 , 25033 , 25037 , 25057 , 25073 , 25087 , 25097 , 25111 , 25117 , 25121 , 25127 , 25147 , 25153 , 25163 , 25169 , 25171 , 25183 , 25189 , 25219 , 25229 , 25237 , 25243 , 25247 , 25253 , 25261 , 25301 , 25303 , 25307 , 25309 , 25321 , 25339 , 25343 , 25349 , 25357 , 25367 , 25373 , 25391 , 25409 , 25411 , 25423 , 25439 , 25447 , 25453 , 25457 , 25463 , 25469 , 25471 , 25523 , 25537 , 25541 , 25561 , 25577 , 25579 , 25583 , 25589 , 25601 , 25603 , 25609 , 25621 , 25633 , 25639 , 25643 , 25657 , 25667 , 25673 , 25679 , 25693 , 25703 , 25717 , 25733 , 25741 , 25747 , 25759 , 25763 , 25771 , 25793 , 25799 , 25801 , 25819 , 25841 , 25847 , 25849 , 25867 , 25873 , 25889 , 25903 , 25913 , 25919 , 25931 , 25933 , 25939 , 25943 , 25951 , 25969 , 25981 , 25997 , 25999 , 26003 , 26017 , 26021 , 26029 , 26041 , 26053 , 26083 , 26099 , 26107 , 26111 , 26113 , 26119 , 26141 , 26153 , 26161 , 26171 , 26177 , 26183 , 26189 , 26203 , 26209 , 26227 , 26237 , 26249 , 26251 , 26261 , 26263 , 26267 , 26293 , 26297 , 26309 , 26317 , 26321 , 26339 , 26347 , 26357 , 26371 , 26387 , 26393 , 26399 , 26407 , 26417 , 26423 , 26431 , 26437 , 26449 , 26459 , 26479 , 26489 , 26497 , 26501 , 26513 , 26539 , 26557 , 26561 , 26573 , 26591 , 26597 , 26627 , 26633 , 26641 , 26647 , 26669 , 26681 , 26683 , 26687 , 26693 , 26699 , 26701 , 26711 , 26713 , 26717 , 26723 , 26729 , 26731 , 26737 , 26759 , 26777 , 26783 , 26801 , 26813 , 26821 , 26833 , 26839 , 26849 , 26861 , 26863 , 26879 , 26881 , 26891 , 26893 , 26903 , 26921 , 26927 , 26947 , 26951 , 26953 , 26959 , 26981 , 26987 , 26993 , 27011 , 27017 , 27031 , 27043 , 27059 , 27061 , 27067 , 27073 , 27077 , 27091 , 27103 , 27107 , 27109 , 27127 , 27143 , 27179 , 27191 , 27197 , 27211 , 27239 , 27241 , 27253 , 27259 , 27271 , 27277 , 27281 , 27283 , 27299 , 27329 , 27337 , 27361 , 27367 , 27397 , 27407 , 27409 , 27427 , 27431 , 27437 , 27449 , 27457 , 27479 , 27481 , 27487 , 27509 , 27527 , 27529 , 27539 , 27541 , 27551 , 27581 , 27583 , 27611 , 27617 , 27631 , 27647 , 27653 , 27673 , 27689 , 27691 , 27697 , 27701 , 27733 , 27737 , 27739 , 27743 , 27749 , 27751 , 27763 , 27767 , 27773 , 27779 , 27791 , 27793 , 27799 , 27803 , 27809 , 27817 , 27823 , 27827 , 27847 , 27851 , 27883 , 27893 , 27901 , 27917 , 27919 , 27941 , 27943 , 27947 , 27953 , 27961 , 27967 , 27983 , 27997 , 28001 , 28019 , 28027 , 28031 , 28051 , 28057 , 28069 , 28081 , 28087 , 28097 , 28099 , 28109 , 28111 , 28123 , 28151 , 28163 , 28181 , 28183 , 28201 , 28211 , 28219 , 28229 , 28277 , 28279 , 28283 , 28289 , 28297 , 28307 , 28309 , 28319 , 28349 , 28351 , 28387 , 28393 , 28403 , 28409 , 28411 , 28429 , 28433 , 28439 , 28447 , 28463 , 28477 , 28493 , 28499 , 28513 , 28517 , 28537 , 28541 , 28547 , 28549 , 28559 , 28571 , 28573 , 28579 , 28591 , 28597 , 28603 , 28607 , 28619 , 28621 , 28627 , 28631 , 28643 , 28649 , 28657 , 28661 , 28663 , 28669 , 28687 , 28697 , 28703 , 28711 , 28723 , 28729 , 28751 , 28753 , 28759 , 28771 , 28789 , 28793 , 28807 , 28813 , 28817 , 28837 , 28843 , 28859 , 28867 , 28871 , 28879 , 28901 , 28909 , 28921 , 28927 , 28933 , 28949 , 28961 , 28979 , 29009 , 29017 , 29021 , 29023 , 29027 , 29033 , 29059 , 29063 , 29077 , 29101 , 29123 , 29129 , 29131 , 29137 , 29147 , 29153 , 29167 , 29173 , 29179 , 29191 , 29201 , 29207 , 29209 , 29221 , 29231 , 29243 , 29251 , 29269 , 29287 , 29297 , 29303 , 29311 , 29327 , 29333 , 29339 , 29347 , 29363 , 29383 , 29387 , 29389 , 29399 , 29401 , 29411 , 29423 , 29429 , 29437 , 29443 , 29453 , 29473 , 29483 , 29501 , 29527 , 29531 , 29537 , 29567 , 29569 , 29573 , 29581 , 29587 , 29599 , 29611 , 29629 , 29633 , 29641 , 29663 , 29669 , 29671 , 29683 , 29717 , 29723 , 29741 , 29753 , 29759 , 29761 , 29789 , 29803 , 29819 , 29833 , 29837 , 29851 , 29863 , 29867 , 29873 , 29879 , 29881 , 29917 , 29921 , 29927 , 29947 , 29959 , 29983 , 29989 , 30011 , 30013 , 30029 , 30047 , 30059 , 30071 , 30089 , 30091 , 30097 , 30103 , 30109 , 30113 , 30119 , 30133 , 30137 , 30139 , 30161 , 30169 , 30181 , 30187 , 30197 , 30203 , 30211 , 30223 , 30241 , 30253 , 30259 , 30269 , 30271 , 30293 , 30307 , 30313 , 30319 , 30323 , 30341 , 30347 , 30367 , 30389 , 30391 , 30403 , 30427 , 30431 , 30449 , 30467 , 30469 , 30491 , 30493 , 30497 , 30509 , 30517 , 30529 , 30539 , 30553 , 30557 , 30559 , 30577 , 30593 , 30631 , 30637 , 30643 , 30649 , 30661 , 30671 , 30677 , 30689 , 30697 , 30703 , 30707 , 30713 , 30727 , 30757 , 30763 , 30773 , 30781 , 30803 , 30809 , 30817 , 30829 , 30839 , 30841 , 30851 , 30853 , 30859 , 30869 , 30871 , 30881 , 30893 , 30911 , 30931 , 30937 , 30941 , 30949 , 30971 , 30977 , 30983 , 31013 , 31019 , 31033 , 31039 , 31051 , 31063 , 31069 , 31079 , 31081 , 31091 , 31121 , 31123 , 31139 , 31147 , 31151 , 31153 , 31159 , 31177 , 31181 , 31183 , 31189 , 31193 , 31219 , 31223 , 31231 , 31237 , 31247 , 31249 , 31253 , 31259 , 31267 , 31271 , 31277 , 31307 , 31319 , 31321 , 31327 , 31333 , 31337 , 31357 , 31379 , 31387 , 31391 , 31393 , 31397 , 31469 , 31477 , 31481 , 31489 , 31511 , 31513 , 31517 , 31531 , 31541 , 31543 , 31547 , 31567 , 31573 , 31583 , 31601 , 31607 , 31627 , 31643 , 31649 , 31657 , 31663 , 31667 , 31687 , 31699 , 31721 , 31723 , 31727 , 31729 , 31741 , 31751 , 31769 , 31771 , 31793 , 31799 , 31817 , 31847 , 31849 , 31859 , 31873 , 31883 , 31891 , 31907 , 31957 , 31963 , 31973 , 31981 , 31991 , 32003 , 32009 , 32027 , 32029 , 32051 , 32057 , 32059 , 32063 , 32069 , 32077 , 32083 , 32089 , 32099 , 32117 , 32119 , 32141 , 32143 , 32159 , 32173 , 32183 , 32189 , 32191 , 32203 , 32213 , 32233 , 32237 , 32251 , 32257 , 32261 , 32297 , 32299 , 32303 , 32309 , 32321 , 32323 , 32327 , 32341 , 32353 , 32359 , 32363 , 32369 , 32371 , 32377 , 32381 , 32401 , 32411 , 32413 , 32423 , 32429 , 32441 , 32443 , 32467 , 32479 , 32491 , 32497 , 32503 , 32507 , 32531 , 32533 , 32537 , 32561 , 32563 , 32569 , 32573 , 32579 , 32587 , 32603 , 32609 , 32611 , 32621 , 32633 , 32647 , 32653 , 32687 , 32693 , 32707 , 32713 , 32717 , 32719 , 32749 , 32771 , 32779 , 32783 , 32789 , 32797 , 32801 , 32803 , 32831 , 32833 , 32839 , 32843 , 32869 , 32887 , 32909 , 32911 , 32917 , 32933 , 32939 , 32941 , 32957 , 32969 , 32971 , 32983 , 32987 , 32993 , 32999 , 33013 , 33023 , 33029 , 33037 , 33049 , 33053 , 33071 , 33073 , 33083 , 33091 , 33107 , 33113 , 33119 , 33149 , 33151 , 33161 , 33179 , 33181 , 33191 , 33199 , 33203 , 33211 , 33223 , 33247 , 33287 , 33289 , 33301 , 33311 , 33317 , 33329 , 33331 , 33343 , 33347 , 33349 , 33353 , 33359 , 33377 , 33391 , 33403 , 33409 , 33413 , 33427 , 33457 , 33461 , 33469 , 33479 , 33487 , 33493 , 33503 , 33521 , 33529 , 33533 , 33547 , 33563 , 33569 , 33577 , 33581 , 33587 , 33589 , 33599 , 33601 , 33613 , 33617 , 33619 , 33623 , 33629 , 33637 , 33641 , 33647 , 33679 , 33703 , 33713 , 33721 , 33739 , 33749 , 33751 , 33757 , 33767 , 33769 , 33773 , 33791 , 33797 , 33809 , 33811 , 33827 , 33829 , 33851 , 33857 , 33863 , 33871 , 33889 , 33893 , 33911 , 33923 , 33931 , 33937 , 33941 , 33961 , 33967 , 33997 , 34019 , 34031 , 34033 , 34039 , 34057 , 34061 , 34123 , 34127 , 34129 , 34141 , 34147 , 34157 , 34159 , 34171 , 34183 , 34211 , 34213 , 34217 , 34231 , 34253 , 34259 , 34261 , 34267 , 34273 , 34283 , 34297 , 34301 , 34303 , 34313 , 34319 , 34327 , 34337 , 34351 , 34361 , 34367 , 34369 , 34381 , 34403 , 34421 , 34429 , 34439 , 34457 , 34469 , 34471 , 34483 , 34487 , 34499 , 34501 , 34511 , 34513 , 34519 , 34537 , 34543 , 34549 , 34583 , 34589 , 34591 , 34603 , 34607 , 34613 , 34631 , 34649 , 34651 , 34667 , 34673 , 34679 , 34687 , 34693 , 34703 , 34721 , 34729 , 34739 , 34747 , 34757 , 34759 , 34763 , 34781 , 34807 , 34819 , 34841 , 34843 , 34847 , 34849 , 34871 , 34877 , 34883 , 34897 , 34913 , 34919 , 34939 , 34949 , 34961 , 34963 , 34981 , 35023 , 35027 , 35051 , 35053 , 35059 , 35069 , 35081 , 35083 , 35089 , 35099 , 35107 , 35111 , 35117 , 35129 , 35141 , 35149 , 35153 , 35159 , 35171 , 35201 , 35221 , 35227 , 35251 , 35257 , 35267 , 35279 , 35281 , 35291 , 35311 , 35317 , 35323 , 35327 , 35339 , 35353 , 35363 , 35381 , 35393 , 35401 , 35407 , 35419 , 35423 , 35437 , 35447 , 35449 , 35461 , 35491 , 35507 , 35509 , 35521 , 35527 , 35531 , 35533 , 35537 , 35543 , 35569 , 35573 , 35591 , 35593 , 35597 , 35603 , 35617 , 35671 , 35677 , 35729 , 35731 , 35747 , 35753 , 35759 , 35771 , 35797 , 35801 , 35803 , 35809 , 35831 , 35837 , 35839 , 35851 , 35863 , 35869 , 35879 , 35897 , 35899 , 35911 , 35923 , 35933 , 35951 , 35963 , 35969 , 35977 , 35983 , 35993 , 35999 , 36007 , 36011 , 36013 , 36017 , 36037 , 36061 , 36067 , 36073 , 36083 , 36097 , 36107 , 36109 , 36131 , 36137 , 36151 , 36161 , 36187 , 36191 , 36209 , 36217 , 36229 , 36241 , 36251 , 36263 , 36269 , 36277 , 36293 , 36299 , 36307 , 36313 , 36319 , 36341 , 36343 , 36353 , 36373 , 36383 , 36389 , 36433 , 36451 , 36457 , 36467 , 36469 , 36473 , 36479 , 36493 , 36497 , 36523 , 36527 , 36529 , 36541 , 36551 , 36559 , 36563 , 36571 , 36583 , 36587 , 36599 , 36607 , 36629 , 36637 , 36643 , 36653 , 36671 , 36677 , 36683 , 36691 , 36697 , 36709 , 36713 , 36721 , 36739 , 36749 , 36761 , 36767 , 36779 , 36781 , 36787 , 36791 , 36793 , 36809 , 36821 , 36833 , 36847 , 36857 , 36871 , 36877 , 36887 , 36899 , 36901 , 36913 , 36919 , 36923 , 36929 , 36931 , 36943 , 36947 , 36973 , 36979 , 36997 , 37003 , 37013 , 37019 , 37021 , 37039 , 37049 , 37057 , 37061 , 37087 , 37097 , 37117 , 37123 , 37139 , 37159 , 37171 , 37181 , 37189 , 37199 , 37201 , 37217 , 37223 , 37243 , 37253 , 37273 , 37277 , 37307 , 37309 , 37313 , 37321 , 37337 , 37339 , 37357 , 37361 , 37363 , 37369 , 37379 , 37397 , 37409 , 37423 , 37441 , 37447 , 37463 , 37483 , 37489 , 37493 , 37501 , 37507 , 37511 , 37517 , 37529 , 37537 , 37547 , 37549 , 37561 , 37567 , 37571 , 37573 , 37579 , 37589 , 37591 , 37607 , 37619 , 37633 , 37643 , 37649 , 37657 , 37663 , 37691 , 37693 , 37699 , 37717 , 37747 , 37781 , 37783 , 37799 , 37811 , 37813 , 37831 , 37847 , 37853 , 37861 , 37871 , 37879 , 37889 , 37897 , 37907 , 37951 , 37957 , 37963 , 37967 , 37987 , 37991 , 37993 , 37997 , 38011 , 38039 , 38047 , 38053 , 38069 , 38083 , 38113 , 38119 , 38149 , 38153 , 38167 , 38177 , 38183 , 38189 , 38197 , 38201 , 38219 , 38231 , 38237 , 38239 , 38261 , 38273 , 38281 , 38287 , 38299 , 38303 , 38317 , 38321 , 38327 , 38329 , 38333 , 38351 , 38371 , 38377 , 38393 , 38431 , 38447 , 38449 , 38453 , 38459 , 38461 , 38501 , 38543 , 38557 , 38561 , 38567 , 38569 , 38593 , 38603 , 38609 , 38611 , 38629 , 38639 , 38651 , 38653 , 38669 , 38671 , 38677 , 38693 , 38699 , 38707 , 38711 , 38713 , 38723 , 38729 , 38737 , 38747 , 38749 , 38767 , 38783 , 38791 , 38803 , 38821 , 38833 , 38839 , 38851 , 38861 , 38867 , 38873 , 38891 , 38903 , 38917 , 38921 , 38923 , 38933 , 38953 , 38959 , 38971 , 38977 , 38993 , 39019 , 39023 , 39041 , 39043 , 39047 , 39079 , 39089 , 39097 , 39103 , 39107 , 39113 , 39119 , 39133 , 39139 , 39157 , 39161 , 39163 , 39181 , 39191 , 39199 , 39209 , 39217 , 39227 , 39229 , 39233 , 39239 , 39241 , 39251 , 39293 , 39301 , 39313 , 39317 , 39323 , 39341 , 39343 , 39359 , 39367 , 39371 , 39373 , 39383 , 39397 , 39409 , 39419 , 39439 , 39443 , 39451 , 39461 , 39499 , 39503 , 39509 , 39511 , 39521 , 39541 , 39551 , 39563 , 39569 , 39581 , 39607 , 39619 , 39623 , 39631 , 39659 , 39667 , 39671 , 39679 , 39703 , 39709 , 39719 , 39727 , 39733 , 39749 , 39761 , 39769 , 39779 , 39791 , 39799 , 39821 , 39827 , 39829 , 39839 , 39841 , 39847 , 39857 , 39863 , 39869 , 39877 , 39883 , 39887 , 39901 , 39929 , 39937 , 39953 , 39971 , 39979 , 39983 , 39989 , 40009 , 40013 , 40031 , 40037 , 40039 , 40063 , 40087 , 40093 , 40099 , 40111 , 40123 , 40127 , 40129 , 40151 , 40153 , 40163 , 40169 , 40177 , 40189 , 40193 , 40213 , 40231 , 40237 , 40241 , 40253 , 40277 , 40283 , 40289 , 40343 , 40351 , 40357 , 40361 , 40387 , 40423 , 40427 , 40429 , 40433 , 40459 , 40471 , 40483 , 40487 , 40493 , 40499 , 40507 , 40519 , 40529 , 40531 , 40543 , 40559 , 40577 , 40583 , 40591 , 40597 , 40609 , 40627 , 40637 , 40639 , 40693 , 40697 , 40699 , 40709 , 40739 , 40751 , 40759 , 40763 , 40771 , 40787 , 40801 , 40813 , 40819 , 40823 , 40829 , 40841 , 40847 , 40849 , 40853 , 40867 , 40879 , 40883 , 40897 , 40903 , 40927 , 40933 , 40939 , 40949 , 40961 , 40973 , 40993 , 41011 , 41017 , 41023 , 41039 , 41047 , 41051 , 41057 , 41077 , 41081 , 41113 , 41117 , 41131 , 41141 , 41143 , 41149 , 41161 , 41177 , 41179 , 41183 , 41189 , 41201 , 41203 , 41213 , 41221 , 41227 , 41231 , 41233 , 41243 , 41257 , 41263 , 41269 , 41281 , 41299 , 41333 , 41341 , 41351 , 41357 , 41381 , 41387 , 41389 , 41399 , 41411 , 41413 , 41443 , 41453 , 41467 , 41479 , 41491 , 41507 , 41513 , 41519 , 41521 , 41539 , 41543 , 41549 , 41579 , 41593 , 41597 , 41603 , 41609 , 41611 , 41617 , 41621 , 41627 , 41641 , 41647 , 41651 , 41659 , 41669 , 41681 , 41687 , 41719 , 41729 , 41737 , 41759 , 41761 , 41771 , 41777 , 41801 , 41809 , 41813 , 41843 , 41849 , 41851 , 41863 , 41879 , 41887 , 41893 , 41897 , 41903 , 41911 , 41927 , 41941 , 41947 , 41953 , 41957 , 41959 , 41969 , 41981 , 41983 , 41999 , 42013 , 42017 , 42019 , 42023 , 42043 , 42061 , 42071 , 42073 , 42083 , 42089 , 42101 , 42131 , 42139 , 42157 , 42169 , 42179 , 42181 , 42187 , 42193 , 42197 , 42209 , 42221 , 42223 , 42227 , 42239 , 42257 , 42281 , 42283 , 42293 , 42299 , 42307 , 42323 , 42331 , 42337 , 42349 , 42359 , 42373 , 42379 , 42391 , 42397 , 42403 , 42407 , 42409 , 42433 , 42437 , 42443 , 42451 , 42457 , 42461 , 42463 , 42467 , 42473 , 42487 , 42491 , 42499 , 42509 , 42533 , 42557 , 42569 , 42571 , 42577 , 42589 , 42611 , 42641 , 42643 , 42649 , 42667 , 42677 , 42683 , 42689 , 42697 , 42701 , 42703 , 42709 , 42719 , 42727 , 42737 , 42743 , 42751 , 42767 , 42773 , 42787 , 42793 , 42797 , 42821 , 42829 , 42839 , 42841 , 42853 , 42859 , 42863 , 42899 , 42901 , 42923 , 42929 , 42937 , 42943 , 42953 , 42961 , 42967 , 42979 , 42989 , 43003 , 43013 , 43019 , 43037 , 43049 , 43051 , 43063 , 43067 , 43093 , 43103 , 43117 , 43133 , 43151 , 43159 , 43177 , 43189 , 43201 , 43207 , 43223 , 43237 , 43261 , 43271 , 43283 , 43291 , 43313 , 43319 , 43321 , 43331 , 43391 , 43397 , 43399 , 43403 , 43411 , 43427 , 43441 , 43451 , 43457 , 43481 , 43487 , 43499 , 43517 , 43541 , 43543 , 43573 , 43577 , 43579 , 43591 , 43597 , 43607 , 43609 , 43613 , 43627 , 43633 , 43649 , 43651 , 43661 , 43669 , 43691 , 43711 , 43717 , 43721 , 43753 , 43759 , 43777 , 43781 , 43783 , 43787 , 43789 , 43793 , 43801 , 43853 , 43867 , 43889 , 43891 , 43913 , 43933 , 43943 , 43951 , 43961 , 43963 , 43969 , 43973 , 43987 , 43991 , 43997 , 44017 , 44021 , 44027 , 44029 , 44041 , 44053 , 44059 , 44071 , 44087 , 44089 , 44101 , 44111 , 44119 , 44123 , 44129 , 44131 , 44159 , 44171 , 44179 , 44189 , 44201 , 44203 , 44207 , 44221 , 44249 , 44257 , 44263 , 44267 , 44269 , 44273 , 44279 , 44281 , 44293 , 44351 , 44357 , 44371 , 44381 , 44383 , 44389 , 44417 , 44449 , 44453 , 44483 , 44491 , 44497 , 44501 , 44507 , 44519 , 44531 , 44533 , 44537 , 44543 , 44549 , 44563 , 44579 , 44587 , 44617 , 44621 , 44623 , 44633 , 44641 , 44647 , 44651 , 44657 , 44683 , 44687 , 44699 , 44701 , 44711 , 44729 , 44741 , 44753 , 44771 , 44773 , 44777 , 44789 , 44797 , 44809 , 44819 , 44839 , 44843 , 44851 , 44867 , 44879 , 44887 , 44893 , 44909 , 44917 , 44927 , 44939 , 44953 , 44959 , 44963 , 44971 , 44983 , 44987 , 45007 , 45013 , 45053 , 45061 , 45077 , 45083 , 45119 , 45121 , 45127 , 45131 , 45137 , 45139 , 45161 , 45179 , 45181 , 45191 , 45197 , 45233 , 45247 , 45259 , 45263 , 45281 , 45289 , 45293 , 45307 , 45317 , 45319 , 45329 , 45337 , 45341 , 45343 , 45361 , 45377 , 45389 , 45403 , 45413 , 45427 , 45433 , 45439 , 45481 , 45491 , 45497 , 45503 , 45523 , 45533 , 45541 , 45553 , 45557 , 45569 , 45587 , 45589 , 45599 , 45613 , 45631 , 45641 , 45659 , 45667 , 45673 , 45677 , 45691 , 45697 , 45707 , 45737 , 45751 , 45757 , 45763 , 45767 , 45779 , 45817 , 45821 , 45823 , 45827 , 45833 , 45841 , 45853 , 45863 , 45869 , 45887 , 45893 , 45943 , 45949 , 45953 , 45959 , 45971 , 45979 , 45989 , 46021 , 46027 , 46049 , 46051 , 46061 , 46073 , 46091 , 46093 , 46099 , 46103 , 46133 , 46141 , 46147 , 46153 , 46171 , 46181 , 46183 , 46187 , 46199 , 46219 , 46229 , 46237 , 46261 , 46271 , 46273 , 46279 , 46301 , 46307 , 46309 , 46327 , 46337 , 46349 , 46351 , 46381 , 46399 , 46411 , 46439 , 46441 , 46447 , 46451 , 46457 , 46471 , 46477 , 46489 , 46499 , 46507 , 46511 , 46523 , 46549 , 46559 , 46567 , 46573 , 46589 , 46591 , 46601 , 46619 , 46633 , 46639 , 46643 , 46649 , 46663 , 46679 , 46681 , 46687 , 46691 , 46703 , 46723 , 46727 , 46747 , 46751 , 46757 , 46769 , 46771 , 46807 , 46811 , 46817 , 46819 , 46829 , 46831 , 46853 , 46861 , 46867 , 46877 , 46889 , 46901 , 46919 , 46933 , 46957 , 46993 , 46997 , 47017 , 47041 , 47051 , 47057 , 47059 , 47087 , 47093 , 47111 , 47119 , 47123 , 47129 , 47137 , 47143 , 47147 , 47149 , 47161 , 47189 , 47207 , 47221 , 47237 , 47251 , 47269 , 47279 , 47287 , 47293 , 47297 , 47303 , 47309 , 47317 , 47339 , 47351 , 47353 , 47363 , 47381 , 47387 , 47389 , 47407 , 47417 , 47419 , 47431 , 47441 , 47459 , 47491 , 47497 , 47501 , 47507 , 47513 , 47521 , 47527 , 47533 , 47543 , 47563 , 47569 , 47581 , 47591 , 47599 , 47609 , 47623 , 47629 , 47639 , 47653 , 47657 , 47659 , 47681 , 47699 , 47701 , 47711 , 47713 , 47717 , 47737 , 47741 , 47743 , 47777 , 47779 , 47791 , 47797 , 47807 , 47809 , 47819 , 47837 , 47843 , 47857 , 47869 , 47881 , 47903 , 47911 , 47917 , 47933 , 47939 , 47947 , 47951 , 47963 , 47969 , 47977 , 47981 , 48017 , 48023 , 48029 , 48049 , 48073 , 48079 , 48091 , 48109 , 48119 , 48121 , 48131 , 48157 , 48163 , 48179 , 48187 , 48193 , 48197 , 48221 , 48239 , 48247 , 48259 , 48271 , 48281 , 48299 , 48311 , 48313 , 48337 , 48341 , 48353 , 48371 , 48383 , 48397 , 48407 , 48409 , 48413 , 48437 , 48449 , 48463 , 48473 , 48479 , 48481 , 48487 , 48491 , 48497 , 48523 , 48527 , 48533 , 48539 , 48541 , 48563 , 48571 , 48589 , 48593 , 48611 , 48619 , 48623 , 48647 , 48649 , 48661 , 48673 , 48677 , 48679 , 48731 , 48733 , 48751 , 48757 , 48761 , 48767 , 48779 , 48781 , 48787 , 48799 , 48809 , 48817 , 48821 , 48823 , 48847 , 48857 , 48859 , 48869 , 48871 , 48883 , 48889 , 48907 , 48947 , 48953 , 48973 , 48989 , 48991 , 49003 , 49009 , 49019 , 49031 , 49033 , 49037 , 49043 , 49057 , 49069 , 49081 , 49103 , 49109 , 49117 , 49121 , 49123 , 49139 , 49157 , 49169 , 49171 , 49177 , 49193 , 49199 , 49201 , 49207 , 49211 , 49223 , 49253 , 49261 , 49277 , 49279 , 49297 , 49307 , 49331 , 49333 , 49339 , 49363 , 49367 , 49369 , 49391 , 49393 , 49409 , 49411 , 49417 , 49429 , 49433 , 49451 , 49459 , 49463 , 49477 , 49481 , 49499 , 49523 , 49529 , 49531 , 49537 , 49547 , 49549 , 49559 , 49597 , 49603 , 49613 , 49627 , 49633 , 49639 , 49663 , 49667 , 49669 , 49681 , 49697 , 49711 , 49727 , 49739 , 49741 , 49747 , 49757 , 49783 , 49787 , 49789 , 49801 , 49807 , 49811 , 49823 , 49831 , 49843 , 49853 , 49871 , 49877 , 49891 , 49919 , 49921 , 49927 , 49937 , 49939 , 49943 , 49957 , 49991 , 49993 , 49999 , 50021 , 50023 , 50033 , 50047 , 50051 , 50053 , 50069 , 50077 , 50087 , 50093 , 50101 , 50111 , 50119 , 50123 , 50129 , 50131 , 50147 , 50153 , 50159 , 50177 , 50207 , 50221 , 50227 , 50231 , 50261 , 50263 , 50273 , 50287 , 50291 , 50311 , 50321 , 50329 , 50333 , 50341 , 50359 , 50363 , 50377 , 50383 , 50387 , 50411 , 50417 , 50423 , 50441 , 50459 , 50461 , 50497 , 50503 , 50513 , 50527 , 50539 , 50543 , 50549 , 50551 , 50581 , 50587 , 50591 , 50593 , 50599 , 50627 , 50647 , 50651 , 50671 , 50683 , 50707 , 50723 , 50741 , 50753 , 50767 , 50773 , 50777 , 50789 , 50821 , 50833 , 50839 , 50849 , 50857 , 50867 , 50873 , 50891 , 50893 , 50909 , 50923 , 50929 , 50951 , 50957 , 50969 , 50971 , 50989 , 50993 , 51001 , 51031 , 51043 , 51047 , 51059 , 51061 , 51071 , 51109 , 51131 , 51133 , 51137 , 51151 , 51157 , 51169 , 51193 , 51197 , 51199 , 51203 , 51217 , 51229 , 51239 , 51241 , 51257 , 51263 , 51283 , 51287 , 51307 , 51329 , 51341 , 51343 , 51347 , 51349 , 51361 , 51383 , 51407 , 51413 , 51419 , 51421 , 51427 , 51431 , 51437 , 51439 , 51449 , 51461 , 51473 , 51479 , 51481 , 51487 , 51503 , 51511 , 51517 , 51521 , 51539 , 51551 , 51563 , 51577 , 51581 , 51593 , 51599 , 51607 , 51613 , 51631 , 51637 , 51647 , 51659 , 51673 , 51679 , 51683 , 51691 , 51713 , 51719 , 51721 , 51749 , 51767 , 51769 , 51787 , 51797 , 51803 , 51817 , 51827 , 51829 , 51839 , 51853 , 51859 , 51869 , 51871 , 51893 , 51899 , 51907 , 51913 , 51929 , 51941 , 51949 , 51971 , 51973 , 51977 , 51991 , 52009 , 52021 , 52027 , 52051 , 52057 , 52067 , 52069 , 52081 , 52103 , 52121 , 52127 , 52147 , 52153 , 52163 , 52177 , 52181 , 52183 , 52189 , 52201 , 52223 , 52237 , 52249 , 52253 , 52259 , 52267 , 52289 , 52291 , 52301 , 52313 , 52321 , 52361 , 52363 , 52369 , 52379 , 52387 , 52391 , 52433 , 52453 , 52457 , 52489 , 52501 , 52511 , 52517 , 52529 , 52541 , 52543 , 52553 , 52561 , 52567 , 52571 , 52579 , 52583 , 52609 , 52627 , 52631 , 52639 , 52667 , 52673 , 52691 , 52697 , 52709 , 52711 , 52721 , 52727 , 52733 , 52747 , 52757 , 52769 , 52783 , 52807 , 52813 , 52817 , 52837 , 52859 , 52861 , 52879 , 52883 , 52889 , 52901 , 52903 , 52919 , 52937 , 52951 , 52957 , 52963 , 52967 , 52973 , 52981 , 52999 , 53003 , 53017 , 53047 , 53051 , 53069 , 53077 , 53087 , 53089 , 53093 , 53101 , 53113 , 53117 , 53129 , 53147 , 53149 , 53161 , 53171 , 53173 , 53189 , 53197 , 53201 , 53231 , 53233 , 53239 , 53267 , 53269 , 53279 , 53281 , 53299 , 53309 , 53323 , 53327 , 53353 , 53359 , 53377 , 53381 , 53401 , 53407 , 53411 , 53419 , 53437 , 53441 , 53453 , 53479 , 53503 , 53507 , 53527 , 53549 , 53551 , 53569 , 53591 , 53593 , 53597 , 53609 , 53611 , 53617 , 53623 , 53629 , 53633 , 53639 , 53653 , 53657 , 53681 , 53693 , 53699 , 53717 , 53719 , 53731 , 53759 , 53773 , 53777 , 53783 , 53791 , 53813 , 53819 , 53831 , 53849 , 53857 , 53861 , 53881 , 53887 , 53891 , 53897 , 53899 , 53917 , 53923 , 53927 , 53939 , 53951 , 53959 , 53987 , 53993 , 54001 , 54011 , 54013 , 54037 , 54049 , 54059 , 54083 , 54091 , 54101 , 54121 , 54133 , 54139 , 54151 , 54163 , 54167 , 54181 , 54193 , 54217 , 54251 , 54269 , 54277 , 54287 , 54293 , 54311 , 54319 , 54323 , 54331 , 54347 , 54361 , 54367 , 54371 , 54377 , 54401 , 54403 , 54409 , 54413 , 54419 , 54421 , 54437 , 54443 , 54449 , 54469 , 54493 , 54497 , 54499 , 54503 , 54517 , 54521 , 54539 , 54541 , 54547 , 54559 , 54563 , 54577 , 54581 , 54583 , 54601 , 54617 , 54623 , 54629 , 54631 , 54647 , 54667 , 54673 , 54679 , 54709 , 54713 , 54721 , 54727 , 54751 , 54767 , 54773 , 54779 , 54787 , 54799 , 54829 , 54833 , 54851 , 54869 , 54877 , 54881 , 54907 , 54917 , 54919 , 54941 , 54949 , 54959 , 54973 , 54979 , 54983 , 55001 , 55009 , 55021 , 55049 , 55051 , 55057 , 55061 , 55073 , 55079 , 55103 , 55109 , 55117 , 55127 , 55147 , 55163 , 55171 , 55201 , 55207 , 55213 , 55217 , 55219 , 55229 , 55243 , 55249 , 55259 , 55291 , 55313 , 55331 , 55333 , 55337 , 55339 , 55343 , 55351 , 55373 , 55381 , 55399 , 55411 , 55439 , 55441 , 55457 , 55469 , 55487 , 55501 , 55511 , 55529 , 55541 , 55547 , 55579 , 55589 , 55603 , 55609 , 55619 , 55621 , 55631 , 55633 , 55639 , 55661 , 55663 , 55667 , 55673 , 55681 , 55691 , 55697 , 55711 , 55717 , 55721 , 55733 , 55763 , 55787 , 55793 , 55799 , 55807 , 55813 , 55817 , 55819 , 55823 , 55829 , 55837 , 55843 , 55849 , 55871 , 55889 , 55897 , 55901 , 55903 , 55921 , 55927 , 55931 , 55933 , 55949 , 55967 , 55987 , 55997 , 56003 , 56009 , 56039 , 56041 , 56053 , 56081 , 56087 , 56093 , 56099 , 56101 , 56113 , 56123 , 56131 , 56149 , 56167 , 56171 , 56179 , 56197 , 56207 , 56209 , 56237 , 56239 , 56249 , 56263 , 56267 , 56269 , 56299 , 56311 , 56333 , 56359 , 56369 , 56377 , 56383 , 56393 , 56401 , 56417 , 56431 , 56437 , 56443 , 56453 , 56467 , 56473 , 56477 , 56479 , 56489 , 56501 , 56503 , 56509 , 56519 , 56527 , 56531 , 56533 , 56543 , 56569 , 56591 , 56597 , 56599 , 56611 , 56629 , 56633 , 56659 , 56663 , 56671 , 56681 , 56687 , 56701 , 56711 , 56713 , 56731 , 56737 , 56747 , 56767 , 56773 , 56779 , 56783 , 56807 , 56809 , 56813 , 56821 , 56827 , 56843 , 56857 , 56873 , 56891 , 56893 , 56897 , 56909 , 56911 , 56921 , 56923 , 56929 , 56941 , 56951 , 56957 , 56963 , 56983 , 56989 , 56993 , 56999 , 57037 , 57041 , 57047 , 57059 , 57073 , 57077 , 57089 , 57097 , 57107 , 57119 , 57131 , 57139 , 57143 , 57149 , 57163 , 57173 , 57179 , 57191 , 57193 , 57203 , 57221 , 57223 , 57241 , 57251 , 57259 , 57269 , 57271 , 57283 , 57287 , 57301 , 57329 , 57331 , 57347 , 57349 , 57367 , 57373 , 57383 , 57389 , 57397 , 57413 , 57427 , 57457 , 57467 , 57487 , 57493 , 57503 , 57527 , 57529 , 57557 , 57559 , 57571 , 57587 , 57593 , 57601 , 57637 , 57641 , 57649 , 57653 , 57667 , 57679 , 57689 , 57697 , 57709 , 57713 , 57719 , 57727 , 57731 , 57737 , 57751 , 57773 , 57781 , 57787 , 57791 , 57793 , 57803 , 57809 , 57829 , 57839 , 57847 , 57853 , 57859 , 57881 , 57899 , 57901 , 57917 , 57923 , 57943 , 57947 , 57973 , 57977 , 57991 , 58013 , 58027 , 58031 , 58043 , 58049 , 58057 , 58061 , 58067 , 58073 , 58099 , 58109 , 58111 , 58129 , 58147 , 58151 , 58153 , 58169 , 58171 , 58189 , 58193 , 58199 , 58207 , 58211 , 58217 , 58229 , 58231 , 58237 , 58243 , 58271 , 58309 , 58313 , 58321 , 58337 , 58363 , 58367 , 58369 , 58379 , 58391 , 58393 , 58403 , 58411 , 58417 , 58427 , 58439 , 58441 , 58451 , 58453 , 58477 , 58481 , 58511 , 58537 , 58543 , 58549 , 58567 , 58573 , 58579 , 58601 , 58603 , 58613 , 58631 , 58657 , 58661 , 58679 , 58687 , 58693 , 58699 , 58711 , 58727 , 58733 , 58741 , 58757 , 58763 , 58771 , 58787 , 58789 , 58831 , 58889 , 58897 , 58901 , 58907 , 58909 , 58913 , 58921 , 58937 , 58943 , 58963 , 58967 , 58979 , 58991 , 58997 , 59009 , 59011 , 59021 , 59023 , 59029 , 59051 , 59053 , 59063 , 59069 , 59077 , 59083 , 59093 , 59107 , 59113 , 59119 , 59123 , 59141 , 59149 , 59159 , 59167 , 59183 , 59197 , 59207 , 59209 , 59219 , 59221 , 59233 , 59239 , 59243 , 59263 , 59273 , 59281 , 59333 , 59341 , 59351 , 59357 , 59359 , 59369 , 59377 , 59387 , 59393 , 59399 , 59407 , 59417 , 59419 , 59441 , 59443 , 59447 , 59453 , 59467 , 59471 , 59473 , 59497 , 59509 , 59513 , 59539 , 59557 , 59561 , 59567 , 59581 , 59611 , 59617 , 59621 , 59627 , 59629 , 59651 , 59659 , 59663 , 59669 , 59671 , 59693 , 59699 , 59707 , 59723 , 59729 , 59743 , 59747 , 59753 , 59771 , 59779 , 59791 , 59797 , 59809 , 59833 , 59863 , 59879 , 59887 , 59921 , 59929 , 59951 , 59957 , 59971 , 59981 , 59999 , 60013 , 60017 , 60029 , 60037 , 60041 , 60077 , 60083 , 60089 , 60091 , 60101 , 60103 , 60107 , 60127 , 60133 , 60139 , 60149 , 60161 , 60167 , 60169 , 60209 , 60217 , 60223 , 60251 , 60257 , 60259 , 60271 , 60289 , 60293 , 60317 , 60331 , 60337 , 60343 , 60353 , 60373 , 60383 , 60397 , 60413 , 60427 , 60443 , 60449 , 60457 , 60493 , 60497 , 60509 , 60521 , 60527 , 60539 , 60589 , 60601 , 60607 , 60611 , 60617 , 60623 , 60631 , 60637 , 60647 , 60649 , 60659 , 60661 , 60679 , 60689 , 60703 , 60719 , 60727 , 60733 , 60737 , 60757 , 60761 , 60763 , 60773 , 60779 , 60793 , 60811 , 60821 , 60859 , 60869 , 60887 , 60889 , 60899 , 60901 , 60913 , 60917 , 60919 , 60923 , 60937 , 60943 , 60953 , 60961 , 61001 , 61007 , 61027 , 61031 , 61043 , 61051 , 61057 , 61091 , 61099 , 61121 , 61129 , 61141 , 61151 , 61153 , 61169 , 61211 , 61223 , 61231 , 61253 , 61261 , 61283 , 61291 , 61297 , 61331 , 61333 , 61339 , 61343 , 61357 , 61363 , 61379 , 61381 , 61403 , 61409 , 61417 , 61441 , 61463 , 61469 , 61471 , 61483 , 61487 , 61493 , 61507 , 61511 , 61519 , 61543 , 61547 , 61553 , 61559 , 61561 , 61583 , 61603 , 61609 , 61613 , 61627 , 61631 , 61637 , 61643 , 61651 , 61657 , 61667 , 61673 , 61681 , 61687 , 61703 , 61717 , 61723 , 61729 , 61751 , 61757 , 61781 , 61813 , 61819 , 61837 , 61843 , 61861 , 61871 , 61879 , 61909 , 61927 , 61933 , 61949 , 61961 , 61967 , 61979 , 61981 , 61987 , 61991 , 62003 , 62011 , 62017 , 62039 , 62047 , 62053 , 62057 , 62071 , 62081 , 62099 , 62119 , 62129 , 62131 , 62137 , 62141 , 62143 , 62171 , 62189 , 62191 , 62201 , 62207 , 62213 , 62219 , 62233 , 62273 , 62297 , 62299 , 62303 , 62311 , 62323 , 62327 , 62347 , 62351 , 62383 , 62401 , 62417 , 62423 , 62459 , 62467 , 62473 , 62477 , 62483 , 62497 , 62501 , 62507 , 62533 , 62539 , 62549 , 62563 , 62581 , 62591 , 62597 , 62603 , 62617 , 62627 , 62633 , 62639 , 62653 , 62659 , 62683 , 62687 , 62701 , 62723 , 62731 , 62743 , 62753 , 62761 , 62773 , 62791 , 62801 , 62819 , 62827 , 62851 , 62861 , 62869 , 62873 , 62897 , 62903 , 62921 , 62927 , 62929 , 62939 , 62969 , 62971 , 62981 , 62983 , 62987 , 62989 , 63029 , 63031 , 63059 , 63067 , 63073 , 63079 , 63097 , 63103 , 63113 , 63127 , 63131 , 63149 , 63179 , 63197 , 63199 , 63211 , 63241 , 63247 , 63277 , 63281 , 63299 , 63311 , 63313 , 63317 , 63331 , 63337 , 63347 , 63353 , 63361 , 63367 , 63377 , 63389 , 63391 , 63397 , 63409 , 63419 , 63421 , 63439 , 63443 , 63463 , 63467 , 63473 , 63487 , 63493 , 63499 , 63521 , 63527 , 63533 , 63541 , 63559 , 63577 , 63587 , 63589 , 63599 , 63601 , 63607 , 63611 , 63617 , 63629 , 63647 , 63649 , 63659 , 63667 , 63671 , 63689 , 63691 , 63697 , 63703 , 63709 , 63719 , 63727 , 63737 , 63743 , 63761 , 63773 , 63781 , 63793 , 63799 , 63803 , 63809 , 63823 , 63839 , 63841 , 63853 , 63857 , 63863 , 63901 , 63907 , 63913 , 63929 , 63949 , 63977 , 63997 , 64007 , 64013 , 64019 , 64033 , 64037 , 64063 , 64067 , 64081 , 64091 , 64109 , 64123 , 64151 , 64153 , 64157 , 64171 , 64187 , 64189 , 64217 , 64223 , 64231 , 64237 , 64271 , 64279 , 64283 , 64301 , 64303 , 64319 , 64327 , 64333 , 64373 , 64381 , 64399 , 64403 , 64433 , 64439 , 64451 , 64453 , 64483 , 64489 , 64499 , 64513 , 64553 , 64567 , 64577 , 64579 , 64591 , 64601 , 64609 , 64613 , 64621 , 64627 , 64633 , 64661 , 64663 , 64667 , 64679 , 64693 , 64709 , 64717 , 64747 , 64763 , 64781 , 64783 , 64793 , 64811 , 64817 , 64849 , 64853 , 64871 , 64877 , 64879 , 64891 , 64901 , 64919 , 64921 , 64927 , 64937 , 64951 , 64969 , 64997 , 65003 , 65011 , 65027 , 65029 , 65033 , 65053 , 65063 , 65071 , 65089 , 65099 , 65101 , 65111 , 65119 , 65123 , 65129 , 65141 , 65147 , 65167 , 65171 , 65173 , 65179 , 65183 , 65203 , 65213 , 65239 , 65257 , 65267 , 65269 , 65287 , 65293 , 65309 , 65323 , 65327 , 65353 , 65357 , 65371 , 65381 , 65393 , 65407 , 65413 , 65419 , 65423 , 65437 , 65447 , 65449 , 65479 , 65497 , 65519 , 65521 , 65537 , 65539 , 65543 , 65551 , 65557 , 65563 , 65579 , 65581 , 65587 , 65599 , 65609 , 65617 , 65629 , 65633 , 65647 , 65651 , 65657 , 65677 , 65687 , 65699 , 65701 , 65707 , 65713 , 65717 , 65719 , 65729 , 65731 , 65761 , 65777 , 65789 , 65809 , 65827 , 65831 , 65837 , 65839 , 65843 , 65851 , 65867 , 65881 , 65899 , 65921 , 65927 , 65929 , 65951 , 65957 , 65963 , 65981 , 65983 , 65993 , 66029 , 66037 , 66041 , 66047 , 66067 , 66071 , 66083 , 66089 , 66103 , 66107 , 66109 , 66137 , 66161 , 66169 , 66173 , 66179 , 66191 , 66221 , 66239 , 66271 , 66293 , 66301 , 66337 , 66343 , 66347 , 66359 , 66361 , 66373 , 66377 , 66383 , 66403 , 66413 , 66431 , 66449 , 66457 , 66463 , 66467 , 66491 , 66499 , 66509 , 66523 , 66529 , 66533 , 66541 , 66553 , 66569 , 66571 , 66587 , 66593 , 66601 , 66617 , 66629 , 66643 , 66653 , 66683 , 66697 , 66701 , 66713 , 66721 , 66733 , 66739 , 66749 , 66751 , 66763 , 66791 , 66797 , 66809 , 66821 , 66841 , 66851 , 66853 , 66863 , 66877 , 66883 , 66889 , 66919 , 66923 , 66931 , 66943 , 66947 , 66949 , 66959 , 66973 , 66977 , 67003 , 67021 , 67033 , 67043 , 67049 , 67057 , 67061 , 67073 , 67079 , 67103 , 67121 , 67129 , 67139 , 67141 , 67153 , 67157 , 67169 , 67181 , 67187 , 67189 , 67211 , 67213 , 67217 , 67219 , 67231 , 67247 , 67261 , 67271 , 67273 , 67289 , 67307 , 67339 , 67343 , 67349 , 67369 , 67391 , 67399 , 67409 , 67411 , 67421 , 67427 , 67429 , 67433 , 67447 , 67453 , 67477 , 67481 , 67489 , 67493 , 67499 , 67511 , 67523 , 67531 , 67537 , 67547 , 67559 , 67567 , 67577 , 67579 , 67589 , 67601 , 67607 , 67619 , 67631 , 67651 , 67679 , 67699 , 67709 , 67723 , 67733 , 67741 , 67751 , 67757 , 67759 , 67763 , 67777 , 67783 , 67789 , 67801 , 67807 , 67819 , 67829 , 67843 , 67853 , 67867 , 67883 , 67891 , 67901 , 67927 , 67931 , 67933 , 67939 , 67943 , 67957 , 67961 , 67967 , 67979 , 67987 , 67993 , 68023 , 68041 , 68053 , 68059 , 68071 , 68087 , 68099 , 68111 , 68113 , 68141 , 68147 , 68161 , 68171 , 68207 , 68209 , 68213 , 68219 , 68227 , 68239 , 68261 , 68279 , 68281 , 68311 , 68329 , 68351 , 68371 , 68389 , 68399 , 68437 , 68443 , 68447 , 68449 , 68473 , 68477 , 68483 , 68489 , 68491 , 68501 , 68507 , 68521 , 68531 , 68539 , 68543 , 68567 , 68581 , 68597 , 68611 , 68633 , 68639 , 68659 , 68669 , 68683 , 68687 , 68699 , 68711 , 68713 , 68729 , 68737 , 68743 , 68749 , 68767 , 68771 , 68777 , 68791 , 68813 , 68819 , 68821 , 68863 , 68879 , 68881 , 68891 , 68897 , 68899 , 68903 , 68909 , 68917 , 68927 , 68947 , 68963 , 68993 , 69001 , 69011 , 69019 , 69029 , 69031 , 69061 , 69067 , 69073 , 69109 , 69119 , 69127 , 69143 , 69149 , 69151 , 69163 , 69191 , 69193 , 69197 , 69203 , 69221 , 69233 , 69239 , 69247 , 69257 , 69259 , 69263 , 69313 , 69317 , 69337 , 69341 , 69371 , 69379 , 69383 , 69389 , 69401 , 69403 , 69427 , 69431 , 69439 , 69457 , 69463 , 69467 , 69473 , 69481 , 69491 , 69493 , 69497 , 69499 , 69539 , 69557 , 69593 , 69623 , 69653 , 69661 , 69677 , 69691 , 69697 , 69709 , 69737 , 69739 , 69761 , 69763 , 69767 , 69779 , 69809 , 69821 , 69827 , 69829 , 69833 , 69847 , 69857 , 69859 , 69877 , 69899 , 69911 , 69929 , 69931 , 69941 , 69959 , 69991 , 69997 , 70001 , 70003 , 70009 , 70019 , 70039 , 70051 , 70061 , 70067 , 70079 , 70099 , 70111 , 70117 , 70121 , 70123 , 70139 , 70141 , 70157 , 70163 , 70177 , 70181 , 70183 , 70199 , 70201 , 70207 , 70223 , 70229 , 70237 , 70241 , 70249 , 70271 , 70289 , 70297 , 70309 , 70313 , 70321 , 70327 , 70351 , 70373 , 70379 , 70381 , 70393 , 70423 , 70429 , 70439 , 70451 , 70457 , 70459 , 70481 , 70487 , 70489 , 70501 , 70507 , 70529 , 70537 , 70549 , 70571 , 70573 , 70583 , 70589 , 70607 , 70619 , 70621 , 70627 , 70639 , 70657 , 70663 , 70667 , 70687 , 70709 , 70717 , 70729 , 70753 , 70769 , 70783 , 70793 , 70823 , 70841 , 70843 , 70849 , 70853 , 70867 , 70877 , 70879 , 70891 , 70901 , 70913 , 70919 , 70921 , 70937 , 70949 , 70951 , 70957 , 70969 , 70979 , 70981 , 70991 , 70997 , 70999 , 71011 , 71023 , 71039 , 71059 , 71069 , 71081 , 71089 , 71119 , 71129 , 71143 , 71147 , 71153 , 71161 , 71167 , 71171 , 71191 , 71209 , 71233 , 71237 , 71249 , 71257 , 71261 , 71263 , 71287 , 71293 , 71317 , 71327 , 71329 , 71333 , 71339 , 71341 , 71347 , 71353 , 71359 , 71363 , 71387 , 71389 , 71399 , 71411 , 71413 , 71419 , 71429 , 71437 , 71443 , 71453 , 71471 , 71473 , 71479 , 71483 , 71503 , 71527 , 71537 , 71549 , 71551 , 71563 , 71569 , 71593 , 71597 , 71633 , 71647 , 71663 , 71671 , 71693 , 71699 , 71707 , 71711 , 71713 , 71719 , 71741 , 71761 , 71777 , 71789 , 71807 , 71809 , 71821 , 71837 , 71843 , 71849 , 71861 , 71867 , 71879 , 71881 , 71887 , 71899 , 71909 , 71917 , 71933 , 71941 , 71947 , 71963 , 71971 , 71983 , 71987 , 71993 , 71999 , 72019 , 72031 , 72043 , 72047 , 72053 , 72073 , 72077 , 72089 , 72091 , 72101 , 72103 , 72109 , 72139 , 72161 , 72167 , 72169 , 72173 , 72211 , 72221 , 72223 , 72227 , 72229 , 72251 , 72253 , 72269 , 72271 , 72277 , 72287 , 72307 , 72313 , 72337 , 72341 , 72353 , 72367 , 72379 , 72383 , 72421 , 72431 , 72461 , 72467 , 72469 , 72481 , 72493 , 72497 , 72503 , 72533 , 72547 , 72551 , 72559 , 72577 , 72613 , 72617 , 72623 , 72643 , 72647 , 72649 , 72661 , 72671 , 72673 , 72679 , 72689 , 72701 , 72707 , 72719 , 72727 , 72733 , 72739 , 72763 , 72767 , 72797 , 72817 , 72823 , 72859 , 72869 , 72871 , 72883 , 72889 , 72893 , 72901 , 72907 , 72911 , 72923 , 72931 , 72937 , 72949 , 72953 , 72959 , 72973 , 72977 , 72997 , 73009 , 73013 , 73019 , 73037 , 73039 , 73043 , 73061 , 73063 , 73079 , 73091 , 73121 , 73127 , 73133 , 73141 , 73181 , 73189 , 73237 , 73243 , 73259 , 73277 , 73291 , 73303 , 73309 , 73327 , 73331 , 73351 , 73361 , 73363 , 73369 , 73379 , 73387 , 73417 , 73421 , 73433 , 73453 , 73459 , 73471 , 73477 , 73483 , 73517 , 73523 , 73529 , 73547 , 73553 , 73561 , 73571 , 73583 , 73589 , 73597 , 73607 , 73609 , 73613 , 73637 , 73643 , 73651 , 73673 , 73679 , 73681 , 73693 , 73699 , 73709 , 73721 , 73727 , 73751 , 73757 , 73771 , 73783 , 73819 , 73823 , 73847 , 73849 , 73859 , 73867 , 73877 , 73883 , 73897 , 73907 , 73939 , 73943 , 73951 , 73961 , 73973 , 73999 , 74017 , 74021 , 74027 , 74047 , 74051 , 74071 , 74077 , 74093 , 74099 , 74101 , 74131 , 74143 , 74149 , 74159 , 74161 , 74167 , 74177 , 74189 , 74197 , 74201 , 74203 , 74209 , 74219 , 74231 , 74257 , 74279 , 74287 , 74293 , 74297 , 74311 , 74317 , 74323 , 74353 , 74357 , 74363 , 74377 , 74381 , 74383 , 74411 , 74413 , 74419 , 74441 , 74449 , 74453 , 74471 , 74489 , 74507 , 74509 , 74521 , 74527 , 74531 , 74551 , 74561 , 74567 , 74573 , 74587 , 74597 , 74609 , 74611 , 74623 , 74653 , 74687 , 74699 , 74707 , 74713 , 74717 , 74719 , 74729 , 74731 , 74747 , 74759 , 74761 , 74771 , 74779 , 74797 , 74821 , 74827 , 74831 , 74843 , 74857 , 74861 , 74869 , 74873 , 74887 , 74891 , 74897 , 74903 , 74923 , 74929 , 74933 , 74941 , 74959 , 75011 , 75013 , 75017 , 75029 , 75037 , 75041 , 75079 , 75083 , 75109 , 75133 , 75149 , 75161 , 75167 , 75169 , 75181 , 75193 , 75209 , 75211 , 75217 , 75223 , 75227 , 75239 , 75253 , 75269 , 75277 , 75289 , 75307 , 75323 , 75329 , 75337 , 75347 , 75353 , 75367 , 75377 , 75389 , 75391 , 75401 , 75403 , 75407 , 75431 , 75437 , 75479 , 75503 , 75511 , 75521 , 75527 , 75533 , 75539 , 75541 , 75553 , 75557 , 75571 , 75577 , 75583 , 75611 , 75617 , 75619 , 75629 , 75641 , 75653 , 75659 , 75679 , 75683 , 75689 , 75703 , 75707 , 75709 , 75721 , 75731 , 75743 , 75767 , 75773 , 75781 , 75787 , 75793 , 75797 , 75821 , 75833 , 75853 , 75869 , 75883 , 75913 , 75931 , 75937 , 75941 , 75967 , 75979 , 75983 , 75989 , 75991 , 75997 , 76001 , 76003 , 76031 , 76039 , 76079 , 76081 , 76091 , 76099 , 76103 , 76123 , 76129 , 76147 , 76157 , 76159 , 76163 , 76207 , 76213 , 76231 , 76243 , 76249 , 76253 , 76259 , 76261 , 76283 , 76289 , 76303 , 76333 , 76343 , 76367 , 76369 , 76379 , 76387 , 76403 , 76421 , 76423 , 76441 , 76463 , 76471 , 76481 , 76487 , 76493 , 76507 , 76511 , 76519 , 76537 , 76541 , 76543 , 76561 , 76579 , 76597 , 76603 , 76607 , 76631 , 76649 , 76651 , 76667 , 76673 , 76679 , 76697 , 76717 , 76733 , 76753 , 76757 , 76771 , 76777 , 76781 , 76801 , 76819 , 76829 , 76831 , 76837 , 76847 , 76871 , 76873 , 76883 , 76907 , 76913 , 76919 , 76943 , 76949 , 76961 , 76963 , 76991 , 77003 , 77017 , 77023 , 77029 , 77041 , 77047 , 77069 , 77081 , 77093 , 77101 , 77137 , 77141 , 77153 , 77167 , 77171 , 77191 , 77201 , 77213 , 77237 , 77239 , 77243 , 77249 , 77261 , 77263 , 77267 , 77269 , 77279 , 77291 , 77317 , 77323 , 77339 , 77347 , 77351 , 77359 , 77369 , 77377 , 77383 , 77417 , 77419 , 77431 , 77447 , 77471 , 77477 , 77479 , 77489 , 77491 , 77509 , 77513 , 77521 , 77527 , 77543 , 77549 , 77551 , 77557 , 77563 , 77569 , 77573 , 77587 , 77591 , 77611 , 77617 , 77621 , 77641 , 77647 , 77659 , 77681 , 77687 , 77689 , 77699 , 77711 , 77713 , 77719 , 77723 , 77731 , 77743 , 77747 , 77761 , 77773 , 77783 , 77797 , 77801 , 77813 , 77839 , 77849 , 77863 , 77867 , 77893 , 77899 , 77929 , 77933 , 77951 , 77969 , 77977 , 77983 , 77999 , 78007 , 78017 , 78031 , 78041 , 78049 , 78059 , 78079 , 78101 , 78121 , 78137 , 78139 , 78157 , 78163 , 78167 , 78173 , 78179 , 78191 , 78193 , 78203 , 78229 , 78233 , 78241 , 78259 , 78277 , 78283 , 78301 , 78307 , 78311 , 78317 , 78341 , 78347 , 78367 , 78401 , 78427 , 78437 , 78439 , 78467 , 78479 , 78487 , 78497 , 78509 , 78511 , 78517 , 78539 , 78541 , 78553 , 78569 , 78571 , 78577 , 78583 , 78593 , 78607 , 78623 , 78643 , 78649 , 78653 , 78691 , 78697 , 78707 , 78713 , 78721 , 78737 , 78779 , 78781 , 78787 , 78791 , 78797 , 78803 , 78809 , 78823 , 78839 , 78853 , 78857 , 78877 , 78887 , 78889 , 78893 , 78901 , 78919 , 78929 , 78941 , 78977 , 78979 , 78989 , 79031 , 79039 , 79043 , 79063 , 79087 , 79103 , 79111 , 79133 , 79139 , 79147 , 79151 , 79153 , 79159 , 79181 , 79187 , 79193 , 79201 , 79229 , 79231 , 79241 , 79259 , 79273 , 79279 , 79283 , 79301 , 79309 , 79319 , 79333 , 79337 , 79349 , 79357 , 79367 , 79379 , 79393 , 79397 , 79399 , 79411 , 79423 , 79427 , 79433 , 79451 , 79481 , 79493 , 79531 , 79537 , 79549 , 79559 , 79561 , 79579 , 79589 , 79601 , 79609 , 79613 , 79621 , 79627 , 79631 , 79633 , 79657 , 79669 , 79687 , 79691 , 79693 , 79697 , 79699 , 79757 , 79769 , 79777 , 79801 , 79811 , 79813 , 79817 , 79823 , 79829 , 79841 , 79843 , 79847 , 79861 , 79867 , 79873 , 79889 , 79901 , 79903 , 79907 , 79939 , 79943 , 79967 , 79973 , 79979 , 79987 , 79997 , 79999 , 80021 , 80039 , 80051 , 80071 , 80077 , 80107 , 80111 , 80141 , 80147 , 80149 , 80153 , 80167 , 80173 , 80177 , 80191 , 80207 , 80209 , 80221 , 80231 , 80233 , 80239 , 80251 , 80263 , 80273 , 80279 , 80287 , 80309 , 80317 , 80329 , 80341 , 80347 , 80363 , 80369 , 80387 , 80407 , 80429 , 80447 , 80449 , 80471 , 80473 , 80489 , 80491 , 80513 , 80527 , 80537 , 80557 , 80567 , 80599 , 80603 , 80611 , 80621 , 80627 , 80629 , 80651 , 80657 , 80669 , 80671 , 80677 , 80681 , 80683 , 80687 , 80701 , 80713 , 80737 , 80747 , 80749 , 80761 , 80777 , 80779 , 80783 , 80789 , 80803 , 80809 , 80819 , 80831 , 80833 , 80849 , 80863 , 80897 , 80909 , 80911 , 80917 , 80923 , 80929 , 80933 , 80953 , 80963 , 80989 , 81001 , 81013 , 81017 , 81019 , 81023 , 81031 , 81041 , 81043 , 81047 , 81049 , 81071 , 81077 , 81083 , 81097 , 81101 , 81119 , 81131 , 81157 , 81163 , 81173 , 81181 , 81197 , 81199 , 81203 , 81223 , 81233 , 81239 , 81281 , 81283 , 81293 , 81299 , 81307 , 81331 , 81343 , 81349 , 81353 , 81359 , 81371 , 81373 , 81401 , 81409 , 81421 , 81439 , 81457 , 81463 , 81509 , 81517 , 81527 , 81533 , 81547 , 81551 , 81553 , 81559 , 81563 , 81569 , 81611 , 81619 , 81629 , 81637 , 81647 , 81649 , 81667 , 81671 , 81677 , 81689 , 81701 , 81703 , 81707 , 81727 , 81737 , 81749 , 81761 , 81769 , 81773 , 81799 , 81817 , 81839 , 81847 , 81853 , 81869 , 81883 , 81899 , 81901 , 81919 , 81929 , 81931 , 81937 , 81943 , 81953 , 81967 , 81971 , 81973 , 82003 , 82007 , 82009 , 82013 , 82021 , 82031 , 82037 , 82039 , 82051 , 82067 , 82073 , 82129 , 82139 , 82141 , 82153 , 82163 , 82171 , 82183 , 82189 , 82193 , 82207 , 82217 , 82219 , 82223 , 82231 , 82237 , 82241 , 82261 , 82267 , 82279 , 82301 , 82307 , 82339 , 82349 , 82351 , 82361 , 82373 , 82387 , 82393 , 82421 , 82457 , 82463 , 82469 , 82471 , 82483 , 82487 , 82493 , 82499 , 82507 , 82529 , 82531 , 82549 , 82559 , 82561 , 82567 , 82571 , 82591 , 82601 , 82609 , 82613 , 82619 , 82633 , 82651 , 82657 , 82699 , 82721 , 82723 , 82727 , 82729 , 82757 , 82759 , 82763 , 82781 , 82787 , 82793 , 82799 , 82811 , 82813 , 82837 , 82847 , 82883 , 82889 , 82891 , 82903 , 82913 , 82939 , 82963 , 82981 , 82997 , 83003 , 83009 , 83023 , 83047 , 83059 , 83063 , 83071 , 83077 , 83089 , 83093 , 83101 , 83117 , 83137 , 83177 , 83203 , 83207 , 83219 , 83221 , 83227 , 83231 , 83233 , 83243 , 83257 , 83267 , 83269 , 83273 , 83299 , 83311 , 83339 , 83341 , 83357 , 83383 , 83389 , 83399 , 83401 , 83407 , 83417 , 83423 , 83431 , 83437 , 83443 , 83449 , 83459 , 83471 , 83477 , 83497 , 83537 , 83557 , 83561 , 83563 , 83579 , 83591 , 83597 , 83609 , 83617 , 83621 , 83639 , 83641 , 83653 , 83663 , 83689 , 83701 , 83717 , 83719 , 83737 , 83761 , 83773 , 83777 , 83791 , 83813 , 83833 , 83843 , 83857 , 83869 , 83873 , 83891 , 83903 , 83911 , 83921 , 83933 , 83939 , 83969 , 83983 , 83987 , 84011 , 84017 , 84047 , 84053 , 84059 , 84061 , 84067 , 84089 , 84121 , 84127 , 84131 , 84137 , 84143 , 84163 , 84179 , 84181 , 84191 , 84199 , 84211 , 84221 , 84223 , 84229 , 84239 , 84247 , 84263 , 84299 , 84307 , 84313 , 84317 , 84319 , 84347 , 84349 , 84377 , 84389 , 84391 , 84401 , 84407 , 84421 , 84431 , 84437 , 84443 , 84449 , 84457 , 84463 , 84467 , 84481 , 84499 , 84503 , 84509 , 84521 , 84523 , 84533 , 84551 , 84559 , 84589 , 84629 , 84631 , 84649 , 84653 , 84659 , 84673 , 84691 , 84697 , 84701 , 84713 , 84719 , 84731 , 84737 , 84751 , 84761 , 84787 , 84793 , 84809 , 84811 , 84827 , 84857 , 84859 , 84869 , 84871 , 84913 , 84919 , 84947 , 84961 , 84967 , 84977 , 84979 , 84991 , 85009 , 85021 , 85027 , 85037 , 85049 , 85061 , 85081 , 85087 , 85091 , 85093 , 85103 , 85109 , 85121 , 85133 , 85147 , 85159 , 85193 , 85199 , 85201 , 85213 , 85223 , 85229 , 85237 , 85243 , 85247 , 85259 , 85297 , 85303 , 85313 , 85331 , 85333 , 85361 , 85363 , 85369 , 85381 , 85411 , 85427 , 85429 , 85439 , 85447 , 85451 , 85453 , 85469 , 85487 , 85513 , 85517 , 85523 , 85531 , 85549 , 85571 , 85577 , 85597 , 85601 , 85607 , 85619 , 85621 , 85627 , 85639 , 85643 , 85661 , 85667 , 85669 , 85691 , 85703 , 85711 , 85717 , 85733 , 85751 , 85781 , 85793 , 85817 , 85819 , 85829 , 85831 , 85837 , 85843 , 85847 , 85853 , 85889 , 85903 , 85909 , 85931 , 85933 , 85991 , 85999 , 86011 , 86017 , 86027 , 86029 , 86069 , 86077 , 86083 , 86111 , 86113 , 86117 , 86131 , 86137 , 86143 , 86161 , 86171 , 86179 , 86183 , 86197 , 86201 , 86209 , 86239 , 86243 , 86249 , 86257 , 86263 , 86269 , 86287 , 86291 , 86293 , 86297 , 86311 , 86323 , 86341 , 86351 , 86353 , 86357 , 86369 , 86371 , 86381 , 86389 , 86399 , 86413 , 86423 , 86441 , 86453 , 86461 , 86467 , 86477 , 86491 , 86501 , 86509 , 86531 , 86533 , 86539 , 86561 , 86573 , 86579 , 86587 , 86599 , 86627 , 86629 , 86677 , 86689 , 86693 , 86711 , 86719 , 86729 , 86743 , 86753 , 86767 , 86771 , 86783 , 86813 , 86837 , 86843 , 86851 , 86857 , 86861 , 86869 , 86923 , 86927 , 86929 , 86939 , 86951 , 86959 , 86969 , 86981 , 86993 , 87011 , 87013 , 87037 , 87041 , 87049 , 87071 , 87083 , 87103 , 87107 , 87119 , 87121 , 87133 , 87149 , 87151 , 87179 , 87181 , 87187 , 87211 , 87221 , 87223 , 87251 , 87253 , 87257 , 87277 , 87281 , 87293 , 87299 , 87313 , 87317 , 87323 , 87337 , 87359 , 87383 , 87403 , 87407 , 87421 , 87427 , 87433 , 87443 , 87473 , 87481 , 87491 , 87509 , 87511 , 87517 , 87523 , 87539 , 87541 , 87547 , 87553 , 87557 , 87559 , 87583 , 87587 , 87589 , 87613 , 87623 , 87629 , 87631 , 87641 , 87643 , 87649 , 87671 , 87679 , 87683 , 87691 , 87697 , 87701 , 87719 , 87721 , 87739 , 87743 , 87751 , 87767 , 87793 , 87797 , 87803 , 87811 , 87833 , 87853 , 87869 , 87877 , 87881 , 87887 , 87911 , 87917 , 87931 , 87943 , 87959 , 87961 , 87973 , 87977 , 87991 , 88001 , 88003 , 88007 , 88019 , 88037 , 88069 , 88079 , 88093 , 88117 , 88129 , 88169 , 88177 , 88211 , 88223 , 88237 , 88241 , 88259 , 88261 , 88289 , 88301 , 88321 , 88327 , 88337 , 88339 , 88379 , 88397 , 88411 , 88423 , 88427 , 88463 , 88469 , 88471 , 88493 , 88499 , 88513 , 88523 , 88547 , 88589 , 88591 , 88607 , 88609 , 88643 , 88651 , 88657 , 88661 , 88663 , 88667 , 88681 , 88721 , 88729 , 88741 , 88747 , 88771 , 88789 , 88793 , 88799 , 88801 , 88807 , 88811 , 88813 , 88817 , 88819 , 88843 , 88853 , 88861 , 88867 , 88873 , 88883 , 88897 , 88903 , 88919 , 88937 , 88951 , 88969 , 88993 , 88997 , 89003 , 89009 , 89017 , 89021 , 89041 , 89051 , 89057 , 89069 , 89071 , 89083 , 89087 , 89101 , 89107 , 89113 , 89119 , 89123 , 89137 , 89153 , 89189 , 89203 , 89209 , 89213 , 89227 , 89231 , 89237 , 89261 , 89269 , 89273 , 89293 , 89303 , 89317 , 89329 , 89363 , 89371 , 89381 , 89387 , 89393 , 89399 , 89413 , 89417 , 89431 , 89443 , 89449 , 89459 , 89477 , 89491 , 89501 , 89513 , 89519 , 89521 , 89527 , 89533 , 89561 , 89563 , 89567 , 89591 , 89597 , 89599 , 89603 , 89611 , 89627 , 89633 , 89653 , 89657 , 89659 , 89669 , 89671 , 89681 , 89689 , 89753 , 89759 , 89767 , 89779 , 89783 , 89797 , 89809 , 89819 , 89821 , 89833 , 89839 , 89849 , 89867 , 89891 , 89897 , 89899 , 89909 , 89917 , 89923 , 89939 , 89959 , 89963 , 89977 , 89983 , 89989 , 90001 , 90007 , 90011 , 90017 , 90019 , 90023 , 90031 , 90053 , 90059 , 90067 , 90071 , 90073 , 90089 , 90107 , 90121 , 90127 , 90149 , 90163 , 90173 , 90187 , 90191 , 90197 , 90199 , 90203 , 90217 , 90227 , 90239 , 90247 , 90263 , 90271 , 90281 , 90289 , 90313 , 90353 , 90359 , 90371 , 90373 , 90379 , 90397 , 90401 , 90403 , 90407 , 90437 , 90439 , 90469 , 90473 , 90481 , 90499 , 90511 , 90523 , 90527 , 90529 , 90533 , 90547 , 90583 , 90599 , 90617 , 90619 , 90631 , 90641 , 90647 , 90659 , 90677 , 90679 , 90697 , 90703 , 90709 , 90731 , 90749 , 90787 , 90793 , 90803 , 90821 , 90823 , 90833 , 90841 , 90847 , 90863 , 90887 , 90901 , 90907 , 90911 , 90917 , 90931 , 90947 , 90971 , 90977 , 90989 , 90997 , 91009 , 91019 , 91033 , 91079 , 91081 , 91097 , 91099 , 91121 , 91127 , 91129 , 91139 , 91141 , 91151 , 91153 , 91159 , 91163 , 91183 , 91193 , 91199 , 91229 , 91237 , 91243 , 91249 , 91253 , 91283 , 91291 , 91297 , 91303 , 91309 , 91331 , 91367 , 91369 , 91373 , 91381 , 91387 , 91393 , 91397 , 91411 , 91423 , 91433 , 91453 , 91457 , 91459 , 91463 , 91493 , 91499 , 91513 , 91529 , 91541 , 91571 , 91573 , 91577 , 91583 , 91591 , 91621 , 91631 , 91639 , 91673 , 91691 , 91703 , 91711 , 91733 , 91753 , 91757 , 91771 , 91781 , 91801 , 91807 , 91811 , 91813 , 91823 , 91837 , 91841 , 91867 , 91873 , 91909 , 91921 , 91939 , 91943 , 91951 , 91957 , 91961 , 91967 , 91969 , 91997 , 92003 , 92009 , 92033 , 92041 , 92051 , 92077 , 92083 , 92107 , 92111 , 92119 , 92143 , 92153 , 92173 , 92177 , 92179 , 92189 , 92203 , 92219 , 92221 , 92227 , 92233 , 92237 , 92243 , 92251 , 92269 , 92297 , 92311 , 92317 , 92333 , 92347 , 92353 , 92357 , 92363 , 92369 , 92377 , 92381 , 92383 , 92387 , 92399 , 92401 , 92413 , 92419 , 92431 , 92459 , 92461 , 92467 , 92479 , 92489 , 92503 , 92507 , 92551 , 92557 , 92567 , 92569 , 92581 , 92593 , 92623 , 92627 , 92639 , 92641 , 92647 , 92657 , 92669 , 92671 , 92681 , 92683 , 92693 , 92699 , 92707 , 92717 , 92723 , 92737 , 92753 , 92761 , 92767 , 92779 , 92789 , 92791 , 92801 , 92809 , 92821 , 92831 , 92849 , 92857 , 92861 , 92863 , 92867 , 92893 , 92899 , 92921 , 92927 , 92941 , 92951 , 92957 , 92959 , 92987 , 92993 , 93001 , 93047 , 93053 , 93059 , 93077 , 93083 , 93089 , 93097 , 93103 , 93113 , 93131 , 93133 , 93139 , 93151 , 93169 , 93179 , 93187 , 93199 , 93229 , 93239 , 93241 , 93251 , 93253 , 93257 , 93263 , 93281 , 93283 , 93287 , 93307 , 93319 , 93323 , 93329 , 93337 , 93371 , 93377 , 93383 , 93407 , 93419 , 93427 , 93463 , 93479 , 93481 , 93487 , 93491 , 93493 , 93497 , 93503 , 93523 , 93529 , 93553 , 93557 , 93559 , 93563 , 93581 , 93601 , 93607 , 93629 , 93637 , 93683 , 93701 , 93703 , 93719 , 93739 , 93761 , 93763 , 93787 , 93809 , 93811 , 93827 , 93851 , 93871 , 93887 , 93889 , 93893 , 93901 , 93911 , 93913 , 93923 , 93937 , 93941 , 93949 , 93967 , 93971 , 93979 , 93983 , 93997 , 94007 , 94009 , 94033 , 94049 , 94057 , 94063 , 94079 , 94099 , 94109 , 94111 , 94117 , 94121 , 94151 , 94153 , 94169 , 94201 , 94207 , 94219 , 94229 , 94253 , 94261 , 94273 , 94291 , 94307 , 94309 , 94321 , 94327 , 94331 , 94343 , 94349 , 94351 , 94379 , 94397 , 94399 , 94421 , 94427 , 94433 , 94439 , 94441 , 94447 , 94463 , 94477 , 94483 , 94513 , 94529 , 94531 , 94541 , 94543 , 94547 , 94559 , 94561 , 94573 , 94583 , 94597 , 94603 , 94613 , 94621 , 94649 , 94651 , 94687 , 94693 , 94709 , 94723 , 94727 , 94747 , 94771 , 94777 , 94781 , 94789 , 94793 , 94811 , 94819 , 94823 , 94837 , 94841 , 94847 , 94849 , 94873 , 94889 , 94903 , 94907 , 94933 , 94949 , 94951 , 94961 , 94993 , 94999 , 95003 , 95009 , 95021 , 95027 , 95063 , 95071 , 95083 , 95087 , 95089 , 95093 , 95101 , 95107 , 95111 , 95131 , 95143 , 95153 , 95177 , 95189 , 95191 , 95203 , 95213 , 95219 , 95231 , 95233 , 95239 , 95257 , 95261 , 95267 , 95273 , 95279 , 95287 , 95311 , 95317 , 95327 , 95339 , 95369 , 95383 , 95393 , 95401 , 95413 , 95419 , 95429 , 95441 , 95443 , 95461 , 95467 , 95471 , 95479 , 95483 , 95507 , 95527 , 95531 , 95539 , 95549 , 95561 , 95569 , 95581 , 95597 , 95603 , 95617 , 95621 , 95629 , 95633 , 95651 , 95701 , 95707 , 95713 , 95717 , 95723 , 95731 , 95737 , 95747 , 95773 , 95783 , 95789 , 95791 , 95801 , 95803 , 95813 , 95819 , 95857 , 95869 , 95873 , 95881 , 95891 , 95911 , 95917 , 95923 , 95929 , 95947 , 95957 , 95959 , 95971 , 95987 , 95989 , 96001 , 96013 , 96017 , 96043 , 96053 , 96059 , 96079 , 96097 , 96137 , 96149 , 96157 , 96167 , 96179 , 96181 , 96199 , 96211 , 96221 , 96223 , 96233 , 96259 , 96263 , 96269 , 96281 , 96289 , 96293 , 96323 , 96329 , 96331 , 96337 , 96353 , 96377 , 96401 , 96419 , 96431 , 96443 , 96451 , 96457 , 96461 , 96469 , 96479 , 96487 , 96493 , 96497 , 96517 , 96527 , 96553 , 96557 , 96581 , 96587 , 96589 , 96601 , 96643 , 96661 , 96667 , 96671 , 96697 , 96703 , 96731 , 96737 , 96739 , 96749 , 96757 , 96763 , 96769 , 96779 , 96787 , 96797 , 96799 , 96821 , 96823 , 96827 , 96847 , 96851 , 96857 , 96893 , 96907 , 96911 , 96931 , 96953 , 96959 , 96973 , 96979 , 96989 , 96997 , 97001 , 97003 , 97007 , 97021 , 97039 , 97073 , 97081 , 97103 , 97117 , 97127 , 97151 , 97157 , 97159 , 97169 , 97171 , 97177 , 97187 , 97213 , 97231 , 97241 , 97259 , 97283 , 97301 , 97303 , 97327 , 97367 , 97369 , 97373 , 97379 , 97381 , 97387 , 97397 , 97423 , 97429 , 97441 , 97453 , 97459 , 97463 , 97499 , 97501 , 97511 , 97523 , 97547 , 97549 , 97553 , 97561 , 97571 , 97577 , 97579 , 97583 , 97607 , 97609 , 97613 , 97649 , 97651 , 97673 , 97687 , 97711 , 97729 , 97771 , 97777 , 97787 , 97789 , 97813 , 97829 , 97841 , 97843 , 97847 , 97849 , 97859 , 97861 , 97871 , 97879 , 97883 , 97919 , 97927 , 97931 , 97943 , 97961 , 97967 , 97973 , 97987 , 98009 , 98011 , 98017 , 98041 , 98047 , 98057 , 98081 , 98101 , 98123 , 98129 , 98143 , 98179 , 98207 , 98213 , 98221 , 98227 , 98251 , 98257 , 98269 , 98297 , 98299 , 98317 , 98321 , 98323 , 98327 , 98347 , 98369 , 98377 , 98387 , 98389 , 98407 , 98411 , 98419 , 98429 , 98443 , 98453 , 98459 , 98467 , 98473 , 98479 , 98491 , 98507 , 98519 , 98533 , 98543 , 98561 , 98563 , 98573 , 98597 , 98621 , 98627 , 98639 , 98641 , 98663 , 98669 , 98689 , 98711 , 98713 , 98717 , 98729 , 98731 , 98737 , 98773 , 98779 , 98801 , 98807 , 98809 , 98837 , 98849 , 98867 , 98869 , 98873 , 98887 , 98893 , 98897 , 98899 , 98909 , 98911 , 98927 , 98929 , 98939 , 98947 , 98953 , 98963 , 98981 , 98993 , 98999 , 99013 , 99017 , 99023 , 99041 , 99053 , 99079 , 99083 , 99089 , 99103 , 99109 , 99119 , 99131 , 99133 , 99137 , 99139 , 99149 , 99173 , 99181 , 99191 , 99223 , 99233 , 99241 , 99251 , 99257 , 99259 , 99277 , 99289 , 99317 , 99347 , 99349 , 99367 , 99371 , 99377 , 99391 , 99397 , 99401 , 99409 , 99431 , 99439 , 99469 , 99487 , 99497 , 99523 , 99527 , 99529 , 99551 , 99559 , 99563 , 99571 , 99577 , 99581 , 99607 , 99611 , 99623 , 99643 , 99661 , 99667 , 99679 , 99689 , 99707 , 99709 , 99713 , 99719 , 99721 , 99733 , 99761 , 99767 , 99787 , 99793 , 99809 , 99817 , 99823 , 99829 , 99833 , 99839 , 99859 , 99871 , 99877 , 99881 , 99901 , 99907 , 99923 , 99929 , 99961 , 99971 , 99989 , 99991 , 100003 , 100019 , 100043 , 100049 , 100057 , 100069 ] <NEWLINE> if plist . count ( X ) == 1 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plist . append ( X ) <NEWLINE> ans = sorted ( plist ) <NEWLINE> a = ans . index ( X ) <NEWLINE> <DEDENT> print ( ans [ a + 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> p = 1000000007 <NEWLINE> <NL> k = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = lcm ( k , a [ i ] ) <NEWLINE> <NL> <DEDENT> k %= p <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += k * pow ( a [ i ] , p - 2 , p ) <NEWLINE> ans %= p <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> H = sorted ( H ) <NEWLINE> ans = 10 ** 9 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , H [ i + K - 1 ] - H [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
l = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 21 ) : <NEWLINE> <INDENT> if 2 ** i > l : <NEWLINE> <INDENT> r = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> ans . append ( ( i + 1 , i + 2 , 0 ) ) <NEWLINE> ans . append ( ( i + 1 , i + 2 , 2 ** i ) ) <NEWLINE> <DEDENT> now = 2 ** r - 1 <NEWLINE> for i in range ( r , 0 , - 1 ) : <NEWLINE> <INDENT> if 2 ** ( i - 1 ) + now <= l - 1 : <NEWLINE> <INDENT> ans . append ( ( i , r + 1 , now + 1 ) ) <NEWLINE> now += 2 ** ( i - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( r + 1 , len ( ans ) ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> G = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> G [ i + 1 ] = [ ] <NEWLINE> <DEDENT> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] += [ [ b , c ] ] <NEWLINE> G [ b ] += [ [ a , c ] ] <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = [ - 1 ] * n <NEWLINE> dist [ k - 1 ] = 0 <NEWLINE> que = [ k ] <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> s = que . pop ( 0 ) <NEWLINE> for [ nv , c ] in G [ s ] : <NEWLINE> <INDENT> if dist [ nv - 1 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv - 1 ] = dist [ s - 1 ] + c <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> l = [ ] <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT> if c [ i ] >= 2 : <NEWLINE> <INDENT> for j in range ( c [ i ] // 2 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( l ) >= 2 : <NEWLINE> <INDENT> print ( heapq . nlargest ( 2 , l ) [ 0 ] * heapq . nlargest ( 2 , l ) [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> S = sorted ( S ) <NEWLINE> <NL> ans = sum ( S ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans = ans - S [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> s . append ( s1 ) <NEWLINE> <DEDENT> s = Counter ( s ) . most_common ( ) <NEWLINE> num = 0 <NEWLINE> for i , h in s : <NEWLINE> <INDENT> num += ( h * ( h - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : a += 1 <NEWLINE> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> ans = max ( ans , a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , point , answer = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> W = [ point ] * N <NEWLINE> for i in range ( answer ) : <NEWLINE> <INDENT> U = int ( input ( ) ) <NEWLINE> W [ U - 1 ] += 1 <NEWLINE> <DEDENT> W = [ n - answer for n in W ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if W [ k ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> import copy <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 9 * 15 <NEWLINE> for i in range ( 2 ** ( N - 1 ) ) : <COMMENT> <NEWLINE> <INDENT> B = copy . copy ( A ) <NEWLINE> count = 0 <NEWLINE> bit = 0 <NEWLINE> for j in range ( N - 1 ) : <COMMENT> <NEWLINE> <INDENT> bit = bit + ( 1 & ( i >> j ) ) <NEWLINE> <DEDENT> if ( bit == K - 1 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( N - 1 ) : <NEWLINE> <INDENT> if ( i >> k & 1 ) : <NEWLINE> <INDENT> if max ( B [ 0 : k + 1 ] ) >= B [ k + 1 ] : <COMMENT> <NEWLINE> <INDENT> dif = max ( B [ 0 : k + 1 ] ) - B [ k + 1 ] + 1 <NEWLINE> B [ k + 1 ] += dif <COMMENT> <NEWLINE> count += dif <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P = <STRING> <NEWLINE> IP = <STRING> <NEWLINE> <NL> M = max ( A ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = gcd ( A [ 0 ] , A [ 0 ] ) <NEWLINE> if N > 1 : <NEWLINE> <INDENT> for a in A [ 1 : ] : <NEWLINE> <INDENT> t = gcd ( t , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if K % t == 0 and K <= M : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( IP ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> def divlist ( n ) : <NEWLINE> <INDENT> sl = [ ] <NEWLINE> ll = [ ] <NEWLINE> for x in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % x == 0 : <NEWLINE> <INDENT> sl . append ( x ) <NEWLINE> ll . append ( n // x ) <NEWLINE> <DEDENT> <DEDENT> ll . reverse ( ) <NEWLINE> sl . extend ( ll ) <NEWLINE> return sl <NEWLINE> <NL> <DEDENT> def f ( b , n ) : <NEWLINE> <INDENT> if n < b : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( b , n // b ) + ( n % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( n , s ) : <NEWLINE> <INDENT> if n < s : <NEWLINE> <INDENT> return print ( - 1 ) <NEWLINE> <DEDENT> elif n == s : <NEWLINE> <INDENT> return print ( n + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dl = divlist ( n - s ) <NEWLINE> for x in dl : <NEWLINE> <INDENT> if s == f ( x + 1 , n ) : <NEWLINE> <INDENT> return print ( x + 1 ) <NEWLINE> <DEDENT> <DEDENT> return print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> s = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> main ( n , s ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict as dd <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> def dfs ( node ) : <NEWLINE> <INDENT> visited [ node - 1 ] = True <NEWLINE> <NL> for next_node in tree [ node ] : <NEWLINE> <INDENT> if visited [ next_node - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ next_node - 1 ] += counter [ node - 1 ] <NEWLINE> dfs ( next_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = dd ( list ) <NEWLINE> visited = [ False ] * N <NEWLINE> counter = [ 0 ] * N <NEWLINE> operation = [ ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> operation . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for p , x in operation : <NEWLINE> <INDENT> counter [ p - 1 ] += x <NEWLINE> <DEDENT> dfs ( 1 ) <NEWLINE> print ( * counter ) <NEWLINE>
from heapq import heappop , heapify , heappush <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> work = [ [ ] for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> work [ a ] . append ( b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> q = [ ] <NEWLINE> heapify ( q ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for w in work [ i ] : <NEWLINE> <INDENT> heappush ( q , - w ) <NEWLINE> <DEDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += heappop ( q ) <NEWLINE> <DEDENT> ans *= - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> minp = n + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> minp = min ( minp , P [ i ] ) <NEWLINE> if minp == P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dp = [ INF for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( i , k ) + 1 ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from math import factorial <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> print ( factorial ( N ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = 1000000007 <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> a . append ( N + 1 ) <NEWLINE> <NL> def fibonacci ( x ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> if x <= 2 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( x - 2 ) : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp + b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> <DEDENT> res = 1 <NEWLINE> prev_a = - 1 <NEWLINE> for cur_a in a : <NEWLINE> <INDENT> if cur_a - prev_a == 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> break <NEWLINE> <DEDENT> res *= fibonacci ( cur_a - prev_a - 1 ) % mod <NEWLINE> res %= mod <NEWLINE> prev_a = cur_a <NEWLINE> continue <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> t [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k -= 1 <NEWLINE> l = [ 0 ] * n <NEWLINE> def dfs ( a , b , c ) : <NEWLINE> <INDENT> for i , j in t [ b ] : <NEWLINE> <INDENT> if i != a : <NEWLINE> <INDENT> l [ i ] = c + j <NEWLINE> dfs ( b , i , c + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( - 1 , k , 0 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( l [ x ] + l [ y ] ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> <NL> N , K , * XY = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> X = sorted ( XY [ : : 2 ] ) <NEWLINE> Y = sorted ( XY [ 1 : : 2 ] ) <NEWLINE> <NL> ans = 10 ** 20 <NEWLINE> for x1 , x2 in combinations ( X , 2 ) : <NEWLINE> <INDENT> for y1 in Y [ : - 1 ] : <NEWLINE> <INDENT> y2s = sorted ( y for x , y in zip ( * [ iter ( XY ) ] * 2 ) if x1 <= x <= x2 and y1 <= y ) <NEWLINE> if len ( y2s ) < K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( ans , ( x2 - x1 ) * ( y2s [ K - 1 ] - y1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( i - ans [ i ] + ans [ n ] - ans [ i + 1 ] for i in range ( n ) ) ) <NEWLINE>
NN = input ( ) <NEWLINE> total = 0 <NEWLINE> for i in NN : <NEWLINE> <INDENT> a = NN . count ( i ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> if total == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> cnt [ b ] += 1 <NEWLINE> <DEDENT> ans = all ( cnt [ i ] % 2 == 0 for i in cnt ) <NEWLINE> print ( <STRING> if ans else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a <= 0 and b >= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> aa = Counter ( LIST ( ) ) <NEWLINE> aa = sorted ( aa . items ( ) , key = itemgetter ( 0 ) ) <NEWLINE> a = [ [ aa [ i ] [ 1 ] , aa [ i ] [ 0 ] ] for i in range ( len ( aa ) ) ] <NEWLINE> b = sorted ( [ LIST ( ) for i in range ( m ) ] , key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = j = 0 <NEWLINE> while i < len ( b ) and j < len ( a ) and b [ i ] [ 1 ] > a [ j ] [ 1 ] : <NEWLINE> <INDENT> if b [ i ] [ 0 ] >= a [ j ] [ 0 ] : <NEWLINE> <INDENT> ans += b [ i ] [ 1 ] * a [ j ] [ 0 ] <NEWLINE> b [ i ] [ 0 ] -= a [ j ] [ 0 ] <NEWLINE> a [ j ] [ 0 ] = 0 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] [ 1 ] * b [ i ] [ 0 ] <NEWLINE> a [ j ] [ 0 ] -= b [ i ] [ 0 ] <NEWLINE> b [ i ] [ 0 ] = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> reg = j <NEWLINE> if reg < len ( a ) : <NEWLINE> <INDENT> for i in range ( j , len ( a ) ) : <NEWLINE> <INDENT> ans += a [ i ] [ 0 ] * a [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a1 = [ ] <NEWLINE> bn = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> a1 . append ( b ) <NEWLINE> <DEDENT> elif b == n : <NEWLINE> <INDENT> bn . append ( a ) <NEWLINE> <DEDENT> <DEDENT> la = len ( a1 ) <NEWLINE> lb = len ( bn ) <NEWLINE> sa = set ( a1 ) <NEWLINE> sb = set ( bn ) <NEWLINE> if len ( sa | sb ) < la + lb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import decimal <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m , d = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( ( m - 1 ) / n ) <NEWLINE> return True <NEWLINE> <DEDENT> print ( ( ( n - d ) * 2 * ( m - 1 ) / pow ( n , 2 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
times = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> <NL> rem = float ( <STRING> ) <NEWLINE> last = 0 <NEWLINE> for time in times : <NEWLINE> <INDENT> if time % 10 < rem and time % 10 != 0 : <NEWLINE> <INDENT> rem = time % 10 <NEWLINE> last = time <NEWLINE> <DEDENT> <DEDENT> if last : <NEWLINE> <INDENT> times . remove ( last ) <NEWLINE> <NL> <DEDENT> total_time = 0 <NEWLINE> for time in times : <NEWLINE> <INDENT> if time % 10 == 0 : <NEWLINE> <INDENT> total_time += time <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_time += time + ( 10 - time % 10 ) <NEWLINE> <DEDENT> <DEDENT> total_time += last <NEWLINE> <NL> print ( total_time ) <NEWLINE>
h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> flag = True <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> sub_flag = False <NEWLINE> if i > 0 and s [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <DEDENT> if j > 0 and s [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <DEDENT> if i < h - 1 and s [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <DEDENT> if j < w - 1 and s [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> sub_flag = True <NEWLINE> <NL> <DEDENT> if sub_flag : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . sort ( ) <NEWLINE> out = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 + i , n ) : <NEWLINE> <INDENT> out += bisect . bisect_left ( lis , lis [ i ] + lis [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = [ int ( 0 ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a ] += 1 <NEWLINE> ans [ b ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s_count = [ 0 ] * 26 <NEWLINE> t_count = [ 0 ] * 26 <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> s_count [ i - 97 ] = s . count ( chr ( i ) ) <NEWLINE> t_count [ i - 97 ] = t . count ( chr ( i ) ) <NEWLINE> <DEDENT> s_count . sort ( ) <NEWLINE> t_count . sort ( ) <NEWLINE> if s_count == t_count : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = mi ( ) <NEWLINE> a , b = i2 ( N - 1 ) <NEWLINE> p , x = i2 ( Q ) <NEWLINE> <NL> d = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> d [ a [ i ] - 1 ] . append ( b [ i ] - 1 ) <NEWLINE> d [ b [ i ] - 1 ] . append ( a [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> child = [ [ ] for i in range ( N ) ] <NEWLINE> parent = [ None ] * N <NEWLINE> <NL> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . pop ( ) <NEWLINE> for v in d [ now ] : <NEWLINE> <INDENT> if parent [ now ] == v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ v ] = now <NEWLINE> q . appendleft ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> c [ p [ i ] - 1 ] += x [ i ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if parent [ i ] == None : <NEWLINE> <INDENT> return c [ i ] <NEWLINE> <NL> <DEDENT> return c [ i ] + dfs ( parent [ i ] ) <NEWLINE> <NL> <DEDENT> print ( * [ dfs ( i ) for i in range ( N ) ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> next = a . pop ( 0 ) <NEWLINE> while True : <NEWLINE> <INDENT> if next == <STRING> : <NEWLINE> <INDENT> if a == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = a . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif next == <STRING> : <NEWLINE> <INDENT> if b == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = b . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next = c . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left , bisect , bisect_right <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> <DEDENT> elif icase == 1 : <NEWLINE> <INDENT> n , m = 3 , 2 <NEWLINE> a = [ 1 , 4 , 5 ] <NEWLINE> cb = [ [ 5 , 1 ] , [ 3 , 2 ] ] <NEWLINE> <DEDENT> elif icase == 3 : <NEWLINE> <INDENT> n , m = 3 , 2 <NEWLINE> a = [ 100 , 100 , 100 ] <NEWLINE> cb = [ [ 99 , 3 ] , [ 99 , 3 ] ] <NEWLINE> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 10 , 3 <NEWLINE> a = [ 1 , 4 , 5 , 5 , 7 , 8 , 13 , 33 , 52 , 100 ] <NEWLINE> cb = [ [ 30 , 4 ] , [ 10 , 3 ] , [ 4 , 1 ] ] <NEWLINE> <DEDENT> elif icase == 4 : <NEWLINE> <INDENT> n , m = 11 , 3 <NEWLINE> a = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] <NEWLINE> cb = [ [ 1000000000 , 4 ] , [ 1000000000 , 3 ] , [ 1000000000 , 3 ] ] <NEWLINE> <DEDENT> elif icase == 5 : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> ll = f . readline ( ) <NEWLINE> n , m = map ( int , ll . split ( ) ) <NEWLINE> ll = f . readline ( ) <NEWLINE> a = list ( map ( int , ll . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ll = f . readline ( ) <NEWLINE> bi , ci = map ( int , ll . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> ans = 99913215738299 <NEWLINE> <DEDENT> elif icase == 6 : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> ll = f . readline ( ) <NEWLINE> n , m = map ( int , ll . split ( ) ) <NEWLINE> ll = f . readline ( ) <NEWLINE> a = list ( map ( int , ll . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ll = f . readline ( ) <NEWLINE> bi , ci = map ( int , ll . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> ans = 95821339675952 <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> cb . sort ( reverse = True ) <NEWLINE> <NL> if cb [ 0 ] [ 0 ] <= a [ 0 ] : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> asum = 0 <NEWLINE> isum = 0 <NEWLINE> isumm = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isum += cb [ i ] [ 1 ] <NEWLINE> if isum > n : <NEWLINE> <INDENT> if a [ - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> asum += cb [ i ] [ 0 ] * ( n - isumm ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ isum - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * cb [ i ] [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> isumm = isum <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> isumm = isum <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> asum += sum ( a [ isumm : ] ) <NEWLINE> <NL> print ( asum ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> L = np . zeros ( ( H , W ) , int ) <NEWLINE> R = np . zeros ( ( H , W ) , int ) <NEWLINE> D = np . zeros ( ( H , W ) , int ) <NEWLINE> U = np . zeros ( ( H , W ) , int ) <NEWLINE> S = np . array ( [ list ( input ( ) ) for h in range ( H ) ] ) == <STRING> <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> U [ h ] = S [ h ] * ( U [ h - 1 ] + 1 ) <NEWLINE> D [ - h - 1 ] = S [ - h - 1 ] * ( D [ - h ] + 1 ) <NEWLINE> <NL> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> L [ : , w ] = S [ : , w ] * ( L [ : , w - 1 ] + 1 ) <NEWLINE> R [ : , - w - 1 ] = S [ : , - w - 1 ] * ( R [ : , - w ] + 1 ) <NEWLINE> <NL> <DEDENT> print ( np . max ( U + D + L + R ) - 3 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> class factorials : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = 1 <COMMENT> <NEWLINE> self . factorials = [ ] <NEWLINE> self . update_factorials ( n ) <NEWLINE> <NL> <DEDENT> def update_factorials ( self , n ) : <NEWLINE> <INDENT> if self . n >= n : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> for i in range ( self . n + 1 , n + 1 ) : <NEWLINE> <INDENT> done = False <NEWLINE> limit = int ( i ** 0.5 ) <NEWLINE> for j in self . factorials : <NEWLINE> <INDENT> if j > limit : break <NEWLINE> if not i % j : <NEWLINE> <INDENT> done = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not done : <NEWLINE> <INDENT> self . factorials . append ( i ) <NEWLINE> <DEDENT> <DEDENT> self . n = n <NEWLINE> return None <NEWLINE> <NL> <DEDENT> def factorials_list ( self ) : <NEWLINE> <INDENT> return self . factorials <NEWLINE> <NL> <DEDENT> def check_fact ( self , x ) : <NEWLINE> <INDENT> if x > self . n ** 2 : <NEWLINE> <INDENT> self . update_factorials ( int ( x ** 0.5 ) + 1 ) <NEWLINE> <DEDENT> MAX = int ( math . sqrt ( x ) ) <NEWLINE> for f in self . factorials : <NEWLINE> <INDENT> if f > MAX : break <NEWLINE> if not x % f : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def prime_factorization ( self , val , divisors = None ) : <NEWLINE> <COMMENT> <NL> <INDENT> max_n = int ( math . sqrt ( val ) ) <NEWLINE> if self . n < max_n : <NEWLINE> <INDENT> self . update_factorials ( max_n ) <NEWLINE> <DEDENT> if divisors == None : <NEWLINE> <INDENT> divisors = defaultdict ( lambda : 0 ) <NEWLINE> <DEDENT> for f in self . factorials : <NEWLINE> <INDENT> if f > val : break <NEWLINE> while True : <NEWLINE> <INDENT> if not val % f : <NEWLINE> <INDENT> divisors [ f ] += 1 <NEWLINE> val //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if val > 1 : <NEWLINE> <INDENT> divisors [ val ] += 1 <NEWLINE> <DEDENT> return divisors <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> facts = factorials ( int ( N ** 0.5 ) ) <NEWLINE> dic = facts . prime_factorization ( N ) <NEWLINE> <COMMENT> <NL> ret = 0 <NEWLINE> <NL> def dfs ( x , l , v ) : <NEWLINE> <INDENT> nonlocal ret <NEWLINE> <COMMENT> <NL> xx , ll = x [ 0 ] , l [ 0 ] <NEWLINE> if len ( x ) == 1 : <NEWLINE> <INDENT> for i in range ( ll + 1 ) : <NEWLINE> <INDENT> tmp = v * ( xx ** i ) <NEWLINE> <COMMENT> <NL> if tmp == 1 : continue <NEWLINE> if N % ( tmp - 1 ) == N // ( tmp - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ret += tmp - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ll + 1 ) : <NEWLINE> <INDENT> tmp = v * xx ** i <NEWLINE> dfs ( x [ 1 : ] , l [ 1 : ] , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( list ( dic . keys ( ) ) , list ( dic . values ( ) ) , 1 ) <NEWLINE> <NL> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = ( sum ( p [ 0 : K ] ) + K ) / 2 <NEWLINE> pre = ans <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> pre -= ( p [ i - 1 ] - p [ i + K - 1 ] ) / 2 <NEWLINE> ans = max ( pre , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for i in range ( len ( AL [ v ] [ CHILDREN ] ) ) : <NEWLINE> <INDENT> u = AL [ v ] [ CHILDREN ] [ i ] <NEWLINE> if visited [ u ] : <NEWLINE> <INDENT> AL [ v ] [ CHILDREN ] [ i ] = None <NEWLINE> continue <NEWLINE> <DEDENT> AL [ v ] [ SIZE ] += dfs ( u ) <NEWLINE> <DEDENT> return AL [ v ] [ SIZE ] <NEWLINE> <NL> <DEDENT> def anaaki ( v ) : <NEWLINE> <INDENT> ret = powp - 1 <NEWLINE> for ch in AL [ v ] [ CHILDREN ] : <NEWLINE> <INDENT> if ch is None : continue <NEWLINE> ret -= pow ( 2 , AL [ ch ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> <DEDENT> ret -= pow ( 2 , n - AL [ v ] [ SIZE ] , p ) - 1 <NEWLINE> ret %= p <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> SIZE = 0 <NEWLINE> CHILDREN = 1 <NEWLINE> AL = [ [ 1 , [ ] ] for _ in range ( n ) ] <NEWLINE> visited = [ False ] * n <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> powp = pow ( 2 , n - 1 , p ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> AL [ a ] [ CHILDREN ] . append ( b ) <NEWLINE> AL [ b ] [ CHILDREN ] . append ( a ) <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> numer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numer += anaaki ( i ) <NEWLINE> numer %= p <NEWLINE> <NL> <DEDENT> denom = powp * 2 % p <NEWLINE> print ( numer * pow ( denom , p - 2 , p ) % p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n - 1 , 0 , - 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 , - 1 , - 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( 3 * N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int1 , input ( ) . split ( ) ) <NEWLINE> G [ u * 3 ] . append ( v * 3 + 1 ) <NEWLINE> G [ u * 3 + 1 ] . append ( v * 3 + 2 ) <NEWLINE> G [ u * 3 + 2 ] . append ( v * 3 ) <NEWLINE> <NL> <DEDENT> S , T = map ( int1 , input ( ) . split ( ) ) <NEWLINE> S *= 3 <NEWLINE> T *= 3 <NEWLINE> <NL> <COMMENT> <NL> d = deque ( [ S ] ) <NEWLINE> distance = [ 0 ] * ( 3 * N ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> dist_v = distance [ v ] <NEWLINE> if v == T : <NEWLINE> <INDENT> print ( dist_v // 3 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for x in G [ v ] : <NEWLINE> <INDENT> if not distance [ x ] : <NEWLINE> <INDENT> d . append ( x ) <NEWLINE> distance [ x ] = dist_v + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xi = [ abs ( xval - x ) for xval in xi ] <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = xi [ 0 ] <NEWLINE> for i in range ( 1 , len ( xi ) ) : <NEWLINE> <INDENT> res = gcd ( res , xi [ i ] ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> use = [ ] <NEWLINE> for i in numbers : <NEWLINE> <INDENT> if not i in P : <NEWLINE> <INDENT> use . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ul = [ ] <NEWLINE> if 0 in use : <NEWLINE> <INDENT> for u5 in [ 0 , use [ 1 ] ] : <NEWLINE> <INDENT> for u4 in use : <NEWLINE> <INDENT> for u3 in use : <NEWLINE> <INDENT> for u2 in use : <NEWLINE> <INDENT> for u1 in use : <NEWLINE> <INDENT> ul . append ( u5 * 10000 + u4 * 1000 + u3 * 100 + u2 * 10 + u1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for u4 in use : <NEWLINE> <INDENT> for u3 in use : <NEWLINE> <INDENT> for u2 in use : <NEWLINE> <INDENT> for u1 in use : <NEWLINE> <INDENT> ul . append ( use [ 0 ] * 10000 + u4 * 1000 + u3 * 100 + u2 * 10 + u1 ) <NEWLINE> ul . append ( u4 * 1000 + u3 * 100 + u2 * 10 + u1 ) <NEWLINE> ul . append ( u3 * 100 + u2 * 10 + u1 ) <NEWLINE> ul . append ( u2 * 10 + u1 ) <NEWLINE> ul . append ( u1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ul . sort ( ) <NEWLINE> for r in ul : <NEWLINE> <INDENT> if N <= r : <NEWLINE> <INDENT> print ( r ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> if A in ans : <NEWLINE> <INDENT> ans [ A ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ A ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in ans : <NEWLINE> <INDENT> if ans [ i ] % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 0 for _ in range ( n ) ] <NEWLINE> already = set ( ) <NEWLINE> next = 1 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> l [ i ] = a <NEWLINE> <DEDENT> while c <= n : <NEWLINE> <INDENT> next = l [ next - 1 ] <NEWLINE> c += 1 <NEWLINE> if next == 2 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> elif next in already : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> already . add ( next ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> L = 0 <NEWLINE> R = 10 ** 5 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L = max ( l , L ) <NEWLINE> R = min ( r , R ) <NEWLINE> <NL> <DEDENT> if ( R - L + 1 ) >= 0 : <NEWLINE> <INDENT> print ( R - L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> d = sorted ( list ( S ) ) <NEWLINE> x = set ( d ) <NEWLINE> for c in d : <NEWLINE> <INDENT> left = S . index ( c ) <NEWLINE> while left < len ( S ) : <NEWLINE> <INDENT> if S [ left ] != c : <NEWLINE> <INDENT> left += 1 <NEWLINE> continue <NEWLINE> <DEDENT> j = 2 <NEWLINE> while j <= K : <NEWLINE> <INDENT> x . add ( S [ left : left + j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> left += 1 <NEWLINE> <DEDENT> if len ( x ) >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x = sorted ( list ( x ) ) <NEWLINE> print ( x [ K - 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> count1 = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> if S [ i ] == S [ i - 1 ] : <NEWLINE> <INDENT> count1 += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ss = S * 2 <NEWLINE> i = 1 <NEWLINE> count2 = 0 <NEWLINE> while i < len ( ss ) : <NEWLINE> <INDENT> if ss [ i ] == ss [ i - 1 ] : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if 2 * count1 + 1 == count2 and len ( set ( S ) ) != 1 : <NEWLINE> <INDENT> print ( K * count1 + ( K - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K * count2 // 2 ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> from collections import Counter <NEWLINE> <NL> N , * xyf = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> xy = [ ( xyf [ i * 2 ] , xyf [ i * 2 + 1 ] ) for i in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = [ ] <NEWLINE> for a , b in permutations ( xy , 2 ) : <NEWLINE> <INDENT> count . append ( ( b [ 0 ] - a [ 0 ] , b [ 1 ] - a [ 1 ] ) ) <NEWLINE> <DEDENT> c = Counter ( count ) <NEWLINE> print ( N - max ( c . values ( ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> if ( i + 1 < N ) and ( p [ i + 1 ] == i + 2 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> data = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> data . append ( abs ( a [ i ] - a [ i + 1 ] ) ) <NEWLINE> <DEDENT> s = sum ( data ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( s - data [ i ] - data [ i + 1 ] + abs ( a [ i ] - a [ i + 2 ] ) ) <NEWLINE> <DEDENT>
N , M , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> * A , = zip ( * [ iter ( A ) ] * 2 ) <NEWLINE> A . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> R = 0 <NEWLINE> for a , b in A : <NEWLINE> <INDENT> if R <= a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> R = b <NEWLINE> <DEDENT> elif b < R : <NEWLINE> <INDENT> R = b <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_counter = Counter ( a ) <NEWLINE> k = list ( a_counter . keys ( ) ) <NEWLINE> v = list ( a_counter . values ( ) ) <NEWLINE> <NL> if len ( a_counter ) == 3 and k [ 0 ] ^ k [ 1 ] ^ k [ 2 ] == 0 and v [ 0 ] == v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( a_counter ) == 2 and 0 in k and ( v [ 0 ] == v [ 1 ] * 2 or v [ 1 ] == v [ 0 ] * 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( a_counter ) == 1 and 0 in k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> dct = defaultdict ( int ) <NEWLINE> for s in S : <NEWLINE> <INDENT> dct [ s ] += 1 <NEWLINE> <DEDENT> for key , val in dct . items ( ) : <NEWLINE> <INDENT> if not val == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> bl = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> cl = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for b in bl : <NEWLINE> <INDENT> i = bisect . bisect_left ( al , b ) <NEWLINE> j = bisect . bisect_right ( cl , b ) <NEWLINE> ans += i * ( n - j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> y = bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += x * ( n - y ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> lcm = int ( n * m / math . gcd ( n , m ) ) <NEWLINE> if ( n - 1 ) // ( lcm // m ) == 0 : <NEWLINE> <INDENT> if s [ 0 ] == t [ 0 ] : <NEWLINE> <INDENT> print ( lcm ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( n - 1 ) // ( lcm // m ) ) : <NEWLINE> <INDENT> if s [ i * ( lcm // m ) ] != t [ i * ( lcm // n ) ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i == ( n - 1 ) // ( lcm // m ) - 1 : <NEWLINE> <INDENT> print ( lcm ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a + i <= b : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( k - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if b - i > a + k - 1 : <NEWLINE> <INDENT> print ( b - i ) <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) ) ) <NEWLINE> l = [ sum ( n ) ] <NEWLINE> for i in range ( 1 , len ( n ) ) : <NEWLINE> <INDENT> n [ - i ] = 9 <NEWLINE> n [ - i - 1 ] -= 1 <NEWLINE> l . append ( sum ( n ) ) <NEWLINE> <DEDENT> print ( max ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> if 1 not in A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == num : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AA = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> AA [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> L = [ str ( a ) for a in AA ] <NEWLINE> L = <STRING> . join ( L ) <NEWLINE> print ( L ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort_lis = sorted ( lis ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> fac_lis = [ [ 0 ] for i in range ( N ) ] <NEWLINE> fac_lis [ 0 ] = 1 <NEWLINE> max_ans = 0 <NEWLINE> min_ans = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> fac_lis [ i ] = fac_lis [ i - 1 ] * ( i + 1 ) % p <NEWLINE> <NL> <DEDENT> def combi ( n , k ) : <NEWLINE> <INDENT> if n == k : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fac_lis [ n - 1 ] * pow ( fac_lis [ k - 1 ] , p - 2 , p ) * pow ( fac_lis [ n - k - 1 ] , p - 2 , p ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K - 1 , N ) : <NEWLINE> <INDENT> max_ans += sort_lis [ i ] * combi ( i , K - 1 ) <NEWLINE> max_ans %= p <NEWLINE> <NL> <DEDENT> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> min_ans += sort_lis [ i ] * combi ( N - ( i + 1 ) , K - 1 ) <NEWLINE> min_ans %= p <NEWLINE> <NL> <DEDENT> ans = ( max_ans - min_ans ) % p <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p , m = [ ] , [ ] <NEWLINE> z = 0 <NEWLINE> for i in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> if i < 0 : m . append ( i ) <NEWLINE> elif i == 0 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> else : p . append ( i ) <NEWLINE> <DEDENT> if p and m : <NEWLINE> <INDENT> print ( sum ( p ) - sum ( m ) ) <NEWLINE> if z : <NEWLINE> <INDENT> for h in range ( z - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> <DEDENT> else : now = p . pop ( ) <NEWLINE> for j in m [ 1 : ] : <NEWLINE> <INDENT> print ( now , j ) <NEWLINE> now -= j <NEWLINE> <DEDENT> if p : <NEWLINE> <INDENT> print ( m [ 0 ] , now ) <NEWLINE> now = - now + m [ 0 ] <NEWLINE> for j in p [ 1 : ] : <NEWLINE> <INDENT> print ( now , j ) <NEWLINE> now -= j <NEWLINE> <DEDENT> print ( p [ 0 ] , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( now , m [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> elif p : <NEWLINE> <INDENT> if z : <NEWLINE> <INDENT> print ( sum ( p ) ) <NEWLINE> for h in range ( z - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> f = p . pop ( ) <NEWLINE> for i in p : <NEWLINE> <INDENT> print ( now , i ) <NEWLINE> now -= i <NEWLINE> <DEDENT> print ( f , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( p ) - 2 * min ( p ) ) <NEWLINE> p . sort ( ) <NEWLINE> now = p [ 0 ] <NEWLINE> k = p . pop ( ) <NEWLINE> for j in p [ 1 : ] : <NEWLINE> <INDENT> print ( now , j ) <NEWLINE> now -= j <NEWLINE> <DEDENT> print ( k , now ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if z : <NEWLINE> <INDENT> print ( - sum ( m ) ) <NEWLINE> for h in range ( z - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . sort ( ) <NEWLINE> print ( - sum ( m ) + 2 * max ( m ) ) <NEWLINE> now = m . pop ( ) <NEWLINE> <DEDENT> for i in m : <NEWLINE> <INDENT> print ( now , i ) <NEWLINE> now -= i <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ K - Q ] * N <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> arr [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in arr : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> a_num = 0 <NEWLINE> b = deque ( ) <NEWLINE> c = deque ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_num = int ( input ( ) ) <NEWLINE> a . append ( a_num ) <NEWLINE> k , p = 0 , 0 <NEWLINE> x = [ 0 ] * N <NEWLINE> b_num = deque ( ) <NEWLINE> for i in range ( a_num ) : <NEWLINE> <INDENT> k , p = map ( int , input ( ) . split ( ) ) <NEWLINE> b_num . append ( k - 1 ) <NEWLINE> x [ k - 1 ] = p <NEWLINE> <DEDENT> b . append ( b_num ) <NEWLINE> c . append ( x ) <NEWLINE> <DEDENT> max_num = 0 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> two = format ( i , <STRING> ) <NEWLINE> two = two [ : : - 1 ] <NEWLINE> flag = True <NEWLINE> for i , k in enumerate ( two ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i < N : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> for l in range ( a [ i ] ) : <NEWLINE> <INDENT> for j in b [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> if c [ i ] [ j ] != int ( two [ j ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <COMMENT> <NL> <INDENT> max_num = max ( max_num , two . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max_num ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> ans += bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ i - 1 for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . n = num <COMMENT> <NEWLINE> self . parents = [ - 1 for i in range ( self . n ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> xx = self . find ( x ) <COMMENT> <NEWLINE> yy = self . find ( y ) <COMMENT> <NEWLINE> if xx == yy : <NEWLINE> <INDENT> return <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> size_xx = abs ( self . parents [ xx ] ) <COMMENT> <NEWLINE> size_yy = abs ( self . parents [ yy ] ) <COMMENT> <NEWLINE> if size_xx > size_yy : <NEWLINE> <INDENT> xx , yy = yy , xx <COMMENT> <NEWLINE> <NL> <DEDENT> self . parents [ yy ] += self . parents [ xx ] <COMMENT> <NEWLINE> self . parents [ xx ] = yy <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> xx = self . find ( x ) <NEWLINE> return abs ( self . parents [ xx ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return 1 if self . find ( x ) == self . find ( y ) else 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> xx = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == xx ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def state_grouping ( self ) : <NEWLINE> <INDENT> return list ( self . all_group_members ( ) . values ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += uf . same ( i , P [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> N = len ( s ) <NEWLINE> p = sum ( [ 1 if si == <STRING> else 0 for si in s ] ) <NEWLINE> print ( N // 2 - p ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> b = b - 1 <NEWLINE> slist = list ( s ) <NEWLINE> if slist [ b ] == <STRING> : <NEWLINE> <INDENT> slist [ b ] = <STRING> <NEWLINE> <DEDENT> if slist [ b ] == <STRING> : <NEWLINE> <INDENT> slist [ b ] = <STRING> <NEWLINE> <DEDENT> if slist [ b ] == <STRING> : <NEWLINE> <INDENT> slist [ b ] = <STRING> <NEWLINE> <DEDENT> s = <STRING> . join ( slist ) <NEWLINE> print ( s ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt_s = Counter ( [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] ) <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in cnt_s . values ( ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> ins = [ 0 ] * N <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> ins [ y - 1 ] += 1 <NEWLINE> <NL> <DEDENT> DP = [ 0 ] * N <NEWLINE> queue = deque ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ins [ i ] == 0 : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in G [ v ] : <NEWLINE> <INDENT> ins [ i ] -= 1 <NEWLINE> if ins [ i ] == 0 : <NEWLINE> <INDENT> DP [ i ] = max ( DP [ i ] , DP [ v ] + 1 ) <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( DP ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> exit ( ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] + a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> start = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> start . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for sh , sw in start : <NEWLINE> <INDENT> maze = [ [ f_inf ] * W for _ in range ( H ) ] <NEWLINE> maze [ sh ] [ sw ] = 0 <NEWLINE> que = deque ( [ [ sh , sw ] ] ) <NEWLINE> while que : <NEWLINE> <INDENT> h , w = que . popleft ( ) <NEWLINE> for dh , dw in [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> next_h , next_w = h + dh , w + dw <NEWLINE> if next_h < 0 or next_h >= H or next_w < 0 or next_w >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S [ next_h ] [ next_w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if maze [ next_h ] [ next_w ] > maze [ h ] [ w ] + 1 : <NEWLINE> <INDENT> maze [ next_h ] [ next_w ] = maze [ h ] [ w ] + 1 <NEWLINE> que . append ( [ next_h , next_w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ma = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> ma = max ( ma , maze [ h ] [ w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = max ( res , ma ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from bisect import bisect_left <NEWLINE> l . sort ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> idx = bisect_left ( l , l [ a ] + l [ b ] , lo = b ) <NEWLINE> count += idx - ( b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n + 1 , r ) : <NEWLINE> <INDENT> for j in range ( 0 , n + 1 , g ) : <NEWLINE> <INDENT> if i + j <= n : <NEWLINE> <INDENT> if ( n - ( i + j ) ) % b == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ d [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> if a [ 0 ] == 1 and d [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i - 1 ] ** a [ i ] <NEWLINE> ans %= 998244353 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> X = nl ( ) <NEWLINE> X_s = sorted ( X ) <NEWLINE> mid = X_s [ n // 2 ] <NEWLINE> del_mid = ( X_s [ : n // 2 ] + X_s [ n // 2 + 1 : ] ) [ ( n - 1 ) // 2 ] <NEWLINE> for x in X : <NEWLINE> <INDENT> if x < mid : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> <DEDENT> elif x > mid : <NEWLINE> <INDENT> print ( X_s [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( del_mid ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect , copy , heapq , string <NEWLINE> from collections import * <NEWLINE> from math import * <NEWLINE> from itertools import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> k = gcd ( n , m ) <NEWLINE> l = n * m // k <NEWLINE> <NL> for i in range ( 0 , l , l // k ) : <NEWLINE> <INDENT> if ( n * i ) % l == ( m * i ) % l == 0 and s [ n * i // l ] != t [ m * i // l ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> sH = np . array ( sorted ( H ) , dtype = np . int64 ) <NEWLINE> shift = sH [ K - 1 : ] <NEWLINE> diff = shift - sH [ : len ( shift ) ] <NEWLINE> ans = min ( diff ) <NEWLINE> print ( ans ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A_list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> max_num = heapq . heappop ( A_list ) * ( - 1 ) <NEWLINE> heapq . heappush ( A_list , ( - 1 ) * ( max_num // 2 ) ) <NEWLINE> <DEDENT> print ( ( - 1 ) * sum ( A_list ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> d = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d [ a [ i ] ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if d [ i ] != 0 : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] + d [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( d [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( x % 100 == 0 ) or ( x % 101 == 0 ) or ( x % 102 == 0 ) or ( x % 103 == 0 ) or ( x % 104 == 0 ) or ( x % 105 == 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return f ( x - 100 ) or f ( x - 101 ) or f ( x - 102 ) or f ( x - 103 ) or f ( x - 104 ) or f ( x - 105 ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = ii ( ) <NEWLINE> print ( 1 if f ( X ) else 0 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> P , X = [ ] , [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> X . append ( x ) <NEWLINE> <NL> <DEDENT> t_sum = sum ( T ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> print ( t_sum - T [ P [ i ] - 1 ] + X [ i ] ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> B = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> C = Counter ( B ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in set ( B ) : <NEWLINE> <INDENT> p = C [ i ] <NEWLINE> ans += p * ( p - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import heapq <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> heapq . heapify ( A ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , - ( - tmp // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> INF = 1000000007 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= INF <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> tv = [ [ 0 ] * C for _ in range ( 100000 ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , t , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( s - 1 , t ) : tv [ i ] [ c - 1 ] = 1 <NEWLINE> <DEDENT> print ( max ( [ sum ( tv [ i ] ) for i in range ( 100000 ) ] ) ) <NEWLINE>
<NL> from functools import reduce <NEWLINE> def comb ( n , max_k , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = [ 1 ] * ( max_k + 1 ) <NEWLINE> t = 1 <NEWLINE> for i in range ( max_k + 1 ) : <NEWLINE> <INDENT> res [ i ] *= t <NEWLINE> t *= n - i <NEWLINE> t %= mod <NEWLINE> <NL> <DEDENT> n = reduce ( lambda x , y : ( x * y ) % mod , range ( 1 , max_k + 1 ) , 1 ) <NEWLINE> n = pow ( n , mod - 2 , mod ) <NEWLINE> <NL> for i in reversed ( range ( max_k + 1 ) ) : <NEWLINE> <INDENT> res [ i ] *= n <NEWLINE> res [ i ] %= mod <NEWLINE> n *= i <NEWLINE> n %= mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = X + Y <NEWLINE> <NL> if d % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = d // 3 <NEWLINE> if X < n or 2 * n < X : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = comb ( n , X - n , 10 ** 9 + 7 ) [ X - n ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = N * ( N - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = N // 2 <NEWLINE> R = sorted ( L ) <NEWLINE> for i in L : <NEWLINE> <INDENT> if i > R [ n - 1 ] : <NEWLINE> <INDENT> print ( R [ n - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R [ n ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def convolve ( x , y ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> z = np . convolve ( x , y ) % MOD <NEWLINE> z [ : 12 ] += z [ 13 : 25 ] <NEWLINE> return z [ : 13 ] % MOD <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> dp = np . zeros ( ( len ( S ) , 13 ) , dtype = <STRING> ) <NEWLINE> amari = 1 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] [ int ( S [ 0 ] ) ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> arr = np . zeros ( 13 , dtype = <STRING> ) <NEWLINE> amari = 10 * amari % 13 <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> for si in range ( 10 ) : <NEWLINE> <INDENT> arr [ amari * si % 13 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr [ amari * int ( S [ i ] ) % 13 ] = 1 <NEWLINE> <DEDENT> dp [ i ] = convolve ( dp [ i - 1 ] , arr ) <NEWLINE> <NL> <DEDENT> print ( dp [ len ( S ) - 1 ] [ 5 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> l . sort ( ) <NEWLINE> dp = [ 0 ] * ( max ( N + 1 , 8 ) ) <NEWLINE> for j in l : <NEWLINE> <INDENT> dp [ w [ j - 1 ] ] = j <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ i ] != 0 : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> if w [ j - 1 ] + i <= N : <NEWLINE> <INDENT> dp [ i + w [ j - 1 ] ] = max ( dp [ i + w [ j - 1 ] ] , dp [ i ] * 10 + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ L - 1 ] [ R - 1 ] += 1 <NEWLINE> <NL> <DEDENT> csum = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> csum [ i ] [ j ] = csum [ i ] [ j - 1 ] + csum [ i - 1 ] [ j ] - csum [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( csum [ q ] [ q ] - csum [ q ] [ p - 1 ] - csum [ p - 1 ] [ q ] + csum [ p - 1 ] [ p - 1 ] ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> broken = [ False ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> broken [ int ( input ( ) ) ] = True <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 if not broken [ 1 ] else 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if not broken [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] += ( dp [ i - 1 ] ) <NEWLINE> <DEDENT> if not broken [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] += ( dp [ i - 2 ] ) <NEWLINE> <DEDENT> dp [ i ] %= MOD <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
from math import ceil <NEWLINE> time = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> mod = [ i % 10 for i in time ] <NEWLINE> a = 124 <NEWLINE> res = 0 <NEWLINE> for i in range ( len ( mod ) ) : <NEWLINE> <INDENT> if mod [ i ] != 0 : <NEWLINE> <INDENT> a = min ( a , mod [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if a == 124 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == mod . index ( a ) : <NEWLINE> <INDENT> res += time [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += ceil ( time [ i ] / 10 ) * 10 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> F = [ ] <NEWLINE> P = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> F . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = - 10 ** 9 <NEWLINE> for i in range ( 1 , 1 << ( 10 ) ) : <NEWLINE> <INDENT> C = [ 0 ] * n <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if i & 2 ** j : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if F [ k ] [ j ] : <NEWLINE> <INDENT> C [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> current = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> current += P [ k ] [ C [ k ] ] <NEWLINE> <DEDENT> ans = max ( current , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from math import factorial <NEWLINE> <NL> <COMMENT> <NL> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if k > N - K + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> c1 = factorial ( K - 1 ) // ( factorial ( K - k ) * factorial ( k - 1 ) ) <NEWLINE> c1 = int ( c1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> c2 = factorial ( N - K + 1 ) // ( factorial ( N - K - k + 1 ) * factorial ( k ) ) <NEWLINE> c2 = int ( c2 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> ans = c1 * c2 % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mini = float ( <STRING> ) <NEWLINE> <NL> cumsum = list ( itertools . accumulate ( A ) ) <NEWLINE> A . reverse ( ) <NEWLINE> rev = list ( itertools . accumulate ( A ) ) <NEWLINE> rev . reverse ( ) <NEWLINE> cumsum . pop ( ) <NEWLINE> rev . pop ( 0 ) <NEWLINE> <NL> for i , j in zip ( cumsum , rev ) : <NEWLINE> <INDENT> if abs ( i - j ) < mini : <NEWLINE> <INDENT> mini = abs ( i - j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mini ) <NEWLINE>
from bisect import bisect_right <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> if set ( list ( t ) ) != ( set ( list ( s ) ) & set ( list ( t ) ) ) : ans = - 1 <NEWLINE> else : <NEWLINE> <INDENT> dct = { } <NEWLINE> <NL> for i , ss in enumerate ( s ) : <NEWLINE> <INDENT> if ss in dct : <NEWLINE> <INDENT> dct [ ss ] . append ( i ) <NEWLINE> <DEDENT> else : dct [ ss ] = [ i ] <NEWLINE> <DEDENT> idx = - 1 <NEWLINE> ans = 0 <NEWLINE> for tt in t : <NEWLINE> <INDENT> m = bisect_right ( dct [ tt ] , idx ) <NEWLINE> if m == len ( dct [ tt ] ) : <NEWLINE> <INDENT> idx = dct [ tt ] [ 0 ] <NEWLINE> ans += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = dct [ tt ] [ m ] <NEWLINE> <DEDENT> <DEDENT> ans += idx + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> if all ( [ x == 0 for x in arr ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if n % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> c = Counter ( arr ) <NEWLINE> <NL> <COMMENT> <NL> if len ( c ) == 2 : <NEWLINE> <INDENT> if c [ 0 ] == n // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif len ( c ) == 3 : <NEWLINE> <INDENT> result = list ( c . values ( ) ) <NEWLINE> if result [ 0 ] == result [ 1 ] == result [ 2 ] : <NEWLINE> <INDENT> ans1 = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> result = list ( c . keys ( ) ) <NEWLINE> ans2 = result [ 0 ] == result [ 1 ] ^ result [ 2 ] and result [ 1 ] == result [ 0 ] ^ result [ 2 ] and result [ 2 ] == result [ 0 ] ^ result [ 1 ] <NEWLINE> <NL> print ( <STRING> if ans1 and ans2 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> lst = [ ] <NEWLINE> if ( n == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ( h [ i ] >= h [ i + 1 ] ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> if ( count != 0 ) : <NEWLINE> <INDENT> lst . append ( count ) <NEWLINE> <NL> <DEDENT> lst . sort ( ) <NEWLINE> lst . reverse ( ) <NEWLINE> <NL> print ( lst [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( pow ( 10 , 6 ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Edges = list ( [ ] for _ in range ( N ) ) <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> Edges [ x - 1 ] . append ( y - 1 ) <NEWLINE> Edges [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( cur_node , parent_node ) : <NEWLINE> <INDENT> grundy = 0 <NEWLINE> for child_node in Edges [ cur_node ] : <NEWLINE> <INDENT> if child_node == parent_node : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> grundy ^= ( dfs ( child_node , cur_node ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> return grundy <NEWLINE> <NL> <DEDENT> G = dfs ( 0 , - 1 ) <NEWLINE> if G == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> A [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> p = [ K - Q ] * N <NEWLINE> <NL> for a , b in zip ( A , p ) : <NEWLINE> <INDENT> print ( <STRING> if 0 < a + b else <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> v . sort ( reverse = True ) <NEWLINE> total = 0 <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> for i in range ( A ) : <NEWLINE> <INDENT> total = total + v [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total / A ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> min = v [ A - 1 ] <NEWLINE> number = v . count ( min ) <NEWLINE> <NL> if ( v . index ( min ) == 0 ) : <NEWLINE> <INDENT> for i in range ( A , number + 1 ) : <NEWLINE> <INDENT> if ( i > B ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = combinations_count ( number , i ) + count <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( combinations_count ( number , A - v . index ( min ) ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : cnt += 1 <NEWLINE> elif s [ i ] == <STRING> : ans . append ( cnt ) <NEWLINE> else : cnt = 0 <NEWLINE> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] - c [ i ] >= 1 : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> import math <NEWLINE> def yakusu ( n ) : <NEWLINE> <INDENT> ans_local = set ( ) <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans_local = ans_local | set ( [ i , n // i ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return list ( ans_local ) <COMMENT> <NEWLINE> <NL> <DEDENT> yaku = sorted ( yakusu ( s ) , reverse = 1 ) <NEWLINE> <COMMENT> <NL> for mod in yaku : <NEWLINE> <INDENT> B = [ i % mod for i in A if i % mod != 0 ] <NEWLINE> if B == [ ] : print ( mod ) ; exit ( ) <NEWLINE> if len ( B ) == 1 : <NEWLINE> <INDENT> q = B [ 0 ] <NEWLINE> if 0 <= q <= k or mod - k <= q : print ( mod ) ; exit ( ) <NEWLINE> else : continue <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> r = [ B [ 0 ] ] * len ( B ) <NEWLINE> for i in range ( len ( B ) - 1 ) : <NEWLINE> <INDENT> r [ i + 1 ] = r [ i ] + B [ i + 1 ] <NEWLINE> <DEDENT> now = float ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( B ) ) : <COMMENT> <NEWLINE> <INDENT> if r [ i - 1 ] == mod * ( len ( B ) - i ) - ( r [ - 1 ] - r [ i - 1 ] ) and r [ i - 1 ] <= k : <NEWLINE> <INDENT> print ( mod ) ; exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> def dfs ( i , now , done ) : <NEWLINE> <INDENT> global count <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> return <NEWLINE> <NL> <DEDENT> for j in ab [ now ] : <NEWLINE> <INDENT> if j not in done : <NEWLINE> <INDENT> dfs ( i + 1 , j , done + [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 , [ 0 ] ) <NEWLINE> print ( count ) <NEWLINE>
from numpy import * <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = ( N - K + 1 ) * [ 0 ] <NEWLINE> R = sum ( P [ 0 : K ] ) <NEWLINE> Q [ 0 ] = R <NEWLINE> <NL> for n in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> R += P [ n - 1 + K ] - P [ n - 1 ] <NEWLINE> Q [ n ] = R <NEWLINE> <NL> <DEDENT> S = argmax ( Q ) <NEWLINE> print ( 0.5 * ( sum ( P [ S : S + K ] ) + K ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> ci = L [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> cij = ci + L [ j ] <NEWLINE> c += bisect . bisect_left ( L , cij , j + 1 , n ) - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> a . append ( i - 1 ) <NEWLINE> <DEDENT> if n // i - 1 != 0 : <NEWLINE> <INDENT> a . append ( ( n // i ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != 1 and ( n // a [ i ] == n % a [ i ] ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> P . sort ( reverse = True ) <NEWLINE> <NL> if k > len ( P ) : <NEWLINE> <INDENT> k = len ( P ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( P [ c : ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> take = [ [ - 1 ] for i in range ( M ) ] <NEWLINE> for x in range ( M ) : <NEWLINE> <INDENT> B , C = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> take [ x ] = B , C <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A . sort ( ) <NEWLINE> take . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> take = [ ( 0 , 0 ) ] + take <NEWLINE> ind = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 1 , M + 1 ) : <COMMENT> <NEWLINE> <INDENT> ind [ i ] = ind [ i - 1 ] + take [ i ] [ 0 ] <NEWLINE> if ind [ i - 1 ] >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif A [ ind [ i - 1 ] ] >= take [ i ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ind [ i ] < N and A [ ind [ i ] ] < take [ i ] [ 1 ] : <COMMENT> <NEWLINE> <INDENT> A [ ind [ i - 1 ] : ind [ i ] ] = [ take [ i ] [ 1 ] ] * ( take [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( ind [ i - 1 ] , ind [ i ] ) : <COMMENT> <NEWLINE> <INDENT> if N <= j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ j ] < take [ i ] [ 1 ] : <NEWLINE> <INDENT> A [ j ] = take [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> m = p [ 0 ] <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> m = min ( m , i ) <NEWLINE> if m == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
ni = lambda : int ( input ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> visited = set ( ) <NEWLINE> <NL> n , q = nm ( ) <NEWLINE> <NL> tval = [ 0 ] * n <NEWLINE> t = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = nm ( ) <NEWLINE> t [ a - 1 ] . append ( b - 1 ) <NEWLINE> t [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = nm ( ) <NEWLINE> tval [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> def dfs ( num , val ) : <NEWLINE> <INDENT> visited . add ( num ) <NEWLINE> now = val + tval [ num ] <NEWLINE> ans [ num ] = now <NEWLINE> for nn in t [ num ] : <NEWLINE> <INDENT> if nn not in visited : <NEWLINE> <INDENT> dfs ( nn , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = int ( s [ : 2 ] ) <NEWLINE> b = int ( s [ 2 : ] ) <NEWLINE> if 0 < a <= 12 and 0 < b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 99 and 0 < b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 0 < a <= 12 and b <= 99 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> left = 0 <NEWLINE> right = len ( s ) - 1 <NEWLINE> x_cnt = 0 <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> if s [ left ] == s [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ left ] == <STRING> : <NEWLINE> <INDENT> x_cnt += 1 <NEWLINE> left += 1 <NEWLINE> <DEDENT> elif s [ right ] == <STRING> : <NEWLINE> <INDENT> x_cnt += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x_cnt ) <NEWLINE>
def primes ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> like = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if ( is_prime [ i ] == False ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( is_prime [ int ( ( i + 1 ) / 2 ) ] == True ) : <NEWLINE> <INDENT> like [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return like <NEWLINE> <COMMENT> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> table = primes ( 10 ** 5 + 10 ) <NEWLINE> accum = [ 0 ] <NEWLINE> for i in range ( 1 , 10 ** 5 + 5 ) : <NEWLINE> <INDENT> if ( table [ i ] == True ) : <NEWLINE> <INDENT> accum . append ( accum [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> accum . append ( accum [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( accum [ r ] - accum [ l - 1 ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> left = 1 <NEWLINE> right = N <NEWLINE> <NL> for l , r in LR : <NEWLINE> <INDENT> left = max ( left , l ) <NEWLINE> right = min ( right , r ) <NEWLINE> <NL> <DEDENT> ans = right - left <NEWLINE> <NL> print ( ans + 1 if ans >= 0 else 0 ) <NEWLINE>
import re <NEWLINE> <NL> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> lis = [ 0 ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> lis . append ( count ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( lis [ r - 1 ] - lis [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> import os <NEWLINE> import random <NEWLINE> import re <NEWLINE> import sys <NEWLINE> def dpfindpath ( a ) : <NEWLINE> <INDENT> dpath = [ int ( 0 ) for _ in range ( len ( a ) ) ] <NEWLINE> dpath [ 0 ] = 0 <NEWLINE> dpath [ 1 ] = abs ( a [ 1 ] - a [ 0 ] ) <NEWLINE> for i in range ( 2 , len ( a ) ) : <NEWLINE> <INDENT> dpath [ i ] = min ( abs ( a [ i ] - a [ i - 1 ] ) + dpath [ i - 1 ] , abs ( a [ i ] - a [ i - 2 ] ) + dpath [ i - 2 ] ) <NEWLINE> <DEDENT> return dpath [ len ( a ) - 1 ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> print ( dpfindpath ( a ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b = l [ i ] <NEWLINE> c , e = l [ j ] <NEWLINE> d [ ( a - c , b - e ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = n <NEWLINE> m = max ( d . values ( ) ) <NEWLINE> for i , j in d . items ( ) : <NEWLINE> <INDENT> if j != m : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> x , y = i <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count = 0 <NEWLINE> for c , d in l : <NEWLINE> <INDENT> if [ c + x , d + y ] in l : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , n - count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> check = [ ] <NEWLINE> check2 = [ ] <NEWLINE> for i in range ( 1 , 33 ) : <NEWLINE> <INDENT> for s in range ( 2 , 11 ) : <NEWLINE> <INDENT> check . append ( pow ( i , s ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in check : <NEWLINE> <INDENT> if i <= X : <NEWLINE> <INDENT> check2 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( check2 ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L , R = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L += [ gcd ( L [ i ] , A [ i ] ) ] <NEWLINE> R += [ gcd ( R [ i ] , A [ - i - 1 ] ) ] <NEWLINE> <NL> <DEDENT> print ( max ( gcd ( L [ i ] , R [ - i - 1 ] ) for i in range ( N ) ) ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> l , r = 0 , len ( s ) - 1 <NEWLINE> ans = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> if s [ l ] == s [ r ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
com = int ( input ( ) ) <NEWLINE> if com == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( input ( ) ) ; b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 1000000007 <NEWLINE> <NL> fac = [ 0 ] * ( N + 1 ) <NEWLINE> fac [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> fac [ i + 1 ] = fac [ i ] * ( i + 1 ) % m <NEWLINE> <NL> <NL> <DEDENT> def mcomb ( n , k ) : <NEWLINE> <INDENT> if n == 0 and k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < k or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * pow ( fac [ n - k ] , m - 2 , m ) * pow ( fac [ k ] , m - 2 , m ) % m <NEWLINE> <NL> <NL> <DEDENT> A . sort ( reverse = True ) <NEWLINE> maxX = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> maxX += A [ i ] * mcomb ( N - ( i + 1 ) , K - 1 ) <NEWLINE> maxX %= m <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> minX = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> minX += A [ i ] * mcomb ( N - ( i + 1 ) , K - 1 ) <NEWLINE> minX %= m <NEWLINE> <NL> <DEDENT> print ( ( maxX - minX ) % m ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> As = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> <NL> cumsum = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> cumsum [ i - 1 ] = abs ( As [ i ] - As [ i - 1 ] ) <NEWLINE> <DEDENT> cumsum_sum = sum ( cumsum ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = cumsum_sum - cumsum [ i - 1 ] - cumsum [ i ] + abs ( As [ i + 1 ] - As [ i - 1 ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 2018 <NEWLINE> i = L <NEWLINE> while i < R : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j <= R : <NEWLINE> <INDENT> if i * j % 2019 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Stlist = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> breakstair = int ( input ( ) ) <NEWLINE> Stlist [ breakstair - 1 ] = 0 <NEWLINE> <DEDENT> Comb = [ 1 , 2 ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> Comb = Stlist <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Stlist [ 0 ] == 0 : <NEWLINE> <INDENT> Comb [ 0 ] = 0 <NEWLINE> Comb [ 1 ] = 1 <NEWLINE> <DEDENT> if Stlist [ 1 ] == 0 : <NEWLINE> <INDENT> Comb [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> Comb . append ( ( Comb [ i - 1 ] + Comb [ i - 2 ] ) % ( 10 ** 9 + 7 ) ) <NEWLINE> if Stlist [ i ] == 0 : <NEWLINE> <INDENT> Comb [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( Comb [ - 1 ] ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = 2 * y - x <NEWLINE> if tmp % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> up = tmp // 3 <NEWLINE> total = y - up * 2 + up <NEWLINE> <NL> n = total <NEWLINE> k = up <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if k == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> modinv_table = [ - 1 ] * ( k + 1 ) <NEWLINE> modinv_table [ 1 ] = 1 <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> modinv_table [ i ] = ( - modinv_table [ mod % i ] * ( mod // i ) ) % mod <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> k = total - up <NEWLINE> modinv_table = [ - 1 ] * ( k + 1 ) <NEWLINE> modinv_table [ 1 ] = 1 <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> modinv_table [ i ] = ( - modinv_table [ mod % i ] * ( mod // i ) ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def binomial_coefficients ( n , k ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= n - i <NEWLINE> ans *= modinv_table [ i + 1 ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( binomial_coefficients ( n , k ) ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> sl = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> sl . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if sum ( sl ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( sl ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in itertools . combinations ( sl , n - 1 ) : <NEWLINE> <INDENT> if sum ( v ) % 10 != 0 : <NEWLINE> <INDENT> ans = max ( ans , sum ( v ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ 0 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> ans [ i - 1 ] = abs ( li [ 1 ] - li [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] = min ( abs ( li [ i - 1 ] - li [ i - 2 ] ) + ans [ i - 2 ] , abs ( li [ i - 1 ] - li [ i - 3 ] ) + ans [ i - 3 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( 0 , b - ( k - a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
N , K = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> h = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( [ dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - K ) , i ) ] ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LRD = [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> Graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for l , r , d in LRD : <NEWLINE> <INDENT> Graph [ r - 1 ] . append ( ( l - 1 , d ) ) <NEWLINE> Graph [ l - 1 ] . append ( ( r - 1 , - d ) ) <NEWLINE> <NL> <DEDENT> seen = set ( ) <NEWLINE> Dfr = [ 0 ] * N <COMMENT> <NEWLINE> for root in range ( N ) : <NEWLINE> <INDENT> if root in seen : continue <NEWLINE> seen . add ( root ) <NEWLINE> V = [ root ] <NEWLINE> while len ( V ) != 0 : <COMMENT> <NEWLINE> <INDENT> v = V . pop ( 0 ) <NEWLINE> for nv , d in Graph [ v ] : <NEWLINE> <INDENT> if nv in seen and Dfr [ nv ] != Dfr [ v ] + d : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if nv in seen : continue <NEWLINE> else : <NEWLINE> <INDENT> seen . add ( nv ) <NEWLINE> Dfr [ nv ] = Dfr [ v ] + d <NEWLINE> V . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import heapq <NEWLINE> import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( lambda x : x * ( - 1 ) , A ) ) <NEWLINE> <NL> heapq . heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> max_value = heapq . heappop ( A ) * ( - 1 ) <NEWLINE> heapq . heappush ( A , max_value // 2 * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> import numpy as np <NEWLINE> def resolve ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def check ( X ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = X // F <NEWLINE> diff = np . maximum ( A - a , 0 ) <NEWLINE> cnt = np . sum ( diff ) <NEWLINE> return cnt <= K <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> F . sort ( ) <NEWLINE> F = F [ : : - 1 ] <NEWLINE> <NL> ok = 10 ** 12 <COMMENT> <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> X = ( ok + ng ) // 2 <NEWLINE> if check ( X ) : <NEWLINE> <INDENT> ok = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = X <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hat_nperson = [ 0 , 0 , 1 ] <NEWLINE> ans = 3 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if a_ls [ 0 ] != 0 or ( n != 1 and a_ls [ 1 ] == 2 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> n_same = a_ls [ i ] <NEWLINE> n_choices = 0 <NEWLINE> choice_ind = - 1 <NEWLINE> for j , person in enumerate ( hat_nperson ) : <NEWLINE> <INDENT> if person == n_same : <NEWLINE> <INDENT> n_choices += 1 <NEWLINE> choice_ind = j <NEWLINE> <DEDENT> <DEDENT> if choice_ind == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> hat_nperson [ choice_ind ] += 1 <NEWLINE> ans *= n_choices <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ship = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> s1 = [ False ] * N <NEWLINE> sN = [ False ] * N <NEWLINE> <NL> for i , s in enumerate ( ship ) : <NEWLINE> <INDENT> if s [ 0 ] == 1 : <NEWLINE> <INDENT> s1 [ s [ 1 ] - 1 ] = True <NEWLINE> <NL> <DEDENT> if s [ 1 ] == N : <NEWLINE> <INDENT> sN [ s [ 0 ] - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> if any ( [ p1 * pN for p1 , pN in zip ( s1 , sN ) ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 [ : , : ] ( i8 , i8 , i8 [ : , : ] , i8 [ : , : ] ) , cache = True ) <NEWLINE> def calc_cost ( N , C , D , c ) : <NEWLINE> <INDENT> cost = np . zeros ( ( C , 3 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( C ) : <NEWLINE> <INDENT> cost [ k ] [ ( i + j ) % 3 ] += D [ c [ i ] [ j ] - 1 ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> N , C , * Dc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> D = np . array ( Dc [ : C * C ] , dtype = np . int64 ) . reshape ( C , C ) <NEWLINE> c = np . array ( Dc [ C * C : ] , dtype = np . int64 ) . reshape ( N , N ) <NEWLINE> cost = calc_cost ( N , C , D , c ) <NEWLINE> <NL> ans = min ( <NEWLINE> <INDENT> sum ( cost [ c ] [ i ] for i , c in enumerate ( colors ) ) <NEWLINE> for colors in permutations ( range ( C ) , 3 ) <NEWLINE> <DEDENT> ) <NEWLINE> print ( ans ) <NEWLINE>
import itertools as it <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( [ a , b ] ) <NEWLINE> ans . append ( [ b , a ] ) <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for e in it . permutations ( range ( n ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> count = 1 <NEWLINE> if e [ 0 ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if [ e [ i ] + 1 , e [ i + 1 ] + 1 ] in ans : <NEWLINE> <INDENT> count *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count *= 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> a += count <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> a = b = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( a [ 0 ] // ( 2 ** m ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> while m > 0 : <NEWLINE> <INDENT> m -= 1 <NEWLINE> i = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> i //= 2 <NEWLINE> heapq . heappush ( a , i * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
from bisect import * <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> ans += ( n - bisect ( C , b ) ) * bisect_left ( A , b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> n , k = inpm ( ) <NEWLINE> A = sorted ( inpl ( ) ) <NEWLINE> <NL> f = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f . append ( f [ - 1 ] * i % mod ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> if n <= 0 or r <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> x = f [ n ] % mod <NEWLINE> y = f [ r ] * f [ n - r ] % mod <NEWLINE> return ( x * pow ( y , mod - 2 , mod ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = comb ( n - i - 1 , k - 1 ) <NEWLINE> ans += A [ n - 1 - i ] * c - A [ i ] * c <NEWLINE> ans %= mod <NEWLINE> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def main4 ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> L = ( N * M ) // math . gcd ( N , M ) <NEWLINE> <NL> pair = dict ( ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> idx = ( i - 1 ) * ( L // N ) + 1 <NEWLINE> pair [ idx ] = S [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> idx = ( i - 1 ) * ( L // M ) + 1 <NEWLINE> <NL> if idx in pair . keys ( ) : <NEWLINE> <INDENT> if pair [ idx ] != T [ i - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> substrings = set ( [ ] ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) - i ) : <NEWLINE> <COMMENT> <NL> <INDENT> substrings . add ( s [ j : j + i + 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( sorted ( substrings ) [ K - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ 0 for _ in range ( max ( A ) + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> if n > 3 : <NEWLINE> <INDENT> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> tmp = sum ( count [ i : i + 3 ] ) <NEWLINE> if tmp > answer : <NEWLINE> <INDENT> answer = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> if len ( count ) > 3 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 2 <NEWLINE> <DEDENT> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nlis = sorted ( lis ) <NEWLINE> <NL> med1 = nlis [ n // 2 - 1 ] <NEWLINE> med2 = nlis [ n // 2 ] <NEWLINE> <NL> for i in lis : <NEWLINE> <INDENT> if i <= med1 : <NEWLINE> <INDENT> print ( med2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( med1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = int ( input ( ) ) <NEWLINE> <NL> a = math . ceil ( s / 2 ) <NEWLINE> print ( a - 1 ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ball = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) [ : : - 1 ] : <NEWLINE> <INDENT> m = n // ( i + 1 ) <NEWLINE> count = 0 <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> count += ball [ j * ( i + 1 ) - 1 ] <NEWLINE> <DEDENT> ball [ i ] = ( a [ i ] % 2 ) ^ ( count % 2 ) <NEWLINE> <NL> <DEDENT> print ( sum ( ball ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ball [ i ] == 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
L , R = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if R - L >= 2018 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 < ans : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = int ( input ( ) ) <NEWLINE> c = ( a * b ) // math . gcd ( a , b ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> c = ( c * b ) // math . gcd ( c , b ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = 0 <NEWLINE> m = 10 ** 9 <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if m >= a : <NEWLINE> <INDENT> m = a <NEWLINE> <DEDENT> if M < a : <NEWLINE> <INDENT> M = a <NEWLINE> c = b + 1 <NEWLINE> <DEDENT> <DEDENT> ans = c + M - 1 <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> q = int ( math . sqrt ( N ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> b = int ( N / a ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( str ( b ) ) ) <NEWLINE>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> <NL> status = s [ 0 ] <NEWLINE> cnt = 1 <NEWLINE> sa = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != status : <NEWLINE> <INDENT> sa . append ( status * cnt ) <NEWLINE> cnt = 0 <NEWLINE> status = s [ i ] <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> sa . append ( status * cnt ) <NEWLINE> <NL> for i in range ( 1 , min ( k * 2 , len ( sa ) ) , 2 ) : <NEWLINE> <INDENT> sa [ i ] = ( <STRING> if sa [ i ] [ 0 ] == <STRING> else <STRING> ) * len ( sa [ i ] ) <NEWLINE> <NL> <DEDENT> sa = <STRING> . join ( sa ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sa [ i ] == <STRING> : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if sa [ i - 1 ] == <STRING> : ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i < n - 1 : <NEWLINE> <INDENT> if sa [ i + 1 ] == <STRING> : ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lw = [ input ( ) for i in range ( n ) ] <NEWLINE> used = set ( ) <NEWLINE> cond = True <NEWLINE> last = lw [ 0 ] [ 0 ] <NEWLINE> for w in lw : <NEWLINE> <INDENT> if w in used or last != w [ 0 ] : <NEWLINE> <INDENT> cond = False <NEWLINE> break <NEWLINE> <DEDENT> used . add ( w ) <NEWLINE> last = w [ - 1 ] <NEWLINE> <DEDENT> print ( <STRING> if cond else <STRING> ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> if ans == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> print ( min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) * 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ float ( <STRING> ) for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i + 1 , k + 1 ) ) : <NEWLINE> <INDENT> m = dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) <NEWLINE> if dp [ i ] > m : <NEWLINE> <INDENT> dp [ i ] = m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import networkx as nx <NEWLINE> import numpy as np <NEWLINE> <NL> h , w , * X , = open ( 0 ) . read ( ) . split ( ) <NEWLINE> h , w = int ( h ) , int ( w ) <NEWLINE> <NL> G = nx . grid_2d_graph ( h , w ) <NEWLINE> for i , S in enumerate ( X ) : <NEWLINE> <INDENT> for j , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> G . remove_node ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> path = nx . shortest_path ( G , ( 0 , 0 ) , ( h - 1 , w - 1 ) ) <NEWLINE> <DEDENT> except nx . NetworkXNoPath : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for node in path : <NEWLINE> <INDENT> G . remove_node ( node ) <NEWLINE> <DEDENT> print ( len ( G . nodes ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> X = [ 0 ] * n <NEWLINE> Y = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X [ i ] , Y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> x = X [ i ] - X [ j ] <NEWLINE> y = Y [ i ] - Y [ j ] <NEWLINE> dic [ ( x , y ) ] = dic . get ( ( x , y ) , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - max ( dic . values ( ) ) ) <NEWLINE> <DEDENT>
from itertools import groupby <NEWLINE> import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> S = [ [ i , len ( list ( j ) ) ] for i , j in groupby ( S ) ] <NEWLINE> <NL> if len ( S ) // 2 <= K : <NEWLINE> <INDENT> if len ( S ) % 2 == 1 and S [ - 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( sum ( [ j for i , j in S ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( [ j for i , j in S ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> lidx = - 1 <NEWLINE> for i , j in S : <NEWLINE> <INDENT> lidx += 1 <NEWLINE> if cnt == K and i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += j <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> sidx = 0 <NEWLINE> mans = ans <NEWLINE> for i in range ( lidx , len ( S ) ) : <NEWLINE> <INDENT> ans += S [ i ] [ 1 ] <NEWLINE> if i == len ( S ) - 1 or S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> ans -= S [ sidx ] [ 1 ] <NEWLINE> sidx += 1 <NEWLINE> if S [ sidx ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> mans = max ( mans , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mans ) <NEWLINE> <NL> <NL> <NL>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . factorial ( n ) % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> num , a , b = 0 , 0 , 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> num , a , b = abs ( t - num ) , abs ( x - a ) , abs ( y - b ) <NEWLINE> su = a + b <NEWLINE> if num >= su and num % 2 == su % 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> if 4 * h * n - N * n - N * h > 0 and ( N * h * n ) % ( 4 * h * n - N * n - N * h ) == 0 : <NEWLINE> <INDENT> print ( h , n , ( N * h * n ) // ( 4 * h * n - N * n - N * h ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = l [ i ] - i - 1 <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( sum ( list ( map ( lambda x : abs ( x - l [ ( ( n // 2 ) ) ] ) , l ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( sum ( list ( map ( lambda x : abs ( x - l [ ( n // 2 ) - 1 ] ) , l ) ) ) , sum ( list ( map ( lambda x : abs ( x - l [ ( n // 2 ) ] ) , l ) ) ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> S = input ( ) . strip ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> a = [ 0 if x == <STRING> else 1 for x in S ] <NEWLINE> <NL> q = deque ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if q : <NEWLINE> <INDENT> if q [ - 1 ] != i : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( q ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> mask = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> one_cnt = np . sum ( A >> i & 1 ) <NEWLINE> tmp = one_cnt * ( N - one_cnt ) <NEWLINE> tmp %= MOD <NEWLINE> ans += tmp * mask <NEWLINE> ans %= MOD <NEWLINE> mask <<= 1 <NEWLINE> mask %= MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> MOD = 1_000_000_007 <NEWLINE> print ( solve ( ) ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations <NEWLINE> from itertools import permutations <NEWLINE> from math import factorial <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> xy = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in xy : <NEWLINE> <INDENT> for j in xy : <NEWLINE> <INDENT> cnt += np . linalg . norm ( i - j ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt / N ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( W * H / 2 , int ( ( x + x == W and y + y == H ) ) ) <NEWLINE>
import math <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lrL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> li = [ 0 ] * n <NEWLINE> mx = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> mx += 1 <NEWLINE> <DEDENT> li [ i + 1 ] = mx <NEWLINE> <NL> <DEDENT> for l , r in lrL : <NEWLINE> <INDENT> print ( li [ r - 1 ] - li [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> T = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 1 ] * ( M + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp_prev = dp [ : ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if S [ i ] == T [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = ( dp_prev [ j + 1 ] + dp [ j ] ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j + 1 ] = ( dp_prev [ j + 1 ] + dp [ j ] - dp_prev [ j ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ M ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> num = int ( m ** 0.5 ) + 1 <NEWLINE> <NL> for i in range ( 1 , num ) : <NEWLINE> <INDENT> if m % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = m // i <NEWLINE> if i >= n : <NEWLINE> <INDENT> ans = max ( ans , j ) <NEWLINE> <DEDENT> if j >= n : <NEWLINE> <INDENT> ans = max ( ans , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2100 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 < ans : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> S = list ( input ( ) ) <NEWLINE> <NL> cnt_b = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt_b += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += cnt_b <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> j = max ( 0 , i - k ) <NEWLINE> dp [ i ] = min ( x + abs ( h [ i ] - y ) for x , y in zip ( dp [ j : i ] , h [ j : i ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif a < k and b > k - a : <NEWLINE> <INDENT> print ( 0 , ( b - k + a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> def divisor_count ( n : int ) -> int : <NEWLINE> <INDENT> ans = 0 <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i != n // i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> if divisor_count ( n ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = [ ] <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == n - 2 : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> m = 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < m : <NEWLINE> <INDENT> m = p [ i ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string , scipy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> P = LI ( ) <NEWLINE> Pe = [ ( v + 1 ) / 2 for v in P ] <NEWLINE> P_ms = numpy . cumsum ( Pe ) <NEWLINE> if K == N : print ( <STRING> . format ( sum ( Pe ) ) ) ; exit ( 0 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> ans = max ( ans , P_ms [ i ] - P_ms [ i - K ] ) <NEWLINE> <DEDENT> print ( <STRING> . format ( ans ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <NL>
import math <NEWLINE> from collections import Counter <NEWLINE> s = list ( input ( ) ) <NEWLINE> s = list ( map ( int , s ) ) <NEWLINE> dict_s = Counter ( s ) <NEWLINE> <COMMENT> <NL> print ( ( min ( dict_s [ 0 ] , dict_s [ 1 ] ) ) * 2 ) <NEWLINE>
from itertools import product <NEWLINE> s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> pattern = list ( product ( [ <STRING> , <STRING> ] , repeat = n - 1 ) ) <NEWLINE> <NL> for i in range ( 2 ** ( n - 1 ) ) : <NEWLINE> <INDENT> formula = s [ 0 ] <NEWLINE> for j , k in zip ( pattern [ i ] , s [ 1 : ] ) : <NEWLINE> <INDENT> formula += ( j + k ) <NEWLINE> <DEDENT> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( <STRING> . format ( formula ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
H = int ( input ( ) ) <NEWLINE> if H == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> count = 1 <NEWLINE> while H // 2 != 1 : <NEWLINE> <INDENT> i *= 2 <NEWLINE> count += i <NEWLINE> H = H // 2 <NEWLINE> <DEDENT> i *= 2 <NEWLINE> count += i <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> L = make_divisors ( N ) <NEWLINE> l = len ( L ) <NEWLINE> if l % 2 == 0 : <NEWLINE> <INDENT> a1 = str ( L [ l // 2 ] - 1 ) <NEWLINE> a2 = str ( L [ l // 2 ] ) <NEWLINE> print ( max ( len ( a1 ) , len ( a2 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1 = str ( L [ l // 2 - 1 ] ) <NEWLINE> a2 = str ( L [ l // 2 ] ) <NEWLINE> a3 = str ( L [ l // 2 + 1 ] ) <NEWLINE> d1 = max ( len ( a1 ) , len ( a2 ) ) <NEWLINE> d2 = max ( len ( a2 ) , len ( a3 ) ) <NEWLINE> print ( min ( d1 , d2 ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> vmax = sum ( [ wv [ i ] [ 1 ] for i in range ( N ) ] ) <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> dp = np . full ( vmax + 1 , INF ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = wv [ i - 1 ] <NEWLINE> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <NL> <DEDENT> print ( max ( [ i for i in range ( vmax + 1 ) if dp [ i ] <= W ] ) ) <NEWLINE>
import sys <NEWLINE> a = [ c for c in input ( ) ] <NEWLINE> B = 0 <NEWLINE> W = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W += B <NEWLINE> <NL> <DEDENT> <DEDENT> print ( W ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
arb = <STRING> <NEWLINE> S = input ( ) <NEWLINE> s_S = sorted ( set ( arb ) ^ set ( S ) ) <NEWLINE> print ( <STRING> if len ( s_S ) == 0 else s_S [ 0 ] ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> X = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> X = sorted ( X , reverse = True ) <NEWLINE> <NL> S = sum ( X [ : K ] ) <NEWLINE> <NL> ans = N - S <NEWLINE> <NL> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = sorted ( D ) [ : : - 1 ] <NEWLINE> import math <NEWLINE> from math import comb <NEWLINE> print ( sum ( D [ : A ] ) / A ) <NEWLINE> ans = 0 <NEWLINE> if D [ 0 ] != D [ A - 1 ] : <NEWLINE> <INDENT> n = D . count ( D [ A - 1 ] ) <NEWLINE> k = D [ : A ] . count ( D [ A - 1 ] ) <NEWLINE> print ( comb ( n , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = D . count ( D [ A - 1 ] ) <NEWLINE> for i in range ( A , min ( n , B ) + 1 ) : <NEWLINE> <INDENT> ans += comb ( n , i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> index6 , index9 , num6 , num9 = 0 , 0 , 0 , 0 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> a = [ INF for _ in range ( n + 1 ) ] <NEWLINE> a [ n ] = 0 <NEWLINE> <NL> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 1 <NEWLINE> while i - 9 ** j >= 0 : <NEWLINE> <INDENT> a [ i - 9 ** j ] = min ( a [ i ] + 1 , a [ i - 9 ** j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> j = 1 <NEWLINE> while i - 6 ** j >= 0 : <NEWLINE> <INDENT> a [ i - 6 ** j ] = min ( a [ i ] + 1 , a [ i - 6 ** j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> if i - 1 >= 0 : <NEWLINE> <INDENT> a [ i - 1 ] = min ( a [ i ] + 1 , a [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] ) <NEWLINE>
import numpy as np <NEWLINE> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> dp = np . zeros ( ( n + 1 , n + 1 , 3001 ) ) . astype ( np . int64 ) <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> _x = x [ i ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 , j + 1 , _x : ] += dp [ i , j , : - _x ] <NEWLINE> dp [ i + 1 , j , : ] += dp [ i , j , : ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += dp [ n , j , j * a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( X ) <NEWLINE> l = x [ n // 2 - 1 ] <NEWLINE> r = x [ n // 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] <= l : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) ; a = [ k - q for i in range ( n ) ] <NEWLINE> for _ in range ( q ) : a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> print ( * [ <STRING> if i > 0 else <STRING> for i in a ] , sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> a_idx = ord ( <STRING> ) <NEWLINE> S_Lis = { 0 : [ ] , 1 : [ ] , 2 : [ ] , 3 : [ ] , 4 : [ ] , 5 : [ ] , 6 : [ ] , 7 : [ ] , 8 : [ ] , 9 : [ ] , 10 : [ ] , 11 : [ ] , 12 : [ ] , <NEWLINE> <INDENT> 13 : [ ] , 14 : [ ] , 15 : [ ] , 16 : [ ] , 17 : [ ] , 18 : [ ] , 19 : [ ] , 20 : [ ] , 21 : [ ] , 22 : [ ] , 23 : [ ] , 24 : [ ] , 25 : [ ] } <NEWLINE> <DEDENT> T_Lis = { 0 : [ ] , 1 : [ ] , 2 : [ ] , 3 : [ ] , 4 : [ ] , 5 : [ ] , 6 : [ ] , 7 : [ ] , 8 : [ ] , 9 : [ ] , 10 : [ ] , 11 : [ ] , 12 : [ ] , <NEWLINE> <INDENT> 13 : [ ] , 14 : [ ] , 15 : [ ] , 16 : [ ] , 17 : [ ] , 18 : [ ] , 19 : [ ] , 20 : [ ] , 21 : [ ] , 22 : [ ] , 23 : [ ] , 24 : [ ] , 25 : [ ] } <NEWLINE> <DEDENT> leng = len ( S ) <NEWLINE> for i in range ( leng ) : <NEWLINE> <INDENT> S_Lis [ ord ( S [ i ] ) - a_idx ] . append ( i ) <NEWLINE> T_Lis [ ord ( T [ i ] ) - a_idx ] . append ( i ) <NEWLINE> <DEDENT> if sorted ( S_Lis . values ( ) ) == sorted ( T_Lis . values ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> divisors = [ [ ] , [ ] ] <NEWLINE> for i in range ( 1 , int ( sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divisors [ 0 ] . append ( i ) <NEWLINE> if i * i != x : <NEWLINE> <INDENT> divisors [ 1 ] . append ( x // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors [ 0 ] + divisors [ 1 ] [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in f ( m ) : <NEWLINE> <INDENT> if n <= i : <NEWLINE> <INDENT> print ( m // i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> from typing import Any , Callable , Deque , Dict , List , Mapping , Optional , Sequence , Set , Tuple , TypeVar , Union <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> Num = Union [ int , float ] <NEWLINE> mod = 1000000007 <COMMENT> <NEWLINE> inf = float ( <STRING> ) <COMMENT> <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def mi_0 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lmi_0 ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> def li ( ) : return list ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> def check_palindrome ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ n - 1 - i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def find_center ( s , cnt ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> n = len ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> if num == cnt : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find_center_even ( s , cnt ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> n = len ( s ) <NEWLINE> left , right = - 1 , - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> if num == cnt : <NEWLINE> <INDENT> if left == - 1 : <NEWLINE> <INDENT> left = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if num == cnt + 1 : <NEWLINE> <INDENT> right = i <NEWLINE> <COMMENT> <NL> return ( left + right ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def not_x_split ( s ) : <NEWLINE> <INDENT> buf = [ ] <NEWLINE> s += <STRING> <NEWLINE> n = len ( s ) <NEWLINE> x_cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> buf . append ( x_cnt ) <NEWLINE> x_cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return buf <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve ( s , buf ) : <NEWLINE> <INDENT> bufsize = len ( buf ) <NEWLINE> if bufsize % 2 == 0 : <NEWLINE> <INDENT> cnt = bufsize // 2 <NEWLINE> ind = find_center_even ( s , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = ( bufsize + 1 ) // 2 <NEWLINE> ind = find_center ( s , cnt ) <NEWLINE> <NL> <DEDENT> if ind % 1 == 0 : <NEWLINE> <INDENT> left_s = s [ : int ( ind ) ] [ : : - 1 ] <NEWLINE> right_s = s [ int ( ind ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_s = s [ : int ( ind ) + 1 ] [ : : - 1 ] <NEWLINE> right_s = s [ int ( ind ) + 1 : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> left = not_x_split ( left_s ) <NEWLINE> right = not_x_split ( right_s ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> assert len ( left ) == len ( right ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( left ) ) : <NEWLINE> <INDENT> ans += max ( left [ i ] , right [ i ] ) - min ( left [ i ] , right [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> s = input ( ) <NEWLINE> if check_palindrome ( s ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf = [ char for char in s if char != <STRING> ] <NEWLINE> if not check_palindrome ( buf ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( solve ( s , buf ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x2 = copy . copy ( x ) <NEWLINE> x2 . sort ( ) <NEWLINE> num1 , num2 = ( len ( x ) // 2 ) - 1 , ( len ( x ) // 2 ) <NEWLINE> med1 , med2 = x2 [ num1 ] , x2 [ num2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= med1 : <NEWLINE> <INDENT> print ( med2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( med1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> mini = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mini = min ( mini , P [ i ] ) <NEWLINE> if ( mini >= P [ i ] ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> a_len = len ( a ) <NEWLINE> b_len = len ( b ) <NEWLINE> <NL> huku = [ ] <NEWLINE> <NL> for i in range ( a_len ) : <NEWLINE> <INDENT> if a_len != b_len and i == a_len - 1 : <NEWLINE> <INDENT> huku . append ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> huku . append ( a [ i ] ) <NEWLINE> huku . append ( b [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( huku ) ) : <NEWLINE> <INDENT> print ( huku [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = Counter ( s ) <NEWLINE> <NL> <NL> if len ( num ) <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> cnt = len ( num ) - k <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> for v in sorted ( num . values ( ) ) : <NEWLINE> <INDENT> if cnt == i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += v <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> from collections import deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> <NL> def warshallfloyd ( cost , V ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> for k in range ( V ) : <NEWLINE> <INDENT> for i in range ( V ) : <NEWLINE> <INDENT> for j in range ( V ) : <NEWLINE> <INDENT> if cost [ i ] [ k ] != INF and cost [ k ] [ j ] != INF : <NEWLINE> <INDENT> cost [ i ] [ j ] = min ( cost [ i ] [ j ] , cost [ i ] [ k ] + cost [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in cost : <NEWLINE> <INDENT> if float ( <STRING> ) in i : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ float ( <STRING> ) for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab . append ( [ a - 1 , b - 1 ] ) <NEWLINE> edge [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> edge [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> tmp = deepcopy ( edge ) <NEWLINE> tmp [ a ] [ b ] = float ( <STRING> ) <NEWLINE> tmp [ b ] [ a ] = float ( <STRING> ) <NEWLINE> if not warshallfloyd ( tmp , N ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , itertools , bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> process = [ ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> tmp = A . pop ( ) <NEWLINE> y = A . pop ( ) <NEWLINE> A . append ( tmp ) <NEWLINE> if y >= 0 : <NEWLINE> <INDENT> process . append ( [ A [ 0 ] , y ] ) <NEWLINE> A [ 0 ] -= y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> process . append ( [ A [ - 1 ] , y ] ) <NEWLINE> A [ - 1 ] -= y <NEWLINE> <DEDENT> <DEDENT> process . append ( [ A [ - 1 ] , A [ 0 ] ] ) <NEWLINE> print ( A [ - 1 ] - A [ 0 ] ) <NEWLINE> for pro in process : <NEWLINE> <INDENT> print ( * pro ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> def solve1 ( N , K , heights ) : <NEWLINE> <INDENT> heights += [ INF ] * K <NEWLINE> costs = [ INF ] * ( N + K ) <NEWLINE> costs [ 0 ] = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> newcost = costs [ i ] + abs ( heights [ i + k ] - heights [ i ] ) <NEWLINE> if newcost < costs [ i + k ] : <NEWLINE> <INDENT> costs [ i + k ] = newcost <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return costs [ N - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , K , heights ) : <NEWLINE> <INDENT> costs = [ 0 ] * N <NEWLINE> costs [ 0 ] = 0 <NEWLINE> costs [ 1 ] = abs ( heights [ 1 ] - heights [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> costs [ i ] = min ( <NEWLINE> <INDENT> costs [ j ] + abs ( heights [ i ] - heights [ j ] ) <NEWLINE> for j in range ( max ( i - K , 0 ) , i ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> return costs [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def solve3 ( N , heights ) : <NEWLINE> <INDENT> costs = [ None ] * N <NEWLINE> costs [ 0 ] = 0 <NEWLINE> costs [ 1 ] = abs ( heights [ 1 ] - heights [ 0 ] ) <NEWLINE> <NL> def get_cost ( i ) : <NEWLINE> <INDENT> if costs [ i ] != None : <NEWLINE> <INDENT> return costs [ i ] <NEWLINE> <NL> <DEDENT> c = min ( <NEWLINE> <INDENT> get_cost ( i - 2 ) + abs ( heights [ i ] - heights [ i - 2 ] ) , <NEWLINE> get_cost ( i - 1 ) + abs ( heights [ i ] - heights <NEWLINE> <INDENT> [ i - 1 ] ) , <NEWLINE> <DEDENT> <DEDENT> ) <NEWLINE> costs [ i ] = c <NEWLINE> return c <NEWLINE> <NL> <DEDENT> return get_cost ( N - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( N , K , heights ) ) <NEWLINE> <NL> <NL> <DEDENT> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> black = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if black > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> black -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = sum ( p [ 0 : k ] ) <NEWLINE> ans = num <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> num = num - p [ i ] + p [ i + k ] <NEWLINE> ans = max ( ans , num ) <NEWLINE> <DEDENT> print ( ( ans + k ) / 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sum ( b ) <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> f = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> d = d + b [ i ] <NEWLINE> if d >= c / 2 : <NEWLINE> <INDENT> e = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( e ) : <NEWLINE> <INDENT> f = f + b [ i ] <NEWLINE> <DEDENT> if abs ( d - ( c - d ) ) < abs ( f - ( c - f ) ) : <NEWLINE> <INDENT> print ( abs ( d - ( c - d ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( f - ( c - f ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> count = 0 <NEWLINE> <NL> min_a = N + 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == min ( min_a , a ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> min_a = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
numbers = input ( ) <NEWLINE> <NL> if numbers [ 1 ] == numbers [ 2 ] : <NEWLINE> <INDENT> if numbers . count ( numbers [ 1 ] ) >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z <= k and z >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> import numpy as np <NEWLINE> from functools import partial <NEWLINE> array = partial ( np . array , dtype = np . int64 ) <NEWLINE> zeros = partial ( np . zeros , dtype = np . int64 ) <NEWLINE> full = partial ( np . full , dtype = np . int64 ) <NEWLINE> <NL> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def exit ( * argv , ** kwarg ) : <NEWLINE> <INDENT> print ( * argv , ** kwarg ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def mina ( * argv , sub = 1 ) : return list ( map ( lambda x : x - sub , argv ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> <NL> def ints ( ) : return np . fromstring ( readline ( ) , sep = <STRING> , dtype = np . int64 ) <NEWLINE> <NL> <NL> def read_matrix ( H , W ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lines = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> lines . append ( read ( ) ) <NEWLINE> <DEDENT> lines = <STRING> . join ( lines ) <COMMENT> <NEWLINE> return np . fromstring ( lines , sep = <STRING> , dtype = np . int64 ) . reshape ( H , W ) <NEWLINE> <NL> <NL> <DEDENT> def read_col ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( list ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return tuple ( map ( list , zip ( * ret ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_tuple ( H ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> ret . append ( tuple ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> INF = 2 ** 31 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> from collections import defaultdict , Counter , deque <NEWLINE> from operator import itemgetter , xor , add <NEWLINE> from itertools import product , permutations , combinations <NEWLINE> from bisect import bisect_left , bisect_right <COMMENT> <NEWLINE> from functools import reduce , lru_cache <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <COMMENT> <NL> <INDENT> g = gcd ( a , b ) <NEWLINE> return a // g * b <NEWLINE> <NL> <NL> <DEDENT> N = a_int ( ) <NEWLINE> A = ints ( ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> <STRING> <NEWLINE> <NL> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1.0 ) <NEWLINE> dp [ 0 , 0 , 0 ] = 0 <NEWLINE> from numba import njit <NEWLINE> <COMMENT> <NL> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def dfs ( i , j , k , N , dp ) : <NEWLINE> <INDENT> if i < 0 or j < 0 or k < 0 or i == j == k == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ i , j , k ] != - 1 : <NEWLINE> <INDENT> return dp [ i , j , k ] <NEWLINE> <DEDENT> ret = 1 <NEWLINE> ret += i / N * dfs ( i - 1 , j , k , N , dp ) <NEWLINE> ret += j / N * dfs ( i + 1 , j - 1 , k , N , dp ) <NEWLINE> ret += k / N * dfs ( i , j + 1 , k - 1 , N , dp ) <NEWLINE> if ( i + j + k ) == 0 : <NEWLINE> <INDENT> dp [ i , j , k ] = ret <NEWLINE> return ret <NEWLINE> <DEDENT> dp [ i , j , k ] = N / ( i + j + k ) * ret <NEWLINE> return dp [ i , j , k ] <NEWLINE> <NL> <NL> <DEDENT> print ( dfs ( cnt [ 1 ] , cnt [ 2 ] , cnt [ 3 ] , N , dp ) ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> dp = [ INF ] * ( n + 5 ) <NEWLINE> dp [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> temp = [ dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( i - 1 , max ( 0 , i - k - 1 ) , - 1 ) ] <NEWLINE> dp [ i ] = min ( temp ) <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL>
from itertools import groupby <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> grouped = groupby ( s ) <NEWLINE> <NL> res = [ ] <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> res . append ( ( 1 , 0 ) ) <NEWLINE> <NL> <DEDENT> for l , v in grouped : <NEWLINE> <INDENT> res . append ( ( l , len ( list ( v ) ) ) ) <NEWLINE> <NL> <DEDENT> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> res . append ( ( 1 , 0 ) ) <NEWLINE> <NL> <DEDENT> now = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( min ( len ( res ) , 2 * k + 1 ) ) : <NEWLINE> <INDENT> now += res [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> ans = max ( ans , now ) <NEWLINE> <NL> for i in range ( 2 * k + 1 , len ( res ) , 2 ) : <NEWLINE> <INDENT> now -= res [ i - 2 * k - 1 ] [ 1 ] <NEWLINE> now -= res [ i - 2 * k ] [ 1 ] <NEWLINE> <NL> now += res [ i ] [ 1 ] <NEWLINE> now += res [ i + 1 ] [ 1 ] <NEWLINE> <NL> ans = max ( ans , now ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> h = s - i - j <NEWLINE> if 0 <= h and h <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mx = 3503 <NEWLINE> found = False <NEWLINE> for i in range ( 1 , mx ) : <NEWLINE> <INDENT> for j in range ( 1 , mx ) : <NEWLINE> <INDENT> if i * j * 4 % N != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> den = ( ( i * j * 4 ) // N ) - i - j <NEWLINE> num = i * j <NEWLINE> if den == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num % den == 0 and num // den > 0 and num // den < mx : <NEWLINE> <INDENT> print ( i , j , num // den ) <NEWLINE> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if found : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from itertools import permutations as pe <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> ns = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ns . append ( str ( i ) ) <NEWLINE> <DEDENT> p = LISTS ( ) <NEWLINE> q = LISTS ( ) <NEWLINE> ct = 0 <NEWLINE> for v in pe ( ns , n ) : <NEWLINE> <INDENT> v = list ( v ) <NEWLINE> <COMMENT> <NL> ct += 1 <NEWLINE> if p == v : <NEWLINE> <INDENT> a = ct <NEWLINE> <DEDENT> if q == v : <NEWLINE> <INDENT> b = ct <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( a - b ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> <NL> def min2 ( x , y ) : return x if x <= y else y <NEWLINE> <NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> items = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> items . sort ( ) <NEWLINE> <NL> dp = [ INF ] * ( H + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for vi , wi in items : <NEWLINE> <INDENT> for j in range ( H - vi + 1 ) : <NEWLINE> <INDENT> dp [ j + vi ] = min2 ( dp [ j + vi ] , dp [ j ] + wi ) <NEWLINE> <DEDENT> for j in range ( max ( 0 , H - vi + 1 ) , H + 1 ) : <NEWLINE> <INDENT> dp [ H ] = min2 ( dp [ H ] , dp [ j ] + wi ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( dp [ H ] ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
from _collections import deque <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( h ) ] <NEWLINE> A = deque ( [ ] ) <NEWLINE> cnt = 1 <NEWLINE> <NL> def func ( X ) : <NEWLINE> <INDENT> global cnt <NEWLINE> ANS = [ ] <NEWLINE> c = X . count ( <STRING> ) <NEWLINE> a = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> ANS . append ( cnt ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a += 1 <NEWLINE> if a == c : <NEWLINE> <INDENT> for _ in range ( w - len ( ANS ) ) : <NEWLINE> <INDENT> ANS . append ( cnt - 1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A . append ( ANS ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if S [ i ] . count ( <STRING> ) == 0 and i != 0 and len ( A ) != 0 : <NEWLINE> <INDENT> A . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> elif S [ i ] . count ( <STRING> ) != 0 : <NEWLINE> <INDENT> func ( S [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( A ) != h : <NEWLINE> <INDENT> for _ in range ( h - len ( A ) ) : <NEWLINE> <INDENT> A . appendleft ( A [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in A : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> S = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> L = [ S [ 0 ] ] <NEWLINE> used = [ False ] * ( 1 << n ) <NEWLINE> used [ 0 ] = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L . sort ( reverse = True ) <NEWLINE> idx = 0 <NEWLINE> for j , s in enumerate ( S ) : <NEWLINE> <INDENT> if used [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if L [ idx ] > s : <NEWLINE> <INDENT> L . append ( s ) <NEWLINE> used [ j ] = True <NEWLINE> idx += 1 <NEWLINE> if idx == 1 << i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == i : <NEWLINE> <INDENT> if i + 1 < n : <NEWLINE> <INDENT> a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
from heapq import heappop , heappush <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> event = [ ] <NEWLINE> q = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S , T , X = map ( int , input ( ) . split ( ) ) <NEWLINE> event . append ( [ S - X , 1 , X ] ) <NEWLINE> event . append ( [ T - X , - 1 , X ] ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> event . append ( [ int ( input ( ) ) , 2 , i ] ) <NEWLINE> <NL> <DEDENT> stop_set = set ( ) <NEWLINE> event . sort ( ) <NEWLINE> q = [ ] <NEWLINE> <NL> for pos , m , x in event : <NEWLINE> <INDENT> if m == - 1 : <NEWLINE> <INDENT> stop_set . remove ( x ) <NEWLINE> <NL> <DEDENT> elif m == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> heappush ( q , x ) <NEWLINE> stop_set . add ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> while q : <NEWLINE> <COMMENT> <NL> <INDENT> if q [ 0 ] not in stop_set : <NEWLINE> <INDENT> heappop ( q ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q : <NEWLINE> <INDENT> print ( q [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> if tmp in dic : <NEWLINE> <INDENT> dic [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ tmp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in dic : <NEWLINE> <INDENT> dic [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ C ] = B <NEWLINE> <NL> <DEDENT> <DEDENT> dic = sorted ( dic . items ( ) , reverse = True ) <NEWLINE> <NL> ans , cnt = 0 , 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> k , v = dic [ i ] <NEWLINE> cnt += v <NEWLINE> if cnt < N : <NEWLINE> <INDENT> ans += k * v <NEWLINE> <DEDENT> elif cnt == N : <NEWLINE> <INDENT> ans += k * v <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += k * ( v - ( cnt - N ) ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> b_count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for pos in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ pos ] == <STRING> : <NEWLINE> <INDENT> b_count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b_count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ j ] - h [ i ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dp = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp += [ min ( [ dp [ - j ] + abs ( h [ i ] - h [ i - j ] ) for j in range ( 1 , min ( i , k ) + 1 ) ] ) ] <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ True ] * ( N + 1 ) <NEWLINE> D = [ 1 ] + [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> B [ a ] = False <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( N , i + 2 ) + 1 ) : <NEWLINE> <INDENT> if B [ j ] : <NEWLINE> <INDENT> D [ j ] = ( D [ j ] + D [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( D [ N ] ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> h . sort ( ) <NEWLINE> result = 10 ** 9 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> result = min ( result , h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = sum ( a ) <NEWLINE> sb = sum ( b ) <NEWLINE> counta = 0 <NEWLINE> countb = 0 <NEWLINE> for i , j in zip ( a , b ) : <NEWLINE> <INDENT> if j > i : <NEWLINE> <INDENT> if ( j - i ) % 2 : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> counta += ( j - i + 1 ) // 2 <NEWLINE> <DEDENT> elif i > j : <NEWLINE> <INDENT> countb += i - j <NEWLINE> <DEDENT> <DEDENT> if counta <= sb - sa and countb <= sb - sa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import heapq , bisect <NEWLINE> s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> L = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( n + 1 , i + 6 ) ) : <NEWLINE> <INDENT> L . add ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = list ( L ) <NEWLINE> L . sort ( ) <NEWLINE> print ( L [ K - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<NL> o = list ( input ( ) ) <NEWLINE> e = list ( input ( ) ) + [ <STRING> ] <NEWLINE> <NL> for x , y in zip ( o , e ) : print ( x + y , end = <STRING> ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if Y % 1000 != 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <NL> <DEDENT> n1 = Y // 10000 <NEWLINE> n2 = Y // 5000 <NEWLINE> <NL> for i in range ( n1 + 1 ) : <NEWLINE> <INDENT> for j in range ( n2 + 1 ) : <NEWLINE> <INDENT> if ( N - i - j ) < 0 : continue <NEWLINE> if i * 10000 + j * 5000 + ( N - i - j ) * 1000 == Y : <NEWLINE> <INDENT> print ( i , j , ( N - i - j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if Y < i * 10000 + j * 5000 + ( N - i - j ) * 1000 : break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
import string <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> flag = True <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in string . ascii_uppercase : <NEWLINE> <INDENT> if i == 1 or i == len ( s ) - 1 or s [ i ] != <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag and count == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> z = 10 ** 9 + 7 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x *= n <NEWLINE> x %= z <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums . sort ( ) <NEWLINE> cnt = nums [ N // 2 ] - nums [ N // 2 - 1 ] <NEWLINE> print ( cnt ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> P [ i + 1 ] *= P [ i ] * 2 <NEWLINE> P [ i + 1 ] %= MOD <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> l , r = i , N - i - 1 <NEWLINE> now = P [ r ] <NEWLINE> if r != 0 : <NEWLINE> <INDENT> now += P [ r - 1 ] * r <NEWLINE> <DEDENT> now *= P [ l ] <NEWLINE> now *= C [ i ] <NEWLINE> ans += now <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans *= P [ N ] <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a in dic : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> li = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for a in dic : <NEWLINE> <INDENT> li [ dic [ a ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> k = len ( dic ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if li [ i ] > 0 : <NEWLINE> <INDENT> if k - li [ i ] >= K : <NEWLINE> <INDENT> ans += i * li [ i ] <NEWLINE> k -= li [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i * ( k - K ) <NEWLINE> k -= li [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if k <= K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = ( N + 1 ) * [ 0 ] <NEWLINE> R = ( N + 1 ) * [ 0 ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> L [ n ] = gcd ( L [ n - 1 ] , A [ n ] ) <NEWLINE> <NL> <DEDENT> for n in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> R [ n ] = gcd ( R [ n + 1 ] , A [ n ] ) <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> ans += [ gcd ( L [ n - 1 ] , R [ n + 1 ] ) ] <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , T , A = map ( int , input ( ) . split ( ) ) ; INF = float ( <STRING> ) <NEWLINE> T -= 1 ; A -= 1 <COMMENT> <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <COMMENT> <NEWLINE> G [ a ] . append ( b ) ; G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> disT = [ INF for _ in range ( N ) ] ; disT [ T ] = 0 <NEWLINE> disA = [ INF for _ in range ( N ) ] ; disA [ A ] = 0 <NEWLINE> <NL> def dfs ( v , L ) : <NEWLINE> <INDENT> for u in G [ v ] : <NEWLINE> <INDENT> if L [ u ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L [ u ] = L [ v ] + 1 <NEWLINE> dfs ( u , L ) <NEWLINE> <DEDENT> <DEDENT> dfs ( T , disT ) <NEWLINE> dfs ( A , disA ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if disT [ i ] < disA [ i ] : <NEWLINE> <INDENT> ans = max ( ans , disA [ i ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> l = - ( - x // 105 ) <NEWLINE> h = x // 100 <NEWLINE> fix = l * 100 <NEWLINE> <NL> for b in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for c in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for d in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for e in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for f in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> if fix + 1 * b + 2 * c + 3 * d + 4 * e + 5 * f == x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = deque ( ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> seen = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> queue . append ( [ 0 , 0 ] ) <NEWLINE> ans = [ [ 1000000000 ] * w for _ in range ( h ) ] <NEWLINE> seen [ 0 ] [ 0 ] = True <NEWLINE> ans [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( h * w * 10 ) : <NEWLINE> <INDENT> if len ( queue ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = queue . popleft ( ) <NEWLINE> if cnt [ 0 ] != 0 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] == False and s [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] - 1 , cnt [ 1 ] ] ) <NEWLINE> ans [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] = True <NEWLINE> <DEDENT> <DEDENT> if cnt [ 1 ] != 0 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] == False and s [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] , cnt [ 1 ] - 1 ] ) <NEWLINE> ans [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> if cnt [ 0 ] != h - 1 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] == False and s [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] + 1 , cnt [ 1 ] ] ) <NEWLINE> ans [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] = True <NEWLINE> <DEDENT> <DEDENT> if cnt [ 1 ] != w - 1 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] == False and s [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] , cnt [ 1 ] + 1 ] ) <NEWLINE> ans [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt2 = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if seen [ - 1 ] [ - 1 ] == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt2 - ans [ - 1 ] [ - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( H [ 1 ] - H [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 2 ] + abs ( H [ i ] - H [ i - 2 ] ) , dp [ i - 1 ] + abs ( H [ i ] - H [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l = [ ( i + 1 ) / 2 for i in l ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> from itertools import accumulate <NEWLINE> cum = [ 0 ] + list ( accumulate ( l ) ) <NEWLINE> <NL> <COMMENT> <NL> sum_k = [ ] <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> sum_k . append ( cum [ k + j ] - cum [ j ] ) <NEWLINE> <NL> <DEDENT> print ( max ( sum_k ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> combo = False <NEWLINE> cnt = 0 <NEWLINE> ans = [ 0 , ] <NEWLINE> for mozi in s : <NEWLINE> <INDENT> if ( mozi == <STRING> or mozi == <STRING> or mozi == <STRING> or mozi == <STRING> ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> if combo != True : <NEWLINE> <INDENT> combo = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if combo : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> combo = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans . append ( cnt ) <NEWLINE> print ( max ( ans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans . append ( ab ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> l = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l += ans [ i ] [ 1 ] <NEWLINE> if l >= K : <NEWLINE> <INDENT> s = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans [ s ] [ 0 ] ) <NEWLINE>
import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> N = I ( ) <NEWLINE> s = [ <STRING> . join ( sorted ( S ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in c . keys ( ) : <NEWLINE> <INDENT> ans += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = lcm ( c , d ) <NEWLINE> <NL> total = b - ( a - 1 ) <NEWLINE> cc = b // c - ( a - 1 ) // c <NEWLINE> dd = b // d - ( a - 1 ) // d <NEWLINE> ee = b // e - ( a - 1 ) // e <NEWLINE> <NL> ans = total - cc - dd + ee <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> a -= 1 <NEWLINE> b -= 1 <NEWLINE> wide = 100 <NEWLINE> <NL> ans1 = [ [ <STRING> ] * wide for i in range ( wide // 2 ) ] <NEWLINE> <NL> ans2 = [ [ <STRING> ] * wide for i in range ( wide // 2 ) ] <NEWLINE> <NL> index_x = 0 <NEWLINE> index_y = 0 <NEWLINE> while ( a > 0 ) : <NEWLINE> <INDENT> ans1 [ index_y ] [ index_x ] = <STRING> <NEWLINE> index_x += 2 <NEWLINE> if index_x == wide : <NEWLINE> <INDENT> index_x = 0 <NEWLINE> index_y += 2 <NEWLINE> <DEDENT> a -= 1 <NEWLINE> <NL> <NL> <DEDENT> index_x = 0 <NEWLINE> index_y = 1 <NEWLINE> a = b <NEWLINE> while ( a > 0 ) : <NEWLINE> <INDENT> ans2 [ index_y ] [ index_x ] = <STRING> <NEWLINE> index_x += 2 <NEWLINE> if index_x == wide : <NEWLINE> <INDENT> index_x = 0 <NEWLINE> index_y += 2 <NEWLINE> <DEDENT> a -= 1 <NEWLINE> <NL> <DEDENT> print ( 100 , 100 ) <NEWLINE> for i in ans1 + ans2 : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> rg = R * i + G * j <NEWLINE> <NL> if rg <= N : <NEWLINE> <INDENT> if ( N - rg ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> avg = round ( sum ( a ) / N ) <NEWLINE> sums = [ ] <NEWLINE> for i in range ( min ( a ) , avg + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> s += ( i - a [ j ] ) ** 2 <NEWLINE> <DEDENT> sums . append ( s ) <NEWLINE> <DEDENT> print ( min ( sums ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1e19 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> tate = W * i <COMMENT> <NEWLINE> <COMMENT> <NL> if i < H - 1 : <NEWLINE> <INDENT> mini = W * ( ( H - i ) // 2 ) <COMMENT> <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( tate , mini , H * W - mini - tate ) - min ( tate , mini , H * W - mini - tate ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mini = ( H - i ) * ( W // 2 ) <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( tate , mini , H * W - tate - mini ) - min ( tate , mini , H * W - tate - mini ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , W ) : <NEWLINE> <INDENT> yoko = H * i <NEWLINE> if i < W - 1 : <NEWLINE> <INDENT> mini = H * ( ( W - i ) // 2 ) <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( yoko , mini , H * W - mini - yoko ) - min ( yoko , mini , H * W - yoko - mini ) ) <NEWLINE> <DEDENT> mini = ( W - i ) * ( H // 2 ) <NEWLINE> <COMMENT> <NL> ans = min ( ans , max ( yoko , mini , H * W - yoko - mini ) - min ( yoko , mini , H * W - yoko - mini ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CB = [ None ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> CB [ i ] = ( c , b ) <NEWLINE> <DEDENT> CB . sort ( reverse = True ) <NEWLINE> <NL> i = 0 <NEWLINE> ans = 0 <NEWLINE> for c , b in CB : <NEWLINE> <INDENT> x = bisect . bisect_left ( A , c , i ) <NEWLINE> count = min ( x - i , b ) <NEWLINE> ans += c * count <NEWLINE> i += count <NEWLINE> <DEDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> ans += A [ j ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == n - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 2 * ( n - m - 1 ) > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> e = [ [ ] for i in range ( n ) ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ x ] . append ( y ) <NEWLINE> e [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> def dfs ( x ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> d [ x ] = 1 <NEWLINE> l . append ( a [ x ] ) <NEWLINE> q = deque ( [ ] ) <NEWLINE> q . append ( x ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . pop ( ) <NEWLINE> for nex in e [ now ] : <NEWLINE> <INDENT> if d [ nex ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . append ( a [ nex ] ) <NEWLINE> d [ nex ] = 1 <NEWLINE> q . append ( nex ) <NEWLINE> <DEDENT> <DEDENT> l . sort ( ) <NEWLINE> ans = l [ 0 ] <NEWLINE> <NL> for i in l [ 1 : ] : <NEWLINE> <INDENT> h . append ( i ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> count = 2 * ( n - m - 1 ) <NEWLINE> d = [ - 1 ] * n <NEWLINE> ans = 0 <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] < 0 : <NEWLINE> <INDENT> ans += dfs ( i ) <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> h . sort ( ) <NEWLINE> ans += sum ( h [ : count ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> S_cnt = sorted ( S . count ( c ) for c in set ( S ) ) <NEWLINE> T_cnt = sorted ( T . count ( c ) for c in set ( T ) ) <NEWLINE> print ( <STRING> ) if S_cnt == T_cnt else print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i - 1 ] == <STRING> and S [ i - 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <STRING> <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> def solve ( N , h ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while ( np . any ( h > 0 ) ) : <NEWLINE> <INDENT> w = np . where ( h > 0 ) [ 0 ] <NEWLINE> l = w [ 0 ] <NEWLINE> r = w [ 0 ] <NEWLINE> i = 1 <NEWLINE> while ( i < len ( w ) ) : <NEWLINE> <INDENT> if ( w [ i ] == r + 1 ) : <NEWLINE> <INDENT> r = w [ i ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> h = np . concatenate ( [ h [ : l ] , h [ l : r + 1 ] - 1 , h [ r + 1 : ] ] ) <NEWLINE> s += 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> print ( solve ( N , h ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> def fact ( n , p ) : <NEWLINE> <INDENT> a = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> a [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] = ( a [ i ] * ( i + 1 ) ) % p <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> f = fact ( n , p ) <NEWLINE> invf = [ ] <NEWLINE> for i in f : <NEWLINE> <INDENT> invf . append ( pow ( i , - 1 , p ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i > n - k + 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> ans . append ( ( ( f [ n - k + 1 ] * invf [ n - k + 1 - i ] ) % p ) * ( ( invf [ i ] * f [ k - 1 ] ) % p ) * ( ( invf [ i - 1 ] * invf [ k - i ] ) ) % p ) <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i % p ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( readline ( ) . rstrip ( ) ) <NEWLINE> ans = x // 100 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> sur = x - ans * 100 <NEWLINE> print ( 1 if sur / ans <= 5 else 0 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s = sorted ( s ) <NEWLINE> t = sorted ( t ) [ : : - 1 ] <NEWLINE> <NL> answer = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == len ( t ) : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> s_c = s [ i ] <NEWLINE> t_c = t [ i ] <NEWLINE> if s_c < t_c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s_c == t_c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if s == t : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = 1 <NEWLINE> rm = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = max ( la , a ) <NEWLINE> rm = min ( rm , b ) <NEWLINE> <DEDENT> print ( max ( 0 , rm - la + 1 ) ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> r = [ ] <NEWLINE> for right in range ( 0 , n ) : <NEWLINE> <INDENT> for left in range ( right + 1 , right + k + 1 ) : <NEWLINE> <INDENT> r . append ( s [ right : left ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( set ( r ) ) [ k - 1 ] ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> <NL> a = ( 2 * x - y ) / 3 <NEWLINE> b = ( 2 * y - x ) / 3 <NEWLINE> if not ( a . is_integer ( ) and b . is_integer ( ) ) or 2 * x < y or 2 * y < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> from functools import reduce <NEWLINE> def mycmb ( n , r , p ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> over = reduce ( lambda x , y : x * y % p , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( lambda x , y : x * y % p , range ( 1 , r + 1 ) ) <NEWLINE> return ( over * pow ( under , p - 2 , p ) ) % p <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( mycmb ( a + b , a , mod ) ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> x = bisect_left ( L , L [ a ] + L [ b ] , lo = b ) <NEWLINE> ans += ( x - 1 - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = [ None ] + [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p_to_i = [ None ] * ( N + 1 ) <NEWLINE> for i , x in enumerate ( P [ 1 : ] , 1 ) : <NEWLINE> <INDENT> p_to_i [ x ] = i <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def BIT_add ( i ) : <NEWLINE> <INDENT> while i <= N : <NEWLINE> <INDENT> tree [ i ] += 1 <NEWLINE> i += i & ( - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def BIT_sum ( i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i : <NEWLINE> <INDENT> s += tree [ i ] <NEWLINE> i -= i & ( - i ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def BIT_search ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> s = 0 <NEWLINE> step = 1 << ( N . bit_length ( ) - 1 ) <NEWLINE> while step : <NEWLINE> <INDENT> if i + step <= N and s + tree [ i + step ] < x : <NEWLINE> <INDENT> i += step <NEWLINE> s += tree [ i ] <NEWLINE> <DEDENT> step >>= 1 <NEWLINE> <DEDENT> return i + 1 <NEWLINE> left = 0 <NEWLINE> right = N <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if BIT_sum ( mid ) >= x : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> return right <NEWLINE> <NL> <DEDENT> tree = [ 0 ] * ( N + 1 ) <NEWLINE> answer = 0 <NEWLINE> for x in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> c = p_to_i [ x ] <NEWLINE> L = BIT_sum ( c ) <COMMENT> <NEWLINE> BIT_add ( c ) <NEWLINE> R = N - x - L <COMMENT> <NEWLINE> a = BIT_search ( L - 1 ) if L >= 2 else 0 <NEWLINE> b = BIT_search ( L ) if L >= 1 else 0 <NEWLINE> d = BIT_search ( L + 2 ) if R >= 1 else N + 1 <NEWLINE> e = BIT_search ( L + 3 ) if R >= 2 else N + 1 <NEWLINE> coef = 0 <NEWLINE> if b != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> coef += ( b - a ) * ( d - c ) <NEWLINE> <DEDENT> if d != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> coef += ( e - d ) * ( c - b ) <NEWLINE> <DEDENT> answer += x * coef <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> C = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> MAX_C = 2 * 10 ** 5 <NEWLINE> C = [ - 1 ] + C <NEWLINE> D = [ - 1 ] * ( MAX_C + 1 ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i + 1 ] == C [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = D [ C [ i + 1 ] ] <NEWLINE> if j != - 1 : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + dp [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> <DEDENT> dp [ i + 1 ] %= P <NEWLINE> D [ C [ i + 1 ] ] = i + 1 <NEWLINE> <NL> <DEDENT> ans = dp [ N ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10010010 ) <NEWLINE> <NL> def abc106_d ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> table [ l ] [ r ] += 1 <NEWLINE> <DEDENT> query = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> dp = [ [ - 1 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> <NL> def calc ( l , r ) : <NEWLINE> <INDENT> nonlocal dp <NEWLINE> if l == 0 or r == 0 : return 0 <NEWLINE> if dp [ l ] [ r ] != - 1 : return dp [ l ] [ r ] <NEWLINE> res = calc ( l - 1 , r ) + calc ( l , r - 1 ) - calc ( l - 1 , r - 1 ) + table [ l ] [ r ] <NEWLINE> dp [ l ] [ r ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for p , q in query : <NEWLINE> <INDENT> ans = calc ( q , q ) - calc ( q , p - 1 ) - calc ( p - 1 , q ) + calc ( p - 1 , p - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc106_d ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ i + 1 ] = cnt [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cnt [ r - 1 ] - cnt [ l - 1 ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ r - 1 ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D . sort ( ) <NEWLINE> <NL> M = N // 2 <NEWLINE> ans = D [ M ] - D [ M - 1 ] <NEWLINE> <NL> if D [ M ] == D [ M - 1 ] : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> vertices = { i : [ ] for i in range ( n ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> vertices [ l - 1 ] . append ( ( r - 1 , d ) ) <NEWLINE> vertices [ r - 1 ] . append ( ( l - 1 , - d ) ) <NEWLINE> <NL> <NL> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> x = [ None ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x [ i ] = 0 <NEWLINE> queue = [ i ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> i0 = queue . pop ( ) <NEWLINE> for i1 , d in vertices [ i0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> if x [ i1 ] is None : <NEWLINE> <INDENT> x [ i1 ] = x [ i0 ] + d <NEWLINE> queue . append ( i1 ) <NEWLINE> <DEDENT> elif x [ i1 ] != x [ i0 ] + d : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> if answer ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a -= k <NEWLINE> if a <= - 1 : <NEWLINE> <INDENT> p = abs ( a ) <NEWLINE> a = 0 <NEWLINE> b -= p <NEWLINE> if b <= - 1 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b >= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c - b <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans_list = [ 0 ] <NEWLINE> e_cnt = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> e_cnt += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt -= 0 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 0 <NEWLINE> e_cnt += 1 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans_list . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( ans_list ) + e_cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> a [ k ] //= 2 <NEWLINE> <NL> <DEDENT> foo = 1 <NEWLINE> while a [ 0 ] % 2 == 0 : <NEWLINE> <INDENT> foo *= 2 <NEWLINE> a [ 0 ] //= 2 <NEWLINE> <DEDENT> for k in range ( 1 , N ) : <NEWLINE> <INDENT> if a [ k ] % foo == 0 and a [ k ] % ( 2 * foo ) != 0 : <NEWLINE> <INDENT> a [ k ] //= foo <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> import math <NEWLINE> lcm = a . pop ( ) <NEWLINE> for k in range ( 1 , N ) : <NEWLINE> <INDENT> b = a . pop ( ) <NEWLINE> lcm = lcm * b // math . gcd ( lcm , b ) <NEWLINE> if lcm * foo > M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> lcm *= foo <NEWLINE> ans = int ( ( M / lcm - 1 ) // 2 + 1 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> ans += h [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def comb ( n , r , mod ) : <NEWLINE> <INDENT> return math . factorial ( n + r - 1 ) // ( math . factorial ( n - 1 ) * math . factorial ( r ) ) % mod <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> red = n - k <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> redmod = red - i <NEWLINE> if redmod < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> redplace = 2 + i <NEWLINE> bluemod = k - ( i + 1 ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> bluemod = 0 <NEWLINE> <DEDENT> blueplace = i + 1 <NEWLINE> ans += comb ( redplace , redmod , mod ) * comb ( blueplace , bluemod , mod ) <NEWLINE> print ( ans % mod ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> if n < 3 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) and ( s [ i + 1 ] == <STRING> ) and ( s [ i + 2 ] == <STRING> ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if p == sorted ( p ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> is_sorted = False <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p [ i ] < p [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = p . copy ( ) <NEWLINE> k [ i ] , k [ j ] = k [ j ] , k [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if k == sorted ( p ) : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> is_sorted = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_sorted : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2019 <NEWLINE> for i in range ( l , min ( l + 2019 , r ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( l + 2020 , r + 1 ) ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> data [ b - 1 ] += 1 <NEWLINE> if data [ b - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if b == n : <NEWLINE> <INDENT> data [ a - 1 ] += 1 <NEWLINE> if data [ a - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> min_p = n <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> if i <= min_p : <NEWLINE> <INDENT> min_p = i <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while j < N and S [ i : j ] in S [ j : ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> ans = max ( ans , j - i - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> finput = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> p = 10 ** 9 + 7 <NEWLINE> n = int ( finput ( ) ) <NEWLINE> a = list ( map ( int , finput ( ) . split ( ) ) ) <NEWLINE> k = sum ( a ) - ( n * ( n + 1 ) ) // 2 <NEWLINE> pk = [ i for i in range ( n + 1 ) if a [ i ] == k ] <NEWLINE> fact = [ 1 ] * ( n + 2 ) <NEWLINE> ifact = [ 1 ] * ( n + 2 ) <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % p <NEWLINE> <DEDENT> a = fact [ - 1 ] <NEWLINE> inv = 1 <NEWLINE> m = p - 2 <NEWLINE> while m > 0 : <NEWLINE> <INDENT> if m & 1 : <NEWLINE> <INDENT> inv = a * inv % p <NEWLINE> <DEDENT> m >>= 1 <NEWLINE> a = a * a % p <NEWLINE> <DEDENT> ifact [ - 1 ] = inv <NEWLINE> for i in range ( n + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> ifact [ i - 1 ] = ifact [ i ] * i % p <NEWLINE> <DEDENT> ans0 = [ 0 ] * ( n + 2 ) <NEWLINE> ans1 = [ 0 ] * ( n + 2 ) <NEWLINE> ans2 = [ 0 ] * ( n + 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans0 [ i ] = fact [ n - 1 ] * ifact [ n - i - 1 ] * ifact [ i ] % p <NEWLINE> ans1 [ i + 1 ] = ans0 [ i ] * 2 <NEWLINE> ans2 [ i + 2 ] = ans0 [ i ] <NEWLINE> <DEDENT> sn = pk [ 0 ] + n - pk [ 1 ] <NEWLINE> for i in range ( sn + 1 ) : <NEWLINE> <INDENT> ans1 [ i + 1 ] -= fact [ sn ] * ifact [ sn - i ] * ifact [ i ] % p <NEWLINE> <DEDENT> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> print ( ( ans0 [ i ] + ans1 [ i ] + ans2 [ i ] ) % p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ [ ] for _ in range ( n ) ] <NEWLINE> vals = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a - 1 ] . append ( b - 1 ) <NEWLINE> route [ b - 1 ] . append ( a - 1 ) <NEWLINE> vals . append ( [ a - 1 , b - 1 ] ) <NEWLINE> <DEDENT> ans = m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> route2 = set ( ) <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> route [ vals [ i ] [ 0 ] ] . remove ( vals [ i ] [ 1 ] ) <NEWLINE> route [ vals [ i ] [ 1 ] ] . remove ( vals [ i ] [ 0 ] ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> a = q . get ( ) <NEWLINE> if not a in route2 : <NEWLINE> <INDENT> route2 . add ( a ) <NEWLINE> for j in route [ a ] : <NEWLINE> <INDENT> q . put ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( route2 ) == n : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> route [ vals [ i ] [ 0 ] ] . append ( vals [ i ] [ 1 ] ) <NEWLINE> route [ vals [ i ] [ 1 ] ] . append ( vals [ i ] [ 0 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = 10 ** 10 <NEWLINE> h . sort ( ) <NEWLINE> <NL> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> res = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
import bisect <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> for i in b : <NEWLINE> <INDENT> s = bisect . bisect_right ( c , i ) <NEWLINE> s_num = n - s <NEWLINE> <NL> t = bisect . bisect_left ( a , i ) <NEWLINE> t_num = t <NEWLINE> <NL> ans += s_num * t_num <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> e , w = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w [ i ] += w [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> e [ i ] += e [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> ans = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , w [ i ] + e [ - 1 ] - e [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( g * 10 + b ) % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
R = int ( input ( ) ) <NEWLINE> if R < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif R < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if z >= 0 and z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> sum = l [ i ] + l [ j ] <NEWLINE> index = bisect . bisect_left ( l , sum ) <NEWLINE> cnt += index - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n = readInt ( ) <NEWLINE> a = readInts ( ) <NEWLINE> rate = [ 0 ] * 9 <NEWLINE> <NL> <NL> for i in a : <NEWLINE> <INDENT> rate [ min ( i // 400 , 8 ) ] += 1 <NEWLINE> <DEDENT> base = 8 - rate [ : - 1 ] . count ( 0 ) <NEWLINE> ma = base + rate [ - 1 ] <NEWLINE> print ( max ( base , 1 ) , ma ) <NEWLINE>
import sys <NEWLINE> a = sys . stdin . readline ( ) <NEWLINE> A = int ( a ) <NEWLINE> P = 1 <NEWLINE> I = 1 <NEWLINE> W = 10 ** 9 + 7 <NEWLINE> while I <= A : <NEWLINE> <INDENT> P *= I <NEWLINE> I += 1 <NEWLINE> P %= W <NEWLINE> <DEDENT> print ( P ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = [ 0 ] * 10 ** 5 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( a , b + 1 ) : <NEWLINE> <INDENT> c [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( c ) ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x - a ) < abs ( x - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = A , B , C <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( A % 2 == 0 and B % 2 == 0 and C % 2 == 0 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> a , b , c = A , B , C <NEWLINE> A = ( b + c ) / 2 <NEWLINE> B = ( c + a ) / 2 <NEWLINE> C = ( a + b ) / 2 <NEWLINE> <COMMENT> <NL> if ( A == a and B == b and C == c ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> if ( A == a and B == b and C == c ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ [ c == <STRING> for c in input ( ) ] for _ in range ( H ) ] <NEWLINE> field = np . array ( field , dtype = np . int16 ) <NEWLINE> <NL> u = field . copy ( ) <NEWLINE> d = field . copy ( ) <NEWLINE> l = field . copy ( ) <NEWLINE> r = field . copy ( ) <NEWLINE> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * u [ i ] <NEWLINE> d [ - i - 1 ] = ( d [ - i ] + 1 ) * d [ - i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> l [ : , j ] = ( l [ : , j - 1 ] + 1 ) * l [ : , j ] <NEWLINE> r [ : , - j - 1 ] = ( r [ : , - j ] + 1 ) * r [ : , - j - 1 ] <NEWLINE> <NL> <DEDENT> print ( ( u + d + l + r - 3 ) . max ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> size [ y ] = size [ x ] + size [ y ] <NEWLINE> size [ x ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> Ans = 0 <NEWLINE> for j in size [ 1 : ] : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> Ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
<COMMENT> <NL> def bipartite_graph_check ( n , edge ) : <NEWLINE> <INDENT> color = [ - 1 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack = [ i ] <NEWLINE> color [ i ] = 0 <NEWLINE> for node in stack : <NEWLINE> <INDENT> for mode in edge [ node ] : <NEWLINE> <INDENT> if color [ mode ] == - 1 : <NEWLINE> <INDENT> stack . append ( mode ) <NEWLINE> color [ mode ] = color [ node ] ^ 1 <NEWLINE> <DEDENT> elif color [ mode ] == color [ node ] : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return color <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <DEDENT> if bipartite_graph_check ( n , edge ) : <NEWLINE> <INDENT> color = bipartite_graph_check ( n , edge ) <NEWLINE> print ( color . count ( 0 ) * color . count ( 1 ) - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 1 ) // 2 - m ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , D , A = MAP ( ) <NEWLINE> XH = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> XH . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> X , H = zip ( * XH ) <NEWLINE> right = [ 0 ] * N <NEWLINE> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> right [ i ] = bisect ( X , x + 2 * D ) <NEWLINE> <NL> <DEDENT> damage = [ 0 ] * ( N + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , ( X , H ) in enumerate ( XH ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> damage [ i ] += damage [ i - 1 ] <NEWLINE> <DEDENT> H -= damage [ i ] <NEWLINE> if 0 < H : <NEWLINE> <INDENT> n = - ( - H // A ) <NEWLINE> ans += n <NEWLINE> d = A * n <NEWLINE> damage [ i ] += d <NEWLINE> damage [ right [ i ] ] -= d <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> ans += max ( 0 , 0 <= s - x - y <= k ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> ans += bisect . bisect_left ( A , i ) * ( N - bisect . bisect_right ( C , i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> g = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> g [ i ] = [ int ( s == <STRING> ) for s in input ( ) ] <NEWLINE> <NL> <DEDENT> L = g . copy ( ) <NEWLINE> R = g . copy ( ) <NEWLINE> U = g . copy ( ) <NEWLINE> D = g . copy ( ) <NEWLINE> <NL> for i in range ( 1 , h ) : <NEWLINE> <INDENT> U [ i ] = ( U [ i - 1 ] + 1 ) * g [ i ] <NEWLINE> D [ ~ i ] = ( D [ ~ i + 1 ] + 1 ) * g [ ~ i ] <NEWLINE> <DEDENT> for j in range ( 1 , w ) : <NEWLINE> <INDENT> L [ : , j ] = ( L [ : , j - 1 ] + 1 ) * g [ : , j ] <NEWLINE> R [ : , ~ j ] = ( R [ : , ~ j + 1 ] + 1 ) * g [ : , ~ j ] <NEWLINE> <NL> <DEDENT> ans = np . max ( L + R + U + D - 3 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> s1 = 0 <NEWLINE> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> s1 += a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ s - s1 * 2 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans . append ( ( a [ i - 1 ] - ans [ i - 1 ] // 2 ) * 2 ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 1 in a and 2 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif 1 in a : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = 1 <NEWLINE> <DEDENT> elif 2 in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] % MOD ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if ( S - K ) <= ( i + j ) <= S : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ti = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> <NL> def euc_alg ( val1 , val2 ) : <NEWLINE> <NL> <INDENT> if val1 == val2 : <NEWLINE> <INDENT> return val1 <NEWLINE> <NL> <DEDENT> mod = min ( val1 , val2 ) <NEWLINE> divided = max ( val1 , val2 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> tmp_mod = divided % mod <NEWLINE> <NL> if tmp_mod == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> divided = mod <NEWLINE> mod = tmp_mod <NEWLINE> <NL> <DEDENT> ret = val1 * val2 // mod <NEWLINE> <NL> return ret <NEWLINE> <NL> <DEDENT> maxti = max ( ti ) <NEWLINE> <COMMENT> <NL> <NL> ans = ti [ 0 ] <NEWLINE> for t in ti : <NEWLINE> <INDENT> ans = euc_alg ( ans , t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> N = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Ncum = N . cumsum ( ) <NEWLINE> L = Ncum [ : - 1 ] <NEWLINE> R = Ncum [ - 1 ] - L <NEWLINE> ans = np . abs ( L - R ) . min ( ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> l = [ 0 ] * ( N + 1 ) <NEWLINE> l [ 0 ] = 1 <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if j < M and i == a [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> l [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = ( l [ i - 1 ] + l [ i - 2 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( l [ N ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 2 and m > 2 : <NEWLINE> <INDENT> ans = ( n - 2 ) * ( m - 2 ) <NEWLINE> <DEDENT> elif n == 2 or m == 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif n == 1 and m == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> ans = m - 2 <NEWLINE> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> ans = n - 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> A . append ( tmp ) <NEWLINE> <NL> <DEDENT> B = copy . copy ( A ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> max_val = max ( B ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == max_val : <NEWLINE> <INDENT> print ( B [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ N - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> values = list ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> values . append ( int ( lines [ i ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> su = 0 <NEWLINE> amaris = list ( ) <NEWLINE> <NL> for value in values : <NEWLINE> <INDENT> amari = value % 10 <NEWLINE> if amari > 0 : <NEWLINE> <INDENT> amaris . append ( 10 - amari ) <NEWLINE> <NL> <DEDENT> <DEDENT> if amaris == [ ] : <NEWLINE> <INDENT> result = sum ( values ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = sum ( values ) + sum ( amaris ) - max ( amaris ) <NEWLINE> <NL> <DEDENT> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 215 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 481 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 643 ] <NEWLINE> <DEDENT> if pattern == - 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 50 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <DEDENT> if FLAG_LOG : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> if lines_result == lines_export : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> finished = time . time ( ) <NEWLINE> duration = finished - started <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> dp = np . full ( n , INF , np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i , e in enumerate ( h [ 1 : ] , 1 ) : <NEWLINE> <INDENT> lb = max ( 0 , i - k ) <NEWLINE> dp [ i ] = np . min ( dp [ lb : i ] + np . abs ( h [ lb : i ] - e ) ) <NEWLINE> <NL> <DEDENT> ans = dp [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def iif ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def lmif ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def ss ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> mod = 1000000007 <NEWLINE> <NL> F = [ 1 , 1 ] <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> F . append ( F [ i ] + F [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> N , M = mi ( ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( F [ N ] % mod ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> A = iif ( M ) <NEWLINE> DA = [ ] <NEWLINE> left = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> da = A [ i ] - left <NEWLINE> if da == 0 and left != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DA . append ( da - 1 ) <NEWLINE> <DEDENT> left = A [ i ] + 1 <NEWLINE> <DEDENT> if A [ - 1 ] != N : <NEWLINE> <INDENT> DA . append ( N - A [ - 1 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for i in DA : <NEWLINE> <INDENT> ans *= F [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> N = 10 <NEWLINE> ARR = [ 3 , 1 , 4 , 1 , 5 , 9 , 2 , 6 , 5 , 3 ] <NEWLINE> <NL> N = 10 <NEWLINE> ARR = [ 3 , 14 , 159 , 2653 , 58979 , 323846 , 2643383 , 27950288 , 419716939 , 9375105820 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> if max ( arr ) == 0 : <NEWLINE> <INDENT> mathNum = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mathNum = math . ceil ( math . log ( max ( arr ) , 2 ) ) <NEWLINE> <NL> <DEDENT> oneArray = [ 0 ] * mathNum <NEWLINE> zeroArray = [ 0 ] * mathNum <NEWLINE> <NL> result = 0 <NEWLINE> arr = np . array ( arr ) <NEWLINE> for i in range ( mathNum ) : <NEWLINE> <INDENT> s = ( arr >> i ) & 1 <NEWLINE> <NL> oneCount = np . count_nonzero ( s ) <NEWLINE> zeroCount = n - oneCount <NEWLINE> oneArray [ i ] = oneCount <NEWLINE> zeroArray [ i ] = zeroCount <NEWLINE> <NL> <DEDENT> for i in range ( mathNum ) : <NEWLINE> <INDENT> result += ( 2 ** i ) * ( oneArray [ i ] * zeroArray [ i ] ) <NEWLINE> <NL> <DEDENT> print ( result % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , ARR ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> check = 0 <NEWLINE> NEW_x = [ ] <NEWLINE> <NL> def roop ( N , x ) : <NEWLINE> <INDENT> global check <NEWLINE> global NEW_x <NEWLINE> for i in x : <NEWLINE> <INDENT> s = i // 2 <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> check += 1 <NEWLINE> <NL> NEW_x . append ( s ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> NEW_x . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> roop ( N , x ) <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> x = NEW_x <NEWLINE> NEW_x = [ ] <NEWLINE> if check == N : <NEWLINE> <INDENT> check = 0 <NEWLINE> count += 1 <NEWLINE> roop ( N , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a = a * ( n + 1 ) % mod <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> k = 0 <NEWLINE> flg = False <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai == k + 1 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> <DEDENT> <DEDENT> if k == 0 and flg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - k ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_li . sort ( ) <NEWLINE> b_li . sort ( ) <NEWLINE> c_li . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in b_li : <NEWLINE> <INDENT> s = bisect . bisect_right ( c_li , i ) <NEWLINE> s_num = n - s <NEWLINE> <NL> t = bisect . bisect_left ( a_li , i ) <NEWLINE> t_num = t <NEWLINE> <NL> ans += s_num * t_num <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
D , G = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> score_table = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> p , c = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> score_table . append ( [ i * 100 , p , c ] ) <NEWLINE> <NL> <DEDENT> min_count = sum ( [ l [ 1 ] for l in score_table ] ) <NEWLINE> <COMMENT> <NL> <NL> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> score += score_table [ i ] [ 0 ] * score_table [ i ] [ 1 ] + score_table [ i ] [ 2 ] <NEWLINE> count += score_table [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> additional = [ ] <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if not bit & ( 1 << j ) : <NEWLINE> <INDENT> additional . append ( score_table [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> additional_ = sorted ( additional , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> add_score = additional_ [ 0 ] <NEWLINE> <NL> for k in range ( add_score [ 1 ] - 1 ) : <NEWLINE> <INDENT> score += add_score [ 0 ] <NEWLINE> count += 1 <NEWLINE> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min_count ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( Q ) ] <NEWLINE> <NL> p = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] > 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> d = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> d += ( ( x [ i ] [ 0 ] - x [ j ] [ 0 ] ) ** 2 + ( x [ i ] [ 1 ] - x [ j ] [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d * ( n - 1 ) / cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 2 <NEWLINE> b = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c = b + a <NEWLINE> a , b = b , c <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
( n , m , * b ) , a , * q = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> t = [ - 1 ] * n <NEWLINE> def r ( x ) : <NEWLINE> <INDENT> while - 1 < t [ x ] : x = t [ x ] <NEWLINE> return x <NEWLINE> <DEDENT> def u ( x ) : <NEWLINE> <INDENT> x , y = map ( r , x ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if t [ x ] > t [ y ] : x , y = y , x <NEWLINE> t [ x ] += t [ y ] ; t [ y ] = x <NEWLINE> <DEDENT> <DEDENT> [ * map ( u , q ) ] <NEWLINE> i = c = 0 <NEWLINE> k = j = n + ~ m << 1 <NEWLINE> * d , = eval ( <STRING> * n ) <NEWLINE> for v in a : d [ r ( i ) ] += v , ; i += 1 <NEWLINE> for p in d : x , * y = sorted ( p ) + [ 0 ] ; c += x ; b += y [ : - 1 ] ; j -= p > [ ] <NEWLINE> print ( k < 1 and <STRING> or ( k > n ) * <STRING> or c + sum ( sorted ( b ) [ : j ] ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> ans = [ <STRING> ] <NEWLINE> <NL> if <STRING> not in set ( s ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> f = True <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> f &= ( s [ i + j ] == <STRING> or s [ i + j ] == t [ j ] ) <NEWLINE> <NL> <DEDENT> if f : <NEWLINE> <INDENT> ans = s . copy ( ) <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> ans [ i + j ] = t [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 2019 <NEWLINE> <NL> if R - L >= p : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = p <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> res = min ( res , i * j % p ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_lst [ i ] += 1 <NEWLINE> <NL> <DEDENT> max_a = max ( a_lst ) <NEWLINE> count_lst = [ 0 ] * ( max_a + 2 ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = a_lst [ i ] <NEWLINE> index1 = a - 1 <NEWLINE> index2 = a <NEWLINE> index3 = a + 1 <NEWLINE> <NL> count_lst [ index1 ] += 1 <NEWLINE> count_lst [ index2 ] += 1 <NEWLINE> count_lst [ index3 ] += 1 <NEWLINE> <NL> <DEDENT> maximum = max ( count_lst ) <NEWLINE> print ( maximum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> b = 100 - int ( b ) <NEWLINE> if b < 10 : <NEWLINE> <INDENT> b = str ( <STRING> ) + str ( b ) <NEWLINE> <DEDENT> elif b == 100 : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = str ( b ) <NEWLINE> <DEDENT> a = a + b <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> l2 = sorted ( l ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( l . index ( l2 [ i ] ) + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ str ( i ) for i in input ( ) ] <NEWLINE> <NL> search = [ ( <STRING> + str ( s ) ) [ - 3 : ] for s in range ( 0 , 1000 ) ] <NEWLINE> ans = [ ] <NEWLINE> for num in search : <NEWLINE> <INDENT> tmp_S = S <NEWLINE> if num [ 0 ] in tmp_S : <NEWLINE> <INDENT> tmp_S = tmp_S [ tmp_S . index ( num [ 0 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num [ 1 ] in tmp_S : <NEWLINE> <INDENT> tmp_S = tmp_S [ tmp_S . index ( num [ 1 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num [ 2 ] in tmp_S : <NEWLINE> <INDENT> ans . append ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> mod = 998244353 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> xy = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> xy . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> diff = [ ] <NEWLINE> <NL> for s , t in combinations ( xy , 2 ) : <NEWLINE> <INDENT> st = str ( t [ 0 ] - s [ 0 ] ) + <STRING> + str ( t [ 1 ] - s [ 1 ] ) <NEWLINE> diff . append ( st ) <NEWLINE> <NL> <DEDENT> print ( max ( N - Counter ( diff ) . most_common ( ) [ 0 ] [ 1 ] , 1 ) ) <NEWLINE> <NL>
K , S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> s , t = 0 , 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> s -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s + t ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power = power % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ex = [ 0 ] <NEWLINE> for x in p : <NEWLINE> <INDENT> ex . append ( ex [ - 1 ] + ( x + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , ex [ i ] - ex [ i - k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] - i - 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> import bisect <NEWLINE> z = bisect . bisect_left ( A , 0 ) <NEWLINE> ans = sum ( A [ z : ] ) - sum ( A [ : z ] ) <NEWLINE> if z > N - z : <NEWLINE> <INDENT> p = 0 <NEWLINE> while z > N - z : <NEWLINE> <INDENT> b = A [ z - 1 ] <NEWLINE> ans += ( N - 2 * z ) * ( p - b ) <NEWLINE> p = b <NEWLINE> z = bisect . bisect_left ( A , b ) <NEWLINE> <DEDENT> <DEDENT> elif N > 2 * bisect . bisect_right ( A , 0 ) : <NEWLINE> <INDENT> z = bisect . bisect_right ( A , 0 ) <NEWLINE> p = 0 <NEWLINE> while N - z > z : <NEWLINE> <INDENT> b = A [ z ] <NEWLINE> ans += ( 2 * z - N ) * ( b - p ) <NEWLINE> p = b <NEWLINE> z = bisect . bisect_right ( A , b ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in d : <NEWLINE> <INDENT> ans += d [ s ] <NEWLINE> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> a_c = a . cumsum ( ) <NEWLINE> a_t = a_c [ - 1 ] <NEWLINE> diff = np . abs ( 2 * a_c - a_t ) <NEWLINE> ans = diff [ : - 1 ] . min ( ) <NEWLINE> print ( ans ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> x = [ LIST ( ) for i in range ( n ) ] <NEWLINE> reg = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> p = x [ j ] [ 0 ] - x [ i ] [ 0 ] <NEWLINE> q = x [ j ] [ 1 ] - x [ i ] [ 1 ] <NEWLINE> count = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for l in range ( n ) : <NEWLINE> <INDENT> if x [ l ] [ 0 ] - x [ k ] [ 0 ] == p and x [ l ] [ 1 ] - x [ k ] [ 1 ] == q : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> reg = max ( reg , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = n - reg <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( ( x - l , x + l - 1 ) ) <NEWLINE> <NL> <DEDENT> X = sorted ( X , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> last = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if X [ last ] [ 1 ] < X [ i ] [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> last = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> AGCT = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> AGCT_list = [ ] <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ i ] in AGCT : <NEWLINE> <INDENT> k = 1 <NEWLINE> agct_tmp = S [ i ] <NEWLINE> if i + k < len ( S ) : <NEWLINE> <INDENT> while S [ i + k ] in AGCT : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> agct_tmp += S [ i + k ] <NEWLINE> if i + k + 1 < len ( S ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> AGCT_list . append ( agct_tmp ) <NEWLINE> i = i + k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if AGCT_list : <NEWLINE> <INDENT> print ( max ( [ len ( string ) for string in AGCT_list ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> if n == 1 and x == a [ 0 ] : <NEWLINE> <INDENT> print ( max ( x , 10 ** 9 - x ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( abs ( a [ i ] - x ) ) <NEWLINE> <DEDENT> import math <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = math . gcd ( c , b [ i ] ) <NEWLINE> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> x = sorted ( LIST ( ) ) <NEWLINE> dx = [ x [ i + 1 ] - x [ i ] for i in range ( m - 1 ) ] <NEWLINE> dx . sort ( reverse = True ) <NEWLINE> <NL> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ m - 1 ] - x [ 0 ] - sum ( dx [ 0 : n - 1 ] ) ) <NEWLINE> <DEDENT>
from collections import OrderedDict <NEWLINE> <NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> res = [ ] <NEWLINE> <NL> if K > B - A : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> res_unique = list ( set ( res ) ) <NEWLINE> res_unique . sort ( ) <NEWLINE> <NL> for i in res_unique : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> def factorize ( n ) : <NEWLINE> <INDENT> b = 2 <NEWLINE> fct = [ ] <NEWLINE> while b * b <= n : <NEWLINE> <INDENT> while n % b == 0 : <NEWLINE> <INDENT> n //= b <NEWLINE> fct . append ( b ) <NEWLINE> <DEDENT> b = b + 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> fct . append ( n ) <NEWLINE> <DEDENT> return fct <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> N , P = map ( int , pin ( ) . split ( ) ) <NEWLINE> l = factorize ( P ) <NEWLINE> d = list ( set ( l ) ) <NEWLINE> ans = 1 <NEWLINE> for i in d : <NEWLINE> <INDENT> t = l . count ( i ) <NEWLINE> if t >= N : <NEWLINE> <INDENT> ans *= i ** ( int ( t / N ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> mae = deque ( ) <NEWLINE> usiro = deque ( ) <NEWLINE> <NL> <COMMENT> <NL> Flag = 0 <NEWLINE> <NL> for i in reversed ( range ( 0 , N , 1 ) ) : <NEWLINE> <NL> <INDENT> if Flag == 0 : <COMMENT> <NEWLINE> <INDENT> mae . append ( str ( A [ i ] ) ) <NEWLINE> mae . append ( <STRING> ) <NEWLINE> Flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> usiro . insert ( 0 , str ( A [ i ] ) ) <NEWLINE> usiro . appendleft ( <STRING> ) <NEWLINE> Flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> moziretu = ( mae + usiro ) <NEWLINE> del moziretu [ ( ( len ( moziretu ) ) // 2 ) ] <NEWLINE> moziretu = <STRING> . join ( moziretu ) <NEWLINE> print ( moziretu ) <NEWLINE> <NL> <NL> <NL> <NL>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = collections . Counter ( int ( T ) for T in input ( ) . split ( ) ) . most_common ( ) <NEWLINE> Remove = 0 <NEWLINE> for T in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> if A [ T ] [ 0 ] > A [ T ] [ 1 ] : <NEWLINE> <INDENT> Remove += A [ T ] [ 1 ] <NEWLINE> <DEDENT> elif A [ T ] [ 0 ] < A [ T ] [ 1 ] : <NEWLINE> <INDENT> Remove += A [ T ] [ 1 ] - A [ T ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( Remove ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> DP = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> min_k = float ( <STRING> ) <NEWLINE> min_k = min ( [ DP [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( i - K , 0 ) , i ) ] ) <NEWLINE> DP [ i ] = min_k <NEWLINE> pass <NEWLINE> <DEDENT> print ( DP [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , D = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> M = [ 0 ] * H <NEWLINE> C = { } <NEWLINE> revM = { } <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> M [ h ] = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> for i , w in enumerate ( M [ h ] ) : <NEWLINE> <INDENT> revM [ w ] = ( h , i ) <NEWLINE> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> HW = H * W <NEWLINE> ans = [ 0 ] * ( HW + 1 ) <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> cur = i <NEWLINE> while cur + D <= HW : <NEWLINE> <INDENT> ans [ cur + D ] += ans [ cur ] + abs ( revM [ cur ] [ 0 ] - revM [ cur + D ] [ 0 ] ) + abs ( revM [ cur ] [ 1 ] - revM [ cur + D ] [ 1 ] ) <NEWLINE> cur += D <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> l , r = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> print ( ans [ r ] - ans [ l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ c ] += b <NEWLINE> <NL> <DEDENT> d_sorted = sorted ( d . items ( ) , reverse = True , key = lambda x : x [ 0 ] ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i , j in d_sorted : <NEWLINE> <INDENT> for k in range ( j ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if len ( l ) > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> for i in range ( min ( n , len ( l ) ) ) : <NEWLINE> <INDENT> a [ i ] = max ( a [ i ] , l [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> tmp = factorization ( p ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> while tmp [ i ] [ 1 ] >= n : <NEWLINE> <INDENT> tmp [ i ] [ 1 ] -= n <NEWLINE> ans *= tmp [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s_dic = { } <NEWLINE> s_set = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> s = <STRING> . join ( sorted ( s ) ) <NEWLINE> <NL> if s in s_set : <NEWLINE> <INDENT> s_dic [ s ] += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> s_set . add ( s ) <NEWLINE> s_dic [ s ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> <NL> for val in s_dic . values ( ) : <NEWLINE> <NL> <INDENT> if val > 1 : <NEWLINE> <INDENT> result += int ( ( val * ( val - 1 ) ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lst . append ( ( p_lst [ i ] + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> tmp_sum = sum ( lst [ : k ] ) <NEWLINE> maximum = tmp_sum <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> tmp_sum -= lst [ i ] <NEWLINE> tmp_sum += lst [ i + k ] <NEWLINE> maximum = max ( maximum , tmp_sum ) <NEWLINE> <NL> <DEDENT> print ( maximum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> INFTY = sys . maxsize <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nList = [ ] <NEWLINE> for _ in range ( n + 1 ) : <NEWLINE> <INDENT> nList . append ( [ ] ) <NEWLINE> <DEDENT> for _ in range ( 1 , n ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> nList [ u ] . append ( ( v , w ) ) <NEWLINE> nList [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> return n , nList <NEWLINE> <NL> <DEDENT> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> status = [ ] <NEWLINE> color = [ ] <NEWLINE> <NL> def dfs ( s , nList ) : <NEWLINE> <INDENT> for u , w in nList [ s ] : <NEWLINE> <INDENT> if status [ u ] == WHITE : <NEWLINE> <INDENT> if w % 2 == 0 : <NEWLINE> <INDENT> color [ u ] = color [ s ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color [ u ] = ( color [ s ] + 1 ) % 2 <NEWLINE> <DEDENT> status [ u ] = GRAY <NEWLINE> dfs ( u , nList ) <NEWLINE> <DEDENT> <DEDENT> status [ s ] = BLACK <NEWLINE> <NL> <DEDENT> def main ( n , nList ) : <NEWLINE> <INDENT> global status <NEWLINE> global color <NEWLINE> <NL> status = [ WHITE ] * ( n + 1 ) <NEWLINE> color = [ WHITE ] * ( n + 1 ) <NEWLINE> dfs ( 1 , nList ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( color [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , nList = readinput ( ) <NEWLINE> main ( n , nList ) <NEWLINE> <COMMENT> <NL> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] == T [ 0 ] : <NEWLINE> <INDENT> tem = i + 1 <NEWLINE> f = 1 <NEWLINE> if tem == len ( S ) : <NEWLINE> <INDENT> tem = 0 <NEWLINE> <DEDENT> for t in range ( 1 , len ( T ) ) : <NEWLINE> <INDENT> if T [ t ] == S [ tem ] : <NEWLINE> <INDENT> tem += 1 <NEWLINE> if tem == len ( S ) : <NEWLINE> <INDENT> tem = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t == len ( T ) - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * A , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> * B , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> * C , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lenc = len ( C ) <NEWLINE> <NL> from bisect import * <NEWLINE> <NL> cnt = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> in_a = bisect_left ( A , b ) <NEWLINE> in_c = bisect_right ( C , b ) <NEWLINE> cnt += in_a * ( lenc - in_c ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> edges , vertices = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ None for _ in range ( edges ) ] <NEWLINE> <NL> nodes = [ [ ] for _ in range ( edges ) ] <NEWLINE> <NL> for i in range ( vertices ) : <NEWLINE> <INDENT> start , end = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ end - 1 ] . append ( start - 1 ) <NEWLINE> <NL> <DEDENT> def find ( arr ) : <NEWLINE> <INDENT> if not len ( arr ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for x in arr : <NEWLINE> <INDENT> if dp [ x ] is None : <NEWLINE> <INDENT> dp [ x ] = find ( nodes [ x ] ) <NEWLINE> <DEDENT> <DEDENT> return 1 + max ( dp [ x ] for x in arr ) <NEWLINE> <NL> <DEDENT> for i in range ( edges ) : <NEWLINE> <INDENT> dp [ i ] = find ( nodes [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> import statistics <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = ns ( ) <NEWLINE> e = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = ns ( ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> e [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> s , t = ns ( ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> <NL> visited = [ [ True ] * 3 for _ in range ( n ) ] <NEWLINE> <NL> que = collections . deque ( ) <NEWLINE> que . append ( [ 0 , s ] ) <NEWLINE> visited [ s ] [ 0 ] = False <NEWLINE> cnt = 0 <NEWLINE> ans = - 1 <NEWLINE> flg = True <NEWLINE> <NL> while que and flg : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> for _ in range ( len ( que ) ) : <NEWLINE> <INDENT> i , q = que . popleft ( ) <NEWLINE> for ei in e [ q ] : <NEWLINE> <INDENT> tmp = ( i + 1 ) % 3 <NEWLINE> if tmp == 0 and ei == t : <NEWLINE> <INDENT> ans = cnt // 3 <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> elif visited [ ei ] [ tmp ] : <NEWLINE> <INDENT> visited [ ei ] [ tmp ] = False <NEWLINE> que . append ( [ tmp , ei ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A >= 13 : <NEWLINE> <INDENT> ans = B <NEWLINE> <DEDENT> elif A >= 6 : <NEWLINE> <INDENT> ans = int ( B / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
import collections <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ct = collections . Counter ( t ) <NEWLINE> cd = collections . Counter ( d ) <NEWLINE> cct = list ( ct . items ( ) ) <NEWLINE> <COMMENT> <NL> if n < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( cct ) ) : <NEWLINE> <INDENT> if cd [ cct [ i ] [ 0 ] ] < cct [ i ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> def main ( N , A ) : <NEWLINE> <INDENT> B = [ 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T = A [ i ] + B [ i ] <NEWLINE> <NL> B . append ( T ) <NEWLINE> <DEDENT> c = collections . Counter ( B ) <NEWLINE> <NL> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> k , v = c . popitem ( ) <NEWLINE> for z in range ( v ) : <NEWLINE> <INDENT> count += z <NEWLINE> <NL> <DEDENT> <DEDENT> return print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> main ( N , A ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cou = 0 <NEWLINE> x = math . inf <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> if min ( x , p [ j ] ) == p [ j ] : <NEWLINE> <INDENT> x = p [ j ] <NEWLINE> cou += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cou ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s1 = set ( ) <NEWLINE> s2 = set ( ) <NEWLINE> s3 = set ( ) <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> for j in s2 : <NEWLINE> <INDENT> s3 . add ( j + i ) <NEWLINE> <DEDENT> for k in s1 : <NEWLINE> <INDENT> s2 . add ( k + i ) <NEWLINE> <DEDENT> s1 . add ( i ) <NEWLINE> <DEDENT> print ( len ( s3 ) ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> factorial = 1 <NEWLINE> divisor = [ ] <NEWLINE> ans = 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> def get_prime ( num ) : <NEWLINE> <INDENT> if num <= 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for i in range ( 2 , num + 1 ) : <NEWLINE> <INDENT> while num % i == 0 : <NEWLINE> <INDENT> divisor . append ( i ) <NEWLINE> num //= i <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> get_prime ( j ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> count = collections . Counter ( divisor ) <NEWLINE> <NL> for k in count . most_common ( ) : <NEWLINE> <INDENT> temp = list ( k ) [ 1 ] <NEWLINE> ans = ans * ( temp + 1 ) <NEWLINE> <NL> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
