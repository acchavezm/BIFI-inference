<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> X = { - INF , INF } <NEWLINE> Y = { - INF , INF } <NEWLINE> for i in a : <NEWLINE> <INDENT> Y . add ( i [ 2 ] ) <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> X . add ( i [ 0 ] ) <NEWLINE> <NL> <DEDENT> X = list ( sorted ( X ) ) <NEWLINE> Y = list ( sorted ( Y ) ) <NEWLINE> n = len ( X ) - 1 <NEWLINE> m = len ( Y ) - 1 <NEWLINE> wallx = [ [ False ] * m for i in range ( n ) ] <NEWLINE> wally = [ [ False ] * m for i in range ( n ) ] <NEWLINE> <NL> for x1 , x2 , y1 in a : <NEWLINE> <INDENT> x1 = bisect_left ( X , x1 ) <NEWLINE> y1 = bisect_left ( Y , y1 ) <NEWLINE> x2 = bisect_right ( X , x2 ) - 1 <NEWLINE> for i in range ( x1 , x2 ) : <NEWLINE> <INDENT> wally [ i ] [ y1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for x1 , y1 , y2 in b : <NEWLINE> <INDENT> x1 = bisect_left ( X , x1 ) <NEWLINE> y1 = bisect_left ( Y , y1 ) <NEWLINE> y2 = bisect_right ( Y , y2 ) - 1 <NEWLINE> for i in range ( y1 , y2 ) : <NEWLINE> <INDENT> wallx [ x1 ] [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> cow = [ [ False ] * m for i in range ( n ) ] <NEWLINE> cx = bisect_right ( X , 0 ) - 1 <NEWLINE> cy = bisect_right ( Y , 0 ) - 1 <NEWLINE> cow [ cx ] [ cy ] = True <NEWLINE> q = [ ( cx , cy ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> x , y = q . pop ( ) <NEWLINE> if not x or not y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans += ( X [ x + 1 ] - X [ x ] ) * ( Y [ y + 1 ] - Y [ y ] ) <NEWLINE> if x and not wallx [ x ] [ y ] and not cow [ x - 1 ] [ y ] : <NEWLINE> <INDENT> cow [ x - 1 ] [ y ] = True <NEWLINE> q . append ( ( x - 1 , y ) ) <NEWLINE> <DEDENT> if y and not wally [ x ] [ y ] and not cow [ x ] [ y - 1 ] : <NEWLINE> <INDENT> cow [ x ] [ y - 1 ] = True <NEWLINE> q . append ( ( x , y - 1 ) ) <NEWLINE> <DEDENT> if x + 1 < n and not wallx [ x + 1 ] [ y ] and not cow [ x + 1 ] [ y ] : <NEWLINE> <INDENT> cow [ x + 1 ] [ y ] = True <NEWLINE> q . append ( ( x + 1 , y ) ) <NEWLINE> <DEDENT> if y + 1 < m and not wally [ x ] [ y + 1 ] and not cow [ x ] [ y + 1 ] : <NEWLINE> <INDENT> cow [ x ] [ y + 1 ] = True <NEWLINE> q . append ( ( x , y + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> area = r * r * math . pi <NEWLINE> length = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( area , length ) ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> nmx = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( nmx [ 0 ] ) <NEWLINE> m = int ( nmx [ 1 ] ) <NEWLINE> x = int ( nmx [ 2 ] ) <NEWLINE> a = [ ] <NEWLINE> c = [ ] <NEWLINE> total = [ ] <NEWLINE> pattern = [ [ 0 ] * n ] <NEWLINE> <NL> for i in range ( pow ( 2 , n ) - 1 ) : <NEWLINE> <INDENT> pattern . append ( [ pattern [ i ] [ j ] for j in range ( n ) ] ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if pattern [ i + 1 ] [ j ] == 0 : <NEWLINE> <INDENT> pattern [ i + 1 ] [ j ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pattern [ i + 1 ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> r = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> text = input ( ) . split ( <STRING> ) <NEWLINE> c . append ( int ( text [ 0 ] ) ) <NEWLINE> a . append ( [ int ( text [ i ] ) for i in range ( 1 , m + 1 ) ] ) <NEWLINE> <NL> <DEDENT> a = np . array ( a ) <NEWLINE> <NL> for i in range ( pow ( 2 , n ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> array = a . T @ pattern [ i ] <NEWLINE> if not ( all ( v >= x for v in array ) ) : <NEWLINE> <INDENT> pattern = np . delete ( pattern , i , 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> total = [ np . dot ( np . array ( c ) , p ) for p in pattern ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if len ( total ) > 0 : <NEWLINE> <INDENT> print ( min ( total ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
x1 , y1 , x2 , y2 = [ float ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s0m = 0 <NEWLINE> x = max ( 0 , A - K ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> s0m = + A <NEWLINE> K = K - A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s0m = + K <NEWLINE> K = 0 <NEWLINE> <DEDENT> if K == 0 : <NEWLINE> <INDENT> print ( s0m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = max ( 0 , B - K ) <NEWLINE> if y == 0 : <NEWLINE> <INDENT> K = K - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = 0 <NEWLINE> <DEDENT> if K == 0 : <NEWLINE> <INDENT> print ( s0m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = max ( 0 , C - K ) <NEWLINE> if z == 0 : <NEWLINE> <INDENT> s0m = s0m - C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s0m -= K <NEWLINE> <DEDENT> print ( s0m ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> q = [ ] <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( a [ i ] * ( - 1 ) , 1 ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> heapq . heappush ( q , ( c * ( - 1 ) , b ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> c , b = heapq . heappop ( q ) <NEWLINE> res += c * ( - 1 ) <NEWLINE> if b > 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> heapq . heappush ( q , ( c , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = 100 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> while a < n : <NEWLINE> <COMMENT> <NL> <INDENT> a = math . floor ( a * 1.01 ) <NEWLINE> ans = ans + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b - a + 1 ) >= ( 2 * k ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> for i in reversed ( range ( 0 , k ) ) : <NEWLINE> <INDENT> print ( b - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> tree = { } <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if A not in tree : <NEWLINE> <INDENT> tree [ A ] = [ ] <NEWLINE> <DEDENT> if B not in tree : <NEWLINE> <INDENT> tree [ B ] = [ ] <NEWLINE> <DEDENT> tree [ A ] . append ( ( B , C ) ) <NEWLINE> tree [ B ] . append ( ( A , C ) ) <NEWLINE> <NL> <NL> <DEDENT> c = { } <NEWLINE> q = [ ] <NEWLINE> visited = set ( ) <NEWLINE> <NL> def dfs ( a , acc ) : <NEWLINE> <INDENT> q . append ( ( a , acc ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> n , r = q . pop ( ) <NEWLINE> c [ n ] = r <NEWLINE> visited . add ( n ) <NEWLINE> for b , cost in ( ( b , cost ) for b , cost in tree [ n ] if b not in visited ) : <NEWLINE> <INDENT> q . append ( ( b , cost + r ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> Q , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dfs ( K , 0 ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( c [ x ] + c [ y ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n ; b = [ 0 ] * n ; <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> p = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> dict = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = math . gcd ( a [ i ] , b [ i ] ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> aa = a [ i ] // d <NEWLINE> bb = b [ i ] // d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = a [ i ] <NEWLINE> bb = b [ i ] <NEWLINE> <DEDENT> if aa < 0 : <COMMENT> <NEWLINE> <INDENT> aa = - aa <NEWLINE> bb = - bb <NEWLINE> <DEDENT> if aa == 0 and bb > 0 : <NEWLINE> <INDENT> bb = - bb <NEWLINE> <COMMENT> <NL> <DEDENT> if ( aa , bb ) in dict : <NEWLINE> <INDENT> dict [ ( aa , bb ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ ( aa , bb ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> bad = [ ] <NEWLINE> others = [ ] <NEWLINE> zeros = 0 <NEWLINE> <NL> for ( aa , bb ) in dict : <NEWLINE> <INDENT> if dict [ ( aa , bb ) ] == 0 : continue <NEWLINE> if aa == 0 and bb == 0 : <NEWLINE> <INDENT> zeros += dict [ ( aa , bb ) ] <NEWLINE> dict [ ( aa , bb ) ] = 0 <NEWLINE> <DEDENT> elif ( bb , - aa ) in dict : <NEWLINE> <INDENT> bad . append ( ( dict [ ( aa , bb ) ] , dict [ ( bb , - aa ) ] ) ) <NEWLINE> dict [ ( bb , - aa ) ] = 0 <NEWLINE> <DEDENT> elif ( - bb , aa ) in dict : <NEWLINE> <INDENT> bad . append ( ( dict [ ( aa , bb ) ] , dict [ ( - bb , aa ) ] ) ) <NEWLINE> dict [ ( - bb , aa ) ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> others . append ( dict [ ( aa , bb ) ] ) <NEWLINE> <DEDENT> dict [ ( aa , bb ) ] = 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for ( x , y ) in bad : <NEWLINE> <INDENT> ans = ans * ( pow ( 2 , x , p ) + pow ( 2 , y , p ) - 1 ) % p <NEWLINE> <DEDENT> for z in others : <NEWLINE> <INDENT> ans = ans * pow ( 2 , z , p ) % p <NEWLINE> <DEDENT> ans = ( ans - 1 ) % p <NEWLINE> if zeros > 0 : <NEWLINE> <INDENT> ans = ( ans + zeros ) % p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a_len = int ( input ( ) ) <NEWLINE> a_ar = sorted ( [ int ( n ) for n in input ( ) . split ( <STRING> ) ] ) <NEWLINE> b_len = int ( input ( ) ) <NEWLINE> b_ar = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> max_b = max ( b_ar ) <NEWLINE> dp = [ 0 for n in range ( max_b + 1 ) ] <NEWLINE> for a in a_ar : <NEWLINE> <INDENT> new_dp = dp [ : ] <NEWLINE> new_dp [ a ] = 1 <NEWLINE> for i , d in enumerate ( dp ) : <NEWLINE> <INDENT> if d and i + a <= max_b : <NEWLINE> <INDENT> new_dp [ i + a ] = 1 <NEWLINE> <DEDENT> <DEDENT> dp = new_dp <NEWLINE> <DEDENT> for b in b_ar : <NEWLINE> <INDENT> if dp [ b ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> lis = [ i for i in l if i % 10 != 0 ] <NEWLINE> <NL> sum_l = sum ( l ) <NEWLINE> <NL> if sum_l % 10 != 0 : <NEWLINE> <INDENT> print ( sum_l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( lis ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum_l - min ( lis ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> cb = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cb . append ( [ c , b ] ) <NEWLINE> <DEDENT> cb . sort ( reverse = True ) <NEWLINE> k = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < cb [ i ] [ 1 ] and k + j < n and a [ k + j ] < cb [ i ] [ 0 ] : <NEWLINE> <INDENT> a [ k + j ] = cb [ i ] [ 0 ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> k += j <NEWLINE> if k == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> day = 0 <NEWLINE> money = 1000 <NEWLINE> stock = 0 <NEWLINE> is_up = True <NEWLINE> while day < N : <NEWLINE> <INDENT> if is_up : <NEWLINE> <INDENT> past_day = day <NEWLINE> while A [ day ] <= A [ day + 1 ] : <NEWLINE> <INDENT> day += 1 <NEWLINE> if day == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> stock = int ( money / A [ past_day ] ) <NEWLINE> money += stock * ( A [ day ] - A [ past_day ] ) <NEWLINE> day += 1 <NEWLINE> if day == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> is_up = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while A [ day ] >= A [ day + 1 ] : <NEWLINE> <INDENT> day += 1 <NEWLINE> if day == N - 1 : <NEWLINE> <INDENT> day += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> is_up = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( money ) ) <NEWLINE> <NL> <NL> <NL>
from sys import stdin <NEWLINE> A , B , C , K = list ( map ( int , ( stdin . readline ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> K = K - ( A + B ) <NEWLINE> print ( A + ( K * - 1 ) ) <NEWLINE> exit ( ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> actividad = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> puntos = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> actividad . append ( puntos ) <NEWLINE> <NL> <DEDENT> primer_puntos = [ 0 ] * 3 <NEWLINE> <NL> for i in range ( len ( primer_puntos ) ) : <NEWLINE> <INDENT> primer_puntos [ i ] = actividad [ 0 ] [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> siguiente = [ 0 ] * 3 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if j != k : <NEWLINE> <INDENT> siguiente [ j ] = max ( siguiente [ j ] , primer_puntos [ k ] + actividad [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> primer_puntos = siguiente <NEWLINE> <NL> <DEDENT> print ( max ( primer_puntos ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def calc ( a , b ) : <NEWLINE> <INDENT> return a ** 5 - b ** 5 <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> even = 0 <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> even = 1 <NEWLINE> <DEDENT> flag = 0 <NEWLINE> if even : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> b = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> if calc ( a , b ) == x : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif calc ( a , b ) > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b -= 2 <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> if even : <NEWLINE> <INDENT> b = a - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a - 1 <NEWLINE> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> to = [ [ ] for i in range ( 100010 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ 0 ] * ( N + 1 ) <NEWLINE> q = [ 1 ] <NEWLINE> dist [ 0 ] = - 1 <NEWLINE> <COMMENT> <NL> <NL> dist = [ 0 ] * N <NEWLINE> pre = [ 0 ] * N <NEWLINE> <NL> while len ( q ) != 0 : <NEWLINE> <INDENT> a = q . pop ( 0 ) <NEWLINE> for i in to [ a ] : <NEWLINE> <INDENT> if dist [ i - 1 ] == 0 : <NEWLINE> <INDENT> dist [ i - 1 ] = dist [ a - 1 ] + 1 <NEWLINE> pre [ i - 1 ] = a <NEWLINE> q . append ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( pre [ i ] ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> heapq . heappush ( A , ( - ( ( - heapq . heappop ( A ) ) // 2 ) ) ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
import math <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( A [ i - 1 ] > A [ i - K - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ a [ i ] [ 0 ] - 1 ] . append ( a [ i ] [ 1 ] ) <NEWLINE> b [ a [ i ] [ 1 ] - 1 ] . append ( a [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> seen = [ - 1 ] * n <NEWLINE> seen [ 0 ] = 1 <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> for i in b [ v - 1 ] : <NEWLINE> <INDENT> if seen [ i - 1 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . append ( i ) <NEWLINE> seen [ i - 1 ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if seen [ i ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> del seen [ 0 ] <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( seen [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] > A [ i - K ] else <STRING> ) <NEWLINE> <DEDENT>
N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( reversed ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> zero = 0 <NEWLINE> left_zero = 0 <NEWLINE> right_zero = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> left_zero += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> right_zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> dic [ a , b ] += 1 <NEWLINE> <DEDENT> <DEDENT> done = set ( ) <NEWLINE> ans = 1 <NEWLINE> for a , b in dic : <NEWLINE> <INDENT> k = ( a , b ) <NEWLINE> if k in done : continue <NEWLINE> rk = ( - b , a ) <NEWLINE> rk2 = ( b , - a ) <NEWLINE> done . add ( k ) <NEWLINE> done . add ( rk ) <NEWLINE> done . add ( rk2 ) <NEWLINE> c = pow ( 2 , dic [ k ] , MOD ) - 1 <NEWLINE> if rk in dic : <NEWLINE> <INDENT> c += pow ( 2 , dic [ rk ] , MOD ) - 1 <NEWLINE> <DEDENT> if rk2 in dic : <NEWLINE> <INDENT> c += pow ( 2 , dic [ rk2 ] , MOD ) - 1 <NEWLINE> <DEDENT> c += 1 <NEWLINE> ans *= c <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> c1 = pow ( 2 , left_zero , MOD ) - 1 <NEWLINE> c2 = pow ( 2 , right_zero , MOD ) - 1 <NEWLINE> c = c1 + c2 + 1 <NEWLINE> ans *= c <NEWLINE> ans += zero <NEWLINE> print ( ( ans - 1 ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x = x // 10 <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> sumall = sum ( A ) <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sumall -= A [ i ] <NEWLINE> cnt += ( A [ i ] * sumall ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( cnt % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> if 2 * j - i > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ 2 * j - i ] not in ( s [ i ] , s [ j ] ) : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> r = 1 <NEWLINE> for num in a : <NEWLINE> <INDENT> r *= num <NEWLINE> if r > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
<COMMENT> <NL> <NL> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_l = [ list ( format ( int ( x ) , <STRING> ) ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for _d , _tp in enumerate ( zip ( * a_l ) ) : <NEWLINE> <INDENT> if <STRING> not in _tp : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if <STRING> not in _tp : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _num = _tp . count ( <STRING> ) <NEWLINE> if _num % 2 == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a_l [ i ] [ _d ] == <STRING> : <NEWLINE> <INDENT> a_l [ i ] [ _d ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_l [ i ] [ _d ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * [ int ( <STRING> . join ( x ) , 2 ) for x in a_l ] ) <NEWLINE>
from enum import IntEnum <NEWLINE> <NL> <NL> class Action ( IntEnum ) : <NEWLINE> <INDENT> ADD = 1 <NEWLINE> SEARCH = 2 <NEWLINE> REMOVE = 3 <NEWLINE> <NL> <NL> <DEDENT> class Color ( IntEnum ) : <NEWLINE> <INDENT> BLACK = 0 <NEWLINE> RED = 1 <NEWLINE> <NL> @ staticmethod <NEWLINE> def flip ( c ) : <NEWLINE> <INDENT> return [ Color . RED , Color . BLACK ] [ c . value ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , value ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = Leaf <NEWLINE> self . right = Leaf <NEWLINE> self . color = Color . RED <NEWLINE> self . valid = True <NEWLINE> <NL> <DEDENT> def flip_color ( self ) : <NEWLINE> <INDENT> self . color = Color . flip ( self . color ) <NEWLINE> <NL> <DEDENT> def is_red ( self ) : <NEWLINE> <INDENT> return self . color == Color . RED <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return ( <STRING> + str ( self . left ) + <STRING> <NEWLINE> <INDENT> + str ( self . value ) + <STRING> + str ( self . right ) + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class LeafNode ( Node ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . value = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . color = None <NEWLINE> self . valid = False <NEWLINE> <NL> <DEDENT> def flip_color ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def is_red ( self ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> Leaf = LeafNode ( ) <NEWLINE> <NL> <NL> class RedBlackBST : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = Leaf <NEWLINE> <NL> <DEDENT> def add ( self , value ) : <NEWLINE> <INDENT> def _add ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> node = Node ( value ) <NEWLINE> <DEDENT> if node . value > value : <NEWLINE> <INDENT> node . left = _add ( node . left ) <NEWLINE> <DEDENT> elif node . value < value : <NEWLINE> <INDENT> node . right = _add ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not node . valid : <NEWLINE> <INDENT> node . valid = True <NEWLINE> <NL> <DEDENT> <DEDENT> node = self . _balance ( node ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> self . root = _add ( self . root ) <NEWLINE> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> def _balance ( self , node ) : <NEWLINE> <INDENT> if node . right . is_red ( ) and not node . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_left ( node ) <NEWLINE> <DEDENT> if node . left . is_red ( ) and node . left . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> if node . left . is_red ( ) and node . right . is_red ( ) : <NEWLINE> <INDENT> node = self . _flip_colors ( node ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def _rotate_left ( self , node ) : <NEWLINE> <INDENT> x = node . right <NEWLINE> node . right = x . left <NEWLINE> x . left = node <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . RED <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def _rotate_right ( self , node ) : <NEWLINE> <INDENT> x = node . left <NEWLINE> node . left = x . right <NEWLINE> x . right = node <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . RED <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def _flip_colors ( self , node ) : <NEWLINE> <INDENT> node . flip_color ( ) <NEWLINE> node . left . flip_color ( ) <NEWLINE> node . right . flip_color ( ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def remove ( self , value ) : <NEWLINE> <INDENT> def _remove ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if node . value > value : <NEWLINE> <INDENT> _remove ( node . left ) <NEWLINE> <DEDENT> elif node . value < value : <NEWLINE> <INDENT> _remove ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . valid = False <NEWLINE> <NL> <DEDENT> <DEDENT> _remove ( self . root ) <NEWLINE> <NL> <DEDENT> def count ( self , min_ , max_ ) : <NEWLINE> <INDENT> def _range ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if node . value > max_ : <NEWLINE> <INDENT> return _range ( node . left ) <NEWLINE> <DEDENT> elif node . value < min_ : <NEWLINE> <INDENT> return _range ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = _range ( node . left ) + _range ( node . right ) <NEWLINE> if node . valid : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> <DEDENT> return _range ( self . root ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def count_intersections ( segments ) : <NEWLINE> <INDENT> segments . sort ( ) <NEWLINE> tree = RedBlackBST ( ) <NEWLINE> count = 0 <NEWLINE> for seg in segments : <NEWLINE> <INDENT> x , action , y = seg <NEWLINE> if action == Action . SEARCH : <NEWLINE> <INDENT> count += tree . count ( * y ) <NEWLINE> <DEDENT> elif action == Action . ADD : <NEWLINE> <INDENT> tree . add ( y ) <NEWLINE> <DEDENT> elif action == Action . REMOVE : <NEWLINE> <INDENT> tree . remove ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> segs = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if x1 > x2 or y1 > y2 : <NEWLINE> <INDENT> x1 , x2 = x2 , x1 <NEWLINE> y1 , y2 = y2 , y1 <NEWLINE> <DEDENT> if x1 == x2 : <NEWLINE> <INDENT> segs . append ( ( x1 , Action . SEARCH , ( y1 , y2 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> segs . append ( ( x1 , Action . ADD , y1 ) ) <NEWLINE> segs . append ( ( x2 , Action . REMOVE , y2 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( count_intersections ( segs ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import collections <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def f ( v ) : <NEWLINE> <INDENT> state [ v ] = 1 <NEWLINE> a = As [ v ] <NEWLINE> idx = bisect . bisect_left ( D , a ) <NEWLINE> stack . append ( ( idx , D [ idx ] ) ) <COMMENT> <NEWLINE> D [ idx ] = a <NEWLINE> <NL> ans [ v ] = bisect . bisect_left ( D , float ( <STRING> ) ) <NEWLINE> <NL> for u in V [ v ] : <NEWLINE> <INDENT> if state [ u ] == 0 : <NEWLINE> <INDENT> f ( u ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> i_pre , d_pre = stack . pop ( ) <NEWLINE> D [ i_pre ] = d_pre <NEWLINE> <NL> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = [ float ( <STRING> ) ] * N <NEWLINE> stack = collections . deque ( [ ] ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> state = [ 0 ] * N <NEWLINE> <NL> V = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> V [ u - 1 ] . append ( v - 1 ) <NEWLINE> V [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> f ( 0 ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> rs = [ ] <NEWLINE> gs = [ ] <NEWLINE> bs = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rs . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> gs . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bs . setdefault ( i , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for ri in rs : <NEWLINE> <INDENT> for gi in gs : <NEWLINE> <INDENT> df = abs ( gi - ri ) <NEWLINE> rr = max ( gi , ri ) + df <NEWLINE> ll = min ( gi , ri ) - df <NEWLINE> mm = - 1 <NEWLINE> if df % 2 == 0 : <NEWLINE> <INDENT> mm = int ( ( gi + ri ) / 2 ) <NEWLINE> <NL> <DEDENT> if rr in bs : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if mm in bs : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if ll in bs : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> all_cnt = len ( rs ) * len ( gs ) * len ( bs ) <NEWLINE> <NL> print ( all_cnt - cnt ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <COMMENT> <NEWLINE> n = len ( s ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> amari = defaultdict ( lambda : 0 ) <NEWLINE> amari [ 0 ] = 1 <NEWLINE> num = 0 <NEWLINE> tmp = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> num = tmp + int ( s [ - 1 - i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> tmp = num % 2019 <NEWLINE> amari [ tmp ] += 1 <NEWLINE> <NL> if amari [ tmp ] > 1 : <NEWLINE> <INDENT> val = amari [ tmp ] <NEWLINE> ans -= ( val - 1 ) * ( val - 2 ) // 2 <NEWLINE> ans += ( val ) * ( val - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> s = 0 <NEWLINE> t = 0 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> t = 1 <NEWLINE> p = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if s == 0 and t == 0 : <NEWLINE> <INDENT> p = p * a [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> s = 1 <NEWLINE> p = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> d = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . add ( x [ 7 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x [ 5 : ] in d ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
wfwfe = input ( ) <NEWLINE> check = 0 <NEWLINE> b = input ( ) . split ( ) <NEWLINE> if <STRING> in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> count = 1 <NEWLINE> for i in b : <NEWLINE> <INDENT> count = count * int ( i ) <NEWLINE> <NL> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> check = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> uvw = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) ] <NEWLINE> d = [ - 1 for i in range ( n ) ] <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> for u , v , w in uvw : <NEWLINE> <INDENT> edge [ u - 1 ] . append ( ( v - 1 , w ) ) <NEWLINE> edge [ v - 1 ] . append ( ( u - 1 , w ) ) <NEWLINE> <DEDENT> def dfs ( now , D ) : <NEWLINE> <INDENT> d [ now ] = D <NEWLINE> for i , j in edge [ now ] : <NEWLINE> <INDENT> if d [ i ] == - 1 : <NEWLINE> <INDENT> dfs ( i , D + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> for i in d : <NEWLINE> <INDENT> print ( i % 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lst . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> max_profit = lst [ 1 ] - lst [ 0 ] <NEWLINE> min_value = min ( lst [ 0 ] , lst [ 1 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> price = lst [ i ] <NEWLINE> max_profit = max ( max_profit , price - min_value ) <NEWLINE> min_value = min ( min_value , price ) <NEWLINE> <NL> <DEDENT> print ( max_profit ) <NEWLINE>
string = input ( ) <NEWLINE> length = len ( string ) <NEWLINE> mod = [ 1 ] + [ 0 ] * 2018 <NEWLINE> s = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> s = ( s + int ( string [ - 1 - i ] ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> mod [ s ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in mod ] ) ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , q = input2 ( ) <NEWLINE> B = str ( input ( ) ) <NEWLINE> LR = [ input_array ( ) for _ in range ( q ) ] <NEWLINE> <NL> <COMMENT> <NL> T = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if B [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> T [ i + 1 ] = T [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i + 1 ] = T [ i ] <NEWLINE> <DEDENT> <DEDENT> for lr in LR : <NEWLINE> <INDENT> st = lr [ 0 ] - 1 <NEWLINE> fi = lr [ 1 ] - 1 <NEWLINE> print ( T [ fi ] - T [ st ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> DP = [ 0 ] * ( N + 1 ) <NEWLINE> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> DP [ i + 1 ] = ( DP [ i ] + pow ( 10 , i , 2019 ) * int ( s ) ) % 2019 <NEWLINE> <NL> <DEDENT> D = defaultdict ( int ) <NEWLINE> for dp in DP : <NEWLINE> <INDENT> D [ dp ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for dp in D . values ( ) : <NEWLINE> <INDENT> ans += dp * ( dp - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while ( True ) : <NEWLINE> <COMMENT> <NL> <INDENT> if X - i not in P : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif X + i not in P : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> if i > 120 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mul = A [ 0 ] <NEWLINE> for v in A [ 1 : ] : <NEWLINE> <INDENT> mul *= v <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 11 <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if A > 1 and B > 1 : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> A += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A == 1 and B > 1 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> A += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif A > 1 and B == 1 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 and B == 1 : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> A -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A == 0 and B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> A -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if C > 1 and B > 1 : <NEWLINE> <INDENT> if C > B : <NEWLINE> <INDENT> C -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif C == 1 and B > 1 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif C > 1 and B == 1 : <NEWLINE> <INDENT> C -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif C == 1 and B == 1 : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> C -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif C == 0 and B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif C == 0 : <NEWLINE> <INDENT> C += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if A > 1 and C > 1 : <NEWLINE> <INDENT> if A > C : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C -= 1 <NEWLINE> A += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A == 1 and C > 1 : <NEWLINE> <INDENT> C -= 1 <NEWLINE> A += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif A > 1 and C == 1 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 and C == 1 : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> C += 1 <NEWLINE> A -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif C == 0 : <NEWLINE> <INDENT> C += 1 <NEWLINE> A -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> upper = round ( ( N - 1 ) ** 0.5 - 1 ) <NEWLINE> for x in range ( 1 , upper + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , upper + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , upper + 1 ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if tmp < N + 1 : <NEWLINE> <INDENT> l [ tmp - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in l : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
def base_k ( n , k = 26 ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> ny = n <NEWLINE> while ny : <NEWLINE> <NL> <INDENT> ret . append ( ny % k ) <NEWLINE> ny //= k <NEWLINE> <DEDENT> return ret [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def letter ( i ) : <NEWLINE> <INDENT> return chr ( i + 97 ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> check = 26 <NEWLINE> cnt = 1 <NEWLINE> k = n <NEWLINE> while True : <NEWLINE> <INDENT> if n <= check : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> check *= 26 <NEWLINE> check += 26 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> k -= check // 26 - 1 <NEWLINE> t = base_k ( k - 1 ) <NEWLINE> ans = <STRING> <NEWLINE> if not t : <NEWLINE> <INDENT> ans = <STRING> * cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( cnt ) : <NEWLINE> <INDENT> if not t : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> ans += letter ( t . pop ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 for _ in range ( n ) ] <NEWLINE> L [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + a [ i ] <NEWLINE> <DEDENT> delay = 0 <NEWLINE> all_over = 0 <NEWLINE> anti_delay = 0 <NEWLINE> anti_all_over = 0 <NEWLINE> if a [ 0 ] != 0 : <NEWLINE> <INDENT> antiL = L [ : ] <NEWLINE> sign = ( a [ 0 ] > 0 ) - ( a [ 0 ] < 0 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> L [ i ] += delay <NEWLINE> if L [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> delay += 1 - L [ i ] <NEWLINE> all_over += 1 - L [ i ] <NEWLINE> L [ i ] = 1 <NEWLINE> <DEDENT> elif L [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> delay -= L [ i ] + 1 <NEWLINE> all_over += L [ i ] + 1 <NEWLINE> L [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> if antiL [ 0 ] < 0 : <NEWLINE> <INDENT> sign = 1 <NEWLINE> anti_delay = 1 - antiL [ 0 ] <NEWLINE> anti_all_over = 1 - antiL [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sign = - 1 <NEWLINE> anti_delay = - ( antiL [ 0 ] + 1 ) <NEWLINE> anti_all_over = antiL [ 0 ] + 1 <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> antiL [ i ] += anti_delay <NEWLINE> if antiL [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> anti_delay += 1 - antiL [ i ] <NEWLINE> anti_all_over += 1 - antiL [ i ] <NEWLINE> antiL [ i ] = 1 <NEWLINE> <DEDENT> elif antiL [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> anti_delay -= antiL [ i ] + 1 <NEWLINE> anti_all_over += antiL [ i ] + 1 <NEWLINE> antiL [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> print ( min ( anti_all_over , all_over ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posL = L [ : ] <NEWLINE> negL = L [ : ] <NEWLINE> pos_delay , neg_delay = 1 , - 1 <NEWLINE> pos_all_over , neg_all_over = 1 , 1 <NEWLINE> sign = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> posL [ i ] += pos_delay <NEWLINE> if posL [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> pos_delay += 1 - posL [ i ] <NEWLINE> pos_all_over += 1 - posL [ i ] <NEWLINE> posL [ i ] = 1 <NEWLINE> <DEDENT> elif posL [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> pos_delay -= posL [ i ] + 1 <NEWLINE> pos_all_over += posL [ i ] + 1 <NEWLINE> posL [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> sign = - 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> negL [ i ] += neg_delay <NEWLINE> if negL [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> neg_delay += 1 - negL [ i ] <NEWLINE> neg_all_over += 1 - negL [ i ] <NEWLINE> negL [ i ] = 1 <NEWLINE> <DEDENT> elif negL [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> neg_delay -= negL [ i ] + 1 <NEWLINE> neg_all_over += negL [ i ] + 1 <NEWLINE> negL [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> print ( min ( pos_all_over , neg_all_over ) ) <NEWLINE> <DEDENT>
from _collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> data_input = [ ] <NEWLINE> dlList = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> dlList . appendleft ( x [ 1 ] ) <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> if x [ 1 ] in dlList : <NEWLINE> <INDENT> dlList . remove ( x [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> dlList . popleft ( ) <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> dlList . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( dlList ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> s = 2 ** i <NEWLINE> if s <= N : <NEWLINE> <INDENT> list . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ( list ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for _ in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = ii ( ) <NEWLINE> V = li ( ) <NEWLINE> C = li ( ) <NEWLINE> <NL> sa = [ V [ i ] - C [ i ] for i in range ( N ) if V [ i ] - C [ i ] > 0 ] <NEWLINE> <NL> print ( sum ( sa ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> mae = deque ( ) <NEWLINE> usiro = deque ( ) <NEWLINE> <NL> <COMMENT> <NL> Flag = 0 <NEWLINE> <NL> for i in reversed ( range ( 0 , N , 1 ) ) : <NEWLINE> <NL> <INDENT> if Flag == 0 : <COMMENT> <NEWLINE> <INDENT> mae . append ( str ( A [ i ] ) ) <NEWLINE> mae . append ( <STRING> ) <NEWLINE> Flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> usiro . insert ( 0 , str ( A [ i ] ) ) <NEWLINE> usiro . appendleft ( <STRING> ) <NEWLINE> Flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> moziretu = ( mae + usiro ) <NEWLINE> del moziretu [ ( ( len ( moziretu ) ) // 2 ) ] <NEWLINE> moziretu = <STRING> . join ( moziretu ) <NEWLINE> print ( moziretu ) <NEWLINE> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> a = sorted ( l , key = lambda x : x [ 0 ] ) <NEWLINE> b = sorted ( l , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( b [ n // 2 ] [ 1 ] - a [ n // 2 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b [ n // 2 ] [ 1 ] + b [ n // 2 - 1 ] [ 1 ] ) - ( a [ n // 2 ] [ 0 ] + a [ n // 2 - 1 ] [ 0 ] ) + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def solve ( a , lvl , prev , dp ) : <NEWLINE> <INDENT> if ( prev , lvl ) in dp : return dp [ ( prev , lvl ) ] <NEWLINE> if lvl == len ( a ) - 1 : <NEWLINE> <INDENT> if prev == 0 : return max ( a [ - 1 ] [ 1 ] , a [ - 1 ] [ 2 ] ) <NEWLINE> if prev == 1 : return max ( a [ - 1 ] [ 0 ] , a [ - 1 ] [ 2 ] ) <NEWLINE> if prev == 2 : return max ( a [ - 1 ] [ 0 ] , a [ - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> if prev == - 1 : <NEWLINE> <INDENT> p = a [ 0 ] [ 0 ] + solve ( a , lvl + 1 , 0 , dp ) <NEWLINE> q = a [ 0 ] [ 1 ] + solve ( a , lvl + 1 , 1 , dp ) <NEWLINE> r = a [ 0 ] [ 2 ] + solve ( a , lvl + 1 , 2 , dp ) <NEWLINE> return max ( p , q , r ) <NEWLINE> <DEDENT> dp [ ( prev , lvl ) ] = max ( a [ lvl ] [ ( prev + 1 ) % 3 ] + solve ( a , lvl + 1 , ( prev + 1 ) % 3 , dp ) , a [ lvl ] [ ( prev - 1 ) % 3 ] + solve ( a , lvl + 1 , ( prev - 1 ) % 3 , dp ) ) <NEWLINE> return dp [ ( prev , lvl ) ] <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( max ( a [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( solve ( a , 0 , - 1 , { } ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m_l = [ [ 0 , 0 ] ] * m <NEWLINE> r_l = [ { } ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = r [ 0 ] - 1 <NEWLINE> b = r [ 1 ] - 1 <NEWLINE> <NL> ral = set ( [ ] ) if len ( r_l [ a ] ) == 0 else r_l [ a ] <NEWLINE> rbl = set ( [ ] ) if len ( r_l [ b ] ) == 0 else r_l [ b ] <NEWLINE> <NL> ral . add ( b ) <NEWLINE> rbl . add ( a ) <NEWLINE> <NL> r_l [ a ] = ral <NEWLINE> r_l [ b ] = rbl <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> for r in r_l [ ni ] : <NEWLINE> <INDENT> if h_a [ r ] >= h_a [ ni ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ 0 ] * ( N - 1 ) <NEWLINE> list1 = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> list [ i - 1 ] = A [ i - 1 ] <NEWLINE> list1 [ A [ i - 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> list1 . append ( 0 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> print ( list1 [ j ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L_list = [ ] <NEWLINE> R_list = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> L_list . append ( A ) <NEWLINE> R_list . append ( B ) <NEWLINE> <NL> <DEDENT> if max ( L_list ) > min ( R_list ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( R_list ) - max ( L_list ) + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . readline <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> if 400 <= N and N <= 599 : <NEWLINE> <INDENT> ans = 8 <NEWLINE> <DEDENT> elif 600 <= N and N <= 799 : <NEWLINE> <INDENT> ans = 7 <NEWLINE> <DEDENT> elif 800 <= N and N <= 999 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> elif 1000 <= N and N <= 1199 : <NEWLINE> <INDENT> ans = 5 <NEWLINE> <DEDENT> elif 1200 <= N and N <= 1399 : <NEWLINE> <INDENT> ans = 4 <NEWLINE> <DEDENT> elif 1400 <= N and N <= 1599 : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif 1600 <= N and N <= 1799 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif 1800 <= N and N <= 1999 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 ; <NEWLINE> <NL> if 0 in numlist : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in numlist : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n >= a + b : <NEWLINE> <INDENT> if n % ( a + b ) <= a : <NEWLINE> <INDENT> print ( a * ( n // ( a + b ) ) + ( n % ( a + b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * ( n // ( a + b ) ) + a ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n < a : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> <NL> r = C . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> import sys <NEWLINE> from collections import deque <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def read_values ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def read_index ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def read_list ( ) : return list ( read_values ( ) ) <NEWLINE> def read_lists ( N ) : return [ read_list ( ) for n in range ( N ) ] <NEWLINE> <NL> H , W = read_values ( ) <NEWLINE> P = [ [ False for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> F = [ input ( ) . strip ( ) for i in range ( H ) ] <NEWLINE> <NL> def f ( h , w ) : <NEWLINE> <INDENT> S = deque ( ) <NEWLINE> S . append ( ( h , w ) ) <NEWLINE> P [ h ] [ w ] = True <NEWLINE> T = [ 0 , 1 ] <NEWLINE> while S : <NEWLINE> <INDENT> h , w = S . popleft ( ) <NEWLINE> for hh , ww in [ ( h + 1 , w ) , ( h - 1 , w ) , ( h , w + 1 ) , ( h , w - 1 ) ] : <NEWLINE> <INDENT> if not ( 0 <= hh < H and 0 <= ww < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if P [ hh ] [ ww ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if F [ hh ] [ ww ] == F [ h ] [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> P [ hh ] [ ww ] = True <NEWLINE> t = 0 if F [ hh ] [ ww ] == <STRING> else 1 <NEWLINE> T [ t ] += 1 <NEWLINE> S . append ( ( hh , ww ) ) <NEWLINE> <DEDENT> <DEDENT> return T [ 0 ] * T [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if P [ h ] [ w ] or F [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res += f ( h , w ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) - 1 for a in input ( ) . split ( ) ] <NEWLINE> city = 0 <NEWLINE> if K <= N : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> city = A [ city ] <NEWLINE> <DEDENT> print ( city + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited = [ - 1 ] * N <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> if visited [ city ] != - 1 : <NEWLINE> <INDENT> roop_start = visited [ city ] <NEWLINE> cycle_num = k - roop_start <NEWLINE> break <NEWLINE> <DEDENT> visited [ city ] = k <NEWLINE> city = A [ city ] <NEWLINE> <DEDENT> K = ( K - roop_start ) % cycle_num + roop_start <NEWLINE> city = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> city = A [ city ] <NEWLINE> <DEDENT> print ( city + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if y == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , 200 ) : <NEWLINE> <INDENT> if i not in nums : <NEWLINE> <INDENT> ans = ans if abs ( ans - x ) <= abs ( i - x ) else i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> si , sj , ti , tj = map ( int , input ( ) . split ( ) ) <NEWLINE> si -= 1 <NEWLINE> sj -= 1 <NEWLINE> ti -= 1 <NEWLINE> tj -= 1 <NEWLINE> b = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> ans [ si ] [ sj ] = 0 <NEWLINE> from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> d . append ( ( si , sj ) ) <NEWLINE> while d : <NEWLINE> <INDENT> x , y = d . popleft ( ) <NEWLINE> if x == ti and y == tj : <NEWLINE> <INDENT> exit ( print ( ans [ x ] [ y ] ) ) <NEWLINE> <DEDENT> for dx , dy in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx = x + dx * i <NEWLINE> yy = y + dy * i <NEWLINE> if not ( 0 <= xx < h and 0 <= yy < w ) or b [ xx ] [ yy ] == <STRING> : break <NEWLINE> if 0 <= ans [ xx ] [ yy ] <= ans [ x ] [ y ] : break <NEWLINE> if ans [ xx ] [ yy ] == - 1 : d . append ( ( xx , yy ) ) <NEWLINE> ans [ xx ] [ yy ] = ans [ x ] [ y ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> a = <STRING> <NEWLINE> al = <STRING> <NEWLINE> b = [ 1 ] <NEWLINE> c = [ 1 ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> c . append ( c [ - 1 ] * 26 ) <NEWLINE> b . append ( sum ( c ) ) <NEWLINE> <DEDENT> b . sort ( reverse = True ) <NEWLINE> b . append ( 1 ) <NEWLINE> c . sort ( reverse = True ) <NEWLINE> c . append ( 1 ) <NEWLINE> flg = 0 <NEWLINE> i = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if flg == 1 : <NEWLINE> <INDENT> if n >= b [ i ] : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> while n >= b [ i ] and tmp < 26 : <NEWLINE> <INDENT> n -= c [ i ] <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> a += al [ tmp - 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> elif n >= b [ i ] : <NEWLINE> <INDENT> flg = 1 <NEWLINE> tmp = 0 <NEWLINE> while n >= b [ i ] and tmp < 26 : <NEWLINE> <INDENT> n -= c [ i ] <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> a += al [ tmp - 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> i = 2 <NEWLINE> <NL> c = [ ] <NEWLINE> <NL> while i * i <= n : <NEWLINE> <INDENT> j = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> c . append ( j ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> c . append ( 1 ) <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> if c == [ ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in c : <NEWLINE> <INDENT> d += int ( ( sqrt ( 1 + 8 * k ) - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> d = 0 <NEWLINE> p = 1 <NEWLINE> ml = [ 0 ] * mod <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = int ( s [ - i ] ) <NEWLINE> d += p * k <NEWLINE> d %= mod <NEWLINE> ml [ d ] += 1 <NEWLINE> p *= 10 <NEWLINE> p %= mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in ml : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans + ml [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def t ( k ) : <NEWLINE> <INDENT> return k * ( k + 1 ) // 2 <NEWLINE> <DEDENT> print ( t ( n ) - 3 * ( t ( n // 3 ) ) - 5 * ( t ( n // 5 ) ) + 15 * ( t ( n // 15 ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> for i in range ( 10 ** n ) : <NEWLINE> <INDENT> tmp = str ( i ) <NEWLINE> if len ( tmp ) == n : <NEWLINE> <INDENT> f = True <NEWLINE> for s , c in a : <NEWLINE> <INDENT> if tmp [ s - 1 ] != str ( c ) : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> a = int ( input ( ) ) <NEWLINE> for i in range ( 151 ) : <NEWLINE> <INDENT> b = i ** 5 - a <NEWLINE> c = abs ( b ) <NEWLINE> j = 0 <NEWLINE> while j ** 5 <= c : <NEWLINE> <INDENT> if j ** 5 == c : <NEWLINE> <INDENT> if b >= 0 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
def solve ( n , a ) : <NEWLINE> <INDENT> res , total = 0 , 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> res += total // 2 <NEWLINE> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += x <NEWLINE> <DEDENT> <DEDENT> return res + total // 2 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( solve ( n , a ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_a = max ( a ) <NEWLINE> <NL> c = { } <COMMENT> <NEWLINE> d = { } <COMMENT> <NEWLINE> for a_i in a : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c [ a_i ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> c [ a_i ] = 1 <NEWLINE> d [ a_i ] = False <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> for a_i in a : <NEWLINE> <INDENT> if c [ a_i ] > 0 : <NEWLINE> <INDENT> tmp = 2 * a_i <NEWLINE> while tmp <= max_a : <NEWLINE> <INDENT> d [ tmp ] = True <NEWLINE> tmp += a_i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a_i in a : <NEWLINE> <INDENT> if c [ a_i ] == 1 and d [ a_i ] == False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ 0 ] * ( N + 1 ) <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> count [ b ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if count [ i ] > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> diff = 0 <NEWLINE> checked = set ( ) <NEWLINE> ida = 0 <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> if b in checked : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> checked . add ( b ) <NEWLINE> while ida < N and A [ ida ] <= b : <NEWLINE> <INDENT> ida += 1 <NEWLINE> <DEDENT> diff = max ( diff , ida - i ) <NEWLINE> <NL> <NL> <DEDENT> idx = ( np . arange ( N ) - diff ) % N <NEWLINE> print ( <STRING> ) <NEWLINE> print ( * np . array ( B ) [ idx ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = [ True ] * 102 <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> flag [ i ] = False <NEWLINE> <NL> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> low = max ( x - i , 0 ) <NEWLINE> high = min ( x + i , 101 ) <NEWLINE> if flag [ low ] : <NEWLINE> <INDENT> print ( low ) <NEWLINE> break <NEWLINE> <DEDENT> elif flag [ high ] : <NEWLINE> <INDENT> print ( high ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ i ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <DEDENT> dp [ i ] = 2 ** 60 <COMMENT> <NEWLINE> if i - 1 >= 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , rec ( i - 1 ) + abs ( h [ i - 1 ] - h [ i ] ) ) <NEWLINE> <DEDENT> if i - 2 >= 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , rec ( i - 2 ) + abs ( h [ i - 2 ] - h [ i ] ) ) <NEWLINE> <DEDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> print ( rec ( N - 1 ) ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : x * y / math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M , X = il ( ) <NEWLINE> CA = [ il ( ) for _ in range ( N ) ] <NEWLINE> <NL> ret = MAX <NEWLINE> for n in range ( 1 << N ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> A = [ 0 ] * M <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> c , * alist = CA [ j ] <NEWLINE> if n >> j & 1 : <NEWLINE> <INDENT> k += c <NEWLINE> for i in range ( len ( alist ) ) : <NEWLINE> <INDENT> A [ i ] += alist [ i ] <NEWLINE> <DEDENT> <DEDENT> if all ( [ a >= X for a in A ] ) : <NEWLINE> <INDENT> ret = min ( ret , k ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if ret == MAX else ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> m , p , d = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> m -= 1 <NEWLINE> p -= 1 <NEWLINE> a = [ [ ] for i in range ( d + 1 ) ] <NEWLINE> for i in range ( d ) : a [ i ] = list ( map ( int , input ( ) ) ) <NEWLINE> s = [ [ 0 for j in range ( n ) ] for i in range ( d + 1 ) ] <NEWLINE> s [ d ] = [ i for i in range ( n ) ] <NEWLINE> for i in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : s [ i ] [ j ] = s [ i + 1 ] [ j ] <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] : s [ i ] [ j ] , s [ i ] [ j + 1 ] = s [ i ] [ j + 1 ] , s [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> k = s [ 0 ] [ m ] <NEWLINE> if k == p : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> f = False <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if ( ( s [ i ] [ j ] == k and s [ i ] [ j + 1 ] == p ) or ( s [ i ] [ j ] == p and s [ i ] [ j + 1 ] == k ) ) and ( j == 0 or a [ i ] [ j - 1 ] == 0 ) and a [ i ] [ j ] == 0 and ( j == n - 2 or a [ i ] [ j + 1 ] == 0 ) : <NEWLINE> <INDENT> print ( i + 1 , j + 1 ) <NEWLINE> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : break <NEWLINE> <DEDENT> if not f : print ( 1 ) <NEWLINE> <DEDENT>
X , Y , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> q = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> r = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> red = p [ : X ] <NEWLINE> green = q [ : Y ] <NEWLINE> <NL> red_no_eat = 0 <NEWLINE> green_no_eat = 0 <NEWLINE> for no in r : <NEWLINE> <INDENT> red_worst = red [ - red_no_eat - 1 ] if red_no_eat < X else 10 ** 10 <NEWLINE> green_worst = green [ - green_no_eat - 1 ] if green_no_eat < Y else 10 ** 10 <NEWLINE> if no > red_worst or no > green_worst : <NEWLINE> <INDENT> if red_worst < green_worst : <NEWLINE> <INDENT> red_no_eat += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> green_no_eat += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( p [ : X - red_no_eat ] ) + sum ( q [ : Y - green_no_eat ] ) + sum ( r [ : red_no_eat + green_no_eat ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> MOD = 2019 <NEWLINE> d = [ 0 ] * MOD <NEWLINE> d [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> r += int ( i ) * t <NEWLINE> r %= MOD <NEWLINE> t *= 10 <NEWLINE> t %= MOD <NEWLINE> d [ r ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in d ) ) <NEWLINE>
import math <NEWLINE> r = input ( ) <NEWLINE> r = float ( r ) <NEWLINE> s = r ** 2 * math . pi <NEWLINE> enshu = r * 2 * math . pi <NEWLINE> print ( <STRING> . format ( s ) ) <NEWLINE> print ( <STRING> . format ( enshu ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = [ 0 ] * 10010 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = ( x + y + z ) ** 2 - x * y - y * z - z * x <NEWLINE> if v <= n : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> N = int ( input ( ) ) - 1 <NEWLINE> smap = dict ( enumerate ( string . ascii_lowercase ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> d , m = divmod ( N , 26 ) <NEWLINE> res . append ( m ) <NEWLINE> if d - 1 > 25 : <NEWLINE> <INDENT> N = d - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( d - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( smap [ i ] for i in reversed ( res ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( a ) ** 2 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans -= i ** 2 <NEWLINE> <DEDENT> print ( ( ans // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import itertools <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ 0 ] <NEWLINE> arr += list ( itertools . accumulate ( a ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> c = Counter ( arr ) <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> sq_sum = sum ( map ( lambda x : x * x , A ) ) <NEWLINE> sum_sq = sum ( A ) * sum ( A ) <NEWLINE> answer = ( sum_sq - sq_sum ) // 2 <NEWLINE> <NL> print ( answer % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> l = 0 <NEWLINE> r = n - 1 <NEWLINE> ans = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> while l < n and c [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while r >= 0 and c [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if l > r : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if num_list [ i ] < num_list [ i - 1 ] : <NEWLINE> <INDENT> count += ( num_list [ i - 1 ] - num_list [ i ] ) <NEWLINE> num_list [ i ] = num_list [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = [ 0 ] * n <NEWLINE> for x in a : <NEWLINE> <INDENT> res [ x - 1 ] += 1 <NEWLINE> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> rep = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> i = 0 <NEWLINE> for b , c in rep : <NEWLINE> <INDENT> while i < n and b : <NEWLINE> <INDENT> if a [ i ] < c : <NEWLINE> <INDENT> a [ i ] = c <NEWLINE> i += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> L . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> L = sorted ( L ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if L [ i ] != L [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> nekotyann = [ 0 ] * N <NEWLINE> wanntyann = [ 0 ] * N <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> nekotyann [ b - 1 ] += 1 <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> wanntyann [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if nekotyann [ k ] != 0 and wanntyann [ k ] != 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> y = x + 1 <NEWLINE> <NL> print ( c [ y ] ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = [ i for i in range ( 1 , n ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> if p [ i - 1 ] == i : <NEWLINE> <INDENT> p [ i - 1 ] = p [ i ] <NEWLINE> p [ i ] = i <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> value_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = value_list [ i ] - cost_list [ i ] <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> total += ans <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def len_lcs ( s1 , s2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> results = [ 0 ] * len ( s1 ) <NEWLINE> <NL> for i , c2 in enumerate ( s2 ) : <NEWLINE> <INDENT> sec1 , pr1 = 0 , 0 <NEWLINE> for j , c1 in enumerate ( s1 ) : <NEWLINE> <INDENT> pr2 = results [ j ] <NEWLINE> if c1 == c2 : <NEWLINE> <INDENT> mval = pr1 + 1 <NEWLINE> <DEDENT> elif sec1 > pr2 : <NEWLINE> <INDENT> mval = sec1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mval = pr2 <NEWLINE> <NL> <DEDENT> results [ j ] = mval <NEWLINE> sec1 , pr1 = mval , pr2 <NEWLINE> <NL> <DEDENT> <DEDENT> return results [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> s . append ( line . strip ( ) ) <NEWLINE> <DEDENT> for i in range ( 0 , 2 * n , 2 ) : <NEWLINE> <INDENT> print ( len_lcs ( s [ i ] , s [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> run ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * 10001 <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + x * z <NEWLINE> if v < 10001 : <NEWLINE> <INDENT> a [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
ans = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> lim = 10 ** 18 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in set ( l ) : print ( 0 ) ; exit ( ) <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > lim : print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , itertools <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> MOD = 998244353 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def factorialMod ( n , p ) : <NEWLINE> <INDENT> fact = [ 0 ] * ( n + 1 ) <NEWLINE> fact [ 0 ] = fact [ 1 ] = 1 <NEWLINE> factinv = [ 0 ] * ( n + 1 ) <NEWLINE> factinv [ 0 ] = factinv [ 1 ] = 1 <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = ( fact [ i - 1 ] * i ) % p <NEWLINE> inv [ i ] = ( - inv [ p % i ] * ( p // i ) ) % p <NEWLINE> factinv [ i ] = ( factinv [ i - 1 ] * inv [ i ] ) % p <NEWLINE> <DEDENT> return fact , factinv <NEWLINE> <NL> <DEDENT> def combMod ( n , r , fact , factinv , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N , M , K = LI ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> fact , factinv = factorialMod ( N , MOD ) <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += combMod ( N - 1 , i , fact , factinv , MOD ) * M * pow ( M - 1 , N - 1 - i , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> alice = 0 <NEWLINE> bob = 0 <NEWLINE> <NL> A_rev = sorted ( A , reverse = True ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if len ( A_rev ) != 0 : <NEWLINE> <INDENT> alice += A_rev . pop ( 0 ) <NEWLINE> <NL> <DEDENT> if len ( A_rev ) != 0 : <NEWLINE> <INDENT> bob += A_rev . pop ( 0 ) <NEWLINE> <NL> <DEDENT> if len ( A_rev ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> k -= 1 <NEWLINE> <NL> d1 = defaultdict ( list ) <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> d1 [ c ] . append ( i ) <NEWLINE> <DEDENT> d2 = sorted ( d1 . items ( ) ) <NEWLINE> <NL> lens = len ( s ) <NEWLINE> for d2e in d2 : <NEWLINE> <INDENT> subs = set ( ) <NEWLINE> subs . add ( d2e [ 0 ] ) <NEWLINE> for d2ee in d2e [ 1 ] : <NEWLINE> <INDENT> end = min ( lens + 1 , d2ee + k + 2 ) <NEWLINE> for i1 in range ( d2ee + 1 , end ) : <NEWLINE> <INDENT> subs . add ( <STRING> . join ( s [ d2ee : i1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( subs ) > k : <NEWLINE> <INDENT> subsl = list ( subs ) <NEWLINE> subsl . sort ( ) <NEWLINE> print ( subsl [ k ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= len ( subs ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> tmp = [ i for i in nums if i % 2 == 0 ] <NEWLINE> count = 0 <NEWLINE> for i in tmp : <NEWLINE> <NL> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> i //= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = ( 1 + P [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> if N == K : <NEWLINE> <INDENT> print ( sum ( P ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> P [ i ] += P [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> T [ i ] = P [ i ] - P [ i - K ] <NEWLINE> <NL> <DEDENT> T = T [ K : ] <NEWLINE> <NL> print ( max ( T ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> str_num = input ( ) . split ( ) <NEWLINE> <NL> num_list = [ ] <NEWLINE> for i in str_num : <NEWLINE> <INDENT> num_list . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> num_list . sort ( reverse = True ) <NEWLINE> <NL> ans = num_list [ 0 ] <NEWLINE> <NL> LIMIT_NUM = 10 ** 18 <NEWLINE> <NL> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= num_list [ i ] <NEWLINE> if ans > LIMIT_NUM : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> count = 0 <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> c = collections . Counter ( prime_factorize ( N ) ) <NEWLINE> C = list ( c . items ( ) ) <NEWLINE> <NL> if len ( list ( c . keys ( ) ) ) == 1 : <NEWLINE> <INDENT> for j in range ( 1 , C [ 0 ] [ 1 ] + 1 ) : <NEWLINE> <INDENT> if N % ( C [ 0 ] [ 0 ] ** j ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> N /= C [ 0 ] [ 0 ] ** j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> for j in range ( 1 , C [ i ] [ 1 ] + 1 ) : <NEWLINE> <INDENT> if N % ( C [ i ] [ 0 ] ** j ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> N /= ( C [ i ] [ 0 ] ** j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( d , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * a * b == x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> import math <NEWLINE> if 2 * x / ( a * b ) >= a : <NEWLINE> <INDENT> ans = a / ( 2 * b - 2 * x / ( a ** 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2 * x / ( a * b ** 2 ) <NEWLINE> <DEDENT> print ( 90 - math . degrees ( math . atan ( ans ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num_case = 0 <NEWLINE> while True : <NEWLINE> <INDENT> num_case += 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( num_case ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lim = int ( N ** 0.5 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> m = N // i <NEWLINE> quotient = N // m <NEWLINE> while m != 0 : <NEWLINE> <INDENT> remainder = N % m <NEWLINE> if N // m != quotient or remainder > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if quotient == remainder : <NEWLINE> <INDENT> ans += m <NEWLINE> break <NEWLINE> <DEDENT> m -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> if a_l [ i ] > a_l [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> l = list ( set ( l ) ) <NEWLINE> print ( len ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> ans = R * G * B <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> import bisect <NEWLINE> from itertools import product <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> d = defaultdict ( list ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ s [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> def canCreate ( x , y , z ) : <NEWLINE> <INDENT> pos = 0 <NEWLINE> for c in map ( str , [ x , y , z ] ) : <NEWLINE> <INDENT> pos = bisect . bisect_left ( d [ c ] , pos ) <NEWLINE> if pos == len ( d [ c ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> pos = d [ c ] [ pos ] + 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> ans = sum ( [ canCreate ( x , y , z ) for x , y , z in product ( range ( 10 ) , repeat = 3 ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> popcount_X = X . count ( <STRING> ) <NEWLINE> numX = int ( X , 2 ) <NEWLINE> a = numX % ( popcount_X + 1 ) <NEWLINE> b = numX % ( popcount_X - 1 ) if popcount_X != 1 else 0 <NEWLINE> for i , x in enumerate ( X , 1 ) : <COMMENT> <NEWLINE> <INDENT> if x == <STRING> and popcount_X == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> ans = 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> temp = ( b - pow ( 2 , N - i , popcount_X - 1 ) ) % ( popcount_X - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( a + pow ( 2 , N - i , popcount_X + 1 ) ) % ( popcount_X + 1 ) <NEWLINE> <DEDENT> while temp : <NEWLINE> <INDENT> p = format ( temp , <STRING> ) . count ( <STRING> ) <COMMENT> <NEWLINE> temp %= p <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> n = len ( S ) <NEWLINE> <NL> if n <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 2019 <NEWLINE> s = input ( ) . rstrip ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod_list = [ 0 ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> mod_list . append ( ( mod_list [ - 1 ] + int ( s [ i ] ) * pow ( 10 , n - 1 - i , mod ) ) % mod ) <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> c = Counter ( mod_list ) <NEWLINE> ans = 0 <NEWLINE> for i in c . keys ( ) : <NEWLINE> <INDENT> ans += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> nn = N <NEWLINE> import math <NEWLINE> sq = round ( math . sqrt ( N ) ) + 1 <NEWLINE> <NL> i = 2 <NEWLINE> ans = 0 <NEWLINE> count1 = 0 <NEWLINE> count2 = 1 <NEWLINE> while sq >= i : <NEWLINE> <INDENT> if nn % i == 0 : <NEWLINE> <INDENT> nn //= i <NEWLINE> count1 += 1 <NEWLINE> if count1 == count2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> count2 += 1 <NEWLINE> count1 = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> count1 = 0 <NEWLINE> count2 = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if nn > sq : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> root = [ 1 ] <NEWLINE> setroot = set ( root ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ root [ - 1 ] - 1 ] in setroot : <NEWLINE> <INDENT> start = root . index ( A [ root [ - 1 ] - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> setroot . add ( A [ root [ - 1 ] - 1 ] ) <NEWLINE> root . append ( A [ root [ - 1 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> roop = root [ start : ] <NEWLINE> <NL> if K <= start : <NEWLINE> <INDENT> print ( root [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( root [ ( K - start ) % len ( roop ) + start ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> t = list ( ( input ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for e in t : <NEWLINE> <INDENT> sum += int ( e ) <NEWLINE> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h_t = [ 0 ] * H <NEWLINE> w_t = [ 0 ] * W <NEWLINE> t = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ ( h - 1 , w - 1 ) ] = 1 <NEWLINE> h_t [ h - 1 ] += 1 <NEWLINE> w_t [ w - 1 ] += 1 <NEWLINE> <DEDENT> h_max = max ( h_t ) <NEWLINE> h_max_list = [ i for i in range ( len ( h_t ) ) if h_t [ i ] == h_max ] <NEWLINE> w_max = max ( w_t ) <NEWLINE> w_max_list = [ i for i in range ( len ( w_t ) ) if w_t [ i ] == w_max ] <NEWLINE> <NL> for h in h_max_list : <NEWLINE> <INDENT> for w in w_max_list : <NEWLINE> <INDENT> if ( h , w ) not in t : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 ) <NEWLINE>
table = list ( <STRING> ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> ans . append ( N % 26 ) <NEWLINE> if N % 26 == 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> <DEDENT> if N // 26 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N //= 26 <NEWLINE> <DEDENT> for x in reversed ( ans ) : <NEWLINE> <INDENT> print ( table [ x - 1 ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> import math <NEWLINE> read = sys . stdin . readline <NEWLINE> <NL> N = int ( read ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , read ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> da = [ ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> da . append ( [ i , a ] ) <NEWLINE> <NL> <DEDENT> dR = { } <NEWLINE> dL = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for d in reversed ( da ) : <NEWLINE> <INDENT> r = d [ 0 ] + d [ 1 ] + 1 <NEWLINE> l = d [ 0 ] - d [ 1 ] + 1 <NEWLINE> if r in dR : <NEWLINE> <INDENT> dR [ r ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dR [ r ] = 1 <NEWLINE> <NL> <DEDENT> if r in dL : <NEWLINE> <INDENT> ans += dL [ r ] <NEWLINE> <NL> <DEDENT> if l in dL : <NEWLINE> <INDENT> dL [ l ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dL [ l ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> a = input ( ) <NEWLINE> if <STRING> not in a : print ( 0 ) ; exit ( ) <NEWLINE> a = a [ a . index ( <STRING> ) : ] <NEWLINE> b = a . count ( <STRING> ) <NEWLINE> print ( b - a [ : b ] . count ( <STRING> ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = list ( collections . Counter ( A ) . values ( ) ) <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if li [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
pi = 3.141592653589793 <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( pi * r ** 2 , 2 * pi * r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
D = 365 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> <NL> point = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> point [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if point [ i ] > q - k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = sorted ( A , reverse = True ) <NEWLINE> <NL> ans = B [ 0 ] <NEWLINE> <NL> sheets = [ B [ 0 ] ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <NL> <INDENT> ans += sheets [ i - 1 ] <NEWLINE> sheets . append ( B [ i ] ) <NEWLINE> sheets . append ( B [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> while len ( S ) > 0 : <NEWLINE> <INDENT> if len ( S ) < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> third = S [ - 3 ] <NEWLINE> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 5 or S [ - 5 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 5 ] <NEWLINE> continue <NEWLINE> <DEDENT> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 5 or S [ - 5 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 5 ] <NEWLINE> continue <NEWLINE> <DEDENT> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 7 or S [ - 7 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 7 ] <NEWLINE> continue <NEWLINE> <DEDENT> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 6 or S [ - 6 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 6 ] <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( a , reverse = True ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import * <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> f = ( c * d ) // gcd ( c , d ) <NEWLINE> r = f <NEWLINE> rock = 2 <NEWLINE> compteur = ( b // f ) - ( a // f ) <NEWLINE> if a % f == 0 : <NEWLINE> <INDENT> compteur += 1 <NEWLINE> <DEDENT> div1 = ( ( b // c ) - ( a // c ) ) <NEWLINE> div2 = ( ( b // d ) - ( a // d ) ) <NEWLINE> if a % c == 0 : <NEWLINE> <INDENT> div1 += 1 <NEWLINE> <DEDENT> if a % d == 0 : <NEWLINE> <INDENT> div2 += 1 <NEWLINE> <DEDENT> roger = ( div1 + div2 ) - compteur <NEWLINE> mm = ( b - a ) + 1 <NEWLINE> print ( mm - roger ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xa = min ( a , k ) <NEWLINE> k -= xa <NEWLINE> xb = min ( b , k ) <NEWLINE> k -= xb <NEWLINE> xc = k <NEWLINE> print ( xa - xc ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> friend = [ [ ] for _ in range ( N ) ] <NEWLINE> block = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> friend [ a - 1 ] . append ( b - 1 ) <NEWLINE> friend [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> block [ c - 1 ] . append ( d - 1 ) <NEWLINE> block [ d - 1 ] . append ( c - 1 ) <NEWLINE> <NL> <NL> <DEDENT> friendnetwork = [ ] <NEWLINE> sgn = [ 0 for _ in range ( N ) ] <NEWLINE> groupnum = 0 <NEWLINE> <NL> def makenetwork ( n , groupnum ) : <NEWLINE> <INDENT> for item in friend [ n ] : <NEWLINE> <INDENT> if sgn [ item ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sgn [ item ] = groupnum <NEWLINE> makenetwork ( item , groupnum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if sgn [ k ] == 0 : <NEWLINE> <INDENT> groupnum += 1 <NEWLINE> sgn [ k ] = groupnum <NEWLINE> makenetwork ( k , groupnum ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> friends = [ [ ] for _ in range ( groupnum ) ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> friends [ sgn [ k ] - 1 ] . append ( k ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> num = len ( friends [ sgn [ k ] - 1 ] ) - 1 - len ( friend [ k ] ) <NEWLINE> for item in block [ k ] : <NEWLINE> <INDENT> if sgn [ item ] == sgn [ k ] : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( num ) <NEWLINE> <NL> <DEDENT> a = str ( ans [ 0 ] ) <NEWLINE> for j in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> a += <STRING> + str ( ans [ j ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> NN = N <NEWLINE> li = [ ] <NEWLINE> isused = [ False ] * M <NEWLINE> while isused [ X ] == False and N != 0 : <NEWLINE> <INDENT> li . append ( X ) <NEWLINE> isused [ X ] = True <NEWLINE> X = ( X ** 2 ) % M <NEWLINE> N -= 1 <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( sum ( li ) ) <NEWLINE> <NL> <DEDENT> elif N != 0 and X in li : <NEWLINE> <INDENT> l = len ( li ) <NEWLINE> s = li . index ( X ) <NEWLINE> T = l - s <NEWLINE> q = ( NN - s ) // T <NEWLINE> r = ( NN - s ) % T <NEWLINE> print ( sum ( li ) + sum ( li [ i ] for i in range ( s , len ( li ) ) ) * ( q - 1 ) + sum ( li [ i ] for i in range ( s , s + r ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in li : <NEWLINE> <INDENT> j = i - 1 <NEWLINE> ans [ j ] = ans [ j ] + 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> asum = sum ( a ) <NEWLINE> adic = { } <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i in adic : <NEWLINE> <INDENT> adic [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adic [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in adic : <NEWLINE> <INDENT> if c not in adic : <NEWLINE> <INDENT> adic [ c ] = 0 <NEWLINE> <DEDENT> cnt = adic . pop ( b ) <NEWLINE> adic [ c ] += cnt <NEWLINE> asum += ( c - b ) * cnt <NEWLINE> <DEDENT> print ( asum ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> print ( ( N // K ) ** 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( N // K ) ** 3 <NEWLINE> k = K // 2 <NEWLINE> j = ( N + k ) // K <NEWLINE> print ( j ** 3 + ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> gcdSum = 0 <NEWLINE> myDict = { } <NEWLINE> <NL> for iIndx in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for jIndx in range ( 1 , iIndx + 1 ) : <NEWLINE> <INDENT> presGcd = math . gcd ( iIndx , jIndx ) <NEWLINE> if ( presGcd in list ( myDict . keys ( ) ) ) and ( iIndx == jIndx ) : <NEWLINE> <INDENT> myDict [ presGcd ] += 1 <NEWLINE> <DEDENT> elif ( presGcd in list ( myDict . keys ( ) ) ) and ( iIndx != jIndx ) : <NEWLINE> <INDENT> myDict [ presGcd ] += 2 <NEWLINE> <DEDENT> elif ( presGcd not in list ( myDict . keys ( ) ) ) and ( iIndx == jIndx ) : <NEWLINE> <INDENT> myDict [ presGcd ] = 1 <NEWLINE> <DEDENT> elif ( presGcd not in list ( myDict . keys ( ) ) ) and ( iIndx != jIndx ) : <NEWLINE> <INDENT> myDict [ presGcd ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for kIndx in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for keyItem in list ( myDict . keys ( ) ) : <NEWLINE> <INDENT> gcdSum += math . gcd ( keyItem , kIndx ) * myDict [ keyItem ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( gcdSum ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = tuple ( int ( n ) for n in input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] , dp [ 1 ] = 1 , 1 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ a ] = - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> if dp [ i + 2 ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dp [ i ] == - 1 and dp [ i + 1 ] == - 1 : <NEWLINE> <INDENT> dp [ i + 2 ] = - 1 <NEWLINE> <DEDENT> elif dp [ i ] == - 1 : <NEWLINE> <INDENT> dp [ i + 2 ] = dp [ i + 1 ] <NEWLINE> <DEDENT> elif dp [ i + 1 ] == - 1 : <NEWLINE> <INDENT> dp [ i + 2 ] = dp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 2 ] = dp [ i ] + dp [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] % ( 10 ** 9 + 7 ) if dp [ n ] != - 1 else 0 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ <STRING> ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if A [ s - 1 ] == <STRING> : <NEWLINE> <INDENT> A [ s - 1 ] = c <NEWLINE> <DEDENT> elif A [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if A [ 0 ] == 0 and N > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 1 and ( A [ 0 ] == <STRING> or A [ 0 ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif A [ 0 ] == <STRING> or A [ 0 ] == 0 : <NEWLINE> <INDENT> A [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> A [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if A [ 0 ] > 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * 10 ** ( N - i - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = [ int ( 0 ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a ] += 1 <NEWLINE> ans [ b ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
dataNum = 0 <NEWLINE> combNum = [ 0 ] * 100 <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n is x is 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> calcResult = a + b + c <NEWLINE> if calcResult == x : <NEWLINE> <INDENT> combNum [ dataNum ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dataNum += 1 <NEWLINE> <NL> <DEDENT> for index in range ( dataNum ) : <NEWLINE> <INDENT> print ( combNum [ index ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = n // a <NEWLINE> <DEDENT> count += b <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> temp = 0 <NEWLINE> if a == 0 and b == 0 and c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , c ) : <NEWLINE> <INDENT> for j in range ( i , c ) : <NEWLINE> <INDENT> if i * ( 100 + a ) // 100 + j * ( 100 + a ) // 100 == c : <NEWLINE> <INDENT> if temp < i * ( 100 + b ) // 100 + j * ( 100 + b ) // 100 : <NEWLINE> <INDENT> temp = i * ( 100 + b ) // 100 + j * ( 100 + b ) // 100 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( temp ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <NL> def can_be_composed ( n , min_list , max_list , m , A ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if m < min_list [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if m > max_list [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> combination_list = list ( itertools . combinations ( A , i ) ) <NEWLINE> for l in combination_list : <NEWLINE> <INDENT> if m == sum ( l ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> fin = sys . stdin <NEWLINE> <NL> n = int ( fin . readline ( ) ) <NEWLINE> A = list ( map ( int , fin . readline ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> q = int ( fin . readline ( ) ) <NEWLINE> m_list = list ( map ( int , fin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> min_list = [ 0 ] <NEWLINE> min_list [ 0 ] += A [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> min_list . append ( min_list [ i - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> max_list = [ 0 ] <NEWLINE> max_list [ 0 ] += A [ n - 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> max_list . append ( max_list [ i - 1 ] + A [ n - i - 1 ] ) <NEWLINE> <NL> <DEDENT> for m in m_list : <NEWLINE> <INDENT> if can_be_composed ( n , min_list , max_list , m , A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ss = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> if temp in ss : <NEWLINE> <INDENT> next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ss . add ( temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ss ) ) <NEWLINE>
a , n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> check_list = [ ] <NEWLINE> i = 0 <NEWLINE> if a == 0 : i = 1 <NEWLINE> while ( i + a ) ** n < m : <NEWLINE> <INDENT> check_list . append ( ( i + a ) ** n ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> for x in check_list : <NEWLINE> <INDENT> xl = [ int ( i ) for i in list ( str ( x ) ) ] <NEWLINE> y = sum ( xl ) <NEWLINE> if x == ( y + a ) ** n : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ False ] * n <NEWLINE> t = [ False ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> s [ b - 1 ] = True <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> t [ a - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == True and t [ i ] == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> a [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( a [ j ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s + <STRING> <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 and Q == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> del i [ 0 ] <NEWLINE> [ D . append ( ii ) for ii in i ] <NEWLINE> <DEDENT> if not len ( D ) == 0 : <NEWLINE> <INDENT> c = collections . Counter ( D ) <NEWLINE> cc = c . most_common ( ) <NEWLINE> <COMMENT> <NL> if cc [ 0 ] [ 1 ] >= Q : <NEWLINE> <INDENT> ans = 1000000 <NEWLINE> tmp = cc [ 0 ] [ 1 ] <NEWLINE> for i in range ( len ( cc ) ) : <NEWLINE> <INDENT> if cc [ i ] [ 1 ] == tmp : <NEWLINE> <INDENT> ans = min ( cc [ i ] [ 0 ] , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def print_row ( iterable ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( lambda x : str ( x ) . rjust ( 5 ) , iterable ) ) , <NEWLINE> <INDENT> str ( sum ( iterable ) ) . rjust ( 5 ) , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> last = [ 0 for i in range ( n ) ] <NEWLINE> for row in m : <NEWLINE> <INDENT> print_row ( row ) <NEWLINE> for ( i , e ) in enumerate ( row ) : <NEWLINE> <INDENT> last [ i ] += e <NEWLINE> <NL> <DEDENT> <DEDENT> print_row ( last ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> a_dict = { } <NEWLINE> <NL> for a in a_li : <NEWLINE> <INDENT> if str ( a ) in a_dict : <NEWLINE> <INDENT> a_dict [ str ( a ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ str ( a ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if str ( i ) in a_dict : <NEWLINE> <INDENT> print ( a_dict [ str ( i ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for i in range ( h + 1 ) ] <NEWLINE> b = [ 0 for i in range ( w + 1 ) ] <NEWLINE> <NL> v = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> v [ ( x , y ) ] = 1 <NEWLINE> a [ x ] += 1 <NEWLINE> b [ y ] += 1 <NEWLINE> <NL> <NL> <DEDENT> maxx = max ( a ) <NEWLINE> aa = [ ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == maxx : <NEWLINE> <INDENT> aa . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> maxy = max ( b ) <NEWLINE> bb = [ ] <NEWLINE> for i in range ( 1 , len ( b ) ) : <NEWLINE> <INDENT> if b [ i ] == maxy : <NEWLINE> <INDENT> bb . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( aa ) ) : <NEWLINE> <INDENT> for j in range ( len ( bb ) ) : <NEWLINE> <INDENT> if ( aa [ i ] , bb [ j ] ) in v : <NEWLINE> <INDENT> ans = max ( ans , a [ aa [ i ] ] + b [ bb [ j ] ] - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , a [ aa [ i ] ] + b [ bb [ j ] ] ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
M = 1046527 <NEWLINE> L = 14 <NEWLINE> H = [ <STRING> ] * M <NEWLINE> <NL> def getChar ( ch ) : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif ch == <STRING> : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif ch == <STRING> : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif ch == <STRING> : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def getKey ( strings ) : <NEWLINE> <INDENT> Sum = 0 <NEWLINE> p = 1 <NEWLINE> for i in xrange ( len ( strings ) ) : <NEWLINE> <INDENT> Sum += p * getChar ( strings [ i ] ) <NEWLINE> p *= 5 <NEWLINE> <NL> <DEDENT> return Sum <NEWLINE> <NL> <DEDENT> def h1 ( key ) : <NEWLINE> <INDENT> return key % M <NEWLINE> <NL> <DEDENT> def h2 ( key ) : <NEWLINE> <INDENT> return 1 + ( key % ( M - 1 ) ) <NEWLINE> <NL> <DEDENT> def find ( strings ) : <NEWLINE> <INDENT> key = getKey ( strings ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h = ( h1 ( key ) + i * h2 ( key ) ) % M <NEWLINE> if H [ h ] == strings : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( H [ h ] ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def insert ( strings ) : <NEWLINE> <INDENT> key = getKey ( strings ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h = ( h1 ( key ) + i * h2 ( key ) ) % M <NEWLINE> if H [ h ] == strings : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( H [ h ] ) == 0 : <NEWLINE> <INDENT> H [ h ] = strings <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> com = raw_input ( ) . split ( ) <NEWLINE> if com [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( com [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if find ( com [ 1 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AC = [ 0 for i in range ( N ) ] <NEWLINE> WA = [ 0 for i in range ( N ) ] <NEWLINE> a = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , S = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> AC [ p - 1 ] = 1 <NEWLINE> a [ p - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if AC [ p - 1 ] == 0 : <NEWLINE> <INDENT> WA [ p - 1 ] += 1 <NEWLINE> a [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = sum ( AC ) <NEWLINE> wa = sum ( WA ) - sum ( a ) <NEWLINE> print ( c , wa , sep = <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> a . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ - 1 ] != s [ - 1 ] : <NEWLINE> <INDENT> a . append ( s [ - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( len ( a ) ) <NEWLINE> <DEDENT>
N , X , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ 0 ] * ( M + 1 ) <NEWLINE> firstApearAt = { i : 0 for i in range ( M ) } <NEWLINE> A [ 1 ] = X <NEWLINE> firstApearAt [ X ] = 1 <NEWLINE> l , r = 1 , 2 <NEWLINE> for i in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> A [ i ] = ( A [ i - 1 ] * A [ i - 1 ] ) % M <NEWLINE> if firstApearAt [ A [ i ] ] > 0 : <NEWLINE> <INDENT> r = i <NEWLINE> l = firstApearAt [ A [ i ] ] <NEWLINE> break <NEWLINE> <DEDENT> firstApearAt [ A [ i ] ] = i <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> if N <= l - 1 : <NEWLINE> <INDENT> ans = sum ( A [ 1 : N + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q , p = ( N - l + 1 ) // ( r - l ) , ( N - l + 1 ) % ( r - l ) <NEWLINE> ans = sum ( A [ 1 : l ] ) + q * sum ( A [ l : r ] ) + sum ( A [ l : l + p ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = sum ( A ) <NEWLINE> count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> A = list ( set ( A ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = S - B * count [ B ] + C * count [ B ] <NEWLINE> count [ C ] += count [ B ] <NEWLINE> count [ B ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += y * ( y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumval = 0 <NEWLINE> for e in a : <NEWLINE> <INDENT> sumval = sumval ^ e <NEWLINE> <DEDENT> for e in a : <NEWLINE> <INDENT> print ( sumval ^ e , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> F = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> F [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> P = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = - 10 ** 10 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , 2 ** 10 ) : <COMMENT> <NEWLINE> <INDENT> open_n = [ 0 ] * N <NEWLINE> profit = 0 <NEWLINE> for j in range ( 10 ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( N ) : <COMMENT> <NEWLINE> <INDENT> if F [ k ] [ j ] == 1 : <NEWLINE> <INDENT> open_n [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in range ( N ) : <NEWLINE> <INDENT> profit += P [ l ] [ open_n [ l ] ] <NEWLINE> <DEDENT> if ans < profit : <NEWLINE> <INDENT> ans = profit <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 for i in range ( N ) ] <NEWLINE> A . sort ( ) <NEWLINE> i = 0 <NEWLINE> while i < N - 1 : <NEWLINE> <INDENT> C [ A [ i ] - 1 ] = C [ A [ i ] - 1 ] + 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> for i in C : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> while K : <NEWLINE> <INDENT> if K & 1 : <NEWLINE> <INDENT> c = A [ c ] <NEWLINE> <DEDENT> A = [ A [ A [ i ] ] for i in range ( len ( A ) ) ] <NEWLINE> K >>= 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def reversedeq ( deq ) : <NEWLINE> <INDENT> newdeq = deque ( ) <NEWLINE> for _ in range ( len ( deq ) ) : <NEWLINE> <INDENT> c = deq . pop ( ) <NEWLINE> newdeq . append ( c ) <NEWLINE> <NL> <DEDENT> return newdeq <NEWLINE> <NL> <NL> <DEDENT> S = deque ( list ( input ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> reverse_state = False <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> Query = [ x for x in input ( ) . split ( ) ] <NEWLINE> if len ( Query ) == 1 : <NEWLINE> <INDENT> reverse_state = reverse_state ^ 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if reverse_state : <NEWLINE> <INDENT> if Query [ 1 ] == <STRING> : <NEWLINE> <INDENT> S . append ( Query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( Query [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Query [ 1 ] == <STRING> : <NEWLINE> <INDENT> S . appendleft ( Query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( Query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if reverse_state : <NEWLINE> <INDENT> S = reversedeq ( S ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> ( x1 , y1 , x2 , y2 ) = [ float ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> d = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> bin_X = int ( X , 2 ) <NEWLINE> cnt = 0 <NEWLINE> for i in X : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def bit_count ( bits ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while bits : <NEWLINE> <INDENT> bits = bits & ( bits - 1 ) <NEWLINE> bits >> 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def pop_counter ( n ) : <NEWLINE> <INDENT> return n % bit_count ( n ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> xp = bin_X % ( cnt + 1 ) <NEWLINE> if cnt != 1 : <NEWLINE> <INDENT> xm = bin_X % ( cnt - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xm = 0 <NEWLINE> <DEDENT> for n , i in enumerate ( X ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> tmp = xp + pow ( 2 , N - n - 1 , cnt + 1 ) <NEWLINE> tmp %= cnt + 1 <NEWLINE> <DEDENT> elif cnt != 1 : <NEWLINE> <INDENT> tmp = xm - pow ( 2 , N - n - 1 , cnt - 1 ) <NEWLINE> tmp %= cnt - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while tmp != 0 : <NEWLINE> <INDENT> tmp = pop_counter ( tmp ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ 0 ] * n <NEWLINE> d = defaultdict ( list ) <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> visited [ n ] = 1 <NEWLINE> <COMMENT> <NL> for i in d [ n ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> r = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= a_list [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i ** 5 + j ** 5 == x : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> select = 0 <NEWLINE> a . sort ( reverse = True ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] / sum ( a ) >= 1 / ( 4 * m ) : <NEWLINE> <INDENT> select = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> select = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if select == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> as_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 for _ in range ( n ) ] <NEWLINE> for a in as_ : <NEWLINE> <INDENT> l [ a - 1 ] += 1 <NEWLINE> <DEDENT> for c in l : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 * 2 ) <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> top = - 1 <NEWLINE> hist = [ ] <NEWLINE> finished = [ True ] + [ False for _ in range ( N ) ] <NEWLINE> seen = [ True ] + [ False for _ in range ( N ) ] <NEWLINE> <NL> def dfs ( cur ) : <NEWLINE> <INDENT> global hist , finished , seen , top <NEWLINE> hist . append ( cur ) <NEWLINE> seen [ cur ] = True <NEWLINE> nex = A [ cur ] <NEWLINE> if seen [ nex ] and not finished [ nex ] : <NEWLINE> <INDENT> top = nex <NEWLINE> return <NEWLINE> <DEDENT> dfs ( nex ) <NEWLINE> if not top == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> hist . pop ( ) <NEWLINE> finished [ cur ] = True <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> cycle = [ ] <NEWLINE> while not hist == [ ] : <NEWLINE> <INDENT> i = hist . pop ( ) <NEWLINE> cycle . append ( i ) <NEWLINE> if i == top : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> cycle . reverse ( ) <NEWLINE> <NL> cur = 1 <NEWLINE> while not cur == top and not K == 0 : <NEWLINE> <INDENT> cur = A [ cur ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> if cur == top : <NEWLINE> <INDENT> cur = cycle [ K % len ( cycle ) ] <NEWLINE> <NL> <DEDENT> print ( cur ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> init = sum ( A ) <NEWLINE> A = Counter ( A ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ C ] += A [ B ] <NEWLINE> init = init - ( B * A [ B ] ) + ( C * A [ B ] ) <NEWLINE> print ( init ) <NEWLINE> A [ B ] = 0 <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> i = A [ 0 ] <NEWLINE> ok = True <NEWLINE> R = [ 1 ] <NEWLINE> seen = [ 0 ] * N <NEWLINE> seen [ 0 ] = 1 <NEWLINE> count = 1 <NEWLINE> <NL> if A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while ok : <NEWLINE> <INDENT> count += 1 <NEWLINE> seen [ i - 1 ] += count <NEWLINE> R . append ( i ) <NEWLINE> i = A [ i - 1 ] <NEWLINE> <COMMENT> <NL> if seen [ i - 1 ] != 0 : <NEWLINE> <INDENT> k = seen [ i - 1 ] <NEWLINE> loop = R [ k - 1 : ] <NEWLINE> remain = R [ : k - 1 ] <NEWLINE> ok = False <NEWLINE> <NL> <DEDENT> <DEDENT> L = len ( loop ) <NEWLINE> <NL> if K < len ( remain ) : <NEWLINE> <INDENT> print ( remain [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( K - len ( remain ) ) % L ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ A [ 0 ] ] + [ b for a , b in zip ( A , A [ 1 : ] ) if a != b ] <NEWLINE> <NL> if len ( A ) < 2 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> diff = [ a - b for a , b in zip ( A [ 1 : ] , A ) ] <NEWLINE> B = [ A [ 0 ] ] if diff [ 0 ] > 0 else [ ] <NEWLINE> <NL> for i , ( d1 , d2 ) in enumerate ( zip ( diff , diff [ 1 : ] ) , start = 1 ) : <NEWLINE> <INDENT> if d1 * d2 < 0 : <NEWLINE> <INDENT> B . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> B . append ( A [ - 1 ] ) <NEWLINE> t = iter ( B ) <NEWLINE> c = 1000 <NEWLINE> for a , b in zip ( t , t ) : <NEWLINE> <INDENT> c = c // a * b + c % a <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> dp = [ float ( <STRING> ) for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if j < c [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( dp [ j - c [ i ] ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> dp [ j ] = min ( temp ) <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> from heapq import heappush , heappop <NEWLINE> solution = [ i + 1 for i in range ( 15 ) ] + [ 0 ] <NEWLINE> sol_idx = ( 15 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ) <NEWLINE> MAX_DEPTH = 45 <NEWLINE> count = 0 <NEWLINE> neighbor = ( <NEWLINE> <INDENT> ( 1 , 4 ) , <NEWLINE> ( 0 , 2 , 5 ) , <NEWLINE> ( 1 , 6 , 3 ) , <NEWLINE> ( 2 , 7 ) , <NEWLINE> ( 0 , 5 , 8 ) , <NEWLINE> ( 1 , 4 , 6 , 9 ) , <NEWLINE> ( 2 , 5 , 7 , 10 ) , <NEWLINE> ( 3 , 6 , 11 ) , <NEWLINE> ( 4 , 9 , 12 ) , <NEWLINE> ( 5 , 8 , 10 , 13 ) , <NEWLINE> ( 6 , 9 , 11 , 14 ) , <NEWLINE> ( 7 , 10 , 15 ) , <NEWLINE> ( 8 , 13 ) , <NEWLINE> ( 9 , 12 , 14 ) , <NEWLINE> ( 10 , 13 , 15 ) , <NEWLINE> ( 11 , 14 ) <NEWLINE> <INDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> distance = ( <NEWLINE> <INDENT> ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEWLINE> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) , <NEWLINE> ( 6 , 5 , 4 , 3 , 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 ) <NEWLINE> <INDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_diff ( B ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> for i , v in enumerate ( B ) : <NEWLINE> <INDENT> diff += distance [ v ] [ i ] <NEWLINE> <DEDENT> return diff <NEWLINE> <NL> <DEDENT> def get_next_board ( board , space , prev ) : <NEWLINE> <INDENT> for nxt in neighbor [ space ] : <NEWLINE> <INDENT> if nxt == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = board [ : ] <NEWLINE> b [ space ] , b [ nxt ] = b [ nxt ] , 0 <NEWLINE> yield b , nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def answer_is_odd ( board ) : <NEWLINE> <INDENT> return sum ( divmod ( board . index ( 0 ) , 4 ) ) % 2 <NEWLINE> <NL> <DEDENT> def search ( board ) : <NEWLINE> <INDENT> lower = get_diff ( board ) <NEWLINE> start_depth = lower <NEWLINE> if ( lower % 2 ) ^ answer_is_odd ( board ) : <NEWLINE> <INDENT> start_depth += 1 <NEWLINE> <DEDENT> for limit in range ( start_depth , MAX_DEPTH + 1 , 2 ) : <NEWLINE> <INDENT> get_next ( board , limit , 0 , board . index ( 0 ) , None , lower ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> return limit <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get_next ( board , limit , move , space , prev , lower ) : <NEWLINE> <INDENT> if move == limit : <NEWLINE> <INDENT> if board == solution : <NEWLINE> <INDENT> global count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for b , nxt in get_next_board ( board , space , prev ) : <NEWLINE> <INDENT> p = board [ nxt ] <NEWLINE> new_lower = lower - distance [ p ] [ nxt ] + distance [ p ] [ space ] <NEWLINE> if new_lower + move <= limit : <NEWLINE> <INDENT> get_next ( b , limit , move + 1 , nxt , space , new_lower ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> boad = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> boad . extend ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( search ( boad ) ) <NEWLINE> exit ( ) <NEWLINE>
import random <NEWLINE> <NL> def primesbelow ( N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> correction = N % 6 > 1 <NEWLINE> N = { 0 : N , 1 : N - 1 , 2 : N + 4 , 3 : N + 3 , 4 : N + 2 , 5 : N + 1 } [ N % 6 ] <NEWLINE> sieve = [ True ] * ( N // 3 ) <NEWLINE> sieve [ 0 ] = False <NEWLINE> for i in range ( int ( N ** .5 ) // 3 + 1 ) : <NEWLINE> <INDENT> if sieve [ i ] : <NEWLINE> <INDENT> k = ( 3 * i + 1 ) | 1 <NEWLINE> sieve [ k * k // 3 : : 2 * k ] = [ False ] * ( ( N // 6 - ( k * k ) // 6 - 1 ) // k + 1 ) <NEWLINE> sieve [ ( k * k + 4 * k - 2 * k * ( i % 2 ) ) // 3 : : 2 * k ] = [ False ] * ( ( N // 6 - ( k * k + 4 * k - 2 * k * ( i % 2 ) ) // 6 - 1 ) // k + 1 ) <NEWLINE> <DEDENT> <DEDENT> return [ 2 , 3 ] + [ ( 3 * i + 1 ) | 1 for i in range ( 1 , N // 3 - correction ) if sieve [ i ] ] <NEWLINE> <NL> <DEDENT> smallprimeset = set ( primesbelow ( 100000 ) ) <NEWLINE> _smallprimeset = 100000 <NEWLINE> def isprime ( n , precision = 7 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if n < 1 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> elif n <= 3 : <NEWLINE> <INDENT> return n >= 2 <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n < _smallprimeset : <NEWLINE> <INDENT> return n in smallprimeset <NEWLINE> <NL> <NL> <DEDENT> d = n - 1 <NEWLINE> s = 0 <NEWLINE> while d % 2 == 0 : <NEWLINE> <INDENT> d //= 2 <NEWLINE> s += 1 <NEWLINE> <NL> <DEDENT> for repeat in range ( precision ) : <NEWLINE> <INDENT> a = random . randrange ( 2 , n - 2 ) <NEWLINE> x = pow ( a , d , n ) <NEWLINE> <NL> if x == 1 or x == n - 1 : continue <NEWLINE> <NL> for r in range ( s - 1 ) : <NEWLINE> <INDENT> x = pow ( x , 2 , n ) <NEWLINE> if x == 1 : return False <NEWLINE> if x == n - 1 : break <NEWLINE> <DEDENT> else : return False <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def pollard_brent ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : return 2 <NEWLINE> if n % 3 == 0 : return 3 <NEWLINE> <NL> y , c , m = random . randint ( 1 , n - 1 ) , random . randint ( 1 , n - 1 ) , random . randint ( 1 , n - 1 ) <NEWLINE> g , r , q = 1 , 1 , 1 <NEWLINE> while g == 1 : <NEWLINE> <INDENT> x = y <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> y = ( pow ( y , 2 , n ) + c ) % n <NEWLINE> <NL> <DEDENT> k = 0 <NEWLINE> while k < r and g == 1 : <NEWLINE> <INDENT> ys = y <NEWLINE> for i in range ( min ( m , r - k ) ) : <NEWLINE> <INDENT> y = ( pow ( y , 2 , n ) + c ) % n <NEWLINE> q = q * abs ( x - y ) % n <NEWLINE> <DEDENT> g = gcd ( q , n ) <NEWLINE> k += m <NEWLINE> <DEDENT> r *= 2 <NEWLINE> <DEDENT> if g == n : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> ys = ( pow ( ys , 2 , n ) + c ) % n <NEWLINE> g = gcd ( abs ( x - ys ) , n ) <NEWLINE> if g > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return g <NEWLINE> <NL> <DEDENT> smallprimes = primesbelow ( 1000 ) <COMMENT> <NEWLINE> def primefactors ( n , sort = False ) : <NEWLINE> <INDENT> factors = [ ] <NEWLINE> <NL> for checker in smallprimes : <NEWLINE> <INDENT> while n % checker == 0 : <NEWLINE> <INDENT> factors . append ( checker ) <NEWLINE> n //= checker <NEWLINE> <DEDENT> if checker > n : break <NEWLINE> <NL> <DEDENT> if n < 2 : return factors <NEWLINE> <NL> while n > 1 : <NEWLINE> <INDENT> if isprime ( n ) : <NEWLINE> <INDENT> factors . append ( n ) <NEWLINE> break <NEWLINE> <DEDENT> factor = pollard_brent ( n ) <COMMENT> <NEWLINE> factors . extend ( primefactors ( factor ) ) <COMMENT> <NEWLINE> n //= factor <NEWLINE> <NL> <DEDENT> if sort : factors . sort ( ) <NEWLINE> <NL> return factors <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> factors = { } <NEWLINE> for p1 in primefactors ( n ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> factors [ p1 ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> factors [ p1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> return factors <NEWLINE> <NL> <DEDENT> totients = { } <NEWLINE> def totient ( n ) : <NEWLINE> <INDENT> if n == 0 : return 1 <NEWLINE> <NL> try : return totients [ n ] <NEWLINE> except KeyError : pass <NEWLINE> <NL> tot = 1 <NEWLINE> for p , exp in factorization ( n ) . items ( ) : <NEWLINE> <INDENT> tot *= ( p - 1 ) * p ** ( exp - 1 ) <NEWLINE> <NL> <DEDENT> totients [ n ] = tot <NEWLINE> return tot <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == b : return a <NEWLINE> while b > 0 : a , b = b , a % b <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return abs ( ( a // gcd ( a , b ) ) * b ) <NEWLINE> <DEDENT> l = [ 0 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> choice = 0 <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> dic = factorization ( N ) <NEWLINE> <NL> for key in dic . keys ( ) : <NEWLINE> <INDENT> ans += l [ dic [ key ] ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> if s [ x ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ x ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> rgb = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> rgb = rgb - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rgb ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> tenbo_height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj_height = [ 0 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> road = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj_height [ road [ 0 ] - 1 ] = max ( adj_height [ road [ 0 ] - 1 ] , tenbo_height [ road [ 1 ] - 1 ] ) <NEWLINE> adj_height [ road [ 1 ] - 1 ] = max ( adj_height [ road [ 1 ] - 1 ] , tenbo_height [ road [ 0 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> good_tenbo = 0 <NEWLINE> for tenbo in range ( N ) : <NEWLINE> <INDENT> if ( ( tenbo_height [ tenbo ] > adj_height [ tenbo ] ) ) or ( adj_height [ tenbo ] == 0 ) : <NEWLINE> <INDENT> good_tenbo += 1 <NEWLINE> <DEDENT> <DEDENT> print ( good_tenbo ) <NEWLINE>
import math <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> L = lcm ( N , M ) <NEWLINE> d = { } <NEWLINE> s = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ str ( i * ( L // N ) ) ] = S [ i ] <NEWLINE> s . add ( str ( i * ( L // N ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> key = str ( i * ( L // M ) ) <NEWLINE> if key in s : <NEWLINE> <INDENT> if d [ key ] != T [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( L ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list = sorted ( A_list ) <NEWLINE> B_list = sorted ( B_list ) <NEWLINE> C_list = sorted ( C_list ) <NEWLINE> cnt = 0 <NEWLINE> <NL> def is_ok ( arg ) : <COMMENT> <NEWLINE> <INDENT> return A_list [ arg ] < B_list [ i ] <NEWLINE> <NL> <DEDENT> def bisect ( ng , ok ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> def is_ok2 ( arg ) : <COMMENT> <NEWLINE> <INDENT> return C_list [ arg ] > B_list [ i ] <NEWLINE> <NL> <DEDENT> def bisect2 ( ng , ok ) : <NEWLINE> <INDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok2 ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> A_key = bisect ( len ( A_list ) , 0 ) <NEWLINE> if A_list [ A_key ] < B_list [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> C_key = bisect2 ( - 1 , len ( C_list ) - 1 ) <NEWLINE> if B_list [ i ] < C_list [ C_key ] : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += ( n - C_key ) * ( A_key + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> h , remainder = divmod ( x , 60 * 60 ) <NEWLINE> m , s = divmod ( remainder , 60 ) <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> A [ i ] = list ( map ( lambda x : x - 1 , map ( int , readline ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> candi = set ( range ( N ) ) <NEWLINE> <NL> day = 0 <NEWLINE> while candi : <NEWLINE> <INDENT> day += 1 <NEWLINE> nex = set ( ) <NEWLINE> done = set ( ) <NEWLINE> for player in candi : <NEWLINE> <INDENT> if player in done : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if len ( A [ player ] ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rival = A [ player ] [ - 1 ] <NEWLINE> if rival in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ rival ] [ - 1 ] == player : <NEWLINE> <COMMENT> <NL> <INDENT> A [ player ] . pop ( ) <NEWLINE> A [ rival ] . pop ( ) <NEWLINE> if A [ player ] : <NEWLINE> <INDENT> nex . add ( player ) <NEWLINE> <DEDENT> done . add ( player ) <NEWLINE> if A [ rival ] : <NEWLINE> <INDENT> nex . add ( rival ) <NEWLINE> <DEDENT> done . add ( rival ) <NEWLINE> <DEDENT> <DEDENT> if len ( done ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> candi = nex <NEWLINE> <NL> <DEDENT> print ( day ) <NEWLINE>
import re <NEWLINE> print ( <STRING> if re . match ( <STRING> , input ( ) ) else <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> total = sum ( a ) <NEWLINE> if total / ( 4 * m ) > a [ - m ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> s = ( a * x ) // b - a * ( x // b ) <NEWLINE> print ( s ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> sum1 = 1 <NEWLINE> <NL> if <STRING> in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> sum1 = sum1 * int ( b [ i ] ) <NEWLINE> if sum1 > 10 ** 18 : <NEWLINE> <INDENT> sum1 = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tmp = ( n * ( n - 1 ) ) // 2 <NEWLINE> print ( tmp ) <NEWLINE>
X , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if len ( l ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif X not in l : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if X - i not in l : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif X + i not in l : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ta , tb = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] = ta - 1 <NEWLINE> B [ i ] = tb - 1 <NEWLINE> <NL> <DEDENT> ans = [ True ] * N <NEWLINE> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ans [ A [ i ] ] = H [ A [ i ] ] > H [ B [ i ] ] and ans [ A [ i ] ] <NEWLINE> ans [ B [ i ] ] = H [ B [ i ] ] > H [ A [ i ] ] and ans [ B [ i ] ] <NEWLINE> <NL> <DEDENT> print ( ans . count ( True ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , bisect <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> A = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> n = A [ 0 ] <NEWLINE> A = A [ 1 : ] <NEWLINE> L = A [ : 1 ] <NEWLINE> for a_i in A [ 1 : ] : <NEWLINE> <INDENT> if a_i > L [ - 1 ] : <NEWLINE> <INDENT> L . append ( a_i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = bisect . bisect_left ( L , a_i ) <NEWLINE> L [ j ] = a_i <NEWLINE> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a , b = il ( ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for n in reversed ( range ( N ) ) : <NEWLINE> <INDENT> if ( A [ n ] + ret ) % B [ n ] == 0 : continue <NEWLINE> else : <NEWLINE> <INDENT> ret += B [ n ] - ( ( A [ n ] + ret ) % B [ n ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> index6 , index9 , num6 , num9 = 0 , 0 , 0 , 0 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> a = [ INF for _ in range ( n + 1 ) ] <NEWLINE> a [ n ] = 0 <NEWLINE> <NL> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 1 <NEWLINE> while i - 9 ** j >= 0 : <NEWLINE> <INDENT> a [ i - 9 ** j ] = min ( a [ i ] + 1 , a [ i - 9 ** j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> j = 1 <NEWLINE> while i - 6 ** j >= 0 : <NEWLINE> <INDENT> a [ i - 6 ** j ] = min ( a [ i ] + 1 , a [ i - 6 ** j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> if i - 1 >= 0 : <NEWLINE> <INDENT> a [ i - 1 ] = min ( a [ i ] + 1 , a [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] ) <NEWLINE>
import sys <NEWLINE> from functools import reduce <NEWLINE> <NL> def main ( n , m , k , a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> bestScore = 0 <NEWLINE> _k = 0 <NEWLINE> _ai = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if _ai >= n or _k + a [ _ai ] > k : <NEWLINE> <INDENT> bestScore = _ai <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _k = _k + a [ _ai ] <NEWLINE> _ai = _ai + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> _bi = 0 <NEWLINE> <NL> while _bi < m : <NEWLINE> <INDENT> _k = _k + b [ _bi ] <NEWLINE> <NL> while _k > k and _ai - 1 >= 0 : <NEWLINE> <INDENT> _k = _k - a [ _ai - 1 ] <NEWLINE> _ai = _ai - 1 <NEWLINE> <NL> <DEDENT> if _k > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> _bi = _bi + 1 <NEWLINE> <NL> if _ai + _bi > bestScore : <NEWLINE> <INDENT> bestScore = _ai + _bi <NEWLINE> <NL> <DEDENT> <DEDENT> return bestScore <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M , K = map ( int , sys . stdin . readline ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> B = list ( map ( int , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> print ( main ( N , M , K , A , B ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> from functools import lru_cache <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> INF = 10 ** 18 <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dp ( idx , n ) : <NEWLINE> <INDENT> if idx >= N : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if N - idx + 2 < 2 * n : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return max ( nums [ idx : ] ) <NEWLINE> <DEDENT> return max ( nums [ idx ] + dp ( idx + 2 , n - 1 ) , dp ( idx + 1 , n ) ) <NEWLINE> <DEDENT> print ( dp ( 0 , N // 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( input ( ) [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a = list ( map ( int , a ) ) <NEWLINE> ans = 1 <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for calc in a : <NEWLINE> <INDENT> ans *= calc <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( list ( int ( input ( ) ) for i in range ( m ) ) ) <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % p <NEWLINE> if i in a : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL>
from collections import deque <NEWLINE> from typing import List <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> r = list ( input ( ) ) <NEWLINE> g . append ( r ) <NEWLINE> <DEDENT> print ( mm ( h , w , g ) ) <NEWLINE> <NL> <NL> <DEDENT> def mm ( h : int , w : int , g : List [ List [ str ] ] ) -> int : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( g [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = set ( ) <NEWLINE> q = deque ( [ ( i , j , 0 ) ] ) <NEWLINE> v . add ( ( i , j ) ) <NEWLINE> while q : <NEWLINE> <INDENT> ii , jj , cnt = q . popleft ( ) <NEWLINE> ret = max ( ret , cnt ) <NEWLINE> <COMMENT> <NL> if ii < h - 1 and g [ ii + 1 ] [ jj ] == <STRING> and ( ii + 1 , jj ) not in v : <NEWLINE> <INDENT> q . append ( ( ii + 1 , jj , cnt + 1 ) ) <NEWLINE> v . add ( ( ii + 1 , jj ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if jj < w - 1 and g [ ii ] [ jj + 1 ] == <STRING> and ( ii , jj + 1 ) not in v : <NEWLINE> <INDENT> q . append ( ( ii , jj + 1 , cnt + 1 ) ) <NEWLINE> v . add ( ( ii , jj + 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if ii > 0 and g [ ii - 1 ] [ jj ] == <STRING> and ( ii - 1 , jj ) not in v : <NEWLINE> <INDENT> q . append ( ( ii - 1 , jj , cnt + 1 ) ) <NEWLINE> v . add ( ( ii - 1 , jj ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if jj > 0 and g [ ii ] [ jj - 1 ] == <STRING> and ( ii , jj - 1 ) not in v : <NEWLINE> <INDENT> q . append ( ( ii , jj - 1 , cnt + 1 ) ) <NEWLINE> v . add ( ( ii , jj - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> ans [ S ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> rgb = input ( ) <NEWLINE> <NL> r = rgb . count ( <STRING> ) <NEWLINE> g = rgb . count ( <STRING> ) <NEWLINE> b = rgb . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> a = i + k <NEWLINE> b = a + k <NEWLINE> if b >= n : break <NEWLINE> if rgb [ i ] != rgb [ a ] and rgb [ i ] != rgb [ b ] and rgb [ a ] != rgb [ b ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> seen = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> length = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( [ i , j ] ) <NEWLINE> seen [ i ] [ j ] = 1 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> ci , cj = q . get ( ) <NEWLINE> for ni , nj in [ [ ci - 1 , cj ] , [ ci + 1 , cj ] , [ ci , cj - 1 ] , [ ci , cj + 1 ] ] : <NEWLINE> <INDENT> if 0 <= ni < h and 0 <= nj < w and s [ ni ] [ nj ] == <STRING> and seen [ ni ] [ nj ] == 0 : <NEWLINE> <INDENT> q . put ( [ ni , nj ] ) <NEWLINE> length [ ni ] [ nj ] = length [ ci ] [ cj ] + 1 <NEWLINE> seen [ ni ] [ nj ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , length [ ci ] [ cj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> while n : <NEWLINE> <INDENT> s += int ( n [ - 1 ] ) <NEWLINE> n = n [ : - 1 ] <NEWLINE> <NL> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * ( k * ( k + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> start = 1 <NEWLINE> now = start <NEWLINE> c = 0 <NEWLINE> flag = [ - 1 ] * ( n + 1 ) <NEWLINE> while c < k and flag [ now ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> flag [ now ] = c <NEWLINE> c += 1 <NEWLINE> now = a [ now ] <NEWLINE> <COMMENT> <NL> <DEDENT> if c == k : <NEWLINE> <INDENT> print ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= c <NEWLINE> cc = c - flag [ now ] <NEWLINE> nokori = k % cc <NEWLINE> for i in range ( nokori ) : <NEWLINE> <INDENT> now = a [ now ] <NEWLINE> <DEDENT> print ( now ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Lum = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> @ jit ( <STRING> ) <NEWLINE> def fn ( N , K , A ) : <NEWLINE> <INDENT> K1 = min ( K , 41 ) <NEWLINE> for i1 in range ( K1 ) : <NEWLINE> <INDENT> B = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = min ( N - 1 , i + A [ i ] ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <DEDENT> A = B <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> Lum = list ( fn ( N , K , Lum ) ) <NEWLINE> Lum = [ str ( l ) for l in Lum ] <NEWLINE> Lum = <STRING> . join ( Lum ) <NEWLINE> print ( Lum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * k * ( k + 1 ) // 2 <NEWLINE> if i != k : <NEWLINE> <INDENT> l = n // ( i + 1 ) <NEWLINE> ans += i * ( i + 1 ) * ( k + l + 1 ) * ( k - l ) // 4 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) + <STRING> for _ in range ( H ) ] <NEWLINE> S . append ( <STRING> * ( W + 1 ) ) <NEWLINE> <NL> todo = deque ( ) <NEWLINE> done = set ( ) <NEWLINE> ans = 0 <NEWLINE> for sh in range ( H ) : <NEWLINE> <INDENT> for sw in range ( W ) : <NEWLINE> <INDENT> if S [ sh ] [ sw ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = ( sh , sw ) <NEWLINE> done . clear ( ) <NEWLINE> done . add ( s ) <NEWLINE> todo . append ( ( s , 0 ) ) <NEWLINE> while todo : <NEWLINE> <INDENT> p , count = todo . popleft ( ) <NEWLINE> ncount = count + 1 <NEWLINE> for dh , dw in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nh , nw = p [ 0 ] + dh , p [ 1 ] + dw <NEWLINE> if S [ nh ] [ nw ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> np = ( nh , nw ) <NEWLINE> if np in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> done . add ( np ) <NEWLINE> ans = max ( ans , ncount ) <NEWLINE> todo . append ( ( np , ncount ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = [ list ( map ( int , list ( input ( ) . split ( ) ) ) ) for i in range ( m ) ] <NEWLINE> <NL> d = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d [ k [ i ] [ 0 ] - 1 ] = max ( d [ k [ i ] [ 0 ] - 1 ] , h [ k [ i ] [ 1 ] - 1 ] ) <NEWLINE> d [ k [ i ] [ 1 ] - 1 ] = max ( d [ k [ i ] [ 1 ] - 1 ] , h [ k [ i ] [ 0 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > d [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class BinarySearchTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , z ) : <NEWLINE> <INDENT> p = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> p = x <NEWLINE> if z . key < x . key : x = x . left <NEWLINE> else : x = x . right <NEWLINE> <DEDENT> z . p = p <NEWLINE> if p == None : self . root = z <NEWLINE> elif z . key < p . key : p . left = z <NEWLINE> else : p . right = z <NEWLINE> <DEDENT> def get_inorder_list ( self ) : <NEWLINE> <INDENT> def _get_inorder_list ( root ) : <NEWLINE> <INDENT> l = root . left <NEWLINE> r = root . right <NEWLINE> if l : yield from _get_inorder_list ( l ) <NEWLINE> yield root . key <NEWLINE> if r : yield from _get_inorder_list ( r ) <NEWLINE> <DEDENT> yield from _get_inorder_list ( self . root ) <NEWLINE> <DEDENT> def get_preorder_list ( self ) : <NEWLINE> <INDENT> def _get_preorder_list ( root ) : <NEWLINE> <INDENT> l = root . left <NEWLINE> r = root . right <NEWLINE> yield root . key <NEWLINE> if l : yield from _get_preorder_list ( l ) <NEWLINE> if r : yield from _get_preorder_list ( r ) <NEWLINE> <DEDENT> yield from _get_preorder_list ( self . root ) <NEWLINE> <DEDENT> def find ( self , k ) : <NEWLINE> <INDENT> def _find ( k , x ) : <NEWLINE> <INDENT> if x == None : return False <NEWLINE> if k == x . key : return True <NEWLINE> if k < x . key : return _find ( k , x . left ) <NEWLINE> return _find ( k , x . right ) <NEWLINE> <DEDENT> return _find ( k , self . root ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , k ) : <NEWLINE> <INDENT> self . key = k <NEWLINE> self . p = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> <NL> T = BinarySearchTree ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> op = input ( ) . split ( ) <NEWLINE> if op [ 0 ] == <STRING> : T . insert ( Node ( int ( op [ 1 ] ) ) ) <NEWLINE> elif op [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if T . find ( int ( op [ 1 ] ) ) else <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , * T . get_inorder_list ( ) ) <NEWLINE> print ( <STRING> , * T . get_preorder_list ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> def now_place ( li , n ) : <NEWLINE> <INDENT> now = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now = li [ now - 1 ] <NEWLINE> <DEDENT> return now <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def root ( li , p ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> now = 1 <NEWLINE> for j in range ( p ) : <NEWLINE> <INDENT> ans . append ( now_place ( li , j + 1 ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> n , k = MI ( ) <NEWLINE> a = LI ( ) <NEWLINE> <COMMENT> <NL> town = [ ] <NEWLINE> <COMMENT> <NL> visit = [ 0 ] * n <NEWLINE> p = 1 <NEWLINE> while visit [ p - 1 ] == 0 : <NEWLINE> <INDENT> town . append ( p ) <NEWLINE> visit [ p - 1 ] = 1 <NEWLINE> p = a [ p - 1 ] <NEWLINE> <DEDENT> l = town . index ( p ) <NEWLINE> if k < len ( town ) : <NEWLINE> <INDENT> print ( town [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( town [ l + ( k - l ) % ( len ( town [ l : ] ) ) ] ) <NEWLINE> <DEDENT>
exec ( <STRING> + <STRING> * 200 ) <NEWLINE>
N , M , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> listA = list ( range ( 1 , N + 1 ) ) <NEWLINE> ANS = 0 <NEWLINE> <NL> import itertools <NEWLINE> for i in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> for j in range ( len ( i ) - 1 ) : <NEWLINE> <INDENT> if not i [ j ] <= i [ j + 1 ] : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> if i [ B [ q ] - 1 ] - i [ A [ q ] - 1 ] == C [ q ] : <NEWLINE> <INDENT> ans += D [ q ] <NEWLINE> <DEDENT> <DEDENT> ANS = max ( [ ANS , ans ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> cnt = np . zeros ( ( 10 , 10 ) ) <NEWLINE> <NL> for x in map ( str , range ( 0 , N + 1 ) ) : <NEWLINE> <INDENT> cnt [ int ( x [ 0 ] ) , int ( x [ - 1 ] ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> ans += cnt [ i , j ] * cnt [ j , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= ls [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> s = [ 0 ] * 2020 <NEWLINE> m = [ 0 ] * ( l + 1 ) <NEWLINE> m [ 0 ] = 1 <NEWLINE> s [ 0 ] = 1 <NEWLINE> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> m [ i ] = ( m [ i - 1 ] * 10 ) % 2019 <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> n = list ( n ) [ : : - 1 ] <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = ( tmp + int ( n [ i ] ) * m [ i ] ) % 2019 <NEWLINE> <COMMENT> <NL> s [ tmp ] += 1 <NEWLINE> <DEDENT> su = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <COMMENT> <NL> <INDENT> su += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( su ) <NEWLINE>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> out = 0 <NEWLINE> s = sorted ( s ) <NEWLINE> for i in range ( i [ 1 ] ) : <NEWLINE> <INDENT> out += s [ i ] <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> <NL> res = 0 <NEWLINE> tmp = [ 0 ] * 2019 <NEWLINE> tmp [ 0 ] = 1 <NEWLINE> sum_of_digits = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for c in S : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> sum_of_digits %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> tmp [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> for t in tmp : <NEWLINE> <INDENT> res += ( t * ( t - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> a2 = [ 0 ] * len ( a ) * 2 <NEWLINE> for i in range ( len ( a2 ) ) : <NEWLINE> <INDENT> a2 [ i ] = a [ i // 2 ] <NEWLINE> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> a2 [ 0 ] = 0 <NEWLINE> return sum ( a2 [ : n ] ) <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> <NL> cum = [ 0 ] * n <NEWLINE> cum [ n - 1 ] = int ( s [ - 1 ] ) % mod <NEWLINE> d = [ 1 ] * n <NEWLINE> for i in range ( n - 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> d [ i ] = d [ i + 1 ] * 10 % mod <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n - 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> a = int ( s [ i ] ) * d [ i ] % mod <NEWLINE> cum [ i ] = ( cum [ i + 1 ] + a ) % mod <NEWLINE> <DEDENT> cnt = [ 0 ] * mod <NEWLINE> <NL> ans = 0 <NEWLINE> for i in cum [ : : - 1 ] : <NEWLINE> <INDENT> ans += cnt [ i ] <NEWLINE> cnt [ i ] += 1 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> S = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> S . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ 0 ] * N <NEWLINE> acc = [ 0 ] * N <NEWLINE> ans [ 0 ] = 1 <NEWLINE> acc [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for l , r in S : <NEWLINE> <NL> <INDENT> if i - l < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += acc [ i - l ] <NEWLINE> <DEDENT> if i - r - 1 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] -= acc [ i - r - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ i ] %= mod <NEWLINE> acc [ i ] = ( acc [ i - 1 ] + ans [ i ] ) % mod <NEWLINE> <NL> <NL> <DEDENT> print ( ans [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A_done = [ 0 ] * N <NEWLINE> A_route = [ ] <NEWLINE> point = 1 <NEWLINE> end_point = 0 <NEWLINE> while A_done [ point - 1 ] == 0 : <NEWLINE> <INDENT> A_done [ point - 1 ] = 1 <NEWLINE> A_route . append ( point ) <NEWLINE> point = A [ point - 1 ] <NEWLINE> if A_done [ point - 1 ] == 1 : <NEWLINE> <INDENT> end_point = point <NEWLINE> <DEDENT> <DEDENT> cal = K % len ( A_route ) <NEWLINE> roop = A_route . index ( end_point ) <NEWLINE> f_len = len ( A_route [ : roop ] ) <NEWLINE> roop_len = len ( A_route [ roop : ] ) <NEWLINE> A_roop = A_route [ roop : ] <NEWLINE> if K >= f_len + roop_len : <NEWLINE> <INDENT> cal = ( K - f_len ) % ( len ( A_roop ) ) <NEWLINE> <COMMENT> <NL> print ( A_roop [ cal ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A_route [ K ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mul = 1 <NEWLINE> check = 10 ** 18 <NEWLINE> count = x . count ( 0 ) <NEWLINE> if ( count >= 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> mul *= int ( x [ i ] ) <NEWLINE> if ( check < mul ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( check < mul ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import scipy as sp <NEWLINE> import queue <NEWLINE> import collections <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> def main ( kwargs ) : <NEWLINE> <INDENT> n = kwargs [ <STRING> ] <NEWLINE> C = kwargs [ <STRING> ] <NEWLINE> left = 0 <NEWLINE> right = C . count ( <STRING> ) <NEWLINE> res = max ( [ left , right ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> tmp = max ( [ left , right ] ) <NEWLINE> res = min ( res , tmp ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> kwargs = { } <NEWLINE> <NL> cin = input ( ) . split ( ) <NEWLINE> kwargs [ <STRING> ] = [ int ( i ) for i in cin ] [ 0 ] <NEWLINE> cin = input ( ) . split ( ) [ 0 ] <NEWLINE> kwargs [ <STRING> ] = [ i for i in cin ] <NEWLINE> <NL> cout = main ( kwargs ) <NEWLINE> print ( cout ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
import sys <NEWLINE> tmp = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> t = 0 <NEWLINE> d = 1 <NEWLINE> for i in reversed ( tmp ) : <NEWLINE> <INDENT> t = ( t + int ( i ) * d ) % 2019 <NEWLINE> cnt [ t ] += 1 <NEWLINE> d = d * 10 % 2019 <NEWLINE> <DEDENT> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> c = collections . Counter ( a ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> k = int ( input ( ) . strip ( ) ) <NEWLINE> gcdsum = 0 <NEWLINE> <NL> for a , b , c in itertools . combinations_with_replacement ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> gcdsum += math . gcd ( math . gcd ( a , b ) , c ) * 1 <NEWLINE> <DEDENT> elif a != b and b == c : <NEWLINE> <INDENT> gcdsum += math . gcd ( math . gcd ( a , b ) , c ) * 3 <NEWLINE> <DEDENT> elif a == b and b != c : <NEWLINE> <INDENT> gcdsum += math . gcd ( math . gcd ( a , b ) , c ) * 3 <NEWLINE> <DEDENT> elif a != b and b != c : <NEWLINE> <INDENT> gcdsum += math . gcd ( math . gcd ( a , b ) , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> print ( gcdsum ) <NEWLINE>
import math <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : return b <NEWLINE> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def div ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> while temp % i == 0 : <NEWLINE> <INDENT> temp //= i <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> return cnt + 1 <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( div ( gcd ( a , b ) ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . sort ( ) <NEWLINE> D = 0 <NEWLINE> for i in range ( 0 , B ) : <NEWLINE> <INDENT> D = D + C [ i ] <NEWLINE> <DEDENT> print ( D ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> print ( N // 2 , N , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if N < 4 * i : <NEWLINE> <INDENT> n = 4 * i - N <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> j , k = 2 * N * i , 2 * N * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> j , k = 2 * N * i // 3 , 2 * N * i // 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( 100 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> for y in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> if ( ( N * i ) % y == 0 ) and ( ( N * i ) % ( n - y ) == 0 ) : <NEWLINE> <INDENT> j = ( N * i ) // y <NEWLINE> k = ( N * i ) // ( n - y ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> n += 4 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( i , j , k ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> set ( a ) <NEWLINE> ans = [ 0 ] * 1000005 <NEWLINE> x = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( ans [ i ] != 0 ) : <NEWLINE> <INDENT> ans [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i , 1000005 , i ) : <NEWLINE> <INDENT> ans [ j ] = ans [ j ] + 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( ans [ a [ i ] ] == 1 ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> res = [ 0 ] * 2019 <NEWLINE> res [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> a = 0 <NEWLINE> <NL> for c in reversed ( S ) : <NEWLINE> <INDENT> a += int ( c ) * d <NEWLINE> a %= 2019 <NEWLINE> res [ a ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for r in res : <NEWLINE> <INDENT> ans += r * ( r - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> A_ele = [ ] <NEWLINE> B_ele = [ ] <NEWLINE> C_ele = [ ] <NEWLINE> ele = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( ele [ 0 ] ) : <NEWLINE> <INDENT> A_ele . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for i in range ( ele [ 1 ] ) : <NEWLINE> <INDENT> B_ele . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for i in range ( ele [ 0 ] ) : <NEWLINE> <INDENT> C_ele . append ( [ ] ) <NEWLINE> for j in range ( ele [ 1 ] ) : <NEWLINE> <INDENT> for k in range ( ele [ 2 ] ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> C_ele [ i ] . append ( 0 ) <NEWLINE> <DEDENT> C_ele [ i ] [ k ] = C_ele [ i ] [ k ] + A_ele [ i ] [ j ] * B_ele [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( ele [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , C_ele [ i ] ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a , reverse = True ) <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> number = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> number = number * a [ i ] <NEWLINE> if number > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( number ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> start = j = 7 % K <NEWLINE> count = 1 <NEWLINE> <NL> <COMMENT> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if j == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> j = 10 * j + 7 <NEWLINE> j = j % K <NEWLINE> count += 1 <NEWLINE> <NL> <COMMENT> <NL> if j == start : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> AB = [ [ ] for i in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> AB [ a ] . append ( b ) <NEWLINE> AB [ b ] . append ( a ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i , ab in enumerate ( AB ) : <NEWLINE> <INDENT> ind = list ( set ( ab ) ) <NEWLINE> if ind == [ ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if np . max ( H [ ind ] ) < H [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> r += a [ i ] <NEWLINE> t += a [ i - 1 ] * r <NEWLINE> <DEDENT> print ( t % mod ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> string = str ( r ** 2 * math . pi ) + <STRING> + str ( 2 * math . pi * r ) <NEWLINE> print ( string ) <NEWLINE>
from math import gcd <NEWLINE> <NL> line = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , line + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , line + 1 ) : <NEWLINE> <INDENT> c = gcd ( a , b ) <NEWLINE> for d in range ( 1 , line + 1 ) : <NEWLINE> <INDENT> ans += gcd ( d , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if tmp in s : <NEWLINE> <INDENT> s [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ tmp ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> N = list ( input ( ) ) <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> cnt += int ( N [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if cnt % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> c = [ 0 ] * m <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ x ] == 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> ans . append ( x ) <NEWLINE> c [ x ] = 1 <NEWLINE> x = x ** 2 % m <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> p = ans . index ( x ) <NEWLINE> l = len ( ans ) - p <NEWLINE> d , e = divmod ( n - p , l ) <NEWLINE> print ( sum ( ans [ : p ] ) + d * sum ( ans [ p : ] ) + sum ( ans [ p : p + e ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( ans ) ) <NEWLINE> <DEDENT>
def find ( x ) : <NEWLINE> <INDENT> global s <NEWLINE> if s [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> s [ x ] = find ( s [ x ] ) <NEWLINE> return s [ x ] <NEWLINE> <NL> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ i for i in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com : <NEWLINE> <INDENT> if find ( x ) == find ( y ) : print ( 1 ) <NEWLINE> else : print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ find ( y ) ] = find ( x ) <NEWLINE> <DEDENT> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 for i in range ( M ) ] <NEWLINE> B = [ 0 for i in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> uf = UnionFind ( max ( N , M ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = A [ i ] - 1 <NEWLINE> b = B [ i ] - 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * l [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> ans . add ( S ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> S = [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> cnt = Counter ( S ) <NEWLINE> ma = max ( cnt . values ( ) ) <NEWLINE> list = [ ] <NEWLINE> for k in cnt . keys ( ) : <NEWLINE> <INDENT> if cnt [ k ] == ma : <NEWLINE> <INDENT> list . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> list . sort ( ) <NEWLINE> for i in list : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> for val in arr : <COMMENT> <NEWLINE> <INDENT> cnt [ val ] += 1 <NEWLINE> <DEDENT> sums = sum ( arr ) <COMMENT> <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( c - b ) * ( cnt [ b ] ) <COMMENT> <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> cnt [ c ] += cnt [ b ] <COMMENT> <NEWLINE> cnt [ b ] = 0 <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> black = 0 <NEWLINE> white = 0 <NEWLINE> <NL> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += i + 1 - white <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> <NL> def dump ( * args ) : <NEWLINE> <INDENT> sys . stderr . write ( str ( args ) ) <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def cum ( array ) : <COMMENT> <NEWLINE> <INDENT> result = [ 0 ] <NEWLINE> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> result . append ( array [ i ] + result [ i ] ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> bc = cum ( b ) <NEWLINE> ac = cum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ac [ i ] <= k : <NEWLINE> <COMMENT> <NL> <INDENT> ans = max ( ans , i + bisect . bisect_right ( bc , k - ac [ i ] ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> X = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> X = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if X == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> X = X * a [ i ] <NEWLINE> if X > 1000000000000000000 : <NEWLINE> <INDENT> X = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( X ) <NEWLINE>
n , k = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> arr = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> ans = 0 <NEWLINE> arr = sorted ( arr ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += arr [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> M *= a <NEWLINE> if M > 1000000000000000000 : break <NEWLINE> <NL> <DEDENT> print ( - 1 if M > 1000000000000000000 else M ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 9 + 7 <NEWLINE> aa = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> aa [ i ] = A [ i ] ** 2 <NEWLINE> <DEDENT> X = sum ( A ) ** 2 - sum ( aa ) <NEWLINE> print ( ( X // 2 ) % inf ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if k > len ( s ) - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] == s [ j ] or s [ j ] == s [ k ] or s [ k ] == s [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> all = r * g * b <NEWLINE> print ( all - cnt ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> MAX_NUM = 10 ** 18 <NEWLINE> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for num in nums : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for num in nums : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > MAX_NUM : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> root = [ - 1 ] * n <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = find ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> parent_x = find ( x ) <NEWLINE> parent_y = find ( y ) <NEWLINE> <NL> if parent_x == parent_y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if parent_x > parent_y : <NEWLINE> <INDENT> parent_x , parent_y = parent_y , parent_x <NEWLINE> <NL> <DEDENT> root [ parent_x ] += root [ parent_y ] <NEWLINE> root [ parent_y ] = parent_x <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> a = find ( x ) <NEWLINE> return - root [ a ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> unite ( AB [ i ] [ 0 ] - 1 , AB [ i ] [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ a [ i ] for i in range ( n ) if i % 2 == 0 ] <NEWLINE> c = [ a [ i ] for i in range ( n ) if i % 2 == 1 ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> d = c [ : : - 1 ] + b <NEWLINE> <DEDENT> elif n % 2 == 1 : <NEWLINE> <INDENT> d = b [ : : - 1 ] + c <NEWLINE> <DEDENT> s = <STRING> . join ( [ str ( e ) for e in d ] ) <NEWLINE> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> a = float ( input ( ) ) <NEWLINE> <NL> c = a * a * math . pi <NEWLINE> r = ( a + a ) * math . pi <NEWLINE> <NL> print ( float ( c ) , float ( r ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> i = min ( b - 1 , n ) <NEWLINE> print ( int ( ( a * i ) / b ) - a * int ( i / b ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> s = map ( int , input ( ) [ : : - 1 ] ) <NEWLINE> <NL> mod = 2019 <NEWLINE> <NL> counts = [ 0 ] * mod <NEWLINE> counts [ 0 ] = 1 <NEWLINE> t = 0 <NEWLINE> x = 1 <NEWLINE> for num in s : <NEWLINE> <INDENT> t = ( t + num * x ) % mod <NEWLINE> counts [ t ] += 1 <NEWLINE> x = ( x * 10 ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for count in counts : <NEWLINE> <INDENT> if count > 1 : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = input ( ) <NEWLINE> <NL> dp = [ [ 0 ] * ( n + 1 ) for _ in range ( 2 ) ] <NEWLINE> dp [ 1 ] [ 0 ] = arr . count ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if arr [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 <NEWLINE> dp [ 1 ] [ i ] = dp [ 1 ] [ i - 1 ] <NEWLINE> <DEDENT> if arr [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] <NEWLINE> dp [ 1 ] [ i ] = dp [ 1 ] [ i - 1 ] - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dp = np . array ( dp ) <NEWLINE> <NL> print ( dp . min ( axis = 0 ) . max ( ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = input ( ) <NEWLINE> q = deque ( list ( s ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> if len ( q ) >= 5 : <NEWLINE> <INDENT> subs = q . popleft ( ) + q . popleft ( ) + q . popleft ( ) + q . popleft ( ) + q . popleft ( ) <NEWLINE> if subs != <STRING> and subs != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if subs == <STRING> and len ( q ) != 0 and q [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> if subs == <STRING> and len ( q ) == 2 and q [ 0 ] + q [ 1 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> q . popleft ( ) <NEWLINE> <DEDENT> if subs == <STRING> and len ( q ) >= 3 and q [ 0 ] + q [ 1 ] == <STRING> and q [ 2 ] != <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> q . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N , K = [ int ( v ) for v in input ( ) . split ( <STRING> ) ] <NEWLINE> points = [ int ( v ) for v in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> if points [ i - K - 1 ] < points [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
MAX = 10 ** 18 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> liste = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( liste [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> res *= liste [ i ] <NEWLINE> <COMMENT> <NL> if ( res > MAX ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( res > MAX ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> <NL> h = int ( l [ 0 ] ) <NEWLINE> w = int ( l [ 1 ] ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( h ) <NEWLINE> a . append ( w ) <NEWLINE> i = i + 2 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> while m < i : <NEWLINE> <INDENT> while a [ m ] > 0 : <NEWLINE> <INDENT> print ( a [ m + 1 ] * <STRING> ) <NEWLINE> a [ m ] = a [ m ] - 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> m = m + 2 <NEWLINE> <NL> <DEDENT>
N , K = input ( ) . split ( ) <NEWLINE> <NL> dislike = set ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> next_map = { } <NEWLINE> min_digit = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( i , 10 ) : <NEWLINE> <INDENT> if j not in dislike : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> min_digit = j <NEWLINE> <DEDENT> next_map . update ( { i : j } ) <NEWLINE> break <NEWLINE> <DEDENT> next_map . update ( { i : min_digit } ) <NEWLINE> <DEDENT> <DEDENT> max_digit = max ( next_map . values ( ) ) <NEWLINE> <NL> num = len ( list ( N ) ) <NEWLINE> count = num <NEWLINE> cand = [ ] <NEWLINE> for n in list ( N ) : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> if n in dislike : <NEWLINE> <INDENT> n_ = next_map [ n ] <NEWLINE> cand . append ( n_ ) <NEWLINE> count -= 1 <NEWLINE> cand . extend ( count * [ min_digit ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( n ) <NEWLINE> count -= 1 <NEWLINE> <DEDENT> <DEDENT> cand = int ( <STRING> . join ( list ( map ( str , cand ) ) ) ) <NEWLINE> if int ( N ) <= cand : <NEWLINE> <INDENT> print ( cand ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if min_digit == 0 : <NEWLINE> <INDENT> next_min = next_map [ 1 ] <NEWLINE> cand = [ next_min ] + num * [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand = ( num + 1 ) * [ min_digit ] <NEWLINE> <DEDENT> cand = int ( <STRING> . join ( list ( map ( str , cand ) ) ) ) <NEWLINE> print ( cand ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> B = [ 0 ] * N <NEWLINE> C = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b = i + A [ i ] <NEWLINE> c = i - A [ i ] <NEWLINE> if 0 < b < N : <NEWLINE> <INDENT> B [ b ] += 1 <NEWLINE> <DEDENT> if 0 < c < N : <NEWLINE> <INDENT> C [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans += B [ i ] * C [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> n = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n += int ( S [ i ] ) * d <NEWLINE> r = n % 2019 <NEWLINE> l [ r ] += 1 <NEWLINE> d = 10 * d % 2019 <NEWLINE> <NL> <DEDENT> out = 0 <NEWLINE> for m in l : <NEWLINE> <INDENT> out += ( m * ( m - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> if power >= 10 ** 9 + 7 : <NEWLINE> <INDENT> power %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> li = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> li . append ( cnt ) <NEWLINE> print ( max ( li ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> num = set ( A ) <NEWLINE> count = Counter ( A ) <NEWLINE> dp = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in num : <NEWLINE> <INDENT> for n in range ( a + a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> dp [ n ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in num : <NEWLINE> <INDENT> if count [ a ] == 1 and dp [ a ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H == W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> first = False <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> G = s . count ( <STRING> ) <NEWLINE> R = s . count ( <STRING> ) <NEWLINE> B = s . count ( <STRING> ) <NEWLINE> <NL> ans = G * R * B <NEWLINE> <NL> if n <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( min ( i + 1 , n - 2 - i ) ) : <NEWLINE> <INDENT> if s [ i + 1 ] != s [ i - j ] and s [ i + 1 ] != s [ i + 2 + j ] and s [ i - j ] != s [ i + 2 + j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ ] <NEWLINE> h_cnt = [ 0 ] * h <NEWLINE> w_cnt = [ 0 ] * w <NEWLINE> hw = [ ] <NEWLINE> hw_set = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= 1 <NEWLINE> c -= 1 <NEWLINE> h_cnt [ r ] += 1 <NEWLINE> w_cnt [ c ] += 1 <NEWLINE> hw . append ( ( r , c ) ) <NEWLINE> hw_set . add ( ( r , c ) ) <NEWLINE> <DEDENT> mh = max ( h_cnt ) <NEWLINE> mw = max ( w_cnt ) <NEWLINE> cand_r = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if h_cnt [ i ] == mh : <NEWLINE> <INDENT> cand_r . append ( i ) <NEWLINE> <DEDENT> <DEDENT> cand_c = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if w_cnt [ j ] == mw : <NEWLINE> <INDENT> cand_c . append ( j ) <NEWLINE> <DEDENT> <DEDENT> ans = mh + mw <NEWLINE> for i in cand_r : <NEWLINE> <INDENT> for j in cand_c : <NEWLINE> <INDENT> if not ( i , j ) in hw_set : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
import sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 120 ) : <NEWLINE> <INDENT> for b in range ( 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif a ** 5 - ( - b ) ** 5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> reverse = False <NEWLINE> front = <STRING> <NEWLINE> rear = <STRING> <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> reverse = not reverse <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ( inp [ 2 ] == <STRING> and not reverse ) or ( inp [ 2 ] == <STRING> and reverse ) : <NEWLINE> <INDENT> front = inp [ 4 ] + front <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rear = rear + inp [ 4 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = front + S + rear <NEWLINE> if reverse : <NEWLINE> <INDENT> ans = ans [ : : - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = z [ 0 ] <NEWLINE> if z [ 1 ] == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> for i in p : <NEWLINE> <INDENT> l . remove ( i ) <NEWLINE> <DEDENT> t = 200 <NEWLINE> for i in l : <NEWLINE> <INDENT> e = abs ( x - i ) <NEWLINE> if e >= t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = e <NEWLINE> ans = i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> nR = 0 <NEWLINE> nG = 0 <NEWLINE> nB = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> nR += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> nG += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nB += 1 <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j - i + j <NEWLINE> if k < N : <NEWLINE> <INDENT> L = [ S [ i ] , S [ j ] , S [ k ] ] <NEWLINE> if <STRING> in L and <STRING> in L and <STRING> in L : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( nR * nG * nB - cnt ) <NEWLINE>
import sys <NEWLINE> from itertools import groupby <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> readline ( ) <NEWLINE> b = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> b . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> x = len ( b ) <NEWLINE> c = [ ( k , len ( tuple ( L ) ) ) for k , L in groupby ( b ) ] <NEWLINE> <COMMENT> <NL> m = c [ - 1 ] [ 0 ] <NEWLINE> <COMMENT> <NL> s = [ True ] * ( m + 1 ) <NEWLINE> <COMMENT> <NL> <NL> a = 0 <NEWLINE> for i , le in c : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> if le <= 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> for v in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> s [ v ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import copy <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N = int ( pin ( ) ) <NEWLINE> X = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> t = ( N + 1 ) // 2 <NEWLINE> Y = sorted ( X ) <NEWLINE> ans1 = Y [ t - 1 ] <NEWLINE> ans2 = Y [ t ] <NEWLINE> median = ans1 + ans2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = X [ i ] <NEWLINE> if s == ans1 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> elif s == ans2 : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> elif 2 * s < median : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> elif 2 * s > median : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) <NEWLINE> if cmd in d : <NEWLINE> <INDENT> d [ cmd ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ cmd ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mval = max ( d . values ( ) ) <NEWLINE> A = [ kv [ 0 ] for kv in d . items ( ) if kv [ 1 ] == mval ] <NEWLINE> <NL> B = sorted ( A ) <NEWLINE> for b in B : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans . append ( s ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ans [ i ] != ans [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 0 for i in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> r = [ 0 for i in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> c = 1 <NEWLINE> a = 0 <NEWLINE> if n != 0 : <NEWLINE> <INDENT> k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if k [ i ] + c <= 2 * 10 ** 5 : <NEWLINE> <INDENT> l [ k [ i ] + c ] += 1 <NEWLINE> <DEDENT> if - k [ i ] + c >= 0 and - k [ i ] + c <= 2 * 10 ** 5 : <NEWLINE> <INDENT> r [ - k [ i ] + c ] += 1 <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a += l [ i ] * r [ i ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if A + B + C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + B + C == 1 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if A == 0 and B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if A == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( res ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = [ ] <NEWLINE> s = input ( ) <NEWLINE> if ( s == <STRING> and A == 0 and B == 0 ) or ( s == <STRING> and A == 0 and C == 0 ) or ( s == <STRING> and B == 0 and C == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> next = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> A += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> A -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if next == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif next == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> C -= 1 <NEWLINE> A += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif C == 0 : <NEWLINE> <INDENT> C += 1 <NEWLINE> A -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if next == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif next == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C == 0 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if next == <STRING> : <NEWLINE> <INDENT> C += 1 <NEWLINE> B -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> elif next == <STRING> : <NEWLINE> <INDENT> C += 1 <NEWLINE> B -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C -= 1 <NEWLINE> B += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = next <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( res ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = a [ 0 ] <NEWLINE> m = a [ 0 ] <NEWLINE> <NL> g = True <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> d = gcd ( d , a [ i ] ) <NEWLINE> <NL> <DEDENT> if d != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while len ( a ) > 1 : <NEWLINE> <INDENT> b = [ ] <NEWLINE> for i in range ( 0 , len ( a ) , 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == len ( a ) - 1 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = gcd ( a [ i ] , a [ i + 1 ] ) <NEWLINE> if e != 1 : <NEWLINE> <INDENT> g = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] * a [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a = b . copy ( ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if not g : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> def getInvs ( n , MOD ) : <NEWLINE> <INDENT> invs = [ 1 ] * ( n + 1 ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> invs [ x ] = ( - ( MOD // x ) * invs [ MOD % x ] ) % MOD <NEWLINE> <DEDENT> return invs <NEWLINE> <DEDENT> invs = getInvs ( N + 3 , MOD ) <NEWLINE> <NL> num = M <NEWLINE> nums = [ ] <NEWLINE> for i in reversed ( range ( 1 , N ) ) : <NEWLINE> <INDENT> nums . append ( num ) <NEWLINE> num *= i * ( M - 1 ) <NEWLINE> num *= invs [ N - i ] <NEWLINE> num %= MOD <NEWLINE> <DEDENT> nums . append ( num ) <NEWLINE> nums . reverse ( ) <NEWLINE> <NL> ans = sum ( nums [ : K + 1 ] ) <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = [ 0 ] * N <NEWLINE> D = [ 0 ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a - 1 ] += 1 <NEWLINE> D [ C [ a - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> S = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] + D [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = N <NEWLINE> for K in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> while ans > 0 and S [ ans ] < K * ans : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> all = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if 0 <= 2 * i - j < N : <NEWLINE> <INDENT> if S [ 2 * i - j ] != S [ i ] != S [ j ] != S [ 2 * i - j ] : <NEWLINE> <INDENT> all -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( all ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> D = dict ( ) <NEWLINE> s = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> s += i <NEWLINE> if i in D : <NEWLINE> <INDENT> D [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in D : <NEWLINE> <INDENT> s += ( c - b ) * D [ b ] <NEWLINE> if c in D : <NEWLINE> <INDENT> D [ c ] += D [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ c ] = D [ b ] <NEWLINE> <DEDENT> del D [ b ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> [ print ( x , end = <STRING> ) for x in B ] <NEWLINE>
S = list ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = list ( input ( ) . split ( ) ) <NEWLINE> q [ 0 ] = int ( q [ 0 ] ) <NEWLINE> if q [ 0 ] == 1 : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> q [ 1 ] = int ( q [ 1 ] ) <NEWLINE> if ( q [ 1 ] == 1 and a == 0 ) or ( q [ 1 ] == 2 and a == 1 ) : <NEWLINE> <INDENT> B . append ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> B = B [ : : - 1 ] <NEWLINE> ans = B + S + A <NEWLINE> if a == 1 : <NEWLINE> <INDENT> ans = ans [ : : - 1 ] <NEWLINE> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , M , Q , LR , pq ) : <NEWLINE> <INDENT> S = np . zeros ( shape = ( N + 1 , N + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = LR [ i ] <NEWLINE> S [ L ] [ R ] += 1 <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> S [ i ] = np . cumsum ( S [ i ] ) <NEWLINE> <NL> <DEDENT> ans = np . zeros ( shape = Q , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , q = pq [ i ] <NEWLINE> for j in range ( p , q + 1 ) : <NEWLINE> <INDENT> ans [ i ] += S [ j ] [ q ] - S [ j ] [ p - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = np . zeros ( shape = ( M , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> LR [ i ] = input ( ) . split ( ) <NEWLINE> <DEDENT> pq = np . zeros ( shape = ( Q , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> pq [ i ] = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> ans = solve ( N , M , Q , LR , pq ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> c = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i , j ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> score = 0 <NEWLINE> <NL> <NL> if K <= A + B : <NEWLINE> <INDENT> score = min ( A , K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = A - min ( C , ( K - ( A + B ) ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( score ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> tot = [ ] <NEWLINE> cur = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> cur += i <NEWLINE> tot . append ( cur ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> if n > i : <NEWLINE> <INDENT> max_ = tot [ n ] - tot [ n - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_ = tot [ n ] <NEWLINE> <DEDENT> min_ = tot [ i - 1 ] <NEWLINE> cnt += max_ - min_ + 1 <NEWLINE> cnt %= mod <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> def popcount ( ni ) : <NEWLINE> <INDENT> n_b = str ( bin ( ni ) ) <NEWLINE> return n_b . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def ans ( n , x ) : <NEWLINE> <INDENT> x_i = int ( x , 2 ) <NEWLINE> x_orig = popcount ( x_i ) <NEWLINE> x_i_t = x_i % ( x_orig + 1 ) <NEWLINE> if x_orig != 1 : <NEWLINE> <INDENT> x_i_b = x_i % ( x_orig - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_i_b = x_i <NEWLINE> <DEDENT> solve = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x_count = x_orig <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> x_count += 1 <NEWLINE> solve = x_i_t + pow ( 2 , n - 1 - i , x_count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_count -= 1 <NEWLINE> if x_count != 0 : <NEWLINE> <INDENT> solve = x_i_b - pow ( 2 , n - 1 - i , x_count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> <NL> if x_count != 0 : <NEWLINE> <INDENT> solve = solve % x_count <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> while solve > 0 : <NEWLINE> <INDENT> solve = solve % popcount ( solve ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans ( n , x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> SUM = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> node = 1 <NEWLINE> for i , leaf in enumerate ( A ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> non_leaf = 1 - leaf <NEWLINE> ans += 1 <NEWLINE> if non_leaf < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> left , right = non_leaf , non_leaf * 2 <NEWLINE> if SUM < left or non_leaf <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> node = min ( right , SUM ) <NEWLINE> ans += node <NEWLINE> non_leaf = node - leaf <NEWLINE> SUM -= leaf <NEWLINE> if non_leaf < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ar = [ 0 ] <NEWLINE> br = [ 0 ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> ar . append ( ar [ - 1 ] + r [ i ] ) <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> br . append ( br [ - 1 ] + l [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = b <NEWLINE> for i in range ( len ( ar ) ) : <NEWLINE> <INDENT> if ar [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if ar [ i ] + br [ j ] <= k : <NEWLINE> <INDENT> t = i + j <NEWLINE> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> t = math . ceil ( a / d ) <NEWLINE> a = math . ceil ( c / b ) <NEWLINE> if t >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> from itertools import product <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> n_np = np . zeros ( 105 ** 3 ) <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> idx = i ** 2 + j ** 2 + k ** 2 + i * j + i * k + j * k <NEWLINE> n_np [ idx - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( int ( n_np [ i ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x1 = a * c <NEWLINE> x2 = a * d <NEWLINE> x3 = b * c <NEWLINE> x4 = b * d <NEWLINE> <NL> z = x1 <NEWLINE> if z < x2 : <NEWLINE> <INDENT> z = x2 <NEWLINE> <DEDENT> if z < x3 : <NEWLINE> <INDENT> z = x3 <NEWLINE> <DEDENT> if z < x4 : <NEWLINE> <INDENT> z = x4 <NEWLINE> <NL> <DEDENT> print ( z ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for j in range ( n ) ] <NEWLINE> <NL> dp = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if dp [ - 1 ] < a [ i ] : <NEWLINE> <INDENT> dp . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ bisect . bisect_left ( dp , a [ i ] ) ] = a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( len ( dp ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> suu = <STRING> <COMMENT> <NEWLINE> n = int ( input ( ) ) <NEWLINE> puts = <STRING> <NEWLINE> if n < 27 : <COMMENT> <NEWLINE> <INDENT> print ( suu [ n - 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> temp = n % 26 <NEWLINE> n //= 26 <NEWLINE> puts = suu [ temp - 1 ] + puts <NEWLINE> if temp == 0 : <COMMENT> <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> if n < 27 : <NEWLINE> <INDENT> puts = suu [ n - 1 ] + puts <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( puts ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ ] for _ in range ( n ) ] <NEWLINE> c = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c_as = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ i ] , A [ i ] = c_as [ 0 ] , c_as [ 1 : ] <NEWLINE> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> <NL> for s in range ( 0 , 1 << n ) : <NEWLINE> <INDENT> smart = [ 0 ] * m <NEWLINE> cost_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s >> i ) % 2 == 0 : continue <NEWLINE> cost_sum += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> smart [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if smart [ j ] < X : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost_sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 for i in range ( n ) ] <NEWLINE> for e in a : <NEWLINE> <INDENT> b [ e - 1 ] += 1 <NEWLINE> <DEDENT> for e in b : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> res = [ 0 ] <NEWLINE> for j in uf . roots ( ) : <NEWLINE> <INDENT> res . append ( uf . size ( j ) ) <NEWLINE> <DEDENT> print ( max ( res ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> dp = np . zeros ( s + 1 , np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for e in a : <NEWLINE> <INDENT> pre = dp . copy ( ) <NEWLINE> <NL> dp = 2 * pre <NEWLINE> dp [ e : ] += pre [ : - e ] <NEWLINE> dp %= mod <NEWLINE> <NL> <DEDENT> ans = dp [ s ] <NEWLINE> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> seven = 7 <NEWLINE> counter = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if seven % K == 0 : <NEWLINE> <INDENT> print ( counter ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> seven = ( seven * 10 + 7 ) % K <NEWLINE> counter += 1 <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <COMMENT> <NEWLINE> from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> chk = [ 0 for _ in range ( N ) ] <NEWLINE> tmp = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if chk [ tmp ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> chk [ tmp ] = 1 <NEWLINE> L . append ( tmp ) <NEWLINE> tmp = A [ tmp ] - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> loop_s = A [ L [ - 1 ] ] - 1 <NEWLINE> loop_g = L [ - 1 ] <NEWLINE> one_to_s = 0 <NEWLINE> tmp = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> while ( 1 ) : <NEWLINE> <INDENT> if tmp == loop_s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = A [ tmp ] - 1 <NEWLINE> <COMMENT> <NL> one_to_s += 1 <NEWLINE> <NL> <DEDENT> loop_l = 0 <NEWLINE> tmp = loop_s <NEWLINE> Loop = [ loop_s ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if tmp == loop_g : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = A [ tmp ] - 1 <NEWLINE> Loop . append ( tmp ) <NEWLINE> loop_l += 1 <NEWLINE> <DEDENT> loop_l += 1 <NEWLINE> <COMMENT> <NL> if K <= one_to_s : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if cnt == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = A [ tmp ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans = tmp + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= one_to_s <NEWLINE> num = K % loop_l <NEWLINE> ans = Loop [ num ] + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cnt [ A_i [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
from bisect import bisect_right <NEWLINE> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10 ** 8 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> gr . append ( [ ] ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> gr [ a ] . append ( b ) <NEWLINE> gr [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> dp = [ 10 ** 10 for i in range ( 1 + n ) ] <NEWLINE> dp [ 0 ] = - 10 ** 10 <NEWLINE> kek = 1 <NEWLINE> used = { 0 } <NEWLINE> <NL> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global kek <NEWLINE> j = bisect_right ( dp , A [ v ] - 1 ) <NEWLINE> old = dp [ j ] <NEWLINE> if dp [ j - 1 ] < A [ v ] < dp [ j ] : <NEWLINE> <INDENT> old = dp [ j ] <NEWLINE> dp [ j ] = A [ v ] <NEWLINE> if kek == j : <NEWLINE> <INDENT> for h in range ( kek + 1 , 1 + n ) : <NEWLINE> <INDENT> if dp [ h ] == 10 ** 10 : <NEWLINE> <INDENT> kek = h <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if kek == j : <NEWLINE> <INDENT> kek = n + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans [ v ] = kek - 1 <NEWLINE> for u in gr [ v ] : <NEWLINE> <INDENT> if u not in used : <NEWLINE> <INDENT> used . add ( u ) <NEWLINE> dfs ( u ) <NEWLINE> <DEDENT> <DEDENT> dp [ j ] = old <NEWLINE> if kek > j and old == 10 ** 10 : <NEWLINE> <INDENT> kek = j <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
N , M , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> stackA = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> stackB = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> indexB = 0 <NEWLINE> indexA = 0 <NEWLINE> <NL> books = 0 <NEWLINE> mostBooks = 0 <NEWLINE> time = 0 <NEWLINE> <NL> for x in stackB : <NEWLINE> <INDENT> if time + x > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> time += x <NEWLINE> indexB += 1 <NEWLINE> books += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> indexB -= 1 <NEWLINE> <NL> mostBooks = books <NEWLINE> <NL> for x in stackA : <NEWLINE> <INDENT> time += x <NEWLINE> books += 1 <NEWLINE> <NL> while time > K and indexB >= 0 : <NEWLINE> <INDENT> time -= stackB [ indexB ] <NEWLINE> indexB -= 1 <NEWLINE> books -= 1 <NEWLINE> <NL> <DEDENT> if indexB < 0 and time > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> mostBooks = max ( mostBooks , books ) <NEWLINE> <NL> <DEDENT> print ( mostBooks ) <NEWLINE>
MOD = int ( 10 ** 9 + 7 ) <NEWLINE> <NL> def pow_mod ( x , n , mod ) : <NEWLINE> <INDENT> if n > 1 : <NEWLINE> <INDENT> return pow_mod ( pow ( x , 2 ) % mod , n // 2 , mod ) * pow ( x , n % 2 ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> tot = [ 0 ] * ( K + 1 ) <NEWLINE> <NL> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> tot [ i ] = pow_mod ( K // i , N , MOD ) <NEWLINE> s = 2 <NEWLINE> while s * i <= K : <NEWLINE> <INDENT> tot [ i ] -= tot [ s * i ] <NEWLINE> s += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += ( ( tot [ i ] % MOD ) * i ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> a5 = pow ( a , 5 ) <NEWLINE> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> b5 = pow ( b , 5 ) <NEWLINE> if a5 - b5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> n = input ( ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a <= 10 ** 18 and count != 1 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
d = { } <NEWLINE> n = input ( ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in aaa : <NEWLINE> <INDENT> d [ a ] = d . get ( a , 0 ) + 1 <NEWLINE> if d [ a ] >= 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( S + 1 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> if S <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif S == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans [ 3 ] = 1 <NEWLINE> for i in range ( 4 , S + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] + ans [ i - 3 ] <NEWLINE> <NL> <DEDENT> print ( ans [ i ] % MOD ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> dist = [ INF ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for a , b , c in ABC : <NEWLINE> <INDENT> a , b , c = a - 1 , b - 1 , - c <NEWLINE> if dist [ b ] > dist [ a ] + c : <NEWLINE> <INDENT> dist [ b ] = dist [ a ] + c <NEWLINE> if i == N - 1 and b == N - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - dist [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> from numba import njit <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> print ( getresult ( k ) ) <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def getresult ( k ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <COMMENT> <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = input ( ) <NEWLINE> stones = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> count = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> red = 0 <NEWLINE> white = 0 <NEWLINE> for i in range ( len ( stones ) ) : <NEWLINE> <INDENT> if stones [ i ] == <STRING> : <NEWLINE> <INDENT> red += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( red ) : <NEWLINE> <INDENT> if stones [ i ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> <DEDENT> print ( white ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> a . append ( 0 ) <NEWLINE> mon = 1000 <NEWLINE> kab = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] <= a [ i + 1 ] : <NEWLINE> <INDENT> kab = mon // a [ i ] <NEWLINE> mon += kab * ( a [ i + 1 ] - a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( mon ) <NEWLINE>
T = str ( input ( ) ) <NEWLINE> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> if N == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N_remein = N <NEWLINE> <COMMENT> <NL> p_list = [ ] <NEWLINE> p_factor_list = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for p in range ( 2 , math . ceil ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N_remein % p == 0 : <NEWLINE> <INDENT> counter = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if N_remein % p == 0 : <NEWLINE> <INDENT> N_remein = N_remein // p <NEWLINE> counter += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_list . append ( p ) <NEWLINE> p_factor_list . append ( counter ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if N_remein != 1 : <NEWLINE> <INDENT> p_list . append ( N_remein ) <NEWLINE> p_factor_list . append ( 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if not p_factor_list : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for factor in p_factor_list : <NEWLINE> <INDENT> counter = 1 <NEWLINE> while ( counter * ( counter + 1 ) ) // 2 <= factor : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> answer += ( counter - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> return answer <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> line = <STRING> <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , W ) : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> line += i <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print ( line ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin , stdout <NEWLINE> def ws ( pos , win ) : <NEWLINE> <INDENT> l , r = win <NEWLINE> l1 = pos - r <NEWLINE> r1 = pos - l <NEWLINE> l = max ( l1 , 0 ) <NEWLINE> r = max ( r1 , 0 ) <NEWLINE> <COMMENT> <NL> sm = ps [ r ] - ( ps [ l - 1 ] if l >= 1 else 0 ) <NEWLINE> return ( sm + M ) % M <NEWLINE> <DEDENT> n , k = list ( map ( int , stdin . readline ( ) . split ( ) ) ) ; w = [ ] ; s = [ ] ; M = 998244353 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> x , y = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> w += [ [ x , y ] ] <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) ; dp [ 1 ] = 1 ; ps = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for win in w : <NEWLINE> <INDENT> ans = ws ( i , win ) <NEWLINE> dp [ i ] = ( dp [ i ] + ans ) % M <NEWLINE> <DEDENT> ps += [ ps [ - 1 ] + dp [ i ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for id , h in enumerate ( A , start = 1 ) : <NEWLINE> <INDENT> r . append ( id - h ) <NEWLINE> l . append ( id + h ) <NEWLINE> <NL> <DEDENT> r_cou = Counter ( r ) <NEWLINE> l_cou = Counter ( l ) <NEWLINE> ans = [ ] <NEWLINE> for i in l_cou . keys ( ) : <NEWLINE> <INDENT> ans . append ( l_cou [ i ] * r_cou . get ( i , 0 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_right <NEWLINE> <NL> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> xh = sorted ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) <NEWLINE> x = [ 0 ] * ( n + 1 ) <NEWLINE> h = [ 0 ] * ( n + 1 ) <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i , ( f , g ) in enumerate ( xh ) : <NEWLINE> <INDENT> x [ i ] , h [ i ] = f , g <NEWLINE> <DEDENT> x [ n ] = 10 ** 10 + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> s [ i ] += s [ i - 1 ] <NEWLINE> <DEDENT> h [ i ] -= s [ i ] <NEWLINE> if h [ i ] > 0 : <NEWLINE> <INDENT> num = 0 - - h [ i ] // a <NEWLINE> ans += num <NEWLINE> s [ i ] += num * a <NEWLINE> <NL> j = bisect_right ( x , x [ i ] + d * 2 ) <NEWLINE> s [ j ] -= num * a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = A [ 0 ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res = res * A [ i + 1 ] <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> class Node ( object ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . p = [ - 1 for i in range ( N ) ] <NEWLINE> self . l = [ - 1 for i in range ( N ) ] <NEWLINE> self . r = [ - 1 for i in range ( N ) ] <NEWLINE> self . D = [ 0 for i in range ( N ) ] <NEWLINE> <NL> <DEDENT> def set_depth_rec ( self , u , p ) : <NEWLINE> <INDENT> self . D [ u ] = p <NEWLINE> if self . r [ u ] is not - 1 : <NEWLINE> <INDENT> self . set_depth ( self . r [ u ] , p ) <NEWLINE> <DEDENT> if self . l [ u ] is not - 1 : <NEWLINE> <INDENT> self . set_depth ( self . l [ u ] , p + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def set_depth ( self , u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> pre_u = u <NEWLINE> while self . p [ u ] is not - 1 : <NEWLINE> <INDENT> u = self . p [ u ] <NEWLINE> d += 1 <NEWLINE> <DEDENT> self . D [ pre_u ] = d <NEWLINE> <NL> <DEDENT> def print_children ( self , u ) : <NEWLINE> <INDENT> children = [ ] <NEWLINE> flag = self . l [ u ] <NEWLINE> while flag is not - 1 : <NEWLINE> <INDENT> children . append ( flag ) <NEWLINE> flag = self . r [ flag ] <NEWLINE> <NL> <DEDENT> return children <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = Node ( N ) <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> if len ( A ) > 2 : <NEWLINE> <INDENT> T . l [ A [ 0 ] ] = A [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T . l [ A [ 0 ] ] = - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for index , i in enumerate ( A [ 2 : ] ) : <NEWLINE> <INDENT> if ( A [ - 1 ] == i ) : <NEWLINE> <INDENT> T . p [ i ] , T . r [ i ] = A [ 0 ] , - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T . p [ i ] , T . r [ i ] = A [ 0 ] , A [ index + 3 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> T . set_depth ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if T . p [ i ] is - 1 : <NEWLINE> <INDENT> node = <STRING> <NEWLINE> <DEDENT> elif T . l [ i ] is - 1 : <NEWLINE> <INDENT> node = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( i , T . p [ i ] , T . D [ i ] , node , T . print_children ( i ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_ls . sort ( ) <NEWLINE> if x_ls [ 0 ] >= 0 : <NEWLINE> <INDENT> print ( x_ls [ k - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif x_ls [ - 1 ] <= 0 : <NEWLINE> <INDENT> x_ls . sort ( reverse = True ) <NEWLINE> print ( abs ( x_ls [ k - 1 ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = k - 1 <NEWLINE> ans = float ( <STRING> ) <NEWLINE> while r < n : <NEWLINE> <INDENT> cost_1 = 2 * abs ( x_ls [ l ] ) + abs ( x_ls [ r ] ) <NEWLINE> cost_2 = abs ( x_ls [ l ] ) + 2 * abs ( x_ls [ r ] ) <NEWLINE> cost = min ( cost_1 , cost_2 ) <NEWLINE> ans = min ( cost , ans ) <NEWLINE> r += 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p2 = [ 0 ] * n <NEWLINE> <NL> for x in p : <NEWLINE> <INDENT> p2 [ x - 1 ] = p2 [ x - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for x in p2 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = sorted ( a , reverse = True ) <NEWLINE> m = 1 <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> m *= i <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> P = input ( ) <NEWLINE> for i in range ( len ( T ) - len ( P ) + 1 ) : <NEWLINE> <INDENT> t = T [ i : i + len ( P ) ] <NEWLINE> if t == P : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import resource <NEWLINE> <NL> def root ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> par [ x ] = root ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> rx = root ( x ) <NEWLINE> ry = root ( y ) <NEWLINE> if rx != ry : <NEWLINE> <INDENT> par [ rx ] = ry <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> par = list ( range ( n + 1 ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> union ( a , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> maxi = 0 <NEWLINE> count = 1 <NEWLINE> <COMMENT> <NL> countpar = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> countpar [ root ( par [ i ] ) ] += 1 <NEWLINE> <DEDENT> print ( max ( countpar ) ) <NEWLINE> <COMMENT> <NL>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> Rcount = 0 <NEWLINE> Gcount = 0 <NEWLINE> Bcount = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> Rcount += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> Gcount += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> Bcount += 1 <NEWLINE> <DEDENT> <DEDENT> RGB = Rcount * Gcount * Bcount <NEWLINE> for i in range ( 1 , ( len ( s ) // 2 ) + 2 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if i * 2 + j >= len ( s ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ j ] != s [ j + i ] and s [ j + i ] != s [ j + i + i ] and s [ j + i + i ] != s [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( RGB - cnt ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= ( A + B ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp , i = sum ( a [ : k ] ) , k <NEWLINE> for _ in range ( n - k ) : <NEWLINE> <INDENT> score = temp + a [ i ] - a [ i - k ] <NEWLINE> print ( <STRING> if score > temp else <STRING> ) <NEWLINE> temp = score <NEWLINE> i += 1 <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = 102 <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if i not in p and abs ( X - i ) < diff : <NEWLINE> <INDENT> diff = abs ( X - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> ans = 0 <NEWLINE> i = int ( input ( ) ) <NEWLINE> for a in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> n = gcd ( gcd ( a , b ) , c ) <NEWLINE> ans += n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x2 = copy . copy ( x ) <NEWLINE> x2 . sort ( ) <NEWLINE> num1 , num2 = ( len ( x ) // 2 ) - 1 , ( len ( x ) // 2 ) <NEWLINE> med1 , med2 = x2 [ num1 ] , x2 [ num2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= med1 : <NEWLINE> <INDENT> print ( med2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( med1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x * x + y * y + z * z + x * y + x * z + y * z <NEWLINE> if a > n : continue <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans : print ( i ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] + [ W + 1 ] * ( N * 100 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( i * 100 , - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ j + v ] > dp [ j ] + w : <NEWLINE> <INDENT> dp [ j + v ] = dp [ j ] + w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for v , w in zip ( range ( N * 100 , - 1 , - 1 ) , dp [ : : - 1 ] ) : <NEWLINE> <INDENT> if w < W + 1 : <NEWLINE> <INDENT> print ( v ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> inputnumber = int ( input ( ) ) <NEWLINE> if inputnumber == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , count + 1 , end = <STRING> ) <NEWLINE> print ( <STRING> , inputnumber ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def circumscribed_circle ( x1 , y1 , x2 , y2 , x3 , y3 ) : <NEWLINE> <INDENT> d = 2 * ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) <NEWLINE> px = ( ( x1 ** 2 + y1 ** 2 ) * ( y2 - y3 ) + ( x2 ** 2 + y2 ** 2 ) * ( y3 - y1 ) + ( x3 ** 2 + y3 ** 2 ) * ( y1 - y2 ) ) / d <NEWLINE> py = ( ( x1 ** 2 + y1 ** 2 ) * ( x3 - x2 ) + ( x2 ** 2 + y2 ** 2 ) * ( x1 - x3 ) + ( x3 ** 2 + y3 ** 2 ) * ( x2 - x1 ) ) / d <NEWLINE> a = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> b = math . sqrt ( ( x1 - x3 ) ** 2 + ( y1 - y3 ) ** 2 ) <NEWLINE> c = math . sqrt ( ( x2 - x3 ) ** 2 + ( y2 - y3 ) ** 2 ) <NEWLINE> s = ( a + b + c ) / 2 <NEWLINE> A = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) <NEWLINE> r = a * b * c / ( 4 * A ) <NEWLINE> return px , py , r <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = [ float ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> px , py , r = circumscribed_circle ( x1 , y1 , x2 , y2 , x3 , y3 ) <NEWLINE> print ( <STRING> % ( px , py , r ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b > 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <NL> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( c , g ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> gacha_list = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> gacha_list . append ( S ) <NEWLINE> <DEDENT> gacha_list = list ( set ( gacha_list ) ) <NEWLINE> <NL> print ( len ( gacha_list ) ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) ** 0.5 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> S = [ 0 for _ in range ( N ) ] <NEWLINE> min_value = 0 <NEWLINE> score = [ 0 for _ in range ( M ) ] <NEWLINE> <NL> for x in range ( N ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for x in range ( N ) : <NEWLINE> <INDENT> min_value += A [ x ] [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> sucess = 0 <NEWLINE> <NL> for bit in range ( 2 ** N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 : <NEWLINE> <INDENT> S . append ( A [ i ] [ 0 ] ) <NEWLINE> for x in range ( M ) : <NEWLINE> <INDENT> score [ x ] += A [ i ] [ x + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag = 0 <NEWLINE> <COMMENT> <NL> for k in score : <NEWLINE> <INDENT> if k >= X : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> if flag == len ( score ) : <NEWLINE> <COMMENT> <NL> <INDENT> if min_value >= sum ( S ) : <NEWLINE> <INDENT> min_value = sum ( S ) <NEWLINE> sucess += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> score = [ 0 for _ in range ( M ) ] <NEWLINE> S = [ ] <NEWLINE> <NL> <DEDENT> if sucess > 0 : <NEWLINE> <INDENT> print ( min_value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def rec ( x1 , q ) : <NEWLINE> <INDENT> return x1 - ( ( x1 ** 3 - q ) / ( 3 * ( x1 ** 2 ) ) ) <NEWLINE> <NL> <DEDENT> q = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> if tmp == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> q . append ( tmp ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> x1 = float ( q [ i ] / 2 ) <NEWLINE> while True : <NEWLINE> <INDENT> x1 = rec ( x1 , q [ i ] ) <NEWLINE> if abs ( x1 ** 3 - q [ i ] ) < 0.00001 * q [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( x1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = int ( input ( ) ) <NEWLINE> <NL> a = math . ceil ( s / 2 ) <NEWLINE> print ( a - 1 ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> mae = A [ 0 ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i < mae : <NEWLINE> <INDENT> c += mae - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mae = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( count [ i + 1 ] ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> h , m = 0 , 0 <NEWLINE> if int ( a / ( 60 ** 2 ) ) > 0 : <NEWLINE> <INDENT> h = int ( a / ( 60 ** 2 ) ) <NEWLINE> <DEDENT> a -= ( 60 ** 2 ) * h <NEWLINE> <NL> if int ( a / 60 ) > 0 : <NEWLINE> <INDENT> m = int ( a / 60 ) <NEWLINE> <DEDENT> a -= 60 * m <NEWLINE> s = a <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hp = [ 0 ] * h <NEWLINE> wp = [ 0 ] * w <NEWLINE> hw = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> h1 , w1 = map ( int , input ( ) . split ( ) ) <NEWLINE> hp [ h1 - 1 ] += 1 <NEWLINE> wp [ w1 - 1 ] += 1 <NEWLINE> hw . add ( ( h1 , w1 ) ) <NEWLINE> <NL> <DEDENT> h_max = max ( hp ) <NEWLINE> w_max = max ( wp ) <NEWLINE> <NL> hh = [ i + 1 for i , v in enumerate ( hp ) if v == h_max ] <NEWLINE> ww = [ i + 1 for i , v in enumerate ( wp ) if v == w_max ] <NEWLINE> ans = h_max + w_max <NEWLINE> <NL> for hb in hh : <NEWLINE> <INDENT> for wb in ww : <NEWLINE> <INDENT> if ( hb , wb ) not in hw : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( min ( len ( s ) , k ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> a = s . index ( i ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if j in s [ a + 1 : ] : <NEWLINE> <INDENT> b = [ x for x , y in enumerate ( s ) if x > a and y == j ] [ 0 ] <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> if k in s [ b + 1 : ] : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( k , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n >= b - 1 : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <NL> <DEDENT> print ( a * x // b - a * ( x // b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if b <= 10 ** 18 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 1 <NEWLINE> rec = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> rec = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if rec : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return a * x // b - a * ( x // b ) <NEWLINE> <NL> <DEDENT> print ( f ( min ( n , b - 1 ) ) ) <NEWLINE>
def ceil ( n , m ) : <NEWLINE> <INDENT> return - ( - n // m ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def possible ( l , K ) : <NEWLINE> <INDENT> cut = 0 <NEWLINE> if l <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cut += ceil ( A [ i ] , l ) - 1 <NEWLINE> if cut > K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> L = sum ( A ) <NEWLINE> <NL> ng = ( L // ( N + K ) ) - 1 <COMMENT> <NEWLINE> ok = max ( A ) <NEWLINE> <NL> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if possible ( mid , K ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> facs = [ 1 ] * N <NEWLINE> invs = [ 1 ] * N <NEWLINE> nfac = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> nfac = nfac * i % mod <NEWLINE> facs [ i ] = nfac <NEWLINE> invs [ i ] = pow ( facs [ i ] , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> d = facs [ N - 1 ] * invs [ i ] * invs [ N - 1 - i ] * M * pow ( M - 1 , N - 1 - i , mod ) % mod <NEWLINE> s = ( s + d ) % mod <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> assert S == <STRING> or <STRING> , <STRING> <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for a in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - a <NEWLINE> if 2 * a + 4 * b == y or 4 * a + 2 * b == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> K = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for d in range ( K ) : <NEWLINE> <INDENT> i = ( 10 * i + 7 ) % K <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( d + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mm = 0 <NEWLINE> mx = 10 ** 5 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> mm = max ( mm , l ) <NEWLINE> mx = min ( mx , r ) <NEWLINE> <DEDENT> print ( max ( mx - mm + 1 , 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = { } <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c [ b [ i ] ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> c [ b [ i ] ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> [ numbers . append ( int ( input ( ) . rstrip ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> max_n = 0 <NEWLINE> second_n = 0 <NEWLINE> <NL> for i in numbers : <NEWLINE> <INDENT> if i > max_n : <NEWLINE> <INDENT> max_n = i <NEWLINE> <DEDENT> elif i > second_n : <NEWLINE> <INDENT> second_n = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in numbers : <NEWLINE> <INDENT> if i == max_n : <NEWLINE> <INDENT> print ( second_n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> par = [ i for i in range ( n + 1 ) ] <NEWLINE> rank = [ 1 for _ in range ( n + 1 ) ] <NEWLINE> <NL> def root ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = root ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return root ( x ) == root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = root ( x ) <NEWLINE> y = root ( y ) <NEWLINE> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ y ] = x <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a , b in edges : <NEWLINE> <INDENT> unite ( a , b ) <NEWLINE> <DEDENT> memo = [ False for _ in range ( n + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> r = root ( i ) <NEWLINE> if memo [ r ] == False : <NEWLINE> <INDENT> memo [ r ] = True <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ 0 ] * m <NEWLINE> visit_sum = [ 0 ] * m <NEWLINE> i = 1 <NEWLINE> sm = x <NEWLINE> visited [ x ] = 1 <NEWLINE> visit_sum [ x ] = x <NEWLINE> work = x <NEWLINE> while i < n : <NEWLINE> <INDENT> work **= 2 <NEWLINE> work %= m <NEWLINE> sm += work <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> if not visited [ work ] : <NEWLINE> <INDENT> visited [ work ] = i <NEWLINE> visit_sum [ work ] = sm <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sm ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> loop_sum = sm - visit_sum [ work ] <NEWLINE> loop_num = i - visited [ work ] <NEWLINE> if visited [ work ] != 1 : <NEWLINE> <INDENT> initial_sum = visit_sum [ visited . index ( visited [ work ] - 1 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_sum = 0 <NEWLINE> <NL> <DEDENT> out = initial_sum <NEWLINE> <COMMENT> <NL> out += ( n - visited [ work ] + 1 ) // loop_num * loop_sum <NEWLINE> <COMMENT> <NL> work_num = ( n - visited [ work ] + 1 ) % loop_num <NEWLINE> if work_num > 0 : <NEWLINE> <INDENT> out += visit_sum [ visited . index ( visited [ work ] - 1 + work_num ) ] - initial_sum <NEWLINE> <NL> <DEDENT> print ( out ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def digitSum ( n ) : <NEWLINE> <INDENT> s = str ( bin ( n ) ) <NEWLINE> s = s [ 2 : ] <NEWLINE> array = list ( map ( int , s ) ) <NEWLINE> return sum ( array ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> X_temp = [ ] <NEWLINE> Y_temp = [ ] <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X_temp . append ( x ) <NEWLINE> Y_temp . append ( y ) <NEWLINE> <DEDENT> X . append ( X_temp ) <NEWLINE> Y . append ( Y_temp ) <NEWLINE> <DEDENT> for i in range ( 1 << N ) : <NEWLINE> <INDENT> judge = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <COMMENT> <NEWLINE> <INDENT> for k in range ( A [ j ] ) : <NEWLINE> <INDENT> if ( i >> X [ j ] [ k ] - 1 ) & 1 != Y [ j ] [ k ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <DEDENT> if judge : <NEWLINE> <INDENT> res = max ( res , digitSum ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
mod = 998244353 <NEWLINE> <NL> N , S , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> dp = [ 1 ] + [ 0 ] * S <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> dp = [ ( 2 * dp [ j ] + ( dp [ j - a ] if j >= a else 0 ) ) % mod for j in range ( S + 1 ) ] <NEWLINE> <NL> <DEDENT> print ( dp [ S ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += d [ i - a [ i ] ] <NEWLINE> d [ i + a [ i ] ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import calendar as C <NEWLINE> j = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> if j : print ( ) <NEWLINE> j = 1 <NEWLINE> if sum ( [ 1 for i in range ( a , b + 1 ) if C . isleap ( i ) ] ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if C . isleap ( i ) : print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> def find ( target ) : <NEWLINE> <INDENT> if parent [ target ] < 0 : <NEWLINE> <INDENT> return target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ target ] = find ( parent [ target ] ) <NEWLINE> return parent [ target ] <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> root_x = find ( x ) <NEWLINE> root_y = find ( y ) <NEWLINE> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if parent [ root_x ] > parent [ root_y ] : <NEWLINE> <INDENT> root_x , root_y = root_y , root_x <NEWLINE> <DEDENT> parent [ root_x ] += parent [ root_y ] <NEWLINE> parent [ root_y ] = root_x <NEWLINE> <NL> <DEDENT> def members ( n , x ) : <NEWLINE> <INDENT> root = find ( x ) <NEWLINE> return [ i for i in range ( n ) if find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def get_size ( x ) : <NEWLINE> <INDENT> return - parent [ find ( x ) ] <NEWLINE> <NL> <DEDENT> def get_root ( ) : <NEWLINE> <INDENT> return [ i for i , root in enumerate ( parent ) if root < 0 ] <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> parent = [ - 1 for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> union ( a , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , get_size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s . append ( [ int ( _ ) for _ in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> dp = [ 0 for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp_s = [ 0 for i in range ( n + 1 ) ] <NEWLINE> dp_s [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> r , l = s [ j ] <NEWLINE> if i - r >= 0 : <NEWLINE> <INDENT> if i - l >= 0 : <NEWLINE> <INDENT> dp [ i ] += dp_s [ i - r + 1 ] - dp_s [ i - l ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] += dp_s [ i - r + 1 ] - dp_s [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp [ i ] = dp [ i ] % 998244353 <NEWLINE> <COMMENT> <NL> dp_s [ i + 1 ] += dp_s [ i ] + dp [ i ] <NEWLINE> dp_s [ i + 1 ] = dp_s [ i + 1 ] % 998244353 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return A , cnt <NEWLINE> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ 1 ] <NEWLINE> while G [ - 1 ] <= n / 9 : <NEWLINE> <INDENT> G . append ( G [ - 1 ] * 3 + 1 ) <NEWLINE> <DEDENT> G = G [ : : - 1 ] <NEWLINE> m = len ( G ) <NEWLINE> for g in G : <NEWLINE> <INDENT> A , cnt = insertionSort ( A , n , g , cnt ) <NEWLINE> <DEDENT> return A , m , G , cnt <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> [ A . append ( int ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> <STRING> <NEWLINE> <NL> A , m , G , cnt = shellSort ( A , n ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in G ] ) ) <NEWLINE> print ( cnt ) <NEWLINE> [ print ( a ) for a in A ] <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement as c <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> arr . append ( l ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> for g in c ( list ( range ( 1 , m + 1 ) ) , n ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> for h in arr : <NEWLINE> <INDENT> if g [ h [ 1 ] - 1 ] - g [ h [ 0 ] - 1 ] == h [ 2 ] : <NEWLINE> <INDENT> f += h [ 3 ] <NEWLINE> <DEDENT> <DEDENT> res = max ( res , f ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> l = [ None ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> minX = min ( [ e [ 0 ] for e in l ] ) <NEWLINE> minY = min ( [ e [ 1 ] for e in l ] ) <NEWLINE> maxX = max ( [ e [ 0 ] for e in l ] ) <NEWLINE> maxY = max ( [ e [ 1 ] for e in l ] ) <NEWLINE> <NL> def d ( _a , _b ) : <NEWLINE> <INDENT> return abs ( _a [ 0 ] - _b [ 0 ] ) + abs ( _a [ 1 ] - _b [ 1 ] ) <NEWLINE> <NL> <DEDENT> s0 = min ( [ d ( [ minX , minY ] , e ) for e in l ] ) <NEWLINE> s1 = min ( [ d ( [ maxX , maxY ] , e ) for e in l ] ) <NEWLINE> <NL> t0 = min ( [ d ( [ maxX , minY ] , e ) for e in l ] ) <NEWLINE> t1 = min ( [ d ( [ minX , maxY ] , e ) for e in l ] ) <NEWLINE> <NL> <NL> print ( d ( [ minX , minY ] , [ maxX , maxY ] ) - min ( s0 + s1 , t0 + t1 ) ) <NEWLINE> <NL> <NL> <NL> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> MOD = 1_000_000_007 <NEWLINE> def dot_MOD ( x1 , x2 , MOD ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = np . zeros ( ( x1 . shape [ 1 ] , x2 . shape [ 0 ] ) , dtype = <STRING> ) <NEWLINE> for i in range ( x1 . shape [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( x2 . shape [ 1 ] ) : <NEWLINE> <INDENT> ret [ i ] [ j ] = np . mod ( x1 [ i , : ] * ( x2 [ : , j ] [ np . newaxis : ] ) , MOD , dtype = <STRING> ) . sum ( ) <NEWLINE> <DEDENT> <DEDENT> ret %= MOD <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def x2_MOD ( x , MOD ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ret = np . empty ( x . shape , dtype = <STRING> ) <NEWLINE> for i in range ( x . shape [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( x . shape [ 0 ] ) : <NEWLINE> <INDENT> ret [ i ] [ j ] = np . mod ( x [ i , : ] * ( x [ : , j ] [ np . newaxis : ] ) , MOD , dtype = <STRING> ) . sum ( ) <NEWLINE> <DEDENT> <DEDENT> ret %= MOD <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , read ( ) . split ( ) ) ) , dtype = <STRING> ) . reshape ( ( N , N ) ) <NEWLINE> ans = np . eye ( N , dtype = <STRING> ) <NEWLINE> while K : <NEWLINE> <INDENT> if K & 1 : <NEWLINE> <INDENT> ans = dot_MOD ( ans , A , MOD ) <NEWLINE> <DEDENT> A = x2_MOD ( A , MOD ) <NEWLINE> K >>= 1 <NEWLINE> <DEDENT> print ( np . mod ( ans . sum ( ) , MOD , dtype = <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in l : <NEWLINE> <INDENT> l . add ( s ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> m = int ( p ** ( 1 / n ) + 1e-9 ) <NEWLINE> <NL> for i in range ( m , 0 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> RedWine = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> RedWine *= A [ i ] <NEWLINE> if RedWine > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if RedWine > 1000000000000000000 : <NEWLINE> <INDENT> if A . count ( 0 ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( RedWine ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> count = int ( N / ( A + B ) ) <NEWLINE> blue_balls = count * A <NEWLINE> <NL> if N % ( A + B ) != 0 : <NEWLINE> <INDENT> if N % ( A + B ) > A : <NEWLINE> <INDENT> blue_balls += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> blue_balls += N % ( A + B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( blue_balls ) <NEWLINE>
import sys <NEWLINE> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = i * 2 + 1 <NEWLINE> r = i * 2 + 2 <NEWLINE> if l < n : <NEWLINE> <INDENT> largest = l <NEWLINE> if r < n and A [ r ] > A [ l ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if A [ largest ] > A [ i ] : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def insert ( S , k ) : <NEWLINE> <INDENT> global n <NEWLINE> S [ n ] = k <NEWLINE> n += 1 <NEWLINE> i = n - 1 <NEWLINE> p = ( i - 1 ) // 2 <NEWLINE> while i > 0 and S [ i ] > S [ p ] : <NEWLINE> <INDENT> S [ i ] , S [ p ] = S [ p ] , S [ i ] <NEWLINE> i = p <NEWLINE> p = ( i - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> def extractMax ( S ) : <NEWLINE> <INDENT> global n <NEWLINE> if n == 1 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> return S [ 0 ] <NEWLINE> <DEDENT> ans = S [ 0 ] <NEWLINE> n -= 1 <NEWLINE> S [ 0 ] = S [ n ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> l = i * 2 + 1 <NEWLINE> r = i * 2 + 2 <NEWLINE> if l >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> largest = l <NEWLINE> if r < n and A [ r ] > A [ l ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if A [ largest ] > A [ i ] : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> i = largest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> A = [ 0 ] * 2000000 <NEWLINE> S = [ ] <NEWLINE> n = 0 <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> insert ( A , int ( s [ 7 : ] ) ) <NEWLINE> <DEDENT> elif s [ 2 ] == <STRING> : <NEWLINE> <INDENT> S . append ( extractMax ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , S ) ) ) <NEWLINE> <NL>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = S ( ) <NEWLINE> n2 = len ( t ) <NEWLINE> <NL> d = { } <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> if x in d : <NEWLINE> <INDENT> y = d [ x ] <NEWLINE> y . append ( i ) <NEWLINE> d [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> ans = 1 <NEWLINE> while j < n2 : <NEWLINE> <INDENT> check = t [ j ] <NEWLINE> if check not in d : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> l = d [ check ] <NEWLINE> if i < l [ 0 ] : <NEWLINE> <INDENT> ans += l [ 0 ] - i + 1 <NEWLINE> i = l [ 0 ] + 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif l [ - 1 ] < i : <NEWLINE> <INDENT> ans += n - ( i + 1 ) + l [ 0 ] + 2 <NEWLINE> i = l [ 0 ] + 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == l [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif i == l [ - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( l ) <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> m = ( right + left ) // 2 <NEWLINE> if l [ m ] >= i : <NEWLINE> <INDENT> right = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = m <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans += l [ right ] - i + 1 <NEWLINE> i = l [ right ] + 1 <NEWLINE> j += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> i %= n <NEWLINE> <NL> <DEDENT> return ans - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> N , M = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> Xs = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> if N < M : <NEWLINE> <INDENT> Xs . sort ( ) <NEWLINE> ds = [ Xs [ i ] - Xs [ i - 1 ] for i in range ( 1 , M ) ] <NEWLINE> ds . sort ( ) <NEWLINE> <COMMENT> <NL> print ( sum ( ds [ : M - N ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> sum = sum * i <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = d [ i - 1 ] + l [ i - 1 ] <NEWLINE> if temp > x : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> d . append ( temp ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = n + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> [ print ( * x ) for x in [ [ sum ( j * k for j , k in zip ( x , y ) ) for y in zip ( * b ) ] for x in a ] ] <NEWLINE>
import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = solve ( n , m , g ) <NEWLINE> if - 1 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( n , m , g ) : <NEWLINE> <INDENT> q = collections . deque ( ) <NEWLINE> distances = [ - 1 for i in range ( n ) ] <NEWLINE> ans = [ - 1 for i in range ( n ) ] <NEWLINE> distances [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> pos = q . popleft ( ) <NEWLINE> for i in g [ pos ] : <NEWLINE> <INDENT> if distances [ i ] == - 1 : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> distances [ i ] = distances [ pos ] + 1 <NEWLINE> ans [ i ] = pos + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> is_zero = False <NEWLINE> is_over = False <NEWLINE> res = 1 <NEWLINE> <NL> for item in A_list : <NEWLINE> <INDENT> if item == 0 : <NEWLINE> <INDENT> is_zero = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for item in A_list : <NEWLINE> <INDENT> res *= item <NEWLINE> <NL> if res > 10 ** 18 : <NEWLINE> <INDENT> is_over = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if is_over : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> mod = 2019 <NEWLINE> rem = [ 0 ] * mod <NEWLINE> rem [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> for k , v in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> now += int ( v ) * pow ( 10 , k , mod ) <NEWLINE> rem [ now % mod ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in rem : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from sys import stdin <NEWLINE> <NL> import time <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> temp = stdin . readline ( ) . split ( ) <NEWLINE> N = int ( temp [ 0 ] ) + 1 <NEWLINE> <NL> out = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> part = np . gcd ( j , i ) <NEWLINE> <COMMENT> <NL> out += np . sum ( np . gcd ( part , np . arange ( 1 , N ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def loop1 ( a ) : <NEWLINE> <COMMENT> <NL> <INDENT> b = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = max ( 0 , i - a [ i ] ) <NEWLINE> r = min ( i + a [ i ] + 1 , n ) <NEWLINE> b [ l ] += 1 <NEWLINE> if r <= n - 1 : b [ r ] -= 1 <NEWLINE> <NL> <DEDENT> b = np . cumsum ( b ) [ : - 1 ] <NEWLINE> return b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for q in range ( min ( 42 , k ) ) : <NEWLINE> <INDENT> a = loop1 ( a ) <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> def Fib ( n ) : <NEWLINE> <INDENT> seq = [ ] <NEWLINE> a , b = 0 , 1 <NEWLINE> for i in range ( 1 , n + 10 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> seq . append ( 0 ) <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> seq . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> seq . append ( b ) <NEWLINE> <DEDENT> <DEDENT> return seq <NEWLINE> <DEDENT> table = Fib ( n ) <NEWLINE> temp = - 1 <NEWLINE> route = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dif = a - temp - 1 <NEWLINE> temp = a <NEWLINE> route = route * table [ dif ] % mod <NEWLINE> <DEDENT> print ( route * table [ n - temp ] % mod ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> pi = 1 <NEWLINE> ni = 0 <NEWLINE> ans = 1 <NEWLINE> i = 0 <NEWLINE> while i < k - 1 : <NEWLINE> <INDENT> if a [ ni ] * a [ ni + 1 ] > a [ - pi ] * a [ - pi - 1 ] : <NEWLINE> <INDENT> ans = ans * a [ ni ] * a [ ni + 1 ] % p <NEWLINE> ni += 2 <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a [ - pi ] % p <NEWLINE> pi += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> ans = ans * a [ - pi ] % p <NEWLINE> <DEDENT> if a [ - 1 ] < 0 and k % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a [ n - k : ] : <NEWLINE> <INDENT> ans = ans * i % p <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> j = 7 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if j % k < 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> j = ( j * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> lst . append ( x ) <NEWLINE> <NL> <DEDENT> lst2 = copy . deepcopy ( lst ) <NEWLINE> lst2 . sort ( ) <NEWLINE> max = max ( lst2 ) <NEWLINE> for x in lst : <NEWLINE> <INDENT> if x == max : <NEWLINE> <INDENT> print ( lst2 [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = A . pop ( - 1 ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ans * A [ N - ( i + 2 ) ] <NEWLINE> if ans > ( 10 ** 18 ) : break <NEWLINE> if ans == 0 : break <NEWLINE> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = list ( s ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] . islower ( ) == True : <NEWLINE> <INDENT> t [ i ] = t [ i ] . upper ( ) <NEWLINE> <DEDENT> elif t [ i ] . isupper ( ) == True : <NEWLINE> <INDENT> t [ i ] = t [ i ] . lower ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
def xor_operate ( a_list ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> result ^= int ( a ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> a_list = input ( ) <NEWLINE> <NL> a_list = a_list . split ( <STRING> ) <NEWLINE> <NL> bit_value = xor_operate ( a_list ) <NEWLINE> <NL> i_list = [ ] <NEWLINE> for a in a_list : <NEWLINE> <INDENT> i_list . append ( str ( bit_value ^ int ( a ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( i_list ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> s = <STRING> <NEWLINE> for c in t : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <NL> <DEDENT> s += c <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( x , y ) <NEWLINE> s = min ( x , y ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> olds = s <NEWLINE> oldl = l <NEWLINE> s = oldl % olds <NEWLINE> l = olds <NEWLINE> <NL> if s == 0 : <NEWLINE> <INDENT> print ( l ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
input ( ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <NL> <DEDENT> return a <NEWLINE> <NL> <DEDENT> s = dict ( Counter ( prime_factorize ( n ) ) ) <NEWLINE> <COMMENT> <NL> sum_ans = 0 <NEWLINE> for i in s . values ( ) : <NEWLINE> <NL> <INDENT> if i == 1 : <NEWLINE> <INDENT> sum_ans += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> k = 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i -= k <NEWLINE> k += 1 <NEWLINE> <COMMENT> <NL> if i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum_ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_ans ) <NEWLINE>
from itertools import combinations , product <NEWLINE> import bisect as bs <NEWLINE> <NL> def tuple_int ( iterable ) : <NEWLINE> <INDENT> return tuple ( map ( int , iterable . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def S_with_K_plots ( plots , K ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> X , Y = sorted ( [ x for x , y in plots ] ) , sorted ( [ y for x , y in plots ] ) <NEWLINE> for xinf , xsup in combinations ( X , 2 ) : <NEWLINE> <INDENT> for yinf in Y : <NEWLINE> <INDENT> ysup = [ y for x , y in plots if xinf <= x <= xsup and y >= yinf ] <NEWLINE> if len ( ysup ) < K : continue <NEWLINE> ysup . sort ( ) <NEWLINE> result . append ( ( xsup - xinf ) * ( ysup [ K - 1 ] - yinf ) ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> with open ( 0 ) as f : <NEWLINE> <INDENT> N , K = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> plots = list ( map ( tuple_int , f . readlines ( ) ) ) <NEWLINE> <DEDENT> print ( min ( S_with_K_plots ( plots , K ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> str_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum0 = str_list [ 0 ] <NEWLINE> <NL> for n in range ( 0 , N ) : <NEWLINE> <INDENT> if str_list [ n ] == 0 : <NEWLINE> <INDENT> sum0 = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( 1 , N ) : <NEWLINE> <INDENT> if sum0 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum0 = sum0 * str_list [ n ] <NEWLINE> if sum0 > 10 ** 18 : <NEWLINE> <INDENT> sum0 = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum0 ) <NEWLINE>
s = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> tsum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tsum += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tsum ) <NEWLINE>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> count = [ 0 ] * a <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in num_list : <NEWLINE> <INDENT> count [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> if count [ i ] == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_sum = 0 <NEWLINE> tmp_sum = 0 <NEWLINE> <NL> tmp_sum = sum ( array ) <NEWLINE> <NL> for a in array : <NEWLINE> <INDENT> tmp_sum -= a <NEWLINE> num_sum += tmp_sum * a <NEWLINE> <NL> <DEDENT> print ( num_sum % 1000000007 ) <NEWLINE>
def ABC_86_B ( ) : <NEWLINE> <INDENT> T = list ( input ( ) ) <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> ABC_86_B ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from typing import List , Tuple <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <NL> def binary_mod ( bits : List [ int ] , div : int ) -> int : <NEWLINE> <INDENT> if div == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> val = 0 <NEWLINE> for b in bits : <NEWLINE> <INDENT> val = ( val * 2 + b ) % div <NEWLINE> <DEDENT> return val <NEWLINE> <NL> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> x = x % bin ( x ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> popcount = sum ( X ) <NEWLINE> div1 = popcount + 1 <NEWLINE> div2 = popcount - 1 <NEWLINE> <NL> if popcount == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , [ 1 ] * N ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rem1 = binary_mod ( X , div1 ) <NEWLINE> rem2 = binary_mod ( X , div2 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> r = ( rem1 + pow ( 2 , N - 1 - i , div1 ) ) % div1 <NEWLINE> print ( f ( r ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if div2 > 0 : <NEWLINE> <INDENT> r = ( rem2 - pow ( 2 , N - 1 - i , div2 ) + div2 ) % div2 <NEWLINE> print ( f ( r ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( sorted ( p ) [ : K ] ) ) <NEWLINE>
<COMMENT> <NL> s = str ( input ( ) ) <NEWLINE> <NL> mod = 2019 <NEWLINE> <NL> div_memo = [ 0 for _ in range ( mod ) ] <NEWLINE> <NL> num = 0 <NEWLINE> d = 1 <NEWLINE> for n in reversed ( s ) : <NEWLINE> <INDENT> num += int ( n ) * d <NEWLINE> num %= 2019 <NEWLINE> div_memo [ num ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( div_memo ) ) : <NEWLINE> <INDENT> ans += div_memo [ i ] * ( div_memo [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans += div_memo [ 0 ] <NEWLINE> print ( int ( ans ) ) <NEWLINE>
<STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> high = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> calc = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans += calc [ i - high [ i - 1 ] ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if ( i + high [ i - 1 ] ) in calc . keys ( ) : <NEWLINE> <INDENT> calc [ i + high [ i - 1 ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc [ i + high [ i - 1 ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s ^= a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( a [ i ] ^ s ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def comb ( n , r ) : <NEWLINE> <INDENT> if ( r < 0 and r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % MOD <NEWLINE> <NL> <DEDENT> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % MOD ) <NEWLINE> inverse . append ( ( - inverse [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % MOD ) <NEWLINE> <NL> <DEDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if not ( X + Y ) % 3 : <NEWLINE> <INDENT> m = ( 2 * X - Y ) // 3 <NEWLINE> n = ( 2 * Y - X ) // 3 <NEWLINE> if n >= 0 and m >= 0 : <NEWLINE> <INDENT> print ( comb ( n + m , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ ] <NEWLINE> l = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> cnt . append ( - 1 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> cnt [ l [ i ] ] = 0 <NEWLINE> <DEDENT> cnt [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ i ] = cnt [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> cnt [ i ] += cnt [ i - 2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt [ n ] % 1000000007 ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> j = 0 <NEWLINE> for i in arr [ k : ] : <NEWLINE> <INDENT> if i > arr [ j ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> j += 1 <NEWLINE> <DEDENT>
from _collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> f [ a ] . append ( b ) <NEWLINE> f [ b ] . append ( a ) <NEWLINE> <DEDENT> g = [ 0 ] * ( n + 1 ) <NEWLINE> p = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> p [ i ] = i <NEWLINE> data = [ i ] <NEWLINE> data = deque ( data ) <NEWLINE> while len ( data ) > 0 : <NEWLINE> <INDENT> pos = data . popleft ( ) <NEWLINE> p [ pos ] = i <NEWLINE> for j in f [ pos ] : <NEWLINE> <INDENT> if p [ j ] == 0 : <NEWLINE> <INDENT> data . append ( j ) <NEWLINE> <DEDENT> <DEDENT> f [ pos ] = [ ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> g [ p [ i + 1 ] ] += 1 <NEWLINE> <DEDENT> print ( max ( g ) ) <NEWLINE> <NL>
<COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> cnt += S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for k in range ( N ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> i = 2 * j - k <NEWLINE> if i < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ [ 0 for i in range ( 10 ) ] for j in range ( 12 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> list [ 3 * ( b - 1 ) + ( f - 1 ) ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> if i % 3 == 0 and i != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( list [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> if j == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ [ i , a [ i ] ] for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> aa . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( aa [ i ] [ 0 ] + 1 , end = <STRING> ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_sum . append ( A_sum [ i ] + A [ i ] ) <NEWLINE> <DEDENT> B_sum = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B_sum . append ( B_sum [ i ] + B [ i ] ) <NEWLINE> <DEDENT> B_sum . append ( 10 ** 10 ) <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( len ( A_sum ) ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( B_sum ) <NEWLINE> while high - low > 1 : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if A_sum [ i ] + B_sum [ mid ] <= K : <NEWLINE> <INDENT> low = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> if A_sum [ i ] + B_sum [ low ] <= K : <NEWLINE> <INDENT> res = max ( res , i + low ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
class PrimeChecker : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . primes = [ 2 , 3 , 5 ] <NEWLINE> <NL> <DEDENT> def isPrime ( self , n ) : <NEWLINE> <INDENT> if n in self . primes : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n < self . primes [ - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in self . primes : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i = self . primes [ - 1 ] <NEWLINE> w = 2 if i % 6 == 5 else 4 <NEWLINE> <NL> while i * i <= n : <NEWLINE> <INDENT> if self . isPrime ( i ) : <NEWLINE> <INDENT> self . primes . append ( i ) <NEWLINE> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> i += w <NEWLINE> w = 6 - w <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> primeChecker = PrimeChecker ( ) <NEWLINE> count = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if primeChecker . isPrime ( ( int ( input ( ) ) ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> areaOfCircle = format ( r * r * math . pi , <STRING> ) <NEWLINE> circumference = format ( 2 * r * math . pi , <STRING> ) <NEWLINE> print ( <STRING> . format ( areaOfCircle , circumference ) ) <NEWLINE>
def permutations ( L ) : <NEWLINE> <NL> <INDENT> if L == [ ] : <NEWLINE> <INDENT> return [ [ ] ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> <NL> <COMMENT> <NL> S = sorted ( set ( L ) ) <NEWLINE> <NL> for i in S : <NEWLINE> <NL> <INDENT> data = L [ : ] <NEWLINE> data . remove ( i ) <NEWLINE> <NL> for j in permutations ( data ) : <NEWLINE> <INDENT> ret . append ( [ i ] + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bou = [ 1 ] * N <NEWLINE> ball = [ 2 ] * ( M - 1 ) <NEWLINE> <NL> junretsu = permutations ( bou + ball ) <NEWLINE> <NL> a , b , c , d = [ ] , [ ] , [ ] , [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> b . append ( B ) <NEWLINE> c . append ( C ) <NEWLINE> d . append ( D ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( junretsu ) ) : <NEWLINE> <INDENT> souwa = 0 <NEWLINE> check = 0 <NEWLINE> A = [ ] <NEWLINE> for j in range ( N + M - 1 ) : <NEWLINE> <INDENT> if junretsu [ i ] [ j ] == 1 : <NEWLINE> <INDENT> A . append ( j - check + 1 ) <NEWLINE> check += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> if ( A [ b [ j ] - 1 ] - A [ a [ j ] - 1 ] ) == c [ j ] : <NEWLINE> <INDENT> souwa += d [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , souwa ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a_i = x <NEWLINE> log = [ x ] <NEWLINE> app = [ - 1 ] * m <NEWLINE> app [ x ] = 0 <NEWLINE> last = x <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a_i = ( a_i ** 2 ) % m <NEWLINE> if app [ a_i ] > - 1 : <NEWLINE> <INDENT> last = a_i <NEWLINE> break <NEWLINE> <DEDENT> app [ a_i ] = i <NEWLINE> log . append ( a_i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( log [ : min ( n , app [ last ] ) ] ) <NEWLINE> if n > app [ last ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans += sum ( log [ app [ last ] : ] ) * ( ( n - app [ last ] ) // ( len ( log ) - app [ last ] ) ) <NEWLINE> <COMMENT> <NL> ans += sum ( log [ app [ last ] : app [ last ] + ( n - app [ last ] ) % ( len ( log ) - app [ last ] ) ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b = int ( n ** 0.5 ) <NEWLINE> i = 2 <NEWLINE> l = [ ] <NEWLINE> while i <= b : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> n = n // i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n > b : <NEWLINE> <INDENT> l . append ( n ) <NEWLINE> <DEDENT> c = collections . Counter ( l ) <NEWLINE> v = list ( c . values ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for vv in v : <NEWLINE> <INDENT> wa = 1 <NEWLINE> s = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if vv < wa : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += 1 <NEWLINE> wa += s <NEWLINE> <DEDENT> ans += ( s - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> c = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( line ) <NEWLINE> c -= 1 <NEWLINE> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] . strip ( ) . split ( <STRING> ) <NEWLINE> for j in range ( 0 , len ( a [ i ] ) ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( a [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> kousya = [ <NEWLINE> [ <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ] , <NEWLINE> [ <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ] , <NEWLINE> [ <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ] , <NEWLINE> [ <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ] <NEWLINE> ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> kousya [ i [ 0 ] - 1 ] [ i [ 1 ] - 1 ] [ i [ 2 ] - 1 ] += i [ 3 ] <NEWLINE> <NL> <DEDENT> touc = 0 <NEWLINE> for tou in kousya : <NEWLINE> <INDENT> for kai in tou : <NEWLINE> <INDENT> for heya in kai : <NEWLINE> <INDENT> print ( <STRING> + str ( heya ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if touc != len ( kousya ) - 1 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> touc += 1 <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = [ None ] * m <NEWLINE> c = [ None ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> _b , _c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> b [ i ] = _b <NEWLINE> c [ i ] = _c <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> cnt = collections . Counter ( a ) <NEWLINE> <NL> <COMMENT> <NL> for j in range ( m ) : <NEWLINE> <INDENT> cnt . update ( { c [ j ] : b [ j ] } ) <NEWLINE> <NL> <DEDENT> a_tup = cnt . items ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> res = 0 <NEWLINE> num_cnt = 0 <NEWLINE> for _ in sorted ( a_tup , reverse = True ) : <NEWLINE> <INDENT> res += _ [ 0 ] * _ [ 1 ] <NEWLINE> num_cnt += _ [ 1 ] <NEWLINE> <NL> if num_cnt >= n : <NEWLINE> <INDENT> res -= _ [ 0 ] * ( num_cnt - n ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from bisect import bisect_right <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> B = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> As = np . cumsum ( A ) <NEWLINE> Bs = np . cumsum ( B ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i , a in enumerate ( As ) : <NEWLINE> <INDENT> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect_right ( Bs , K - a ) <NEWLINE> <COMMENT> <NL> count = max ( count , ( i + j - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( a ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( a ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> q = 0 <NEWLINE> while abs ( x ) > q ** 4 : <NEWLINE> <INDENT> q += 1 <NEWLINE> <NL> <DEDENT> deta = False <NEWLINE> for A in range ( - q , q + 1 ) : <NEWLINE> <INDENT> if deta : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for B in range ( - q , q + 1 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == x : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> deta = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ ai [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for m in range ( n ) : <NEWLINE> <INDENT> print ( b [ m ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> count = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> <NL> for a_i in A : <NEWLINE> <INDENT> count [ a_i ] += 1 <NEWLINE> <NL> <DEDENT> bef_ans = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = count [ B ] <NEWLINE> count [ B ] = 0 <NEWLINE> count [ C ] += tmp <NEWLINE> ans = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> for j in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> ans += j * count [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = bef_ans - B * tmp + C * tmp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> bef_ans = ans <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = input ( ) <NEWLINE> <NL> password_list = [ ] <NEWLINE> initial_list = [ ] <NEWLINE> initial_list2 = [ ] <NEWLINE> initial_list3 = [ ] <NEWLINE> <NL> for i in range ( len ( num ) - 2 ) : <NEWLINE> <INDENT> initial_list2 = [ ] <NEWLINE> if num [ i ] in initial_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( initial_list ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_list . append ( num [ i ] ) <NEWLINE> for j in range ( i + 1 , len ( num ) - 1 ) : <NEWLINE> <INDENT> initial_list3 = [ ] <NEWLINE> if num [ j ] in initial_list2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( initial_list2 ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_list2 . append ( num [ j ] ) <NEWLINE> for k in range ( j + 1 , len ( num ) ) : <NEWLINE> <INDENT> if num [ k ] in initial_list3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( initial_list3 ) == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> initial_list3 . append ( num [ k ] ) <NEWLINE> target = num [ i ] + num [ j ] + num [ k ] <NEWLINE> if target not in password_list : <NEWLINE> <INDENT> password_list . append ( target ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( password_list ) ) <NEWLINE>
import sys <NEWLINE> <NL> alphabets = <STRING> <NEWLINE> <NL> cnt = { } <NEWLINE> for c in alphabets : <NEWLINE> <INDENT> cnt [ c ] = 0 <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> for c in line : <NEWLINE> <INDENT> if <STRING> <= c . lower ( ) <= <STRING> : <NEWLINE> <INDENT> cnt [ c . lower ( ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for c in alphabets : <NEWLINE> <INDENT> print ( <STRING> % ( c , cnt [ c ] ) ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def amari ( m , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return amari ( m , n / 2 ) ** 2 % 1000000007 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return m * amari ( m , n - 1 ) % 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( amari ( m , n ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> s = set ( ) <NEWLINE> x = a [ 0 ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> flg = True <NEWLINE> flg2 = False <NEWLINE> if i < n - 1 and a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> flg = False <NEWLINE> flg2 = True <NEWLINE> <DEDENT> if a [ i ] in s : <NEWLINE> <INDENT> flg = False <NEWLINE> flg2 = False <NEWLINE> <NL> <DEDENT> if flg : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if flg or flg2 : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> while x <= 10 ** 6 : <NEWLINE> <INDENT> s . add ( x ) <NEWLINE> x += a [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] > A [ i ] : <NEWLINE> <INDENT> s += A [ i - 1 ] - A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> X1 , Y1 , X2 , Y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> dist = math . sqrt ( ( X2 - X1 ) ** 2 + ( Y2 - Y1 ) ** 2 ) <NEWLINE> print ( dist ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> print ( a [ n - 1 - i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ 0 ] ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for X in range ( k + 1 ) : <NEWLINE> <INDENT> for Y in range ( k + 1 ) : <NEWLINE> <INDENT> Z = s - X - Y <NEWLINE> if k >= Z >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> from itertools import combinations <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . __make_set ( ) <NEWLINE> <NL> <DEDENT> def __make_set ( self ) : <NEWLINE> <INDENT> self . _parent = list ( range ( self . N + 1 ) ) <NEWLINE> self . _rank = [ 0 ] * ( self . N + 1 ) <NEWLINE> self . _size = [ 1 ] * ( self . N + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . _parent [ x ] != x : <NEWLINE> <INDENT> self . _parent [ x ] = self . find ( self . _parent [ x ] ) <NEWLINE> <DEDENT> return self . _parent [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x_root = self . find ( x ) <NEWLINE> y_root = self . find ( y ) <NEWLINE> <NL> if x_root == y_root : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> x_rank = self . _rank [ x_root ] <NEWLINE> y_rank = self . _rank [ y_root ] <NEWLINE> if x_rank > y_rank : <NEWLINE> <INDENT> self . _parent [ y_root ] = x_root <NEWLINE> self . _size [ x_root ] += self . _size [ y_root ] <NEWLINE> <DEDENT> elif x_rank < y_rank : <NEWLINE> <INDENT> self . _parent [ x_root ] = y_root <NEWLINE> self . _size [ y_root ] += self . _size [ x_root ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _parent [ y_root ] = x_root <NEWLINE> self . _rank [ x_root ] += 1 <NEWLINE> self . _size [ x_root ] += self . _size [ y_root ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same_set ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return self . _size [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> uf = UnionFind ( N ) <NEWLINE> ans = [ 0 ] * M <NEWLINE> ans [ - 1 ] = N * ( N - 1 ) // 2 <NEWLINE> for i in reversed ( range ( M - 1 ) ) : <NEWLINE> <INDENT> a , b = A [ i + 1 ] , B [ i + 1 ] <NEWLINE> if uf . same_set ( a , b ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = ans [ i + 1 ] - uf . size ( a ) * uf . size ( b ) <NEWLINE> <DEDENT> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> count = int ( input ( ) ) <NEWLINE> input_list = [ int ( i ) for i in sys . stdin . readlines ( ) ] <NEWLINE> <NL> first = 0 <NEWLINE> second = 1 <NEWLINE> maxv = - 1000000000 <NEWLINE> minv = input_list [ first ] <NEWLINE> <NL> for i in input_list [ second : ] : <NEWLINE> <INDENT> if i - minv > maxv : <NEWLINE> <INDENT> maxv = i - minv <NEWLINE> <DEDENT> if i < minv : <NEWLINE> <INDENT> minv = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> j = 1 <NEWLINE> <NL> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( - 1 , n - j + 1 ) [ j != 1 ] ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> str = a [ 0 ] + b [ 0 ] + c [ 0 ] <NEWLINE> print ( str ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> k = N % ( A + B ) <NEWLINE> add = 0 <NEWLINE> if k < A : <NEWLINE> <INDENT> add = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = A <NEWLINE> <DEDENT> print ( N // ( A + B ) * A + add ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] <NEWLINE> E = sum ( a ) ** 2 <NEWLINE> s = 0 <NEWLINE> s = sum ( i * i for i in a ) <NEWLINE> print ( ( ( E - s ) // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A [ : : - 1 ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def dfs ( now_node , parent_node , dist ) : <NEWLINE> <INDENT> depth [ now_node ] = dist <NEWLINE> for next_node , w in graph [ now_node ] : <NEWLINE> <INDENT> if next_node == parent_node : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( next_node , now_node , dist + w ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , c ) ) <NEWLINE> graph [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> depth = [ - 1 ] * ( n + 1 ) <NEWLINE> dfs ( k , 0 , 0 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( depth [ x ] + depth [ y ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = inpl ( ) <NEWLINE> flag = 0 <NEWLINE> t = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> aaa = 0 <NEWLINE> <NL> if not flag : <NEWLINE> <NL> <INDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> t *= a [ i ] <NEWLINE> if t > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> aaa = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not aaa : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r_cnt = 0 <NEWLINE> g_cnt = 0 <NEWLINE> b_cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r_cnt += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g_cnt += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> if n < 4 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , math . floor ( ( len ( s ) - 2 ) / 2 ) + 10 ) : <NEWLINE> <INDENT> for j in range ( n - 2 * i ) : <NEWLINE> <INDENT> tmp = s [ j ] + s [ j + i ] + s [ j + 2 * i ] <NEWLINE> if ( tmp == <STRING> ) or ( tmp == <STRING> ) or ( tmp == <STRING> ) or ( tmp == <STRING> ) or ( tmp == <STRING> ) or ( tmp == <STRING> ) : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , pena = 0 , 0 <NEWLINE> N , M = MI ( ) <NEWLINE> P = [ 0 ] * N <NEWLINE> PENA = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> p -= 1 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if P [ p ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> P [ p ] = 1 <NEWLINE> if PENA [ p ] != 0 : <NEWLINE> <INDENT> pena += PENA [ p ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if P [ p ] == 0 : <NEWLINE> <INDENT> PENA [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans , pena ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> data = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> data . append ( [ int ( x ) for x in line . strip ( ) . split ( <STRING> ) ] ) <NEWLINE> if len ( data ) == 2 : <NEWLINE> <INDENT> choice_a = data [ 0 ] <NEWLINE> choice_b = data [ 1 ] <NEWLINE> data = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> hit = 0 <NEWLINE> blow = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i , d in enumerate ( choice_a ) : <NEWLINE> <INDENT> if d in choice_b : <NEWLINE> <INDENT> if d == choice_b [ i ] : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( hit , blow ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> def gcd ( a , b , c ) : <NEWLINE> <INDENT> return math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or i == k or j == k : <NEWLINE> <INDENT> ans += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j , k ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lsab = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lsab . append ( [ a , b ] ) <NEWLINE> <DEDENT> lscd = [ ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lscd . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> lsans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> max1 = 4 * 10 ** 8 + 100 <NEWLINE> ans = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> dis = abs ( lsab [ i ] [ 0 ] - lscd [ j ] [ 0 ] ) + abs ( lsab [ i ] [ 1 ] - lscd [ j ] [ 1 ] ) <NEWLINE> if dis < max1 : <NEWLINE> <INDENT> ans = j + 1 <NEWLINE> max1 = dis <NEWLINE> <DEDENT> <DEDENT> lsans . append ( ans ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( lsans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = int ( s , 2 ) <NEWLINE> pcx = s . count ( <STRING> ) <NEWLINE> pc1 = x % ( pcx - 1 ) if pcx > 1 else 0 <NEWLINE> pc2 = x % ( pcx + 1 ) <NEWLINE> <NL> def f ( j ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while j : <NEWLINE> <INDENT> j %= bin ( j ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> for i , y in enumerate ( s ) : <NEWLINE> <INDENT> k = n - 1 - i <NEWLINE> if y == <STRING> : <NEWLINE> <INDENT> print ( f ( ( pc2 + pow ( 2 , k , pcx + 1 ) ) % ( pcx + 1 ) ) + 1 ) <NEWLINE> <DEDENT> elif pcx > 1 : <NEWLINE> <INDENT> print ( f ( ( pc1 - pow ( 2 , k , pcx - 1 ) ) % ( pcx - 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> import numpy as np <NEWLINE> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n . insert ( 0 , 0 ) <NEWLINE> m . insert ( 0 , 0 ) <NEWLINE> n = np . array ( n ) <NEWLINE> m = np . array ( m ) <NEWLINE> n = n . cumsum ( ) <NEWLINE> m = m . cumsum ( ) <NEWLINE> ans = 0 <NEWLINE> j = len ( m ) - 1 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while m [ j ] > k - n [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> dp = np . full ( ( 3 , n + 1 ) , - pow ( 10 , 15 ) ) <NEWLINE> dp [ : , 0 ] = 0 <NEWLINE> dp [ 1 , 1 ] = a [ 0 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> l , r = max ( 1 , i // 2 - 1 ) , ( i + 1 ) // 2 + 1 <NEWLINE> if i % 3 == 2 : <NEWLINE> <INDENT> now , pre , prepre = 2 , 1 , 0 <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> now , pre , prepre = 0 , 2 , 1 <NEWLINE> <DEDENT> elif i % 3 == 1 : <NEWLINE> <INDENT> now , pre , prepre = 1 , 0 , 2 <NEWLINE> <DEDENT> dp [ now , l : r ] = np . maximum ( dp [ pre , l : r ] , dp [ prepre , l - 1 : r - 1 ] + a [ i - 1 ] ) <NEWLINE> <DEDENT> print ( dp [ now , n // 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = ( 10 ** 9 + 7 ) <NEWLINE> ans = 0 <NEWLINE> nn = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans %= MOD <NEWLINE> ans += la [ i ] % MOD <NEWLINE> nn %= MOD <NEWLINE> nn += ( la [ i ] ** 2 ) % MOD <NEWLINE> <DEDENT> ans = ( ans ** 2 - nn + 10 ** 9 + 7 ) * pow ( 2 , - 1 , MOD ) % MOD <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * N <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> c [ l [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c . count ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = N // a <NEWLINE> <NL> if N % a == 0 : <NEWLINE> <INDENT> ans += x - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> input_line2 = input ( ) <NEWLINE> <NL> a_list = list ( map ( int , input_line2 . split ( ) ) ) <NEWLINE> <NL> counts = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( len ( a_list ) ) : <NEWLINE> <INDENT> counts [ a_list [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for c in counts : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> s = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> s *= a <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif s == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif n == 100 : <NEWLINE> <INDENT> if x > 50 : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> c = 0 <NEWLINE> for e in p : <NEWLINE> <INDENT> d . append ( abs ( e - x ) ) <NEWLINE> <DEDENT> d1 = d [ 0 ] <NEWLINE> z = p [ 0 ] <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] < d1 : <NEWLINE> <INDENT> d1 = d [ i ] <NEWLINE> z = p [ i ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for g in p : <NEWLINE> <INDENT> if z + j != g : <NEWLINE> <INDENT> c += 1 <NEWLINE> w1 = z + j <NEWLINE> <DEDENT> <DEDENT> if c == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> c = 0 <NEWLINE> for j2 in range ( 1 , 100 ) : <NEWLINE> <INDENT> for g2 in p : <NEWLINE> <INDENT> if z - j2 != g2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> w2 = z - j2 <NEWLINE> <DEDENT> <DEDENT> if c == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> if w2 < 0 : <NEWLINE> <INDENT> print ( w1 ) <NEWLINE> <DEDENT> elif abs ( w1 - x ) < abs ( w2 - x ) : <NEWLINE> <INDENT> print ( w1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w2 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <COMMENT> <NEWLINE> z = [ ] <COMMENT> <NEWLINE> an = 0 <NEWLINE> zn = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> zn += 1 <NEWLINE> z . append ( y ) <NEWLINE> <DEDENT> elif y == n : <NEWLINE> <INDENT> an += 1 <NEWLINE> a . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> a . sort ( ) <NEWLINE> z . sort ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i < an and j < zn : <NEWLINE> <INDENT> if a [ i ] == z [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] > z [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> stk = deque ( [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> while stk : <NEWLINE> <INDENT> v = stk . pop ( ) <NEWLINE> for s in G [ v ] : <NEWLINE> <COMMENT> <NL> <INDENT> if ans [ s ] == 0 : <NEWLINE> <INDENT> ans [ s ] = v <NEWLINE> stk . appendleft ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ans [ 2 : ] <NEWLINE> <NL> if 0 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> tmp = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> sum %= mod <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum -= a [ i ] <NEWLINE> if sum < 0 : <NEWLINE> <INDENT> sum += mod <NEWLINE> <DEDENT> tmp += a [ i ] * sum <NEWLINE> tmp %= mod <NEWLINE> <DEDENT> print ( tmp ) <NEWLINE>
<COMMENT> <NL> <NL> N , M = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> scores = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] <= B [ j ] : <NEWLINE> <INDENT> scores [ i ] += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> max_i , max_val = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if scores [ i ] > max_val : <NEWLINE> <INDENT> max_val = scores [ i ] <NEWLINE> max_i = i <NEWLINE> <DEDENT> <DEDENT> print ( max_i + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> cc = Counter ( ) <NEWLINE> ans = 0 <NEWLINE> for i , val in enumerate ( A , 1 ) : <NEWLINE> <INDENT> if i - val > 0 : <NEWLINE> <INDENT> ans += cc [ i - val ] <NEWLINE> <DEDENT> cc [ i + val ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> def dfs ( x , y ) : <NEWLINE> <INDENT> global count <NEWLINE> if x >= N or y >= N : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if ( A [ x ] + A [ y ] ) == y - x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> if x + 1 >= N and y + 1 >= N : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if y + 1 >= N : <NEWLINE> <INDENT> dfs ( x + 1 , x + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( x , y + 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> List = [ ( A , B ) for A in range ( - 120 , 120 ) for B in range ( - 120 , 120 ) if A ** 5 - B ** 5 == X ] <NEWLINE> <NL> print ( * List [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> for i in A_i : <NEWLINE> <INDENT> C [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * C ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> <NL> def get ( k ) : <NEWLINE> <INDENT> ans = 7 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ans % k == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> ans = ( ans * 10 + 7 ) % k <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( get ( k ) ) <NEWLINE> <NL> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> hlist = [ 0 ] * H <NEWLINE> wlist = [ 0 ] * W <NEWLINE> sets = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> hlist [ h ] += 1 <NEWLINE> wlist [ w ] += 1 <NEWLINE> sets . add ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> hmax = 0 <NEWLINE> hind = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if hmax < hlist [ i ] : <NEWLINE> <INDENT> hmax = hlist [ i ] <NEWLINE> hind = [ i ] <NEWLINE> <DEDENT> elif hmax == hlist [ i ] : <NEWLINE> <INDENT> hind . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> wmax = 0 <NEWLINE> wind = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if wmax < wlist [ i ] : <NEWLINE> <INDENT> wmax = wlist [ i ] <NEWLINE> wind = [ i ] <NEWLINE> <DEDENT> elif wmax == wlist [ i ] : <NEWLINE> <INDENT> wind . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> for h in hind : <NEWLINE> <INDENT> for w in wind : <NEWLINE> <INDENT> if ( h , w ) not in sets : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hmax + wmax - 1 ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ - 1 for _ in range ( n ) ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> flg = True <NEWLINE> <NL> for a in B : <NEWLINE> <INDENT> x = a [ 0 ] <NEWLINE> y = a [ 1 ] <NEWLINE> <NL> if A [ x - 1 ] == - 1 : <NEWLINE> <INDENT> A [ x - 1 ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ x - 1 ] != y : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if flg : <NEWLINE> <COMMENT> <NL> <INDENT> for i , j in enumerate ( A ) : <NEWLINE> <INDENT> if j == - 1 : <NEWLINE> <INDENT> if i == 0 and len ( A ) != 1 : <NEWLINE> <INDENT> A [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tmp = <STRING> <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> tmp += str ( A [ k ] ) <NEWLINE> <DEDENT> tmp = str ( int ( tmp ) ) <NEWLINE> if len ( tmp ) == n : <NEWLINE> <INDENT> ans = int ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( map ( str , sorted ( data ) ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> s = list ( input ( ) ) <NEWLINE> s = Counter ( s ) <NEWLINE> print ( min ( s [ <STRING> ] , s [ <STRING> ] ) * 2 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> seen = [ False ] * ( n + 1 ) <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( 1 ) <NEWLINE> <NL> while len ( que ) != 0 : <NEWLINE> <INDENT> k = que . popleft ( ) <NEWLINE> seen [ k ] = True <NEWLINE> <NL> for i in graph [ k ] : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = k <NEWLINE> que . append ( i ) <NEWLINE> seen [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans [ 2 : ] <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> import math <NEWLINE> d = defaultdict ( int ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = math . gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> k = ( 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( 0 , 1 ) <NEWLINE> <DEDENT> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> k = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if b < 0 : <NEWLINE> <INDENT> a , b = a // x , - ( ( - b ) // x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = a // x , b // x <NEWLINE> <DEDENT> k = ( a , b ) <NEWLINE> <DEDENT> d [ k ] += 1 <NEWLINE> <NL> <DEDENT> ind = defaultdict ( int ) <NEWLINE> index = 1 <NEWLINE> _ans = [ 1 ] <NEWLINE> for a , b in list ( d . keys ( ) ) : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if b <= 0 : <NEWLINE> <INDENT> _k = ( - b , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _k = ( b , - a ) <NEWLINE> <DEDENT> if d [ _k ] == 0 : <NEWLINE> <INDENT> _ans [ 0 ] *= pow ( 2 , d [ ( a , b ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ind [ _k ] == 0 : <NEWLINE> <INDENT> _ans . append ( pow ( 2 , d [ ( a , b ) ] , MOD ) ) <NEWLINE> ind [ ( a , b ) ] = index <NEWLINE> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _ans [ ind [ _k ] ] += pow ( 2 , d [ ( a , b ) ] , MOD ) - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for a in _ans : <NEWLINE> <INDENT> ans = ans * a % MOD <NEWLINE> <DEDENT> print ( ( d [ ( 0 , 0 ) ] + ans - 1 + MOD ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> Q . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def check ( i , A , B , C ) : <NEWLINE> <INDENT> if A < 0 or B < 0 or C < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if Q [ i ] == <STRING> : <NEWLINE> <INDENT> return not ( A == 0 and B == 0 ) <NEWLINE> <DEDENT> if Q [ i ] == <STRING> : <NEWLINE> <INDENT> return not ( A == 0 and C == 0 ) <NEWLINE> <DEDENT> return not ( B == 0 and C == 0 ) <NEWLINE> <NL> <DEDENT> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> if Q [ i ] == <STRING> : <NEWLINE> <INDENT> if A == 0 and B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A += 1 <NEWLINE> B -= 1 <NEWLINE> if B < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A -= 1 <NEWLINE> B += 1 <NEWLINE> if A < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif Q [ i ] == <STRING> : <NEWLINE> <INDENT> if A == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A += 1 <NEWLINE> C -= 1 <NEWLINE> if C < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A -= 1 <NEWLINE> C += 1 <NEWLINE> if A < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> B += 1 <NEWLINE> C -= 1 <NEWLINE> if C < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> B -= 1 <NEWLINE> C += 1 <NEWLINE> if B < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not check ( i , A , B , C ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if Q [ i ] == <STRING> : <NEWLINE> <INDENT> if check ( i + 1 , A + 1 , B - 1 , C ) : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A += 1 <NEWLINE> B -= 1 <NEWLINE> if B < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif check ( i + 1 , A - 1 , B + 1 , C ) : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A -= 1 <NEWLINE> B += 1 <NEWLINE> if A < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif Q [ i ] == <STRING> : <NEWLINE> <INDENT> if check ( i + 1 , A + 1 , B , C - 1 ) : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A += 1 <NEWLINE> C -= 1 <NEWLINE> if C < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif check ( i + 1 , A - 1 , B , C + 1 ) : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> A -= 1 <NEWLINE> C += 1 <NEWLINE> if A < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if check ( i + 1 , A , B + 1 , C - 1 ) : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> B += 1 <NEWLINE> C -= 1 <NEWLINE> if C < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif check ( i + 1 , A , B - 1 , C + 1 ) : <NEWLINE> <INDENT> L . append ( <STRING> ) <NEWLINE> B -= 1 <NEWLINE> C += 1 <NEWLINE> if B < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in L : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans *= A [ i + 1 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> table = [ [ 0 for j in range ( c + 1 ) ] for i in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> temp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if not j == c : <NEWLINE> <INDENT> table [ i ] [ j ] = temp [ j ] <NEWLINE> table [ i ] [ c ] += temp [ j ] <NEWLINE> <DEDENT> table [ r ] [ j ] += table [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j != c : <NEWLINE> <INDENT> print ( table [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( table [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> <NL> x = 7 % K <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> x = ( x * 10 + 7 ) % K <NEWLINE> <NL> <DEDENT> if i == K : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> alst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> work = [ inf ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> j = bisect_right ( work , alst [ i ] ) <NEWLINE> work [ j ] = alst [ i ] <NEWLINE> <DEDENT> print ( n - work . count ( inf ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> while True : <NEWLINE> <INDENT> if s . find ( <STRING> ) == - 1 and s . find ( <STRING> ) == - 1 : <NEWLINE> <INDENT> index = s . rfind ( <STRING> ) <NEWLINE> if index == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> e = s [ index : ] . find ( <STRING> ) <NEWLINE> s = s [ : index ] + s [ index + 1 : index + e ] [ : : - 1 ] + s [ index + e + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> index = s . find ( <STRING> ) <NEWLINE> <DEDENT> if s . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> if s . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> index = min ( index , s . find ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = s . find ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> e = index <NEWLINE> f = 0 <NEWLINE> while s [ e ] == <STRING> or s [ e ] == <STRING> : <NEWLINE> <INDENT> if s [ e ] == <STRING> : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f -= 1 <NEWLINE> <DEDENT> e += 1 <NEWLINE> <DEDENT> r = s [ e ] <NEWLINE> if r != <STRING> : <NEWLINE> <INDENT> r = chr ( ( ord ( r ) - ord ( <STRING> ) + f ) % 26 + ord ( <STRING> ) ) <NEWLINE> <DEDENT> s = s [ : index ] + r + s [ e + 1 : ] <NEWLINE> <DEDENT> <DEDENT> print ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if ( n % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . sort ( ) <NEWLINE> out = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 + i , n ) : <NEWLINE> <INDENT> out += bisect . bisect_left ( lis , lis [ i ] + lis [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
import cmath , math , sys <NEWLINE> z = 0 ; p = 90 <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> r , d = map ( int , e . split ( <STRING> ) ) <NEWLINE> z += cmath . rect ( r , math . radians ( p ) ) <NEWLINE> p -= d <NEWLINE> <DEDENT> print ( int ( z . real ) , <STRING> , int ( z . imag ) , sep = <STRING> ) <NEWLINE>
r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> while K > 0 : <NEWLINE> <INDENT> if g <= r : <NEWLINE> <INDENT> g *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> elif b <= g : <NEWLINE> <INDENT> b *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if g > r and b > g : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> p_change = [ ] <NEWLINE> m = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in p : <NEWLINE> <INDENT> p_change . append ( abs ( i - x ) ) <NEWLINE> <NL> <DEDENT> if x in p : <NEWLINE> <INDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i != 0 and p_change . count ( i ) != 2 : <NEWLINE> <INDENT> m = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if x - m in p : <NEWLINE> <INDENT> print ( x + m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - m ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buka = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> buka [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for b in buka : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> count = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> count = count * i <NEWLINE> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif count > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = input ( ) . split ( ) <NEWLINE> r = int ( N [ 0 ] ) <NEWLINE> c = int ( N [ 1 ] ) <NEWLINE> d = [ [ 0 for i in range ( c ) ] for j in range ( r ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> data = input ( ) . split ( ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> d [ i ] [ j ] = int ( data [ j ] ) <NEWLINE> <DEDENT> <DEDENT> sum2 = [ 0 for i in range ( c ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> line = <STRING> <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> line += str ( d [ i ] [ j ] ) <NEWLINE> line += <STRING> <NEWLINE> sum2 [ j ] += d [ i ] [ j ] <NEWLINE> <DEDENT> line += str ( sum ( d [ i ] ) ) <NEWLINE> print ( line ) <NEWLINE> <DEDENT> line2 = <STRING> <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> line2 += str ( sum2 [ i ] ) <NEWLINE> line2 += <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( line2 , sum ( sum2 ) ) ) <NEWLINE>
<NL> v , e = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> g = [ [ ] for i in range ( v ) ] <COMMENT> <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( t ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> color = [ <STRING> for i in range ( v ) ] <COMMENT> <NEWLINE> <NL> def dfs ( u ) : <NEWLINE> <INDENT> color [ u ] = <STRING> <NEWLINE> <NL> for adj in g [ u ] : <NEWLINE> <INDENT> if color [ adj ] == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif color [ adj ] == <STRING> : <NEWLINE> <INDENT> if dfs ( adj ) == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> color [ u ] = <STRING> <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for u in range ( v ) : <NEWLINE> <INDENT> color [ i in range ( v ) ] = <STRING> <NEWLINE> if dfs ( u ) == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def dfs ( G , C , id , color ) : <NEWLINE> <INDENT> S = deque ( ) <NEWLINE> S . append ( id ) <NEWLINE> C [ id ] = color <NEWLINE> <NL> while S : <NEWLINE> <INDENT> u = S . pop ( ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( G [ u ] ) ) : <NEWLINE> <INDENT> v = G [ u ] [ i ] <NEWLINE> if C [ v ] == - 1 : <NEWLINE> <INDENT> C [ v ] = color <NEWLINE> S . append ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_users , num_of_links = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> links = [ ] <NEWLINE> for _ in range ( num_of_links ) : <NEWLINE> <INDENT> links . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> num_of_queries = int ( input ( ) ) <NEWLINE> queries = [ ] <NEWLINE> for _ in range ( num_of_queries ) : <NEWLINE> <INDENT> queries . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> G = [ [ ] for _ in range ( 100000 ) ] <NEWLINE> C = [ - 1 ] * 100000 <NEWLINE> for f , t in links : <NEWLINE> <INDENT> G [ f ] . append ( t ) <NEWLINE> G [ t ] . append ( f ) <NEWLINE> <NL> <DEDENT> color = 1 <NEWLINE> for id in range ( num_of_users ) : <NEWLINE> <INDENT> if C [ id ] == - 1 : <NEWLINE> <INDENT> dfs ( G , C , id , color ) <NEWLINE> <DEDENT> color += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for x , y in queries : <NEWLINE> <INDENT> if C [ x ] == C [ y ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import permutations <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , deque <NEWLINE> from fractions import gcd <NEWLINE> from math import factorial , sqrt , ceil <NEWLINE> from functools import lru_cache , reduce <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def dijkstra_heap ( s , edge , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ 10 ** 20 ] * n <NEWLINE> used = [ True ] * n <COMMENT> <NEWLINE> d [ s ] = 0 <NEWLINE> used [ s ] = False <NEWLINE> edgelist = [ ] <NEWLINE> for a , b in edge [ s ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , a * ( 10 ** 6 ) + b ) <NEWLINE> <DEDENT> while len ( edgelist ) : <NEWLINE> <INDENT> minedge = heapq . heappop ( edgelist ) <NEWLINE> <COMMENT> <NL> if not used [ minedge % ( 10 ** 6 ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = minedge % ( 10 ** 6 ) <NEWLINE> d [ v ] = minedge // ( 10 ** 6 ) <NEWLINE> used [ v ] = False <NEWLINE> for e in edge [ v ] : <NEWLINE> <INDENT> if used [ e [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , ( e [ 0 ] + d [ v ] ) * ( 10 ** 6 ) + e [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm , numbers , 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( gcd , numbers ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> p = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if p ** 2 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> p += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def eratosthenes ( limit ) : <NEWLINE> <INDENT> A = [ i for i in range ( 2 , limit + 1 ) ] <NEWLINE> P = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> prime = min ( A ) <NEWLINE> <NL> if prime > sqrt ( limit ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> P . append ( prime ) <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( A ) : <NEWLINE> <INDENT> if A [ i ] % prime == 0 : <NEWLINE> <INDENT> A . pop ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> P . append ( a ) <NEWLINE> <NL> <DEDENT> return P <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def permutation_with_duplicates ( L ) : <NEWLINE> <NL> <INDENT> if L == [ ] : <NEWLINE> <INDENT> return [ [ ] ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> <NL> <COMMENT> <NL> S = sorted ( set ( L ) ) <NEWLINE> <NL> for i in S : <NEWLINE> <NL> <INDENT> data = L [ : ] <NEWLINE> data . remove ( i ) <NEWLINE> <NL> for j in permutation_with_duplicates ( data ) : <NEWLINE> <INDENT> ret . append ( [ i ] + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for i in range ( q ) ] <NEWLINE> b = [ 0 for i in range ( q ) ] <NEWLINE> c = [ 0 for i in range ( q ) ] <NEWLINE> d = [ 0 for i in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] -= 1 <NEWLINE> b [ i ] -= 1 <NEWLINE> <NL> <DEDENT> def dfs ( n , m , i , a ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> global x <NEWLINE> x . append ( a ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if len ( a ) > 0 : <NEWLINE> <INDENT> for j in range ( a [ - 1 ] , m + 1 ) : <NEWLINE> <INDENT> dfs ( n , m , i + 1 , a + [ j ] ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> dfs ( n , m , i + 1 , a + [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x = [ ] <NEWLINE> dfs ( n , m , 0 , [ ] ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if i [ b [ j ] ] - i [ a [ j ] ] == c [ j ] : <NEWLINE> <INDENT> cnt += d [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> from bisect import bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> def getCount ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> idx = bisect_left ( A , x - a ) <NEWLINE> <COMMENT> <NL> cnt += N - idx <NEWLINE> <COMMENT> <NL> <DEDENT> return cnt >= M <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ng = 10 ** 9 <NEWLINE> ok = 0 <NEWLINE> <COMMENT> <NL> while ng - ok > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if getCount ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> B = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> idx = bisect_left ( A , ok - A [ i ] ) <NEWLINE> ans += B [ N ] - B [ idx ] + A [ i ] * ( N - idx ) <NEWLINE> cnt += N - idx <NEWLINE> <NL> <DEDENT> rest = ( cnt - M ) * ok <NEWLINE> print ( ans - rest ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if W >= V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if A > B : <NEWLINE> <INDENT> V *= - 1 <NEWLINE> W *= - 1 <NEWLINE> <NL> A = A + V * T <NEWLINE> B = B + W * T <NEWLINE> if A <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = A + V * T <NEWLINE> B = B + W * T <NEWLINE> <NL> if A >= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for num in range ( r ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S . append ( A ) <NEWLINE> A . append ( sum ( A ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> C = [ ] <NEWLINE> for t in ( zip ( * S ) ) : <NEWLINE> <INDENT> C . append ( sum ( t ) ) <NEWLINE> <DEDENT> S . append ( C ) <NEWLINE> for i in S : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> <NL> n_max = math . ceil ( math . sqrt ( N ) ) <NEWLINE> res = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for x in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v <= N : <NEWLINE> <INDENT> res [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> X = B - 1 <NEWLINE> X = min ( B - 1 , N ) <NEWLINE> ans = ( A * X ) // B - A * ( X // B ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> class Unionfind : <NEWLINE> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . uf = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . uf [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . uf [ x ] = self . find ( self . uf [ x ] ) <NEWLINE> return self . uf [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . uf [ x ] > self . uf [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . uf [ x ] += self . uf [ y ] <NEWLINE> self . uf [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> return - self . uf [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> xy2 = [ [ x [ 0 ] , x [ 1 ] , i ] for ( i , x ) in enumerate ( xy ) ] <NEWLINE> xy2 . sort ( ) <NEWLINE> u = Unionfind ( n ) <NEWLINE> <NL> l = [ ] <NEWLINE> for x , y , ind in xy2 : <NEWLINE> <INDENT> M = y <NEWLINE> le = ind <NEWLINE> while l and xy [ l [ - 1 ] ] [ 1 ] < y : <NEWLINE> <INDENT> v = l . pop ( ) <NEWLINE> if M > xy [ v ] [ 1 ] : <NEWLINE> <INDENT> M = xy [ v ] [ 1 ] <NEWLINE> le = v <NEWLINE> <DEDENT> u . union ( ind , v ) <NEWLINE> <DEDENT> l . append ( le ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( u . size ( i ) ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> student = list ( range ( N ) ) <NEWLINE> <NL> student . sort ( key = lambda i : list_A [ i ] ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += str ( student [ i ] + 1 ) + <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> ans = ans . strip ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def dfs ( s , Map , H , W , c ) : <NEWLINE> <INDENT> dxdy = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , - 1 ) ] <NEWLINE> for i in range ( len ( dxdy ) ) : <NEWLINE> <INDENT> Map [ s [ 0 ] ] [ s [ 1 ] ] = c <NEWLINE> nextPos = ( s [ 0 ] + dxdy [ i ] [ 0 ] , s [ 1 ] + dxdy [ i ] [ 1 ] ) <NEWLINE> if nextPos [ 0 ] >= 0 and nextPos [ 1 ] >= 0 and nextPos [ 0 ] < H and nextPos [ 1 ] < W : <NEWLINE> <INDENT> if Map [ nextPos [ 0 ] ] [ nextPos [ 1 ] ] == 1 : <NEWLINE> <INDENT> dfs ( nextPos , Map , H , W , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> W , H = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Map = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 0 , H ) ] <NEWLINE> c = 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> dfs ( ( i , j ) , Map , H , W , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> flag = [ 0 ] * ( n + 1 ) <NEWLINE> flag [ 0 ] = 1 <NEWLINE> flag [ 1 ] = 1 <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> <NL> guidepost = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if flag [ i ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag [ i ] = 1 <NEWLINE> d . append ( i ) <NEWLINE> if guidepost [ i ] != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> guidepost [ i ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not all ( guidepost ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = guidepost [ 2 : ] <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
class Node ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , parent , left , right ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . height = None <NEWLINE> <NL> <DEDENT> def get_type ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif self . left == - 1 and self . right == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def get_depth ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> depth = 1 <NEWLINE> t = Nodes [ self . parent ] <NEWLINE> while t . parent != - 1 : <NEWLINE> <INDENT> t = Nodes [ t . parent ] <NEWLINE> depth += 1 <NEWLINE> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> <DEDENT> def get_height ( self ) : <NEWLINE> <INDENT> if self . height : <NEWLINE> <INDENT> return self . height <NEWLINE> <DEDENT> h_left = 0 <NEWLINE> h_right = 0 <NEWLINE> if self . left != - 1 : <NEWLINE> <INDENT> h_left = Nodes [ self . left ] . get_height ( ) + 1 <NEWLINE> <DEDENT> if self . right != - 1 : <NEWLINE> <INDENT> h_right = Nodes [ self . right ] . get_height ( ) + 1 <NEWLINE> <DEDENT> self . height = max ( h_left , h_right ) <NEWLINE> return self . height <NEWLINE> <NL> <DEDENT> def get_degree ( self ) : <NEWLINE> <INDENT> degree = 0 <NEWLINE> if self . left != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> <DEDENT> if self . right != - 1 : <NEWLINE> <INDENT> degree += 1 <NEWLINE> <DEDENT> return degree <NEWLINE> <NL> <DEDENT> def get_sibling ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> p = Nodes [ self . parent ] <NEWLINE> if Nodes [ p . left ] != self and Nodes [ p . left ] != - 1 : <NEWLINE> <INDENT> return p . left <NEWLINE> <DEDENT> if Nodes [ p . right ] != self and Nodes [ p . right ] != - 1 : <NEWLINE> <INDENT> return p . right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def process_node_data ( data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num_of_elem = len ( data ) <NEWLINE> if num_of_elem != 3 : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> my_id , left , right = data <NEWLINE> Nodes [ my_id ] . left = left <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> Nodes [ left ] . parent = my_id <NEWLINE> <DEDENT> Nodes [ my_id ] . right = right <NEWLINE> if right != - 1 : <NEWLINE> <INDENT> Nodes [ right ] . parent = my_id <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def walk_preorder ( Nodes , current_id ) : <NEWLINE> <INDENT> results = [ ] <NEWLINE> results . append ( current_id ) <NEWLINE> if Nodes [ current_id ] . left != - 1 : <NEWLINE> <INDENT> results . append ( walk_preorder ( Nodes , Nodes [ current_id ] . left ) ) <NEWLINE> <DEDENT> if Nodes [ current_id ] . right != - 1 : <NEWLINE> <INDENT> results . append ( walk_preorder ( Nodes , Nodes [ current_id ] . right ) ) <NEWLINE> <DEDENT> return results <NEWLINE> <NL> <NL> <DEDENT> def walk_inorder ( Nodes , current_id ) : <NEWLINE> <INDENT> results = [ ] <NEWLINE> if Nodes [ current_id ] . left != - 1 : <NEWLINE> <INDENT> results . append ( walk_inorder ( Nodes , Nodes [ current_id ] . left ) ) <NEWLINE> <DEDENT> results . append ( current_id ) <NEWLINE> if Nodes [ current_id ] . right != - 1 : <NEWLINE> <INDENT> results . append ( walk_inorder ( Nodes , Nodes [ current_id ] . right ) ) <NEWLINE> <DEDENT> return results <NEWLINE> <NL> <NL> <DEDENT> def walk_postorder ( Nodes , current_id ) : <NEWLINE> <INDENT> results = [ ] <NEWLINE> if Nodes [ current_id ] . left != - 1 : <NEWLINE> <INDENT> results . append ( walk_postorder ( Nodes , Nodes [ current_id ] . left ) ) <NEWLINE> <DEDENT> if Nodes [ current_id ] . right != - 1 : <NEWLINE> <INDENT> results . append ( walk_postorder ( Nodes , Nodes [ current_id ] . right ) ) <NEWLINE> <DEDENT> results . append ( current_id ) <NEWLINE> return results <NEWLINE> <NL> <NL> <DEDENT> def flatten ( l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> for el in l : <NEWLINE> <INDENT> if isinstance ( el , collections . Iterable ) and not isinstance ( el , ( str , bytes ) ) : <NEWLINE> <INDENT> yield from flatten ( el ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield el <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> MAX_NODES = 25 <NEWLINE> <COMMENT> <NL> Nodes = [ Node ( - 1 , None , None ) for _ in range ( MAX_NODES ) ] <NEWLINE> <NL> <COMMENT> <NL> num_of_nodes = int ( input ( ) ) <NEWLINE> node_data = [ ] <NEWLINE> for i in range ( num_of_nodes ) : <NEWLINE> <INDENT> t = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> node_data . append ( t ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for d in node_data : <NEWLINE> <INDENT> process_node_data ( d ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> root_id = - 1 <NEWLINE> for i , n in enumerate ( Nodes ) : <NEWLINE> <INDENT> if n . parent == - 1 : <NEWLINE> <INDENT> root_id = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> result = walk_preorder ( Nodes , root_id ) <NEWLINE> print ( <STRING> . format ( <STRING> . join ( map ( str , flatten ( result ) ) ) ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> result = walk_inorder ( Nodes , root_id ) <NEWLINE> print ( <STRING> . format ( <STRING> . join ( map ( str , flatten ( result ) ) ) ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> result = walk_postorder ( Nodes , root_id ) <NEWLINE> print ( <STRING> . format ( <STRING> . join ( map ( str , flatten ( result ) ) ) ) ) <NEWLINE> <DEDENT>
a , b , c = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> print ( a , b , c ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <COMMENT> <NL> <NL> <NL> dictionary = { } <NEWLINE> for A , B in AB : <NEWLINE> <INDENT> if dictionary . get ( A ) is None : <NEWLINE> <INDENT> dictionary [ A ] = [ ] <NEWLINE> <DEDENT> if dictionary . get ( B ) is None : <NEWLINE> <INDENT> dictionary [ B ] = [ ] <NEWLINE> <NL> <DEDENT> dictionary [ A ] . append ( H [ B - 1 ] ) <NEWLINE> dictionary [ B ] . append ( H [ A - 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i , heights in dictionary . items ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if H [ i - 1 ] > max ( heights ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> import itertools <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if dictionary . get ( i ) is None : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from itertools import product <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> <NL> def neighbors ( ih , iw ) : <NEWLINE> <INDENT> for ih1 , iw1 in ( <NEWLINE> <INDENT> ( ih - 1 , iw ) , <NEWLINE> ( ih + 1 , iw ) , <NEWLINE> ( ih , iw - 1 ) , <NEWLINE> ( ih , iw + 1 ) , <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> if 0 <= ih1 < h and 0 <= iw1 < w and maze [ ih1 ] [ iw1 ] == <STRING> : <NEWLINE> <INDENT> yield ( ih1 , iw1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def len_maze ( ih , iw ) : <NEWLINE> <COMMENT> <NL> <INDENT> if maze [ ih ] [ iw ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> stepped = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> q0 = [ ( ih , iw ) ] <NEWLINE> l = - 1 <NEWLINE> while q0 : <NEWLINE> <INDENT> q1 = set ( ) <NEWLINE> for ih0 , iw0 in q0 : <NEWLINE> <INDENT> stepped [ ih0 ] [ iw0 ] = True <NEWLINE> for ih1 , iw1 in neighbors ( ih0 , iw0 ) : <NEWLINE> <INDENT> if not stepped [ ih1 ] [ iw1 ] : <NEWLINE> <INDENT> q1 . add ( ( ih1 , iw1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q0 = list ( q1 ) <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> return l <NEWLINE> <NL> <NL> <DEDENT> answer = max ( len_maze ( ih , iw ) for ih , iw in product ( range ( h ) , range ( w ) ) ) <NEWLINE> print ( answer ) <NEWLINE>
from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( floor ( A * x / B ) - A * floor ( x / B ) ) <NEWLINE>
global A <NEWLINE> <NL> def max_heapfy ( i ) : <NEWLINE> <INDENT> left = 2 * i + 1 <NEWLINE> right = 2 * i + 2 <NEWLINE> <NL> max_val = 0 <NEWLINE> if left < H and A [ i ] < A [ left ] : <NEWLINE> <INDENT> max_val = left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_val = i <NEWLINE> <NL> <DEDENT> if right < H and A [ max_val ] < A [ right ] : <NEWLINE> <INDENT> max_val = right <NEWLINE> <NL> <DEDENT> if max_val != i : <NEWLINE> <INDENT> temp = A [ i ] <NEWLINE> A [ i ] = A [ max_val ] <NEWLINE> A [ max_val ] = temp <NEWLINE> max_heapfy ( max_val ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> global H <NEWLINE> H = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in reversed ( range ( H // 2 ) ) : <NEWLINE> <INDENT> max_heapfy ( i ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( <STRING> . format ( a ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> num = int ( m ** 0.5 ) + 1 <NEWLINE> <NL> for i in range ( 1 , num ) : <NEWLINE> <INDENT> if m % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = m // i <NEWLINE> if i >= n : <NEWLINE> <INDENT> ans = max ( ans , j ) <NEWLINE> <DEDENT> if j >= n : <NEWLINE> <INDENT> ans = max ( ans , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> FORMAT = ( <STRING> <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> ) . format <NEWLINE> <NL> <NL> <DEDENT> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . id = data [ 0 ] <NEWLINE> self . parent = - 1 <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = int ( data [ 1 ] >= 0 ) + int ( data [ 2 ] >= 0 ) <NEWLINE> <COMMENT> <NL> self . childs = data [ 1 : ] <NEWLINE> self . depth = 0 <NEWLINE> self . height = - 1 <NEWLINE> self . type = <STRING> if self . degree else <STRING> <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return FORMAT ( self ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc_depth ( tree , i ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> for k , j in enumerate ( tree [ i ] . childs ) : <NEWLINE> <INDENT> if j >= 0 : <NEWLINE> <INDENT> tree [ j ] . depth += 1 <NEWLINE> tree [ j ] . sibling = tree [ i ] . childs [ 1 - k ] <NEWLINE> h = max ( h , calc_depth ( tree , j ) ) <NEWLINE> <DEDENT> <DEDENT> if tree [ i ] . type == <STRING> : <NEWLINE> <INDENT> tree [ i ] . height = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ i ] . height = h <NEWLINE> <DEDENT> return tree [ i ] . height + 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( stdin . readline ( ) ) <NEWLINE> tree = [ - 1 ] * n <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> node = Node ( [ int ( s ) for s in stdin . readline ( ) . split ( ) ] ) <NEWLINE> parent = tree [ node . id ] <NEWLINE> tree [ node . id ] = node <NEWLINE> if isinstance ( parent , int ) : <NEWLINE> <INDENT> tree [ node . id ] . parent = parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ node . id ] . parent = parent . id <NEWLINE> <DEDENT> for i in node . childs : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> if isinstance ( tree [ i ] , int ) : <NEWLINE> <INDENT> tree [ i ] = node . id <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ i ] . parent = node . id <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> calc_depth ( tree , i ) <NEWLINE> <NL> <DEDENT> for node in tree : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> print ( node ) <NEWLINE> <DEDENT>
import queue <NEWLINE> while 1 : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = queue . deque ( int ( input ( ) ) for _ in range ( k ) ) <NEWLINE> m = b = sum ( a ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> c = a . popleft ( ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> a . append ( d ) <NEWLINE> b += d - c <NEWLINE> m = max ( b , m ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s2 = sum ( map ( lambda x : x ** 2 , s ) ) <NEWLINE> ans = ( ( ( sum ( s ) ) ** 2 ) - ( s2 ) ) // 2 % mod <NEWLINE> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def judge ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> while n != 1 : <NEWLINE> <INDENT> if n % i != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> n //= i <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def get_prime ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime = [ 2 ] <NEWLINE> limit = int ( math . sqrt ( n ) ) <NEWLINE> <NL> data = [ i + 1 for i in range ( 2 , n , 2 ) ] <NEWLINE> while limit > data [ 0 ] : <NEWLINE> <INDENT> prime . append ( data [ 0 ] ) <NEWLINE> data = [ j for j in data if j % data [ 0 ] != 0 ] <NEWLINE> <DEDENT> return prime + data <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> i = 2 <NEWLINE> limit = int ( math . sqrt ( N ) ) <NEWLINE> while N != 1 : <NEWLINE> <NL> <INDENT> if i > limit : <NEWLINE> <INDENT> if N > i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if N % i == 0 and judge ( i ) : <NEWLINE> <INDENT> N //= i <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > L : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> L = 10 ** 18 <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ None ] * 200000 <NEWLINE> cc = set ( ) <NEWLINE> p = 0 <NEWLINE> st = 0 <NEWLINE> ed = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> c [ i ] = p <NEWLINE> cc . add ( p ) <NEWLINE> i += 1 <NEWLINE> p = a [ p ] <NEWLINE> if p in cc : <NEWLINE> <INDENT> st = c . index ( p ) <NEWLINE> ed = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k < ed : <NEWLINE> <INDENT> print ( c [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= st <NEWLINE> k %= ed - st <NEWLINE> print ( c [ st + k ] + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> S = sum ( lst ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> S = S - lst [ i ] <NEWLINE> tmp = lst [ i ] * S <NEWLINE> ans = ( ans + tmp ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> tmp += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> c . append ( tmp ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = input ( ) . split ( ) <NEWLINE> N = int ( n [ 0 ] ) <NEWLINE> K = int ( n [ 1 ] ) <NEWLINE> <NL> listb = [ 1 ] <NEWLINE> listc = [ 0 ] * N <NEWLINE> C = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> C = A [ C - 1 ] <NEWLINE> if listc [ C - 1 ] == 0 : <NEWLINE> <INDENT> listb . append ( C ) <NEWLINE> listc [ C - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = listb . index ( C ) <NEWLINE> listb . append ( C ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> L = len ( listb ) - 1 <NEWLINE> <NL> if K <= N : <NEWLINE> <INDENT> print ( listb [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if L - D == 1 or L - D == 0 : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = ( K - D ) % ( L - D ) <NEWLINE> print ( listb [ ( D + M ) % L ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> A = set ( A ) <NEWLINE> MAX_A = 10 ** 6 <NEWLINE> X = [ 0 ] * ( MAX_A + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( a , MAX_A + 1 , a ) : <NEWLINE> <INDENT> X [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( [ a for a in A if ( X [ a ] == 1 ) and ( C [ a ] == 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> fft = np . fft . rfft <NEWLINE> ifft = np . fft . irfft <NEWLINE> mod = 998244353 <NEWLINE> <NL> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = 3003 <NEWLINE> <NL> dp = np . zeros ( U + 10 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> newDP = dp . copy ( ) * 2 <NEWLINE> newDP [ a : ] += dp [ : - a ] <NEWLINE> newDP %= mod <NEWLINE> dp = newDP <NEWLINE> <NL> <DEDENT> print ( dp [ S ] ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n // 2 <NEWLINE> y = sorted ( x ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bisect . bisect_right ( y , x [ i ] ) > m : <NEWLINE> <INDENT> print ( y [ m - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ m ] ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> tmp_a = 0 <NEWLINE> tmp_b = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp_a += i <NEWLINE> a . append ( tmp_a ) <NEWLINE> <NL> <DEDENT> for i in B : <NEWLINE> <INDENT> tmp_b += i <NEWLINE> b . append ( tmp_b ) <NEWLINE> <NL> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <COMMENT> <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> if b [ j ] <= ( K - a [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def func ( N , A ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> S = sum ( A ) % MOD <NEWLINE> for x in A : <NEWLINE> <INDENT> S -= x <NEWLINE> S %= MOD <NEWLINE> result += x * S <NEWLINE> result %= MOD <NEWLINE> <DEDENT> result %= MOD <NEWLINE> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( func ( N , A ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l = [ ( i + 1 ) / 2 for i in l ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> from itertools import accumulate <NEWLINE> cum = [ 0 ] + list ( accumulate ( l ) ) <NEWLINE> <NL> <COMMENT> <NL> sum_k = [ ] <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> sum_k . append ( cum [ k + j ] - cum [ j ] ) <NEWLINE> <NL> <DEDENT> print ( max ( sum_k ) ) <NEWLINE>
<COMMENT> <NL> <NL> import copy <NEWLINE> import functools <NEWLINE> import typing <NEWLINE> <NL> <NL> def _sa_naive ( s : typing . List [ int ] ) -> typing . List [ int ] : <NEWLINE> <INDENT> sa = list ( range ( len ( s ) ) ) <NEWLINE> return sorted ( sa , key = lambda i : s [ i : ] ) <NEWLINE> <NL> <NL> <DEDENT> def _sa_doubling ( s : typing . List [ int ] ) -> typing . List [ int ] : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> sa = list ( range ( n ) ) <NEWLINE> rnk = copy . deepcopy ( s ) <NEWLINE> tmp = [ 0 ] * n <NEWLINE> k = 1 <NEWLINE> while k < n : <NEWLINE> <INDENT> def cmp ( x : int , y : int ) -> bool : <NEWLINE> <INDENT> if rnk [ x ] != rnk [ y ] : <NEWLINE> <INDENT> return rnk [ x ] - rnk [ y ] <NEWLINE> <DEDENT> rx = rnk [ x + k ] if x + k < n else - 1 <NEWLINE> ry = rnk [ y + k ] if y + k < n else - 1 <NEWLINE> return rx - ry <NEWLINE> <DEDENT> sa . sort ( key = functools . cmp_to_key ( cmp ) ) <NEWLINE> tmp [ sa [ 0 ] ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp [ sa [ i ] ] = tmp [ sa [ i - 1 ] ] + ( 1 if cmp ( sa [ i - 1 ] , sa [ i ] ) else 0 ) <NEWLINE> <DEDENT> tmp , rnk = rnk , tmp <NEWLINE> k *= 2 <NEWLINE> <DEDENT> return sa <NEWLINE> <NL> <NL> <DEDENT> def _sa_is ( s : typing . List [ int ] , upper : int ) -> typing . List [ int ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> threshold_naive = 10 <NEWLINE> threshold_doubling = 40 <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> return [ 0 ] <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> if s [ 0 ] < s [ 1 ] : <NEWLINE> <INDENT> return [ 0 , 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ 1 , 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if n < threshold_naive : <NEWLINE> <INDENT> return _sa_naive ( s ) <NEWLINE> <DEDENT> if n < threshold_doubling : <NEWLINE> <INDENT> return _sa_doubling ( s ) <NEWLINE> <NL> <DEDENT> sa = [ 0 ] * n <NEWLINE> ls = [ False ] * n <NEWLINE> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> ls [ i ] = ls [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls [ i ] = s [ i ] < s [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> sum_l = [ 0 ] * ( upper + 1 ) <NEWLINE> sum_s = [ 0 ] * ( upper + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not ls [ i ] : <NEWLINE> <INDENT> sum_s [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_l [ s [ i ] + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( upper + 1 ) : <NEWLINE> <INDENT> sum_s [ i ] += sum_l [ i ] <NEWLINE> if i < upper : <NEWLINE> <INDENT> sum_l [ i + 1 ] += sum_s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def induce ( lms : typing . List [ int ] ) -> None : <NEWLINE> <INDENT> nonlocal sa <NEWLINE> sa = [ - 1 ] * n <NEWLINE> <NL> buf = copy . deepcopy ( sum_s ) <NEWLINE> for d in lms : <NEWLINE> <INDENT> if d == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sa [ buf [ s [ d ] ] ] = d <NEWLINE> buf [ s [ d ] ] += 1 <NEWLINE> <NL> <DEDENT> buf = copy . deepcopy ( sum_l ) <NEWLINE> sa [ buf [ s [ n - 1 ] ] ] = n - 1 <NEWLINE> buf [ s [ n - 1 ] ] += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = sa [ i ] <NEWLINE> if v >= 1 and not ls [ v - 1 ] : <NEWLINE> <INDENT> sa [ buf [ s [ v - 1 ] ] ] = v - 1 <NEWLINE> buf [ s [ v - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> buf = copy . deepcopy ( sum_l ) <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> v = sa [ i ] <NEWLINE> if v >= 1 and ls [ v - 1 ] : <NEWLINE> <INDENT> buf [ s [ v - 1 ] + 1 ] -= 1 <NEWLINE> sa [ buf [ s [ v - 1 ] + 1 ] ] = v - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> lms_map = [ - 1 ] * ( n + 1 ) <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if not ls [ i - 1 ] and ls [ i ] : <NEWLINE> <INDENT> lms_map [ i ] = m <NEWLINE> m += 1 <NEWLINE> <DEDENT> <DEDENT> lms = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if not ls [ i - 1 ] and ls [ i ] : <NEWLINE> <INDENT> lms . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> induce ( lms ) <NEWLINE> <NL> if m : <NEWLINE> <INDENT> sorted_lms = [ ] <NEWLINE> for v in sa : <NEWLINE> <INDENT> if lms_map [ v ] != - 1 : <NEWLINE> <INDENT> sorted_lms . append ( v ) <NEWLINE> <DEDENT> <DEDENT> rec_s = [ 0 ] * m <NEWLINE> rec_upper = 0 <NEWLINE> rec_s [ lms_map [ sorted_lms [ 0 ] ] ] = 0 <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> left = sorted_lms [ i - 1 ] <NEWLINE> right = sorted_lms [ i ] <NEWLINE> if lms_map [ left ] + 1 < m : <NEWLINE> <INDENT> end_l = lms [ lms_map [ left ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end_l = n <NEWLINE> <DEDENT> if lms_map [ right ] + 1 < m : <NEWLINE> <INDENT> end_r = lms [ lms_map [ right ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end_r = n <NEWLINE> <NL> <DEDENT> same = True <NEWLINE> if end_l - left != end_r - right : <NEWLINE> <INDENT> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while left < end_l : <NEWLINE> <INDENT> if s [ left ] != s [ right ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> left += 1 <NEWLINE> right += 1 <NEWLINE> <DEDENT> if left == n or s [ left ] != s [ right ] : <NEWLINE> <INDENT> same = False <NEWLINE> <NL> <DEDENT> <DEDENT> if not same : <NEWLINE> <INDENT> rec_upper += 1 <NEWLINE> <DEDENT> rec_s [ lms_map [ sorted_lms [ i ] ] ] = rec_upper <NEWLINE> <NL> <DEDENT> rec_sa = _sa_is ( rec_s , rec_upper ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> sorted_lms [ i ] = lms [ rec_sa [ i ] ] <NEWLINE> <DEDENT> induce ( sorted_lms ) <NEWLINE> <NL> <DEDENT> return sa <NEWLINE> <NL> <NL> <DEDENT> def suffix_array ( s : typing . Union [ str , typing . List [ int ] ] , <NEWLINE> <INDENT> upper : typing . Optional [ int ] = None ) -> typing . List [ int ] : <NEWLINE> if isinstance ( s , str ) : <NEWLINE> return _sa_is ( [ ord ( c ) for c in s ] , 255 ) <NEWLINE> elif upper is None : <NEWLINE> n = len ( s ) <NEWLINE> idx = list ( range ( n ) ) <NEWLINE> idx . sort ( key = functools . cmp_to_key ( lambda l , r : s [ l ] - s [ r ] ) ) <NEWLINE> s2 = [ 0 ] * n <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> if i and s [ idx [ i - 1 ] ] != s [ idx [ i ] ] : <NEWLINE> now += 1 <NEWLINE> s2 [ idx [ i ] ] = now <NEWLINE> return _sa_is ( s2 , now ) <NEWLINE> else : <NEWLINE> assert 0 <= upper <NEWLINE> for d in s : <NEWLINE> assert 0 <= d <= upper <NEWLINE> <NL> return _sa_is ( s , upper ) <NEWLINE> <NL> <NL> <DEDENT> def lcp_array ( s : typing . Union [ str , typing . List [ int ] ] , <NEWLINE> <INDENT> sa : typing . List [ int ] ) -> typing . List [ int ] : <NEWLINE> <STRING> <NEWLINE> <NL> if isinstance ( s , str ) : <NEWLINE> s = [ ord ( c ) for c in s ] <NEWLINE> <NL> n = len ( s ) <NEWLINE> assert n >= 1 <NEWLINE> <NL> rnk = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> rnk [ sa [ i ] ] = i <NEWLINE> <NL> lcp = [ 0 ] * ( n - 1 ) <NEWLINE> h = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> if h > 0 : <NEWLINE> h -= 1 <NEWLINE> if rnk [ i ] == 0 : <NEWLINE> continue <NEWLINE> j = sa [ rnk [ i ] - 1 ] <NEWLINE> while j + h < n and i + h < n : <NEWLINE> if s [ j + h ] != s [ i + h ] : <NEWLINE> <INDENT> break <NEWLINE> h += 1 <NEWLINE> lcp [ rnk [ i ] - 1 ] = h <NEWLINE> <NL> return lcp <NEWLINE> <NL> <DEDENT> <DEDENT> s = input ( ) <NEWLINE> sa = suffix_array ( s ) <NEWLINE> <NL> answer = len ( s ) * ( len ( s ) + 1 ) // 2 <NEWLINE> for x in lcp_array ( s , sa ) : <NEWLINE> <INDENT> answer -= x <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> B = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> C = [ [ abs ( A [ i ] [ j ] - B [ i ] [ j ] ) for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> <NL> X = ( H + W ) * 80 <NEWLINE> L = X + X + 1 <NEWLINE> dp = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> dp [ 0 ] [ 0 ] |= 1 << ( X - C [ 0 ] [ 0 ] ) <NEWLINE> dp [ 0 ] [ 0 ] |= 1 << ( X + C [ 0 ] [ 0 ] ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= dp [ i - 1 ] [ j ] << C [ i ] [ j ] <NEWLINE> dp [ i ] [ j ] |= dp [ i - 1 ] [ j ] >> C [ i ] [ j ] <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= dp [ i ] [ j - 1 ] << C [ i ] [ j ] <NEWLINE> dp [ i ] [ j ] |= dp [ i ] [ j - 1 ] >> C [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = L <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> if dp [ - 1 ] [ - 1 ] & 1 << i > 0 : <NEWLINE> <INDENT> ans = min ( ans , abs ( i - X ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def ALDS1_5A ( ) : <NEWLINE> <INDENT> n , A , q = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , int ( input ( ) ) <NEWLINE> allFromA = [ False ] * 2001 <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( 2000 - a , 0 , - 1 ) : <NEWLINE> <INDENT> if allFromA [ i ] : <NEWLINE> <INDENT> allFromA [ i + a ] = True <NEWLINE> <DEDENT> <DEDENT> allFromA [ a ] = True <NEWLINE> <NL> <DEDENT> for m in input ( ) . split ( ) : <NEWLINE> <INDENT> if allFromA [ int ( m ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ALDS1_5A ( ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if R == 1 and G == 1 : <NEWLINE> <INDENT> for b in range ( N // B + 1 ) : <NEWLINE> <INDENT> ans += N - b * B + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> bB = N - r * R - g * G <NEWLINE> if bB >= 0 and bB % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ k - q ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> b [ ai - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if b [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def i1str ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <NL> <DEDENT> def istrs ( n = None ) : <NEWLINE> <INDENT> if n is None : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( istrs ( ) ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def i1num ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def inums ( n = None ) : <NEWLINE> <INDENT> if n is None : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( inums ( ) ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def ostrs ( l , sp = <STRING> ) : <NEWLINE> <INDENT> print ( sp . join ( l ) ) <NEWLINE> <NL> <NL> <DEDENT> def onums ( l , sp = <STRING> ) : <NEWLINE> <INDENT> print ( sp . join ( map ( str , l ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( n , aii ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ai , i = aii [ x - 1 ] <NEWLINE> dp [ x ] [ 0 ] = dp [ x - 1 ] [ 0 ] + ai * ( i - x + 1 ) <NEWLINE> dp [ 0 ] [ x ] = dp [ 0 ] [ x - 1 ] + ai * ( n - x - i ) <NEWLINE> <NL> <DEDENT> for s in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , s ) : <NEWLINE> <INDENT> y = s - x <NEWLINE> ai , i = aii [ s - 1 ] <NEWLINE> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + ai * ( i - x + 1 ) , <NEWLINE> <INDENT> dp [ x ] [ y - 1 ] + ai * ( n - y - i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for x in range ( n + 1 ) : <NEWLINE> <INDENT> if dp [ x ] [ n - x ] > res : <NEWLINE> <INDENT> res = dp [ x ] [ n - x ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = i1num ( ) <NEWLINE> a = inums ( ) <NEWLINE> aii = sorted ( [ ( a [ i ] , i ) for i in range ( n ) ] , reverse = True ) <NEWLINE> print ( solve ( n , aii ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> dataset = sys . stdin . readlines ( ) <NEWLINE> <NL> for item in dataset : <NEWLINE> <INDENT> a , b , c , d , e , f = list ( map ( int , item . split ( ) ) ) <NEWLINE> <NL> y = ( c * d - f * a ) / ( b * d - e * a ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> nana = 7 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 7 % K <NEWLINE> while True : <NEWLINE> <INDENT> i = nana % K <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> elif c >= 10 ** 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nana = ( 10 * i + n ) % K <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> l = list ( itertools . combinations_with_replacement ( range ( k + 1 ) [ 1 : ] , 3 ) ) <NEWLINE> s = 0 <NEWLINE> n = 0 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> x = len ( set ( i ) ) <NEWLINE> if x == 3 : <NEWLINE> <INDENT> n = 6 <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> n = 3 <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> n = 1 <NEWLINE> <NL> <DEDENT> s += gcd_list ( list ( i ) ) * n <NEWLINE> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = sum ( B ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> <INDENT> ans += C [ A [ i ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Nums = [ ] <NEWLINE> now = 1 <COMMENT> <NEWLINE> cnt = 0 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == str ( now ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Nums . append ( cnt ) <NEWLINE> now = 1 - now <COMMENT> <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt != 0 : <NEWLINE> <INDENT> Nums . append ( cnt ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( Nums ) % 2 == 0 : <NEWLINE> <INDENT> Nums . append ( 0 ) <NEWLINE> <NL> <DEDENT> Add = 2 * K + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> sum = [ 0 ] * ( len ( Nums ) + 1 ) <NEWLINE> for i in range ( len ( Nums ) ) : <NEWLINE> <INDENT> sum [ i + 1 ] = sum [ i ] + Nums [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 0 , len ( Nums ) , 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> left = i <NEWLINE> right = min ( i + Add , len ( Nums ) ) <NEWLINE> tmp = sum [ right ] - sum [ left ] <NEWLINE> ans = max ( tmp , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( A ) <NEWLINE> p = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for k , v in c . items ( ) : <NEWLINE> <INDENT> t = k * 2 <NEWLINE> while t <= 10 ** 6 : <NEWLINE> <INDENT> p [ t ] = False <NEWLINE> t += k <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if c [ a ] == 1 and p [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * lis [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> goal = sorted ( S ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] != goal [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( i + i * ( n // i ) ) * ( n // i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <NL> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> elif A + B < K : <NEWLINE> <INDENT> c = - 1 * ( K - ( A + B ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cc = A + c <NEWLINE> print ( cc ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> global x , k , d <NEWLINE> i = min ( k , abs ( x // d ) ) <NEWLINE> if abs ( x - d * i ) < abs ( x + d * i ) : <NEWLINE> <INDENT> x -= d * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += d * i <NEWLINE> <DEDENT> k -= i <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> if abs ( x - d ) < abs ( x + d ) : <NEWLINE> <INDENT> print ( abs ( x - d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x + d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , k , d = IL ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> M = 10 ** 6 + 1 <NEWLINE> cnt = [ 0 ] * M <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if cnt [ a ] != 0 : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( M ) [ a : : a ] : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def fib ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = fib ( n ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> amax = max ( a for a , b in ab ) <NEWLINE> dp = [ 0 ] + [ 0 ] * ( h + amax ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( dp [ h ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> start_to_middle = [ ] <NEWLINE> middle_to_end = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> start_to_middle . append ( b ) <NEWLINE> <DEDENT> elif b == N : <NEWLINE> <INDENT> middle_to_end . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if not len ( start_to_middle ) or not len ( middle_to_end ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> middle_to_end . sort ( ) <NEWLINE> for middle in start_to_middle : <NEWLINE> <INDENT> idx = bisect . bisect_left ( middle_to_end , middle ) <NEWLINE> if idx < len ( middle_to_end ) and middle_to_end [ idx ] == middle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> already_town_check = [ False ] * ( N + 1 ) <NEWLINE> already_town_check [ 1 ] = True <NEWLINE> already_town = [ 1 ] <NEWLINE> now_town = 1 <NEWLINE> check = False <NEWLINE> my_append = already_town . append <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> check_town = A [ now_town - 1 ] <NEWLINE> if ( already_town_check [ check_town ] ) : <NEWLINE> <INDENT> cicle_start_value = check_town <NEWLINE> check = True <NEWLINE> break <NEWLINE> <DEDENT> already_town_check [ check_town ] = True <NEWLINE> my_append ( check_town ) <NEWLINE> now_town = check_town <NEWLINE> <NL> <DEDENT> if ( check == False ) : <NEWLINE> <INDENT> print ( now_town ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cicle_start = already_town . index ( cicle_start_value ) <NEWLINE> roop_town = already_town [ cicle_start : ] <NEWLINE> print ( roop_town [ ( K - cicle_start ) % ( ( i + 1 ) - cicle_start ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> if N % A == 0 : <NEWLINE> <INDENT> count += ( N // A ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += ( N // A ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def maiin ( S ) : <NEWLINE> <INDENT> N = int ( S [ - 1 ] ) <NEWLINE> <NL> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> maiin ( input ( ) ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ 0 ] * ( 26 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> sub = s [ j ] <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sub -= c [ k ] * ( i - data [ k ] ) <NEWLINE> <DEDENT> L . append ( sub ) <NEWLINE> <DEDENT> out = L . index ( max ( L ) ) <NEWLINE> print ( out + 1 ) <NEWLINE> data [ out ] = i <NEWLINE> <DEDENT>
import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> <NL> S = pin ( ) [ : - 1 ] <NEWLINE> Q = int ( pin ( ) ) <NEWLINE> now = 1 <NEWLINE> ans1 = <STRING> <NEWLINE> ans2 = <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> D = pin ( ) . split ( ) <NEWLINE> T = 0 <NEWLINE> F = 0 <NEWLINE> C = <STRING> <NEWLINE> if len ( D ) == 1 : <NEWLINE> <INDENT> T = int ( D [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T = int ( D [ 0 ] ) <NEWLINE> F = int ( D [ 1 ] ) <NEWLINE> C = D [ 2 ] <NEWLINE> <DEDENT> if T == 1 : <NEWLINE> <INDENT> now *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if F == 1 : <NEWLINE> <INDENT> if now == 1 : <NEWLINE> <INDENT> ans1 = C + ans1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 = ans2 + C <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if now == 1 : <NEWLINE> <INDENT> ans2 = ans2 + C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = C + ans1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if now == 1 : <NEWLINE> <INDENT> print ( ans1 + S + ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans2 [ : : - 1 ] + S [ : : - 1 ] + ans1 [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <COMMENT> <NL> uf . union ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = int ( N / j ) <NEWLINE> ans += ( j * Y * ( Y + 1 ) / 2 ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> t = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_sorted_lst = sorted ( x_lst ) <NEWLINE> <NL> median1 = x_sorted_lst [ n // 2 - 1 ] <NEWLINE> median2 = x_sorted_lst [ n // 2 ] <NEWLINE> <NL> if median1 == median2 : <NEWLINE> <INDENT> lst = [ median1 ] * n <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = x_lst [ i ] <NEWLINE> <NL> if x <= median1 : <NEWLINE> <INDENT> lst . append ( median2 ) <NEWLINE> <DEDENT> elif median2 <= x : <NEWLINE> <INDENT> lst . append ( median1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( lst [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 2000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def BFS ( cnt , color , path , u ) : <NEWLINE> <INDENT> color [ u ] = cnt <NEWLINE> for v in path [ u ] : <NEWLINE> <INDENT> if color [ v ] == - 1 : <NEWLINE> <INDENT> BFS ( cnt , color , path , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ A ] . append ( B ) <NEWLINE> path [ B ] . append ( A ) <NEWLINE> <DEDENT> color = [ - 1 ] * ( N + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if color [ i ] == - 1 : <NEWLINE> <INDENT> BFS ( cnt , color , path , i ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( color ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> m = P [ 0 ] <NEWLINE> for p in P : <NEWLINE> <INDENT> if m >= p : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> m = p <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def modComb ( n , r , mod ) : <NEWLINE> <INDENT> nume = 1 <NEWLINE> deno = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> nume = nume * ( n - i ) % mod <NEWLINE> deno = deno * ( i + 1 ) % mod <NEWLINE> <DEDENT> return nume * pow ( deno , mod - 2 , mod ) % mod <NEWLINE> <NL> <DEDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = ( pow ( 2 , n , mod ) - 1 - modComb ( n , a , mod ) <NEWLINE> <INDENT> - modComb ( n , b , mod ) ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * reversed ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> c = b [ i ] * ( - ( - a [ i ] // b [ i ] ) ) - a [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> count += c <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> a [ i - 1 ] += count <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_cont = collections . Counter ( A_list ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( A_cont [ i ] ) <NEWLINE> <DEDENT>
print ( * [ <STRING> ] + [ i for i in range ( 3 , int ( input ( ) ) + 1 ) if i % 3 == 0 or <STRING> in str ( i ) ] ) <NEWLINE>
line1 = input ( ) . split ( ) <NEWLINE> n = int ( line1 [ 0 ] ) <NEWLINE> k = int ( line1 [ 1 ] ) <NEWLINE> a = [ int ( ai ) for ai in input ( ) . split ( ) ] <NEWLINE> <NL> route = [ 0 ] <NEWLINE> use = { 0 } <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> now = a [ route [ j ] ] - 1 <NEWLINE> if now in use : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> route . append ( now ) <NEWLINE> use . add ( now ) <NEWLINE> <NL> <DEDENT> <DEDENT> l_start = route . index ( now ) <NEWLINE> print ( route [ l_start + ( ( k - l_start ) % ( len ( route ) - l_start ) ) ] + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = s . count <NEWLINE> <NL> <COMMENT> <NL> ans = c ( <STRING> ) * c ( <STRING> ) * c ( <STRING> ) <NEWLINE> <NL> for a in range ( n - 2 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( ( n - a + 1 ) // 2 ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s [ a ] != s [ a + j ] and s [ a + j ] != s [ a + 2 * j ] and s [ a + 2 * j ] != s [ a ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def solve ( a , m ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> return solve_ ( a , 0 , m , dict ) <NEWLINE> <NL> <DEDENT> def solve_ ( a , i , m , dict ) : <NEWLINE> <INDENT> res = False <NEWLINE> key = str ( i ) + <STRING> + str ( m ) <NEWLINE> if key in dict : <NEWLINE> <INDENT> res = dict [ key ] <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> res = True <NEWLINE> <DEDENT> elif i >= len ( a ) : <NEWLINE> <INDENT> res = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res1 = solve_ ( a , i + 1 , m , dict ) <NEWLINE> res2 = solve_ ( a , i + 1 , m - a [ i ] , dict ) <NEWLINE> res = res1 or res2 <NEWLINE> <DEDENT> dict [ key ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if solve ( a , m [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , q = I ( ) <NEWLINE> s = v ( ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = I ( ) <NEWLINE> ans . append ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> data = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = eval ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> data . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> Data = iter ( data ) <NEWLINE> for i in Data : <NEWLINE> <INDENT> print ( statistics . pstdev ( i ) ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = N // ( A + B ) <NEWLINE> j = N % ( A + B ) <NEWLINE> if j >= A : <NEWLINE> <INDENT> count = A * ( i + 1 ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = A * i + j <NEWLINE> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( temp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input_ = input ( ) <NEWLINE> n = int ( input_ . split ( <STRING> ) [ 0 ] ) <NEWLINE> k = int ( input_ . split ( <STRING> ) [ 1 ] ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = x - b ** 5 <NEWLINE> if n < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( math . pow ( n , 1 / 5 ) ) <NEWLINE> if a ** 5 == n : <NEWLINE> <INDENT> ans . append ( a ) <NEWLINE> ans . append ( - b ) <NEWLINE> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <NL> <DEDENT> if len ( ans ) != 0 : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n = x + b ** 5 <NEWLINE> a = int ( math . pow ( n , 1 / 5 ) ) <NEWLINE> if a ** 5 == n : <NEWLINE> <INDENT> ans . append ( a ) <NEWLINE> ans . append ( b ) <NEWLINE> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> allList = [ ] <NEWLINE> <NL> for i in range ( - 201 , 301 ) : <NEWLINE> <INDENT> allList . append ( i ) <NEWLINE> <NL> <DEDENT> diff = set ( allList ) ^ set ( p ) <NEWLINE> <NL> <NL> <NL> diff = list ( diff ) <NEWLINE> diff . append ( x ) <NEWLINE> diff = sorted ( diff ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ind = diff . index ( x ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> a = diff [ ind - 1 ] <NEWLINE> b = diff [ ind + 1 ] <NEWLINE> <COMMENT> <NL> <NL> ax = abs ( x - a ) <NEWLINE> bx = abs ( x - b ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if ax == bx : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ax > bx : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> wb = { <STRING> : 1 , <STRING> : 0 } <NEWLINE> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> xyc = [ l . split ( ) for l in read ( ) . splitlines ( ) ] <NEWLINE> xy = [ [ int ( lst [ 0 ] ) % ( 2 * k ) , ( int ( lst [ 1 ] ) + k * wb [ lst [ 2 ] ] ) % ( 2 * k ) ] for lst in xyc ] <NEWLINE> mat = np . zeros ( ( k + 1 , 2 * k + 1 ) , dtype = <STRING> ) <NEWLINE> cand = np . zeros ( ( k + 1 , k + 1 ) , dtype = <STRING> ) <NEWLINE> for e in xy : <NEWLINE> <INDENT> f0 = e [ 0 ] >= k <NEWLINE> f1 = e [ 1 ] >= k <NEWLINE> mat [ e [ 0 ] - f0 * k + 1 , e [ 1 ] + ( - 1 ) ** f1 * f0 * k + 1 ] += 1 <NEWLINE> <DEDENT> mat = np . cumsum ( mat , axis = 0 ) <NEWLINE> mat = np . cumsum ( mat , axis = 1 ) <NEWLINE> cand = mat [ k , 2 * k ] - mat [ k , k : 2 * k + 1 ] + mat [ k , : k + 1 ] - np . reshape ( mat [ : k + 1 , 2 * k ] , ( k + 1 , 1 ) ) + 2 * mat [ : , k : 2 * k + 1 ] - 2 * mat [ : , : k + 1 ] <NEWLINE> print ( max ( np . max ( cand ) , mat [ k , 2 * k ] - np . min ( cand ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = ( int ( s ) for s in stdin . readline ( ) . split ( ) ) <NEWLINE> s = [ { i } for i in range ( n ) ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = ( int ( s ) for s in stdin . readline ( ) . split ( ) ) <NEWLINE> if com : <NEWLINE> <INDENT> if x in s [ x ] and y in s [ x ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = s [ x ] <NEWLINE> b = s [ y ] <NEWLINE> if a is not b : <NEWLINE> <INDENT> a |= b <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] = a <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * h <NEWLINE> t = [ 0 ] * h <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> st = str ( input ( ) ) <NEWLINE> st = list ( st ) <NEWLINE> s [ i ] = st <NEWLINE> tt = [ 0 ] * w <NEWLINE> t [ i ] = tt <NEWLINE> <DEDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> t [ i ] [ 0 ] = t [ i - 1 ] [ 0 ] <NEWLINE> if s [ i - 1 ] [ 0 ] == <STRING> and s [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] [ 0 ] = t [ i - 1 ] [ 0 ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , w ) : <NEWLINE> <INDENT> t [ 0 ] [ i ] = t [ 0 ] [ i - 1 ] <NEWLINE> if s [ 0 ] [ i - 1 ] == <STRING> and s [ 0 ] [ i ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] [ i ] = t [ 0 ] [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , w ) : <NEWLINE> <INDENT> for j in range ( 1 , h ) : <NEWLINE> <INDENT> if s [ j - 1 ] [ i ] == <STRING> and s [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> t1 = t [ j - 1 ] [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t1 = t [ j - 1 ] [ i ] <NEWLINE> <DEDENT> if s [ j ] [ i - 1 ] == <STRING> and s [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> t2 = t [ j ] [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t2 = t [ j ] [ i - 1 ] <NEWLINE> <DEDENT> t [ j ] [ i ] = min ( t1 , t2 ) <NEWLINE> <DEDENT> <DEDENT> print ( t [ h - 1 ] [ w - 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S_len = len ( S ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> for _ in range ( S_len ) : <NEWLINE> <INDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += S [ 1 : ] . count ( <STRING> ) * S [ 1 : ] . count ( <STRING> ) <NEWLINE> for j in range ( int ( len ( S ) / 2 + 1 ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if S [ j + 1 ] != S [ j * 2 + 2 ] and S [ j * 2 + 2 ] != <STRING> and S [ j + 1 ] != <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += S [ 1 : ] . count ( <STRING> ) * S [ 1 : ] . count ( <STRING> ) <NEWLINE> for j in range ( int ( len ( S ) / 2 + 1 ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if S [ j + 1 ] != S [ j * 2 + 2 ] and S [ j * 2 + 2 ] != <STRING> and S [ j + 1 ] != <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += S [ 1 : ] . count ( <STRING> ) * S [ 1 : ] . count ( <STRING> ) <NEWLINE> for j in range ( int ( len ( S ) / 2 + 1 ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if S [ j + 1 ] != S [ j * 2 + 2 ] and S [ j * 2 + 2 ] != <STRING> and S [ j + 1 ] != <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = S [ 1 : ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = set ( range ( A , min ( A + K , B + 1 ) ) ) . union ( set ( range ( B , max ( A - 1 , B - K ) , - 1 ) ) ) <NEWLINE> <NL> print ( * sorted ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if j - i <= 6 : <NEWLINE> <INDENT> li += [ s [ i : j ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> li2 = set ( li ) <NEWLINE> li3 = sorted ( li2 ) <NEWLINE> print ( li3 [ k - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> def check ( i , T ) : <NEWLINE> <INDENT> ns = S [ i : i + len ( T ) ] <NEWLINE> res = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if ns [ i ] != T [ i ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( min ( [ check ( i , T ) for i in range ( len ( S ) - len ( T ) + 1 ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( input ( ) ) <NEWLINE> one = X . count ( <STRING> ) <NEWLINE> L1 = [ 1 ] <NEWLINE> L2 = [ 1 ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> if one - 1 == 0 : <NEWLINE> <INDENT> L1 . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L1 . append ( ( L1 [ - 1 ] * 2 ) % ( one - 1 ) ) <NEWLINE> <DEDENT> L2 . append ( ( L2 [ - 1 ] * 2 ) % ( one + 1 ) ) <NEWLINE> <NL> <DEDENT> x1 = 0 <NEWLINE> x2 = 0 <NEWLINE> power1 = 1 <NEWLINE> power2 = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ N - i - 1 ] == <STRING> : <NEWLINE> <INDENT> if one - 1 != 0 : <NEWLINE> <INDENT> x1 += power1 <NEWLINE> <DEDENT> x2 += power2 <NEWLINE> <DEDENT> power1 *= 2 <NEWLINE> power2 *= 2 <NEWLINE> if one - 1 != 0 : <NEWLINE> <INDENT> power1 %= one - 1 <NEWLINE> <DEDENT> power2 %= one + 1 <NEWLINE> <NL> <DEDENT> def solve ( X , cnt ) : <NEWLINE> <INDENT> if X == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <DEDENT> X %= bin ( X ) . count ( <STRING> ) <NEWLINE> return solve ( X , cnt + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> tmp = ( x2 + L2 [ N - i - 1 ] ) % ( one + 1 ) <NEWLINE> ans = solve ( tmp , 0 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if one - 1 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( x1 - L1 [ N - i - 1 ] ) % ( one - 1 ) <NEWLINE> ans = solve ( tmp , 0 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> T = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> T [ - 1 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = [ 1 for i in range ( n ) ] <NEWLINE> for i in reversed ( range ( n - 1 ) ) : <NEWLINE> <INDENT> b [ i ] = b [ i + 1 ] * 10 % 2019 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> T [ i ] = ( b [ i ] * int ( S [ i ] ) + T [ i + 1 ] ) % 2019 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> C = collections . Counter ( T ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for value , count in C . items ( ) : <NEWLINE> <INDENT> ans += int ( count * ( count - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( a + i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def levenshtein ( X , Y ) : <NEWLINE> <INDENT> f = [ [ 0 for i in range ( len ( Y ) + 1 ) ] for j in range ( len ( X ) + 1 ) ] <NEWLINE> for i in range ( len ( X ) + 1 ) : <NEWLINE> <INDENT> f [ i ] [ 0 ] = i <NEWLINE> <DEDENT> for j in range ( len ( Y ) + 1 ) : <NEWLINE> <INDENT> f [ 0 ] [ j ] = j <NEWLINE> <DEDENT> for i in range ( 1 , len ( X ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , len ( Y ) + 1 ) : <NEWLINE> <INDENT> if X [ i - 1 ] == Y [ j - 1 ] : <NEWLINE> <INDENT> f [ i ] [ j ] = min ( f [ i - 1 ] [ j ] + 1 , f [ i ] [ j - 1 ] + 1 , f [ i - 1 ] [ j - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f [ i ] [ j ] = min ( f [ i - 1 ] [ j ] + 1 , f [ i ] [ j - 1 ] + 1 , f [ i - 1 ] [ j - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return f [ len ( X ) ] [ len ( Y ) ] <NEWLINE> <NL> <DEDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> <NL> print ( levenshtein ( X , Y ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = [ ] <NEWLINE> p = np . array ( p ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += ( 1 + p [ i ] ) / 2 <NEWLINE> s . append ( sum ) <NEWLINE> <COMMENT> <NL> <DEDENT> if k == n : <NEWLINE> <INDENT> print ( s [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> max = s [ k - 1 ] - s [ 0 ] <NEWLINE> for j in range ( 1 , n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> if max <= s [ j + k ] - s [ j ] : <NEWLINE> <INDENT> max = s [ j + k ] - s [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for s in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( s , t ) == 1 : <NEWLINE> <INDENT> ans = ans + k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for u in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans = ans + math . gcd ( math . gcd ( s , t ) , u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> list1 = [ ] <NEWLINE> for l in range ( N ) : <NEWLINE> <INDENT> list1 . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> list1 . sort ( ) <NEWLINE> print ( <STRING> . join ( list1 ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def hcf ( l ) : <NEWLINE> <INDENT> return reduce ( math . gcd , l ) <NEWLINE> <DEDENT> gcd = hcf ( A ) <NEWLINE> m = max ( A ) <NEWLINE> if k % gcd == 0 and k <= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> participants = sorted ( [ int ( v ) for v in input ( ) . split ( <STRING> ) ] , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sum = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> sum += participants [ 2 * i + 1 ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for j in range ( N ) ] <NEWLINE> q = deque ( [ ] ) <NEWLINE> depth_array = [ - 1 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def bfs ( graph , q , depth_array ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> return depth_array <NEWLINE> <NL> <DEDENT> cur_room = q . popleft ( ) <NEWLINE> <NL> <COMMENT> <NL> for r in graph [ cur_room ] : <NEWLINE> <INDENT> if depth_array [ r ] == - 1 : <COMMENT> <NEWLINE> <INDENT> q . append ( r ) <NEWLINE> depth_array [ r ] = depth_array [ cur_room ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return bfs ( graph , q , depth_array ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> q . append ( 0 ) <NEWLINE> depth_array [ 0 ] = 0 <NEWLINE> depth_array = bfs ( graph , q , depth_array ) <NEWLINE> <NL> mark_array = [ - 1 for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> <NL> for room , depth in enumerate ( depth_array ) : <NEWLINE> <INDENT> for node in graph [ room ] : <NEWLINE> <INDENT> if depth_array [ node ] + 1 == depth_array [ room ] : <NEWLINE> <INDENT> mark_array [ room ] = node <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in mark_array [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for m in mark_array [ 1 : ] : <NEWLINE> <INDENT> print ( m + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> dp = np . zeros ( s + 1 , dtype = int ) <COMMENT> <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ddp = dp * 2 % MOD <NEWLINE> ddp [ a [ i ] : ] += dp [ : - a [ i ] ] <COMMENT> <NEWLINE> dp = ddp % MOD <NEWLINE> <NL> <NL> <DEDENT> print ( dp [ s ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX_EXP = 30 <COMMENT> <NEWLINE> pow2 = [ 1 ] * ( MAX_EXP + 1 ) <NEWLINE> for e in range ( 1 , MAX_EXP + 1 ) : <NEWLINE> <INDENT> pow2 [ e ] = 2 * pow2 [ e - 1 ] <NEWLINE> <DEDENT> counter = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> counter [ a ] += 1 <NEWLINE> <DEDENT> DISTINCT_A = list ( counter . keys ( ) ) <NEWLINE> DISTINCT_A . sort ( reverse = True ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for a in DISTINCT_A : <NEWLINE> <INDENT> b = pow2 [ a . bit_length ( ) ] - a <NEWLINE> if counter [ b ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = min ( counter [ a ] , counter [ b ] ) <NEWLINE> ans += cnt <NEWLINE> counter [ a ] -= cnt <NEWLINE> counter [ b ] -= cnt <NEWLINE> <COMMENT> <NL> <DEDENT> for e in range ( MAX_EXP + 1 ) : <NEWLINE> <INDENT> a = pow2 [ e ] <NEWLINE> ans += counter [ a ] // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( ( l , r ) ) <NEWLINE> <NL> <DEDENT> L . sort ( ) <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for l , r in L : <NEWLINE> <INDENT> if l >= i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif l < i and i - r > 1 : <NEWLINE> <INDENT> count += dp [ i - l ] - dp [ i - r - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += dp [ i - l ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + count ) % mod <NEWLINE> <NL> <DEDENT> print ( ( dp [ N ] - dp [ N - 1 ] ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> _A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1000 <NEWLINE> A = [ _A [ 0 ] ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ( _A [ i ] != _A [ i + 1 ] ) : <NEWLINE> <INDENT> A . append ( _A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> if ( len ( A ) < 2 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if ( flag == 0 and A [ i ] < A [ i + 1 ] ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> B . append ( A [ i ] ) <NEWLINE> <DEDENT> elif ( flag == 1 and A [ i ] > A [ i + 1 ] ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> B . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if ( ( A [ - 1 ] > A [ - 2 ] and flag == 1 ) or ( A [ - 1 ] < A [ - 2 ] and flag == 0 ) ) : <NEWLINE> <INDENT> B . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> if ( len ( B ) < 2 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( B [ - 1 ] < B [ - 2 ] ) : <NEWLINE> <INDENT> B . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> stock = 0 <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> stock = ans // b <NEWLINE> ans = ans % b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + stock * b <NEWLINE> stock = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
INF = float ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> L = A [ left : mid ] + [ INF ] <NEWLINE> R = A [ mid : right ] + [ INF ] <NEWLINE> i = j = 0 <NEWLINE> limit = mid - left <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> if i >= limit : <NEWLINE> <INDENT> A [ k + 1 : right ] = R [ j : - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += limit - i <NEWLINE> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( S , 0 , n ) <NEWLINE> print ( cnt ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ex = [ 0 ] <NEWLINE> for x in p : <NEWLINE> <INDENT> ex . append ( ex [ - 1 ] + ( x + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , ex [ i ] - ex [ i - k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 1 <NEWLINE> if ( 0 in li ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in li : <NEWLINE> <INDENT> n = n * i <NEWLINE> if ( n > 1000000000000000000 ) : <NEWLINE> <INDENT> n = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
a , b , c , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( ( a - b ) * ( ( - 1 ) ** K ) ) <NEWLINE>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X >= B - A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , 101 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 7 <NEWLINE> n_before = 7 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> count += 1 <NEWLINE> n = n % K <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_before = 10 * n_before % K <NEWLINE> n = n + n_before <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> top = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - 1 ) * ( - top // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> num = len ( s ) <NEWLINE> a = [ 0 ] * ( num + 1 ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = max ( a [ i + 1 ] , a [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if s [ - i ] == <STRING> : <NEWLINE> <INDENT> a [ - ( i + 1 ) ] = max ( a [ - ( i + 1 ) ] , a [ - i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> ls = [ 2 , 2 , 2 , 3 , 3 , 5 ] <NEWLINE> a = [ ] <NEWLINE> for l in ls : <NEWLINE> <INDENT> if X % l == 0 : <NEWLINE> <INDENT> a . append ( l ) <NEWLINE> X /= l <NEWLINE> <DEDENT> <DEDENT> num = 1 <NEWLINE> if len ( a ) != 0 : <NEWLINE> <INDENT> for b in a : <NEWLINE> <INDENT> num *= b <NEWLINE> <DEDENT> <DEDENT> print ( int ( 360 / num ) ) <NEWLINE>
import sys <NEWLINE> def lcs ( X , Y ) : <NEWLINE> <INDENT> indices = [ 0 ] <NEWLINE> for c in Y : <NEWLINE> <INDENT> for i in range ( len ( indices ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = X . find ( c , indices [ i ] ) <NEWLINE> if tmp + 1 : <NEWLINE> <INDENT> if i + 1 < len ( indices ) : <NEWLINE> <INDENT> indices [ i + 1 ] = min ( indices [ i + 1 ] , tmp + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> indices . append ( tmp + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( indices ) - 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> X = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> Y = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> print ( lcs ( X , Y ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> import random <NEWLINE> from collections import Counter <NEWLINE> <NL> res = 1 <NEWLINE> val = Counter ( s ) . values ( ) <NEWLINE> if len ( val ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in val : <NEWLINE> <INDENT> res *= i <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i + 2 * j < n : <NEWLINE> <INDENT> if ( s [ i ] != s [ i + j ] ) and ( s [ i + j ] != s [ i + 2 * j ] ) and ( s [ i ] != s [ i + 2 * j ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res - count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from sys import exit <NEWLINE> from collections import Iterable <NEWLINE> from unittest import TestCase <NEWLINE> <NL> <COMMENT> <NL> <NL> def top_face_after_rolling_dice ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> faces = [ int ( num ) for num in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> rollings = input ( ) . rstrip ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return __input_error ( ) <NEWLINE> <NL> <DEDENT> dice = CubicArbitraryValueDice ( faces [ 0 ] , faces [ 1 ] , faces [ 2 ] , faces [ 3 ] , faces [ 4 ] , faces [ 5 ] ) <NEWLINE> dice . put ( dice . TOP , dice . SOUTH , dice . EAST , dice . WEST , dice . NORTH , dice . BOTTOM ) <NEWLINE> <NL> for operator in rollings : <NEWLINE> <INDENT> dice . roll ( operator ) <NEWLINE> <NL> <DEDENT> print ( dice . get_value ( dice . TOP ) ) <NEWLINE> <NL> <DEDENT> class CubicArbitraryValueDice ( ) : <NEWLINE> <INDENT> ( TOP , BOTTOM , EAST , WEST , SOUTH , NORTH , RIGHT , LEFT ) = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> ( stVALUE , stDIRECTION ) = ( <STRING> , <STRING> ) <NEWLINE> <NL> ( plus_x , minus_x , plus_y , minus_y , plus_z , minus_z ) = ( ( 1 , 0 , 0 ) , ( - 1 , 0 , 0 ) , ( 0 , 1 , 0 ) , ( 0 , - 1 , 0 ) , ( 0 , 0 , 1 ) , ( 0 , 0 , - 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ROLL_x2y = ( ( 0 , - 1 , 0 ) , ( 1 , 0 , 0 ) , ( 0 , 0 , 1 ) ) <NEWLINE> ROLL_y2x = ( ( 0 , 1 , 0 ) , ( - 1 , 0 , 0 ) , ( 0 , 0 , 1 ) ) <NEWLINE> ROLL_y2z = ( ( 1 , 0 , 0 ) , ( 0 , 0 , - 1 ) , ( 0 , 1 , 0 ) ) <NEWLINE> ROLL_z2y = ( ( 1 , 0 , 0 ) , ( 0 , 0 , 1 ) , ( 0 , - 1 , 0 ) ) <NEWLINE> ROLL_z2x = ( ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( - 1 , 0 , 0 ) ) <NEWLINE> ROLL_x2z = ( ( 0 , 0 , - 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) ) <NEWLINE> <NL> DIRECTION = { EAST : plus_x , WEST : minus_x , NORTH : plus_y , SOUTH : minus_y , TOP : plus_z , BOTTOM : minus_z } <NEWLINE> OPERATOR = { EAST : ROLL_z2x , WEST : ROLL_x2z , NORTH : ROLL_z2y , SOUTH : ROLL_y2z , RIGHT : ROLL_y2x , LEFT : ROLL_x2y } <NEWLINE> <NL> <COMMENT> <NL> def __init__ ( self , n_f0 , n_f1 , n_f2 , n_f3 , n_f4 , n_f5 ) : <NEWLINE> <INDENT> self . info = [ { self . stVALUE : n_fi } for n_fi in [ n_f0 , n_f1 , n_f2 , n_f3 , n_f4 , n_f5 ] ] <NEWLINE> <NL> <DEDENT> def put ( self , dir_f0 , dir_f1 , dir_f2 , dir_f3 , dir_f4 , dir_f5 ) : <COMMENT> <NEWLINE> <INDENT> for ( info , dir_fi ) in zip ( self . info , [ dir_f0 , dir_f1 , dir_f2 , dir_f3 , dir_f4 , dir_f5 ] ) : <NEWLINE> <INDENT> info [ self . stDIRECTION ] = self . DIRECTION [ dir_fi ] <NEWLINE> <NL> <DEDENT> <DEDENT> def roll ( self , operator ) : <COMMENT> <NEWLINE> <INDENT> for info in self . info : <NEWLINE> <COMMENT> <NL> <INDENT> vector = info [ self . stDIRECTION ] <NEWLINE> matrix = self . OPERATOR [ operator ] <NEWLINE> info [ self . stDIRECTION ] = tuple ( [ sum ( [ matrix [ row ] [ col ] * vector [ col ] for col in range ( len ( vector ) ) ] ) for row in range ( len ( matrix ) ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_value ( self , direction ) : <NEWLINE> <INDENT> for info in self . info : <NEWLINE> <INDENT> if info [ self . stDIRECTION ] == self . DIRECTION [ direction ] : <NEWLINE> <INDENT> return info [ self . stVALUE ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get_direction ( self , value ) : <NEWLINE> <INDENT> for info in self . info : <NEWLINE> <INDENT> if info [ self . stVALUE ] == value : <NEWLINE> <INDENT> dir_key_values = self . DIRECTION . items ( ) <NEWLINE> for items in dir_key_values : <NEWLINE> <INDENT> if info [ self . stDIRECTION ] in items : <NEWLINE> <INDENT> return items [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def __input_error ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <NL> <DEDENT> class __TestValueClass ( TestCase ) : <NEWLINE> <INDENT> def testEqual ( self , func , tuples , eff_digit = None , print_success = False ) : <NEWLINE> <INDENT> self . testFunction ( self . assertEqual , func , tuples , eff_digit , print_success ) <NEWLINE> <NL> <DEDENT> def testFunction ( self , assertfunc , func , tuples , eff_digit , print_success ) : <NEWLINE> <COMMENT> <NL> <INDENT> for item in tuples : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if isinstance ( item [ 0 ] , Iterable ) : <NEWLINE> <INDENT> value = func ( * item [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = func ( item [ 0 ] ) <NEWLINE> <NL> <DEDENT> if eff_digit is None : <NEWLINE> <INDENT> assertfunc ( value , item [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> format_str = <STRING> + str ( eff_digit ) + <STRING> <NEWLINE> assertfunc ( format_str . format ( value ) , format_str . format ( item [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> except Exception as msg : <NEWLINE> <INDENT> swidth = 15 <NEWLINE> print ( <STRING> * 50 ) <NEWLINE> print ( <STRING> + func . __name__ + <STRING> ) <NEWLINE> info = [ ] <NEWLINE> info . append ( [ <STRING> , item [ 0 ] ] ) <NEWLINE> info . append ( [ <STRING> , item [ 1 ] ] ) <NEWLINE> info . append ( [ <STRING> , <STRING> + msg ] ) <NEWLINE> for info_state in info : <NEWLINE> <INDENT> print ( info_state [ 0 ] . ljust ( swidth ) + <STRING> , info_state [ 1 ] ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if print_success : <NEWLINE> <INDENT> print ( func . __name__ , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> top_face_after_rolling_dice ( ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( float ( B ) * 100 + .5 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> primes = prime_factorize ( N ) <NEWLINE> <NL> num = 0 <NEWLINE> hist = [ 1 ] <NEWLINE> c = 1 <NEWLINE> <NL> tmp = 1 <NEWLINE> for p in primes : <NEWLINE> <COMMENT> <NL> <INDENT> if tmp != p : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> tmp = p <NEWLINE> c *= p <NEWLINE> if c not in hist : <NEWLINE> <INDENT> hist . append ( c ) <NEWLINE> num += 1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def ans120 ( A : int , B : int , K : int ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> n = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = B <NEWLINE> <DEDENT> ans_list = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> ans_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans_list [ - K ] <NEWLINE> <NL> <DEDENT> print ( ans120 ( A , B , K ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> all_count = r * g * b <NEWLINE> <NL> reduce = 0 <NEWLINE> for i in range ( 1 , n - 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( n + i ) // 2 + 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > n : continue <NEWLINE> if s [ i - 1 ] != s [ j - 1 ] and s [ i - 1 ] != s [ k - 1 ] and s [ j - 1 ] != s [ k - 1 ] : <NEWLINE> <INDENT> reduce += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( all_count - reduce ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> a = ord ( <STRING> ) <NEWLINE> alf = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> alf . append ( chr ( a ) ) <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> SN = [ [ ] for i in range ( 26 ) ] <NEWLINE> TN = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> if alf [ j ] == S [ i ] : <NEWLINE> <INDENT> SN [ j ] . append ( i ) <NEWLINE> <DEDENT> if alf [ j ] == T [ i ] : <NEWLINE> <INDENT> TN [ j ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> SN . sort ( ) <NEWLINE> TN . sort ( ) <NEWLINE> print ( <STRING> if SN == TN else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( H [ 1 ] - H [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 2 ] + abs ( H [ i ] - H [ i - 2 ] ) , dp [ i - 1 ] + abs ( H [ i ] - H [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
INF = 999999999999 <NEWLINE> <NL> def BellmanFord_edge ( s , v , edge ) : <NEWLINE> <INDENT> dp = [ INF ] * v <NEWLINE> dp [ s ] = 0 <NEWLINE> for i in range ( 0 , v ) : <NEWLINE> <INDENT> dp1 = dp [ : ] <NEWLINE> for fr , to , d in edge : <NEWLINE> <INDENT> if dp [ fr ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dp [ to ] > dp [ fr ] + d : <NEWLINE> <INDENT> dp [ to ] = dp [ fr ] + d <NEWLINE> if i == v - 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp == dp1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> def BellmanFord_graph ( s , v , graph ) : <NEWLINE> <INDENT> dp = [ INF ] * v <NEWLINE> dp [ s ] = 0 <NEWLINE> for i in range ( 0 , v ) : <NEWLINE> <INDENT> for k in range ( 0 , v ) : <NEWLINE> <INDENT> dp1 = [ dp [ k ] + graph [ k ] [ j ] if dp [ k ] != INF and graph [ k ] [ j ] != INF and dp [ j ] > dp [ k ] + graph [ k ] [ j ] <NEWLINE> <INDENT> else dp [ j ] <NEWLINE> for j in range ( 0 , v ) ] <NEWLINE> <DEDENT> if dp1 != dp and i == v - 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> dp = dp1 <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> dp = [ ] <NEWLINE> line = input ( ) <NEWLINE> v , e = list ( map ( int , line . split ( ) ) ) <NEWLINE> graph = [ [ INF ] * v for _ in range ( 0 , v ) ] <NEWLINE> edge = [ ] <NEWLINE> for _ in range ( 0 , e ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s , t , d = list ( map ( int , line . split ( ) ) ) <NEWLINE> edge += [ [ s , t , d ] ] <NEWLINE> graph [ s ] [ t ] = d <NEWLINE> <DEDENT> for s in range ( 0 , v ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp = BellmanFord_edge ( s , v , edge ) <NEWLINE> if dp == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , [ dp [ t ] if dp [ t ] != INF else <STRING> for t in range ( 0 , v ) ] ) ) ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = 1 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> x = 7 % K <NEWLINE> ans = - 1 <NEWLINE> <NL> for n in range ( 1 , K + 10 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <NL> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import copy <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> grid [ i ] = list ( input ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for sy in range ( H ) : <NEWLINE> <INDENT> for sx in range ( W ) : <NEWLINE> <INDENT> if grid [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> now_grid = copy . deepcopy ( grid ) <NEWLINE> time_grid = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( [ sy , sx , 0 ] ) <NEWLINE> now_grid [ sy ] [ sx ] = <STRING> <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , t = queue . popleft ( ) <NEWLINE> for next_y , next_x in [ [ y + 1 , x ] , [ y , x + 1 ] , [ y - 1 , x ] , [ y , x - 1 ] ] : <NEWLINE> <INDENT> if 0 <= next_y < H and 0 <= next_x < W and now_grid [ next_y ] [ next_x ] != <STRING> : <NEWLINE> <INDENT> queue . append ( [ next_y , next_x , t + 1 ] ) <NEWLINE> time_grid [ next_y ] [ next_x ] = t + 1 <NEWLINE> now_grid [ next_y ] [ next_x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Max = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> Max = max ( Max , time_grid [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , Max ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> cur = 1 <NEWLINE> ans = 0 <NEWLINE> pushed = [ False ] * ( N + 1 ) <NEWLINE> pushed [ 1 ] = True <NEWLINE> ok = True <NEWLINE> while True : <NEWLINE> <INDENT> pushed [ cur ] = True <NEWLINE> ans += 1 <NEWLINE> cur = A [ cur ] <NEWLINE> if cur == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if pushed [ cur ] : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for diff in range ( n ) : <NEWLINE> <INDENT> j = i + diff <NEWLINE> k = i + diff * 2 <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> if s [ i ] != s [ k ] : <NEWLINE> <INDENT> if s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> A1 = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> A1 *= i <NEWLINE> if A1 > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] < x : <NEWLINE> <INDENT> cost += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cost , m - cost ) ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> A2 = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> A3 = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> <NL> c2 = Counter ( A2 ) <NEWLINE> c3 = Counter ( A3 ) <NEWLINE> <NL> retval = 0 <NEWLINE> for key in c2 + c3 : <NEWLINE> <INDENT> retval += c2 [ key ] * c3 [ key ] <NEWLINE> <NL> <DEDENT> print ( retval ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if 0 <= ( abs ( B - A ) / ( V - W ) ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = - A [ i ] <NEWLINE> <DEDENT> heapq . heapify ( A ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> trgt = - heapq . heappop ( A ) // 2 <NEWLINE> heapq . heappush ( A , - trgt ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
<COMMENT> <NL> import random <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> adjl = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> NIL = - 1 <NEWLINE> appear = { } <NEWLINE> isalone = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if appear . get ( ( a , b ) , False ) or appear . get ( ( a , b ) , False ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> appear [ ( a , b ) ] = True <NEWLINE> appear [ ( b , a ) ] = True <NEWLINE> isalone [ a ] = False <NEWLINE> isalone [ b ] = False <NEWLINE> adjl [ a ] . append ( b ) <NEWLINE> adjl [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> color = [ NIL for i in range ( n + 1 ) ] <NEWLINE> color_id = 0 <NEWLINE> <NL> <NL> def dfs ( u , color_id ) : <NEWLINE> <INDENT> global color <NEWLINE> color [ u ] = color_id <NEWLINE> for v in adjl [ u ] : <NEWLINE> <INDENT> if color [ v ] == NIL : <COMMENT> <NEWLINE> <INDENT> color [ v ] = color_id <NEWLINE> dfs ( v , color_id ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for u in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if color [ u ] == NIL : <NEWLINE> <INDENT> color_id += 1 <NEWLINE> dfs ( u , color_id ) <NEWLINE> <NL> <DEDENT> <DEDENT> group = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if isalone . get ( i , True ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> group [ color [ i ] ] = group . get ( color [ i ] , 0 ) + 1 <NEWLINE> <NL> <DEDENT> mx = 1 <NEWLINE> for k , v in group . items ( ) : <NEWLINE> <INDENT> mx = max ( mx , v ) <NEWLINE> <NL> <DEDENT> print ( mx ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> d = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> nxm = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * q ] <NEWLINE> for n , x , m in nxm : <NEWLINE> <INDENT> d2 = np . sum ( ( d [ : ( n - 2 ) % k + 1 ] - 1 ) % m + 1 ) <NEWLINE> d3 = np . sum ( ( d [ ( n - 2 ) % k + 1 : ] - 1 ) % m + 1 ) <NEWLINE> print ( n - 1 - ( x % m + ( d2 + d3 ) * ( ( n - 2 ) // k ) + d2 ) // m ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> D = [ ] <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> D . append ( [ L , R ] ) <NEWLINE> <NL> <DEDENT> dp [ 0 ] = 1 <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a += dp [ i ] <NEWLINE> a %= mod <NEWLINE> for d in D : <NEWLINE> <INDENT> if i + d [ 0 ] > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i + d [ 0 ] ] += a <NEWLINE> dp [ i + d [ 0 ] ] %= mod <NEWLINE> if i + d [ 1 ] + 1 > N : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp [ i + d [ 1 ] + 1 ] -= a <NEWLINE> dp [ i + d [ 1 ] + 1 ] %= mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Hs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if Hs [ a - 1 ] <= Hs [ b - 1 ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <DEDENT> if Hs [ b - 1 ] <= Hs [ a - 1 ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if abs ( ( b - a ) ) <= ( v - w ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import log2 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ai = list ( map ( lambda x : log2 ( int ( x ) ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> before = sum ( ai [ 0 : k ] ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> after = before + ai [ i + k ] - ai [ i ] <NEWLINE> <NL> if before < after : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> before = after <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> a , b , c , d , e , f = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> def searints ( m , n , l ) : <COMMENT> <NEWLINE> <INDENT> mask = ( 1 << l + 1 ) - 1 <NEWLINE> s = sum ( [ 1 << n * i for i in range ( 1 , l // n + 1 ) ] ) & mask <NEWLINE> for i in range ( 1 , l // m + 1 ) : <NEWLINE> <INDENT> s = ( s + 1 << m * i | s ) & mask <NEWLINE> <DEDENT> return [ x for x in range ( 0 , l + 1 ) if ( ( s + 1 ) >> x ) & 1 == 1 ] <NEWLINE> <NL> <DEDENT> w = searints ( 100 * a , 100 * b , f ) <NEWLINE> s = searints ( c , d , f ) <NEWLINE> candidates = [ ( 100 * y / ( x + y ) , x + y , y ) for x in w for y in s if e * x >= 100 * y and x * y > 0 and x + y <= f ] <NEWLINE> if candidates : <NEWLINE> <INDENT> print ( * max ( candidates ) [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 * a , 0 ) <NEWLINE> <DEDENT>
k = [ i for i in range ( 1 , 10 ** 5 + 1 ) ] <NEWLINE> v = [ 0 ] * ( 10 ** 5 ) <NEWLINE> dic = { key : val for key , val in zip ( k , v ) } <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dic [ a [ i ] ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = [ sum ( a ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( ans [ - 1 ] + ( c - b ) * dic [ b ] ) <NEWLINE> dic [ c ] += dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> <DEDENT> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if s == 3 * k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif s > 3 * k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif s == k : <NEWLINE> <INDENT> ans = int ( ( k + 1 ) * ( k + 2 ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = k <NEWLINE> <NL> while l >= 0 : <NEWLINE> <INDENT> t_sum = s - l <NEWLINE> m = s - t_sum <NEWLINE> <NL> if t_sum > 2 * k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if m < k : <NEWLINE> <INDENT> m = k <NEWLINE> <NL> <DEDENT> while m >= 0 : <NEWLINE> <INDENT> n = s - l - m <NEWLINE> <NL> if n > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if n >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> m -= 1 <NEWLINE> <DEDENT> l -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> c [ t - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in d : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> a . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( d . values ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if d [ i ] == m : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> y = factorization ( n ) <NEWLINE> def judge ( y ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while np . arange ( i + 2 ) . sum ( ) <= y : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> return i <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> ans += judge ( y [ i ] [ 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = set ( a ) <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt *= i <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cnt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> if B > N : <NEWLINE> <INDENT> c = ( math . floor ( A * N / B ) ) - ( A * ( math . floor ( N / B ) ) ) <NEWLINE> <DEDENT> elif B <= N : <NEWLINE> <INDENT> c = ( math . floor ( A * ( B - 1 ) / B ) ) - ( A * ( math . floor ( ( B - 1 ) / B ) ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> def kake ( a ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in sorted ( a ) : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> <DEDENT> print ( kake ( A ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> start = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> start . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for sh , sw in start : <NEWLINE> <INDENT> maze = [ [ f_inf ] * W for _ in range ( H ) ] <NEWLINE> maze [ sh ] [ sw ] = 0 <NEWLINE> que = deque ( [ [ sh , sw ] ] ) <NEWLINE> while que : <NEWLINE> <INDENT> h , w = que . popleft ( ) <NEWLINE> for dh , dw in [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> next_h , next_w = h + dh , w + dw <NEWLINE> if next_h < 0 or next_h >= H or next_w < 0 or next_w >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S [ next_h ] [ next_w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if maze [ next_h ] [ next_w ] > maze [ h ] [ w ] + 1 : <NEWLINE> <INDENT> maze [ next_h ] [ next_w ] = maze [ h ] [ w ] + 1 <NEWLINE> que . append ( [ next_h , next_w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ma = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> ma = max ( ma , maze [ h ] [ w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = max ( res , ma ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> a = int ( X , 2 ) <NEWLINE> b = X . count ( <STRING> ) <NEWLINE> <NL> if b > 1 : <NEWLINE> <INDENT> a1 = a % ( b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1 = 0 <NEWLINE> <DEDENT> a0 = a % ( b + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> t = ( a1 - pow ( 2 , N - 1 - i , b - 1 ) ) % ( b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( a0 + pow ( 2 , N - 1 - i , b + 1 ) ) % ( b + 1 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> while t > 0 : <NEWLINE> <INDENT> t %= bin ( t ) . count ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> expect = 0 <NEWLINE> a = [ ] <NEWLINE> exsum = 0 <NEWLINE> for i in range ( N ) : <COMMENT> <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> exsum += a [ i ] [ 0 ] * a [ i ] [ 1 ] <COMMENT> <NEWLINE> <DEDENT> b = sorted ( a , key = lambda x : x [ 1 ] ) <COMMENT> <NEWLINE> i = N - 1 <NEWLINE> while M > 0 and i >= 0 : <COMMENT> <NEWLINE> <INDENT> if b [ i ] [ 0 ] <= M : <NEWLINE> <INDENT> exsum -= b [ i ] [ 0 ] * b [ i ] [ 1 ] <NEWLINE> M -= b [ i ] [ 0 ] <NEWLINE> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exsum -= b [ i ] [ 1 ] * M <NEWLINE> M = 0 <NEWLINE> i -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( exsum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> total_triplets = sum ( int ( val == <STRING> ) for val in s ) * sum ( int ( val == <STRING> ) for val in s ) * sum ( int ( val == <STRING> ) for val in s ) <NEWLINE> num_missing = 0 <NEWLINE> for centre_point in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for halfwidth in range ( 1 , 1 + min ( centre_point , n - centre_point - 1 ) ) : <NEWLINE> <INDENT> if s [ centre_point - halfwidth ] != s [ centre_point ] : <NEWLINE> <INDENT> if s [ centre_point ] != s [ centre_point + halfwidth ] : <NEWLINE> <INDENT> if s [ centre_point - halfwidth ] != s [ centre_point + halfwidth ] : num_missing += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total_triplets - num_missing ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = np . zeros ( 10 ** 6 + 1 ) <NEWLINE> for x in a : <NEWLINE> <INDENT> if count [ x ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count [ : : x ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if count [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> arr = [ ] <NEWLINE> R = len ( list ( filter ( lambda x : x == <STRING> , s ) ) ) <NEWLINE> G = len ( list ( filter ( lambda x : x == <STRING> , s ) ) ) <NEWLINE> B = len ( list ( filter ( lambda x : x == <STRING> , s ) ) ) <NEWLINE> tot = R * G * B <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( s [ i ] != s [ j ] ) and ( s [ i ] != s [ k ] ) and ( s [ j ] != s [ k ] ) : <NEWLINE> <INDENT> tot -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BCs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> max_A = max ( A ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A_num = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> A_num [ a ] += 1 <NEWLINE> <NL> <DEDENT> Si = sum ( A ) <NEWLINE> <NL> for BC in BCs : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if A_num [ BC [ 0 ] ] > 0 : <NEWLINE> <INDENT> Si += A_num [ BC [ 0 ] ] * ( BC [ 1 ] - BC [ 0 ] ) <NEWLINE> A_num [ BC [ 1 ] ] += A_num [ BC [ 0 ] ] <NEWLINE> A_num [ BC [ 0 ] ] = 0 <NEWLINE> <NL> <DEDENT> print ( Si ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> A = np . arange ( - 120 , 120 ) <NEWLINE> a = A ** 5 <NEWLINE> for i , a_1 in enumerate ( a ) : <NEWLINE> <INDENT> for j , a_2 in enumerate ( a ) : <NEWLINE> <INDENT> if a_1 - a_2 == x : <NEWLINE> <INDENT> print ( A [ i ] , A [ j ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
def get_input ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield <STRING> . join ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = list ( get_input ( ) ) <NEWLINE> N . sort ( ) <NEWLINE> <NL> N1 , N2 = N [ 0 ] . split ( ) <NEWLINE> word = N1 <NEWLINE> pnum = [ ] <NEWLINE> pnum . append ( int ( N2 ) ) <NEWLINE> <NL> for l in range ( 1 , len ( N ) ) : <NEWLINE> <INDENT> N1 , N2 = N [ l ] . split ( ) <NEWLINE> <NL> if word != N1 : <NEWLINE> <INDENT> print ( word ) <NEWLINE> pnum . sort ( ) <NEWLINE> print ( pnum [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , len ( pnum ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( pnum [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> word = N1 <NEWLINE> pnum . clear ( ) <NEWLINE> pnum . append ( int ( N2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pnum . append ( int ( N2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( word ) <NEWLINE> pnum . sort ( ) <NEWLINE> print ( pnum [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , len ( pnum ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( pnum [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> class RSQ ( object ) : <NEWLINE> <INDENT> INT_MAX = 2 ** 31 - 1 <NEWLINE> <NL> def __init__ ( self , nn , init_val = 0 ) : <NEWLINE> <INDENT> self . val = [ init_val ] * ( nn + 1 ) <NEWLINE> self . n = 1 <NEWLINE> while self . n < nn : <NEWLINE> <INDENT> self . n *= 2 <NEWLINE> <DEDENT> self . dat = [ init_val ] * ( ( 2 * self . n ) - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , k , a ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . val [ k ] = a <NEWLINE> k += ( self . n - 1 ) <NEWLINE> self . dat [ k ] = a <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> k = ( k - 1 ) // 2 <COMMENT> <NEWLINE> self . dat [ k ] = self . dat [ k * 2 + 1 ] + self . dat [ k * 2 + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( self , k , a ) : <NEWLINE> <INDENT> self . val [ k ] += a <NEWLINE> self . update ( k , self . val [ k ] ) <NEWLINE> <NL> <DEDENT> def query ( self , a , b , k , l , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if r <= a or b <= l : <COMMENT> <NEWLINE> <INDENT> return RSQ . INT_MAX <NEWLINE> <DEDENT> if a == l and r == b : <NEWLINE> <INDENT> return self . dat [ k ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if b <= mid : <NEWLINE> <INDENT> return self . query ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) <COMMENT> <NEWLINE> <DEDENT> elif a >= mid : <NEWLINE> <INDENT> return self . query ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = self . query ( a , mid , k * 2 + 1 , l , mid ) <NEWLINE> vr = self . query ( mid , b , k * 2 + 2 , mid , r ) <NEWLINE> return vl + vr <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , s , t ) : <NEWLINE> <INDENT> return self . query ( s , t + 1 , 0 , 0 , self . n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> rq = RSQ ( n + 1 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> rq . add ( x , y ) <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> res = rq . find ( x , y ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> A = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ansBa = [ ] <NEWLINE> ansBc = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> idx = bisect . bisect_left ( A , b ) <NEWLINE> ansBa . append ( idx ) <NEWLINE> <NL> idx2 = bisect . bisect_right ( C , b ) <NEWLINE> ansBc . append ( N - idx2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for aa , cc in zip ( ansBa , ansBc ) : <NEWLINE> <INDENT> ans += aa * cc <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> Hlist = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> flag = [ 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if ( Hlist [ A ] == Hlist [ B ] ) : <NEWLINE> <INDENT> flag [ A ] = 0 <NEWLINE> flag [ B ] = 0 <NEWLINE> <DEDENT> elif ( Hlist [ A ] > Hlist [ B ] ) : <NEWLINE> <INDENT> flag [ B ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ A ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> d = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> d [ ord ( c ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <DEDENT> d2 = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i , c in enumerate ( T ) : <NEWLINE> <INDENT> d2 [ ord ( c ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ set ( ( tuple ( x ) for x in d ) ) == set ( ( tuple ( x ) for x in d2 ) ) ] ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> def expected_val ( limit ) : <NEWLINE> <INDENT> return ( 1 + limit ) / 2 <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> lst = [ 0 ] <NEWLINE> res = 0 <NEWLINE> for p in P : <NEWLINE> <COMMENT> <NL> <INDENT> res += expected_val ( p ) <NEWLINE> lst . append ( res ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> res = lst [ i + K ] - lst [ i ] <NEWLINE> ans = res if res > ans else ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 7 + 10 ** 9 <NEWLINE> ans = 0 <NEWLINE> Asum = sum ( As ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Asum -= As [ i ] <NEWLINE> ans = ( ans + As [ i ] * Asum ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> mem = set ( ) <NEWLINE> base = ord ( <STRING> ) - 1 <NEWLINE> mod1 = 1000000007 <NEWLINE> mod2 = 2147483647 <NEWLINE> h1 = [ 0 ] <NEWLINE> h2 = [ 0 ] <NEWLINE> for c in s : <NEWLINE> <INDENT> h1 . append ( ( h1 [ - 1 ] * 27 + ord ( c ) - base ) % mod1 ) <NEWLINE> h2 . append ( ( h2 [ - 1 ] * 27 + ord ( c ) - base ) % mod2 ) <NEWLINE> <DEDENT> pow_mem1 = { 0 : 1 } <NEWLINE> pow_mem2 = { 0 : 1 } <NEWLINE> def my_pow1 ( x ) : <NEWLINE> <INDENT> if x in pow_mem1 : return pow_mem1 [ x ] <NEWLINE> pow_mem1 [ x ] = my_pow1 ( x - 1 ) * 27 % mod1 <NEWLINE> return pow_mem1 [ x ] <NEWLINE> <NL> <DEDENT> def my_pow2 ( x ) : <NEWLINE> <INDENT> if x in pow_mem2 : return pow_mem2 [ x ] <NEWLINE> pow_mem2 [ x ] = my_pow2 ( x - 1 ) * 27 % mod2 <NEWLINE> return pow_mem2 [ x ] <NEWLINE> <NL> <DEDENT> left = right = 1 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> com = input ( ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> if com == <STRING> : <NEWLINE> <INDENT> left -= 1 <NEWLINE> <DEDENT> if com == <STRING> : <NEWLINE> <INDENT> right += 1 <NEWLINE> <DEDENT> if com == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> x = ( h1 [ right ] - h1 [ left - 1 ] * my_pow1 ( right - left + 1 ) ) % mod1 <NEWLINE> y = ( h2 [ right ] - h2 [ left - 1 ] * my_pow2 ( right - left + 1 ) ) % mod2 <NEWLINE> mem . add ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> print ( len ( mem ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
alphabet = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> } <NEWLINE> N = int ( input ( ) ) <NEWLINE> name = <STRING> <NEWLINE> while N != 0 : <NEWLINE> <INDENT> index = int ( N % 26 ) <NEWLINE> if index == 0 : <NEWLINE> <INDENT> name += alphabet [ 25 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name += alphabet [ index - 1 ] <NEWLINE> <DEDENT> N = int ( ( N - 1 ) / 26 ) <NEWLINE> <DEDENT> print ( name [ : : - 1 ] ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = N // ( A + B ) <NEWLINE> plus = N % ( A + B ) <NEWLINE> print ( A * count + min ( A , plus ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> t = len ( { a , b , c } ) <NEWLINE> if t == 3 : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 6 <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> sum = 0 <NEWLINE> tmp = 0 <NEWLINE> o = 0 <NEWLINE> while ( o < n ) : <NEWLINE> <INDENT> tmp = ( a [ o ] % mod + tmp % mod ) % mod <NEWLINE> o += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = ( tmp % mod - a [ i ] % mod ) % mod <NEWLINE> sum = ( ( a [ i ] % mod ) * tmp ) % mod + sum % mod <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( sum % mod ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> cnt = Counter ( a ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = s - b * cnt [ b ] <NEWLINE> s = s + c * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> p = 1 <NEWLINE> vis = [ 0 ] * n <NEWLINE> while vis [ p - 1 ] == 0 : <NEWLINE> <INDENT> a . append ( p ) <NEWLINE> vis [ p - 1 ] = 1 <NEWLINE> p = m [ p - 1 ] <NEWLINE> <NL> <DEDENT> l = a . index ( p ) <NEWLINE> <NL> if k < len ( a ) : <NEWLINE> <INDENT> print ( a [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> print ( a [ l + k % ( len ( a ) - l ) ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ A [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += ( l [ i ] + <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> cnt = [ 0 ] * 3 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= cnt . count ( A [ i ] ) <NEWLINE> ans %= mod <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt [ cnt . index ( A [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> res = <STRING> <NEWLINE> for i in range ( ( len ( S ) + W - 1 ) // W ) : <NEWLINE> <INDENT> res = <STRING> . join ( ( res , S [ W * i ] ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> number = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> a = number . pop ( - 1 ) <NEWLINE> <NL> if number [ 0 ] == 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> number . pop ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> numbermap = [ [ 0 for i in range ( 21 ) ] for j in range ( N ) ] <NEWLINE> <NL> numbermap [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( 21 ) : <NEWLINE> <INDENT> if j + number [ i ] <= 20 : <NEWLINE> <INDENT> numbermap [ i + 1 ] [ j + number [ i ] ] += numbermap [ i ] [ j ] <NEWLINE> <DEDENT> if j - number [ i ] >= 0 : <NEWLINE> <INDENT> numbermap [ i + 1 ] [ j - number [ i ] ] += numbermap [ i ] [ j ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( numbermap [ - 1 ] [ a ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stack = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stack = money // A [ i ] <NEWLINE> <DEDENT> money += ( A [ i + 1 ] - A [ i ] ) * stack <NEWLINE> stack = 0 <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ j ] != S [ i ] and S [ i ] != S [ k ] and S [ k ] != S [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) - cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> nums [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> d = 1 <NEWLINE> mods = [ 0 ] <NEWLINE> counter = [ 0 ] * 2019 <NEWLINE> counter [ 0 ] += 1 <NEWLINE> result = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> s = int ( s ) <NEWLINE> mods . append ( ( mods [ - 1 ] + s * d ) % 2019 ) <NEWLINE> counter [ mods [ - 1 ] ] += 1 <NEWLINE> result += counter [ mods [ - 1 ] ] - 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> length = int ( sys . stdin . readline ( ) ) <NEWLINE> num_seq = sys . stdin . readline ( ) . split ( ) <NEWLINE> <NL> for i in range ( 1 , length ) : <NEWLINE> <INDENT> print ( num_seq [ length - i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( num_seq [ 0 ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s_len = len ( s ) <NEWLINE> t_len = len ( t ) <NEWLINE> count = 0 <NEWLINE> ans = [ ] <NEWLINE> <NL> <NL> <NL> for i in range ( s_len - t_len + 1 ) : <NEWLINE> <INDENT> for j in range ( t_len ) : <NEWLINE> <INDENT> if s [ i : t_len + i ] [ j ] != t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> min_ans = min ( ans ) <NEWLINE> print ( min_ans ) <NEWLINE> <NL>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> check = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) - 1 <NEWLINE> check [ A ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> if check [ i ] > 0 else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> max_a = 0 <NEWLINE> next_a = 0 <NEWLINE> max_loc = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> if ai > max_a : <NEWLINE> <INDENT> max_a = ai <NEWLINE> max_loc = i <NEWLINE> <DEDENT> elif ai > next_a : <NEWLINE> <INDENT> next_a = ai <NEWLINE> <DEDENT> <DEDENT> if next_a == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( max_a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( max_loc ) : <NEWLINE> <INDENT> print ( max_a ) <NEWLINE> <DEDENT> print ( next_a ) <NEWLINE> for i in range ( n - max_loc - 1 ) : <NEWLINE> <INDENT> print ( max_a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> tmp = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp = tmp * i <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> if tmp > 10 ** 18 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> tmp = - 1 <NEWLINE> print ( tmp ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
X = input ( ) . split ( ) <NEWLINE> X = int ( X [ 0 ] ) <NEWLINE> ans = [ 0 ] * 2 <NEWLINE> <NL> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> x = i ** 5 - j ** 5 <NEWLINE> <NL> if x == X : <NEWLINE> <INDENT> ans = ( i , j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = 0 <NEWLINE> r_min = 10 ** 5 + 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = max ( l_max , l ) <NEWLINE> r_min = min ( r_min , r ) <NEWLINE> <DEDENT> print ( max ( 0 , r_min - l_max + 1 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def qsort ( a ) : <NEWLINE> <INDENT> if not isinstance ( a , list ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if len ( a ) <= 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> p = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ 0 ] != a [ i ] : <NEWLINE> <INDENT> if a [ 0 ] < a [ i ] : <NEWLINE> <INDENT> p = a [ i ] <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> elif i == len ( a ) - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = len ( a ) <NEWLINE> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> if p <= a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( a ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ j ] < p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i >= j : <NEWLINE> <INDENT> a1 = qsort ( a [ : i ] ) <NEWLINE> if i < len ( a ) : <NEWLINE> <INDENT> a2 = qsort ( a [ i : ] ) <NEWLINE> a1 . extend ( a2 ) <NEWLINE> <DEDENT> return a1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> a [ i ] = a [ j ] <NEWLINE> a [ j ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m_list = [ ] <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> m_list . append ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> <DEDENT> s = qsort ( m_list ) <NEWLINE> s . reverse ( ) <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( s [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> length = np . zeros ( 102 ) <NEWLINE> length = list ( length ) <NEWLINE> <NL> for i in range ( len ( length ) ) : <NEWLINE> <INDENT> length [ i ] = abs ( X - i ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> length [ p [ i ] ] = 1000 <NEWLINE> <NL> <DEDENT> ans = length . index ( min ( length ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> C = [ ] <NEWLINE> maxNum = 999999999 <NEWLINE> dmaxNum = 999999999 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> ar = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i & 2 ** j ) != 0 : <NEWLINE> <INDENT> ar = [ x + y for ( x , y ) in zip ( ar , C [ j ] ) ] <NEWLINE> <DEDENT> <DEDENT> if ( np . array ( ar [ 1 : ] ) >= X ) . all ( ) > 0 : <NEWLINE> <INDENT> maxNum = min ( maxNum , ar [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if maxNum == dmaxNum : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxNum ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ : 2 ] == <STRING> or s [ 1 : ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def run_length_compress ( S ) : <NEWLINE> <INDENT> res = [ [ S [ 0 ] , 1 ] ] <NEWLINE> for c in S [ 1 : ] : <NEWLINE> <INDENT> if c == res [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> res [ - 1 ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( [ c , 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> T = run_length_compress ( S ) <NEWLINE> if T [ 0 ] [ 1 ] == N : <NEWLINE> <INDENT> print ( N * K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = sum ( l // 2 for _ , l in T ) * K <NEWLINE> if T [ 0 ] [ 0 ] == T [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> head , tail = T [ 0 ] [ 1 ] , T [ - 1 ] [ 1 ] <NEWLINE> ans += ( ( head + tail ) // 2 - head // 2 - tail // 2 ) * ( K - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
nmq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = nmq [ 0 ] <NEWLINE> M = nmq [ 1 ] <NEWLINE> Q = nmq [ 2 ] <NEWLINE> ablist = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> tp = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ablist . append ( tp ) <NEWLINE> <DEDENT> sumlist = [ ] <NEWLINE> alist = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> import itertools <NEWLINE> case = list ( itertools . combinations_with_replacement ( alist , N ) ) <NEWLINE> for nowcase in case : <NEWLINE> <INDENT> sumd = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if nowcase [ ablist [ i ] [ 1 ] - 1 ] - nowcase [ ablist [ i ] [ 0 ] - 1 ] == ablist [ i ] [ 2 ] : <NEWLINE> <INDENT> sumd += ablist [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> sumlist . append ( sumd ) <NEWLINE> <DEDENT> print ( max ( sumlist ) ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> h , w , k = MAP ( ) <NEWLINE> s = [ ] <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> if s [ i ] . count ( <STRING> ) > 0 : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> num = 0 <NEWLINE> if p : <NEWLINE> <INDENT> for i in p : <NEWLINE> <INDENT> num += 1 <NEWLINE> m = 0 <NEWLINE> while s [ i ] [ m ] == <STRING> : <NEWLINE> <INDENT> a [ i ] [ m ] = num <NEWLINE> m += 1 <NEWLINE> <DEDENT> if m < w : <NEWLINE> <INDENT> if s [ i ] [ m ] == <STRING> : <NEWLINE> <INDENT> a [ i ] [ m ] = num <NEWLINE> m += 1 <NEWLINE> <DEDENT> if m < w : <NEWLINE> <INDENT> for j in range ( m , w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> a [ i ] [ j ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if q : <NEWLINE> <INDENT> for i in q : <NEWLINE> <INDENT> m = i <NEWLINE> while m < h and a [ m ] [ 0 ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> if m >= h : <NEWLINE> <INDENT> m = i <NEWLINE> while m > 0 and a [ m ] [ 0 ] == 0 : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> <DEDENT> a [ i ] [ : ] = a [ m ] [ : ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( * a [ i ] [ : ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = ( l [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> lis = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis [ i + 1 ] = lis [ i ] + l [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> num = lis [ i + k ] - lis [ i ] <NEWLINE> ans = max ( num , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst . append ( 0 ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> lst [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in lst : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] ; A = [ ] ; T = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( s [ 0 ] ) <NEWLINE> A . append ( s [ 1 : ] ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for s in range ( 0 , 1 << N ) : <NEWLINE> <COMMENT> <NL> <INDENT> smart = [ 0 ] * M <NEWLINE> cost_sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( s >> i ) & 1 : <NEWLINE> <INDENT> cost_sum += C [ i ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> smart [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ok = True <NEWLINE> if min ( smart ) < X : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost_sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> s = list ( input ( ) ) <NEWLINE> data = s [ 0 ] <NEWLINE> i = 1 <NEWLINE> while i * 2 < len ( s ) : <NEWLINE> <INDENT> data = data + s [ i * 2 ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> print ( data ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> idx0 = S [ : N - 2 ] . find ( str ( i ) ) <NEWLINE> if idx0 != - 1 : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> idx1 = S [ idx0 + 1 : N - 1 ] . find ( str ( j ) ) <NEWLINE> if idx1 != - 1 : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> idx2 = S [ idx0 + idx1 + 2 : ] . find ( str ( k ) ) <NEWLINE> if idx2 != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , parent = - 1 , left = - 1 , right = - 1 , depth = 0 ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . depth = depth <NEWLINE> <NL> <DEDENT> <DEDENT> def print_node ( i ) : <NEWLINE> <INDENT> global node <NEWLINE> print ( <STRING> + str ( i ) + <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> + str ( node [ i ] . parent ) + <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> + str ( node [ i ] . depth ) + <STRING> , end = <STRING> ) <NEWLINE> if node [ i ] . parent == - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif node [ i ] . left != - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if node [ i ] . left != - 1 : <NEWLINE> <INDENT> print ( str ( node [ i ] . left ) , end = <STRING> ) <NEWLINE> j = node [ i ] . left <NEWLINE> while node [ j ] . right != - 1 : <NEWLINE> <INDENT> j = node [ j ] . right <NEWLINE> print ( <STRING> + str ( j ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> node = [ Node ( ) for i in range ( n ) ] <NEWLINE> def input_depth ( i , n ) : <NEWLINE> <INDENT> global node <NEWLINE> node [ i ] . depth = n <NEWLINE> if node [ i ] . right != - 1 : <NEWLINE> <INDENT> input_depth ( node [ i ] . right , n ) <NEWLINE> <DEDENT> if node [ i ] . left != - 1 : <NEWLINE> <INDENT> input_depth ( node [ i ] . left , n + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p , k , * c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if k > 0 : <NEWLINE> <INDENT> node [ p ] . left = c [ 0 ] <NEWLINE> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> node [ c [ j ] ] . parent = p <NEWLINE> if j != k - 1 : <NEWLINE> <INDENT> node [ c [ j ] ] . right = c [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if node [ i ] . parent == - 1 : <NEWLINE> <INDENT> input_depth ( i , 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print_node ( i ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def ma ( k ) : <NEWLINE> <INDENT> s = a * k / b <NEWLINE> t = k / b <NEWLINE> ss = s // 1 <NEWLINE> tt = ( t // 1 ) * a <NEWLINE> return ss - tt <NEWLINE> <NL> <DEDENT> if ( n < b ) : <NEWLINE> <INDENT> print ( str ( int ( ma ( n ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( int ( ma ( b - 1 ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A_str = input ( ) . strip ( <STRING> ) <NEWLINE> A = A_str . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> C = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in C : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def rep ( b , c ) : <NEWLINE> <INDENT> if c in C : <NEWLINE> <INDENT> C [ c ] += C [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ c ] = C [ b ] <NEWLINE> <DEDENT> C [ b ] = 0 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> Ans = [ ] <NEWLINE> ans = <STRING> <NEWLINE> b , c = input ( ) . strip ( <STRING> ) . split ( ) <NEWLINE> <COMMENT> <NL> tmp = 0 <NEWLINE> hoge = map ( int , A ) <NEWLINE> for a in hoge : <NEWLINE> <INDENT> if str ( a ) == b : <NEWLINE> <INDENT> tmp += int ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += a <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> Ans . append ( tmp ) <NEWLINE> if b in C : <NEWLINE> <INDENT> rep ( b , c ) <NEWLINE> <DEDENT> for i in range ( 1 , q - 1 ) : <NEWLINE> <INDENT> b , c = input ( ) . strip ( <STRING> ) . split ( ) <NEWLINE> if b in C : <NEWLINE> <INDENT> tmp += ( int ( c ) - int ( b ) ) * C [ b ] <NEWLINE> rep ( b , c ) <NEWLINE> <COMMENT> <NL> <DEDENT> Ans . append ( tmp ) <NEWLINE> <DEDENT> b , c = input ( ) . strip ( <STRING> ) . split ( ) <NEWLINE> if b in C : <NEWLINE> <INDENT> tmp += ( int ( c ) - int ( b ) ) * C [ b ] <NEWLINE> <COMMENT> <NL> <DEDENT> Ans . append ( tmp ) <NEWLINE> <COMMENT> <NL> for ans in Ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> def diff ( a , b ) : <NEWLINE> <INDENT> return sum ( aa != bb for aa , bb in zip ( a , b ) ) <NEWLINE> <NL> <DEDENT> answer = min ( diff ( S [ i : i + len ( T ) ] , T ) for i in range ( len ( S ) - len ( T ) + 1 ) ) <NEWLINE> print ( answer ) <NEWLINE>
matrix = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> values = input ( ) <NEWLINE> if <STRING> == values : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> matrix . append ( [ int ( x ) for x in values . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for height , width in matrix : <NEWLINE> <INDENT> for i in range ( height ) : <NEWLINE> <INDENT> print ( <STRING> * width ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_plus_idx = Counter ( [ a [ i ] + i for i in range ( n ) ] ) <NEWLINE> a_minus_idx = Counter ( [ i - a [ i ] for i in range ( n ) ] ) <NEWLINE> <NL> total = 0 <NEWLINE> for k , v in a_plus_idx . items ( ) : <NEWLINE> <INDENT> total += v * a_minus_idx [ k ] <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = np . array ( a ) <NEWLINE> s = a . cumsum ( ) <NEWLINE> ans = abs ( 2 * s - sum ( a ) ) <NEWLINE> <NL> <NL> print ( min ( ans ) ) <NEWLINE>
loopCnt = int ( input ( ) ) <NEWLINE> <NL> strList = [ ] <NEWLINE> for i in range ( loopCnt ) : <NEWLINE> <INDENT> inputStr = input ( ) <NEWLINE> strList . append ( inputStr ) <NEWLINE> <NL> <DEDENT> setList = set ( strList ) <NEWLINE> <NL> print ( str ( len ( setList ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> head_s = [ ] <NEWLINE> back_s = [ ] <NEWLINE> n2 = 1 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> n2 = 0 <NEWLINE> <DEDENT> for h in range ( n - 1 , - 1 , - 2 ) : <NEWLINE> <INDENT> head_s . append ( a [ h ] ) <NEWLINE> <DEDENT> for b in range ( n2 , n , 2 ) : <NEWLINE> <INDENT> back_s . append ( a [ b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans_h = ( <STRING> . join ( map ( str , head_s ) ) ) <NEWLINE> ans_b = ( <STRING> . join ( map ( str , back_s ) ) ) <NEWLINE> print ( ans_h , ans_b ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r * r ) , <NEWLINE> <INDENT> <STRING> . format ( 2 * math . pi * r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum = sum ( As ) <NEWLINE> <NL> ans = 0 <NEWLINE> for index , A in enumerate ( As ) : <NEWLINE> <INDENT> ans += ( A * ( Asum - A ) ) <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> Asum -= A <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors = [ ] <NEWLINE> upper_divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> upper_divisors . reverse ( ) <NEWLINE> return lower_divisors + upper_divisors <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> used_list = [ ] <NEWLINE> <NL> def solve ( n , used_list ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return len ( used_list ) <NEWLINE> <DEDENT> div_list = make_divisors ( n ) [ 1 : ] <NEWLINE> for i in div_list : <NEWLINE> <INDENT> z_kouho = factorization ( i ) <NEWLINE> if i not in used_list and len ( z_kouho ) == 1 : <NEWLINE> <INDENT> used_list . append ( i ) <NEWLINE> return solve ( int ( n / i ) , used_list ) <NEWLINE> <NL> <DEDENT> <DEDENT> return len ( used_list ) <NEWLINE> <NL> <DEDENT> print ( solve ( n , used_list ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> s = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> query = [ ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> temp = input ( ) . split ( ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> query . append ( temp + [ flag % 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for q in query : <NEWLINE> <INDENT> if q [ - 1 ] == 0 : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> : <NEWLINE> <INDENT> s . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> : <NEWLINE> <INDENT> s . append ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( s ) [ : : - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> area = math . pi * ( r ** 2 ) <NEWLINE> circum = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( area , circum ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> s , t = [ ] , [ ] <COMMENT> <NEWLINE> for i in a : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> t . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <DEDENT> <DEDENT> S , T = len ( s ) , len ( t ) <NEWLINE> is_positive = False <COMMENT> <NEWLINE> if S > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if n == k : <NEWLINE> <COMMENT> <NL> <INDENT> is_positive = ( T % 2 == 0 ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_positive = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> is_positive = ( k % 2 == 0 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if not is_positive : <NEWLINE> <INDENT> a . sort ( key = abs ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * a [ i ] % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . sort ( ) <NEWLINE> t . sort ( reverse = True ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans = ans * s . pop ( - 1 ) % MOD <NEWLINE> <DEDENT> p = [ ] <NEWLINE> while ( len ( s ) >= 2 ) : <NEWLINE> <INDENT> x = s . pop ( - 1 ) <NEWLINE> x *= s . pop ( - 1 ) <NEWLINE> p . append ( x ) <NEWLINE> <DEDENT> while ( len ( t ) >= 2 ) : <NEWLINE> <INDENT> x = t . pop ( - 1 ) <NEWLINE> x *= t . pop ( - 1 ) <NEWLINE> p . append ( x ) <NEWLINE> <DEDENT> p . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> ans = ans * p [ i ] % MOD <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> x = a [ - 1 ] <NEWLINE> ans = a [ - 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> x = a [ - 1 - i ] <NEWLINE> <DEDENT> e = x - 1 <NEWLINE> if e > a [ - 1 - i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> elif e < a [ - 1 - i ] : <NEWLINE> <INDENT> x = a [ - 1 - i ] <NEWLINE> ans += a [ - 1 - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> l = [ 0 ] * 100010 <NEWLINE> ans = sum ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * l [ b ] <NEWLINE> l [ c ] += l [ b ] <NEWLINE> l [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = 1 <NEWLINE> f = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = x * a [ i ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif x > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> from decimal import Decimal <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> l = [ 0 ] * 26 <NEWLINE> for c in S : <NEWLINE> <INDENT> l [ ord ( c ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> if len ( S ) < 26 : <NEWLINE> <INDENT> i = l . index ( 0 ) <NEWLINE> print ( S + chr ( i + ord ( <STRING> ) ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] < S [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> c = min ( S [ j ] for j in range ( i , len ( S ) ) if S [ j ] > S [ i - 1 ] ) <NEWLINE> print ( S [ : i - 1 ] + c ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ 0 for _ in range ( max ( A ) + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> if n > 3 : <NEWLINE> <INDENT> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> tmp = sum ( count [ i : i + 3 ] ) <NEWLINE> if tmp > answer : <NEWLINE> <INDENT> answer = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> if len ( count ) > 3 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 2 <NEWLINE> <DEDENT> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> ls = [ 0 ] * 10 ** 6 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ls [ a ] += 1 <NEWLINE> <NL> <DEDENT> s = sum ( A ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ls [ B ] * ( C - B ) <NEWLINE> ls [ C ] += ls [ B ] <NEWLINE> ls [ B ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> sento = 0 <NEWLINE> ketu = 0 <NEWLINE> tmp = <STRING> <NEWLINE> zeroichi = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if tmp == s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zeroichi . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> tmp = s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> zeroichi . append ( cnt ) <NEWLINE> <NL> if len ( zeroichi ) % 2 == 0 : <NEWLINE> <INDENT> zeroichi . append ( 0 ) <NEWLINE> <NL> <DEDENT> if len ( zeroichi ) == 1 : <NEWLINE> <INDENT> zeroichi . append ( 0 ) <NEWLINE> zeroichi . append ( 0 ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> ans = 0 <NEWLINE> ans_list = [ ] <NEWLINE> j = 0 <NEWLINE> right = min ( 1 + k * 2 , len ( zeroichi ) ) <NEWLINE> left = 0 <NEWLINE> <NL> while i != right : <NEWLINE> <INDENT> ans += zeroichi [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> ans_list . append ( ans ) <NEWLINE> <NL> while right != len ( zeroichi ) : <NEWLINE> <INDENT> ans -= zeroichi [ left ] <NEWLINE> ans -= zeroichi [ left + 1 ] <NEWLINE> ans += zeroichi [ right ] <NEWLINE> ans += zeroichi [ right + 1 ] <NEWLINE> ans_list . append ( ans ) <NEWLINE> left += 2 <NEWLINE> right += 2 <NEWLINE> <NL> <DEDENT> print ( max ( ans_list ) ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> import re <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> ascii_lowercase = <STRING> <NEWLINE> name_roop = [ ] <NEWLINE> <NL> level = 1 <NEWLINE> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> n = N % 26 <NEWLINE> ans += ascii_lowercase [ n ] <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> pow2 = defaultdict ( int ) <NEWLINE> <NL> ret = 0 <NEWLINE> lim = [ 0 ] * ( N + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> r = 1 - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 2 * lim [ i - 1 ] - A [ i ] <NEWLINE> <DEDENT> if r < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> lim [ i ] = r <NEWLINE> <NL> <DEDENT> for d in reversed ( range ( N + 1 ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if d == N : <NEWLINE> <COMMENT> <NL> <INDENT> n = A [ d ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> n = A [ d ] + min ( n , lim [ d ] ) <NEWLINE> <DEDENT> ret += n <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE>
from collections import deque <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> def calc ( x ) : <COMMENT> <NEWLINE> <INDENT> ans = 0 <NEWLINE> for a , b , c , d in A : <NEWLINE> <INDENT> if int ( x [ b - 1 ] ) - int ( x [ a - 1 ] ) == c : <NEWLINE> <INDENT> ans += d <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> q = deque ( [ [ 1 ] ] ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> while q : <NEWLINE> <INDENT> tmp = q . popleft ( ) <COMMENT> <NEWLINE> if len ( tmp ) == N : <NEWLINE> <INDENT> ans = max ( ans , calc ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( tmp [ - 1 ] , M + 1 ) : <COMMENT> <NEWLINE> <INDENT> q . append ( tmp + [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> sumn = 0 <NEWLINE> i , k = 0 , 1 <NEWLINE> while k <= h : <NEWLINE> <INDENT> sumn += k <NEWLINE> i += 1 <NEWLINE> k = 2 ** i <NEWLINE> <NL> <DEDENT> print ( sumn ) <NEWLINE>
<COMMENT> <NL> from bisect import bisect_left <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> L = [ A [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if L [ - 1 ] < A [ i ] : <NEWLINE> <INDENT> L . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ bisect_left ( L , A [ i ] ) ] = A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> d1 = defaultdict ( int ) <NEWLINE> d2 = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d1 [ i - a [ i ] ] += 1 <NEWLINE> d2 [ i + a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for k in d1 . keys ( ) : <NEWLINE> <INDENT> ans += d1 [ k ] * d2 [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = Counter ( arr ) <NEWLINE> sm = sum ( arr ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sm = sm - ( x * ans [ x ] ) <NEWLINE> sm = sm + ( y * ans [ x ] ) <NEWLINE> ans [ y ] += ans [ x ] <NEWLINE> ans [ x ] = 0 <NEWLINE> print ( sm ) <NEWLINE> <DEDENT>
from math import sqrt , ceil <NEWLINE> <NL> <NL> def divisors ( n ) : <NEWLINE> <INDENT> out = [ ] <NEWLINE> nn = ceil ( sqrt ( n ) ) <NEWLINE> for i in range ( 1 , nn ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> out . append ( i ) <NEWLINE> out . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if nn ** 2 == n : <NEWLINE> <INDENT> out . append ( nn ) <NEWLINE> <NL> <DEDENT> out . sort ( ) <NEWLINE> return out <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = len ( divisors ( n - 1 ) [ 1 : ] ) <NEWLINE> <NL> d = divisors ( n ) <NEWLINE> for dd in d [ 1 : ] : <NEWLINE> <INDENT> nn = n <NEWLINE> while nn % dd == 0 : <NEWLINE> <INDENT> nn = nn // dd <NEWLINE> <DEDENT> if nn % dd == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k % 7 == 0 : <NEWLINE> <INDENT> k //= 7 <NEWLINE> <DEDENT> k *= 9 <NEWLINE> a = 10 % k <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = a % k <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a *= 10 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> hList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> n_p = collections . Counter ( [ i + hList [ i ] for i in range ( len ( hList ) ) ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i - hList [ i ] > 0 : <NEWLINE> <INDENT> count += n_p . get ( i - hList [ i ] , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> for seq in itertools . combinations_with_replacement ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> if seq [ 0 ] == seq [ 1 ] or seq [ 1 ] == seq [ 2 ] : <NEWLINE> <INDENT> if seq [ 0 ] != seq [ 2 ] : <NEWLINE> <INDENT> ans += ( math . gcd ( seq [ 0 ] , math . gcd ( seq [ 1 ] , seq [ 2 ] ) ) ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( seq [ 0 ] , math . gcd ( seq [ 1 ] , seq [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( seq [ 0 ] , math . gcd ( seq [ 1 ] , seq [ 2 ] ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> _ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( _ [ 1 ] ) <NEWLINE> b . append ( _ [ 0 ] ) <NEWLINE> <NL> <DEDENT> s = sum ( a ) <NEWLINE> <NL> <COMMENT> <NL> hist = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in hist : <NEWLINE> <INDENT> hist [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hist [ a [ i ] ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> diff = c [ i ] - b [ i ] <NEWLINE> if b [ i ] in hist : <NEWLINE> <INDENT> s += hist [ b [ i ] ] * diff <NEWLINE> print ( s ) <NEWLINE> if c [ i ] in hist : <NEWLINE> <INDENT> hist [ c [ i ] ] += hist [ b [ i ] ] <NEWLINE> del hist [ b [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hist [ c [ i ] ] = hist [ b [ i ] ] <NEWLINE> del hist [ b [ i ] ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = num_list [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= num_list [ i ] <NEWLINE> <NL> <NL> <DEDENT> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> H = [ int ( s ) for s in str ( input ( ) ) . split ( ) ] <NEWLINE> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if dp [ i ] < np . inf : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> res = np . inf <NEWLINE> res = min ( res , rec ( i - 1 ) + abs ( H [ i ] - H [ i - 1 ] ) ) <NEWLINE> if i > 1 : <NEWLINE> <INDENT> res = min ( res , rec ( i - 2 ) + abs ( H [ i ] - H [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> dp [ i ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def main3 ( ) : <NEWLINE> <INDENT> print ( int ( rec ( N - 1 ) ) ) <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ i ] + abs ( H [ i ] - H [ i + 1 ] ) ) <NEWLINE> <DEDENT> if i + 2 < N : <NEWLINE> <INDENT> dp [ i + 2 ] = min ( dp [ i + 2 ] , dp [ i ] + abs ( H [ i ] - H [ i + 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( dp [ N - 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Sets = [ ] <NEWLINE> <NL> Dicto = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if Dicto [ a ] == - 1 and Dicto [ b ] == - 1 : <NEWLINE> <INDENT> Sets . append ( set ( [ a , b ] ) ) <NEWLINE> x_i = len ( Sets ) <NEWLINE> Dicto [ a ] = x_i - 1 <NEWLINE> Dicto [ b ] = x_i - 1 <NEWLINE> <DEDENT> elif Dicto [ a ] != - 1 and Dicto [ b ] == - 1 : <NEWLINE> <INDENT> Sets [ Dicto [ a ] ] . add ( b ) <NEWLINE> Dicto [ b ] = Dicto [ a ] <NEWLINE> <DEDENT> elif Dicto [ b ] != - 1 and Dicto [ a ] == - 1 : <NEWLINE> <INDENT> Sets [ Dicto [ b ] ] . add ( a ) <NEWLINE> Dicto [ a ] = Dicto [ b ] <NEWLINE> <DEDENT> elif Dicto [ b ] != - 1 and Dicto [ a ] != - 1 and Dicto [ a ] != Dicto [ b ] : <NEWLINE> <INDENT> if Dicto [ b ] > Dicto [ a ] : <NEWLINE> <INDENT> set_x = Sets [ Dicto [ b ] ] <NEWLINE> Sets [ Dicto [ a ] ] |= ( set_x ) <NEWLINE> l_set_x = list ( set_x ) <NEWLINE> for j in l_set_x : <NEWLINE> <INDENT> Dicto [ j ] = Dicto [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> set_x = Sets [ Dicto [ a ] ] <NEWLINE> Sets [ Dicto [ b ] ] |= ( set_x ) <NEWLINE> l_set_x = list ( set_x ) <NEWLINE> for j in l_set_x : <NEWLINE> <INDENT> Dicto [ j ] = Dicto [ b ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> max_len = 1 <NEWLINE> <NL> for i in range ( len ( Sets ) ) : <NEWLINE> <INDENT> if max_len < len ( Sets [ i ] ) : <NEWLINE> <INDENT> max_len = len ( Sets [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_len ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10001 ) <NEWLINE> <NL> def dfs ( u , g , stack ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs ( v , g , stack ) <NEWLINE> <DEDENT> <DEDENT> stack . append ( u ) <NEWLINE> return stack <NEWLINE> <NL> <DEDENT> nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj , tps = ( [ [ ] for _ in range ( nv ) ] for _ in range ( 2 ) ) <NEWLINE> <NL> for _ in range ( ne ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> tps [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * nv <NEWLINE> stack = [ ] <NEWLINE> for i in range ( nv ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> stack = dfs ( i , adj , stack ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ False ] * nv <NEWLINE> comp_is = { } <NEWLINE> while stack : <NEWLINE> <INDENT> i = stack . pop ( ) <NEWLINE> if not visited [ i ] : <NEWLINE> <INDENT> comp = dfs ( i , tps , [ ] ) <NEWLINE> for v in comp : <NEWLINE> <INDENT> comp_is [ v ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> nv = int ( input ( ) ) <NEWLINE> for _ in range ( nv ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if comp_is [ u ] == comp_is [ v ] : print ( 1 ) <NEWLINE> else : print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> num = sum ( A ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> num -= a <NEWLINE> ans += a * num <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> x = S . count ( <STRING> ) <NEWLINE> y = S . count ( <STRING> ) <NEWLINE> print ( 2 * min ( x , y ) ) <NEWLINE>
import math <NEWLINE> con = 0 ; <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> <NL> m = int ( math . sqrt ( n ) // 1 ) ; <NEWLINE> for x in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> s = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ; <NEWLINE> if s <= n : <NEWLINE> <INDENT> a [ s - 1 ] += 1 ; <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for v in range ( n ) : <NEWLINE> <INDENT> print ( a [ v ] ) ; <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq , math <NEWLINE> from itertools import zip_longest , permutations , combinations , combinations_with_replacement <NEWLINE> from itertools import accumulate , dropwhile , takewhile , groupby <NEWLINE> from functools import lru_cache <NEWLINE> from copy import deepcopy <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = { } <NEWLINE> s = 0 <NEWLINE> ans = 0 <NEWLINE> B [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> s = ( s + a ) % M <NEWLINE> ans += B . get ( s , 0 ) <NEWLINE> B [ s ] = B . get ( s , 0 ) + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> count_num = int ( input ( ) ) <NEWLINE> text = input ( ) <NEWLINE> <NL> num_data = text . split ( <STRING> ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in num_data : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> for i in num_data : <NEWLINE> <INDENT> ans = ans * int ( i ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> import networkx as nx <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR_dict = defaultdict ( lambda : 10 ** 9 ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> LR_dict [ ( l , r ) ] = min ( LR_dict [ ( l , r ) ] , c ) <NEWLINE> <NL> <DEDENT> G = nx . DiGraph ( ) <NEWLINE> G . add_nodes_from ( range ( 1 , N + 1 ) ) <NEWLINE> G . add_weighted_edges_from ( [ ( x + 1 , x , 0 ) for x in range ( 1 , N ) ] ) <NEWLINE> G . add_weighted_edges_from ( ( l , r , c ) for ( l , r ) , c in LR_dict . items ( ) ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> print ( nx . dijkstra_path_length ( G , 1 , N ) ) <NEWLINE> <DEDENT> except nx . NetworkXNoPath : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ ] <NEWLINE> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> line = list ( input ( ) ) <NEWLINE> G . append ( line ) <NEWLINE> black += line . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> ls = deque ( [ [ 0 , 0 , 0 ] ] ) <NEWLINE> D = [ [ float ( <STRING> ) ] * W for i in range ( H ) ] <NEWLINE> direction = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> find = False <NEWLINE> while len ( ls ) > 0 : <NEWLINE> <INDENT> h , w , depth = ls . popleft ( ) <NEWLINE> <NL> if h == H - 1 and w == W - 1 : <NEWLINE> <INDENT> route = depth + 1 <NEWLINE> find = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> for dh , dw in direction : <NEWLINE> <INDENT> if h + dh < 0 or H - 1 < h + dh : continue <NEWLINE> if w + dw < 0 or W - 1 < w + dw : continue <NEWLINE> if depth + 1 < D [ h + dh ] [ w + dw ] and G [ h + dh ] [ w + dw ] != <STRING> : <NEWLINE> <INDENT> ls . append ( [ h + dh , w + dw , depth + 1 ] ) <NEWLINE> D [ h + dh ] [ w + dw ] = depth + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if find : <NEWLINE> <INDENT> ans = ( H * W ) - black - route <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , 1001 ) : <NEWLINE> <INDENT> sub = a ** 5 <NEWLINE> ss = sub - x <NEWLINE> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if b ** 5 == ss : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> sam = sum ( A ) <NEWLINE> baketu = [ 0 ] * ( 100001 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> baketu [ a ] += 1 <NEWLINE> <NL> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> sam = sam + baketu [ B [ q ] ] * ( C [ q ] - B [ q ] ) <NEWLINE> baketu [ C [ q ] ] += baketu [ B [ q ] ] <NEWLINE> baketu [ B [ q ] ] = 0 <NEWLINE> <COMMENT> <NL> print ( sam ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> tmp = [ ] <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> for b in range ( k ) : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> tmp . append ( math . gcd ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> for i in tmp : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> cnt = cnt + k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> cnt = cnt + math . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def grid ( y , x ) : <NEWLINE> <INDENT> global dp , visited <NEWLINE> if visited [ y ] [ x ] : <NEWLINE> <INDENT> return dp [ y ] [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ y ] [ x ] = True <NEWLINE> if mp [ y ] [ x ] != <STRING> and dp [ y ] [ x ] == 0 : <NEWLINE> <INDENT> dp [ y ] [ x ] = ( grid ( y - 1 , x ) + grid ( y , x - 1 ) ) % mod <NEWLINE> <DEDENT> return dp [ y ] [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ [ <STRING> ] * ( W + 1 ) ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> mp . append ( [ <STRING> ] + list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( H + 1 ) ] <NEWLINE> dp [ 1 ] [ 1 ] = 1 <NEWLINE> visited = [ [ False ] * ( W + 1 ) for _ in range ( H + 1 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> grid ( H , W ) <NEWLINE> print ( dp [ H ] [ W ] ) <NEWLINE>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> aa = Counter ( LIST ( ) ) <NEWLINE> aa = sorted ( aa . items ( ) , key = itemgetter ( 0 ) ) <NEWLINE> a = [ [ aa [ i ] [ 1 ] , aa [ i ] [ 0 ] ] for i in range ( len ( aa ) ) ] <NEWLINE> b = sorted ( [ LIST ( ) for i in range ( m ) ] , key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = j = 0 <NEWLINE> while i < len ( b ) and j < len ( a ) and b [ i ] [ 1 ] > a [ j ] [ 1 ] : <NEWLINE> <INDENT> if b [ i ] [ 0 ] >= a [ j ] [ 0 ] : <NEWLINE> <INDENT> ans += b [ i ] [ 1 ] * a [ j ] [ 0 ] <NEWLINE> b [ i ] [ 0 ] -= a [ j ] [ 0 ] <NEWLINE> a [ j ] [ 0 ] = 0 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] [ 1 ] * b [ i ] [ 0 ] <NEWLINE> a [ j ] [ 0 ] -= b [ i ] [ 0 ] <NEWLINE> b [ i ] [ 0 ] = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> reg = j <NEWLINE> if reg < len ( a ) : <NEWLINE> <INDENT> for i in range ( j , len ( a ) ) : <NEWLINE> <INDENT> ans += a [ i ] [ 0 ] * a [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> gcd_sum = 0 <NEWLINE> target_range = range ( 1 , K + 1 ) <NEWLINE> for comb in itertools . combinations_with_replacement ( target_range , 3 ) : <NEWLINE> <INDENT> a , b , c = comb [ 0 ] , comb [ 1 ] , comb [ 2 ] <NEWLINE> gcd = reduce ( math . gcd , comb ) <NEWLINE> <NL> if a == b == c : <NEWLINE> <INDENT> gcd_sum += gcd <NEWLINE> <DEDENT> elif a != b != c : <NEWLINE> <INDENT> gcd_sum += gcd * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd_sum += gcd * 3 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( gcd_sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> observary = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> observary [ a ] . append ( h [ b ] ) <NEWLINE> observary [ b ] . append ( h [ a ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if len ( observary [ i ] ) == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif max ( observary [ i ] ) < h [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 for i in range ( int ( 1e5 ) + 1 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> L [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( int ( 1e5 ) + 1 ) : <NEWLINE> <INDENT> S = sum ( L [ i : i + 3 ] ) <NEWLINE> if ans < S : <NEWLINE> <INDENT> ans = S <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - i - j <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a_list = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> mod = 1000000007 <NEWLINE> <NL> sum_list = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> sum += i <NEWLINE> sum_list . append ( sum ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for idx , i in enumerate ( a_list [ : - 1 ] ) : <NEWLINE> <INDENT> sum += i * ( sum_list [ - 1 ] - sum_list [ idx ] ) <NEWLINE> <NL> <DEDENT> print ( sum % mod ) <NEWLINE>
<COMMENT> <NL> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def func ( i ) : <NEWLINE> <INDENT> return int ( i * a / b ) - a * int ( i / b ) <NEWLINE> <NL> <DEDENT> print ( func ( min ( b - 1 , n ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> s = sum ( A ) % mod <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> if 0 > s : <NEWLINE> <INDENT> s += mod <NEWLINE> <DEDENT> ans += A [ i ] * s <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> noguchi = [ 1000 * n for n in range ( 1 , 11 ) ] <NEWLINE> <NL> <COMMENT> <NL> print ( min ( [ ngc - N for ngc in noguchi if ( ngc - N ) >= 0 ] ) ) <NEWLINE>
def solve ( x ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> x %= bin ( x ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> one = sum ( map ( int , list ( x ) ) ) <NEWLINE> num = int ( x , 2 ) <NEWLINE> <NL> up = num % ( one + 1 ) <NEWLINE> if one == 1 : <NEWLINE> <INDENT> down = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> down = num % ( one - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if one == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> s = ( down - pow ( 2 , n - i - 1 , one - 1 ) ) % ( one - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( up + pow ( 2 , n - i - 1 , one + 1 ) ) % ( one + 1 ) <NEWLINE> <DEDENT> print ( solve ( s ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( sum ( x < 0 for x in uf . parents ) - 1 ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> i = 1 <NEWLINE> while N > 26 ** i : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> N -= 1 <NEWLINE> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += ascii_lowercase [ N // ( 26 ** j ) ] <NEWLINE> N %= 26 ** j <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
sec = int ( input ( ) ) <NEWLINE> <NL> h = int ( sec / 3600 ) <NEWLINE> sec %= 3600 <NEWLINE> <NL> m = int ( sec / 60 ) <NEWLINE> sec %= 60 <NEWLINE> <NL> s = sec <NEWLINE> <NL> print ( <STRING> . join ( map ( str , [ h , m , s ] ) ) ) <NEWLINE>
from operator import itemgetter <NEWLINE> <COMMENT> <NL> def calc ( w , pdp , pl , pr , dp , l , r ) : <NEWLINE> <INDENT> if l >= r : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> m = ( l + r ) // 2 <NEWLINE> dp [ m ] , i = min ( [ ( pdp [ i ] + w [ i + 1 ] [ m ] , i ) for i in range ( pl , min ( m , pr ) ) ] , key = itemgetter ( 0 ) ) <NEWLINE> calc ( w , pdp , pl , i + 1 , dp , l , m ) <NEWLINE> calc ( w , pdp , i , pr , dp , m + 1 , r ) <NEWLINE> return dp <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> s , n , m = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> tp = [ list ( map ( int , line . split ( ) ) ) for line in f ] <NEWLINE> <NL> c = [ ti - x [ pi - 1 ] for ti , pi in tp ] <NEWLINE> c . sort ( ) <NEWLINE> min_c = c [ 0 ] <NEWLINE> c = [ ci - min_c for ci in c ] <NEWLINE> d = c [ : ] <NEWLINE> for i in range ( 1 , len ( d ) ) : <NEWLINE> <INDENT> d [ i ] += d [ i - 1 ] <NEWLINE> <NL> <DEDENT> w = [ [ 0 for j in range ( n ) ] for i in range ( n ) ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> w [ i ] [ j ] = c [ j ] * ( j - i + 1 ) - ( d [ j ] - d [ i ] + c [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dp = w [ 0 ] [ : ] <NEWLINE> for bus in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> pdp = dp <NEWLINE> dp = [ 0 ] * len ( pdp ) <NEWLINE> pl = bus - 2 <NEWLINE> pr = n - m + bus <NEWLINE> if pl > pr : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp = calc ( w , pdp , pl , pr , dp , bus , n ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> H . sort ( reverse = True ) <NEWLINE> <NL> if K >= N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( H [ K : ] ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> LEN = 10 ** 6 <NEWLINE> is_avl = [ 0 ] * ( LEN + 1 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> is_avl [ a ] = 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> for i in range ( 2 * a , LEN + 1 , a ) : <NEWLINE> <INDENT> is_avl [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if is_avl [ a ] == 1 and A [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> ins = lambda : input ( ) . rstrip ( ) <NEWLINE> ini = lambda : int ( input ( ) . rstrip ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> out = lambda x : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <NL> n , m , k = inm ( ) <NEWLINE> a = inl ( ) <NEWLINE> b = [ 0 ] + inl ( ) <NEWLINE> count = 0 <NEWLINE> prev = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a [ i + 1 ] += a [ i ] <NEWLINE> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> if b [ i ] + prev > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect . bisect ( a , ( k - b [ i ] - prev ) ) <NEWLINE> count = max ( count , i + j ) <NEWLINE> prev += b [ i ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
Residents = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Residents [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , Residents [ k ] [ j ] ) ) ) <NEWLINE> <DEDENT> if k == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> for _ in A : <NEWLINE> <INDENT> sum *= _ <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> total = 1 <NEWLINE> A . sort ( ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif total > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total = total * i <NEWLINE> <DEDENT> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> c_list = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> cand = [ ] <NEWLINE> e_list = [ i for i in range ( N ) ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for e in itertools . combinations ( e_list , n ) : <NEWLINE> <INDENT> sum_list = np . zeros ( M ) <NEWLINE> sum_maney = 0 <NEWLINE> for i in set ( e ) : <NEWLINE> <INDENT> sum_list += np . array ( c_list [ i ] [ 1 : ] ) <NEWLINE> sum_maney += c_list [ i ] [ 0 ] <NEWLINE> <DEDENT> flag = True <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> if not sum_list [ m ] >= X : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> cand . append ( sum_maney ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cand == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( cand ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def maxProfit ( prices ) -> int : <NEWLINE> <INDENT> if len ( prices ) < 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ans = 1000 <NEWLINE> for i in range ( 1 , len ( prices ) ) : <NEWLINE> <INDENT> if prices [ i ] > prices [ i - 1 ] : <NEWLINE> <INDENT> stock = ans // prices [ i - 1 ] <NEWLINE> ans += stock * ( prices [ i ] - prices [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) . strip ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> ans = maxProfit ( A ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = int ( math . sqrt ( n ) ) <NEWLINE> ans = [ 0 for i in range ( 100001 ) ] <NEWLINE> for j in range ( 1 , t ) : <NEWLINE> <INDENT> for k in range ( 1 , t ) : <NEWLINE> <INDENT> for l in range ( 1 , t ) : <NEWLINE> <INDENT> s = j ** 2 + k ** 2 + l ** 2 + j * k + k * l + j * l <NEWLINE> if s < 10001 : <NEWLINE> <INDENT> ans [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ m ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a <= k and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b < k and k <= a + b + c : <NEWLINE> <INDENT> print ( a - k + a + b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> N = int ( readline ( ) ) <NEWLINE> se = set ( [ readline ( ) for _ in range ( N ) ] ) <NEWLINE> print ( len ( se ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while a != 0 or c != 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ L - 1 ] [ R - 1 ] += 1 <NEWLINE> <NL> <DEDENT> csum = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> csum [ i ] [ j ] = csum [ i ] [ j - 1 ] + csum [ i - 1 ] [ j ] - csum [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( csum [ q ] [ q ] - csum [ q ] [ p - 1 ] - csum [ p - 1 ] [ q ] + csum [ p - 1 ] [ p - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = p [ 0 ] <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if m >= p [ i ] : <NEWLINE> <INDENT> m = p [ i ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minus = { } <NEWLINE> plus = { } <NEWLINE> res = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> pp = a [ i ] <NEWLINE> if i - pp in minus : <NEWLINE> <INDENT> minus [ i - pp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus [ i - pp ] = 1 <NEWLINE> <DEDENT> if i + pp in plus : <NEWLINE> <INDENT> plus [ i + pp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus [ i + pp ] = 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( minus ) ) : <NEWLINE> <INDENT> t = minus . popitem ( ) <NEWLINE> try : <NEWLINE> <INDENT> res += t [ 1 ] * plus [ t [ 0 ] ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import Counter <NEWLINE> <NL> <NL> def solve ( N : int , A : <STRING> , Q : int , BC : <STRING> ) : <NEWLINE> <INDENT> A = Counter ( A ) <NEWLINE> answers = [ ] <NEWLINE> ans = ans = sum ( ( i * n for i , n in A . items ( ) ) ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> if b != c : <NEWLINE> <INDENT> ans += ( c - b ) * A [ b ] <NEWLINE> A [ c ] += A [ b ] <NEWLINE> del A [ b ] <NEWLINE> <DEDENT> answers . append ( ans ) <NEWLINE> <DEDENT> return answers <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <COMMENT> <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> answer = solve ( N , A , Q , BC ) <NEWLINE> for ans in answer : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> if x - i not in table : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + i not in table : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> forward = True <NEWLINE> que0 = [ ] <NEWLINE> que1 = [ ] <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> <NL> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> forward = not forward <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> head = ( query [ 1 ] == <STRING> ) <NEWLINE> if head ^ forward : <NEWLINE> <INDENT> que1 . append ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que0 . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = <STRING> . join ( que0 [ : : - 1 ] ) + S + <STRING> . join ( que1 ) <NEWLINE> <NL> if forward : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : : - 1 ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) ; <NEWLINE> n1 = 0 ; <NEWLINE> n2 = 0 ; <NEWLINE> if ( x == 1 ) : <NEWLINE> <INDENT> n1 = 0 ; <NEWLINE> n2 = - 1 ; <NEWLINE> print ( n1 , n2 ) ; <NEWLINE> <DEDENT> flag = False ; <NEWLINE> <NL> if ( x != 1 ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> if ( ( i * i * i * i * i ) - ( - ( j * j * j * j * j ) ) == x ) : <NEWLINE> <INDENT> print ( i , - j ) ; <NEWLINE> flag = True ; <NEWLINE> break ; <NEWLINE> <DEDENT> if ( ( i * i * i * i * i ) - ( ( j * j * j * j * j ) ) == x ) : <NEWLINE> <INDENT> print ( i , j ) ; <NEWLINE> flag = True ; <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> b = a [ n - 1 : : - 2 ] + a [ : : 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a [ n - 1 : : - 2 ] + a [ 1 : : 2 ] <NEWLINE> <NL> <DEDENT> print ( * b ) <NEWLINE>
def sort ( a , b , c ) : <NEWLINE> <INDENT> l = [ a , b , c ] <NEWLINE> l . sort ( ) <NEWLINE> return l <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> sum = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i - 1 >= 0 and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif i + 1 < len ( s ) and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif i + 1 < len ( s ) and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> s [ i + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = L // 2019 <NEWLINE> r1 = R // 2019 <NEWLINE> if l1 < r1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif l1 == r1 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> res . append ( ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( res ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> row = [ 0 ] * ( H ) <NEWLINE> col = [ 0 ] * ( W ) <NEWLINE> bomb = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( h , w ) ) <NEWLINE> row [ h - 1 ] += 1 <NEWLINE> col [ w - 1 ] += 1 <NEWLINE> <DEDENT> row_max = max ( row ) <NEWLINE> row_index_list = [ i for i , v in enumerate ( row ) if v == row_max ] <NEWLINE> col_max = max ( col ) <NEWLINE> col_index_list = [ i for i , v in enumerate ( col ) if v == col_max ] <NEWLINE> ans = row_max + col_max - 1 <NEWLINE> c = False <NEWLINE> for x in row_index_list : <NEWLINE> <INDENT> for y in col_index_list : <NEWLINE> <INDENT> if not ( x + 1 , y + 1 ) in bomb : <NEWLINE> <INDENT> c = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> b = [ ] <NEWLINE> a = a [ : : - 1 ] <NEWLINE> for i in range ( n ) [ : : 2 ] : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> a = a [ : : - 1 ] <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> a . pop ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) [ : : 2 ] : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , 1500 ) : <NEWLINE> <INDENT> a4 = a ** 4 <NEWLINE> a3 = a ** 3 <NEWLINE> a2 = a ** 2 <NEWLINE> for b in range ( - 1500 , 1500 ) : <NEWLINE> <INDENT> an = ( a - b ) * ( a4 + ( a3 ) * b + ( a2 ) * ( b ** 2 ) + a * ( b ** 3 ) + b ** 4 ) <NEWLINE> if an < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if an == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = [ 0 ] * N <NEWLINE> summ = [ 0 ] * N <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> diff [ i ] = i - A [ i ] <NEWLINE> summ [ i ] = A [ i ] + i <NEWLINE> <NL> <DEDENT> c_diff = collections . Counter ( diff ) <NEWLINE> c_summ = collections . Counter ( summ ) <NEWLINE> for k in c_diff . keys ( ) : <NEWLINE> <INDENT> count = count + c_diff [ k ] * c_summ [ k ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 400000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> paths = [ list ( ) for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ a ] . append ( b ) <NEWLINE> paths [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> counters = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> for x in px : <NEWLINE> <INDENT> counters [ x [ 0 ] ] += x [ 1 ] <NEWLINE> <NL> <DEDENT> visit = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> def dfs ( node , score , ans ) : <NEWLINE> <INDENT> visit [ node ] = 1 <COMMENT> <NEWLINE> score += counters [ node ] <COMMENT> <NEWLINE> ans [ node ] = score <COMMENT> <NEWLINE> for loof in paths [ node ] : <COMMENT> <NEWLINE> <INDENT> if visit [ loof ] == 0 : <COMMENT> <NEWLINE> <INDENT> dfs ( loof , score , ans ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , 0 , ans ) <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> from collections import deque <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sa , sb = [ 0 ] , [ 0 ] <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> if s > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sa . append ( s ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s += b [ i ] <NEWLINE> if s > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sb . append ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( sa ) ) : <NEWLINE> <INDENT> l = k - sa [ i ] <NEWLINE> if l < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> num = bisect . bisect_right ( sb , l ) - 1 <NEWLINE> ans = max ( ans , num + i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> s = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s *= int ( A [ i ] ) <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> d = Counter ( a ) <NEWLINE> <NL> s = sum ( [ k * v for k , v in d . items ( ) ] ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in d . keys ( ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> continue <NEWLINE> <DEDENT> cc = 0 <NEWLINE> s = s + ( c - b ) * d [ b ] <NEWLINE> print ( s ) <NEWLINE> if c in d . keys ( ) : <NEWLINE> <INDENT> cc = d [ c ] <NEWLINE> <DEDENT> d [ c ] = cc + d [ b ] <NEWLINE> del d [ b ] <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> num = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> num = ( num * 10 + 7 ) % k <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <NL> <NL> def xnxn ( n = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> return temp [ 0 ] <NEWLINE> <DEDENT> elif len ( temp ) > 1 : <NEWLINE> <INDENT> return temp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> return temp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def sp_xnxn ( n = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return [ int ( k ) for k in xsxs ( ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ [ int ( k ) for k in xsxs ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def xsxs ( n = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> temp = list ( input ( ) . split ( ) ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> return temp [ 0 ] <NEWLINE> <DEDENT> elif len ( temp ) > 1 : <NEWLINE> <INDENT> return temp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return [ list ( input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def sp_xsxs ( n = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return [ s for s in xsxs ( ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ [ s for s in xsxs ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def p_num ( a ) : <NEWLINE> <NL> <INDENT> if a == 1 : <NEWLINE> <INDENT> return [ [ a , 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 2 <NEWLINE> ans = [ ] <NEWLINE> while tmp < np . sqrt ( a ) + 1 : <NEWLINE> <INDENT> n = 0 <NEWLINE> p = [ tmp ] <NEWLINE> <NL> while a % tmp == 0 : <NEWLINE> <INDENT> a = int ( a / tmp ) <NEWLINE> <COMMENT> <NL> n += 1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> if n != 0 : <NEWLINE> <INDENT> p . append ( n ) <NEWLINE> ans . append ( p ) <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> c = 0 <NEWLINE> <DEDENT> if c == 0 and a != 1 : <NEWLINE> <INDENT> ans . append ( [ a , 1 ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = xnxn ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = p_num ( n ) <NEWLINE> c = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> i = 1 <NEWLINE> while num [ 1 ] - i > - 1 : <NEWLINE> <INDENT> num [ 1 ] -= i <NEWLINE> i += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> lcm = lcm ( C , D ) <NEWLINE> <NL> u_b_ans = ( B // C + B // D ) - B // lcm <NEWLINE> u_a_ans = ( ( A - 1 ) // C + ( A - 1 ) // D ) - ( A - 1 ) // lcm <NEWLINE> <NL> print ( B - A + 1 - u_b_ans + u_a_ans ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> from operator import itemgetter <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mp ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmp ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 10 ** 6 + 10 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = Counter ( lmp ( ) ) . most_common ( ) <NEWLINE> a = sorted ( a , key = lambda x : x [ 0 ] ) <NEWLINE> c = [ 0 ] * M <NEWLINE> for j , x in a : <NEWLINE> <INDENT> if c [ j ] == 0 : <NEWLINE> <INDENT> k = 2 <NEWLINE> while j * k < M : <NEWLINE> <INDENT> c [ j * k ] = 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x , y in a : <NEWLINE> <INDENT> if c [ x ] == 0 and y == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <DEDENT> used = set ( ) <NEWLINE> num = [ 0 ] * n <NEWLINE> used . add ( 0 ) <NEWLINE> now = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if not a [ now ] in used : <NEWLINE> <INDENT> used . add ( a [ now ] ) <NEWLINE> num [ a [ now ] ] = cnt <NEWLINE> now = a [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lps = a [ now ] <NEWLINE> mod = cnt - num [ a [ now ] ] <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> <DEDENT> now = 0 <NEWLINE> <COMMENT> <NL> while k : <NEWLINE> <INDENT> if now == lps : <NEWLINE> <INDENT> k %= mod <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now = a [ now ] <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> print ( now + 1 ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( k > a + b ) : <NEWLINE> <INDENT> print ( a - min ( k - a - b , c ) ) <NEWLINE> <DEDENT> elif ( k >= a ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> towns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> towns . insert ( 0 , - 1 ) <NEWLINE> p = 1 <NEWLINE> tmp_move , first_move , roop_move = [ 1 ] , [ ] , [ ] <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> res = - 1 <NEWLINE> <NL> while not visited [ p ] : <NEWLINE> <INDENT> visited [ p ] = True <NEWLINE> tmp_move . append ( towns [ p ] ) <NEWLINE> p = towns [ p ] <NEWLINE> <NL> <DEDENT> index = tmp_move . index ( p ) <NEWLINE> roop_move = tmp_move [ index : - 1 ] <NEWLINE> first_move = tmp_move [ : index ] <NEWLINE> <NL> if K < len ( first_move ) : <NEWLINE> <INDENT> res = first_move [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = ( K - len ( first_move ) ) % len ( roop_move ) <NEWLINE> res = roop_move [ index ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( S ) != 26 : <NEWLINE> <INDENT> L = [ 0 ] * 26 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> L [ ord ( S [ i ] ) - 97 ] = 1 <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if L [ i ] == 0 : <NEWLINE> <INDENT> print ( S + chr ( 97 + i ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = [ ] <NEWLINE> for i in reversed ( range ( 26 ) ) : <NEWLINE> <INDENT> if ord ( S [ i ] ) > ord ( S [ i - 1 ] ) : <NEWLINE> <INDENT> U = i <NEWLINE> M = i - 1 <NEWLINE> B += [ ord ( S [ i ] ) ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += [ ord ( S [ i ] ) ] <NEWLINE> <DEDENT> <DEDENT> B . sort ( ) <NEWLINE> for i in B : <NEWLINE> <INDENT> if chr ( i ) > S [ M ] : <NEWLINE> <INDENT> print ( S [ : M ] + chr ( i ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ l - 1 ] . append ( ( r - 1 , d ) ) <NEWLINE> graph [ r - 1 ] . append ( ( l - 1 , - d ) ) <NEWLINE> <DEDENT> seen = [ False ] * n <NEWLINE> dist = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = deque ( [ i ] ) <NEWLINE> dist [ i ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> if seen [ node ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ node ] = True <NEWLINE> for c_node , d in graph [ node ] : <NEWLINE> <INDENT> if dist [ c_node ] is None : <NEWLINE> <INDENT> dist [ c_node ] = dist [ node ] + d <NEWLINE> <DEDENT> elif dist [ c_node ] != dist [ node ] + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if not seen [ c_node ] : <NEWLINE> <INDENT> q . append ( c_node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
from collections import deque <NEWLINE> import copy <NEWLINE> <NL> <COMMENT> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ deque ( [ ] ) for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> q_sum_list = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> q_sum_list [ p - 1 ] += x <NEWLINE> <COMMENT> <NL> <DEDENT> arrive_rireki = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> score = [ 0 ] * n <NEWLINE> score_temp = 0 <NEWLINE> <NL> <COMMENT> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global score_temp <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> stack = [ v ] <NEWLINE> arrive_rireki [ v ] = 1 <NEWLINE> score_temp += q_sum_list [ v - 1 ] <NEWLINE> while stack : <NEWLINE> <COMMENT> <NL> <INDENT> v = stack [ - 1 ] <NEWLINE> if graph [ v ] : <NEWLINE> <INDENT> w = graph [ v ] . popleft ( ) <NEWLINE> if arrive_rireki [ w ] < 0 : <NEWLINE> <INDENT> arrive_rireki [ w ] = 1 <NEWLINE> stack . append ( w ) <NEWLINE> score_temp += q_sum_list [ w - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <COMMENT> <NL> score [ v - 1 ] = score_temp <NEWLINE> score_temp -= q_sum_list [ v - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> <COMMENT> <NL> print ( * score ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> sum_a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> sum_b = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sum_b . append ( sum_b [ i ] + b [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> a_i = 0 <NEWLINE> b_i = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_i = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> if sum_a [ a_i ] + sum_b [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_i = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = a_i + b_i <NEWLINE> for i in range ( a_i , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( b_i , m + 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] + sum_b [ j ] > k : <NEWLINE> <INDENT> b_i = j - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> rst = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ls [ i - 1 ] > ls [ i ] : <NEWLINE> <INDENT> rst += ls [ i - 1 ] - ls [ i ] <NEWLINE> ls [ i ] += ls [ i - 1 ] - ls [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> num += i * ( n - i + 1 ) + 1 <NEWLINE> <DEDENT> print ( num % ( 10 ** 9 + 7 ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( H ) - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count != 0 : <NEWLINE> <INDENT> ans . append ( count ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ ] <NEWLINE> for i in range ( n ) : Q . append ( deque ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> t = int ( a [ 1 ] ) <NEWLINE> if a [ 0 ] == <STRING> : Q [ t ] . append ( a [ 2 ] ) <COMMENT> <NEWLINE> elif a [ 0 ] == <STRING> and Q [ t ] : print ( Q [ t ] [ - 1 ] ) <COMMENT> <NEWLINE> elif a [ 0 ] == <STRING> and Q [ t ] : Q [ t ] . pop ( ) <COMMENT> <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( int ( float ( input ( ) ) ** 2 / 98 + 2 ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = np . empty ( n , dtype = object ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <DEDENT> print ( np . unique ( s ) . size ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for b2 in b : <NEWLINE> <INDENT> print ( b2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 1000000007 <NEWLINE> sum_n = 0 <NEWLINE> a = [ ] <NEWLINE> for i in b : <NEWLINE> <INDENT> a . append ( i % MOD ) <NEWLINE> <DEDENT> sum_sum = sum ( a [ 1 : ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <INDENT> sum_n = ( sum_n + ( a [ i ] * sum_sum ) % MOD ) % MOD <NEWLINE> if i + 1 < N : <NEWLINE> <INDENT> sum_sum = sum_sum - a [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( sum_n % MOD ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dai = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> plus = [ i for i in range ( N ) ] <NEWLINE> <NL> <NL> for a , b in dai : <NEWLINE> <INDENT> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> plus [ b - 1 ] = - 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus [ a - 1 ] = - 1 <NEWLINE> <DEDENT> if H [ b - 1 ] > H [ a - 1 ] : <NEWLINE> <INDENT> plus [ a - 1 ] = - 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus [ b - 1 ] = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( set ( plus ) ) - 1 ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from math import sqrt <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def closest_part ( points , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> m = n // 2 <NEWLINE> x = points [ m ] [ 0 ] <NEWLINE> d = min ( closest_part ( points [ : m ] , m ) , closest_part ( points [ m : ] , n - m ) ) <NEWLINE> <NL> points . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( points [ i ] [ 0 ] - x ) ** 2 >= d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> dx = points [ i ] [ 0 ] - b [ - j - 1 ] [ 0 ] <NEWLINE> dy = points [ i ] [ 1 ] - b [ - j - 1 ] [ 1 ] <NEWLINE> if dy ** 2 >= d : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = min ( d , ( dx ** 2 + dy ** 2 ) ) <NEWLINE> <DEDENT> b . append ( points [ i ] ) <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> points = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> points . sort ( ) <COMMENT> <NEWLINE> <NL> result = closest_part ( points , n ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> def dfs ( node ) : <NEWLINE> <INDENT> for adjnode in edges [ node ] : <NEWLINE> <INDENT> if colors [ adjnode [ 0 ] ] == - 1 : <NEWLINE> <INDENT> if adjnode [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> colors [ adjnode [ 0 ] ] = colors [ node ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> colors [ adjnode [ 0 ] ] = colors [ node ] ^ 1 <NEWLINE> <DEDENT> dfs ( adjnode [ 0 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> edges = { e : [ ] for e in range ( n ) } <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edges [ u ] . append ( ( v , w ) ) <NEWLINE> edges [ v ] . append ( ( u , w ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> colors = [ - 1 ] * n <NEWLINE> colors [ 0 ] = 0 <NEWLINE> dfs ( 0 ) <NEWLINE> <COMMENT> <NL> print ( * colors , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = [ 0 for i in range ( a [ - 1 ] + 1 ) ] <NEWLINE> lbl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] ] == 2 : <NEWLINE> <INDENT> lbl . append ( a [ i ] ) <NEWLINE> continue <NEWLINE> <DEDENT> if dp [ a [ i ] ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , a [ - 1 ] // a [ i ] + 1 ) : <NEWLINE> <INDENT> dp [ a [ i ] * j ] = 1 <NEWLINE> <DEDENT> dp [ a [ i ] ] = 2 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( lbl ) ) : <NEWLINE> <INDENT> dp [ lbl [ i ] ] = 0 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( dp ) ) : <NEWLINE> <INDENT> if dp [ i ] == 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = [ i - 1 for i in map ( int , readline ( ) . split ( ) ) ] <NEWLINE> <NL> m = 60 <NEWLINE> d = [ A ] <NEWLINE> pre = A <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> current = [ pre [ pre [ j ] ] for j in range ( n ) ] <NEWLINE> d . append ( current ) <NEWLINE> pre = current <NEWLINE> <NL> <DEDENT> route = 0 <NEWLINE> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if k >= ( x : = 1 << i ) : <NEWLINE> <INDENT> route = d [ i ] [ route ] <NEWLINE> k -= x <NEWLINE> <DEDENT> <DEDENT> print ( route + 1 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 1 + ( n - 1 - 1 ) * 2 <NEWLINE> <NL> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> for j in range ( 2 , n ) : <NEWLINE> <INDENT> if i * j >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> keyList = list ( range ( 1 , N + 1 ) ) <NEWLINE> values = [ True ] * N <NEWLINE> dic = dict ( zip ( keyList , values ) ) <NEWLINE> HList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> H_a = HList [ a - 1 ] <NEWLINE> H_b = HList [ b - 1 ] <NEWLINE> if ( H_a == H_b ) : <NEWLINE> <INDENT> dic [ a ] = False <NEWLINE> dic [ b ] = False <NEWLINE> <DEDENT> elif ( H_b > H_a ) : <NEWLINE> <INDENT> dic [ a ] = False <NEWLINE> <DEDENT> elif ( H_a > H_b ) : <NEWLINE> <INDENT> dic [ b ] = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( dic . values ( ) ) + 1 ) : <NEWLINE> <INDENT> if ( dic [ i ] == True ) : <NEWLINE> <INDENT> ans . append ( dic [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sunuke = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> tmp = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> sunuke . append ( tmp [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( set ( sunuke ) ) ) <NEWLINE>
s = [ * input ( ) ] ; print ( 2 * min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ng = - 1 <NEWLINE> ok = max ( A ) + 1 <NEWLINE> def test ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > x : <NEWLINE> <INDENT> cnt += - ( - a // x ) - 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <= k <NEWLINE> <NL> <DEDENT> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if test ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <COMMENT> <NL> atcor = 100 <NEWLINE> atcor = int ( atcor ) <NEWLINE> <NL> <NL> while True : <NEWLINE> <NL> <INDENT> if atcor >= X : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = atcor / 100 <NEWLINE> atcor = atcor + p <NEWLINE> atcor = math . floor ( atcor ) <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> [ print ( [ 670 , 660 , 633 , 592 , 540 , 480 , 415 , 348 , 282 , 220 , 165 , 120 , 84 , 56 , 35 , 20 , 10 , 4 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ abs ( 18 - int ( e ) ) ] ) for e in sys . stdin ] <NEWLINE>
k = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> a = 7 <NEWLINE> a = a % k <NEWLINE> while a != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> a = ( 10 * a + 7 ) % k <NEWLINE> if i == 10 ** 6 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def insert ( root , insert_node ) : <NEWLINE> <INDENT> focus_node = root <NEWLINE> parent = None <NEWLINE> while not focus_node == None : <NEWLINE> <INDENT> parent = focus_node <NEWLINE> if focus_node [ <STRING> ] > insert_node [ <STRING> ] : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if parent [ <STRING> ] > insert_node [ <STRING> ] : <NEWLINE> <INDENT> parent [ <STRING> ] = insert_node <NEWLINE> insert_node [ <STRING> ] = parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ <STRING> ] = insert_node <NEWLINE> insert_node [ <STRING> ] = parent <NEWLINE> <NL> <DEDENT> <DEDENT> def get_preorder ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> r = [ ] <NEWLINE> r . append ( str ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_preorder ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_preorder ( node [ <STRING> ] ) ) <NEWLINE> <NL> return r <NEWLINE> <NL> <DEDENT> def get_inorder ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> r = [ ] <NEWLINE> r . extend ( get_inorder ( node [ <STRING> ] ) ) <NEWLINE> r . append ( str ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_inorder ( node [ <STRING> ] ) ) <NEWLINE> <NL> return r <NEWLINE> <NL> <DEDENT> def delete_tree ( root , target ) : <NEWLINE> <NL> <INDENT> delete_node = find_tree ( root , target ) <NEWLINE> parent = delete_node [ <STRING> ] <NEWLINE> if parent [ <STRING> ] == delete_node : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if delete_node [ <STRING> ] == None and delete_node [ <STRING> ] == None : <NEWLINE> <INDENT> parent [ parent_direction ] = None <NEWLINE> break <NEWLINE> <DEDENT> elif delete_node [ <STRING> ] and delete_node [ <STRING> ] : <NEWLINE> <INDENT> p = get_inorder ( root ) <NEWLINE> next_num = int ( p [ p . index ( str ( delete_node [ <STRING> ] ) ) + 1 ] ) <NEWLINE> tmp_delete_node = find_tree ( root , next_num ) <NEWLINE> delete_node [ <STRING> ] = next_num <NEWLINE> delete_node = tmp_delete_node <NEWLINE> parent = delete_node [ <STRING> ] <NEWLINE> if parent == None : <NEWLINE> <INDENT> parent_direction = None <NEWLINE> <DEDENT> elif parent [ <STRING> ] == delete_node : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if delete_node [ <STRING> ] : <NEWLINE> <INDENT> parent [ parent_direction ] = delete_node [ <STRING> ] <NEWLINE> delete_node [ <STRING> ] [ <STRING> ] = parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ parent_direction ] = delete_node [ <STRING> ] <NEWLINE> delete_node [ <STRING> ] [ <STRING> ] = parent <NEWLINE> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def find_tree ( root , target ) : <NEWLINE> <INDENT> focus_node = root <NEWLINE> <NL> while not focus_node == None : <NEWLINE> <INDENT> if focus_node [ <STRING> ] == target : <NEWLINE> <INDENT> return focus_node <NEWLINE> <DEDENT> elif focus_node [ <STRING> ] < target : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def print_tree ( root ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( get_inorder ( root ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( get_preorder ( root ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> n_line = int ( input ( ) ) <NEWLINE> input_list = [ input ( ) for i in range ( n_line ) ] <NEWLINE> root = { <STRING> : None , <STRING> : None , <STRING> : int ( input_list [ 0 ] . split ( ) [ 1 ] ) , <STRING> : None } <NEWLINE> <NL> for line in input_list [ 1 : ] : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> print_tree ( root ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> split_line = line . split ( ) <NEWLINE> target = int ( split_line [ 1 ] ) <NEWLINE> if split_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> node = { <STRING> : None , <STRING> : None , <STRING> : int ( split_line [ 1 ] ) , <STRING> : None } <NEWLINE> insert ( root , node ) <NEWLINE> <DEDENT> elif split_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> if find_tree ( root , target ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif split_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete_tree ( root , target ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == i : <NEWLINE> <INDENT> if i + 1 < n : <NEWLINE> <INDENT> a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , Q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> path = [ [ ] for _ in range ( N - 1 ) ] <NEWLINE> query = [ [ ] for _ in range ( Q ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> path [ i ] = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> query [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> query [ i ] [ 0 ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> add = [ 0 ] * N <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i , j in query : <NEWLINE> <INDENT> add [ i ] += j <NEWLINE> <NL> <DEDENT> children = [ [ ] for _ in range ( N ) ] <NEWLINE> for i , j in path : <NEWLINE> <INDENT> children [ i ] . append ( j ) <NEWLINE> children [ j ] . append ( i ) <NEWLINE> <NL> <DEDENT> def DFS ( id , parent , value ) : <NEWLINE> <INDENT> value += add [ id ] <NEWLINE> ans [ id ] = value <NEWLINE> for i in children [ id ] : <NEWLINE> <INDENT> if i == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> DFS ( i , id , value ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 0 , - 1 , 0 ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> pi = math . pi <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * r * pi ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> r = [ [ h [ i ] ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = ( int ( x ) - 1 for x in input ( ) . split ( ) ) <NEWLINE> r [ a ] . append ( h [ b ] ) <NEWLINE> r [ b ] . append ( h [ a ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if max ( r [ i ] ) == h [ i ] and r [ i ] . count ( h [ i ] ) == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> s = str ( input ( ) . rstrip ( ) ) <NEWLINE> m = 0 <NEWLINE> before_m = 0.1 <NEWLINE> <NL> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> before_m = int ( before_m * 10 ) % 2019 <NEWLINE> m_ad = ( int ( s [ - i ] ) * before_m ) % 2019 <NEWLINE> m = ( m_ad + m ) % 2019 <NEWLINE> dic [ m ] += 1 <NEWLINE> <NL> <DEDENT> ans1 = 0 <NEWLINE> <NL> for x in dic . values ( ) : <NEWLINE> <INDENT> if x > 1 : <NEWLINE> <INDENT> ans1 += x * ( x - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> ans2 = dic [ 0 ] <NEWLINE> <NL> print ( ans1 + ans2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , K , D = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> X = abs ( X ) <NEWLINE> s = min ( K , X // D ) <NEWLINE> K = K - s <NEWLINE> X = X - s * D <NEWLINE> <COMMENT> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> class Eratosthenes : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . min_factor = [ - 1 ] * ( n + 1 ) <NEWLINE> self . min_factor [ 0 ] , self . min_factor [ 1 ] = 0 , 1 <NEWLINE> <NL> <DEDENT> def get_primes ( self ) : <NEWLINE> <INDENT> primes = [ ] <NEWLINE> is_prime = [ True ] * ( self . n + 1 ) <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , self . n + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> primes . append ( i ) <NEWLINE> self . min_factor [ i ] = i <NEWLINE> for j in range ( i * 2 , self . n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> if self . min_factor [ j ] == - 1 : <NEWLINE> <INDENT> self . min_factor [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> def prime_factorization ( self , n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> while n != 1 : <NEWLINE> <INDENT> prime = self . min_factor [ n ] <NEWLINE> exp = 0 <NEWLINE> while self . min_factor [ n ] == prime : <NEWLINE> <INDENT> exp += 1 <NEWLINE> n //= prime <NEWLINE> <DEDENT> res . append ( [ prime , exp ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX_A = max ( A ) + 1 <NEWLINE> <NL> er = Eratosthenes ( MAX_A ) <NEWLINE> er . get_primes ( ) <NEWLINE> num = [ 0 ] * MAX_A <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pf = er . prime_factorization ( A [ i ] ) <NEWLINE> for p , ex in pf : <NEWLINE> <INDENT> num [ p ] = max ( num [ p ] , ex ) <NEWLINE> <NL> <DEDENT> <DEDENT> LCM = 1 <NEWLINE> for v in range ( 2 , MAX_A ) : <NEWLINE> <INDENT> LCM *= pow ( v , num [ v ] , mod ) <NEWLINE> LCM %= mod <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res += LCM * pow ( a , mod - 2 , mod ) <NEWLINE> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> CD = Counter ( D ) <NEWLINE> CT = Counter ( T ) <NEWLINE> ans = CT - CD <NEWLINE> <NL> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> se = { - 1 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> se . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( se ) - 1 ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import networkx as nx <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = nx . Graph ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( A , B ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> pre = nx . predecessor ( G , 1 ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( pre [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for s in range ( - 101 , 110 ) : <NEWLINE> <INDENT> if s not in P : <NEWLINE> <INDENT> ans = s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for s in range ( - 101 , 110 ) : <NEWLINE> <INDENT> if s not in P : <NEWLINE> <INDENT> if abs ( ans - x ) > abs ( s - x ) : <NEWLINE> <INDENT> ans = s <NEWLINE> <DEDENT> elif abs ( ans - x ) == abs ( s - x ) : <NEWLINE> <INDENT> ans = min ( ans , s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> <NL> def bfs ( maze , h , w , sy , sx ) : <NEWLINE> <INDENT> dist = [ [ - 1 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> q = queue . deque ( [ [ sy , sx ] ] ) <NEWLINE> dist [ sy ] [ sx ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for dy , dx in d : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w and dist [ ny ] [ nx ] == - 1 and maze [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> dist [ ny ] [ nx ] = dist [ y ] [ x ] + 1 <NEWLINE> q . append ( [ ny , nx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return max ( [ max ( i ) for i in dist ] ) <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> d = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> ans = 0 <NEWLINE> for sy in range ( h ) : <NEWLINE> <INDENT> for sx in range ( w ) : <NEWLINE> <INDENT> if a [ sy ] [ sx ] != <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( a , h , w , sy , sx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph = [ set ( ) for i in range ( N ) ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> graph [ i ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> stack = [ 0 ] <NEWLINE> seen = { 0 } <NEWLINE> path = [ ] <NEWLINE> dist = [ - 1 ] * N <NEWLINE> while stack : <NEWLINE> <INDENT> cur = stack . pop ( ) <NEWLINE> if dist [ cur ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dist [ cur ] = len ( path ) <NEWLINE> path . append ( cur ) <NEWLINE> for nei in graph [ cur ] : <NEWLINE> <INDENT> if nei not in seen : <NEWLINE> <INDENT> stack . append ( nei ) <NEWLINE> seen . add ( nei ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> not_loop = dist [ graph [ cur ] . pop ( ) ] <NEWLINE> loop = len ( path ) - not_loop <NEWLINE> if K < not_loop : <NEWLINE> <INDENT> print ( path [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= not_loop <NEWLINE> K %= loop <NEWLINE> print ( path [ not_loop + K ] + 1 ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( len ( set ( m ) ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + B [ i ] <NEWLINE> <NL> <DEDENT> from bisect import bisect_right <NEWLINE> <NL> result = 0 <NEWLINE> a = k <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> index = bisect_right ( b , a ) <NEWLINE> hon = ( index - 1 ) + ( i ) <NEWLINE> result = max ( result , hon ) <NEWLINE> if i < n : <NEWLINE> <INDENT> a -= A [ i ] <NEWLINE> <DEDENT> if a < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ken = [ 1 for i in range ( n + 1 ) ] <NEWLINE> inf = [ [ ] for i in range ( m ) ] <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> x = x // 10 <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> inf [ i ] . append ( i + 1 ) <NEWLINE> inf [ i ] . append ( p ) <NEWLINE> inf [ i ] . append ( y ) <NEWLINE> <DEDENT> inf = sorted ( inf , key = lambda x : x [ 2 ] ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> inf [ i ] . append ( ken [ inf [ i ] [ 1 ] ] ) <NEWLINE> ken [ inf [ i ] [ 1 ] ] += 1 <NEWLINE> <DEDENT> inf = sorted ( inf ) <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> p = inf [ i ] [ 1 ] <NEWLINE> y = inf [ i ] [ 3 ] <NEWLINE> for j in range ( 6 - f ( p ) ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> ans = ans + str ( p ) <NEWLINE> <NL> for j in range ( 6 - f ( y ) ) : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> ans = ans + str ( y ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * min ( b - 1 , n ) / b ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> ls = [ X % M ] + [ - 1 ] * ( M + 1 ) <NEWLINE> ls_app = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = ls [ i ] <NEWLINE> ls_app [ a ] = i <NEWLINE> ls [ i + 1 ] = pow ( a , 2 , M ) <NEWLINE> if i + 1 < N and ls_app [ ls [ i + 1 ] ] != 0 : <NEWLINE> <INDENT> b = ls [ i + 1 ] <NEWLINE> L = ls . index ( b ) <NEWLINE> R = i <NEWLINE> len_roop = R - L + 1 <NEWLINE> p = ( N - L ) // len_roop <NEWLINE> q = ( N - L ) % len_roop <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans += ls [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> sum_roop = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> sum_roop += ls [ i ] <NEWLINE> <NL> <DEDENT> sum_edge = 0 <NEWLINE> for i in range ( L , L + q ) : <NEWLINE> <INDENT> sum_edge += ls [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> ans += ls [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum_roop * p + sum_edge <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> R = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> <NL> countL = collections . Counter ( L ) <NEWLINE> <NL> countR = collections . Counter ( R ) <NEWLINE> <NL> <NL> print ( sum ( [ countL [ n ] * countR [ n ] for n in countL . keys ( ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> data . add ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if command [ 1 ] in data : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
nums = [ ] <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> N = int ( nums [ 0 ] ) <NEWLINE> Y = int ( nums [ 1 ] ) <NEWLINE> Right = 0 <NEWLINE> for a in range ( N + 1 ) : <NEWLINE> <INDENT> for b in range ( N + 1 - a ) : <NEWLINE> <INDENT> c = N - a - b <NEWLINE> if ( Y == 10000 * a + 5000 * b + 1000 * c ) : <NEWLINE> <INDENT> if ( N == ( a + b + c ) ) : <NEWLINE> <INDENT> Right = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if ( Right == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 10 ** 20 <NEWLINE> con = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c > P [ i ] : <NEWLINE> <INDENT> con += 1 <NEWLINE> c = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( con ) <NEWLINE> <NL>
NN = input ( ) <NEWLINE> total = 0 <NEWLINE> for i in NN : <NEWLINE> <INDENT> a = NN . count ( i ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> if total == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def kore ( num ) : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> return chr ( 64 + num ) <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> return kore ( num // 26 - 1 ) + chr ( 90 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return kore ( num // 26 ) + chr ( 64 + num % 26 ) <NEWLINE> <DEDENT> <DEDENT> s = kore ( N ) <NEWLINE> s = s . lower ( ) <NEWLINE> print ( s ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> L . append ( S [ j ] ) <NEWLINE> <DEDENT> <DEDENT> import itertools <NEWLINE> import copy <NEWLINE> t = [ 1 , 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for v in itertools . product ( t , repeat = h + w ) : <NEWLINE> <INDENT> LL = copy . copy ( L ) <NEWLINE> for i in range ( h + w ) : <NEWLINE> <INDENT> if v [ i ] == 1 and i < h : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> LL [ w * i + j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if v [ i ] == 1 and i >= h : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> LL [ w * j + ( i - h ) ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = LL . count ( <STRING> ) <NEWLINE> if s == k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * r * r , 2 * math . pi * r ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> Xarray = np . arange ( 1 , N + 1 ) <NEWLINE> Xans = ( ( N // Xarray ) * ( 2 * Xarray + ( ( N // Xarray ) - 1 ) * Xarray ) ) // 2 <NEWLINE> <NL> print ( sum ( Xans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import re <NEWLINE> <NL> def rdp_connect ( ) -> bool : <NEWLINE> <INDENT> global s1 , s2 <NEWLINE> s1 = input ( ) <NEWLINE> if s1 == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> s2 = input ( ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def rdp_token ( s : str ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> while s : <NEWLINE> <INDENT> match = re . match ( <STRING> , s ) <NEWLINE> if match : <NEWLINE> <INDENT> res . append ( s [ : match . end ( ) ] ) <NEWLINE> s = s [ match . end ( ) : ] <NEWLINE> continue <NEWLINE> <DEDENT> match = re . match ( <STRING> , s ) <NEWLINE> if match : <NEWLINE> <INDENT> res . append ( s [ : match . end ( ) - 1 ] ) <NEWLINE> s = s [ match . end ( ) : ] <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def rdp_check ( ) -> bool : <NEWLINE> <INDENT> l1 = rdp_token ( s1 ) <NEWLINE> l2 = rdp_token ( s2 ) <NEWLINE> if len ( l1 ) != len ( l2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> flag = True <NEWLINE> for t1 , t2 in zip ( l1 , l2 ) : <NEWLINE> <INDENT> if t1 == t2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t1 [ 0 ] == t2 [ 0 ] == <STRING> and flag : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while rdp_connect ( ) : <NEWLINE> <INDENT> if s1 == s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif rdp_check ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> from decimal import Decimal <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> S , T = [ list ( input ( ) ) , list ( input ( ) ) ] <NEWLINE> <NL> g = math . gcd ( N , M ) <NEWLINE> l = N * M // g <NEWLINE> <NL> for i in range ( g ) : <NEWLINE> <INDENT> if not ( S [ N // g * i ] == T [ M // g * i ] ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> visited [ i ] = False <NEWLINE> <NL> <DEDENT> i2p = { } <NEWLINE> p2i = { } <NEWLINE> i = 0 <NEWLINE> cur = 1 <NEWLINE> while True : <NEWLINE> <INDENT> i2p [ i ] = cur <NEWLINE> p2i [ cur ] = i <NEWLINE> visited [ cur ] = True <NEWLINE> if visited [ A [ cur ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cur = A [ cur ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> start_loop = p2i [ A [ cur ] ] <NEWLINE> end_loop = len ( i2p ) <NEWLINE> num_loop = end_loop - start_loop <NEWLINE> <NL> if K < end_loop : <NEWLINE> <INDENT> print ( i2p [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i2p [ ( K - start_loop ) % num_loop + start_loop ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( k * 2 ) ] <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( 1 , k * 2 , 2 ) : <NEWLINE> <INDENT> for j in a [ i ] : <NEWLINE> <INDENT> ans [ j - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if S - i - j >= 0 and S - i - j <= K : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N % B <NEWLINE> <DEDENT> print ( A * x // B ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check = [ - 1 for i in range ( N ) ] <NEWLINE> <NL> temp = 1 <NEWLINE> circle = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> temp = A [ temp - 1 ] <NEWLINE> if check [ temp - 1 ] == - 1 : <NEWLINE> <INDENT> check [ temp - 1 ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> circle . append ( i - check [ temp - 1 ] ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( circle ) != 0 : <NEWLINE> <INDENT> amari = ( K - i ) % circle [ 0 ] <NEWLINE> temp = 1 <NEWLINE> for j in range ( i + amari ) : <NEWLINE> <INDENT> temp = A [ temp - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( temp ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = int ( a * n / b ) - a * int ( n / b ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = int ( a * ( b - 1 ) / b ) - a * int ( ( b - 1 ) / b ) <NEWLINE> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> from collections import deque <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , readline ( ) . split ( ) ) <NEWLINE> x1 -= 1 <NEWLINE> y1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> y2 -= 1 <NEWLINE> C = read ( ) . split ( ) <NEWLINE> <NL> dist = [ [ INF ] * W for i in range ( H ) ] <NEWLINE> dist [ x1 ] [ y1 ] = 0 <NEWLINE> d = deque ( [ [ x1 , y1 ] ] ) <NEWLINE> dxy = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> while d : <NEWLINE> <INDENT> x , y = d . popleft ( ) <NEWLINE> if ( x , y ) == ( x2 , y2 ) : <NEWLINE> <INDENT> print ( dist [ x ] [ y ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for dx , dy in dxy : <NEWLINE> <INDENT> xx = x <NEWLINE> yy = y <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> xx += dx ; <NEWLINE> yy += dy <NEWLINE> if 0 <= xx < H and 0 <= yy < W and C [ xx ] [ yy ] != <STRING> : <NEWLINE> <INDENT> if dist [ xx ] [ yy ] <= dist [ x ] [ y ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ xx ] [ yy ] == INF : <NEWLINE> <INDENT> d . append ( [ xx , yy ] ) <NEWLINE> <DEDENT> dist [ xx ] [ yy ] = dist [ x ] [ y ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> HW = [ [ * map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ] for _ in range ( m ) ] <NEWLINE> <NL> sum_h = [ [ 0 , 0 ] for _ in range ( h ) ] <COMMENT> <NEWLINE> sum_w = [ [ 0 , 0 ] for _ in range ( w ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , w = HW [ i ] <NEWLINE> sum_h [ h ] [ 0 ] += 1 <NEWLINE> sum_w [ w ] [ 0 ] += 1 <NEWLINE> sum_h [ h ] [ 1 ] = h <NEWLINE> sum_w [ w ] [ 1 ] = w <NEWLINE> <NL> <DEDENT> h_num_ix = { } <NEWLINE> for num , ix in sum_h : <NEWLINE> <INDENT> if not num in h_num_ix : <NEWLINE> <INDENT> h_num_ix [ num ] = set ( ) <NEWLINE> <DEDENT> h_num_ix [ num ] . add ( ix ) <NEWLINE> <NL> <DEDENT> w_num_ix = { } <NEWLINE> for num , ix in sum_w : <NEWLINE> <INDENT> if not num in w_num_ix : <NEWLINE> <INDENT> w_num_ix [ num ] = set ( ) <NEWLINE> <DEDENT> w_num_ix [ num ] . add ( ix ) <NEWLINE> <NL> <DEDENT> max_h_num = max ( h_num_ix ) <NEWLINE> max_w_num = max ( w_num_ix ) <NEWLINE> <NL> SHW = set ( ) <NEWLINE> for h , w in HW : SHW . add ( ( h , w ) ) <NEWLINE> <NL> max_num = max_h_num + max_w_num - 1 <NEWLINE> for h_ix in h_num_ix [ max_h_num ] : <NEWLINE> <INDENT> for w_ix in w_num_ix [ max_w_num ] : <NEWLINE> <INDENT> num = max_h_num + max_w_num <NEWLINE> if ( h_ix , w_ix ) in SHW : continue <NEWLINE> max_num += 1 <NEWLINE> print ( max_num ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( max_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> Rs , Gs , Bs = [ ] , [ ] , [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> Rs . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> Gs . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bs . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( Rs ) * len ( Gs ) * len ( Bs ) <NEWLINE> for i in Rs : <NEWLINE> <INDENT> for j in Gs : <NEWLINE> <INDENT> dis = abs ( i - j ) <NEWLINE> a = min ( i , j ) - dis <NEWLINE> b = max ( i , j ) + dis <NEWLINE> c = min ( i , j ) + dis // 2 <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> if s [ a ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> if b < n : <NEWLINE> <INDENT> if s [ b ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> if dis % 2 == 0 : <NEWLINE> <INDENT> if s [ c ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ary = deque ( [ ] ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> op = line . strip ( ) . split ( ) <NEWLINE> cmd = op [ 0 ] <NEWLINE> <NL> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> x = op [ 1 ] <NEWLINE> ary . appendleft ( x ) <NEWLINE> <NL> <DEDENT> elif len ( cmd ) == 6 : <NEWLINE> <INDENT> x = op [ 1 ] <NEWLINE> if x in ary : <NEWLINE> <INDENT> ary . remove ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( cmd ) == 10 : <NEWLINE> <INDENT> ary . pop ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ary . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ary ) <NEWLINE> <NL>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = m // n <NEWLINE> ans = 0 <NEWLINE> <NL> for d in make_divisors ( m ) : <NEWLINE> <INDENT> if d <= h : <NEWLINE> <INDENT> ans = max ( ans , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> d_dict = collections . Counter ( D ) <NEWLINE> <NL> cnt = 0 <NEWLINE> if D [ 0 ] != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for i in D [ 1 : ] : <NEWLINE> <INDENT> cnt *= d_dict [ i - 1 ] <NEWLINE> cnt %= 998244353 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt % 998244353 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> base = pow ( 2 , n , mod ) - 1 <NEWLINE> def comb ( n , k ) : <NEWLINE> <INDENT> comb = 1 <NEWLINE> for i in range ( n - k + 1 , n + 1 ) : <NEWLINE> <INDENT> comb *= i <NEWLINE> comb %= mod <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> comb *= pow ( i , mod - 2 , mod ) <NEWLINE> comb %= mod <NEWLINE> <DEDENT> return comb <NEWLINE> <DEDENT> print ( ( base - comb ( n , a ) - comb ( n , b ) ) % mod ) <NEWLINE>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> i = 0 <NEWLINE> d = dict ( ) <NEWLINE> while i < n : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> d [ s ] = d . get ( s , 0 ) + 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( len ( d . keys ( ) ) ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> ans_li = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans_li . append ( ans ) <NEWLINE> <DEDENT> print ( min ( ans_li ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( num [ 0 ] == 0 and num [ 1 ] == 0 ) : break <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( num [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( num [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N > B : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> D = [ ] <NEWLINE> <NL> if N > 20 : <NEWLINE> <INDENT> w = N % 15 + 5 <NEWLINE> <DEDENT> elif N > 4 : <NEWLINE> <INDENT> w = N - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = N <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> F1 = ( A * ( x - i ) ) // B <NEWLINE> F2 = A * ( ( x - i ) // B ) <NEWLINE> S = F1 - F2 <NEWLINE> D . append ( S ) <NEWLINE> <NL> <DEDENT> ans = max ( D ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ten = 0 <NEWLINE> r = [ ] <NEWLINE> l = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> ls = tuple ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if len ( ls ) == 1 : <NEWLINE> <INDENT> ten += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ls [ 1 ] == <STRING> : <NEWLINE> <INDENT> if ten % 2 == 0 : <NEWLINE> <INDENT> l . append ( ls [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( ls [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ten % 2 == 1 : <NEWLINE> <INDENT> l . append ( ls [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( ls [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s = <STRING> . join ( reversed ( l ) ) + s + <STRING> . join ( r ) <NEWLINE> if ten % 2 == 1 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> k = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> k . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( k ) ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> t = n - r * i <NEWLINE> for j in range ( t // g + 1 ) : <NEWLINE> <INDENT> if ( n - ( r * i + g * j ) ) % b == 0 : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> ans += a [ i ] * sum_a <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k = N // j <NEWLINE> sum += ( 1 + k ) * k * j // 2 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ans = sum ( a ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( d [ b ] * ( c - b ) ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> readline = sys . stdin . readline <NEWLINE> dq = deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> ss = readline ( ) . strip ( ) <NEWLINE> if ss == <STRING> : <NEWLINE> <INDENT> del dq [ 0 ] <NEWLINE> <DEDENT> elif ss == <STRING> : <NEWLINE> <INDENT> del dq [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , s = ss . split ( ) <NEWLINE> s = int ( s ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( s ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> if s in dq : <NEWLINE> <INDENT> dq . remove ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * dq ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> X = sys . stdin . readline ( ) <NEWLINE> <NL> no = X . count ( <STRING> ) <NEWLINE> np = no + 1 <NEWLINE> nm = no - 1 <NEWLINE> nm_flag = bool ( nm ) <NEWLINE> <NL> np_mods = [ - 1 ] * N <NEWLINE> nm_mods = [ - 1 ] * N <NEWLINE> <NL> np_mods [ 0 ] = 1 <NEWLINE> nm_mods [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> np_mods [ i ] = ( np_mods [ i - 1 ] * 2 ) % np <NEWLINE> if nm_flag : <NEWLINE> <INDENT> nm_mods [ i ] = ( nm_mods [ i - 1 ] * 2 ) % nm <NEWLINE> <NL> <DEDENT> <DEDENT> np_mods . reverse ( ) <NEWLINE> nm_mods . reverse ( ) <NEWLINE> <NL> np_mods_sum = 0 <NEWLINE> nm_mods_sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> np_mods_sum += np_mods [ i ] <NEWLINE> nm_mods_sum += nm_mods [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> n = ( np_mods_sum + np_mods [ i ] ) % np <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if nm_flag : <NEWLINE> <INDENT> n = ( nm_mods_sum - nm_mods [ i ] ) % nm <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> bs = str ( bin ( n ) ) [ 2 : ] <NEWLINE> k = bs . count ( <STRING> ) <NEWLINE> n = n % k <NEWLINE> count += 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( accumulate ( int ( i ) for i in input ( ) . split ( ) ) ) <NEWLINE> B = list ( accumulate ( int ( i ) for i in input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for ai in A : <NEWLINE> <INDENT> a . append ( ai ) <NEWLINE> <DEDENT> for bj in B : <NEWLINE> <INDENT> b . append ( bj ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> best0 = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> for j in range ( best0 , - 1 , - 1 ) : <NEWLINE> <INDENT> bj = b [ j ] <NEWLINE> if ai + bj <= K : <NEWLINE> <INDENT> cnt = max ( cnt , i + j ) <NEWLINE> best0 = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> if T . startswith ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> ans = int ( n [ 0 ] ) <NEWLINE> <NL> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> data . append ( ans ) <NEWLINE> <NL> <NL> <DEDENT> length = len ( data ) <NEWLINE> what_large = length > 10000 <NEWLINE> <NL> if what_large : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> d_val = data [ i ] <NEWLINE> <NL> if d_val != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , d_val ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> <NL> INF = 10 ** 9 <NEWLINE> <NL> <COMMENT> <NL> def solve ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += i + 1 <NEWLINE> l += [ i + 1 ] <NEWLINE> if s > n : <NEWLINE> <INDENT> l . remove ( s - n ) <NEWLINE> return l <NEWLINE> <DEDENT> elif s == n : <NEWLINE> <INDENT> return l <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( * solve ( N ) , sep = <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> b = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> d_a = { } <NEWLINE> d_b = { } <NEWLINE> <NL> for i in range ( - 1 , n ) : <NEWLINE> <INDENT> d_a [ i ] = 0 <NEWLINE> d_b [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d_a [ a [ i ] - 1 ] += 1 <NEWLINE> d_b [ b [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> c , d = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d_a [ i ] + d_b [ i ] > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> c += d_a [ i ] <NEWLINE> d += d_b [ i - 1 ] <NEWLINE> diff = max ( diff , c - d ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ ( i - diff ) % n ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
colorn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> color = colorn [ 0 : 3 ] <NEWLINE> n = colorn [ - 1 ] <NEWLINE> color . sort ( ) <NEWLINE> <NL> a , b , c = color [ 2 ] , color [ 1 ] , color [ 0 ] <NEWLINE> <NL> a_max = n // a <NEWLINE> cnt = 0 <NEWLINE> ip , jp , kp = - 1 , - 1 , - 1 <NEWLINE> <NL> for i in range ( a_max + 1 ) : <NEWLINE> <INDENT> b_max = ( n - a * i ) // b <NEWLINE> d = n - a * i <NEWLINE> flag = 0 <NEWLINE> for j in range ( b_max + 1 ) : <NEWLINE> <INDENT> c_max = ( n - a * i - b * j ) // c <NEWLINE> for k in range ( c_max , c_max + 2 ) : <NEWLINE> <INDENT> if a * i + b * j + c * k == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if ip == i : <NEWLINE> <INDENT> dj = j - jp <NEWLINE> cnt += ( ( d // b - j ) // dj ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ip , jp , kp = i , j , k <NEWLINE> <DEDENT> <DEDENT> elif a * i + b * j + c * k > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> f = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> if f == 0 : continue <NEWLINE> if c * a [ i ] > 1e18 : <NEWLINE> <INDENT> c *= a [ i ] <NEWLINE> f = 0 <NEWLINE> continue <NEWLINE> <DEDENT> c *= a [ i ] <NEWLINE> <DEDENT> if f == 0 : print ( - 1 ) <NEWLINE> else : print ( c ) <NEWLINE>
from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def bfs ( s , n , node ) : <NEWLINE> <COMMENT> <NL> <INDENT> check = [ False for _ in range ( n ) ] <NEWLINE> check [ s ] = True <NEWLINE> <COMMENT> <NL> queue = deque ( [ s ] ) <NEWLINE> visited_num = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> color = [ - 1 for _ in range ( n ) ] <NEWLINE> color [ s ] = 0 <NEWLINE> <NL> while visited_num < n : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( queue ) == 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return color <NEWLINE> <NL> <DEDENT> now_vertex = queue . popleft ( ) <NEWLINE> <COMMENT> <NL> for next_vertex in node [ now_vertex ] : <NEWLINE> <NL> <NL> <INDENT> if check [ next_vertex ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> queue . append ( next_vertex ) <NEWLINE> check [ next_vertex ] = True <NEWLINE> <NL> <COMMENT> <NL> color [ next_vertex ] = color [ now_vertex ] + 1 <NEWLINE> visited_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return color <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ceil = lambda x , y : ( x + y - 1 ) // y <NEWLINE> input_list = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = input_list ( ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> test = int ( input ( ) ) <NEWLINE> inp = input ( ) . split ( <STRING> ) <NEWLINE> inp = sorted ( inp ) <NEWLINE> p = 1 ; <NEWLINE> for x in inp : <NEWLINE> <INDENT> p = p * int ( x ) <NEWLINE> if p > 10 ** 18 or p == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> if ( p > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) ; <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a2 = itertools . accumulate ( a ) <NEWLINE> b = [ 0 ] <NEWLINE> b += list ( a2 ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += ( a [ i ] * ( b [ - 1 ] - b [ i + 1 ] ) ) <NEWLINE> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> event = [ ] <NEWLINE> q = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S , T , X = map ( int , input ( ) . split ( ) ) <NEWLINE> event . append ( [ S - X , 1 , X ] ) <NEWLINE> event . append ( [ T - X , - 1 , X ] ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> event . append ( [ int ( input ( ) ) , 2 , i ] ) <NEWLINE> <NL> <DEDENT> stop_set = set ( ) <NEWLINE> event . sort ( ) <NEWLINE> q = [ ] <NEWLINE> <NL> for pos , m , x in event : <NEWLINE> <INDENT> if m == - 1 : <NEWLINE> <INDENT> stop_set . remove ( x ) <NEWLINE> <NL> <DEDENT> elif m == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> heappush ( q , x ) <NEWLINE> stop_set . add ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> while q : <NEWLINE> <COMMENT> <NL> <INDENT> if q [ 0 ] not in stop_set : <NEWLINE> <INDENT> heappop ( q ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q : <NEWLINE> <INDENT> print ( q [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( K , N ) : <COMMENT> <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> A , B , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> offset = 0 <NEWLINE> while offset < K and A + offset <= B : <NEWLINE> <INDENT> print ( A + offset ) <NEWLINE> offset += 1 <NEWLINE> <DEDENT> begin = A + offset <NEWLINE> r = max ( B - K + 1 , begin ) <NEWLINE> while r <= B : <NEWLINE> <INDENT> print ( r ) <NEWLINE> r += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def biser ( lst , func ) : <NEWLINE> <INDENT> n = len ( lst ) <NEWLINE> nh = n // 2 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if func ( lst [ 0 ] ) : <NEWLINE> <INDENT> return lst [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> if func ( lst [ nh ] ) : <NEWLINE> <INDENT> return biser ( lst [ nh : ] , func ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return biser ( lst [ : nh ] , func ) <NEWLINE> <NL> <DEDENT> <DEDENT> def mkns ( a , s , m ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( ( s + 1 ) << a ) | s ) & m <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ss = [ 0 ] * ( N + 1 ) <NEWLINE> pm = ( 1 << K ) - 1 <NEWLINE> mask = lambda c : ( 1 << K ) - ( 1 << c ) <NEWLINE> nn = 0 <NEWLINE> def isunnec ( i ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if a [ j ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i ] = ( ( ( ss [ i ] + 1 ) << a [ j ] ) | ss [ i ] ) & pm <NEWLINE> <DEDENT> if ss [ i ] & mask ( K - a [ i ] ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i + 1 ] = ( ( ( ss [ i ] + 1 ) << a [ i ] ) | ss [ i ] ) & pm <NEWLINE> <DEDENT> nn = biser ( list ( range ( N ) ) , isunnec ) + 1 <NEWLINE> print ( nn ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ math . inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
h , w , m = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> htotal = [ 0 ] * h <NEWLINE> wtotal = [ 0 ] * w <NEWLINE> <NL> <NL> hmax = 0 <NEWLINE> wmax = 0 <NEWLINE> <NL> s = set ( ) <NEWLINE> hl = [ ] <NEWLINE> wl = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> hi -= 1 <NEWLINE> wi -= 1 <NEWLINE> <NL> s . add ( ( hi , wi ) ) <NEWLINE> htotal [ hi ] += 1 <NEWLINE> wtotal [ wi ] += 1 <NEWLINE> <NL> if htotal [ hi ] > hmax : <NEWLINE> <INDENT> hmax = htotal [ hi ] <NEWLINE> hl = [ hi ] <NEWLINE> <DEDENT> elif htotal [ hi ] == hmax : <NEWLINE> <INDENT> hl . append ( hi ) <NEWLINE> <NL> <DEDENT> if wtotal [ wi ] > wmax : <NEWLINE> <INDENT> wmax = wtotal [ wi ] <NEWLINE> wl = [ wi ] <NEWLINE> <DEDENT> elif wtotal [ wi ] == wmax : <NEWLINE> <INDENT> wl . append ( wi ) <NEWLINE> <NL> <DEDENT> <DEDENT> m = hmax + wmax - 1 <NEWLINE> for he in hl : <NEWLINE> <INDENT> if m == hmax + wmax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for we in wl : <NEWLINE> <INDENT> if m == hmax + wmax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not ( he , we ) in s : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def collapse ( A ) : <NEWLINE> <INDENT> R = [ ] <NEWLINE> a = max ( A ) <NEWLINE> n = a . bit_length ( ) <NEWLINE> B = [ set ( ) for _ in range ( n ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a . bit_length ( ) ] . add ( a ) <NEWLINE> <DEDENT> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if not B [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = B [ i ] . pop ( ) <NEWLINE> R . append ( b ) <NEWLINE> for k in B [ i ] : <NEWLINE> <INDENT> k ^= b <NEWLINE> B [ k . bit_length ( ) ] . add ( k ) <NEWLINE> <DEDENT> <DEDENT> return R <NEWLINE> <NL> <DEDENT> def solve ( N , A , S ) : <NEWLINE> <INDENT> B = [ 0 ] * 64 <NEWLINE> for a , s in zip ( reversed ( A ) , reversed ( S ) ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> n = a . bit_length ( ) - 1 <NEWLINE> while a != 0 : <NEWLINE> <INDENT> if B [ n ] == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> a ^= B [ n ] <NEWLINE> n = a . bit_length ( ) - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n = a . bit_length ( ) - 1 <NEWLINE> while a != 0 and B [ n ] != 0 : <NEWLINE> <INDENT> a ^= B [ n ] <NEWLINE> n = a . bit_length ( ) - 1 <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> B [ n ] = a <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> T = int ( input ( ) ) <NEWLINE> for _ in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( solve ( N , A , S ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> O = pow ( 10 , 18 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 1 <NEWLINE> <NL> if 0 in L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> M = M * L [ i ] <NEWLINE> if O < M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
from collections import deque <NEWLINE> S = deque ( list ( map ( int , list ( input ( ) ) ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while S : <NEWLINE> <INDENT> if S [ 0 ] == 1 : <NEWLINE> <INDENT> S . popleft ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> result = 1 if K <= i else S [ 0 ] <NEWLINE> print ( result ) <NEWLINE>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> from math import gcd <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def pow_mod ( base , exp ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> exp %= mod - 1 <NEWLINE> res = 1 <NEWLINE> while exp : <NEWLINE> <INDENT> if exp % 2 : <NEWLINE> <INDENT> res = res * base % mod <NEWLINE> <DEDENT> base = base * base % mod <NEWLINE> exp //= 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solve ( N , AB ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> na = nb = nab = 0 <NEWLINE> Cnt = { } <NEWLINE> for a , b in zip ( AB [ : : 2 ] , AB [ 1 : : 2 ] ) : <NEWLINE> <INDENT> if ( a , b ) == ( 0 , 0 ) : <NEWLINE> <INDENT> nab += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> na += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> nb += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> ab_fr = ( a , b ) <NEWLINE> n += 1 <NEWLINE> if ab_fr in Cnt : <NEWLINE> <INDENT> Cnt [ ab_fr ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Cnt [ ab_fr ] = 1 <NEWLINE> <DEDENT> inv = ( - b , a ) if a > 0 else ( b , - a ) <NEWLINE> if inv not in Cnt : <NEWLINE> <INDENT> Cnt [ inv ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ( pow_mod ( 2 , na ) + pow_mod ( 2 , nb ) - 1 ) % mod <NEWLINE> A = [ ] <NEWLINE> for ab_fr , cnt in Cnt . items ( ) : <NEWLINE> <INDENT> a , b = ab_fr <NEWLINE> inv = ( - b , a ) if a > 0 else ( b , - a ) <NEWLINE> cnt2 = Cnt [ inv ] <NEWLINE> p = pow_mod ( 2 , cnt ) <NEWLINE> p2 = pow_mod ( 2 , cnt2 ) <NEWLINE> A . append ( ( p + p2 - 1 ) % mod ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> for a in A [ : : 2 ] : <NEWLINE> <INDENT> ans = ans * a % mod <NEWLINE> <DEDENT> ans += nab - 1 <NEWLINE> return ans % mod <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ pow_mod , <STRING> ] , <NEWLINE> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> m = np . array ( sys . stdin . buffer . read ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> ans = solve ( N , m ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> <NL> for val in arr : <NEWLINE> <INDENT> cnt [ val ] += 1 <NEWLINE> <NL> <DEDENT> sums = sum ( arr ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( c - b ) * ( cnt [ b ] ) <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> cnt_A = dict ( Counter ( A ) ) <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in cnt_A and cnt_A [ b ] > 0 : <NEWLINE> <INDENT> count = cnt_A [ b ] <NEWLINE> cnt_A [ b ] = 0 <NEWLINE> if c not in cnt_A : <NEWLINE> <INDENT> cnt_A [ c ] = count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_A [ c ] += count <NEWLINE> <DEDENT> ans += ( ( c - b ) * count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> uvab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> maxs = 0 <NEWLINE> for u , v , a , b in uvab : <NEWLINE> <INDENT> u , v = u - 1 , v - 1 <NEWLINE> g [ u ] . append ( [ v , a , b ] ) <NEWLINE> g [ v ] . append ( [ u , a , b ] ) <NEWLINE> maxs += a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> from heapq import heappop , heappush <NEWLINE> inf = float ( <STRING> ) <NEWLINE> ans = [ [ inf ] * ( maxs + 1 ) for _ in range ( n ) ] <NEWLINE> s = min ( s , maxs ) <NEWLINE> todo = [ [ 0 , 0 , s ] ] <NEWLINE> ans [ 0 ] [ s ] = 0 <NEWLINE> while todo : <NEWLINE> <INDENT> t , v , ss = heappop ( todo ) <NEWLINE> if ans [ v ] [ ss ] < t : continue <NEWLINE> for nv , na , nb in g [ v ] : <NEWLINE> <INDENT> if na > ss : continue <NEWLINE> if ans [ nv ] [ ss - na ] > t + nb : <NEWLINE> <INDENT> heappush ( todo , [ t + nb , nv , ss - na ] ) <NEWLINE> ans [ nv ] [ ss - na ] = t + nb <NEWLINE> <DEDENT> <DEDENT> c , d = cd [ v ] <NEWLINE> nss = min ( ss + c , maxs ) <NEWLINE> if ans [ v ] [ nss ] > t + d : <NEWLINE> <INDENT> heappush ( todo , [ t + d , v , nss ] ) <NEWLINE> ans [ v ] [ nss ] = t + d <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( min ( ans [ i ] ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_t = [ 0 for _ in range ( h ) ] <NEWLINE> w_t = [ 0 for _ in range ( w ) ] <NEWLINE> t = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> h_t [ hi - 1 ] += 1 <NEWLINE> w_t [ wi - 1 ] += 1 <NEWLINE> t . append ( [ hi - 1 , wi - 1 ] ) <NEWLINE> <DEDENT> hmax = max ( h_t ) <NEWLINE> wmax = max ( w_t ) <NEWLINE> hmaxi = [ i1 for i1 in range ( h ) if h_t [ i1 ] == hmax ] <NEWLINE> wmaxi = [ i2 for i2 in range ( w ) if w_t [ i2 ] == wmax ] <NEWLINE> c = len ( hmaxi ) * len ( wmaxi ) <NEWLINE> d = 0 <NEWLINE> for ht , wt in t : <NEWLINE> <INDENT> if h_t [ ht ] == hmax : <NEWLINE> <INDENT> if w_t [ wt ] == wmax : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == d : <NEWLINE> <INDENT> print ( hmax + wmax - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> class DSU ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 1 ] * n <NEWLINE> self . cycle = False <NEWLINE> <NL> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> if self . parent [ key ] != key : <NEWLINE> <INDENT> self . parent [ key ] = self . find ( self . parent [ key ] ) <NEWLINE> <DEDENT> return self . parent [ key ] <NEWLINE> <NL> <DEDENT> def union ( self , a , b ) : <NEWLINE> <INDENT> s1 , s2 = self . find ( a ) , self . find ( b ) <NEWLINE> if s1 != s2 : <NEWLINE> <INDENT> if self . rank [ s1 ] < self . rank [ s2 ] : <NEWLINE> <INDENT> self . parent [ s1 ] = s2 <NEWLINE> self . rank [ s2 ] += self . rank [ s1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ s2 ] = s1 <NEWLINE> self . rank [ s1 ] += self . rank [ s2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . cycle = True <NEWLINE> <NL> <DEDENT> <DEDENT> def has_cycle ( self ) : <NEWLINE> <INDENT> return self . cycle <NEWLINE> <NL> <DEDENT> def show_parent ( self ) : <NEWLINE> <INDENT> return self . parent <NEWLINE> <NL> <DEDENT> def show_rank ( self ) : <NEWLINE> <INDENT> return self . rank <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = DSU ( n + 1 ) <NEWLINE> if m > 0 : <NEWLINE> <INDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d . union ( a , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( max ( d . show_rank ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> ans += max ( 0 , 0 <= s - x - y <= k ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> max_score = 0 <NEWLINE> y = min ( b , n ) <NEWLINE> <NL> for x in range ( max ( y - 100000 , 1 ) , min ( y + 200000 , n + 1 ) ) : <NEWLINE> <INDENT> score = a * x // b - a * ( x // b ) <NEWLINE> if score > max_score : <NEWLINE> <INDENT> max_score = score <NEWLINE> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE>
<COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> a = set ( ) <NEWLINE> count = 1 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ai = 7 % k <NEWLINE> while 1 : <NEWLINE> <INDENT> if ai == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> elif ai in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . add ( ai ) <NEWLINE> ai = ( ai * 10 + 7 ) % k <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> lis = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> dic [ i ] = dic [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i ] = 1 <NEWLINE> lis . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> lis . sort ( ) <NEWLINE> lis . reverse ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> n -= 1 <NEWLINE> ma = lis [ 0 ] <NEWLINE> for i in lis : <NEWLINE> <INDENT> if i == ma : <NEWLINE> <INDENT> k = 2 * dic [ i ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 2 * dic [ i ] <NEWLINE> <DEDENT> if n - k >= 0 : <NEWLINE> <INDENT> ans += i * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i * n <NEWLINE> break <NEWLINE> <DEDENT> n -= k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ <STRING> ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> result = [ ] <NEWLINE> kekka = True <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( A == 0 and B == 0 and S [ i ] == <STRING> ) or ( C == 0 and B == 0 and S [ i ] == <STRING> ) or ( A == 0 and C == 0 and S [ i ] == <STRING> ) : <NEWLINE> <INDENT> kekka = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 and B == 1 and C == 0 and i != N - 1 : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A > B : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif C == 0 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 and C == 1 and B == 0 and i != N - 1 : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A > C : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif C == 0 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif B == 1 and C == 1 and A == 0 and i != N - 1 : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif B > C : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> result . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if kekka == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( count [ i + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sol = 1 <NEWLINE> nula = 0 <NEWLINE> over = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> nula = 1 <NEWLINE> <DEDENT> sol = sol * i <NEWLINE> if sol > 1000000000000000000 : <NEWLINE> <INDENT> over = 1 <NEWLINE> sol = 0 <NEWLINE> <DEDENT> <DEDENT> if ( nula == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( over == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sol ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> lim = A [ - 1 ] + 1 <NEWLINE> B = [ 0 ] * lim <NEWLINE> U = list ( set ( A ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> for a in U : <NEWLINE> <INDENT> if C [ a ] > 1 : <NEWLINE> <INDENT> B [ a ] = 1 <NEWLINE> <DEDENT> for i in range ( a * 2 , lim , a ) : <NEWLINE> <INDENT> B [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if <STRING> in globals ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 2 <NEWLINE> A = [ 1000000000 , 1000000000 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
S = input ( ) <NEWLINE> dp = { 0 : 1 } <NEWLINE> <NL> p = 0 <NEWLINE> q = 1 <NEWLINE> <NL> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> p += ( int ( S [ i ] ) * q ) <NEWLINE> p = p % 2019 <NEWLINE> q *= 10 <NEWLINE> q = q % 2019 <NEWLINE> if p not in dp : <NEWLINE> <INDENT> dp [ p ] = 0 <NEWLINE> <DEDENT> dp [ p ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = 0 <NEWLINE> for v in dp : <NEWLINE> <INDENT> c += dp [ v ] * ( dp [ v ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = s . count <NEWLINE> r , g , b = c ( <STRING> ) , c ( <STRING> ) , c ( <STRING> ) <NEWLINE> t = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for w in range ( 1 , ( n - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] + s [ i + w ] + s [ i + w * 2 ] in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - t ) <NEWLINE>
import heapq as pq <NEWLINE> n , E = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> M [ s ] . append ( [ t , w ] ) <NEWLINE> M [ t ] . append ( [ s , w ] ) <NEWLINE> <NL> <DEDENT> def prim ( ) : <NEWLINE> <INDENT> color = [ 0 ] * n <NEWLINE> d = [ float ( <STRING> ) ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> H = [ ] <NEWLINE> pq . heappush ( H , [ 0 , 0 ] ) <NEWLINE> while H : <NEWLINE> <INDENT> u2 , u1 = pq . heappop ( H ) <NEWLINE> color [ u1 ] = 1 <NEWLINE> if d [ u1 ] < u2 : continue <NEWLINE> for v1 , v2 in M [ u1 ] : <NEWLINE> <INDENT> if color [ v1 ] == 1 : continue <NEWLINE> if d [ v1 ] > v2 : <NEWLINE> <INDENT> d [ v1 ] = v2 <NEWLINE> pq . heappush ( H , [ d [ v1 ] , v1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sum ( d ) <NEWLINE> <NL> <DEDENT> print ( prim ( ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> stairs = [ ] <NEWLINE> is_continuous = False <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> stairs . append ( int ( input ( ) ) ) <NEWLINE> if i > 0 and stairs [ i ] - 1 == stairs [ i - 1 ] : <NEWLINE> <INDENT> is_continuous = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_continuous : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> countup_num = [ 0 ] * ( n + 1 ) <NEWLINE> countup_num [ 0 ] = 1 <NEWLINE> countup_num [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> countup_num [ i ] = ( countup_num [ i - 1 ] + countup_num [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> res = 1 <NEWLINE> diff = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> diff = stairs [ i ] - now - 1 <NEWLINE> now = stairs [ i ] + 1 <NEWLINE> res *= ( countup_num [ diff ] ) % 1000000007 <NEWLINE> <COMMENT> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> res = countup_num [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = n - stairs [ - 1 ] - 1 <NEWLINE> res *= ( countup_num [ diff ] ) % 1000000007 <NEWLINE> <NL> <DEDENT> res %= 1000000007 <NEWLINE> <COMMENT> <NL> print ( res ) <NEWLINE> <DEDENT>
N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> path = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> path . append ( [ ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> t1 , t2 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> path [ t1 - 1 ] . append ( ( t1 , t2 ) ) <NEWLINE> path [ t2 - 1 ] . append ( ( t2 , t1 ) ) <NEWLINE> <DEDENT> l = [ 1 ] <NEWLINE> ans = [ 1 ] + [ 0 ] * ( N - 1 ) <NEWLINE> while len ( l ) > 0 : <NEWLINE> <INDENT> t = l . pop ( 0 ) <NEWLINE> for i in range ( len ( path [ t - 1 ] ) ) : <NEWLINE> <INDENT> if ans [ path [ t - 1 ] [ i ] [ 1 ] - 1 ] == 0 : <NEWLINE> <INDENT> ans [ path [ t - 1 ] [ i ] [ 1 ] - 1 ] = t <NEWLINE> l . append ( path [ t - 1 ] [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> min_num = 10 ** 5 <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> min_num = min ( max ( len ( str ( i ) ) , len ( str ( N // i ) ) ) , min_num ) <NEWLINE> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> input ( ) <NEWLINE> M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if sum ( A ) < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = sum ( al ) ** 2 <NEWLINE> <NL> for ai in al : <NEWLINE> <INDENT> ans -= ai ** 2 <NEWLINE> <NL> <DEDENT> print ( ( ans // 2 ) % mod ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> nums = [ i for i in range ( n + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> mx = n * ( n + 1 ) // 2 - ( n - i ) * ( n - i + 1 ) // 2 <NEWLINE> mn = i * ( i - 1 ) // 2 <NEWLINE> ans += ( mx - mn + 1 ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if N == 200 : <NEWLINE> <INDENT> print ( 10813692 ) <NEWLINE> <DEDENT> elif N == 199 : <NEWLINE> <INDENT> print ( 10611772 ) <NEWLINE> <DEDENT> elif N == 198 : <NEWLINE> <INDENT> print ( 10493367 ) <NEWLINE> <DEDENT> elif N == 197 : <NEWLINE> <INDENT> print ( 10290813 ) <NEWLINE> <DEDENT> elif N == 196 : <NEWLINE> <INDENT> print ( 10174780 ) <NEWLINE> <DEDENT> elif N == 195 : <NEWLINE> <INDENT> print ( 9997134 ) <NEWLINE> <DEDENT> elif N == 194 : <NEWLINE> <INDENT> print ( 9827097 ) <NEWLINE> <DEDENT> elif N == 193 : <NEWLINE> <INDENT> print ( 9686065 ) <NEWLINE> <DEDENT> elif N == 192 : <NEWLINE> <INDENT> print ( 9574704 ) <NEWLINE> <DEDENT> elif N == 191 : <NEWLINE> <INDENT> print ( 9376656 ) <NEWLINE> <DEDENT> elif N == 190 : <NEWLINE> <INDENT> print ( 9267595 ) <NEWLINE> <DEDENT> elif N == 189 : <NEWLINE> <INDENT> print ( 9105537 ) <NEWLINE> <DEDENT> elif N == 188 : <NEWLINE> <INDENT> print ( 8949612 ) <NEWLINE> <DEDENT> elif N == 187 : <NEWLINE> <INDENT> print ( 8802826 ) <NEWLINE> <DEDENT> elif N == 186 : <NEWLINE> <INDENT> print ( 8684853 ) <NEWLINE> <DEDENT> elif N == 185 : <NEWLINE> <INDENT> print ( 8523897 ) <NEWLINE> <DEDENT> elif N == 184 : <NEWLINE> <INDENT> print ( 8403448 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H * W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> * W <NEWLINE> a = list ( a ) <NEWLINE> b = <STRING> * W <NEWLINE> b = list ( b ) <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if not ( i % 2 ) : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> b [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( b ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N ) <NEWLINE> <NL> if N <= 3 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> M = int ( ( N - 2 ) ** 0.5 ) <NEWLINE> <NL> for x in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> a = ( x + y + z ) ** 2 - ( x * y + y * z + z * x ) <NEWLINE> if a <= N : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> l = sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( <STRING> ) <NEWLINE> N = int ( l [ 0 ] ) <NEWLINE> <NL> digits = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> ub = 26 ** digits <NEWLINE> if N <= ub : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N -= ub <NEWLINE> digits += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> N -= 1 <NEWLINE> <NL> for pos in range ( digits ) : <NEWLINE> <INDENT> offset = N % 26 <NEWLINE> digit = chr ( ord ( <STRING> ) + offset ) <NEWLINE> ans = digit + ans <NEWLINE> N //= 26 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> N = I ( ) <NEWLINE> A = readInts ( ) <NEWLINE> import collections <NEWLINE> dic = collections . Counter ( A ) <NEWLINE> A = set ( A ) <NEWLINE> is_prime = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if is_prime [ a ] : <NEWLINE> <INDENT> for v in range ( a * 2 , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> is_prime [ v ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if is_prime [ a ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if v >= 2 and is_prime [ k ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> t2 = a [ 0 ] <NEWLINE> x = a [ 0 ] // 2 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> t = abs ( x - a [ i ] ) <NEWLINE> if t < t2 : <NEWLINE> <INDENT> t2 = t <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] , a [ ans ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> fruits = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> x = min ( fruits ) <NEWLINE> total += x <NEWLINE> fruits . remove ( x ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> b = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> b [ a [ i ] [ j ] ] = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> c = [ 0 ] * ( h * w + 1 ) <NEWLINE> for i in range ( d + 1 , h * w + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i - d ] + abs ( b [ i ] [ 0 ] - b [ i - d ] [ 0 ] ) + abs ( b [ i ] [ 1 ] - b [ i - d ] [ 1 ] ) <NEWLINE> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> print ( c [ r ] - c [ l ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> for i in range ( min ( 6 , n + 1 ) ) : <NEWLINE> <INDENT> dp [ i ] = i <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n // 6 + 1 ) : <NEWLINE> <INDENT> if i + 6 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 6 ** j ] = min ( dp [ i + 6 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> for j in range ( 1 , n // 9 + 1 ) : <NEWLINE> <INDENT> if i + 9 ** j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + 9 ** j ] = min ( dp [ i + 9 ** j ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> frag = [ True for _ in range ( n ) ] <NEWLINE> frag [ 0 ] = False <NEWLINE> ans = 0 <NEWLINE> now = 1 <NEWLINE> while ( now != 2 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> now = a [ now - 1 ] <NEWLINE> if ( frag [ now - 1 ] ) : <NEWLINE> <INDENT> frag [ now - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> Q , s = [ ] , [ ] <NEWLINE> flag = 0 <NEWLINE> while ( flag == 0 ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> print ( heapq . heappop ( Q ) * ( - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = c . split ( ) <NEWLINE> heapq . heappush ( Q , int ( s [ 1 ] ) * ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> anssub = 0 <NEWLINE> t = 0 <NEWLINE> while N % i == 0 : <NEWLINE> <INDENT> N = N // i <NEWLINE> anssub += 1 <NEWLINE> <DEDENT> while t * ( t + 1 ) // 2 <= anssub : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> ans += t - 1 <NEWLINE> <DEDENT> if N != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> N , K = inm ( ) <NEWLINE> A = inl ( ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
import math <NEWLINE> s = int ( input ( ) ) <NEWLINE> if s == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( s , 2 * s ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 3 , round ( math . sqrt ( s ) ) + 1 , 2 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> if i % k == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp = [ int ( input ( ) ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a_i = int ( input ( ) ) <NEWLINE> dp . append ( max ( dp [ i - 1 ] + a_i , a_i ) ) <NEWLINE> <DEDENT> print ( max ( dp ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> <COMMENT> <NL> if n == 1 or n == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if 3 <= n <= 5 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> ans [ 3 ] = 1 <NEWLINE> ans [ 4 ] = 1 <NEWLINE> ans [ 5 ] = 1 <NEWLINE> <NL> for i in range ( 6 , n + 1 ) : <NEWLINE> <INDENT> start = 3 <NEWLINE> stop = i - 3 <NEWLINE> s = 1 <NEWLINE> for j in range ( start , stop + 1 ) : <NEWLINE> <INDENT> s = ( s + ans [ j ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> ans [ i ] = s <NEWLINE> <NL> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s [ k - 1 ] = chr ( ord ( s [ k - 1 ] ) + 32 ) <NEWLINE> t = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> t = t + i <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> while True : <NEWLINE> <INDENT> deck = input ( ) <NEWLINE> if ( deck == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> shuffleTime = int ( input ( ) ) <NEWLINE> <NL> for i in range ( shuffleTime ) : <NEWLINE> <INDENT> rollNumber = int ( input ( ) ) <NEWLINE> deck = deck [ rollNumber : ] + deck [ : rollNumber ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( deck ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> <NL> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power = power % ( 10 ** 9 + 7 ) * n <NEWLINE> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for _ in range ( K ) : <NEWLINE> <INDENT> B = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> B [ max ( 0 , i - a ) ] += 1 <NEWLINE> B [ min ( N , i + a + 1 ) ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( B ) [ : - 1 ] <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = int ) <NEWLINE> print ( <STRING> . join ( map ( str , solve ( N , K , A ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= A [ i ] <NEWLINE> <NL> if a > 1000000000000000000 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> x = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x += math . gcd ( t , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> countdic = { } <NEWLINE> mod = 2019 <NEWLINE> <NL> num = 0 <NEWLINE> d = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num += s [ n - i ] * d <NEWLINE> num %= mod <NEWLINE> if num in countdic : <NEWLINE> <INDENT> countdic [ num ] += 1 <NEWLINE> <DEDENT> if num not in countdic : <NEWLINE> <INDENT> countdic [ num ] = 1 <NEWLINE> <DEDENT> d = ( 10 * d ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key in countdic : <NEWLINE> <INDENT> ans += countdic [ key ] * ( countdic [ key ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> if 0 in countdic : <NEWLINE> <INDENT> ans += countdic [ 0 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> a = collections . Counter ( A ) <NEWLINE> b = [ ] <NEWLINE> for i , j in a . items ( ) : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> b . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> b . sort ( reverse = True ) <NEWLINE> if len ( b ) >= 1 and b [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( b [ 0 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> elif len ( b ) >= 2 : <NEWLINE> <INDENT> print ( b [ 0 ] [ 0 ] * b [ 1 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( q ) ] <NEWLINE> m -= 1 <NEWLINE> mx = 0 <NEWLINE> <NL> <NL> def gen_A ( x , y , A , c ) : <NEWLINE> <INDENT> global mx <NEWLINE> if x == n and y == m : <NEWLINE> <INDENT> pts = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if int ( A [ i [ 1 ] - 1 ] ) - int ( A [ i [ 0 ] - 1 ] ) == i [ 2 ] : <NEWLINE> <INDENT> pts += i [ 3 ] <NEWLINE> <DEDENT> <DEDENT> mx = max ( mx , pts ) <NEWLINE> return <NEWLINE> <DEDENT> if x < n : <NEWLINE> <INDENT> nA = A + str ( c ) <NEWLINE> gen_A ( x + 1 , y , nA , c ) <NEWLINE> <DEDENT> if y < m : <NEWLINE> <INDENT> nc = c + 1 <NEWLINE> gen_A ( x , y + 1 , A , nc ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> gen_A ( 0 , 0 , <STRING> , 0 ) <NEWLINE> print ( mx ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> C = readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> <NL> l , r = 0 , N - 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if C [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> elif C [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
room = [ 0 for i in range ( 120 ) ] <NEWLINE> c = int ( input ( ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> index = ( 30 * ( b - 1 ) ) + ( 10 * ( f - 1 ) ) + ( r - 1 ) <NEWLINE> room [ index ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> if ( i != 0 ) and ( i % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( [ str ( v ) for v in room [ i * 10 : i * 10 + 10 ] ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A2N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( A2N ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i in c . keys ( ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s = list ( s ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> word = s [ k - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != word : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> <NL> N , K = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> d = dict ( zip ( B , A ) ) <NEWLINE> t = [ 0 for i in range ( N ) ] <NEWLINE> d1 = dict ( zip ( B , t ) ) <NEWLINE> temp = 1 <NEWLINE> cnt = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d1 [ d [ temp ] ] = d1 . get ( d [ temp ] , 0 ) + 1 <NEWLINE> if d1 . get ( d [ temp ] , 0 ) == 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans . append ( d [ temp ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> if d1 . get ( d [ temp ] , 0 ) == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> temp = d [ temp ] <NEWLINE> if i == K - 1 : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> cnt1 = 0 <NEWLINE> for i , v in enumerate ( d1 ) : <NEWLINE> <INDENT> if d1 [ v ] == 1 : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> k = K - 1 - cnt1 <NEWLINE> print ( ans [ k % cnt ] ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <NL> print ( math . factorial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> MAXN = a [ - 1 ] <NEWLINE> <NL> <NL> divisors = [ False for _ in range ( MAXN + 1 ) ] <NEWLINE> answer = 0 <NEWLINE> apast = None <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if ai == apast : <NEWLINE> <INDENT> is_good = False <NEWLINE> <DEDENT> elif i < n - 1 and ai == a [ i + 1 ] : <NEWLINE> <INDENT> is_good = False <NEWLINE> m = 1 <NEWLINE> while m * ai <= MAXN : <NEWLINE> <INDENT> divisors [ m * ai ] = True <NEWLINE> m += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> is_good = not divisors [ ai ] <NEWLINE> <NL> m = 1 <NEWLINE> while m * ai <= MAXN : <NEWLINE> <INDENT> divisors [ m * ai ] = True <NEWLINE> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if is_good : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> apast = ai <NEWLINE> <NL> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> maximum = max ( A ) <NEWLINE> count_max = A . count ( maximum ) <NEWLINE> if count_max > 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( maximum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != maximum : <NEWLINE> <INDENT> print ( maximum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = A [ i ] <NEWLINE> A [ i ] = 0 <NEWLINE> print ( max ( A ) ) <NEWLINE> A [ i ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import re <NEWLINE> list = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or re . search ( <STRING> , str ( i ) ) : <NEWLINE> <INDENT> list . append ( str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , <STRING> . join ( list ) ) <NEWLINE>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> table = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> sort_table = set ( table ) <NEWLINE> cnt_table = collections . Counter ( table ) <NEWLINE> ans = 0 <NEWLINE> for i in sort_table : <NEWLINE> <INDENT> num_of_i = cnt_table [ i ] <NEWLINE> if num_of_i <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = ( num_of_i * ( num_of_i - 1 ) ) // 2 <NEWLINE> ans += x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import sys <NEWLINE> from functools import reduce <NEWLINE> from operator import add <NEWLINE> from math import log <NEWLINE> <NL> <NL> def solve ( A , K ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> solns = [ ] <NEWLINE> grade = reduce ( add , A [ : K ] ) <NEWLINE> for i in range ( K , len ( A ) ) : <NEWLINE> <INDENT> grade0 = ( grade - A [ i - K ] ) + A [ i ] <NEWLINE> if grade0 > grade : <NEWLINE> <INDENT> solns . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solns . append ( <STRING> ) <NEWLINE> <DEDENT> grade = grade0 <NEWLINE> <DEDENT> return ( solns ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , K = ( int ( i ) for i in sys . stdin . readline ( ) . split ( ) ) <NEWLINE> A = [ log ( float ( i ) ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( solve ( A , K ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromright = list ( accumulate ( a , math . gcd ) ) <NEWLINE> a . reverse ( ) <NEWLINE> fromleft = list ( accumulate ( a , math . gcd ) ) <NEWLINE> fromleft . reverse ( ) <NEWLINE> <NL> gcd = [ ] <NEWLINE> <NL> gcd . append ( fromleft [ 1 ] ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> gcd . append ( math . gcd ( fromright [ i - 1 ] , fromleft [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> gcd . append ( fromright [ n - 2 ] ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( gcd ) ) <NEWLINE> <DEDENT>
<NL> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ss = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> abc = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> ans = [ None ] * n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> No = False <NEWLINE> for i , s in enumerate ( ss ) : <NEWLINE> <INDENT> zero = [ i for i , item in abc . items ( ) if item == 0 ] <NEWLINE> one = [ i for i , item in abc . items ( ) if item == 1 ] <NEWLINE> two = [ i for i , item in abc . items ( ) if item >= 2 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if len ( zero ) == 0 : <NEWLINE> <INDENT> if s in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> abc [ <STRING> ] += 1 <NEWLINE> abc [ s [ 1 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> abc [ <STRING> ] += 1 <NEWLINE> abc [ <STRING> ] -= 1 <NEWLINE> <DEDENT> <DEDENT> elif len ( zero ) == 1 and len ( two ) >= 1 : <NEWLINE> <INDENT> z = zero [ 0 ] <NEWLINE> t = two [ 0 ] <NEWLINE> if z in s : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ i ] = z <NEWLINE> abc [ z ] += 1 <NEWLINE> abc [ s . replace ( z , <STRING> ) ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = s . replace ( t , <STRING> ) <NEWLINE> ans [ i ] = tmp <NEWLINE> abc [ tmp ] += 1 <NEWLINE> abc [ t ] -= 1 <NEWLINE> <DEDENT> <DEDENT> elif len ( zero ) == 1 and len ( one ) == 2 : <NEWLINE> <INDENT> z = zero [ 0 ] <NEWLINE> if s [ 0 ] in one and s [ 1 ] in one : <NEWLINE> <COMMENT> <NL> <INDENT> ns = ss [ i + 1 ] if i + 1 <= n - 1 else None <NEWLINE> if ( ns is None ) or ( z not in ns ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ i ] = one [ 0 ] <NEWLINE> abc [ one [ 0 ] ] += 1 <NEWLINE> abc [ one [ 1 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = ns . replace ( z , <STRING> ) <NEWLINE> ans [ i ] = tmp <NEWLINE> abc [ tmp ] += 1 <NEWLINE> abc [ s . replace ( tmp , <STRING> ) ] -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> z = zero [ 0 ] <NEWLINE> ans [ i ] = z <NEWLINE> abc [ z ] += 1 <NEWLINE> abc [ s . replace ( z , <STRING> ) ] -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> assert len ( zero ) >= 2 <NEWLINE> if len ( zero ) == 3 : <NEWLINE> <INDENT> No = True <NEWLINE> break <NEWLINE> <DEDENT> elif s [ 0 ] in zero and s [ 1 ] in zero : <NEWLINE> <INDENT> No = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> z = ( set ( s ) & set ( zero ) ) . pop ( ) <NEWLINE> ans [ i ] = z <NEWLINE> abc [ z ] += 1 <NEWLINE> abc [ s . replace ( z , <STRING> ) ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if No : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> j = max ( 0 , i - k ) <NEWLINE> dp [ i ] = min ( x + abs ( h [ i ] - y ) for x , y in zip ( dp [ j : i ] , h [ j : i ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 1 or b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n < b : <NEWLINE> <INDENT> print ( floor ( a * n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( floor ( a * ( b - 1 ) / b ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ans = 0 <NEWLINE> x = min ( B , N + 1 ) - 1 <NEWLINE> ans = math . floor ( ( A * x ) / B ) - A * ( math . floor ( x / B ) ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcount ( x ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> count = 0 <NEWLINE> while tmp > 0 : <NEWLINE> <INDENT> if tmp & 1 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> tmp >>= 1 <NEWLINE> <NL> <DEDENT> return count <NEWLINE> <NL> <DEDENT> x = int ( X , 2 ) <NEWLINE> pcx = X . count ( <STRING> ) <NEWLINE> pc1 = x % ( pcx - 1 ) if pcx > 1 else 0 <NEWLINE> pc2 = x % ( pcx + 1 ) <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> X_next = pc2 + pow ( 2 , N - 1 - i , pcx + 1 ) <NEWLINE> X_pop_next = pcx + 1 <NEWLINE> <DEDENT> elif X [ i ] == <STRING> and pcx - 1 != 0 : <NEWLINE> <INDENT> X_next = pc1 - pow ( 2 , N - 1 - i , pcx - 1 ) <NEWLINE> X_pop_next = pcx - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> if X_pop_next == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> X_next = X_next % X_pop_next <NEWLINE> ans = 1 <NEWLINE> <NL> while X_next != 0 : <NEWLINE> <INDENT> X_next = X_next % popcount ( X_next ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ 0 ] * ( N + 1 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S [ n + 1 ] = S [ n ] + A [ n ] <NEWLINE> <DEDENT> B = { } <NEWLINE> for s in range ( len ( S ) ) : <NEWLINE> <INDENT> B [ S [ s ] ] = 0 <NEWLINE> <DEDENT> for s in range ( len ( S ) ) : <NEWLINE> <INDENT> B [ S [ s ] ] += 1 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for v in B . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> res += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> MAX = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if ans > MAX : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans *= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans > MAX : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> ans = make_divisors ( N ) <NEWLINE> result = [ ] <NEWLINE> if len ( ans ) % 2 == 0 : <NEWLINE> <INDENT> for i , j in zip ( range ( 0 , int ( len ( ans ) / 2 ) ) , reversed ( range ( int ( len ( ans ) / 2 ) , len ( ans ) ) ) ) : <NEWLINE> <INDENT> result . append ( int ( ans [ i ] + ans [ j ] ) - 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = ans [ int ( len ( ans ) / 2 ) ] <NEWLINE> result . append ( ( x - 1 ) * 2 ) <NEWLINE> <DEDENT> print ( min ( result ) ) <NEWLINE>
D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S * T >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( - 1 if x % y == 0 else x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> m = max ( a ) <NEWLINE> dp = [ 0 ] * ( m + 1 ) <NEWLINE> d = { } <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = a [ i ] <NEWLINE> if b in d : <NEWLINE> <INDENT> d [ b ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ b ] = 1 <NEWLINE> <DEDENT> j = b <NEWLINE> while b <= m + b : <NEWLINE> <INDENT> if b > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ b ] += 1 <NEWLINE> b += j <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if dp [ i ] == 1 and d [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> log_k = 0 <NEWLINE> k = K <NEWLINE> while k > 0 : <NEWLINE> <INDENT> k >>= 1 <NEWLINE> log_k += 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> work = [ A [ i ] for i in range ( N ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> for k in range ( log_k ) : <NEWLINE> <INDENT> if ( K >> k ) & 1 == 1 : <NEWLINE> <INDENT> ans = work [ ans - 1 ] <NEWLINE> <DEDENT> work = [ work [ work [ i ] - 1 ] for i in range ( N ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def barr ( n ) : return [ False for _ in range ( n ) ] <NEWLINE> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> n , m = imap ( ) <NEWLINE> ab = np . array ( [ iarr ( ) for i in range ( m ) ] ) <NEWLINE> g = adj ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> aa , bb = ab [ i ] [ 0 ] , ab [ i ] [ 1 ] <NEWLINE> g [ aa ] . append ( bb ) <NEWLINE> g [ bb ] . append ( aa ) <NEWLINE> <NL> <DEDENT> dep = iarr ( n + 1 ) <NEWLINE> dep [ 1 ] = 1 <NEWLINE> q = col . deque ( [ 1 ] ) <NEWLINE> route = iarr ( n + 1 ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for next in g [ now ] : <NEWLINE> <INDENT> if dep [ next ] : continue <NEWLINE> else : <NEWLINE> <INDENT> q . append ( next ) <NEWLINE> dep [ next ] = dep [ now ] + 1 <NEWLINE> route [ next ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for ans in route [ 2 : ] : print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = 0 <NEWLINE> for i in a [ : : - 1 ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> if j != n : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> if 7 % k == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> l . append ( 7 % k ) <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> a = ( 10 * l [ i - 1 ] + 7 ) <NEWLINE> if a % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( a % k ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if len ( N ) <= 2 : <NEWLINE> <INDENT> print ( 1000 - int ( N ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> N_1 = N [ - 3 ] + N [ - 2 ] + N [ - 1 ] <NEWLINE> if N_1 == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - int ( N_1 ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while a > 0 and c > 0 : <NEWLINE> <INDENT> a = a - d <NEWLINE> c = c - b <NEWLINE> <NL> <DEDENT> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> P = [ row [ 0 ] for row in C ] <NEWLINE> A = [ row [ 1 : M + 1 ] for row in C ] <NEWLINE> <NL> K = [ 0 for i in range ( 2 ** N ) ] <NEWLINE> G = [ [ 0 for k in range ( M ) ] for i in range ( 2 ** N ) ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> i2 = format ( i , <STRING> ) <NEWLINE> s = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> K [ i ] += int ( i2 [ 11 - k ] ) * P [ k ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> G [ i ] [ j ] += int ( i2 [ 11 - k ] ) * A [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> J = [ [ K [ i ] , G [ i ] ] for i in range ( 2 ** N ) ] <NEWLINE> J = sorted ( J ) <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if ( J [ i ] [ 1 ] ) [ j ] < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if j == M - 1 : <NEWLINE> <INDENT> t = 1 <NEWLINE> print ( J [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 0 <NEWLINE> for item in a : <NEWLINE> <INDENT> if item == ( num + 1 ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if num != 0 : <NEWLINE> <INDENT> print ( N - num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> temp_A , temp_B = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> A . append ( temp_A ) <NEWLINE> B . append ( temp_B ) <NEWLINE> <NL> <DEDENT> dame = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ B [ i ] - 1 ] > H [ A [ i ] - 1 ] : <NEWLINE> <INDENT> dame . append ( A [ i ] ) <NEWLINE> <DEDENT> if H [ A [ i ] - 1 ] > H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> dame . append ( B [ i ] ) <NEWLINE> <DEDENT> if H [ A [ i ] - 1 ] == H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> dame . append ( A [ i ] ) <NEWLINE> dame . append ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( set ( dame ) ) ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 1 <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> total *= a [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> sum_a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t + a [ i ] <= k : <NEWLINE> <INDENT> t += a [ i ] <NEWLINE> sum_a . append ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> sum_b = [ 0 ] <NEWLINE> t = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if t + b [ i ] <= k : <NEWLINE> <INDENT> t += b [ i ] <NEWLINE> sum_b . append ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> j = 0 <NEWLINE> for i in range ( len ( sum_a ) ) : <NEWLINE> <INDENT> while sum_a [ i ] + sum_b [ len ( sum_b ) - j - 1 ] > k : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> ans . append ( i + len ( sum_b ) - j - 1 ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A . count ( 0 ) == 0 : <NEWLINE> <INDENT> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = list ( str ( input ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> sum = ( sum + int ( N [ i ] ) ) % 9 <NEWLINE> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> m = [ set ( ) for _ in range ( 27 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> m [ a ] . add ( b ) <NEWLINE> m [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> def traverse ( n , visits ) : <NEWLINE> <INDENT> visits = visits | set ( [ n ] ) <NEWLINE> if len ( visits ) == N : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> for c in m [ n ] - visits : <NEWLINE> <INDENT> traverse ( c , visits ) <NEWLINE> <DEDENT> <DEDENT> traverse ( 1 , set ( ) ) <NEWLINE> return len ( ans ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> ans += a_list . pop ( 0 ) <NEWLINE> cnt = 2 <NEWLINE> times_2 = 0 <NEWLINE> times_1 = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if cnt == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n - cnt >= 2 : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> times_2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> times_1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ind = 0 <NEWLINE> for i in range ( times_2 ) : <NEWLINE> <INDENT> ans += 2 * a_list [ i ] <NEWLINE> ind += 1 <NEWLINE> <NL> <DEDENT> for i in range ( times_1 ) : <NEWLINE> <INDENT> ans += a_list [ ind + i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = collections . Counter ( A ) <NEWLINE> sums = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sums += C [ b ] * c <NEWLINE> sums -= C [ b ] * b <NEWLINE> C [ c ] += C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> print ( sums ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> ans = s [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> c = 1 <NEWLINE> b = 7 <NEWLINE> if k == 2 or k == 5 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = ( b * 10 ) % k <NEWLINE> a = b + a <NEWLINE> a = a % k <NEWLINE> c += 1 <NEWLINE> if c > k : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = round ( N ** 0.5 ) <NEWLINE> counter = [ 0 ] * N <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if f <= N : <NEWLINE> <INDENT> counter [ f - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( counter [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_l = sum ( l ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_l -= l [ i ] <NEWLINE> ans += l [ i ] * sum_l <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> x = 1 <NEWLINE> while x != 2 : <NEWLINE> <INDENT> r += 1 <NEWLINE> x = a [ x - 1 ] <NEWLINE> if x == 1 or r >= n : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dist = [ - 1 ] * ( N + 1 ) <NEWLINE> dist [ 1 ] = 0 <NEWLINE> connection = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> for quel in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> connection [ a ] . append ( b ) <NEWLINE> connection [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = [ ] <NEWLINE> que . append ( 1 ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> v = que . pop ( 0 ) <NEWLINE> <NL> for i in connection [ v ] : <NEWLINE> <INDENT> if dist [ i ] != - 1 : continue <NEWLINE> <NL> dist [ i ] = dist [ v ] + 1 <NEWLINE> que . append ( i ) <NEWLINE> ans [ i ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for j in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if ( i != 0 ) : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> if ( j % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( j % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> d = defaultdict ( lambda : defaultdict ( int ) ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d [ a ] [ b ] = math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res += d [ d [ a ] [ b ] ] [ c ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> val = sorted ( input ( ) ) <NEWLINE> s . append ( val ) <NEWLINE> <NL> <DEDENT> an = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if len ( s [ an ] ) <= len ( s [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an = i <NEWLINE> <NL> <DEDENT> <DEDENT> a = s [ an ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> while a != s [ i ] and n < len ( a ) and n < len ( s [ i ] ) : <NEWLINE> <INDENT> if a [ n ] == s [ i ] [ n ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ n ] > s [ i ] [ n ] : <NEWLINE> <INDENT> s [ i ] . pop ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( a ) > len ( s [ i ] ) : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
<NL> def input_from_console ( ) : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> return a , b , c , k <NEWLINE> <NL> <NL> <DEDENT> def solve ( a , b , c , k ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> if k < a : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - a <NEWLINE> sum = a <NEWLINE> <DEDENT> if k < b : <NEWLINE> <INDENT> return sum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - b <NEWLINE> <DEDENT> sum -= k <NEWLINE> return sum <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , c , k = input_from_console ( ) <NEWLINE> print ( solve ( a , b , c , k ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> if sys . gettrace ( ) : <COMMENT> <NEWLINE> <INDENT> check_cases ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from itertools import product <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hsum = [ 0 for i in range ( H ) ] <NEWLINE> wsum = [ 0 for i in range ( W ) ] <NEWLINE> s = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = h - 1 , w - 1 <NEWLINE> s . add ( ( h , w ) ) <NEWLINE> hsum [ h ] += 1 <NEWLINE> wsum [ w ] += 1 <NEWLINE> <NL> <DEDENT> hmax = max ( hsum ) <NEWLINE> wmax = max ( wsum ) <NEWLINE> <NL> hmax_index = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if hsum [ i ] == hmax : <NEWLINE> <INDENT> hmax_index . append ( i ) <NEWLINE> <DEDENT> <DEDENT> wmax_index = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if wsum [ i ] == wmax : <NEWLINE> <INDENT> wmax_index . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in hmax_index : <NEWLINE> <INDENT> for y in wmax_index : <NEWLINE> <INDENT> if ( x , y ) not in s : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hmax + wmax - 1 ) <NEWLINE>
import sys <NEWLINE> input_line2 = int ( sys . stdin . readline ( ) ) <NEWLINE> <COMMENT> <NL> print ( input_line2 ** 3 ) <NEWLINE> <COMMENT> <NL> <NL>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( <STRING> ) , dtype = np . int64 ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> s = s % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = s - A [ i ] <NEWLINE> if ( s < 0 ) : <NEWLINE> <INDENT> s += mod <NEWLINE> <NL> <DEDENT> ans += A [ i ] * s <NEWLINE> ans = ans % mod <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <COMMENT> <NL> a , b , c , d , e = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif e == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = input ( ) <NEWLINE> num = len ( s ) <NEWLINE> l , r = 0 , num - 1 <NEWLINE> ans = 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if s [ l ] == s [ r ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = P [ 0 ] <COMMENT> <NEWLINE> cnt = 1 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < m : <NEWLINE> <INDENT> m = P [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> max_A = A [ - 1 ] + 1 <NEWLINE> ans = [ 0 ] * max_A <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> if ans [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , max_A , i ) : <NEWLINE> <INDENT> ans [ j ] = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from __future__ import print_function <NEWLINE> <NL> <NL> class Solution : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> @ staticmethod <NEWLINE> def insertion_sort ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> array_length = int ( input ( ) ) <NEWLINE> unsorted_array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( array_length ) : <NEWLINE> <INDENT> v = unsorted_array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and unsorted_array [ j ] > v : <NEWLINE> <INDENT> unsorted_array [ j + 1 ] = unsorted_array [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> unsorted_array [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( map ( str , unsorted_array ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . insertion_sort ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> l = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def lcm ( X , Y ) : <NEWLINE> <INDENT> x = X <NEWLINE> y = Y <NEWLINE> if y > x : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while x % y != 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return X * Y // y <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> LCM = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Q = lcm ( LCM , A [ i ] ) <NEWLINE> cnt *= Q // LCM <NEWLINE> LCM = Q <NEWLINE> cnt += Q // A [ i ] <NEWLINE> <DEDENT> print ( cnt % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> vary = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> vary . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> uni = list ( set ( vary ) ) <NEWLINE> <NL> print ( len ( uni ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for l in range ( Q ) ] <NEWLINE> <NL> numList = { } <NEWLINE> sum = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if A [ n ] not in numList : <NEWLINE> <INDENT> numList [ A [ n ] ] = 0 <NEWLINE> <DEDENT> numList [ A [ n ] ] += 1 <NEWLINE> sum += A [ n ] <NEWLINE> <NL> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> if S [ q ] [ 0 ] in numList : <NEWLINE> <INDENT> if S [ q ] [ 1 ] not in numList : <NEWLINE> <INDENT> numList [ S [ q ] [ 1 ] ] = 0 <NEWLINE> <DEDENT> sum += ( S [ q ] [ 1 ] - S [ q ] [ 0 ] ) * numList [ S [ q ] [ 0 ] ] <NEWLINE> numList [ S [ q ] [ 1 ] ] += numList [ S [ q ] [ 0 ] ] <NEWLINE> numList [ S [ q ] [ 0 ] ] = 0 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = pow ( sum ( a ) , 2 ) <NEWLINE> y = sum ( ( a [ i ] ** 2 for i in range ( n ) ) ) <NEWLINE> <NL> sum = ( x - y ) // 2 % MOD <NEWLINE> <NL> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = max ( a ) <NEWLINE> che = [ 1 for i in range ( b ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if che [ i - 1 ] == 1 : <NEWLINE> <INDENT> c = b // i <NEWLINE> for j in range ( 2 , c + 1 ) : <NEWLINE> <INDENT> che [ i * j - 1 ] = 0 <NEWLINE> <DEDENT> che [ i - 1 ] = 2 <NEWLINE> <DEDENT> elif che [ i - 1 ] == 2 : <NEWLINE> <INDENT> che [ i - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if che [ i - 1 ] == 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( a ) ** 2 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans -= a [ i ] ** 2 <NEWLINE> <DEDENT> ans //= 2 <NEWLINE> print ( ans % mod ) <NEWLINE>
from copy import deepcopy <NEWLINE> <NL> <NL> class EightQueen : <NEWLINE> <INDENT> NQUEENS = 8 <NEWLINE> SIZE = 8 <NEWLINE> <NL> class Board : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . queens = [ ] <NEWLINE> self . size = size <NEWLINE> <NL> <DEDENT> def place ( self , i , j ) : <NEWLINE> <INDENT> self . queens . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> def count ( self ) : <NEWLINE> <INDENT> return len ( self . queens ) <NEWLINE> <NL> <DEDENT> def ok ( self , i , j ) : <NEWLINE> <INDENT> for qi , qj in self . queens : <NEWLINE> <INDENT> if qi == i : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if qj == j : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if i - j == qi - qj : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if i + j == qi + qj : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for j in range ( self . size ) : <NEWLINE> <INDENT> if ( i , j ) in self . queens : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> result . append ( s ) <NEWLINE> <DEDENT> return <STRING> . join ( result ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . board = self . Board ( self . SIZE ) <NEWLINE> <NL> <DEDENT> def add_queen ( self , i , j ) : <NEWLINE> <INDENT> self . board . place ( i , j ) <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> def _solve ( board , si , sj ) : <NEWLINE> <INDENT> if board . count ( ) == self . NQUEENS : <NEWLINE> <INDENT> return board <NEWLINE> <NL> <DEDENT> for i , j in _from_pos ( si , sj ) : <NEWLINE> <INDENT> if board . ok ( i , j ) : <NEWLINE> <INDENT> b = deepcopy ( board ) <NEWLINE> b . place ( i , j ) <NEWLINE> result = _solve ( b , i , j ) <NEWLINE> if result is not None : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def _from_pos ( i , j ) : <NEWLINE> <INDENT> for n in range ( i * self . SIZE + j , self . SIZE * self . SIZE ) : <NEWLINE> <INDENT> yield ( n // self . SIZE , n % self . SIZE ) <NEWLINE> <NL> <DEDENT> <DEDENT> self . board = _solve ( self . board , 0 , 0 ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if self . board is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return str ( self . board ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> q = EightQueen ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> i , j = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q . add_queen ( i , j ) <NEWLINE> <NL> <DEDENT> q . solve ( ) <NEWLINE> print ( q ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aX = abs ( X ) <NEWLINE> if aX // D >= K : <NEWLINE> <INDENT> ans = aX - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - ( aX // D ) ) % 2 == 0 : <NEWLINE> <INDENT> ans = aX % D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( aX % D ) - D <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( ans ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> def dfs ( source , used , all_weight , connect ) : <NEWLINE> <INDENT> max_weight = all_weight <NEWLINE> max_source = source <NEWLINE> used [ source ] = 1 <NEWLINE> for target , weight in connect [ source ] : <NEWLINE> <INDENT> if not used [ target ] : <NEWLINE> <INDENT> now_weight = all_weight + weight <NEWLINE> this_source , this_weight = dfs ( target , used , now_weight , connect ) <NEWLINE> if max_weight < this_weight : <NEWLINE> <INDENT> max_weight = this_weight <NEWLINE> max_source = this_source <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ max_source , max_weight ] <NEWLINE> <NL> <DEDENT> vertice = int ( input ( ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> for _ in range ( vertice - 1 ) : <NEWLINE> <INDENT> v1 , v2 , weight = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect [ v1 ] . append ( [ v2 , weight ] ) <NEWLINE> connect [ v2 ] . append ( [ v1 , weight ] ) <NEWLINE> <DEDENT> answer = 0 <NEWLINE> start_v = 0 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> used = [ 0 for n in range ( vertice ) ] <NEWLINE> start_v , answer = dfs ( start_v , used , 0 , connect ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> C = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for c in C : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( x ) for x in c ] ) ) <NEWLINE> <DEDENT>
def tenka17_c ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = None <NEWLINE> for x in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for y in range ( 1 , 3501 ) : <NEWLINE> <INDENT> a = N * x * y <NEWLINE> b = 4 * x * y - N * y - N * x <NEWLINE> if b < 1 : continue <NEWLINE> if a % b == 0 : <NEWLINE> <INDENT> ans = ( x , y , a // b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans : break <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> tenka17_c ( ) <NEWLINE>
import sys <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> n , q = map ( int , f_i . readline ( ) . split ( ) ) <NEWLINE> <NL> S = set ( frozenset ( [ i ] ) for i in range ( n ) ) <NEWLINE> <NL> def unite ( sets , v1 , v2 ) : <NEWLINE> <INDENT> s1 = None <NEWLINE> s2 = None <NEWLINE> for s in sets : <NEWLINE> <INDENT> if v1 in s and v2 in s : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif v1 in s : <NEWLINE> <INDENT> s1 = s <NEWLINE> <DEDENT> elif v2 in s : <NEWLINE> <INDENT> s2 = s <NEWLINE> <DEDENT> if s1 and s2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> sets . discard ( s1 ) <NEWLINE> sets . discard ( s2 ) <NEWLINE> s3 = s1 . union ( s2 ) <NEWLINE> sets . add ( s3 ) <NEWLINE> <NL> <DEDENT> def same ( sets , v1 , v2 ) : <NEWLINE> <INDENT> for s in sets : <NEWLINE> <INDENT> if v1 in s and v2 in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif v1 in s or v2 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for l in f_i : <NEWLINE> <INDENT> com , x , y = map ( int , l . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> unite ( S , x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same ( S , x , y ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import product <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> visited = [ ] <NEWLINE> <NL> def dfs ( p ) : <NEWLINE> <INDENT> if s [ p [ 0 ] ] [ p [ 1 ] ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> temp = [ 1 if s [ p [ 0 ] + y ] [ p [ 1 ] + x ] == <STRING> else 0 for ( x , y ) in [ [ 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] if 0 <= y + p [ 0 ] < h and 0 <= x + p [ 1 ] < w ] <NEWLINE> if sum ( temp ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( s [ 0 ] ) ) : <NEWLINE> <INDENT> dfs ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
b = input ( ) <NEWLINE> A = b . count ( <STRING> ) <NEWLINE> B = b . count ( <STRING> ) <NEWLINE> print ( min ( 2 * A , 2 * B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ 0 ] * m , [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if max ( l ) <= min ( r ) : <NEWLINE> <INDENT> print ( min ( r ) - max ( l ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> <NL> for a in list_A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = ans * A [ i ] <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def calculate ( x ) : <NEWLINE> <NL> <INDENT> b = 0 <NEWLINE> while True : <NEWLINE> <INDENT> tmp1 = x + b ** 5 <NEWLINE> a1 = math . pow ( tmp1 , 0.2 ) <NEWLINE> <NL> if ( a1 - math . floor ( a1 ) < 1e-7 ) : <NEWLINE> <INDENT> print ( int ( a1 ) , int ( b ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> tmp2 = x + ( - 1 * b ) ** 5 <NEWLINE> if tmp2 >= 0 : <NEWLINE> <INDENT> a2 = math . pow ( tmp2 , 0.2 ) <NEWLINE> if ( a2 - math . floor ( a2 ) < 1e-7 ) : <NEWLINE> <INDENT> print ( int ( a2 ) , int ( - 1 * b ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> b = b + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> calculate ( X ) <NEWLINE>
S = input ( ) <NEWLINE> r = 1 <NEWLINE> arr = [ 0 ] <NEWLINE> for c in S [ : : - 1 ] : <NEWLINE> <INDENT> arr . append ( ( arr [ - 1 ] + int ( c ) * r ) % 2019 ) <NEWLINE> r *= 10 <NEWLINE> r %= 2019 <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> ctr = Counter ( arr ) <NEWLINE> ans = 0 <NEWLINE> for v in ctr . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> score = 1 <NEWLINE> <NL> if K % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> score *= A [ 0 ] <NEWLINE> A . pop ( 0 ) <NEWLINE> K -= 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> P , M = [ ] , [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> P . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> M = M [ : : - 1 ] <NEWLINE> t = 0 <NEWLINE> p , m = 0 , 0 <NEWLINE> while t <= K : <NEWLINE> <INDENT> if score < 0 : <COMMENT> <NEWLINE> <INDENT> P = P [ : : - 1 ] <NEWLINE> M = M [ : : - 1 ] <NEWLINE> if 0 in M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if t + 2 <= K : <NEWLINE> <INDENT> if 2 * p + 1 < len ( P ) and 2 * m + 1 < len ( M ) : <NEWLINE> <INDENT> if P [ 2 * p ] * P [ 2 * p + 1 ] >= M [ 2 * m ] * M [ 2 * m + 1 ] : <NEWLINE> <INDENT> score *= P [ 2 * p ] * P [ 2 * p + 1 ] <NEWLINE> p += 1 <NEWLINE> t += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score *= M [ 2 * m ] * M [ 2 * m + 1 ] <NEWLINE> m += 1 <NEWLINE> t += 2 <NEWLINE> <DEDENT> <DEDENT> elif 2 * p + 1 < len ( P ) : <NEWLINE> <INDENT> score *= P [ 2 * p ] * P [ 2 * p + 1 ] <NEWLINE> p += 1 <NEWLINE> t += 2 <NEWLINE> <DEDENT> elif 2 * m + 1 < len ( M ) : <NEWLINE> <INDENT> score *= M [ 2 * m ] * M [ 2 * m + 1 ] <NEWLINE> m += 1 <NEWLINE> t += 2 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> score *= P [ - 1 ] * M [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif t + 1 <= K : <NEWLINE> <INDENT> if 2 * p < len ( P ) : <NEWLINE> <INDENT> score *= P [ 2 * p ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score *= M [ 2 * m ] <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> score %= mod <NEWLINE> <NL> <DEDENT> print ( score % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // x <NEWLINE> ans += n * x * ( 1 + n ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = [ 0 for _ in range ( H + 1 ) ] <NEWLINE> w_list = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> bomb = set ( [ ] ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list [ h ] += 1 <NEWLINE> w_list [ w ] += 1 <NEWLINE> bomb . add ( ( h , w ) ) <NEWLINE> <DEDENT> h_max = max ( h_list ) <NEWLINE> w_max = max ( w_list ) <NEWLINE> h_index = [ ] <NEWLINE> w_index = [ ] <NEWLINE> for i in range ( H + 1 ) : <NEWLINE> <INDENT> if h_list [ i ] == h_max : <NEWLINE> <INDENT> h_index . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( W + 1 ) : <NEWLINE> <INDENT> if w_list [ i ] == w_max : <NEWLINE> <INDENT> w_index . append ( i ) <NEWLINE> <DEDENT> <DEDENT> tmp = - 1 <NEWLINE> for h in h_index : <NEWLINE> <INDENT> for w in w_index : <NEWLINE> <INDENT> if ( h , w ) not in bomb : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max + tmp ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = [ True for i in range ( A [ - 1 ] ) ] <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> j = - 1 <NEWLINE> while i < N : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> while A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i + 1 == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ A [ i ] - 1 ] and i - j == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for k in range ( 2 * A [ i ] , A [ - 1 ] + 1 , A [ i ] ) : <NEWLINE> <INDENT> dp [ k - 1 ] = False <NEWLINE> <DEDENT> j = i <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> cum_sum = [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> cum_sum . append ( cum_sum [ i ] + ( 1 + p [ i ] ) / 2 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N - K + 2 ) : <NEWLINE> <INDENT> temp = cum_sum [ i + K - 1 ] - cum_sum [ i - 1 ] <NEWLINE> <COMMENT> <NL> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> A_list . append ( A ) <NEWLINE> <DEDENT> A_Counter = Counter ( A_list ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if K + A_Counter [ i ] - Q > 0 else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def calculate_minkowski_distances ( ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> data . append ( [ float ( value ) for value in input ( ) . rstrip ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for exponent in ( 1 , 2 , 3 , float ( <STRING> ) ) : <NEWLINE> <INDENT> print ( minkowski_distance ( data [ 0 ] , data [ 1 ] , exponent ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def minkowski_distance ( vector_x , vector_y , exponent ) : <NEWLINE> <COMMENT> <NL> <INDENT> abs_xy = [ abs ( vector_x [ i ] - vector_y [ i ] ) for i in range ( len ( vector_x ) ) ] <NEWLINE> <NL> m_dis = 0 <NEWLINE> if exponent == float ( <STRING> ) : <NEWLINE> <INDENT> m_dis = max ( abs_xy ) <NEWLINE> <DEDENT> elif exponent == 0 : <NEWLINE> <INDENT> m_dis = nan <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_dis = sum ( [ elem ** exponent for elem in abs_xy ] ) ** ( 1 / exponent ) <NEWLINE> <NL> <DEDENT> return m_dis <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> calculate_minkowski_distances ( ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = min ( a , k ) - max ( 0 , k - a - b ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> q = 1 <NEWLINE> f = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> q *= i <NEWLINE> if q > 10 ** 18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ret = 0 <NEWLINE> for x in range ( 10 ) : <NEWLINE> <INDENT> for y in range ( 10 ) : <NEWLINE> <INDENT> for z in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( x ) ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> b = S . find ( str ( y ) , a + 1 ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> c = S . find ( str ( z ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
<COMMENT> <NL> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> m = abs ( x ) <NEWLINE> n = m // d <NEWLINE> j = k - n <NEWLINE> if j > 0 : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> x += d * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += d * ( n + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> x -= d * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= d * ( n + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> x += d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= d * k <NEWLINE> <DEDENT> <DEDENT> print ( abs ( x ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> dna = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> res = [ 0 ] <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in dna : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += [ x ] <NEWLINE> x = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( x , max ( res ) ) ) <NEWLINE>
print ( input ( ) . swapcase ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> am = a [ - 1 ] + 1 <NEWLINE> b = [ 0 ] * am <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> if b [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , am , i ) : <NEWLINE> <INDENT> b [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i + 1 <NEWLINE> while ( x > 0 ) : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x // 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : exit ( print ( 0 ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( n * ( n - 1 ) ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> pn = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> mini = pn [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> mini = min ( mini , pn [ i ] ) <NEWLINE> if mini == pn [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> sqn = int ( math . sqrt ( n ) ) + 1 <NEWLINE> count = 0 <NEWLINE> aset = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , sqn ) : <NEWLINE> <INDENT> for y in range ( x , sqn ) : <NEWLINE> <INDENT> for z in range ( y , sqn ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= n : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> aset [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x == y or y == z : <NEWLINE> <INDENT> aset [ a ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aset [ a ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( aset [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sequence = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> print ( len ( set ( sequence ) ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> if a . count ( 0 ) == 0 : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = a . pop ( ) <NEWLINE> s = s * l <NEWLINE> <NL> if len ( str ( s ) ) >= 19 : <NEWLINE> <INDENT> if s == 10 ** 18 and i == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> answer = [ 0 ] * ( 10001 ) <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> index = x * x + y * y + z * z + x * y + y * z + z * x - 1 <NEWLINE> if index > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> answer [ index ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( answer [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> m = A [ 0 ] <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> if m > A [ i + 1 ] : <NEWLINE> <INDENT> x = x + ( m - A [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = A [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
s = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> sum += ( int ( s [ i ] ) ) <NEWLINE> <DEDENT> if ( sum % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> k_range = range ( 1 , k + 1 ) <NEWLINE> <NL> sum_gcd = 0 <NEWLINE> for l in k_range : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for m in k_range : <NEWLINE> <INDENT> temp = math . gcd ( l , m ) <NEWLINE> for n in k_range : <NEWLINE> <INDENT> sum_gcd += math . gcd ( n , temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_gcd ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ev = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> commit = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> commit += 1 <NEWLINE> <DEDENT> <DEDENT> ev . append ( commit ) <NEWLINE> <NL> <DEDENT> ev . sort ( reverse = True ) <NEWLINE> print ( len ( T ) - ev [ 0 ] ) <NEWLINE>
n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> m *= i <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL> <NL>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = collections . Counter ( S ) <NEWLINE> <NL> ans = count [ <STRING> ] * count [ <STRING> ] * count [ <STRING> ] <NEWLINE> <NL> for distance in range ( 1 , ( N - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i + 2 * distance >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if len ( { S [ i ] , S [ i + distance ] , S [ i + 2 * distance ] } ) == 3 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxim = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count > maxim : <NEWLINE> <INDENT> maxim = count <NEWLINE> <DEDENT> <DEDENT> print ( maxim ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> elif i == ( H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> elif H == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> * ( W - 2 ) , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> E = [ ( p + 1 ) / 2.0 for p in P ] <NEWLINE> tmp = sum ( E [ 0 : K ] ) <NEWLINE> ans = tmp <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> tmp = tmp - E [ i - 1 ] + E [ i + K - 1 ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . value = v <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def insert_ ( node , x ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return Node ( x ) <NEWLINE> <DEDENT> elif x == node . value : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> elif x < node . value : <NEWLINE> <INDENT> node . left = insert ( node . left , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = insert ( node . right , x ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def insert ( node ) : <NEWLINE> <INDENT> global root <NEWLINE> y = None <NEWLINE> x = root <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if node . value < x . value : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> node . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> root = node <NEWLINE> <DEDENT> elif node . value < y . value : <NEWLINE> <INDENT> y . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_walk ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> yield node . value <NEWLINE> for x in preorder_walk ( node . left ) : <NEWLINE> <INDENT> yield x <NEWLINE> <DEDENT> for x in preorder_walk ( node . right ) : <NEWLINE> <INDENT> yield x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def inorder_walk ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> for x in inorder_walk ( node . left ) : <NEWLINE> <INDENT> yield x <NEWLINE> <DEDENT> yield node . value <NEWLINE> for x in inorder_walk ( node . right ) : <NEWLINE> <INDENT> yield x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> root = None <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd , * val = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> insert ( Node ( int ( val [ 0 ] ) ) ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , * inorder_walk ( root ) ) <NEWLINE> print ( <STRING> , * preorder_walk ( root ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> rc = 0 <NEWLINE> gc = 0 <NEWLINE> bc = 0 <NEWLINE> <NL> for si in S : <NEWLINE> <INDENT> if si == <STRING> : <NEWLINE> <INDENT> rc += 1 <NEWLINE> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> gc += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bc += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> bad = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k > N - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> bad += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = rc * gc * bc <NEWLINE> <COMMENT> <NL> ans -= bad <NEWLINE> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> flag = False <NEWLINE> L = [ 0 for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> flag = False <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> L [ i ] = cnt <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( L [ r ] - L [ l ] ) <NEWLINE> <DEDENT>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> table = [ ] <NEWLINE> for rc in range ( r ) : <NEWLINE> <INDENT> table . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> table . append ( [ 0 for _ in range ( c + 1 ) ] ) <NEWLINE> <NL> for rc in range ( r ) : <NEWLINE> <INDENT> row_total = 0 <NEWLINE> for cc in range ( c ) : <NEWLINE> <INDENT> table [ r ] [ cc ] += table [ rc ] [ cc ] <NEWLINE> row_total += table [ rc ] [ cc ] <NEWLINE> <NL> <DEDENT> table [ rc ] . append ( row_total ) <NEWLINE> table [ r ] [ c ] += row_total <NEWLINE> <NL> <DEDENT> for row in table : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( column ) for column in row ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 10 ** 6 + 5 <NEWLINE> <NL> count = [ 0 ] * M <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> if count [ a [ x ] ] != 0 : <NEWLINE> <INDENT> count [ a [ x ] ] = 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for i in range ( a [ x ] , M , a [ x ] ) : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> if count [ a [ x ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> if math . log10 ( ans ) >= 18 and ans != 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> <NL> def max2 ( x , y ) : return x if x >= y else y <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = [ ( A , i ) for i , A in enumerate ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> As . sort ( reverse = True ) <NEWLINE> <NL> dp = [ [ - INF ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for no , ( A , pos ) in enumerate ( As ) : <NEWLINE> <INDENT> for i in range ( no + 1 ) : <NEWLINE> <INDENT> j = no - i <NEWLINE> dp [ i + 1 ] [ j ] = max2 ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] + A * abs ( pos - i ) ) <NEWLINE> dp [ i ] [ j + 1 ] = max2 ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] + A * abs ( pos - ( N - 1 - j ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> j = N - i <NEWLINE> ans = max2 ( ans , dp [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
primes = [ 0 , 0 ] + [ 1 ] * 9999 <NEWLINE> for i in range ( 2 , 101 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 10001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = n <NEWLINE> while not primes [ m ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> pnum = [ i for i in range ( m + 1 ) if primes [ i ] ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( pnum ) ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , len ( pnum ) ) : <NEWLINE> <INDENT> tmp += pnum [ j ] <NEWLINE> if tmp == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> if tmp > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> ans = 1 <NEWLINE> mod = 7 % k <NEWLINE> mod1 = 7 % k <NEWLINE> d [ mod1 ] = 1 <NEWLINE> ch = 0 <NEWLINE> <NL> while mod1 != 0 : <NEWLINE> <INDENT> mod = ( mod * 10 ) % k <NEWLINE> mod1 = mod1 + mod <NEWLINE> if mod1 >= k : <NEWLINE> <INDENT> mod1 = mod1 % k <NEWLINE> <DEDENT> if mod1 in d : <NEWLINE> <INDENT> ch += 1 <NEWLINE> break <NEWLINE> <DEDENT> if mod1 not in d : <NEWLINE> <INDENT> d [ mod1 ] = 1 <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> if ch == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> commands = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> <NL> List = deque ( ) <NEWLINE> for list_command in commands : <NEWLINE> <INDENT> if <STRING> in list_command : <NEWLINE> <INDENT> List . appendleft ( list_command [ 1 ] ) <NEWLINE> <DEDENT> elif <STRING> in list_command : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> List . remove ( list_command [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif <STRING> in list_command : <NEWLINE> <INDENT> List . popleft ( ) <NEWLINE> <DEDENT> elif <STRING> in list_command : <NEWLINE> <INDENT> List . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * List ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> count = Counter ( A ) <COMMENT> <NEWLINE> temp_sum = sum ( A ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> before , after = map ( int , input ( ) . split ( ) ) <NEWLINE> temp_sum += ( after - before ) * count [ before ] <NEWLINE> count [ after ] += count [ before ] <NEWLINE> count [ before ] = 0 <NEWLINE> print ( temp_sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <DEDENT> <DEDENT> score = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> dist = abs ( j - i ) <NEWLINE> if ( i > j ) : <NEWLINE> <INDENT> bi = i + dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> bi = j - dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> bi = j + dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> bi = i - dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> <DEDENT> if ( ( i + j ) % 2 == 0 and ( i + j ) / 2 in b ) : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
<NL> from sys import stdin <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ipt = [ [ int ( y ) for y in x . rstrip ( ) . split ( ) ] for x in stdin . readlines ( ) ] <NEWLINE> MOD = 100100100100100100 <NEWLINE> <NL> pl = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for a , b in ipt : <NEWLINE> <INDENT> if pl [ a ] == 0 : <NEWLINE> <INDENT> pl [ a ] = [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pl [ a ] . append ( b ) <NEWLINE> <DEDENT> if pl [ b ] == 0 : <NEWLINE> <INDENT> pl [ b ] = [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pl [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> que = deque ( [ 1 ] ) <NEWLINE> deep = [ MOD ] * ( N + 1 ) <NEWLINE> deep [ 1 ] = 0 <NEWLINE> deep [ 0 ] = 0 <NEWLINE> arrow = [ 0 ] * ( N + 1 ) <NEWLINE> cnt = 1 <NEWLINE> <NL> while not not que : <NEWLINE> <INDENT> q = que . popleft ( ) <NEWLINE> for i in pl [ q ] : <NEWLINE> <INDENT> if deep [ i ] != MOD : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> deep [ i ] = deep [ q ] + 1 <NEWLINE> arrow [ i ] = q <NEWLINE> cnt += 1 <NEWLINE> que . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N != cnt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in arrow [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ [ int ( a ) for a in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> z = A [ i ] [ 0 ] + A [ i ] [ 1 ] <NEWLINE> w = A [ i ] [ 0 ] - A [ i ] [ 1 ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> M_z = m_z = z <NEWLINE> M_w = m_w = w <NEWLINE> <DEDENT> if z > M_z : M_z = z <NEWLINE> if z < m_z : m_z = z <NEWLINE> if w > M_w : M_w = w <NEWLINE> if w < m_w : m_w = w <NEWLINE> <DEDENT> print ( max ( M_z - m_z , M_w - m_w ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( H [ i ] < H [ i - 1 ] ) : <NEWLINE> <INDENT> H [ i - 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( H [ i ] > H [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> l = [ 0 ] * ( k + 1 ) <NEWLINE> <NL> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> m = k // i <NEWLINE> l [ i ] += pow ( k // i , n , mod ) <NEWLINE> for j in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> l [ i ] -= l [ i * j ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += i * l [ i ] % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> num = math . gcd ( n , m ) <NEWLINE> ans = ( n * m ) // num <NEWLINE> numn = n // num <NEWLINE> numm = m // num <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if s [ i * numn ] != t [ i * numm ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) ; <NEWLINE> <NL> ans = [ 0 ] * ( l [ n - 1 ] + 1 ) <NEWLINE> p = 0 <NEWLINE> <NL> while ( p < n ) : <NEWLINE> <NL> <INDENT> for i in range ( l [ p ] , l [ n - 1 ] + 1 , l [ p ] ) : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> p += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> c = 0 <NEWLINE> <COMMENT> <NL> for i in l : <NEWLINE> <INDENT> if ( ans [ i ] == 1 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ls_pass = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> b = 0 <NEWLINE> <NL> ls = [ <STRING> ] + [ 0 ] + [ <STRING> ] * ( N - 1 ) <NEWLINE> ls_past = [ 1 ] <NEWLINE> for i in range ( 1 , N * 3 ) : <NEWLINE> <INDENT> b = a <NEWLINE> a = ls_pass [ a ] <NEWLINE> if ls [ a ] != <STRING> : <NEWLINE> <INDENT> ls_cicle = ls_past [ ls [ a ] : i ] <NEWLINE> print ( ls_cicle [ ( K - i ) % len ( ls_cicle ) ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == K : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls_past . append ( a ) <NEWLINE> ls [ a ] = i <NEWLINE> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in [ 0 ] * N ] <NEWLINE> r_edges = [ [ ] for _ in [ 0 ] * N ] <NEWLINE> <NL> for _ in [ 0 ] * M : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> r_edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> c = get_strongly_connected_components ( edges , r_edges ) <NEWLINE> group = [ 0 ] * N <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> for v in c [ i ] : <NEWLINE> <INDENT> group [ v ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> result = [ ] <NEWLINE> append = result . append <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> append ( <STRING> if group [ a ] == group [ b ] else <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE> <NL> <NL> <DEDENT> def get_strongly_connected_components ( edges , r_edges ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> v_count = len ( edges ) <NEWLINE> order = [ 0 ] * v_count <NEWLINE> k = 1 <NEWLINE> <NL> def get_order ( v ) : <NEWLINE> <INDENT> order [ v ] = 1 <NEWLINE> nonlocal k <NEWLINE> for dest in edges [ v ] : <NEWLINE> <INDENT> if order [ dest ] == 0 : <NEWLINE> <INDENT> get_order ( dest ) <NEWLINE> <DEDENT> <DEDENT> order [ v ] = k <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> def get_components ( v ) : <NEWLINE> <INDENT> order [ v ] = 0 <NEWLINE> return [ v ] + [ _v for dest in r_edges [ v ] if order [ dest ] > 0 for _v in get_components ( dest ) ] <NEWLINE> <NL> <DEDENT> [ None for v in range ( v_count ) if order [ v ] == 0 and get_order ( v ) ] <NEWLINE> return [ get_components ( v ) for v , _ in sorted ( enumerate ( order ) , key = lambda x : x [ 1 ] , reverse = True ) if order [ v ] > 0 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> <NL> warps = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> warps = [ 0 ] + warps <NEWLINE> warps = np . array ( warps , dtype = int ) <NEWLINE> <NL> dp = np . zeros ( ( k . bit_length ( ) + 1 , n + 1 ) , dtype = int ) <NEWLINE> <NL> dp [ 0 , : ] = warps <NEWLINE> <NL> for h in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> dp [ h ] = dp [ h - 1 ] [ dp [ h - 1 ] ] <NEWLINE> <NL> <DEDENT> node = 1 <NEWLINE> <COMMENT> <NL> for i in range ( k . bit_length ( ) , - 1 , - 1 ) : <NEWLINE> <INDENT> if k >> i & 1 : <NEWLINE> <INDENT> node = dp [ i ] [ node ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( node ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , ( n - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if n - 1 < i + 2 * j : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i + 2 * j ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 3 <NEWLINE> for word in s : <NEWLINE> <INDENT> if word == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif word == <STRING> : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_sum = ans [ 0 ] * ans [ 1 ] * ans [ 2 ] <NEWLINE> print ( ans_sum - cnt ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> M = [ ] <NEWLINE> for i in range ( 120 ) : <NEWLINE> <INDENT> M . append ( i ** 5 ) <NEWLINE> <DEDENT> for i in range ( 120 ) : <NEWLINE> <INDENT> for j in range ( 120 ) : <NEWLINE> <INDENT> if ( M [ i ] - M [ j ] == X ) : <NEWLINE> <INDENT> A = i <NEWLINE> B = j <NEWLINE> <DEDENT> elif ( M [ i ] + M [ j ] == X ) : <NEWLINE> <INDENT> A = i <NEWLINE> B = - 1 * j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) // 2 ) <NEWLINE>
ABCK = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = ABCK [ 0 ] <NEWLINE> B = ABCK [ 1 ] <NEWLINE> C = ABCK [ 2 ] <NEWLINE> K = ABCK [ 3 ] <NEWLINE> <NL> n = 0 <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> n = K <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> n = A <NEWLINE> <DEDENT> elif K <= A + B + C : <NEWLINE> <INDENT> n = A - ( K - A - B ) <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> rt = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> minv = int ( rt [ 0 ] ) <NEWLINE> maxv = int ( rt [ 1 ] ) - int ( rt [ 0 ] ) <NEWLINE> <NL> for j in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , int ( rt [ j ] ) - minv ) <NEWLINE> minv = min ( minv , int ( rt [ j ] ) ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> t = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if values [ i ] == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> break <NEWLINE> <DEDENT> if a > t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a * values [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if a <= t : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
I , * U = N , * D = 9 ** 9 , <NEWLINE> P , * L = <STRING> , <NEWLINE> M , * R = <STRING> , <NEWLINE> for t in [ * open ( 0 ) ] [ 1 : ] : * z , u = t . split ( ) ; exec ( u + <STRING> ) <NEWLINE> for * A , S in ( D , U , <STRING> ) , ( L , R , <STRING> ) , ( U , R , P + M ) , ( L , D , P + M ) , ( L , U , M + P ) , ( D , R , M + P ) : <NEWLINE> <INDENT> for x , y , r in eval ( <STRING> % S ) : <NEWLINE> <INDENT> if r : S , p = x , y <NEWLINE> elif x == S : N = min ( N , y - p ) <NEWLINE> <DEDENT> <DEDENT> print ( N % I * 5 or <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> class Dinic : <NEWLINE> <INDENT> <STRING> <NEWLINE> class edge : <NEWLINE> <INDENT> def __init__ ( self , to , cap , rev ) : <NEWLINE> <INDENT> self . to , self . cap , self . rev = to , cap , rev <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self , V , E , source , sink ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . V = V <NEWLINE> self . E = [ [ ] for _ in range ( V ) ] <NEWLINE> for fr in range ( V ) : <NEWLINE> <INDENT> for to , cap in E [ fr ] : <NEWLINE> <INDENT> self . E [ fr ] . append ( self . edge ( to , cap , len ( self . E [ to ] ) ) ) <NEWLINE> self . E [ to ] . append ( self . edge ( fr , 0 , len ( self . E [ fr ] ) - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> self . maxflow = self . dinic ( source , sink ) <NEWLINE> <NL> <DEDENT> def dinic ( self , source , sink ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> INF = float ( <STRING> ) <NEWLINE> maxflow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> self . bfs ( source ) <NEWLINE> if self . level [ sink ] < 0 : <NEWLINE> <INDENT> return maxflow <NEWLINE> <DEDENT> self . itr = [ 0 ] * self . V <NEWLINE> while True : <NEWLINE> <INDENT> flow = self . dfs ( source , sink , INF ) <NEWLINE> if flow > 0 : <NEWLINE> <INDENT> maxflow += flow <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( self , vertex , sink , flow ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if vertex == sink : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> for i in range ( self . itr [ vertex ] , len ( self . E [ vertex ] ) ) : <NEWLINE> <INDENT> self . itr [ vertex ] = i <NEWLINE> e = self . E [ vertex ] [ i ] <NEWLINE> if e . cap > 0 and self . level [ vertex ] < self . level [ e . to ] : <NEWLINE> <INDENT> d = self . dfs ( e . to , sink , min ( flow , e . cap ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> self . E [ vertex ] [ i ] . cap -= d <NEWLINE> self . E [ e . to ] [ e . rev ] . cap += d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def bfs ( self , start ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> que = deque ( ) <NEWLINE> self . level = [ - 1 ] * self . V <NEWLINE> que . append ( start ) <NEWLINE> self . level [ start ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> fr = que . popleft ( ) <NEWLINE> for e in self . E [ fr ] : <NEWLINE> <INDENT> if e . cap > 0 and self . level [ e . to ] < 0 : <NEWLINE> <INDENT> self . level [ e . to ] = self . level [ fr ] + 1 <NEWLINE> que . append ( e . to ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( V ) ] <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> u , v , cap = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ u ] . append ( ( v , cap ) ) <NEWLINE> <DEDENT> print ( Dinic ( V , edge , 0 , V - 1 ) . maxflow ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> from decimal import Decimal <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( Decimal , input ( ) . split ( ) ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> a = Decimal ( 1 ) <NEWLINE> for b in A : <NEWLINE> <INDENT> a *= b <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A_sum = sum ( A ) <NEWLINE> A_count = Counter ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sum += ( C - B ) * A_count [ B ] <NEWLINE> A_count [ C ] += A_count [ B ] <NEWLINE> A_count [ B ] = 0 <NEWLINE> print ( A_sum ) <NEWLINE> <DEDENT>
o = list ( input ( ) ) <NEWLINE> e = list ( input ( ) ) + [ <STRING> ] <NEWLINE> for s , t in zip ( o , e ) : <NEWLINE> <INDENT> print ( s + t , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> query = [ list ( input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> direction = 1 <NEWLINE> S_front = <STRING> <NEWLINE> S_back = <STRING> <NEWLINE> for l in query : <NEWLINE> <INDENT> if l [ 0 ] == <STRING> : <NEWLINE> <INDENT> direction *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( l [ 1 ] == <STRING> and direction == 1 ) or ( l [ 1 ] == <STRING> and direction == - 1 ) : <NEWLINE> <INDENT> S_front += l [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S_back += l [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if direction == 1 : <NEWLINE> <INDENT> print ( S_front [ : : - 1 ] + S + S_back ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S_back [ : : - 1 ] + S [ : : - 1 ] + S_front ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for s in range ( n ) ] <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if not s [ i ] in dic : <NEWLINE> <INDENT> dic [ s [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt_max = max ( dic . values ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for j in dic . keys ( ) : <NEWLINE> <INDENT> if dic [ j ] == cnt_max : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> <NL> for h in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ h ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 10 ** 6 + 1 <NEWLINE> mp = [ 0 ] * M <NEWLINE> for a in A : <NEWLINE> <INDENT> mp [ a ] += 1 <NEWLINE> <NL> <DEDENT> pairwise = 1 <NEWLINE> for i in range ( 2 , M ) : <NEWLINE> <INDENT> if sum ( mp [ i : : i ] ) > 1 : <NEWLINE> <INDENT> pairwise = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif reduce ( gcd , A ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = [ input ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ [ float ( <STRING> ) ] * W for _ in range ( H ) ] <NEWLINE> dist [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> <NL> is_visited = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> is_visited [ start [ 0 ] ] [ start [ 1 ] ] = 1 <NEWLINE> <NL> q = deque ( [ start ] ) <NEWLINE> max_ = 0 <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> now_h , now_w = q . popleft ( ) <NEWLINE> if M [ now_h ] [ now_w ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for next_h , next_w in ( ( now_h + 1 , now_w ) , <NEWLINE> <INDENT> ( now_h - 1 , now_w ) , <NEWLINE> ( now_h , now_w - 1 ) , <NEWLINE> ( now_h , now_w + 1 ) ) : <NEWLINE> <NL> if not ( 0 <= next_h < H ) or not ( 0 <= next_w < W ) or ( is_visited [ next_h ] [ next_w ] == 1 ) or M [ next_h ] [ next_w ] == <STRING> : <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <NL> dist [ next_h ] [ next_w ] = dist [ now_h ] [ now_w ] + 1 <NEWLINE> is_visited [ next_h ] [ next_w ] = 1 <NEWLINE> <NL> max_ = max ( max_ , dist [ next_h ] [ next_w ] ) <NEWLINE> q . append ( ( next_h , next_w ) ) <NEWLINE> <DEDENT> <DEDENT> return max_ <NEWLINE> <NL> <DEDENT> max_ = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if M [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> max_ = max ( bfs ( ( h , w ) ) , max_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_ ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> import numpy as np <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> bs = [ i for i in range ( - 100 , 200 ) ] <NEWLINE> bspow = list ( map ( lambda x : x ** 5 , bs ) ) <NEWLINE> <COMMENT> <NL> <NL> for a in range ( 200 ) : <NEWLINE> <INDENT> b_calc = a ** 5 - x <NEWLINE> index = bisect . bisect_left ( bspow , b_calc ) <NEWLINE> if ( bspow [ index ] == b_calc ) : <NEWLINE> <INDENT> print ( a , bs [ index ] ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict , Counter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main2 ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ k ] or s [ j ] == s [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j - i == k - j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> r = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> g = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> b = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> res += sum ( x > i for x in g ) * sum ( x > i for x in b ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> res += sum ( x > i for x in r ) * sum ( x > i for x in b ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> res += sum ( x > i for x in r ) * sum ( x > i for x in g ) <NEWLINE> <DEDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> xn = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> x = xn [ 0 ] <NEWLINE> n = xn [ 1 ] <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> num_list = [ i for i in range ( 0 , 102 ) if not i in p ] <NEWLINE> <NL> idx = np . abs ( np . asarray ( num_list ) - x ) . argmin ( ) <NEWLINE> print ( num_list [ idx ] ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> test = A [ 0 ] <NEWLINE> l = 0 <NEWLINE> <NL> while test % 2 == 0 : <NEWLINE> <INDENT> test = test // 2 <NEWLINE> c *= 2 <NEWLINE> <NL> <DEDENT> for i in np . arange ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] % c != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i + 1 ] % ( c * 2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = A [ i + 1 ] // c <NEWLINE> test = test * k // math . gcd ( test , k ) <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> k = test * c // 2 <NEWLINE> print ( M // k // 2 + M // k % 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> limit = pow ( 10 , 18 ) <NEWLINE> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def prepare ( X ) : <NEWLINE> <INDENT> N = 101 <NEWLINE> List = [ X ] * N <NEWLINE> for i in range ( 0 , 50 ) : <NEWLINE> <INDENT> List [ 2 * i + 1 ] = X - i - 1 <NEWLINE> List [ 2 * i + 2 ] = X + i + 1 <NEWLINE> <DEDENT> return List <NEWLINE> <NL> <DEDENT> def remove ( List , N , PList ) : <NEWLINE> <INDENT> for Num in range ( N ) : <NEWLINE> <INDENT> if ( PList [ Num ] in List ) : <NEWLINE> <INDENT> List . pop ( List . index ( PList [ Num ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( List [ 0 ] ) <NEWLINE> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <NL> <INDENT> XY = input ( ) . strip ( ) . split ( ) <NEWLINE> X = int ( XY [ 0 ] ) <NEWLINE> N = int ( XY [ 1 ] ) <NEWLINE> <NL> PList = [ 0 ] * N <NEWLINE> if ( N > 0 ) : <NEWLINE> <INDENT> P_str = input ( ) . strip ( ) . split ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> PList [ i ] = int ( P_str [ i ] ) <NEWLINE> <NL> <DEDENT> List = prepare ( X ) <NEWLINE> remove ( List , N , PList ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = 1 <NEWLINE> flag = 0 <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in c : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> for i in c : <NEWLINE> <INDENT> num *= i <NEWLINE> if num > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <NL> <INDENT> print ( num ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> X = il ( ) <NEWLINE> S = sorted ( X ) <NEWLINE> l = S [ N // 2 - 1 ] <NEWLINE> r = S [ N // 2 ] <NEWLINE> for x in X : <NEWLINE> <INDENT> if x <= l : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def cal ( truck_num , cargos ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> <NL> for i in range ( len ( cargos ) - truck_num + 1 ) : <NEWLINE> <INDENT> if not i == 0 and p < sum ( cargos [ : i + 1 ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if truck_num > 1 : <NEWLINE> <INDENT> r = max ( sum ( cargos [ : i + 1 ] ) , cal ( truck_num - 1 , cargos [ i + 1 : ] ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> p = r <NEWLINE> <DEDENT> elif p > r : <NEWLINE> <INDENT> p = r <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return sum ( cargos ) <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def check ( truck_num , carogs , target_load ) : <NEWLINE> <NL> <INDENT> cur_truck = 1 <NEWLINE> cur_weight = 0 <NEWLINE> for weight in cargos : <NEWLINE> <INDENT> cur_weight += weight <NEWLINE> if cur_weight > target_load : <NEWLINE> <INDENT> cur_weight = weight <NEWLINE> cur_truck += 1 <NEWLINE> if cur_truck > truck_num : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( truck_num , cargs ) : <NEWLINE> <NL> <INDENT> max_load = sum ( cargos ) <NEWLINE> min_load = max ( cargos ) <NEWLINE> <COMMENT> <NL> while min_load < max_load : <NEWLINE> <INDENT> target_load = int ( ( min_load + max_load ) / 2 ) <NEWLINE> if check ( truck_num , cargos , target_load ) : <NEWLINE> <INDENT> max_load = target_load <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_load = target_load + 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return max_load <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> truck_num = int ( line . split ( <STRING> ) [ 1 ] ) <NEWLINE> line_num = int ( line . split ( <STRING> ) [ 0 ] ) <NEWLINE> cargos = [ int ( input ( ) ) for i in range ( line_num ) ] <NEWLINE> print ( solve ( truck_num , cargos ) ) <NEWLINE> <DEDENT>
ans = [ ] <NEWLINE> for s in open ( 0 ) . readlines ( ) : <NEWLINE> <INDENT> if <STRING> in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( eval ( s . strip ( ) . replace ( <STRING> , <STRING> ) ) ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
count = 0 <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( a + 1 ) : <NEWLINE> <INDENT> z = b - i - j <NEWLINE> if 0 <= z <= a : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> five = 0 <NEWLINE> two = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> f = n // ( 2 * ( 5 ** i ) ) <NEWLINE> t = n // ( 2 ** i ) <NEWLINE> if f == t == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> five += f <NEWLINE> two += t <NEWLINE> <DEDENT> print ( min ( five , two ) ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if ( v - w ) * t >= abs ( a - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> prices = [ ] <NEWLINE> effects = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , * a = map ( int , input ( ) . split ( ) ) <NEWLINE> prices . append ( c ) <NEWLINE> effects . append ( list ( a ) ) <NEWLINE> <NL> <DEDENT> prices = np . array ( prices ) <NEWLINE> effects = np . array ( effects ) <NEWLINE> <NL> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> pats = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> pat = bin ( i ) . replace ( <STRING> , <STRING> ) <NEWLINE> pat = <STRING> * ( N - len ( pat ) ) + pat <NEWLINE> pat = list ( map ( int , list ( pat ) ) ) <NEWLINE> pats . append ( pat ) <NEWLINE> <NL> <DEDENT> pats = np . array ( pats ) <NEWLINE> total_price = np . dot ( pats , prices ) <NEWLINE> total_effects = np . dot ( pats , effects ) <NEWLINE> cond = ( ( total_effects >= X ) . sum ( axis = 1 ) == M ) <NEWLINE> <NL> final = total_price [ cond == 1 ] <NEWLINE> if len ( final ) > 0 : <NEWLINE> <INDENT> ans = int ( final . min ( ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> d1 = N // ( K // 2 ) <NEWLINE> d2 = N // K <NEWLINE> ans = d2 ** 3 + ( d1 - d2 ) ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = N // K <NEWLINE> ans = d ** 3 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import decimal <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b <= n : <NEWLINE> <INDENT> x = decimal . Decimal ( a * ( b - 1 ) / b ) <NEWLINE> c = math . floor ( x ) <NEWLINE> print ( c ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = decimal . Decimal ( a * n / b ) <NEWLINE> c = math . floor ( x ) <NEWLINE> print ( c ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> def main ( n , var ) : <NEWLINE> <INDENT> mylist = [ ] <NEWLINE> dupliN = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // var ) ) + var ) : <NEWLINE> <INDENT> if dupliN % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while dupliN % i == 0 : <NEWLINE> <INDENT> cnt += var <NEWLINE> dupliN //= i <NEWLINE> <DEDENT> mylist . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if dupliN != 1 : <NEWLINE> <INDENT> mylist . append ( [ dupliN , 1 ] ) <NEWLINE> <DEDENT> if mylist == [ ] : <NEWLINE> <INDENT> mylist . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return mylist <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> f = main ( N , 1 ) <NEWLINE> ansval = 0 <NEWLINE> for extra , value in f : <NEWLINE> <INDENT> num = 1 <NEWLINE> while True : <NEWLINE> <INDENT> value -= num <NEWLINE> if value < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ansval += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ansval ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = LI ( ) <NEWLINE> h = [ 0 ] * H <NEWLINE> w = [ 0 ] * W <NEWLINE> d = { } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = LI ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> h [ a ] += 1 <NEWLINE> w [ b ] += 1 <NEWLINE> d [ ( a , b ) ] = 1 <NEWLINE> <NL> <DEDENT> h_koho = [ ] <NEWLINE> w_koho = [ ] <NEWLINE> <NL> h_max = max ( h ) <NEWLINE> w_max = max ( w ) <NEWLINE> <NL> for i , x in enumerate ( h ) : <NEWLINE> <INDENT> if x == h_max : <NEWLINE> <INDENT> h_koho . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( w ) : <NEWLINE> <INDENT> if x == w_max : <NEWLINE> <INDENT> w_koho . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in h_koho : <NEWLINE> <INDENT> for y in w_koho : <NEWLINE> <INDENT> if ( x , y ) not in d : <NEWLINE> <INDENT> return h_max + w_max <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return h_max + w_max - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power %= mod <NEWLINE> <DEDENT> print ( power ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> start = 7 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if start % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> start = ( start * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( N ) <NEWLINE> <NL> count = 0 <NEWLINE> for p in primes : <NEWLINE> <INDENT> c = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , 10 ** 9 ) : <NEWLINE> <INDENT> c += i <NEWLINE> t += 1 <NEWLINE> if c > p [ 1 ] : <NEWLINE> <INDENT> count += t - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif c == p [ 1 ] : <NEWLINE> <INDENT> count += t <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( max ( len ( set ( S [ : i ] ) & set ( S [ i : ] ) ) for i in range ( N ) ) ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = MAP ( ) <NEWLINE> S = [ ] <NEWLINE> walls = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> line = INPUT ( ) <NEWLINE> walls += line . count ( <STRING> ) <NEWLINE> S . append ( line ) <NEWLINE> <NL> <DEDENT> dist = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 1 <NEWLINE> queue = deque ( [ [ 0 , 0 ] ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> y , x = queue . popleft ( ) <NEWLINE> if y == H - 1 and x == W - 1 : <NEWLINE> <INDENT> print ( H * W - walls - dist [ y ] [ x ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for dy , dx in [ ( y , x - 1 ) , ( y - 1 , x ) , ( y , x + 1 ) , ( y + 1 , x ) ] : <NEWLINE> <INDENT> if 0 <= dy < H and 0 <= dx < W and S [ dy ] [ dx ] == <STRING> and dist [ dy ] [ dx ] == INF : <NEWLINE> <INDENT> dist [ dy ] [ dx ] = dist [ y ] [ x ] + 1 <NEWLINE> queue . append ( [ dy , dx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> xy = [ list ( x ) for x in zip ( * xy ) ] <NEWLINE> a = [ i + j for i , j in zip ( xy [ 0 ] , xy [ 1 ] ) ] <NEWLINE> b = [ i - j for i , j in zip ( xy [ 0 ] , xy [ 1 ] ) ] <NEWLINE> aa = max ( a ) - min ( a ) <NEWLINE> ba = max ( b ) - min ( b ) <NEWLINE> print ( max ( aa , ba ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . V = V <NEWLINE> self . d = float ( <STRING> ) <NEWLINE> self . p = - 1 <NEWLINE> self . state = - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> M = [ float ( <STRING> ) ] * 100 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> M [ i ] = [ float ( <STRING> ) ] * 100 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> nodes = [ 0 ] * 100 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> V = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for ( j , m ) in enumerate ( V ) : <NEWLINE> <INDENT> M [ i ] [ j ] = m if not m == - 1 else float ( <STRING> ) <NEWLINE> <DEDENT> nodes [ i ] = Node ( [ ] ) <NEWLINE> <NL> <DEDENT> nodes [ 0 ] . d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> mincost = float ( <STRING> ) <NEWLINE> u = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> node = nodes [ i ] <NEWLINE> if ( mincost > node . d ) and ( node . state != 1 ) : <NEWLINE> <INDENT> u = i <NEWLINE> mincost = node . d <NEWLINE> <NL> <DEDENT> <DEDENT> if u == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> nodes [ u ] . state = 1 <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> node = nodes [ v ] <NEWLINE> if ( node . state != 1 ) and ( M [ u ] [ v ] != float ( <STRING> ) ) : <NEWLINE> <INDENT> if node . d > M [ u ] [ v ] : <NEWLINE> <INDENT> node . d = M [ u ] [ v ] <NEWLINE> node . p = u <NEWLINE> node . state = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if nodes [ i ] . p != - 1 : <NEWLINE> <INDENT> sum += M [ i ] [ nodes [ i ] . p ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in dic : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> max_val = max ( dic . values ( ) ) <NEWLINE> a = sorted ( [ i for i , k in dic . items ( ) if k == max_val ] ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> A = ( i - 1 ) * i // 2 <NEWLINE> B = N * ( 1 + N ) // 2 - ( N + 1 - i - 1 ) * ( N + 1 - i ) // 2 <NEWLINE> ans += B - A + 1 <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> ans = [ 1 for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> if X [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> l = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if X [ k ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if l == 1 : <NEWLINE> <INDENT> if X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ _ ] = 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = 2 <NEWLINE> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if X [ k ] == <STRING> : <NEWLINE> <INDENT> ans [ k ] = 0 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( ans [ _ ] ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> intN = int ( X , 2 ) <NEWLINE> N1 = intN % ( l - 1 ) <NEWLINE> N0 = intN % ( l + 1 ) <NEWLINE> <NL> <NL> start = [ ] <NEWLINE> s1 = 1 <NEWLINE> s0 = 1 <NEWLINE> for k in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if X [ k ] == <STRING> : <NEWLINE> <INDENT> ia = ( N1 - s1 ) % ( l - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ia = ( N0 + s0 ) % ( l + 1 ) <NEWLINE> <DEDENT> start . append ( ia ) <NEWLINE> s1 = s1 * 2 % ( l - 1 ) <NEWLINE> s0 = s0 * 2 % ( l + 1 ) <NEWLINE> <DEDENT> start = start [ : : - 1 ] <NEWLINE> <NL> <NL> <NL> <NL> poplist = [ 0 for _ in range ( l + 1 ) ] <NEWLINE> t = 1 <NEWLINE> while t < l + 2 : <NEWLINE> <INDENT> for k in range ( t , l + 1 , 2 * t ) : <NEWLINE> <INDENT> for j in range ( t ) : <NEWLINE> <INDENT> if k + j > l : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> poplist [ k + j ] += 1 <NEWLINE> <DEDENT> <DEDENT> t *= 2 <NEWLINE> <NL> <DEDENT> for k in range ( len ( start ) ) : <NEWLINE> <INDENT> for count in range ( 10 * 5 ) : <NEWLINE> <INDENT> if start [ k ] == 0 : <NEWLINE> <INDENT> ans [ k ] += count <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start [ k ] = start [ k ] % poplist [ start [ k ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> tmp = n - 1 <NEWLINE> ret = len ( make_divisors ( tmp ) ) - 1 <NEWLINE> <NL> tmplen = make_divisors ( n ) <NEWLINE> <NL> for item in tmplen : <NEWLINE> <INDENT> if item == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> val = n <NEWLINE> while True : <NEWLINE> <INDENT> if val % item == 0 : <NEWLINE> <INDENT> val = val // item <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if val % item == 1 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> w = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - w <NEWLINE> w += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = min ( b - 1 , n ) <NEWLINE> print ( math . floor ( a * c / b ) - a * math . floor ( c / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> num_dict = dict ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i in num_dict . keys ( ) : <NEWLINE> <INDENT> num_dict [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dict [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k , v in num_dict . items ( ) : <NEWLINE> <INDENT> ans += k * v <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if b [ i ] in num_dict : <NEWLINE> <INDENT> if c [ i ] in num_dict : <NEWLINE> <INDENT> ans += ( c [ i ] - b [ i ] ) * num_dict [ b [ i ] ] <NEWLINE> num_dict [ c [ i ] ] += num_dict . pop ( b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( c [ i ] - b [ i ] ) * num_dict [ b [ i ] ] <NEWLINE> num_dict [ c [ i ] ] = num_dict . pop ( b [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> j = N // i <NEWLINE> ans += int ( j * ( j + 1 ) * i / 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> SMs = [ ] <NEWLINE> for i in range ( 2 , n // 2 + 2 ) : <NEWLINE> <INDENT> SMs . append ( sum ( list ( map ( int , str ( i ) ) ) ) + sum ( list ( map ( int , str ( n - i ) ) ) ) ) <NEWLINE> <DEDENT> print ( min ( SMs ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aL = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> d1 = { } <NEWLINE> d2 = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d1i = i - aL [ i ] <NEWLINE> d2i = i + aL [ i ] <NEWLINE> <NL> if d1i in d1 : <NEWLINE> <INDENT> d1 [ d1i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d1 [ d1i ] = 1 <NEWLINE> <NL> <DEDENT> if d2i in d2 : <NEWLINE> <INDENT> d2 [ d2i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d2 [ d2i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k , v in d2 . items ( ) : <NEWLINE> <INDENT> if k in d1 : <NEWLINE> <INDENT> ans += v * d1 [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line = input ( ) <NEWLINE> L = [ int ( x ) for x in line . split ( ) ] <NEWLINE> <NL> flags = [ False ] * n <NEWLINE> loops = [ ] <NEWLINE> <NL> S = sorted ( L ) <NEWLINE> I = [ S . index ( x ) for x in L ] <NEWLINE> for idx , x in enumerate ( I ) : <NEWLINE> <INDENT> if flags [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == idx : <NEWLINE> <INDENT> flags [ idx ] = True <NEWLINE> continue <NEWLINE> <NL> <DEDENT> ws = [ ] <NEWLINE> while S [ x ] not in ws : <NEWLINE> <INDENT> flags [ x ] = True <NEWLINE> ws . append ( S [ x ] ) <NEWLINE> x = I [ x ] <NEWLINE> <DEDENT> loops . append ( ws ) <NEWLINE> <NL> <DEDENT> cost = 0 <NEWLINE> for loop in loops : <NEWLINE> <INDENT> a = sum ( loop ) + ( len ( loop ) - 2 ) * min ( loop ) <NEWLINE> b = sum ( loop ) + min ( loop ) + ( len ( loop ) + 1 ) * min ( L ) <NEWLINE> cost += min ( a , b ) <NEWLINE> <NL> <DEDENT> print ( cost ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> List = [ 0 ] * 2019 <NEWLINE> ans = 0 <NEWLINE> a = 1 <NEWLINE> d = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> d = d + int ( s ) * a <NEWLINE> List [ d % 2019 ] += 1 <NEWLINE> a = a * 10 <NEWLINE> a = a % 2019 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = List [ 0 ] <NEWLINE> for i in List : <NEWLINE> <INDENT> if ( i >= 2 ) : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> LL = sorted ( L ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if LL [ i + 1 ] != LL [ i ] : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if a < k : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k <NEWLINE> <NL> <DEDENT> minus = k - ( a + b ) <NEWLINE> <NL> if minus > 0 : <NEWLINE> <INDENT> ans -= minus <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from statistics import median <NEWLINE> from time import time <NEWLINE> <NL> t = time ( ) <NEWLINE> <NL> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> line_in_dice = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> result = [ 0 ] * ( N + K ) <NEWLINE> <NL> result [ 0 ] = line_in_dice [ 0 ] <NEWLINE> result [ K ] -= line_in_dice [ 0 ] <NEWLINE> <NL> max_point = 0 <NEWLINE> max_value = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> result [ i ] += ( result [ i - 1 ] + line_in_dice [ i ] ) <NEWLINE> result [ i + K ] -= line_in_dice [ i ] <NEWLINE> <NL> if result [ i ] > max_value : <NEWLINE> <INDENT> max_point = i <NEWLINE> max_value = result [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def create_median ( x ) : <NEWLINE> <INDENT> if x % 2 == 1 : <NEWLINE> <INDENT> return ( 1 + x ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( x // 2 ) + ( x // 2 + 1 ) ) / 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( create_median ( x ) <NEWLINE> <INDENT> for x in line_in_dice [ max_point - K + 1 : max_point + 1 ] ) ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> time = 0 <NEWLINE> pos = 0 <NEWLINE> while pos < X : <NEWLINE> <INDENT> time += 1 <NEWLINE> pos += time <NEWLINE> <NL> <DEDENT> print ( time ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> x = sorted ( [ i for i in A . items ( ) if i [ 1 ] >= 2 ] ) <NEWLINE> <NL> if len ( x ) < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x [ - 1 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( x [ - 1 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ - 1 ] [ 0 ] * x [ - 2 ] [ 0 ] ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> Height = 10 ** 9 <NEWLINE> for i in range ( 0 , N - K + 1 ) : <NEWLINE> <INDENT> hmax = h [ i + K - 1 ] <NEWLINE> hmin = h [ i ] <NEWLINE> Height = min ( Height , hmax - hmin ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( Height ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> h . sort ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = ( 10 ** N ) % ( 10 ** 9 + 7 ) <NEWLINE> b = ( 9 ** N ) % ( 10 ** 9 + 7 ) <NEWLINE> c = ( 8 ** N ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( ( a + c - 2 * b ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> s_ = input ( ) <NEWLINE> r , g , b = s_ . count ( <STRING> ) , s_ . count ( <STRING> ) , s_ . count ( <STRING> ) <NEWLINE> rgb = r * g * b <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s_ ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s_ ) ) : <NEWLINE> <INDENT> h = j - i + j <NEWLINE> if h < n : <NEWLINE> <INDENT> if s_ [ i ] != s_ [ j ] and s_ [ h ] != s_ [ j ] and s_ [ i ] != s_ [ h ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rgb - cnt ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> y = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> print ( y ) <NEWLINE>
from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ceil = lambda x , y : ( x + y - 1 ) // y <NEWLINE> input_list = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> def bfs ( s , n , node ) : <NEWLINE> <INDENT> check = [ - 1 for _ in range ( n ) ] <NEWLINE> check [ 0 ] = 0 <NEWLINE> <NL> side_num_arr = list ( map ( lambda x : len ( x ) , node ) ) <NEWLINE> l = max ( side_num_arr ) <NEWLINE> <COMMENT> <NL> queue = [ - 1 for _ in range ( n ) ] <NEWLINE> now = 0 <NEWLINE> queue [ now ] = s <NEWLINE> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> ans [ 0 ] = [ 0 ] <NEWLINE> last_ind = 1 <NEWLINE> while last_ind < n : <NEWLINE> <NL> <INDENT> if now >= n : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> check [ queue [ now ] ] = True <NEWLINE> if side_num_arr [ queue [ now ] ] <= 0 : <NEWLINE> <INDENT> now += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for i in node [ queue [ now ] ] : <NEWLINE> <INDENT> edge = i [ 0 ] <NEWLINE> <NL> ind = i [ 1 ] <NEWLINE> if side_num_arr [ edge ] <= 0 or check [ edge ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> side_num_arr [ edge ] -= 1 <NEWLINE> side_num_arr [ queue [ now ] ] -= 1 <NEWLINE> queue [ last_ind ] = edge <NEWLINE> last_ind += 1 <NEWLINE> check [ edge ] = True <NEWLINE> <NL> ans [ edge ] = queue [ now ] <NEWLINE> <DEDENT> now += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> n , m = input_list ( ) <NEWLINE> node = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = input_list ( ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> node [ u ] . append ( [ v , i ] ) <NEWLINE> node [ v ] . append ( [ u , i ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = bfs ( 0 , n , node ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for each in ans [ 1 : ] : <NEWLINE> <INDENT> print ( each + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N , M , K = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> A = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> B = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> max_sum = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( len ( B ) ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <NL> <DEDENT> j = len ( B ) <NEWLINE> for i in range ( len ( A ) + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> max_sum = max ( max_sum , i + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_sum ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 4 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> I = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> i = 1 <NEWLINE> for a in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> I [ a - 1 ] . append ( i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def dfs ( v , I , X ) : <NEWLINE> <INDENT> INF = 10 ** 20 <NEWLINE> DP = [ INF for _ in range ( X [ v ] + 1 ) ] <NEWLINE> DP [ 0 ] = 0 <NEWLINE> for i in I [ v ] : <NEWLINE> <INDENT> x = X [ i ] <NEWLINE> y = dfs ( i , I , X ) <NEWLINE> if x < y : <NEWLINE> <INDENT> x , y = y , x <COMMENT> <NEWLINE> <DEDENT> for a in range ( X [ v ] , - 1 , - 1 ) : <NEWLINE> <INDENT> if a - y >= 0 : <NEWLINE> <INDENT> DP [ a ] = DP [ a - y ] + x <NEWLINE> if a - x >= 0 : <NEWLINE> <INDENT> DP [ a ] = min ( DP [ a ] , DP [ a - x ] + y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> DP [ a ] = INF <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = min ( DP ) <NEWLINE> <COMMENT> <NL> if ans >= INF : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> del DP , INF <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> dfs ( 0 , I , X ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
import collections <NEWLINE> import copy <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for i in range ( a [ 2 ] ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( b [ 0 ] ) <NEWLINE> d . append ( b [ 1 ] ) <NEWLINE> <NL> <DEDENT> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> <NL> cp = copy . copy ( c ) <NEWLINE> dp = copy . copy ( d ) <NEWLINE> <NL> e = collections . Counter ( c ) <NEWLINE> f = collections . Counter ( d ) <NEWLINE> g = e . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> gc = e . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> h = f . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> hc = f . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> ans1 += gc <NEWLINE> ans2 += hc <NEWLINE> for i in range ( a [ 2 ] ) : <NEWLINE> <INDENT> if cp [ i ] == g : <NEWLINE> <INDENT> d [ i ] = - 1 <NEWLINE> <DEDENT> if dp [ i ] == h : <NEWLINE> <INDENT> c [ i ] = - 1 <NEWLINE> <DEDENT> <DEDENT> e = collections . Counter ( c ) <NEWLINE> f = collections . Counter ( d ) <NEWLINE> g = e . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> gc = e . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> h = f . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> hc = f . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <NL> if g == - 1 : <NEWLINE> <INDENT> if gc == a [ 2 ] : <NEWLINE> <INDENT> gc = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = e . most_common ( ) [ 1 ] [ 0 ] <NEWLINE> gc = e . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if h == - 1 : <NEWLINE> <INDENT> if hc == a [ 2 ] : <NEWLINE> <INDENT> hc = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = f . most_common ( ) [ 1 ] [ 0 ] <NEWLINE> hc = f . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 += hc <NEWLINE> ans2 += gc <NEWLINE> if ans1 > ans2 : <NEWLINE> <INDENT> print ( str ( ans1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( ans2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> a , b = sorted ( A , reverse = True ) [ 0 : 2 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a_s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a_s ) + 1 <NEWLINE> cnt = [ 0 for _ in range ( m ) ] <NEWLINE> <NL> for a in a_s : <NEWLINE> <INDENT> if cnt [ a ] != 0 : <NEWLINE> <INDENT> cnt [ a ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for n in range ( a , m , a ) : <NEWLINE> <INDENT> cnt [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( cnt [ a ] for a in a_s if cnt [ a ] == 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . p = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def insert ( root , add ) : <NEWLINE> <INDENT> parent = None <NEWLINE> pCandidate = root <NEWLINE> while pCandidate is not None : <NEWLINE> <INDENT> parent = pCandidate <NEWLINE> if add . key < pCandidate . key : <NEWLINE> <INDENT> pCandidate = pCandidate . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pCandidate = pCandidate . right <NEWLINE> <DEDENT> <DEDENT> add . p = parent <NEWLINE> <NL> if parent is None : <NEWLINE> <INDENT> root = add <NEWLINE> <DEDENT> elif add . key < parent . key : <NEWLINE> <INDENT> parent . left = add <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = add <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def inorderTreeWalk ( node ) : <NEWLINE> <INDENT> if node . left is not None : <NEWLINE> <INDENT> inorderTreeWalk ( node . left ) <NEWLINE> <DEDENT> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . right is not None : <NEWLINE> <INDENT> inorderTreeWalk ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorderTreeWalk ( node ) : <NEWLINE> <INDENT> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . left is not None : <NEWLINE> <INDENT> preorderTreeWalk ( node . left ) <NEWLINE> <DEDENT> if node . right is not None : <NEWLINE> <INDENT> preorderTreeWalk ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> root = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> root = insert ( root , Node ( int ( line [ 1 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inorderTreeWalk ( root ) <NEWLINE> print ( ) <NEWLINE> preorderTreeWalk ( root ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> l = list ( range ( 1 , k + 1 ) ) <NEWLINE> y = list ( itertools . combinations_with_replacement ( l , 3 ) ) <NEWLINE> n = len ( y ) <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = y [ i ] [ 0 ] <NEWLINE> b = y [ i ] [ 1 ] <NEWLINE> c = y [ i ] [ 2 ] <NEWLINE> d = math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> if a != b != c : <NEWLINE> <INDENT> t += d * 6 <NEWLINE> <DEDENT> elif a == b == c : <NEWLINE> <INDENT> t += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += d * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> dic [ i + a ] += 1 <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> counter += dic [ i - a ] <NEWLINE> <NL> <DEDENT> print ( counter ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> d = set ( [ ] ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command , string = input ( ) . split ( ) <NEWLINE> if ( command == <STRING> ) : <NEWLINE> <INDENT> d . add ( string ) <NEWLINE> <DEDENT> elif ( command == <STRING> ) : <NEWLINE> <INDENT> if string in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
from bisect import bisect_left <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in [ 0 ] * q : <NEWLINE> <INDENT> s1 , s2 = input ( ) , input ( ) <NEWLINE> l1 , l2 = len ( s1 ) , len ( s2 ) <NEWLINE> <NL> p = [ ] <NEWLINE> for i , c in enumerate ( s1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j = s2 [ s : ] . find ( c ) <NEWLINE> if j == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p . append ( ( i , s + j ) ) <NEWLINE> s += j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> lis = [ ] <NEWLINE> for _ , y in sorted ( p , key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) : <NEWLINE> <INDENT> i = bisect_left ( lis , y ) <NEWLINE> if len ( lis ) <= i : <NEWLINE> <INDENT> lis . append ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ i ] = y <NEWLINE> <DEDENT> <DEDENT> print ( len ( lis ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( N ) ] <NEWLINE> self . rank = [ 0 ] * N <NEWLINE> self . count = 0 <NEWLINE> self . _size = [ 1 ] * N <NEWLINE> <DEDENT> def root ( self , a ) : <NEWLINE> <INDENT> if self . parent [ a ] == a : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ a ] = self . root ( self . parent [ a ] ) <NEWLINE> return self . parent [ a ] <NEWLINE> <DEDENT> <DEDENT> def is_sama ( self , a , b ) : <NEWLINE> <INDENT> return self . root ( a ) == self . root ( b ) <NEWLINE> <DEDENT> def unite ( self , a , b ) : <NEWLINE> <INDENT> ra = self . root ( a ) <NEWLINE> rb = self . root ( b ) <NEWLINE> if ra == rb : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ ra ] < self . rank [ rb ] : <NEWLINE> <INDENT> self . parent [ ra ] = rb <NEWLINE> self . _size [ rb ] += self . _size [ ra ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ rb ] = ra <NEWLINE> if self . rank [ ra ] == self . rank [ rb ] : <NEWLINE> <INDENT> self . rank [ ra ] += 1 <NEWLINE> <DEDENT> self . _size [ ra ] += self . _size [ rb ] <NEWLINE> <DEDENT> self . count += 1 <NEWLINE> <DEDENT> def print_info ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . parent ) <NEWLINE> print ( <STRING> , self . rank ) <NEWLINE> print ( <STRING> , self . count ) <NEWLINE> print ( <STRING> , self . _size ) <NEWLINE> <DEDENT> def size ( self , a ) : <NEWLINE> <INDENT> return self . _size [ self . root ( a ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . unite ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> ans , n = 0 , len ( S ) <NEWLINE> dp = [ 0 ] * ( 2019 ) <NEWLINE> s , dp [ 0 ] , k = 0 , 1 , 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s = ( s + int ( S [ - i ] ) * k ) % 2019 <NEWLINE> k = ( k * 10 ) % 2019 <NEWLINE> ans += dp [ s ] <NEWLINE> dp [ s ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> i = 0 <NEWLINE> v = 0 <NEWLINE> for i in range ( int ( a ) ) : <NEWLINE> <INDENT> if ( ( int ( i ) + 1 ) % 3 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( i ) + 1 ) , end = <STRING> ) <NEWLINE> <DEDENT> elif ( ( int ( i ) + 1 ) % 10 ) == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( i ) + 1 ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( i ) + 1 <NEWLINE> while v == 0 : <NEWLINE> <NL> <INDENT> x = int ( x ) // 10 <NEWLINE> if ( int ( x ) > 10 ) and ( not ( int ( x ) % 10 ) == 3 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif ( int ( x ) % 10 ) == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( i ) + 1 ) , end = <STRING> ) <NEWLINE> v = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> v = 0 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> n , k = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> p = [ ( int ( x ) + 1 ) / 2 for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> m = sum ( p [ 0 : k ] ) <NEWLINE> maxm = m <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> m = m - p [ i - 1 ] + p [ i + k - 1 ] <NEWLINE> maxm = max ( [ maxm , m ] ) <NEWLINE> <NL> <DEDENT> print ( maxm ) <NEWLINE> <NL> <NL>
from collections import deque <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> Dh , Dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> M = [ <STRING> + input ( ) + <STRING> for _ in range ( h ) ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> M . insert ( 0 , <STRING> * ( w + 4 ) ) <NEWLINE> M . append ( <STRING> * ( w + 4 ) ) <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> cost = [ [ INF for _ in range ( w + 4 ) ] for _ in range ( h + 4 ) ] <NEWLINE> cost0 = deque ( ) <NEWLINE> ans = - 1 <NEWLINE> <NL> cost0 . append ( ( ch + 1 , cw + 1 , 0 ) ) <NEWLINE> cost [ ch + 1 ] [ cw + 1 ] = 0 <NEWLINE> <NL> move = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> warp = [ ( i , j ) for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if ( i , j ) not in [ ( 0 , 0 ) ] + move ] <NEWLINE> <NL> cost1 = deque ( ) <NEWLINE> <NL> while cost0 : <NEWLINE> <INDENT> h , w , c = cost0 . popleft ( ) <NEWLINE> cost1 . append ( ( h , w , c ) ) <NEWLINE> <NL> for i , j in move : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if M [ dh ] [ dw ] == <STRING> and c < cost [ dh ] [ dw ] : <COMMENT> <NEWLINE> <INDENT> cost [ dh ] [ dw ] = c <NEWLINE> cost0 . appendleft ( ( dh , dw , cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( cost0 ) == 0 : <NEWLINE> <INDENT> while cost1 : <NEWLINE> <INDENT> h , w , c = cost1 . popleft ( ) <NEWLINE> for i , j in warp : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if M [ dh ] [ dw ] == <STRING> and c + 1 < cost [ dh ] [ dw ] : <COMMENT> <NEWLINE> <INDENT> cost [ dh ] [ dw ] = c + 1 <NEWLINE> cost0 . append ( ( dh , dw , cost [ dh ] [ dw ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cost [ Dh + 1 ] [ Dw + 1 ] != INF : <NEWLINE> <INDENT> ans = cost [ Dh + 1 ] [ Dw + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> candidates = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if h [ x - 1 ] <= h [ y - 1 ] : <NEWLINE> <INDENT> candidates [ x ] = False <NEWLINE> <DEDENT> if h [ x - 1 ] >= h [ y - 1 ] : <NEWLINE> <INDENT> candidates [ y ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> is_highest = candidates . get ( i , True ) <NEWLINE> if is_highest : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def get_sum_arr ( arr ) : <NEWLINE> <INDENT> sum_arr = [ 0 ] <NEWLINE> N = len ( arr ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum_arr . append ( sum_arr [ i - 1 ] + arr [ i - 1 ] ) <NEWLINE> <DEDENT> return sum_arr <NEWLINE> <NL> <DEDENT> def get_max_b ( left_time , j , B_sum_arr ) : <NEWLINE> <COMMENT> <NL> <INDENT> while B_sum_arr [ j ] > left_time and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> return j <NEWLINE> <DEDENT> def get_max_book_num ( A , B , K ) : <NEWLINE> <INDENT> A_sum_arr , B_sum_arr = get_sum_arr ( A ) , get_sum_arr ( B ) <NEWLINE> count , i , j = 0 , 0 , len ( B_sum_arr ) - 1 <NEWLINE> for i in range ( 0 , len ( A_sum_arr ) ) : <NEWLINE> <INDENT> if K < A_sum_arr [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_time = K - A_sum_arr [ i ] <NEWLINE> j = get_max_b ( left_time , j , B_sum_arr ) <NEWLINE> <DEDENT> count = max ( count , ( i + j ) ) <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( get_max_book_num ( A , B , K ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x - n ) <NEWLINE>
x = [ ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( len ( x ) - 1 ) : <NEWLINE> <INDENT> print ( x [ i ] . swapcase ( ) , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( x [ len ( x ) - 1 ] . swapcase ( ) ) <NEWLINE>
import sys <NEWLINE> from itertools import combinations <NEWLINE> <NL> <COMMENT> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> self . n = n <NEWLINE> self . inconvenience = n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> self . inconvenience -= d1 * d2 <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bridges = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ans = [ 0 ] * m <NEWLINE> ans [ - 1 ] = n * ( n - 1 ) // 2 <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> uf . union ( * bridges [ i + 1 ] ) <NEWLINE> ans [ i ] = uf . inconvenience <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = - 1 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> b = ( 10 * b + 7 ) % K <NEWLINE> if ( b == 0 ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( c [ j ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def mod_pow ( x , mod ) : <NEWLINE> <INDENT> xx = [ 1 , x ] <NEWLINE> def _pow ( y , x = x ) : <NEWLINE> <INDENT> nonlocal xx <NEWLINE> if y == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> while len ( xx ) <= math . log ( y , 2 ) + 1 : <NEWLINE> <INDENT> v = xx [ - 1 ] * xx [ - 1 ] <NEWLINE> v %= mod <NEWLINE> xx . append ( v ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> result = 1 <NEWLINE> while y > 0 : <NEWLINE> <INDENT> if y % 2 == 1 : <NEWLINE> <INDENT> result *= xx [ i ] <NEWLINE> result %= mod <NEWLINE> <DEDENT> y = y >> 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> return _pow <NEWLINE> <NL> <DEDENT> pow10 = mod_pow ( 10 , MOD ) <NEWLINE> pow9 = mod_pow ( 9 , MOD ) <NEWLINE> pow8 = mod_pow ( 8 , MOD ) <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> ans = pow10 ( n ) - ( 2 * pow9 ( n ) - pow8 ( n ) ) <NEWLINE> ans %= MOD <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = f ( N ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ input ( ) . split ( ) for l in range ( M ) ] <NEWLINE> tot_1 = min ( a ) + min ( b ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tot = a [ int ( x [ i ] [ 0 ] ) - 1 ] + b [ int ( x [ i ] [ 1 ] ) - 1 ] - int ( x [ i ] [ 2 ] ) <NEWLINE> lis . append ( tot ) <NEWLINE> <DEDENT> if tot_1 <= min ( lis ) : <NEWLINE> <INDENT> print ( tot_1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( lis ) ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> product = arr [ 0 ] <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> product = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> product *= arr [ i ] <NEWLINE> if product > ( 10 ** 18 ) : <NEWLINE> <INDENT> product = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( product ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> def get_count_list ( s ) : <NEWLINE> <INDENT> alphabets = <STRING> <NEWLINE> ans = { } <NEWLINE> for alphabet in alphabets : <NEWLINE> <INDENT> ans [ alphabet ] = [ ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ s [ i ] ] . append ( i ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def get_index2alpha ( s ) : <NEWLINE> <INDENT> ans = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = s [ i ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> s_count = get_count_list ( s ) <NEWLINE> t_count = get_count_list ( t ) <NEWLINE> s_index = get_index2alpha ( s ) <NEWLINE> t_index = get_index2alpha ( t ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> s_set = set ( s ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s_alpha = s_index [ i ] <NEWLINE> t_alpha = t_index [ i ] <NEWLINE> if s_alpha in s_set : <NEWLINE> <INDENT> s_set . remove ( s_alpha ) <NEWLINE> if not s_count [ s_alpha ] == t_count [ t_alpha ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> count = 0 <NEWLINE> flag = 1 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if l [ j - 1 ] > l [ j ] : <NEWLINE> <INDENT> l [ j - 1 ] , l [ j ] = l [ j ] , l [ j - 1 ] <NEWLINE> count += 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( list ( map ( str , l ) ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def IsPrime ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 2 or n == 3 or n == 5 : return True <NEWLINE> if n == 1 or n % 2 == 0 or n % 3 == 0 : return False <NEWLINE> d , l = 5 , int ( n ** ( 1 / 2 ) ) <NEWLINE> while d <= l : <NEWLINE> <INDENT> if n % d == 0 or n % ( d + 2 ) == 0 : return False <NEWLINE> d += 6 <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if IsPrime ( int ( input ( ) ) ) : c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> dic_A = dict ( ) <NEWLINE> sum_A = sum ( A ) <NEWLINE> ans = list ( ) <NEWLINE> tmp = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i in dic_A : <NEWLINE> <INDENT> dic_A [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_A [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> if B [ j ] [ 0 ] in dic_A : <NEWLINE> <INDENT> tmp = sum_A + dic_A [ B [ j ] [ 0 ] ] * ( B [ j ] [ 1 ] - B [ j ] [ 0 ] ) <NEWLINE> ans . append ( tmp ) <NEWLINE> sum_A = tmp <NEWLINE> if B [ j ] [ 1 ] not in dic_A : <NEWLINE> <INDENT> dic_A [ B [ j ] [ 1 ] ] = dic_A [ B [ j ] [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_A [ B [ j ] [ 1 ] ] += dic_A [ B [ j ] [ 0 ] ] <NEWLINE> <DEDENT> dic_A [ B [ j ] [ 0 ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tmp == 0 : <NEWLINE> <INDENT> ans . append ( sum_A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in ans : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xl = list ( reversed ( l ) ) <NEWLINE> g = [ ] <NEWLINE> a = 1 <NEWLINE> k = 0 <NEWLINE> f = 0 <NEWLINE> for i in xl : <NEWLINE> <INDENT> k += i <NEWLINE> g . append ( k ) <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> for i in range ( len ( g ) ) : <NEWLINE> <INDENT> if g [ i ] >= a : <NEWLINE> <INDENT> g [ i ] = a <NEWLINE> <DEDENT> a -= l [ i ] <NEWLINE> a *= 2 <NEWLINE> if a <= 0 and i != len ( g ) - 1 : <NEWLINE> <INDENT> f += 1 <NEWLINE> break <NEWLINE> <DEDENT> if a < 0 and i == len ( g ) - 1 : <NEWLINE> <INDENT> f += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 and n != 0 : <NEWLINE> <INDENT> print ( sum ( g ) ) <NEWLINE> <DEDENT> elif n == 0 : <NEWLINE> <INDENT> if l [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> suma = sum ( A ) <NEWLINE> counter = Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> suma = counter [ b ] * ( c - b ) + suma <NEWLINE> print ( suma ) <NEWLINE> if b in counter : <NEWLINE> <INDENT> if c in counter : <NEWLINE> <INDENT> counter [ c ] += counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ c ] = counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> def bfs ( u ) : <NEWLINE> <INDENT> queue = deque ( [ u ] ) <NEWLINE> d = [ None ] * n <COMMENT> <NEWLINE> d [ u ] = 0 <COMMENT> <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = v <NEWLINE> queue . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> d = bfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( d [ i ] + 1 ) <NEWLINE> <DEDENT>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 2 * x and h == 2 * y : <NEWLINE> <INDENT> print ( w * h / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> w = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> cnt = N + 1 <NEWLINE> tmp = w <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> cnt = min ( cnt , tmp ) <NEWLINE> <NL> <DEDENT> ans = min ( w , b , cnt ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i + j + j >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s1 = s [ i ] <NEWLINE> s2 = s [ i + j ] <NEWLINE> s3 = s [ i + j * 2 ] <NEWLINE> if s1 != s2 and s2 != s3 and s1 != s3 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ABC = [ ] <NEWLINE> Adake = [ [ ] for _ in range ( N ) ] <NEWLINE> Bdake = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC . append ( ( a - 1 , b - 1 , - c ) ) <NEWLINE> Adake [ a - 1 ] . append ( b - 1 ) <NEWLINE> Bdake [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( X , s ) : <NEWLINE> <INDENT> used = { s } <NEWLINE> search = deque ( [ s ] ) <NEWLINE> while search : <NEWLINE> <INDENT> ss = search . pop ( ) <NEWLINE> for sss in X [ ss ] : <NEWLINE> <INDENT> if sss in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( sss ) <NEWLINE> search . append ( sss ) <NEWLINE> <DEDENT> <DEDENT> return used <NEWLINE> <NL> <DEDENT> U = dfs ( Adake , 0 ) & dfs ( Bdake , N - 1 ) <NEWLINE> ABC = [ ( a , b , c ) for ( a , b , c ) in ABC if a in U and b in U ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> dist = [ INF ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for a , b , c in ABC : <NEWLINE> <INDENT> if dist [ b ] > dist [ a ] + c : <NEWLINE> <INDENT> dist [ b ] = dist [ a ] + c <NEWLINE> if i == N - 1 and b == N - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - dist [ - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> num_of_matches = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> val = - 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> if i - num_of_matches [ aa ] < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i - num_of_matches [ aa ] == 0 : <NEWLINE> <INDENT> val = 1 <NEWLINE> <DEDENT> elif dp [ i - num_of_matches [ aa ] ] > 0 : <NEWLINE> <INDENT> val = max ( val , dp [ i - num_of_matches [ aa ] ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = val <NEWLINE> <NL> <DEDENT> res = <STRING> <NEWLINE> remain = dp [ n ] <NEWLINE> match = n <NEWLINE> while match > 0 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if match - num_of_matches [ a [ i ] ] >= 0 and remain - 1 == dp [ match - num_of_matches [ a [ i ] ] ] : <NEWLINE> <INDENT> match -= num_of_matches [ a [ i ] ] <NEWLINE> remain -= 1 <NEWLINE> res += str ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> n = [ i for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) ] <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> for j in n : <NEWLINE> <INDENT> if j % i == 0 and j / i != 1 : <NEWLINE> <INDENT> n . remove ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while x > 0 : <NEWLINE> <INDENT> for i in n : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> check = ( 0 in A ) <NEWLINE> if check : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
r , g , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n + 1 , r ) : <NEWLINE> <INDENT> for j in range ( 0 , n + 1 , g ) : <NEWLINE> <INDENT> if i + j <= n : <NEWLINE> <INDENT> if ( n - ( i + j ) ) % b == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> c = list ( itertools . combinations_with_replacement ( list ( range ( 1 , M + 1 ) ) , N ) ) <NEWLINE> <NL> m = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> flag = True <NEWLINE> sum = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> sum += j [ 3 ] <NEWLINE> <DEDENT> <DEDENT> m = max ( m , sum ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
class prime_factorize_by_osa_k ( ) : <NEWLINE> <INDENT> def __init__ ( self , max_val ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . minFactor = [ - 1 ] * ( max_val + 1 ) <NEWLINE> for i in range ( 2 , max_val + 1 ) : <NEWLINE> <INDENT> if self . minFactor [ i ] == - 1 : <NEWLINE> <INDENT> self . minFactor [ i ] = i <NEWLINE> <COMMENT> <NL> for j in range ( i * i , max_val + 1 , i ) : <NEWLINE> <INDENT> if self . minFactor [ j ] == - 1 : <NEWLINE> <INDENT> self . minFactor [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def osa_k ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> now = n <NEWLINE> while now > 1 : <NEWLINE> <INDENT> d [ self . minFactor [ now ] ] += 1 <NEWLINE> now //= self . minFactor [ now ] <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ob = prime_factorize_by_osa_k ( 10 ** 6 ) <NEWLINE> pairwise = False <NEWLINE> prime_key = set ( ob . osa_k ( A [ - 1 ] ) . keys ( ) ) <NEWLINE> break_flag = False <NEWLINE> prime_flags = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for key in ob . osa_k ( A [ i ] ) . keys ( ) : <NEWLINE> <INDENT> if prime_flags [ key ] : <NEWLINE> <INDENT> break_flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime_flags [ key ] = True <NEWLINE> <DEDENT> <DEDENT> if break_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pairwise = True <NEWLINE> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> work = gcd ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> work = gcd ( work , A [ i ] ) <NEWLINE> <DEDENT> if work != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> fishes = defaultdict ( int ) <NEWLINE> zero_zero = 0 <NEWLINE> zero = 0 <NEWLINE> inf = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero_zero += 1 <NEWLINE> <NL> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <NL> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> inf += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> div = gcd ( a , b ) <NEWLINE> a //= div <NEWLINE> b //= div <NEWLINE> if b < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> key = ( a , b ) <NEWLINE> fishes [ key ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_bad_pair ( fish ) : <NEWLINE> <INDENT> a , b = fish <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> return ( - b , a ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> counted_key = set ( ) <NEWLINE> for fish_key , count in fishes . items ( ) : <NEWLINE> <INDENT> if fish_key in counted_key : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> bad_pair = get_bad_pair ( fish_key ) <NEWLINE> if bad_pair in fishes : <NEWLINE> <INDENT> pair_count = fishes [ bad_pair ] <NEWLINE> pattern = pow ( 2 , count , mod ) + pow ( 2 , pair_count , mod ) - 1 <NEWLINE> counted_key . add ( bad_pair ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pattern = pow ( 2 , count , mod ) <NEWLINE> <NL> <DEDENT> ans = ans * pattern % mod <NEWLINE> <NL> <DEDENT> ans *= pow ( 2 , zero , mod ) + pow ( 2 , inf , mod ) - 1 <NEWLINE> if zero_zero : <NEWLINE> <INDENT> ans += zero_zero <NEWLINE> <NL> <DEDENT> ans -= 1 <NEWLINE> print ( ans % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def dfs ( upper , lower , left , right , cnt ) : <NEWLINE> <NL> <INDENT> if cnt == 1 : <NEWLINE> <INDENT> ans [ upper : lower , left : right ] = np . max ( ans [ upper : lower , left : right ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> elif cnt != max ( cntrow [ upper : lower ] ) : <NEWLINE> <INDENT> for i in range ( upper , lower ) : <NEWLINE> <INDENT> if cntrow [ i ] : <NEWLINE> <INDENT> ncnt = sum ( cntrow [ upper : i + 1 ] ) <NEWLINE> dfs ( upper , i + 1 , left , right , ncnt ) <NEWLINE> dfs ( i + 1 , lower , left , right , cnt - ncnt ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = cntrow [ upper : lower ] . index ( cnt ) + upper <NEWLINE> for j in range ( left , right ) : <NEWLINE> <INDENT> if g [ idx ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( upper , lower , left , j + 1 , 1 ) <NEWLINE> cntrow [ idx ] -= 1 <NEWLINE> dfs ( upper , lower , j + 1 , right , cnt - 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ <STRING> ] * h <NEWLINE> ans = np . zeros ( shape = ( h , w ) , dtype = int ) <NEWLINE> cnt = 1 <NEWLINE> cntrow = [ 0 ] * h <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> g [ i ] = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if g [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i , j ] = cnt <NEWLINE> cntrow [ i ] += 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , h , 0 , w , k ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( * ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <NL> <NL> def gcd ( n , m ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a , b = n , m <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while a != 0 : <NEWLINE> <INDENT> a , b = b % a , a <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += 6 * gcd ( k , gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> count = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if a % K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = ( a * 10 + 7 ) % K <NEWLINE> count += 1 <NEWLINE> <DEDENT> if count == K + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop = [ ] <NEWLINE> mark = [ <STRING> ] * n <NEWLINE> i = 0 <NEWLINE> loop . append ( 1 ) <NEWLINE> mark [ 0 ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if mark [ lst [ i ] - 1 ] != <STRING> : <NEWLINE> <INDENT> start = mark [ lst [ i ] - 1 ] <NEWLINE> last = mark [ i ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mark [ lst [ i ] - 1 ] = mark [ i ] + 1 <NEWLINE> loop . append ( lst [ i ] ) <NEWLINE> <DEDENT> i = lst [ i ] - 1 <NEWLINE> <NL> <NL> <DEDENT> loop_len = last - start + 1 <NEWLINE> loop_num = loop [ start : last + 1 ] <NEWLINE> first = start - 1 <NEWLINE> <NL> if k <= first : <NEWLINE> <INDENT> print ( loop [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = ( k - first ) % loop_len <NEWLINE> print ( loop_num [ q - 1 ] ) <NEWLINE> <NL> <DEDENT>
s = str ( input ( ) ) <NEWLINE> n = len ( s ) - 7 <NEWLINE> for i in range ( n , len ( s ) ) : <NEWLINE> <INDENT> if s [ : i - n ] + s [ i : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
( h , n ) , * c = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> dp = [ 0 ] * 20002 <NEWLINE> for i in range ( h ) : dp [ i ] = min ( dp [ i - a ] + b for a , b in c ) <NEWLINE> print ( dp [ h - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def update ( dic , b , c ) : <NEWLINE> <INDENT> n = dic . pop ( b ) <NEWLINE> dic [ c ] = n + dic . get ( c , 0 ) <NEWLINE> <NL> <DEDENT> def calc_diff ( dic , b , c ) : <NEWLINE> <INDENT> if dic . get ( b ) : <NEWLINE> <INDENT> return c * dic [ b ] - b * dic [ b ] <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def calc_total ( dic ) : <NEWLINE> <INDENT> return sum ( k * v for k , v in dic . items ( ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = dict ( Counter ( lis ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> total = calc_total ( dic ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = calc_diff ( dic , B , C ) <NEWLINE> total += diff <NEWLINE> print ( total ) <NEWLINE> if diff : <NEWLINE> <INDENT> update ( dic , B , C ) <NEWLINE> <DEDENT> <DEDENT>
import random <NEWLINE> import time <NEWLINE> import numpy as np <NEWLINE> <NL> def decrease ( day , schedule , c , s , satisfy ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> date = [ 0 ] * 26 <NEWLINE> <NL> for d in range ( day ) : <NEWLINE> <INDENT> now = schedule [ d ] + 1 <NEWLINE> date [ now - 1 ] = d + 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> tmp += c [ i ] * ( now - date [ i ] ) <NEWLINE> <DEDENT> ret += tmp <NEWLINE> satisfy . append ( tmp ) <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def change ( _from , _to , schedule , c , s , satisfy ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> date = [ 0 ] * 26 <NEWLINE> <NL> for d in range ( _to ) : <NEWLINE> <INDENT> if d < _from : <NEWLINE> <INDENT> ret += satisfy [ d ] <NEWLINE> continue <NEWLINE> <NL> <DEDENT> now = schedule [ d ] + 1 <NEWLINE> date [ now - 1 ] = d + 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> tmp += c [ i ] * ( now - date [ i ] ) <NEWLINE> <DEDENT> ret += tmp <NEWLINE> satisfy [ d ] = tmp <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> dissatisfy = [ ] <NEWLINE> schedule = [ ] <NEWLINE> score = 0 <NEWLINE> start = time . time ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( D ) : <NEWLINE> <INDENT> schedule . append ( np . argmax ( s [ i ] ) ) <NEWLINE> score += np . max ( s [ i ] ) <NEWLINE> <NL> <DEDENT> ans = score - decrease ( D , schedule , c , s , dissatisfy ) <NEWLINE> <NL> while time . time ( ) - start < 1.8 : <NEWLINE> <INDENT> contest = random . randint ( 0 , 25 ) <NEWLINE> day = random . randint ( 0 , D - 1 ) <NEWLINE> save = dissatisfy . copy ( ) <NEWLINE> dec = change ( day + 1 , D , schedule , c , s , dissatisfy ) <NEWLINE> score2 = score - s [ day ] [ schedule [ day ] ] + s [ day ] [ contest ] <NEWLINE> <NL> if ans < score2 - dec : <NEWLINE> <INDENT> ans = score2 - dec <NEWLINE> score = score2 <NEWLINE> schedule [ day ] = contest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dissatisfy = save <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( schedule [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j + i <= N : <NEWLINE> <INDENT> A . append ( S [ j : j + i ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> A = list ( set ( A ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ K - 1 ] ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from collections import deque <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> path = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> visited = [ ] <NEWLINE> que = deque ( [ [ 1 , 1 ] ] ) <COMMENT> <NEWLINE> que_items = set ( [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> now , prev = que . popleft ( ) <NEWLINE> <COMMENT> <NL> for can_go in path [ now ] : <NEWLINE> <INDENT> if ( not ( can_go in que_items ) ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> que . append ( [ can_go , now ] ) <NEWLINE> que_items . add ( can_go ) <NEWLINE> <DEDENT> <DEDENT> ans [ now ] = prev <NEWLINE> visited . append ( now ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if ( len ( visited ) != n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for _ans in ans [ 2 : ] : <NEWLINE> <INDENT> print ( _ans ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , = map ( int , readline ( ) . split ( ) ) <NEWLINE> * a , = map ( lambda x : 2 * int ( x ) , readline ( ) . split ( ) ) <NEWLINE> * b , = map ( lambda x : 2 * int ( x ) + 1 , readline ( ) . split ( ) ) <NEWLINE> <NL> c = sorted ( a + b ) <NEWLINE> res = [ ] <NEWLINE> aa = [ ] <NEWLINE> bb = [ ] <NEWLINE> for x , y in zip ( c [ : n ] , c [ n : ] ) : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> if y % 2 == 0 : <NEWLINE> <INDENT> aa . append ( ( x // 2 , y // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( ( x // 2 , y // 2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y % 2 == 0 : <NEWLINE> <INDENT> res . append ( ( y // 2 , x // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb . append ( ( x // 2 , y // 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while aa : <NEWLINE> <INDENT> p , q = aa . pop ( ) <NEWLINE> r , s = bb . pop ( ) <NEWLINE> if p != r and q != s : <NEWLINE> <INDENT> res . append ( ( p , r ) ) <NEWLINE> res . append ( ( q , s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( ( p , s ) ) <NEWLINE> res . append ( ( q , r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> from operator import itemgetter <NEWLINE> res . sort ( key = itemgetter ( 0 ) ) <NEWLINE> <NL> for x , y in res : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> ans = [ y for x , y in res ] <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from bisect import bisect_left <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> stop = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , t , x = map ( int , input ( ) . split ( ) ) <NEWLINE> stop . append ( ( s , t , x ) ) <NEWLINE> <DEDENT> stop . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> d = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> R = [ - 1 ] * q <NEWLINE> ans = [ - 1 ] * q <NEWLINE> for s , t , x in stop : <NEWLINE> <COMMENT> <NL> <INDENT> l = bisect_left ( d , s - x ) <NEWLINE> r = bisect_left ( d , t - x ) <NEWLINE> while l < r : <NEWLINE> <INDENT> if R [ l ] == - 1 : <COMMENT> <NEWLINE> <INDENT> ans [ l ] = x <NEWLINE> R [ l ] = r <NEWLINE> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = R [ l ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> <NL> for a in range ( A + 1 ) : <NEWLINE> <INDENT> a_total = a * 500 <NEWLINE> for b in range ( B + 1 ) : <NEWLINE> <INDENT> b_total = b * 100 <NEWLINE> for c in range ( C + 1 ) : <NEWLINE> <INDENT> c_total = c * 50 <NEWLINE> total_amount = ( a_total + b_total + c_total ) <NEWLINE> if X == total_amount : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> sl = [ i for i in s ] <NEWLINE> pl = [ i for i in p ] <NEWLINE> lenp = len ( p ) <NEWLINE> pp = pl [ - 1 ] <NEWLINE> el = [ i for i , x in enumerate ( sl ) if x == pp ] <NEWLINE> check = 0 <NEWLINE> for i in el : <NEWLINE> <INDENT> pcheck = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if sl [ i ] == pl [ pcheck ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> pcheck -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if pcheck + lenp <= 0 : <NEWLINE> <INDENT> check += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if check == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
order = int ( input ( ) ) <NEWLINE> data = set ( [ ] ) <NEWLINE> <NL> for i in range ( order ) : <NEWLINE> <INDENT> data . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( data ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ False ] * N <NEWLINE> l = 0 <NEWLINE> r = N + 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> while True : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> if r - l == N // 2 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if f [ min ( r - l , N - ( r - l ) ) ] : <NEWLINE> <INDENT> r -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> f [ min ( r - l , N - ( r - l ) ) ] = True <NEWLINE> print ( l , r ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in A : <NEWLINE> <INDENT> res = res * num <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> D [ a - 1 ] . append ( b ) <NEWLINE> D [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> dist = [ 0 for i in range ( N ) ] <NEWLINE> prev = [ 0 for i in range ( N ) ] <NEWLINE> prev [ 0 ] == 1 <NEWLINE> <NL> q = queue . Queue ( ) <NEWLINE> q . put ( 1 ) <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> t = q . get ( ) <NEWLINE> for i in D [ t - 1 ] : <NEWLINE> <INDENT> if prev [ i - 1 ] == 0 : <NEWLINE> <INDENT> prev [ i - 1 ] = t <NEWLINE> q . put ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in prev [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def solve ( m , A ) : <NEWLINE> <INDENT> if A [ 0 ] == m : return True <NEWLINE> if len ( A ) == 1 : return False <NEWLINE> if m < A [ 0 ] : return solve ( m , A [ 1 : ] ) <NEWLINE> if solve ( m - A [ 0 ] , A [ 1 : ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return solve ( m , A [ 1 : ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for m in Q : <NEWLINE> <INDENT> if m > sum ( A ) : print ( <STRING> ) <NEWLINE> elif solve ( m , A ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> r0 = int ( input ( ) ) <NEWLINE> r1 = int ( input ( ) ) <NEWLINE> p = r1 - r0 <NEWLINE> r = min ( r0 , r1 ) <NEWLINE> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> if p < i - r : <NEWLINE> <INDENT> p = i - r <NEWLINE> <DEDENT> if r > i : <NEWLINE> <INDENT> r = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> total = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = True <NEWLINE> high = 1 * ( 10 ** 18 ) + 1 <NEWLINE> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> total *= A [ i ] <NEWLINE> if high <= total : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> for i in a [ 2 : ] : x ^= i <NEWLINE> m = ( a [ 0 ] + a [ 1 ] - x ) // 2 <NEWLINE> if a [ 0 ] + a [ 1 ] != x + m * 2 or m > a [ 0 ] or ( x & m ) != 0 : exit ( print ( - 1 ) ) <NEWLINE> l = 1 << ( max ( x . bit_length ( ) , m . bit_length ( ) ) + 1 ) <NEWLINE> while l > 0 : <NEWLINE> <INDENT> if ( ( x & l ) != 0 ) and ( ( m | l ) <= a [ 0 ] ) : m |= l <NEWLINE> l >>= 1 <NEWLINE> <DEDENT> print ( a [ 0 ] - m if m != 0 else - 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> X_list = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> sorted_x = sorted ( X_list ) <NEWLINE> <NL> left = sorted_x [ ( N // 2 ) - 1 ] <NEWLINE> right = sorted_x [ N // 2 ] <NEWLINE> for x in X_list : <NEWLINE> <INDENT> if x <= left : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . li = [ i for i in range ( n + 1 ) ] <NEWLINE> self . group = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> while self . li [ x ] != x : <NEWLINE> <INDENT> x = self . li [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return ; <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> self . li [ y ] = x <NEWLINE> self . group [ x ] += self . group [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . li [ x ] = y <NEWLINE> self . group [ y ] += self . group [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x = unionfind ( n ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x . union ( a , b ) <NEWLINE> <DEDENT> print ( max ( x . group ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> limit = 10 ** 18 <NEWLINE> sum = 1 <NEWLINE> <NL> if 0 in A_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A_list : <NEWLINE> <INDENT> sum = sum * i <NEWLINE> if sum > limit : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> aa = X // D <NEWLINE> <NL> if K < aa : <NEWLINE> <INDENT> X -= K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - aa ) % 2 == 1 : <NEWLINE> <INDENT> X -= ( aa + 1 ) * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X -= aa * D <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( X ) ) <NEWLINE>
while True : <NEWLINE> <NL> <INDENT> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> line1 , line2 = <STRING> , <STRING> <NEWLINE> line3 , line4 = <STRING> , <STRING> <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif W % 2 == 0 : <NEWLINE> <INDENT> for i in range ( W // 2 ) : <NEWLINE> <INDENT> line1 += <STRING> <NEWLINE> line2 += <STRING> <NEWLINE> <DEDENT> if H % 2 == 0 : <NEWLINE> <INDENT> for i in range ( H // 2 ) : <NEWLINE> <INDENT> print ( line1 ) <NEWLINE> print ( line2 ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( line1 ) <NEWLINE> for i in range ( H // 2 ) : <NEWLINE> <INDENT> print ( line2 ) <NEWLINE> print ( line1 ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( W // 2 ) : <NEWLINE> <INDENT> line3 += <STRING> <NEWLINE> line4 += <STRING> <NEWLINE> <DEDENT> if H % 2 == 0 : <NEWLINE> <INDENT> for i in range ( H // 2 ) : <NEWLINE> <INDENT> print ( line3 ) <NEWLINE> print ( line4 ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( line3 ) <NEWLINE> for i in range ( H // 2 ) : <NEWLINE> <INDENT> print ( line4 ) <NEWLINE> print ( line3 ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> _n = int ( x ** .2 ) <NEWLINE> for n in range ( _n - 2 , _n + 3 ) : <NEWLINE> <INDENT> if n ** 5 == x : <NEWLINE> <INDENT> print ( n , 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if x - i ** 5 < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> _n = int ( ( x - i ** 5 ) ** .2 ) <NEWLINE> for n in range ( _n - 2 , _n + 3 ) : <NEWLINE> <INDENT> if n ** 5 == ( x - i ** 5 ) : <NEWLINE> <INDENT> print ( i , - n ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> fif = x + i ** 5 <NEWLINE> _n = int ( fif ** .2 ) <NEWLINE> for n in range ( _n - 2 , _n + 3 ) : <NEWLINE> <INDENT> if n ** 5 == fif : <NEWLINE> <INDENT> print ( n , i ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lotteries = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> lotteries . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( lotteries ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for e in a : <NEWLINE> <INDENT> d [ e - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for i in range ( 200000 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ x - 1 ] . append ( y + 99999 ) <NEWLINE> edges [ y + 99999 ] . append ( x - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> visited = [ 0 ] * ( 200000 ) <NEWLINE> cntx , cnty = 0 , 0 <NEWLINE> def dfs ( u ) : <NEWLINE> <INDENT> global cntx , cnty <NEWLINE> visited [ u ] = 1 <NEWLINE> if u // 100000 >= 1 : <NEWLINE> <INDENT> cnty += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cntx += 1 <NEWLINE> <DEDENT> for i in edges [ u ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = - 1 * n <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> cntx , cnty = 0 , 0 <NEWLINE> dfs ( i ) <NEWLINE> ans += cntx * cnty <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> count = x // d <NEWLINE> if count > k : <NEWLINE> <INDENT> ans = x - ( k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == count % 2 : <NEWLINE> <INDENT> ans = x - ( count * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x - ( count + 1 ) * d <NEWLINE> <DEDENT> <DEDENT> print ( abs ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> S = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> S += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if S % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A = il ( ) <NEWLINE> o , t , f = 0 , 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % 4 == 0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> elif a % 2 == 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> <DEDENT> if t > 0 : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> print ( <STRING> if o <= f + 1 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rests = [ ] <NEWLINE> rest_sum = 0 <NEWLINE> for i in reversed ( nums ) : <NEWLINE> <INDENT> rest_sum += i <NEWLINE> rests . append ( rest_sum ) <NEWLINE> <NL> <DEDENT> sum_num = 0 <NEWLINE> for i in range ( len ( nums ) - 1 ) : <NEWLINE> <INDENT> sum_num += nums [ i ] * rests [ - ( i + 2 ) ] <NEWLINE> if sum_num > 10 ** 9 + 7 : <NEWLINE> <INDENT> sum_num = sum_num % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( sum_num ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A1 = [ ] <NEWLINE> A2 = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A1 . append ( i + A [ i ] ) <NEWLINE> A2 . append ( i - A [ i ] ) <NEWLINE> <NL> <DEDENT> C_A1 = collections . Counter ( A1 ) <NEWLINE> C_A2 = collections . Counter ( A2 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += C_A1 [ i ] * C_A2 [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> A = max ( a ) <NEWLINE> b = [ 0 ] * A <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if b [ a [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> for j in range ( a [ i ] , A + 1 , a [ i ] ) : <NEWLINE> <INDENT> b [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif b [ a [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> n = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if b [ a [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> table = [ True ] * 1000001 <NEWLINE> count = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> pp = a [ i ] <NEWLINE> if table [ pp ] == True : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if pp != a [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> for j in range ( pp , 1000001 , pp ) : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> <DEDENT> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> if pp != a [ n - 2 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if pp != a [ i + 1 ] and pp != a [ i - 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> for j in range ( pp , 1000001 , pp ) : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections as c <NEWLINE> n = [ c . Counter ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] ; r = n [ 0 ] <NEWLINE> for i in range ( 1 , len ( n ) ) : r = r & n [ i ] <NEWLINE> print ( * sorted ( [ i * j for i , j in r . items ( ) ] ) , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> NoValue = - 1 <NEWLINE> Prev = 0 <NEWLINE> Next = 1 <NEWLINE> Value = 2 <NEWLINE> <NL> class Dlist : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . items = [ 0 ] * 2000000 <NEWLINE> self . clear ( ) <NEWLINE> <NL> <DEDENT> def clear ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . si = NoValue <NEWLINE> self . ei = NoValue <NEWLINE> self . pos = NoValue <NEWLINE> self . uniqid = 0 <NEWLINE> self . cnt = 0 <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> n = NoValue <NEWLINE> if self . cnt == 0 : <COMMENT> <NEWLINE> <INDENT> self . ei = self . uniqid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . items [ self . si ] [ Prev ] = self . uniqid <NEWLINE> n = self . si <NEWLINE> <DEDENT> self . items [ self . uniqid ] = [ NoValue , n , x ] <NEWLINE> self . si = self . uniqid <NEWLINE> self . uniqid += 1 <NEWLINE> self . cnt += 1 <NEWLINE> <NL> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if self . cnt > 0 : <NEWLINE> <INDENT> hit = False <NEWLINE> i = self . si <NEWLINE> while hit == False : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if self . items [ i ] [ Value ] == x : <NEWLINE> <INDENT> hit = True <NEWLINE> if i == self . si : <NEWLINE> <INDENT> self . deleteFirst ( ) <COMMENT> <NEWLINE> <DEDENT> elif i == self . ei : <NEWLINE> <INDENT> self . deleteLast ( ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = self . items [ i ] [ Prev ] <NEWLINE> n = self . items [ i ] [ Next ] <NEWLINE> self . items [ n ] [ Prev ] = p <NEWLINE> self . items [ p ] [ Next ] = n <NEWLINE> <COMMENT> <NL> self . cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = self . items [ i ] [ Next ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . cnt < 2 : <NEWLINE> <INDENT> self . clear ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = self . items [ self . si ] [ Next ] <NEWLINE> if n != NoValue : <NEWLINE> <INDENT> self . items [ n ] [ Prev ] = NoValue <NEWLINE> <COMMENT> <NL> <DEDENT> self . si = n <NEWLINE> self . cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . cnt < 2 : <NEWLINE> <INDENT> self . clear ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = self . items [ self . ei ] [ Prev ] <NEWLINE> if p != - 1 : <NEWLINE> <INDENT> self . items [ p ] [ Next ] = NoValue <NEWLINE> <COMMENT> <NL> <DEDENT> self . ei = p <NEWLINE> self . cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def getList ( self ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> if self . cnt > 0 : <NEWLINE> <INDENT> i = self . si <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> a . append ( self . items [ i ] [ Value ] ) <NEWLINE> i = self . items [ i ] [ Next ] <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> cmds = list ( istr . splitlines ( ) ) <NEWLINE> dl = Dlist ( ) <NEWLINE> <NL> for i in cmds : <NEWLINE> <INDENT> if i [ 6 ] == <STRING> : <NEWLINE> <INDENT> dl . deleteFirst ( ) <NEWLINE> <DEDENT> elif i [ 6 ] == <STRING> : <NEWLINE> <INDENT> dl . deleteLast ( ) <NEWLINE> <DEDENT> elif i [ 0 ] == <STRING> : <NEWLINE> <INDENT> dl . insert ( i [ 7 : ] ) <NEWLINE> <DEDENT> elif i [ 0 ] == <STRING> : <NEWLINE> <INDENT> dl . delete ( i [ 7 : ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( dl . getList ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n < k : <NEWLINE> <INDENT> print ( min ( n , k - n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n % k , k - ( n % k ) ) ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A = 7 % K <NEWLINE> Flag = False <NEWLINE> for T in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> Flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = ( 10 * A + 7 ) % K <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , T ] [ Flag ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > ( n - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] != s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> ans1 = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> <NL> lim = n // 2 if n % 2 == 1 else n // 2 - 1 <NEWLINE> <NL> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n - i ) : <NEWLINE> <INDENT> right = s [ j - i ] <NEWLINE> middle = s [ j ] <NEWLINE> left = s [ j + i ] <NEWLINE> if right != middle and middle != left and left != right : <NEWLINE> <INDENT> ans1 -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> input_lines = [ [ int ( i ) for i in line . split ( ) ] for line in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> [ user_num , rel_num ] = input_lines [ 0 ] <NEWLINE> rel_list = input_lines [ 1 : rel_num + 1 ] <NEWLINE> ques_num = input_lines [ rel_num + 1 ] [ 0 ] <NEWLINE> ques_list = input_lines [ rel_num + 2 : ] <NEWLINE> color_list = [ - 1 ] * user_num <NEWLINE> adja_list = [ set ( ) for i in range ( user_num ) ] <NEWLINE> <NL> def dfs ( id , color ) : <NEWLINE> <INDENT> if color_list [ id ] == - 1 : <NEWLINE> <INDENT> color_list [ id ] = color <NEWLINE> for a_id in adja_list [ id ] : <NEWLINE> <INDENT> dfs ( a_id , color ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for rel in rel_list : <NEWLINE> <INDENT> adja_list [ rel [ 0 ] ] . add ( rel [ 1 ] ) <NEWLINE> adja_list [ rel [ 1 ] ] . add ( rel [ 0 ] ) <NEWLINE> <NL> <DEDENT> color = 0 <NEWLINE> for id in range ( user_num ) : <NEWLINE> <INDENT> dfs ( id , color ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> for ques in ques_list : <NEWLINE> <INDENT> if color_list [ ques [ 0 ] ] == color_list [ ques [ 1 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> summax = x + y <NEWLINE> summin = x + y <NEWLINE> diffmax = x - y <NEWLINE> diffmin = x - y <NEWLINE> <NL> <DEDENT> if x + y > summax : <NEWLINE> <INDENT> summax = x + y <NEWLINE> <DEDENT> if x + y < summin : <NEWLINE> <INDENT> summin = x + y <NEWLINE> <DEDENT> if x - y > diffmax : <NEWLINE> <INDENT> diffmax = x - y <NEWLINE> <DEDENT> if x - y < diffmin : <NEWLINE> <INDENT> diffmin = x - y <NEWLINE> <NL> <DEDENT> <DEDENT> a = summax - summin <NEWLINE> b = diffmax - diffmin <NEWLINE> sol = max ( a , b ) <NEWLINE> print ( sol ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> numbers = input ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pin = <STRING> <NEWLINE> if numbers [ i ] not in lst : <NEWLINE> <INDENT> pin += numbers [ i ] <NEWLINE> lst . append ( pin ) <NEWLINE> lst2 = [ ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> pin += numbers [ j ] <NEWLINE> if pin [ 1 ] not in lst2 : <NEWLINE> <INDENT> lst2 . append ( pin [ 1 ] ) <NEWLINE> lst3 = [ ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> pin += numbers [ k ] <NEWLINE> if pin [ 2 ] not in lst3 : <NEWLINE> <INDENT> lst3 . append ( pin [ 2 ] ) <NEWLINE> ans . append ( pin ) <NEWLINE> <DEDENT> if ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pin = pin [ 0 ] + pin [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pin = pin [ 0 ] <NEWLINE> <DEDENT> if ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for v in A : <NEWLINE> <INDENT> ans = ans * v <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> comp = 101 <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> x = abs ( X - i ) <NEWLINE> if comp > x and i not in p : <NEWLINE> <INDENT> comp = x <NEWLINE> result = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys , collections , math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> ans = pow ( 2 , n , m ) <NEWLINE> <NL> <NL> la = 1 <NEWLINE> laa = 1 <NEWLINE> for i in range ( n , n - a , - 1 ) : <NEWLINE> <INDENT> la = ( la * i ) % m <NEWLINE> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> laa = ( laa * i ) % m <NEWLINE> <NL> <DEDENT> lb = 1 <NEWLINE> lbb = 1 <NEWLINE> for i in range ( n , n - b , - 1 ) : <NEWLINE> <INDENT> lb = ( lb * i ) % m <NEWLINE> <DEDENT> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> lbb = ( lbb * i ) % m <NEWLINE> <NL> <DEDENT> la = ( la * pow ( laa , 10 ** 9 + 5 , m ) ) % m <NEWLINE> lb = ( lb * pow ( lbb , 10 ** 9 + 5 , m ) ) % m <NEWLINE> <NL> print ( ( ans - la - lb - 1 ) % m ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import string <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : x * y / math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A = il ( ) <NEWLINE> ret = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> ret [ a - 1 ] += 1 <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> while 1 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> s = [ ] <NEWLINE> a = [ 0 ] + sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in a [ i : ] : <NEWLINE> <INDENT> if a [ i ] + j > m : break <NEWLINE> s += [ a [ i ] + j ] <NEWLINE> <DEDENT> <DEDENT> s . sort ( ) <NEWLINE> print ( max ( i + s [ bisect . bisect_right ( s , m - i ) - 1 ] for i in s ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
M = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ma = A [ - 1 ] <NEWLINE> is_prime = [ True ] * ( ma + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , ma + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> k = [ i for i in range ( ma + 1 ) if is_prime [ i ] ] <NEWLINE> N = [ ] <NEWLINE> if len ( A ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] != A [ 1 ] : <NEWLINE> <INDENT> N . append ( A [ 0 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] != A [ i ] and A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> N . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if A [ len ( A ) - 2 ] != A [ len ( A ) - 1 ] : <NEWLINE> <INDENT> N . append ( A [ len ( A ) - 1 ] ) <NEWLINE> <DEDENT> s = set ( k ) & set ( N ) <NEWLINE> print ( len ( s ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> charnums = defaultdict ( int ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> charnums [ input ( ) ] += 1 <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> m = max ( charnums . values ( ) ) <NEWLINE> for key , value in charnums . items ( ) : <NEWLINE> <INDENT> if value == m : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <DEDENT> <DEDENT> for an in sorted ( ans ) : <NEWLINE> <INDENT> print ( an ) <NEWLINE> <DEDENT>
def check ( st ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> n = len ( st ) <NEWLINE> digitSum = 0 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> digitSum = digitSum + ( int ) ( st [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return ( digitSum % 9 == 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> x = input ( ) <NEWLINE> st = str ( x ) <NEWLINE> <NL> if ( check ( st ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> <NL> def bfs ( x1 , y1 , d ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( ( d , x1 , y1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> d , x1 , y1 = q . popleft ( ) <NEWLINE> <NL> M [ x1 ] [ y1 ] = d <NEWLINE> <NL> if [ x1 , y1 ] == [ xg , yg ] : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> <NL> if ( 0 <= x2 < H ) and ( 0 <= y2 < W ) : <NEWLINE> <INDENT> if m [ x2 ] [ y2 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] == - 1 : <NEWLINE> <INDENT> M [ x2 ] [ y2 ] = d + 1 <NEWLINE> q . append ( ( d + 1 , x2 , y2 ) ) <COMMENT> <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> xs , ys , xg , yg = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = xs - 1 , ys - 1 , xg - 1 , yg - 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> <NL> bfs ( xs , ys , 0 ) <NEWLINE> <NL> print ( M [ xg ] [ yg ] ) <NEWLINE>
import re <NEWLINE> <NL> S = input ( ) <NEWLINE> L = <STRING> <NEWLINE> <NL> if re . match ( L , S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> A , B , C = min ( A , 2 ) , min ( B , 2 ) , min ( C , 2 ) <NEWLINE> X = [ 0 , A , B , C ] <COMMENT> <NEWLINE> F = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } <NEWLINE> <NL> ans = [ ] <NEWLINE> for k , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> i , j = 1 , 2 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> i , j = 2 , 3 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> i , j = 1 , 3 <NEWLINE> <NL> <DEDENT> if X [ i ] > X [ j ] : <NEWLINE> <INDENT> X [ i ] -= 1 <NEWLINE> X [ j ] += 1 <NEWLINE> ans . append ( j ) <NEWLINE> <NL> <DEDENT> elif X [ i ] < X [ j ] : <NEWLINE> <INDENT> X [ i ] += 1 <NEWLINE> X [ j ] -= 1 <NEWLINE> ans . append ( i ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( X [ i ] == X [ j ] == 1 ) and ( k < N - 1 ) : <NEWLINE> <INDENT> if ( ( S [ k + 1 ] [ 0 ] == F [ i ] ) and ( S [ k + 1 ] [ 1 ] == F [ i ^ j ] ) ) or ( ( S [ k + 1 ] [ 0 ] == F [ i ^ j ] ) and ( S [ k + 1 ] [ 1 ] == F [ i ] ) ) : <NEWLINE> <INDENT> X [ i ] += 1 <NEWLINE> X [ j ] -= 1 <NEWLINE> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ j ] += 1 <NEWLINE> X [ i ] -= 1 <NEWLINE> ans . append ( j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> X [ i ] -= 1 <NEWLINE> X [ j ] += 1 <NEWLINE> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> if any ( [ x < 0 for x in X ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( F [ a ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans -= i * 2 <NEWLINE> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> l = math . gcd ( i , j ) <NEWLINE> ans -= l * 3 <NEWLINE> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( l , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans -= math . gcd ( i , j ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> a , b , n = readInts ( ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> print ( x * a // b ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( x < 0 ) : <NEWLINE> <INDENT> i = int ( abs ( x ) / d ) <NEWLINE> if ( k > i ) : <NEWLINE> <INDENT> k = k - i <NEWLINE> x = x + d * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + d * k <NEWLINE> k = 0 <NEWLINE> <DEDENT> if ( abs ( x ) > abs ( x - d ) ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> x = x - d <NEWLINE> <DEDENT> <DEDENT> elif ( x > 0 ) : <NEWLINE> <INDENT> i = int ( abs ( x ) / d ) <NEWLINE> if ( k > i ) : <NEWLINE> <INDENT> k = k - i <NEWLINE> x = x - d * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x - d * k <NEWLINE> k = 0 <NEWLINE> <DEDENT> if ( abs ( x ) > abs ( x + d ) ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> x = x + d <NEWLINE> <NL> <DEDENT> <DEDENT> if ( x == 0 ) : <NEWLINE> <INDENT> if ( k % 2 == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( k % 2 == 0 ) : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( x + d ) , abs ( x - d ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> pn = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> if x not in pn : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if x - i not in pn : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif x + i not in pn : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> alphabet = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> <NL> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += alphabet [ n % 26 ] <NEWLINE> n = n // 26 <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> X , N = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> p = np . sort ( p ) <NEWLINE> a = np . ones ( 304 , dtype = np . int ) <NEWLINE> a [ p + 102 ] = 0 <NEWLINE> m = X + 1000 <NEWLINE> n = 0 <NEWLINE> for i in range ( 304 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> if m > abs ( i - X - 102 ) : <NEWLINE> <INDENT> m = abs ( i - X - 102 ) <NEWLINE> n = i - 102 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( n ) ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ma = 1001001 <NEWLINE> nums = [ 0 ] * ma <NEWLINE> <NL> for q in a : <NEWLINE> <INDENT> nums [ q ] += 1 <NEWLINE> if nums [ q ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * q , ma , q ) : <NEWLINE> <INDENT> nums [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for elem in nums : <NEWLINE> <INDENT> if elem == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> count += 2 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> am = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pcnt = 0 <NEWLINE> mcnt = 0 <NEWLINE> <NL> f = 0 <COMMENT> <NEWLINE> wa = 0 <NEWLINE> <NL> <COMMENT> <NL> a = copy . copy ( am ) <NEWLINE> f = 2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> wa += a [ i ] <NEWLINE> <NL> if f == 1 : <COMMENT> <NEWLINE> <INDENT> if wa > - 1 : <NEWLINE> <INDENT> pcnt += wa + 1 <NEWLINE> wa = - 1 <NEWLINE> <NL> <DEDENT> f = 2 <NEWLINE> <NL> <DEDENT> elif f == 2 : <COMMENT> <NEWLINE> <NL> <INDENT> if wa < 1 : <NEWLINE> <INDENT> pcnt += - wa + 1 <NEWLINE> wa = 1 <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> a = copy . copy ( am ) <NEWLINE> wa = 0 <NEWLINE> f = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> wa += a [ i ] <NEWLINE> <NL> if f == 1 : <COMMENT> <NEWLINE> <INDENT> if wa > - 1 : <NEWLINE> <INDENT> mcnt += wa + 1 <NEWLINE> wa = - 1 <NEWLINE> <NL> <DEDENT> f = 2 <NEWLINE> <NL> <DEDENT> elif f == 2 : <COMMENT> <NEWLINE> <NL> <INDENT> if wa < 1 : <NEWLINE> <INDENT> mcnt += - wa + 1 <NEWLINE> wa = 1 <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( pcnt , mcnt ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> b = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for l in range ( j , k + 1 ) : <NEWLINE> <INDENT> p = len ( set ( [ i , j , l ] ) ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> q = math . gcd ( t , l ) <NEWLINE> s += q <NEWLINE> b . append ( q ) <NEWLINE> <DEDENT> elif p == 2 : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> q = math . gcd ( t , l ) <NEWLINE> s += q * 3 <NEWLINE> b . append ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> q = math . gcd ( t , l ) <NEWLINE> s += q * 6 <NEWLINE> b . append ( q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * 10050 <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> tmp = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if tmp < 10050 : <NEWLINE> <INDENT> ans [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> top = bool ( ) <NEWLINE> t = [ ] <NEWLINE> u = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> top = not top <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( q [ 1 ] == <STRING> ) ^ top : <NEWLINE> <INDENT> t . append ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = list ( reversed ( t ) ) + s + u <NEWLINE> if top : <NEWLINE> <INDENT> print ( * list ( reversed ( s ) ) , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * s , sep = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE> <NL>
def makeRelation ( ) : <NEWLINE> <INDENT> visited = [ False ] * ( N + 1 ) <NEWLINE> g = 0 <COMMENT> <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if visited [ n ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = { n } <NEWLINE> D . append ( set ( ) ) <NEWLINE> while q : <NEWLINE> <INDENT> j = q . pop ( ) <NEWLINE> for i in F [ j ] : <COMMENT> <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> visited [ i ] = True <NEWLINE> q . add ( i ) <NEWLINE> D [ g ] |= { i } <NEWLINE> <DEDENT> <DEDENT> <DEDENT> g += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> makeRelation ( ) <NEWLINE> <COMMENT> <NL> for g in D : <NEWLINE> <INDENT> for d in g : <NEWLINE> <INDENT> ans [ d ] = len ( g ) - len ( F [ d ] ) - len ( g & B [ d ] ) - 1 <NEWLINE> <DEDENT> <DEDENT> print ( * ans [ 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> F = [ set ( ) for n in range ( N + 1 ) ] <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for m in range ( M ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> F [ a ] . add ( b ) <NEWLINE> F [ b ] . add ( a ) <NEWLINE> <DEDENT> B = [ set ( ) for n in range ( N + 1 ) ] <NEWLINE> CD = [ list ( map ( int , input ( ) . split ( ) ) ) for k in range ( K ) ] <NEWLINE> for c , d in CD : <NEWLINE> <INDENT> B [ c ] . add ( d ) <NEWLINE> B [ d ] . add ( c ) <NEWLINE> <DEDENT> D = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
s = input ( ) + <STRING> <NEWLINE> <NL> <NL> p = [ 0 ] * ( len ( s ) - 1 ) <NEWLINE> key = s [ 0 ] <NEWLINE> strt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <NL> <INDENT> if key != s [ i ] : <NEWLINE> <INDENT> if key == <STRING> : <NEWLINE> <INDENT> p [ i ] += ( i - strt ) // 2 <NEWLINE> p [ i - 1 ] += ( i - strt ) // 2 + ( i - strt ) % 2 <NEWLINE> key = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ strt ] += ( i - strt ) // 2 + ( i - strt ) % 2 <NEWLINE> p [ strt - 1 ] += ( i - strt ) // 2 <NEWLINE> key = <STRING> <NEWLINE> <DEDENT> strt = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = N - R - G <NEWLINE> <NL> ans = R * G * B <NEWLINE> <NL> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> x = 2 * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t . startswith ( s [ i : ] ) : <NEWLINE> <INDENT> x = n + i <NEWLINE> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ 2 * j - i ] and S [ j ] != S [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> rng = range ( 1 , k + 1 ) <NEWLINE> <NL> gcd_ls = [ math . gcd ( i , j ) for i in rng for j in rng ] <NEWLINE> ans = [ math . gcd ( i , l ) for i in rng for l in gcd_ls ] <NEWLINE> <NL> print ( sum ( ans ) ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if math . gcd ( i , j ) == 1 : <NEWLINE> <INDENT> c += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> c += i <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> c += math . gcd ( i , k ) <NEWLINE> <DEDENT> elif i == k : <NEWLINE> <INDENT> c += math . gcd ( i , j ) <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> c += math . gcd ( i , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
ab = input ( ) <NEWLINE> num_ab = ab . split ( ) <NEWLINE> a = int ( num_ab [ 0 ] ) <NEWLINE> b = int ( num_ab [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , top , dside ) : <NEWLINE> <INDENT> self . top = top <NEWLINE> self . dside = dside <NEWLINE> self . rside = None <NEWLINE> self . num = [ self . top , self . dside , 7 - self . top , 7 - self . dside ] <NEWLINE> <DEDENT> def rside_num ( self ) : <NEWLINE> <INDENT> if 2 in self . num and 3 in self . num : <NEWLINE> <INDENT> if ( self . num . index ( 3 ) == self . num . index ( 2 ) + 1 or <NEWLINE> <INDENT> self . num == [ 3 , 5 , 4 , 2 ] ) : <NEWLINE> self . rside = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . rside = 6 <NEWLINE> <DEDENT> <DEDENT> elif 1 in self . num and 4 in self . num : <NEWLINE> <INDENT> if ( self . num . index ( 4 ) == self . num . index ( 1 ) + 1 or <NEWLINE> <INDENT> self . num == [ 4 , 6 , 3 , 1 ] ) : <NEWLINE> self . rside = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . rside = 5 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( self . num . index ( 2 ) == self . num . index ( 1 ) + 1 or <NEWLINE> <INDENT> self . num == [ 2 , 6 , 5 , 1 ] ) : <NEWLINE> self . rside = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . rside = 4 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> value = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice = Dice ( num . index ( value [ 0 ] ) + 1 , num . index ( value [ 1 ] ) + 1 ) <NEWLINE> dice . rside_num ( ) <NEWLINE> print ( num [ dice . rside - 1 ] ) <NEWLINE> <NL> <DEDENT>
def addAndDeleteMin ( ) : <NEWLINE> <INDENT> global ans <NEWLINE> global p <NEWLINE> minv = min ( p ) <NEWLINE> ans += minv <NEWLINE> p . remove ( minv ) <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> addAndDeleteMin ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if ( n % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> r = [ ( n - int ( m ) ) for n , m in enumerate ( a ) ] <NEWLINE> l = [ ( n + int ( m ) ) for n , m in enumerate ( a ) ] <NEWLINE> <NL> r . remove ( r [ 0 ] ) <NEWLINE> l . remove ( l [ - 1 ] ) <NEWLINE> <NL> mar = max ( r ) <NEWLINE> mir = min ( r ) <NEWLINE> mal = max ( l ) <NEWLINE> mil = min ( l ) <NEWLINE> <NL> R = { } <NEWLINE> L = { } <NEWLINE> <NL> for n , m in zip ( r , l ) : <NEWLINE> <INDENT> R [ n ] = 0 <NEWLINE> L [ m ] = 0 <NEWLINE> <NL> <DEDENT> for n , m in zip ( r , l ) : <NEWLINE> <INDENT> R [ n ] += 1 <NEWLINE> L [ m ] += 1 <NEWLINE> <NL> <DEDENT> for i in R . keys ( ) : <NEWLINE> <INDENT> if i in L . keys ( ) : <NEWLINE> <INDENT> count += R [ i ] * L [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
<NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ ] <NEWLINE> d = [ ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> grid . append ( input ( ) ) <NEWLINE> <DEDENT> dp = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> mod = 1e9 + 7 <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h > 0 and grid [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> dp [ h ] [ w ] = ( dp [ h ] [ w ] + dp [ h - 1 ] [ w ] ) % mod <NEWLINE> <DEDENT> if w > 0 and grid [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h ] [ w ] = ( dp [ h ] [ w ] + dp [ h ] [ w - 1 ] ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( dp [ H - 1 ] [ W - 1 ] ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> d = deque ( A ) <NEWLINE> min_A = d . popleft ( ) <NEWLINE> max_A = d . pop ( ) <NEWLINE> ans = max_A - min_A <NEWLINE> v1 = min_A <NEWLINE> v2 = max_A <NEWLINE> while d : <NEWLINE> <INDENT> if len ( d ) == 1 : <NEWLINE> <INDENT> v = d . pop ( ) <NEWLINE> ans += max ( abs ( v1 - v ) , abs ( v2 - v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_min = d [ 0 ] <NEWLINE> v_max = d [ - 1 ] <NEWLINE> diff = 0 <NEWLINE> is_popleft = None <NEWLINE> if diff < abs ( v1 - v_min ) : <NEWLINE> <INDENT> diff = abs ( v1 - v_min ) <NEWLINE> next_v1 = v_min <NEWLINE> next_v2 = v2 <NEWLINE> is_popleft = True <NEWLINE> <DEDENT> if diff < abs ( v2 - v_min ) : <NEWLINE> <INDENT> diff = abs ( v2 - v_min ) <NEWLINE> next_v1 = v_min <NEWLINE> next_v2 = v1 <NEWLINE> is_popleft = True <NEWLINE> <DEDENT> if diff < abs ( v1 - v_max ) : <NEWLINE> <INDENT> diff = abs ( v1 - v_max ) <NEWLINE> next_v1 = v_max <NEWLINE> next_v2 = v2 <NEWLINE> is_popleft = False <NEWLINE> <DEDENT> if diff < abs ( v2 - v_max ) : <NEWLINE> <INDENT> diff = abs ( v2 - v_max ) <NEWLINE> next_v1 = v_max <NEWLINE> next_v2 = v1 <NEWLINE> is_popleft = False <NEWLINE> <DEDENT> if is_popleft is None : <NEWLINE> <INDENT> next_v1 = v_min <NEWLINE> next_v2 = v2 <NEWLINE> is_popleft = True <NEWLINE> <DEDENT> ans += diff <NEWLINE> v1 , v2 = next_v1 , next_v2 <NEWLINE> if is_popleft : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cycles , check = [ ] , [ False ] * n <NEWLINE> for pi in p : <NEWLINE> <INDENT> if not check [ pi - 1 ] : <NEWLINE> <INDENT> curr , cycle = pi , [ ] <NEWLINE> check [ pi - 1 ] = True <NEWLINE> while pi != p [ curr - 1 ] : <NEWLINE> <INDENT> check [ curr - 1 ] = True <NEWLINE> cycle . append ( c [ curr - 1 ] ) <NEWLINE> curr = p [ curr - 1 ] <NEWLINE> <DEDENT> check [ curr - 1 ] = True <NEWLINE> cycles . append ( cycle + [ c [ curr - 1 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scores = [ ] <NEWLINE> for cycle in ( np . array ( cycle ) for cycle in cycles ) : <NEWLINE> <INDENT> for i in range ( cycle . size ) : <NEWLINE> <INDENT> cum = np . roll ( cycle , i ) . cumsum ( ) <NEWLINE> if cum [ - 1 ] > 0 and k > cycle . size : <NEWLINE> <INDENT> scores . append ( cum [ - 1 ] * ( k // cycle . size - 1 ) + np . concatenate ( [ cum , cum [ : k % cycle . size ] + cum [ - 1 ] ] ) . max ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> scores . append ( cum [ : min ( k , cum . size ) ] . max ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( scores ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = A [ 0 ] <NEWLINE> r = A [ K ] <NEWLINE> for i in range ( 1 , N - K ) : <NEWLINE> <INDENT> if l < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> l = A [ i ] <NEWLINE> r = A [ K + i ] <NEWLINE> <DEDENT> if l < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> t = float ( <STRING> ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if abs ( h [ i + k - 1 ] - h [ i ] ) < t : <NEWLINE> <INDENT> t = abs ( h [ i + k - 1 ] - h [ i ] ) <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( h [ ans + k - 1 ] - h [ ans ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = arr [ 0 ] <NEWLINE> if arr . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> <NL> v = [ 0 ] * 2 * 10 ** 5 <NEWLINE> seen = set ( [ 0 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v [ i + 1 ] = A [ i ] + v [ i ] <NEWLINE> v [ i + 1 ] %= M <NEWLINE> seen . add ( v [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> counts = { x : 0 for x in seen } <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> counts [ v [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for _ , count in counts . items ( ) : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * n <NEWLINE> d = [ 0 ] * n <NEWLINE> <NL> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> c [ i ] = i + j <NEWLINE> <NL> <DEDENT> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> d [ i ] = i - j <NEWLINE> <NL> <DEDENT> x = { } <NEWLINE> for i , j in enumerate ( c ) : <NEWLINE> <INDENT> if j not in x : <NEWLINE> <INDENT> x [ j ] = [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ j ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> if i not in x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += len ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcdix = gcd ( i , x ) <NEWLINE> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( z , gcdix ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> seki = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> seki *= a [ i ] <NEWLINE> if seki > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if seki > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( seki ) <NEWLINE> <DEDENT> <DEDENT>
def func ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <DEDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( func , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> now = 0 <NEWLINE> past = [ ] <NEWLINE> past_set = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if now in past_set : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> past . append ( now ) <NEWLINE> past_set . add ( now ) <NEWLINE> now = A [ now ] <NEWLINE> <NL> <NL> <DEDENT> i_loop = past . index ( now ) <NEWLINE> loop = past [ i_loop : ] <NEWLINE> if K >= i_loop : <NEWLINE> <INDENT> print ( loop [ ( K - i_loop ) % len ( loop ) ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( past [ K ] + 1 ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mylist = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( mylist [ i ] ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> y = n // b <NEWLINE> if y == 0 : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if min ( a ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s = s * a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def is_prime ( x ) : <NEWLINE> <INDENT> if x == 1 or x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> for idx in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % idx == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if is_prime ( int ( input ( ) ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , m , q = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> import itertools as it <NEWLINE> abcd = list ( ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> abcd . append ( [ int ( e ) for e in input ( ) . split ( ) ] ) <NEWLINE> <NL> <NL> <DEDENT> all = it . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) <NEWLINE> <NL> count = list ( ) <NEWLINE> num = 0 <NEWLINE> for i in all : <NEWLINE> <INDENT> for j in abcd : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> num += j [ 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> count . append ( num ) <NEWLINE> num = 0 <NEWLINE> <NL> <DEDENT> print ( max ( count ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) . strip ( ) <NEWLINE> cnt = Counter ( S ) <NEWLINE> ans = cnt [ <STRING> ] * cnt [ <STRING> ] * cnt [ <STRING> ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> wa = [ ] <NEWLINE> total = 0 <NEWLINE> for i in reversed ( range ( 1 , len ( an ) ) ) : <NEWLINE> <INDENT> total = total + an [ i ] <NEWLINE> wa . append ( total ) <NEWLINE> <DEDENT> wa = sorted ( wa , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = ans + an [ i ] * ( wa [ i ] % m ) <NEWLINE> ans = ans % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = k + ( n % k ) <NEWLINE> min = sys . maxsize <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if x % k == 0 : <NEWLINE> <INDENT> min = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> x = abs ( x - k ) <NEWLINE> if x == min : break <NEWLINE> elif x < min : min = x <NEWLINE> <NL> <DEDENT> print ( min ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = min ( a , b ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in reversed ( range ( 1 , n + 1 ) ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( 100000 ) ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ a - 1 ] . append ( - b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> heap = [ ] <NEWLINE> for a in range ( M ) : <NEWLINE> <INDENT> for b in AB [ a ] : <NEWLINE> <INDENT> heappush ( heap , b ) <NEWLINE> <DEDENT> if heap : <NEWLINE> <INDENT> ans -= heappop ( heap ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Bs = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> Bs . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> A_list = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> A_list [ i ] += 1 <NEWLINE> <NL> <DEDENT> sum_value = sum ( A ) <NEWLINE> for B in Bs : <NEWLINE> <INDENT> b , c = B <NEWLINE> sum_value += A_list [ b ] * c <NEWLINE> sum_value -= A_list [ b ] * b <NEWLINE> <NL> A_list [ c ] += A_list [ b ] <NEWLINE> A_list [ b ] = 0 <NEWLINE> print ( sum_value ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> judge = True <NEWLINE> ans = 0 <NEWLINE> <NL> if 0 not in a : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> judge = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , x , parent = None ) : <NEWLINE> <INDENT> self . key = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = parent <NEWLINE> <NL> <DEDENT> def append_child ( self , child ) : <NEWLINE> <INDENT> if self . key > child . key : <NEWLINE> <INDENT> self . left = child <NEWLINE> child . parent = self <NEWLINE> <DEDENT> elif self . key < child . key : <NEWLINE> <INDENT> self . right = child <NEWLINE> child . parent = self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def remove ( self , tree ) : <NEWLINE> <INDENT> parent = self . parent <NEWLINE> if self . left and self . right : <NEWLINE> <INDENT> child = self . right <NEWLINE> while child . left is not None : <NEWLINE> <INDENT> child = child . left <NEWLINE> <DEDENT> child . remove ( tree ) <NEWLINE> self . key = child . key <NEWLINE> <DEDENT> elif self . left or self . right : <NEWLINE> <INDENT> child = self . left or self . right <NEWLINE> if parent is None : <COMMENT> <NEWLINE> <INDENT> self . root = child <NEWLINE> child . parent = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . append_child ( child ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if parent is None : <COMMENT> <NEWLINE> <INDENT> tree . root = None <NEWLINE> <DEDENT> elif self is parent . left : <NEWLINE> <INDENT> parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> inserted = Node ( x ) <NEWLINE> if self . root is None : <NEWLINE> <INDENT> self . root = inserted <NEWLINE> return inserted <NEWLINE> <NL> <DEDENT> node = self . root <NEWLINE> parent = None <NEWLINE> while node is not None : <NEWLINE> <INDENT> if x > node . key : <NEWLINE> <INDENT> parent = node <NEWLINE> node = node . right <NEWLINE> <DEDENT> elif x < node . key : <NEWLINE> <INDENT> parent = node <NEWLINE> node = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node <NEWLINE> <NL> <DEDENT> <DEDENT> parent . append_child ( inserted ) <NEWLINE> return inserted <NEWLINE> <NL> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> deleted = self . find ( x ) <NEWLINE> if deleted is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> deleted . remove ( self ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> node = self . root <NEWLINE> while node is not None : <NEWLINE> <INDENT> if x == node . key : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> elif x > node . key : <NEWLINE> <INDENT> node = node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . left <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def pre_order ( self ) : <NEWLINE> <INDENT> keys = [ ] <NEWLINE> self . do_pre_order ( self . root , keys ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , keys ) ) ) <NEWLINE> <NL> <DEDENT> def do_pre_order ( self , node , keys ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> keys . append ( node . key ) <NEWLINE> self . do_pre_order ( node . left , keys ) <NEWLINE> self . do_pre_order ( node . right , keys ) <NEWLINE> <NL> <DEDENT> def in_order ( self ) : <NEWLINE> <INDENT> keys = [ ] <NEWLINE> self . do_in_order ( self . root , keys ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , keys ) ) ) <NEWLINE> <NL> <DEDENT> def do_in_order ( self , node , keys ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . do_in_order ( node . left , keys ) <NEWLINE> keys . append ( node . key ) <NEWLINE> self . do_in_order ( node . right , keys ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> tree = BinaryTree ( ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> <NL> for line in lines [ 1 : ] : <NEWLINE> <INDENT> if len ( line . rstrip ( ) ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> command = line . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( command [ 1 ] ) ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . in_order ( ) <NEWLINE> tree . pre_order ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ( tree . find ( int ( command [ 1 ] ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . delete ( int ( command [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise <STRING> + command [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import itertools <NEWLINE> print ( abs ( m * n - ( ( n - 1 ) * 2 + ( m - 1 ) * 2 ) ) ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> line = [ ] <NEWLINE> array = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> for i in range ( 0 , r ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> array [ i ] [ j ] = int ( line [ j ] ) <NEWLINE> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> sum = sum + array [ i ] [ j ] <NEWLINE> <DEDENT> array [ i ] [ c ] = sum <NEWLINE> sum = 0 <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> sum = sum + array [ j ] [ i ] <NEWLINE> <DEDENT> array [ r ] [ i ] = sum <NEWLINE> sum = 0 <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> sum = sum + array [ j ] [ c ] <NEWLINE> <DEDENT> array [ r ] [ c ] = sum <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j == c : <NEWLINE> <INDENT> print ( <STRING> . format ( array [ i ] [ j ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( array [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> d = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> m = min ( abs ( i - j ) , abs ( x - i ) + abs ( y - j ) + 1 , abs ( x - j ) + abs ( y - i ) + 1 ) <NEWLINE> d [ m ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( d [ i + 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> S = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> S . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> sum_list = [ 0 ] * ( N + 1 ) <NEWLINE> sum_list [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for L , R in S : <NEWLINE> <INDENT> RR = i - L <NEWLINE> if RR <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> LL = max ( 1 , i - R ) <NEWLINE> if LL <= RR : <NEWLINE> <INDENT> t = sum_list [ RR ] - sum_list [ LL - 1 ] <NEWLINE> dp [ i ] += t <NEWLINE> <DEDENT> <DEDENT> sum_list [ i ] = ( sum_list [ i - 1 ] + dp [ i ] ) % MOD <NEWLINE> dp [ i ] %= MOD <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
<NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> faccs = { } <NEWLINE> <NL> <NL> def isPrime ( n ) : <NEWLINE> <NL> <INDENT> if ( n <= 1 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( n <= 3 ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if ( n % 2 == 0 or n % 3 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i = 5 <NEWLINE> while ( i * i <= n ) : <NEWLINE> <INDENT> if ( n % i == 0 or n % ( i + 2 ) == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = i + 6 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if isPrime ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while n % 2 == 0 : <NEWLINE> <INDENT> if 2 in faccs : <NEWLINE> <INDENT> faccs [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> faccs [ 2 ] = 1 <NEWLINE> <DEDENT> n = n / 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : <NEWLINE> <NL> <NL> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> if i in faccs : <NEWLINE> <INDENT> faccs [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> faccs [ i ] = 1 <NEWLINE> <DEDENT> n = n / i <NEWLINE> <NL> <DEDENT> <DEDENT> if n > 2 : <NEWLINE> <INDENT> faccs [ math . floor ( n ) ] = 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for i in faccs . values ( ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> temp = 1 <NEWLINE> while ( i - temp ) >= 0 : <NEWLINE> <INDENT> i -= temp <NEWLINE> temp += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for j in range ( x + 1 ) : <NEWLINE> <INDENT> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if arr . count ( x + i * j ) == 0 : <NEWLINE> <INDENT> print ( x + i * j ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , key = None , parent = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = parent <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def insert ( key , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if key < node . key : <NEWLINE> <INDENT> if node . left is None : <NEWLINE> <INDENT> left_node = Node ( key , node ) <NEWLINE> node . left = left_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( key , node . left ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if node . right is None : <NEWLINE> <INDENT> right_node = Node ( key , node ) <NEWLINE> node . right = right_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( key , node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( key , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if key == node . key : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> elif key < node . key : <NEWLINE> <INDENT> if node . left is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( key , node . left ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if node . right is None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( key , node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def print_preorder ( node ) : <NEWLINE> <INDENT> print ( <STRING> % node . key , end = <STRING> ) <NEWLINE> if node . left is not None : <NEWLINE> <INDENT> print_preorder ( node . left ) <NEWLINE> <DEDENT> if node . right is not None : <NEWLINE> <INDENT> print_preorder ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_inorder ( node ) : <NEWLINE> <INDENT> if node . left is not None : <NEWLINE> <INDENT> print_inorder ( node . left ) <NEWLINE> <DEDENT> print ( <STRING> % node . key , end = <STRING> ) <NEWLINE> if node . right is not None : <NEWLINE> <INDENT> print_inorder ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def search_minimum_node ( node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if node . left is not None : <NEWLINE> <INDENT> return search_minimum_node ( node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def delete ( node ) : <NEWLINE> <INDENT> if node . left is None and node . right is None : <NEWLINE> <COMMENT> <NL> <INDENT> if node . parent . left is node : <NEWLINE> <INDENT> node . parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . parent . right = None <NEWLINE> <DEDENT> <DEDENT> elif node . left is None and node . right is not None : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if node is node . parent . left : <NEWLINE> <COMMENT> <NL> <INDENT> node . parent . left = node . right <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . parent . right = node . right <NEWLINE> <DEDENT> node . right . parent = node . parent <NEWLINE> <DEDENT> elif node . left is not None and node . right is None : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if node is node . parent . left : <NEWLINE> <COMMENT> <NL> <INDENT> node . parent . left = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> node . parent . right = node . left <NEWLINE> <DEDENT> node . left . parent = node . parent <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> successor = search_minimum_node ( node . right ) <NEWLINE> if successor . right is not None : <NEWLINE> <COMMENT> <NL> <INDENT> successor . right . parent = successor . parent <NEWLINE> successor . parent . left = successor . right <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if successor . parent . left is successor : <NEWLINE> <INDENT> successor . parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> successor . parent . right = None <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> node . key = successor . key <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> root = Node ( ) <NEWLINE> <NL> for order in lines [ 1 : ] : <NEWLINE> <INDENT> if order . startswith ( <STRING> ) : <NEWLINE> <INDENT> _ , key = order . strip ( ) . split ( <STRING> ) <NEWLINE> key = int ( key ) <NEWLINE> if root . key is None : <NEWLINE> <INDENT> root . key = key <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( key , root ) <NEWLINE> <DEDENT> <DEDENT> elif order . startswith ( <STRING> ) : <NEWLINE> <INDENT> _ , key = order . strip ( ) . split ( <STRING> ) <NEWLINE> fild_result = <STRING> if find ( int ( key ) , root ) is None else <STRING> <NEWLINE> print ( fild_result ) <NEWLINE> <DEDENT> elif order . startswith ( <STRING> ) : <NEWLINE> <INDENT> print_inorder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> print_preorder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> elif order . startswith ( <STRING> ) : <NEWLINE> <INDENT> _ , key = order . strip ( ) . split ( <STRING> ) <NEWLINE> node = find ( int ( key ) , root ) <COMMENT> <NEWLINE> delete ( node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dic . setdefault ( a , 0 ) <NEWLINE> dic [ a ] += 1 <NEWLINE> if dic [ a ] == 2 : <NEWLINE> <INDENT> dic . pop ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( dic ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> l = [ 0 , 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( l [ K ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += [ int ( input ( ) ) ] <NEWLINE> <DEDENT> s = sorted ( s ) <NEWLINE> a = sum ( s ) <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> a -= s [ i ] <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> f = 0 <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def get_parent ( index ) : <NEWLINE> <INDENT> return index // 2 <NEWLINE> <NL> <NL> <DEDENT> def get_left ( index ) : <NEWLINE> <INDENT> return 2 * index <NEWLINE> <NL> <NL> <DEDENT> def get_right ( index ) : <NEWLINE> <INDENT> return get_left ( index ) + 1 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> array = list ( map ( int , _input [ 1 ] . split ( ) ) ) <NEWLINE> array . insert ( 0 , None ) <NEWLINE> for i in range ( 1 , array_length + 1 ) : <NEWLINE> <INDENT> parent , left , right = get_parent ( i ) , get_left ( i ) , get_right ( i ) <NEWLINE> print ( <STRING> + str ( i ) + <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> + str ( array [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> if parent : <NEWLINE> <INDENT> print ( <STRING> + str ( array [ parent ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if left <= array_length : <NEWLINE> <INDENT> print ( <STRING> + str ( array [ left ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if right <= array_length : <NEWLINE> <INDENT> print ( <STRING> + str ( array [ right ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if ( z >= 0 and z <= k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t . sort ( ) <NEWLINE> print ( t [ 0 ] , t [ 1 ] , t [ 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> s1 = 0 <NEWLINE> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> s1 += a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ s - s1 * 2 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans . append ( ( a [ i - 1 ] - ans [ i - 1 ] // 2 ) * 2 ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <NL> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = prime_factorize ( N ) <NEWLINE> z = set ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while len ( a ) > 0 : <NEWLINE> <INDENT> num = a . pop ( 0 ) <NEWLINE> cursor = num <NEWLINE> while True : <NEWLINE> <INDENT> if num not in z : <NEWLINE> <INDENT> z . add ( num ) <NEWLINE> break <NEWLINE> <DEDENT> elif len ( a ) <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif cursor != a [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num *= a . pop ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( z ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ i for i in range ( 0 , 102 ) if i not in a ] <NEWLINE> b_tmp = list ( map ( lambda s : abs ( s - x ) , b ) ) <COMMENT> <NEWLINE> address = b_tmp . index ( min ( b_tmp ) ) <NEWLINE> print ( b [ address ] ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> <NL> t = [ ] <NEWLINE> memo = [ 0 for _ in range ( 26 ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> scores = [ ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> delta_score = 0 <NEWLINE> delta_score += s [ i ] [ j ] <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> delta_score -= c [ k ] * ( i + 1 - memo [ k ] ) <NEWLINE> <DEDENT> scores . append ( ( delta_score , j ) ) <NEWLINE> <NL> <DEDENT> scores . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> choice = scores [ 0 ] [ 1 ] <NEWLINE> t . append ( choice + 1 ) <NEWLINE> memo [ choice ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * t , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> minr = a [ 0 ] <NEWLINE> ans = - float ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = max ( a [ i ] - minr , ans ) <NEWLINE> minr = min ( a [ i ] , minr ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> p = 2019 <NEWLINE> ans = 0 <NEWLINE> M = [ 0 ] * p <NEWLINE> M [ 0 ] = 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> tmp += ( int ( s [ - i - 1 ] ) * pow ( 10 , i , p ) ) <NEWLINE> tmp %= p <NEWLINE> ans += M [ tmp ] <NEWLINE> M [ tmp ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> <NL> v_num , e_num , r = map ( int , input ( ) . split ( ) ) <NEWLINE> dist_lst = [ INF for _ in range ( v_num ) ] <NEWLINE> edges_lst = [ [ ] for _ in range ( e_num ) ] <NEWLINE> negative_cycle_flag = False <NEWLINE> <NL> for _ in range ( e_num ) : <NEWLINE> <INDENT> s , t , dist = map ( int , input ( ) . split ( ) ) <NEWLINE> edges_lst [ s ] . append ( ( dist , t ) ) <NEWLINE> <NL> <DEDENT> dist_lst [ r ] = 0 <NEWLINE> <NL> if e_num != 0 : <NEWLINE> <INDENT> for _ in range ( v_num ) : <NEWLINE> <INDENT> for v in range ( v_num ) : <NEWLINE> <INDENT> if dist_lst [ v ] != INF : <NEWLINE> <INDENT> for dist , to in edges_lst [ v ] : <NEWLINE> <INDENT> if dist_lst [ v ] + dist < dist_lst [ to ] : <NEWLINE> <INDENT> dist_lst [ to ] = dist_lst [ v ] + dist <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for v in range ( v_num ) : <NEWLINE> <INDENT> if dist_lst [ v ] != INF : <NEWLINE> <INDENT> for dist , to in edges_lst [ v ] : <NEWLINE> <INDENT> if dist_lst [ v ] + dist < dist_lst [ to ] : <NEWLINE> <INDENT> negative_cycle_flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if negative_cycle_flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if negative_cycle_flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for dist in dist_lst : <NEWLINE> <INDENT> if dist == INF : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> given_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for kabuka in given_a : <NEWLINE> <INDENT> if len ( a ) > 0 and a [ - 1 ] == kabuka : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( kabuka ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = len ( a ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( money ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if a [ i + 1 ] < a [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kabu += money // a [ i ] <NEWLINE> money %= a [ i ] <NEWLINE> <DEDENT> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i - 1 ] < a [ i ] and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> if a [ i - 1 ] > a [ i ] and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> kabu += money // a [ i ] <NEWLINE> money %= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( money ) <NEWLINE> <NL> <NL>
s = input ( ) <NEWLINE> a = 0 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> a = 1 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> a += 1 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i > 0 : plus . append ( i ) <NEWLINE> if i < 0 : minus . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if k > len ( plus ) + len ( minus ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif len ( minus ) == 0 : <NEWLINE> <INDENT> plus . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * plus [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> elif len ( plus ) == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> minus . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * minus [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n != len ( minus ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * minus [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif k == len ( plus ) + len ( minus ) and ( len ( minus ) % 2 ) == 1 : <NEWLINE> <INDENT> if n != k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in plus : <NEWLINE> <INDENT> ans = ( ans * x ) % mod <NEWLINE> <DEDENT> for y in minus : <NEWLINE> <INDENT> ans = ( ans * y ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> i , j = 0 , 0 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans = plus [ 0 ] <NEWLINE> i = 1 <NEWLINE> <DEDENT> while i + j < k : <NEWLINE> <INDENT> tmp_p = plus [ i ] * plus [ i + 1 ] if i <= len ( plus ) - 2 else 1 <NEWLINE> tmp_m = minus [ j ] * minus [ j + 1 ] if j <= len ( minus ) - 2 else 1 <NEWLINE> if tmp_p >= tmp_m : <NEWLINE> <INDENT> ans = ( ans * ( tmp_p % mod ) ) % mod <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * ( tmp_m % mod ) ) % mod <NEWLINE> j += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <DEDENT> p = 998244353 <NEWLINE> N = n <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> l2 = m * ( m - 1 ) ** ( n - k - 1 ) <NEWLINE> for _k in range ( k , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> ncr = cmb ( n - 1 , _k , p ) <NEWLINE> ans += ncr * l2 <NEWLINE> ans %= p <NEWLINE> <NL> l2 %= p <NEWLINE> l2 *= ( m - 1 ) <NEWLINE> l2 %= p <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( height ) for height in input ( ) . split ( ) ] <NEWLINE> <NL> m = Counter ( i - elem for i , elem in enumerate ( A ) ) <NEWLINE> res = 0 <NEWLINE> for i , elem in enumerate ( A ) : <NEWLINE> <INDENT> res += m [ i + elem ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
from sys import stdin <NEWLINE> A , B , C , K = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if ( A >= K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( B >= ( K - A ) ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> path = [ [ ] for i in range ( N ) ] <NEWLINE> indicator = [ None ] * N <NEWLINE> indicator [ 0 ] = ( 0 , 0 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def solve ( N , path , indicator ) : <NEWLINE> <INDENT> visit = [ False ] * N <NEWLINE> visit [ 0 ] = True <NEWLINE> p = 0 <NEWLINE> l = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( ( 0 , 0 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> ( p , l ) = q . popleft ( ) <NEWLINE> for room in path [ p ] : <NEWLINE> <INDENT> if visit [ room ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if indicator [ room ] is None : <NEWLINE> <INDENT> indicator [ room ] = ( p , l + 1 ) <NEWLINE> q . append ( ( room , l + 1 ) ) <NEWLINE> visit [ room ] = True <NEWLINE> <DEDENT> elif indicator [ room ] [ 1 ] > l + 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> L = solve ( N , path , indicator ) <NEWLINE> if L == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for p , l in indicator [ 1 : ] : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a_list = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a_max = a_list [ - 1 ] <NEWLINE> <NL> count = [ 0 ] * ( a_max + 1 ) <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> for j in range ( a , a_max + 1 , a ) : <NEWLINE> <INDENT> count [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if count [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> value = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( value , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <COMMENT> <NEWLINE> Amax = A [ - 1 ] <NEWLINE> dp = [ 1 ] * ( Amax + 1 ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> if dp [ p ] == 1 : <COMMENT> <NEWLINE> <INDENT> for q in range ( Amax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * q ] = 0 <COMMENT> <NEWLINE> <DEDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ Amax ] == 1 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , h = map ( int , input ( ) . split ( ) ) <NEWLINE> X [ i ] = ( x , h ) <NEWLINE> <DEDENT> X = sorted ( X ) <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> q = deque ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , h = X [ i ] <NEWLINE> while ( len ( q ) > 0 and q [ 0 ] [ 0 ] < x ) : <NEWLINE> <INDENT> total -= q [ 0 ] [ 1 ] <NEWLINE> q . popleft ( ) <NEWLINE> <DEDENT> h -= total <NEWLINE> if h > 0 : <NEWLINE> <INDENT> num = ( h + A - 1 ) // A <NEWLINE> ans += num <NEWLINE> damage = num * A <NEWLINE> total += damage <NEWLINE> q . append ( ( x + 2 * D , damage ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
AV = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> BW = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = AV [ 0 ] <NEWLINE> V = AV [ 1 ] <NEWLINE> B = BW [ 0 ] <NEWLINE> W = BW [ 1 ] <NEWLINE> T = int ( input ( ) ) <NEWLINE> T = float ( T ) <NEWLINE> D = abs ( A - B ) <NEWLINE> S = V - W <NEWLINE> if S > 0 : <NEWLINE> <INDENT> T1 = float ( D / S ) <NEWLINE> if T1 <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B <= N : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( N ) / B ) - A * int ( N / B ) ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , - ( - b // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> def select ( l , r ) : <NEWLINE> <INDENT> return ( l + r ) * ( r - l + 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> l = select ( 0 , i - 1 ) <NEWLINE> r = select ( n - i + 1 , n ) <NEWLINE> ans += ( r - l + 1 ) <NEWLINE> ans %= ( pow ( 10 , 9 ) + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> <NL> box = defaultdict ( int ) <NEWLINE> zeros = 0 <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a != 0 and b == 0 : <NEWLINE> <INDENT> box [ ( - 1 , 1 , 0 ) ] += 1 <NEWLINE> <DEDENT> elif a == 0 and b != 0 : <NEWLINE> <INDENT> box [ ( 1 , 0 , 1 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> ga = a // g <NEWLINE> gb = b // g <NEWLINE> if ( a // b ) < 0 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> <DEDENT> box [ ( s , abs ( ga ) , abs ( gb ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> nakawaru = dict ( ) <NEWLINE> others = 0 <NEWLINE> <NL> for ( s , i , j ) , v in box . items ( ) : <NEWLINE> <INDENT> if ( - s , j , i ) in box . keys ( ) : <NEWLINE> <INDENT> if ( s , i , j ) not in nakawaru . keys ( ) and ( - s , j , i ) not in nakawaru . keys ( ) : <NEWLINE> <INDENT> nakawaru [ ( s , i , j ) ] = ( box [ ( s , i , j ) ] , box [ ( - s , j , i ) ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> others += v <NEWLINE> <NL> <DEDENT> <DEDENT> seed = 1 <NEWLINE> for i , j in nakawaru . values ( ) : <NEWLINE> <INDENT> seed *= ( pow ( 2 , i , MOD ) + pow ( 2 , j , MOD ) - 1 ) <NEWLINE> seed %= MOD <NEWLINE> <NL> <DEDENT> ans = zeros + pow ( 2 , others , MOD ) * seed - 1 <NEWLINE> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in a : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in a : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> x = sorted ( LIST ( ) ) <NEWLINE> dx = [ x [ i + 1 ] - x [ i ] for i in range ( m - 1 ) ] <NEWLINE> dx . sort ( reverse = True ) <NEWLINE> <NL> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ m - 1 ] - x [ 0 ] - sum ( dx [ 0 : n - 1 ] ) ) <NEWLINE> <DEDENT>
from heapq import heapify , heappush , heappop <NEWLINE> from collections import Counter , defaultdict , deque , OrderedDict <NEWLINE> from sys import setrecursionlimit as setreclim <NEWLINE> from sys import maxsize <NEWLINE> from bisect import bisect_left , bisect , insort_left , insort <NEWLINE> from math import ceil , log , factorial , hypot , pi <NEWLINE> from fractions import gcd <NEWLINE> from copy import deepcopy <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> from itertools import product , permutations , combinations , accumulate , cycle <NEWLINE> from string import ascii_uppercase , ascii_lowercase , ascii_letters , digits , hexdigits , octdigits <NEWLINE> <NL> prod = lambda l : reduce ( mul , l ) <NEWLINE> prodmod = lambda l , mod : reduce ( lambda x , y : mul ( x , y ) % mod , l ) <NEWLINE> <NL> class Dijkstra : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , V , E , start , INF = 10 ** 9 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . V = V <NEWLINE> self . E = E <NEWLINE> self . dijkstra ( start , INF ) <NEWLINE> <NL> <DEDENT> def dijkstra ( self , start , INF ) : <NEWLINE> <INDENT> que = list ( ) <NEWLINE> self . distance = [ INF ] * self . V <COMMENT> <NEWLINE> self . prev = [ - 1 ] * self . V <COMMENT> <NEWLINE> self . distance [ start ] = 0 <NEWLINE> heappush ( que , ( 0 , start ) ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> dist , v = heappop ( que ) <NEWLINE> if self . distance [ v ] < dist : continue <NEWLINE> for to , cost in self . E [ v ] : <NEWLINE> <INDENT> if self . distance [ v ] + cost < self . distance [ to ] : <NEWLINE> <INDENT> self . distance [ to ] = self . distance [ v ] + cost <NEWLINE> heappush ( que , ( self . distance [ to ] , to ) ) <NEWLINE> self . prev [ to ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getPath ( self , end ) : <NEWLINE> <INDENT> path = [ end ] <NEWLINE> while self . prev [ end ] != - 1 : <NEWLINE> <INDENT> end = self . prev [ end ] <NEWLINE> <DEDENT> return path [ : : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = maxsize <NEWLINE> edge = [ [ ] for _ in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ s ] . append ( ( t , cost ) ) <NEWLINE> <DEDENT> sp = Dijkstra ( V , edge , r , INF ) <NEWLINE> for d in sp . distance : <NEWLINE> <INDENT> print ( d if d != INF else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> cou = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> b = n // i - 1 <NEWLINE> if b >= 2 and n // b == n % b : <NEWLINE> <INDENT> cou += b <NEWLINE> <NL> <DEDENT> if i > 2 : <NEWLINE> <INDENT> c = i - 1 <NEWLINE> if n // c == n % c : <NEWLINE> <INDENT> cou += c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_n = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> zero = 0 in A_n <NEWLINE> if zero : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 1 <NEWLINE> for i in A_n : <NEWLINE> <INDENT> total *= i <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for divisor in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> quotient = num // divisor <NEWLINE> ans += ( quotient + 1 ) * quotient * divisor // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> r = c . count ( <STRING> ) <NEWLINE> w = c . count ( <STRING> ) <NEWLINE> count = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> l = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ i ] = ( l [ i - 1 ] + int ( S [ i ] ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> <DEDENT> c = Counter ( l ) <NEWLINE> c [ 0 ] += 1 <NEWLINE> ans = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> n = int ( file_input . readline ( ) ) <NEWLINE> m = int ( file_input . readline ( ) ) <NEWLINE> <NL> adj_list = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> indeg = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> i , j = map ( int , line . split ( ) ) <NEWLINE> adj_list [ i ] . append ( j ) <NEWLINE> indeg [ j ] += 1 <NEWLINE> <NL> <DEDENT> unvisited = [ True ] * ( n + 1 ) <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> def bfs ( s ) : <NEWLINE> <INDENT> q . append ( s ) <NEWLINE> unvisited [ s ] = False <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> ans . append ( u ) <NEWLINE> for v in adj_list [ u ] : <NEWLINE> <INDENT> indeg [ v ] -= 1 <NEWLINE> if indeg [ v ] == 0 and unvisited [ v ] : <NEWLINE> <INDENT> unvisited [ v ] = False <NEWLINE> q . append ( v ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for s in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if indeg [ s ] == 0 and unvisited [ s ] : <NEWLINE> <INDENT> bfs ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> for s , t in zip ( ans , ans [ 1 : ] ) : <NEWLINE> <INDENT> if t not in adj_list [ s ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if A . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for e in A : <NEWLINE> <INDENT> result *= e <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
def _get_distance ( c1 , c2 ) : <NEWLINE> <INDENT> return ( ( c1 [ 1 ] - c2 [ 1 ] ) ** 2 + ( c1 [ 2 ] - c2 [ 2 ] ) ** 2 ) ** 0.5 - c1 [ 0 ] - c2 [ 0 ] <NEWLINE> <NL> <DEDENT> from itertools import combinations <NEWLINE> <NL> def _get_min_distance ( circles ) : <NEWLINE> <INDENT> min_d = float ( <STRING> ) <NEWLINE> for c1 , c2 in combinations ( circles , 2 ) : <NEWLINE> <INDENT> min_d = min ( min_d , _get_distance ( c1 , c2 ) ) <NEWLINE> <DEDENT> return min_d <NEWLINE> <NL> <DEDENT> def closest_pair_distance ( circles , axis = 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( circles ) <NEWLINE> if n <= 3 : <NEWLINE> <INDENT> return _get_min_distance ( circles ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = n // 2 <NEWLINE> r , x , y = zip ( * circles ) <NEWLINE> <NL> if len ( set ( x ) ) > len ( set ( y ) ) : <NEWLINE> <INDENT> if axis == 2 : <NEWLINE> <INDENT> circles . sort ( key = lambda c : c [ 1 ] - c [ 0 ] ) <NEWLINE> <DEDENT> axis1 = 1 <NEWLINE> axis2 = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if axis == 1 : <NEWLINE> <INDENT> circles . sort ( key = lambda c : c [ 2 ] - c [ 0 ] ) <NEWLINE> <DEDENT> axis1 = 2 <NEWLINE> axis2 = 1 <NEWLINE> <NL> <DEDENT> A_circles = circles [ : mid ] <NEWLINE> B_circles = circles [ mid : ] <NEWLINE> <NL> d_Amin = closest_pair_distance ( A_circles . copy ( ) , axis1 ) <NEWLINE> d_Bmin = closest_pair_distance ( B_circles . copy ( ) , axis1 ) <NEWLINE> dist = min ( d_Amin , d_Bmin ) <NEWLINE> min_d = dist <NEWLINE> <NL> A_circles . sort ( key = lambda c : c [ axis ] + c [ 0 ] ) <NEWLINE> B_edge = B_circles [ 0 ] [ axis1 ] - B_circles [ 0 ] [ 0 ] <NEWLINE> for ac in A_circles [ : : - 1 ] : <NEWLINE> <INDENT> ac_r = ac [ 0 ] <NEWLINE> ac_edge = ac [ axis1 ] + ac_r <NEWLINE> if B_edge - ac_edge >= dist : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for bc in B_circles : <NEWLINE> <INDENT> bc_r = bc [ 0 ] <NEWLINE> if bc [ axis1 ] - bc_r - ac_edge >= dist : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if abs ( ac [ axis2 ] - bc [ axis2 ] ) - ac_r - bc_r < dist : <NEWLINE> <INDENT> min_d = min ( min_d , _get_distance ( ac , bc ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return min_d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input_lines = sys . stdin . readlines ( ) <NEWLINE> while True : <NEWLINE> <INDENT> N = int ( input_lines [ 0 ] ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> circles = [ tuple ( map ( float , l . split ( ) ) ) for l in input_lines [ 1 : N + 1 ] ] <NEWLINE> print ( <STRING> . format ( closest_pair_distance ( circles ) ) ) <NEWLINE> del input_lines [ : N + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N + 1 >= B : <NEWLINE> <INDENT> T = int ( A * ( B - 1 ) / B ) <NEWLINE> print ( T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T = int ( A * N / B ) <NEWLINE> print ( T ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = [ 0 ] * N <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> temp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if temp <= N : <NEWLINE> <INDENT> li [ temp - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = min ( b - 1 , n ) <NEWLINE> f = math . floor ( a * c / b ) <NEWLINE> print ( f ) <NEWLINE>
<COMMENT> <NL> <NL> data = [ ] <NEWLINE> data . append ( [ int ( input ( ) ) ] ) <NEWLINE> length = 2 <NEWLINE> counter = 0 <NEWLINE> while length != 1 : <NEWLINE> <INDENT> r = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> data . append ( r ) <NEWLINE> length = len ( r ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> N = int ( ( counter + 1 ) / 2 ) + 1 <NEWLINE> dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> data_arr = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> <NL> left = data [ : N ] <NEWLINE> right = data [ N : ] <NEWLINE> <NL> i = 0 <NEWLINE> for v in left : <NEWLINE> <INDENT> for idx , r in enumerate ( v ) : <NEWLINE> <INDENT> data_arr [ i - idx ] [ idx ] = r <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> right . reverse ( ) <NEWLINE> for i , v in enumerate ( right ) : <NEWLINE> <INDENT> for idx , r in enumerate ( v ) : <NEWLINE> <INDENT> data_arr [ N - 1 - idx ] [ N - 1 - i + idx ] = r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dp [ 0 ] [ 0 ] = data_arr [ 0 ] [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + data_arr [ 0 ] [ i ] <NEWLINE> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + data_arr [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] [ j ] += data_arr [ i ] [ j ] + max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] [ N - 1 ] ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> n , k = inpm ( ) <NEWLINE> A = sorted ( inpl ( ) ) <NEWLINE> <NL> f = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f . append ( f [ - 1 ] * i % mod ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> if n <= 0 or r <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> x = f [ n ] % mod <NEWLINE> y = f [ r ] * f [ n - r ] % mod <NEWLINE> return ( x * pow ( y , mod - 2 , mod ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = comb ( n - i - 1 , k - 1 ) <NEWLINE> ans += A [ n - 1 - i ] * c - A [ i ] * c <NEWLINE> ans %= mod <NEWLINE> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = pow ( 10 , 5 ) + 2 <NEWLINE> N = int ( input ( ) ) <NEWLINE> num = [ 0 ] * mod <NEWLINE> ans = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num [ A [ i ] ] += 1 <NEWLINE> ans += A [ i ] <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = num [ B ] <NEWLINE> num [ C ] += num [ B ] <NEWLINE> num [ B ] = 0 <NEWLINE> ans += ( C - B ) * cnt <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod_num = int ( 1.0e+9 + 7 ) <NEWLINE> rest = 0 <NEWLINE> temp = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> temp += A [ i ] <NEWLINE> rest += temp * A [ i + 1 ] <NEWLINE> rest = rest % mod_num <NEWLINE> <NL> <DEDENT> print ( int ( rest % mod_num ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> def print_list ( A ) : <NEWLINE> <INDENT> for a in A [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> % a , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ - 1 ] ) <NEWLINE> <NL> <DEDENT> def InsertionSort ( A , N ) : <NEWLINE> <INDENT> print_list ( A ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print_list ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> InsertionSort ( A , N ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from copy import deepcopy <NEWLINE> import queue <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , nums ) : <NEWLINE> <INDENT> self . labels = [ None ] + [ nums [ i ] for i in range ( 6 ) ] <NEWLINE> self . pos = { <NEWLINE> <INDENT> <STRING> : 3 , <NEWLINE> <STRING> : 4 , <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 5 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 6 <NEWLINE> <DEDENT> } <NEWLINE> <NL> <DEDENT> def rolled ( dice , queries ) : <NEWLINE> <INDENT> d = deepcopy ( dice ) <NEWLINE> for q in queries : <NEWLINE> <INDENT> if q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] = d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] , d . pos [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d1_nums = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> d2_nums = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if set ( d1_nums ) != set ( d2_nums ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> d1 = Dice ( d1_nums ) <NEWLINE> d2 = Dice ( d2_nums ) <NEWLINE> <NL> <COMMENT> <NL> memo = [ [ False ] * 7 for i in range ( 7 ) ] <NEWLINE> memo [ d1 . pos [ <STRING> ] ] [ d1 . pos [ <STRING> ] ] = <STRING> <NEWLINE> <NL> <COMMENT> <NL> res = { } <NEWLINE> for j in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if d1 . labels [ d1 . pos [ j ] ] != d2 . labels [ d2 . pos [ j ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ memo [ d1 . pos [ <STRING> ] ] [ d1 . pos [ <STRING> ] ] ] = d1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def solve ( dice = d1 ) : <NEWLINE> <INDENT> que = queue . Queue ( ) <NEWLINE> que . put ( dice ) <NEWLINE> sol_q = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> while not que . empty ( ) : <NEWLINE> <INDENT> d = que . get ( ) <NEWLINE> for i in sol_q : <NEWLINE> <INDENT> d_next = Dice . rolled ( d , i ) <NEWLINE> if memo [ d_next . pos [ <STRING> ] ] [ d_next . pos [ <STRING> ] ] == False : <NEWLINE> <INDENT> que . put ( d_next ) <NEWLINE> memo [ d_next . pos [ <STRING> ] ] [ d_next . pos [ <STRING> ] ] = memo [ d . pos [ <STRING> ] ] [ d . pos [ <STRING> ] ] + i <NEWLINE> for j in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if d_next . labels [ d_next . pos [ j ] ] != d2 . labels [ d2 . pos [ j ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res [ memo [ d_next . pos [ <STRING> ] ] [ d_next . pos [ <STRING> ] ] ] = d_next <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE> check_pos = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> if len ( res ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k , v in res . items ( ) : <NEWLINE> <INDENT> for i in check_pos : <NEWLINE> <INDENT> if v . labels [ v . pos [ i ] ] != d2 . labels [ d2 . pos [ i ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> r = range ( a , b + 1 ) <NEWLINE> for i in sorted ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) : print ( i ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if ( i == j and j == k ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif ( i == j or j == k ) : <NEWLINE> <INDENT> ans += math . gcd ( i , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> two = [ ] <NEWLINE> total = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> two . append ( math . gcd ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in two : <NEWLINE> <INDENT> total += math . gcd ( z , i ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> def Sum ( A , n ) : <NEWLINE> <INDENT> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum = array_sum + A [ i ] <NEWLINE> <DEDENT> array_sum_square = array_sum * array_sum <NEWLINE> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += A [ i ] * A [ i ] <NEWLINE> <DEDENT> return ( array_sum_square - individual_square_sum ) // 2 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( Sum ( a , n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> m , m2 = - 1 , - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a . append ( b ) <NEWLINE> m2 = max ( m2 , min ( m , b ) ) <NEWLINE> m = max ( m , b ) <NEWLINE> <NL> <DEDENT> if m == m2 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = [ m ] * n <NEWLINE> l [ a . index ( m ) ] = m2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = b - a <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , x , 1 ) : <NEWLINE> <INDENT> s += i <NEWLINE> <NL> <DEDENT> ans = s - a <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> elif K <= A + B + C : <NEWLINE> <INDENT> ans = A - ( K - ( A + B ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import itertools <NEWLINE> <NL> n , m , x = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> c = [ [ int ( y ) for y in x . rstrip ( ) . split ( ) ] for x in stdin . readlines ( ) ] <NEWLINE> c . sort ( ) <NEWLINE> mi = - 1 <NEWLINE> r = 0 <NEWLINE> <NL> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> li = [ x [ j ] for x in c ] <NEWLINE> li . sort ( reverse = True ) <NEWLINE> for i in range ( 1 , len ( li ) + 1 ) : <NEWLINE> <INDENT> if sum ( li [ : i ] ) >= x : <NEWLINE> <INDENT> r = max ( r , i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for h in range ( r , n + 1 ) : <NEWLINE> <INDENT> for i in itertools . combinations ( c , h ) : <NEWLINE> <INDENT> cnt = [ 0 ] * m <NEWLINE> mon = 0 <NEWLINE> for j in i : <NEWLINE> <INDENT> cnt = [ cnt [ k ] + j [ k + 1 ] for k in range ( len ( cnt ) ) ] <NEWLINE> mon += j [ 0 ] <NEWLINE> if sum ( 1 for k in cnt if k >= x ) == m : <NEWLINE> <INDENT> if mi > mon or mi == - 1 : <NEWLINE> <NL> <INDENT> mi = mon <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( mi ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 200 , 201 ) : <NEWLINE> <INDENT> for B in range ( - 200 , 201 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def bfs ( H , W , A , dist ) : <NEWLINE> <INDENT> queue = deque ( [ ] ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if A [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> dist [ h ] [ w ] = 0 <NEWLINE> queue . append ( ( h , w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while queue : <NEWLINE> <INDENT> h , w = queue . popleft ( ) <NEWLINE> for y , x in [ ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ] : <NEWLINE> <INDENT> next_h , next_w = h + y , w + x <NEWLINE> if dist [ next_h ] [ next_w ] == - 1 : <NEWLINE> <INDENT> dist [ next_h ] [ next_w ] = dist [ h ] [ w ] + 1 <NEWLINE> queue . append ( ( next_h , next_w ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ None ] * ( H + 2 ) <NEWLINE> A [ 0 ] = A [ - 1 ] = <STRING> * ( W + 2 ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> A [ i ] = <STRING> . join ( [ <STRING> , input ( ) . rstrip ( ) , <STRING> ] ) <NEWLINE> <NL> <DEDENT> dist = [ [ 0 ] + [ - 1 ] * W + [ 0 ] for _ in range ( H + 2 ) ] <NEWLINE> dist [ 0 ] = dist [ - 1 ] = [ 0 ] * ( W + 2 ) <NEWLINE> bfs ( H + 2 , W + 2 , A , dist ) <NEWLINE> <NL> ans = max ( map ( max , dist ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> Poll_Dict = defaultdict ( int ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> Poll_Dict [ str ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> Max_Number = max ( Poll_Dict . values ( ) ) <NEWLINE> Max_List = sorted ( [ k [ 0 ] for k in Poll_Dict . items ( ) if k [ 1 ] == Max_Number ] ) <NEWLINE> <NL> for i in Max_List : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> NM = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> X = np . ones ( NM [ 0 ] ) <NEWLINE> AB = [ ] <NEWLINE> for i in range ( NM [ 1 ] ) : <NEWLINE> <INDENT> AB . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> if H [ AB [ i ] [ 0 ] - 1 ] > H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> X [ AB [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ AB [ i ] [ 0 ] - 1 ] < H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> X [ AB [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ AB [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> X [ AB [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> x = 0 <NEWLINE> for i in range ( NM [ 0 ] ) : <NEWLINE> <INDENT> if X [ i ] == 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> a = <STRING> ; b = n = 0 <NEWLINE> for c in e [ : - 1 ] : <NEWLINE> <INDENT> if <STRING> == c : b = 1 <NEWLINE> elif b & 1 : n = int ( c ) ; b = 2 <NEWLINE> elif b & 2 : a += c * n ; b = 0 <NEWLINE> else : a += c <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> C = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> C [ i ] += C [ i - 1 ] <NEWLINE> if ( S [ i - 1 : i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( C [ r - 1 ] - C [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def fill ( h , H , W , S , MAP , marker ) : <NEWLINE> <INDENT> if not <STRING> in S [ h ] : <NEWLINE> <INDENT> return MAP , marker <NEWLINE> <DEDENT> idxes = [ i for i , s in enumerate ( S [ h ] ) if s == <STRING> ] <NEWLINE> upper = h <NEWLINE> for hh in range ( h - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if MAP [ hh ] [ idxes [ 0 ] ] == 0 : <NEWLINE> <INDENT> upper = hh <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> down = h <NEWLINE> <NL> for hh in range ( h + 1 , H + 1 ) : <NEWLINE> <INDENT> if <STRING> in S [ hh ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> down = hh <NEWLINE> <DEDENT> <DEDENT> left = 1 <NEWLINE> for idx in idxes : <NEWLINE> <INDENT> MAP [ upper : down + 1 , left : idx + 1 ] = marker <NEWLINE> marker += 1 <NEWLINE> left = idx + 1 <NEWLINE> <DEDENT> MAP [ upper : down + 1 , left : W + 1 ] = marker - 1 <NEWLINE> return MAP , marker <NEWLINE> <NL> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> * ( W + 2 ) ] <NEWLINE> up = INF <NEWLINE> down = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> down = i <NEWLINE> if up == INF : <NEWLINE> <INDENT> up = i <NEWLINE> <NL> <DEDENT> <DEDENT> s = <STRING> + s + <STRING> <NEWLINE> S . append ( s ) <NEWLINE> <DEDENT> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> MAP = np . zeros ( ( H + 2 , W + 2 ) , dtype = np . int32 ) <NEWLINE> <NL> marker = 1 <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> MAP , marker = fill ( h , H , W , S , MAP , marker ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> ans = [ str ( s ) for s in MAP [ h , 1 : W + 1 ] ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> p = prime_decomposition ( n ) <NEWLINE> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for k in set ( p ) : <NEWLINE> <INDENT> b = p . count ( k ) <NEWLINE> a = 1 <NEWLINE> c = 1 <NEWLINE> while c <= b : <NEWLINE> <INDENT> a += 1 <NEWLINE> c += a <NEWLINE> <DEDENT> cnt += a - 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ans = a [ 1 ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if abs ( a [ 0 ] / 2 - a [ i ] ) > abs ( a [ 0 ] / 2 - a [ i + 1 ] ) : <NEWLINE> <INDENT> ans = a [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] , ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> lists = list ( c ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( len ( lists ) ) : <NEWLINE> <INDENT> if lists [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> change = 0 <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> if lists [ i ] == <STRING> : <NEWLINE> <INDENT> change += 1 <NEWLINE> <DEDENT> <DEDENT> print ( change ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = [ A [ i ] , i + 1 ] <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i ] = L [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ans * i > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> def check ( t ) : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai > t : <NEWLINE> <INDENT> ans += ai // t <NEWLINE> <DEDENT> <DEDENT> return ans <= k <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = 10 ** 9 + 1 <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <DEDENT> <DEDENT> if check ( l ) : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * ( n ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <COMMENT> <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> cnt [ a ] += b <NEWLINE> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in g [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt [ next ] += cnt [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * cnt ) <NEWLINE>
import bisect <NEWLINE> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> accum_a = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> _a = accum_a [ - 1 ] + i <NEWLINE> if _a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> accum_a . append ( _a ) <NEWLINE> <DEDENT> <DEDENT> accum_a . append ( K ) <NEWLINE> <NL> accum_b = [ 0 ] <NEWLINE> for i in b : <NEWLINE> <INDENT> accum_b . append ( accum_b [ - 1 ] + i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for j in range ( len ( accum_a ) - 1 ) : <NEWLINE> <INDENT> Kb = K - accum_a [ j ] <NEWLINE> bookB = bisect . bisect_right ( accum_b , Kb ) - 1 <NEWLINE> if j + bookB > ans : <NEWLINE> <INDENT> ans = j + bookB <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> <NL> class Edge : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w , capacity ) : <NEWLINE> <INDENT> self . src = v <NEWLINE> self . dest = w <NEWLINE> self . capacity = capacity <NEWLINE> self . flow = 0 <NEWLINE> <NL> <DEDENT> def other ( self , v ) : <NEWLINE> <INDENT> if v == self . src : <NEWLINE> <INDENT> return self . dest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . src <NEWLINE> <NL> <DEDENT> <DEDENT> def residual_capacity ( self , v ) : <NEWLINE> <INDENT> if v == self . src : <NEWLINE> <INDENT> return self . capacity - self . flow <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . flow <NEWLINE> <NL> <DEDENT> <DEDENT> def add_flow ( self , v , f ) : <NEWLINE> <INDENT> if v == self . src : <NEWLINE> <INDENT> self . flow += f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . flow -= f <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Network : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . _edges = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> <DEDENT> def add ( self , edge ) : <NEWLINE> <INDENT> self . _edges [ edge . src ] . append ( edge ) <NEWLINE> self . _edges [ edge . dest ] . append ( edge ) <NEWLINE> <NL> <DEDENT> def adj ( self , v ) : <NEWLINE> <INDENT> return self . _edges [ v ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def max_flow ( network , s , t ) : <NEWLINE> <INDENT> def augment_path ( ) : <NEWLINE> <INDENT> marked = [ False ] * network . v <NEWLINE> edge_to = [ None ] * network . v <NEWLINE> n = 0 <NEWLINE> heap = [ ( - 10 ** 6 , s , n , None ) ] <NEWLINE> while heap : <NEWLINE> <INDENT> cap , v , _ , e = heappop ( heap ) <NEWLINE> edge_to [ v ] = e <NEWLINE> if v == t : <NEWLINE> <INDENT> return ( - cap , edge_to ) <NEWLINE> <DEDENT> if not marked [ v ] : <NEWLINE> <INDENT> marked [ v ] = True <NEWLINE> for ne in network . adj ( v ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> w = ne . other ( v ) <NEWLINE> c = ne . residual_capacity ( v ) <NEWLINE> if not marked [ w ] and c > 0 : <NEWLINE> <INDENT> heappush ( heap , ( max ( - c , cap ) , w , n , ne ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( 0 , [ ] ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> cap , path = augment_path ( ) <NEWLINE> if cap == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> v = t <NEWLINE> e = path [ t ] <NEWLINE> while e is not None : <NEWLINE> <INDENT> v = e . other ( v ) <NEWLINE> e . add_flow ( v , cap ) <NEWLINE> e = path [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> return sum ( e . flow for e in network . adj ( s ) if e . src == s ) <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> v , e = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s , t = 0 , v - 1 <NEWLINE> net = Network ( v ) <NEWLINE> <NL> for _ in range ( e ) : <NEWLINE> <INDENT> v , w , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> net . add ( Edge ( v , w , c ) ) <NEWLINE> <NL> <DEDENT> print ( max_flow ( net , s , t ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
for i , x in enumerate ( iter ( lambda : int ( input ( ) ) , 0 ) , 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> <NL> minv = int ( input ( ) ) <NEWLINE> num = int ( input ( ) ) <NEWLINE> <NL> max_r = num - minv <NEWLINE> <NL> if ( minv > num ) : <NEWLINE> <INDENT> minv = num <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if ( max_r < ( num - minv ) ) : <NEWLINE> <INDENT> max_r = num - minv <NEWLINE> <NL> <DEDENT> if ( minv > num ) : <NEWLINE> <INDENT> minv = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_r ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> g_l = [ [ ] for i in range ( N ) ] <NEWLINE> check_l = [ - 1 ] * N <NEWLINE> num_l = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> g_l [ ai - 1 ] . append ( bi - 1 ) <NEWLINE> g_l [ bi - 1 ] . append ( ai - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( n ) : <NEWLINE> <INDENT> d = 1 <NEWLINE> if check_l [ n ] > 0 : <NEWLINE> <INDENT> return num_l [ n ] <NEWLINE> <DEDENT> check_l [ n ] = 1 <NEWLINE> for next_n in g_l [ n ] : <NEWLINE> <INDENT> d += dfs ( next_n ) <NEWLINE> <DEDENT> num_l [ n ] = d <NEWLINE> return d <NEWLINE> <NL> <NL> <DEDENT> def modinv ( a ) : <NEWLINE> <COMMENT> <NL> <INDENT> return pow ( a , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> dfs ( 0 ) <NEWLINE> pow_l = [ None ] * ( N + 1 ) <NEWLINE> pow_l [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pow_l [ i ] = ( pow_l [ i - 1 ] * 2 ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ( ans + ( pow_l [ num_l [ i ] ] - 1 ) * <NEWLINE> <INDENT> ( pow_l [ N - num_l [ i ] ] - 1 ) % MOD ) % MOD <NEWLINE> <DEDENT> <DEDENT> ans = ( ans + ( pow_l [ N ] - 1 ) - ( N * pow_l [ N - 1 ] ) % MOD ) % MOD <NEWLINE> y = ans <NEWLINE> x = pow ( 2 , N , MOD ) <NEWLINE> <NL> z = ( y * modinv ( x ) ) % MOD <NEWLINE> <NL> print ( z ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> total += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
def setHeapDown_max ( heap , pos ) : <NEWLINE> <INDENT> targetkey = heap [ pos ] <NEWLINE> while pos > 0 : <NEWLINE> <INDENT> parentpos = ( pos - 1 ) >> 1 <NEWLINE> parent = heap [ parentpos ] <NEWLINE> if parent < targetkey : <NEWLINE> <INDENT> heap [ pos ] = parent <NEWLINE> pos = parentpos <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> heap [ pos ] = targetkey <NEWLINE> <NL> <DEDENT> def setHeapUp_max ( heap , pos ) : <NEWLINE> <INDENT> endpos = len ( heap ) <NEWLINE> targetkey = heap [ pos ] <NEWLINE> childpos = 2 * pos + 1 <NEWLINE> while childpos < endpos : <NEWLINE> <INDENT> rightpos = childpos + 1 <NEWLINE> if rightpos < endpos and not heap [ rightpos ] < heap [ childpos ] : <NEWLINE> <INDENT> childpos = rightpos <NEWLINE> <DEDENT> heap [ pos ] = heap [ childpos ] <NEWLINE> pos = childpos <NEWLINE> childpos = 2 * pos + 1 <NEWLINE> <DEDENT> heap [ pos ] = targetkey <NEWLINE> setHeapDown_max ( heap , pos ) <NEWLINE> <NL> <DEDENT> def heapPush_max ( heap , key ) : <NEWLINE> <INDENT> heap . append ( key ) <NEWLINE> setHeapDown_max ( heap , len ( heap ) - 1 ) <NEWLINE> <NL> <DEDENT> def heapPop_max ( heap ) : <NEWLINE> <INDENT> lastkey = heap . pop ( ) <NEWLINE> if heap : <NEWLINE> <INDENT> returnkey = heap [ 0 ] <NEWLINE> heap [ 0 ] = lastkey <NEWLINE> setHeapUp_max ( heap , 0 ) <NEWLINE> return returnkey <NEWLINE> <DEDENT> return lastkey <NEWLINE> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> S = [ ] <NEWLINE> <NL> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> k = int ( x [ 7 : ] ) <NEWLINE> heapPush_max ( S , k ) <NEWLINE> <DEDENT> elif x [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( heapPop_max ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> boss = { i + 1 : 0 for i in range ( N ) } <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> boss [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( boss [ i + 1 ] ) <NEWLINE> <DEDENT>
def abc044_c ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( lambda x : int ( x ) - a , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> x = np . array ( x , dtype = np . int64 ) <NEWLINE> <NL> vrange = n * ( a + np . max ( x ) ) <COMMENT> <NEWLINE> dp = np . zeros ( ( n + 1 , 2 * vrange + 1 ) , dtype = np . int64 ) <COMMENT> <NEWLINE> dp [ 0 , vrange ] = 1 <COMMENT> <NEWLINE> <NL> for i in np . arange ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , : ] += dp [ i , : ] <NEWLINE> if 0 < x [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , x [ i ] : ] += dp [ i , : - x [ i ] ] <NEWLINE> <DEDENT> elif x [ i ] < 0 : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , : x [ i ] ] += dp [ i , - x [ i ] : ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , : ] += dp [ i , : ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = dp [ n , vrange ] - 1 <COMMENT> <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc044_c ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> cum_ls = [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 : i + 1 ] == <STRING> : <NEWLINE> <INDENT> cum_ls . append ( cum_ls [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum_ls . append ( cum_ls [ i - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cum_ls [ r - 1 ] - cum_ls [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 , 0 , 0 , 0 ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , ans [ 0 ] ) <NEWLINE> print ( <STRING> , ans [ 1 ] ) <NEWLINE> print ( <STRING> , ans [ 2 ] ) <NEWLINE> print ( <STRING> , ans [ 3 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> buttons = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> cur = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cur = buttons [ cur - 1 ] <NEWLINE> <NL> if cur == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> tenant = [ <NEWLINE> <INDENT> [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 , ] , <NEWLINE> [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 , ] , <NEWLINE> [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 , ] , <NEWLINE> [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 , ] <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , nu = map ( int , input ( ) . split ( ) ) <NEWLINE> tenant [ b - 1 ] [ f - 1 ] [ r - 1 ] += nu <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , tenant [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> cach = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s == deque ( [ ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = s . popleft ( ) <NEWLINE> <NL> <DEDENT> if tmp != cach : <NEWLINE> <INDENT> ans += 1 <NEWLINE> cach = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s != deque ( [ ] ) : <NEWLINE> <INDENT> tmp += s . popleft ( ) <NEWLINE> ans += 1 <NEWLINE> cach = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if x not in l : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> tmp = [ ] <NEWLINE> for i in range ( x - 60 , x + 60 ) : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for j in tmp : <NEWLINE> <INDENT> if j not in l : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> tmp1 = 100 <NEWLINE> for k in ans : <NEWLINE> <INDENT> tmp2 = abs ( x - k ) <NEWLINE> if tmp2 != 0 : <NEWLINE> <INDENT> if tmp1 >= tmp2 : <NEWLINE> <INDENT> tmp1 = tmp2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans2 = [ ] <NEWLINE> for m in ans : <NEWLINE> <INDENT> a = abs ( m - x ) <NEWLINE> if a == tmp1 : <NEWLINE> <INDENT> ans2 . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ans2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def ruiseki ( n , array ) : <NEWLINE> <INDENT> res = [ 0 ] * ( n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res [ i ] = res [ i - 1 ] + array [ i ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = ruiseki ( n , A ) <NEWLINE> <NL> ans = 10 ** 15 <NEWLINE> left_c = 0 <NEWLINE> right_c = 2 <NEWLINE> for center in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> while left_c + 1 < center : <NEWLINE> <INDENT> if abs ( sa [ center ] - 2 * sa [ left_c ] ) > abs ( sa [ center ] - 2 * sa [ left_c + 1 ] ) : <NEWLINE> <INDENT> left_c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> right_c = max ( right_c , center + 1 ) <NEWLINE> while right_c + 1 < n - 1 : <NEWLINE> <INDENT> if abs ( sa [ - 1 ] + sa [ center ] - 2 * sa [ right_c ] ) > abs ( sa [ - 1 ] + sa [ center ] - 2 * sa [ right_c + 1 ] ) : <NEWLINE> <INDENT> right_c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> x = max ( sa [ left_c ] , sa [ center ] - sa [ left_c ] , sa [ right_c ] - sa [ center ] , sa [ - 1 ] - sa [ right_c ] ) <NEWLINE> y = min ( sa [ left_c ] , sa [ center ] - sa [ left_c ] , sa [ right_c ] - sa [ center ] , sa [ - 1 ] - sa [ right_c ] ) <NEWLINE> ans = min ( ans , x - y ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import heapq <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Us = [ 0 ] * M <NEWLINE> Vs = [ 0 ] * M <NEWLINE> As = [ 0 ] * M <NEWLINE> Bs = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Us [ i ] , Vs [ i ] , As [ i ] , Bs [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> Us [ i ] -= 1 <NEWLINE> Vs [ i ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> V = { } <NEWLINE> Ns = max ( As ) * N <NEWLINE> Nv = N * ( Ns + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for ns in range ( Ns + 1 ) : <NEWLINE> <INDENT> V [ ( i , ns ) ] = cnt <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> G = [ [ ] for _ in range ( Nv ) ] <NEWLINE> <NL> if S > Ns : <NEWLINE> <INDENT> S = Ns <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> u = Us . pop ( ) <NEWLINE> v = Vs . pop ( ) <NEWLINE> a = As . pop ( ) <NEWLINE> b = Bs . pop ( ) <NEWLINE> <COMMENT> <NL> for i in range ( Ns + 1 ) : <COMMENT> <NEWLINE> <INDENT> ns_s = Ns - i <NEWLINE> ns_g = ns_s - a <NEWLINE> if ns_g >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> G [ V [ ( u , ns_s ) ] ] . append ( ( V [ ( v , ns_g ) ] , b ) ) <NEWLINE> <COMMENT> <NL> G [ V [ ( v , ns_s ) ] ] . append ( ( V [ ( u , ns_g ) ] , b ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( Ns ) : <COMMENT> <NEWLINE> <INDENT> ns_s = j <NEWLINE> ns_g = j + c <NEWLINE> if ns_g > Ns : <NEWLINE> <INDENT> ns_g = Ns <NEWLINE> <DEDENT> G [ V [ ( i , ns_s ) ] ] . append ( ( V [ ( i , ns_g ) ] , d ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> D = [ math . inf ] * Nv <NEWLINE> q = [ ] <NEWLINE> <COMMENT> <NL> <NL> s = V [ ( 0 , S ) ] <NEWLINE> D [ s ] = 0 <NEWLINE> heapq . heappush ( q , ( 0 , s ) ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> p_cost , p_v = heapq . heappop ( q ) <NEWLINE> if D [ p_v ] < p_cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for e_to , e_cost in G [ p_v ] : <NEWLINE> <INDENT> if D [ e_to ] > D [ p_v ] + e_cost : <NEWLINE> <INDENT> D [ e_to ] = D [ p_v ] + e_cost <NEWLINE> heapq . heappush ( q , ( D [ e_to ] , e_to ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = min ( [ D [ i * ( Ns + 1 ) + v ] for v in range ( Ns + 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
temp = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> max_count = 0 <NEWLINE> <NL> for i in temp : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> max_count = count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_count < count : <NEWLINE> <INDENT> max_count = count <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> sub = 0 <NEWLINE> for j in range ( 1 , ( N - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , N - 2 * j ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + 2 * j ] and S [ i + 2 * j ] != S [ i ] : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = N - r - g <NEWLINE> <NL> ans = r * g * b - sub <NEWLINE> print ( ans ) <NEWLINE>
x = [ i for i in input ( ) ] <NEWLINE> y = [ i for i in range ( len ( x ) ) ] <NEWLINE> y = x . copy ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = [ j for j in input ( ) . split ( ) ] <NEWLINE> if len ( c ) == 4 : <NEWLINE> <INDENT> for j in range ( len ( c [ 3 ] ) ) : <NEWLINE> <INDENT> y [ j + int ( c [ 1 ] ) ] = list ( c [ 3 ] ) [ j ] <NEWLINE> <DEDENT> x = y . copy ( ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> for j in range ( int ( c [ 1 ] ) , int ( c [ 2 ] ) + 1 ) : <NEWLINE> <INDENT> print ( x [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( int ( c [ 2 ] ) + 1 - int ( c [ 1 ] ) ) : <NEWLINE> <INDENT> z = [ i for i in range ( len ( x ) ) ] <NEWLINE> z = x . copy ( ) <NEWLINE> y [ int ( c [ 2 ] ) - j ] = z [ int ( c [ 1 ] ) + j ] <NEWLINE> <DEDENT> x = y . copy ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> max = int ( math . sqrt ( max ( n , 1 ) ) ) + 1 <NEWLINE> <NL> for x in range ( 1 , max ) : <NEWLINE> <INDENT> for y in range ( 1 , max ) : <NEWLINE> <INDENT> for z in range ( 1 , max ) : <NEWLINE> <INDENT> ns = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ns <= n : <NEWLINE> <INDENT> ans [ ns - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in range ( n ) : <NEWLINE> <INDENT> print ( ans [ a ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if a > pow ( 10 , 18 ) or ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += gcd ( temp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a not in d : <NEWLINE> <INDENT> d [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dsorted = sorted ( d . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> name = [ ] <NEWLINE> cnt = dsorted [ 0 ] [ 1 ] <NEWLINE> <NL> for i in dsorted : <NEWLINE> <INDENT> if i [ 1 ] == cnt : <NEWLINE> <INDENT> name . append ( i [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> name . sort ( ) <NEWLINE> <NL> for i in name : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in reversed ( range ( 1 , min ( a , b ) + 1 ) ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> k = k - 1 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> A_sum = 0 <NEWLINE> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> A_sum = A_sum + A [ i ] <NEWLINE> <NL> <DEDENT> A_sum_sq = A_sum * A_sum <NEWLINE> <NL> idv_sq_sum = 0 <NEWLINE> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> idv_sq_sum += A [ i ] * A [ i ] <NEWLINE> <NL> <DEDENT> Answer = ( A_sum_sq - <NEWLINE> <INDENT> idv_sq_sum ) // 2 <NEWLINE> <DEDENT> print ( Answer % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> ans = math . floor ( A * ( x % B ) / B ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) , input ( ) <NEWLINE> indices = [ ] <NEWLINE> for cb in b : <NEWLINE> <INDENT> bgn_idx = 0 <NEWLINE> for i in range ( len ( indices ) + 1 ) : <NEWLINE> <INDENT> chr_idx = a . find ( cb , bgn_idx ) + 1 <NEWLINE> if chr_idx : <NEWLINE> <INDENT> if i < len ( indices ) : <NEWLINE> <INDENT> bgn_idx = indices [ i ] <NEWLINE> if chr_idx < bgn_idx : <NEWLINE> <INDENT> indices [ i ] = chr_idx <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> indices . append ( chr_idx ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( indices ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = [ 0 ] * N <NEWLINE> for i in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> ans = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if ans <= N : <NEWLINE> <INDENT> num [ ans - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( num [ i ] ) <NEWLINE> <DEDENT>
def cut ( d , w , s ) : <NEWLINE> <INDENT> s %= 2 * ( d + w ) <NEWLINE> sq = [ ] <NEWLINE> if 0 < s < w : <NEWLINE> <INDENT> sq = [ ( d , s ) , ( d , w - s ) ] <NEWLINE> <DEDENT> elif w < s < w + d : <NEWLINE> <INDENT> s -= w <NEWLINE> sq = [ ( s , w ) , ( d - s , w ) ] <NEWLINE> <DEDENT> elif w + d < s < 2 * w + d : <NEWLINE> <INDENT> s -= w + d <NEWLINE> sq = [ ( d , s ) , ( d , w - s ) ] <NEWLINE> <DEDENT> elif 2 * w + d < s < 2 * ( w + d ) : <NEWLINE> <INDENT> s -= 2 * w + d <NEWLINE> sq = [ ( s , w ) , ( d - s , w ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert ( False ) <NEWLINE> <DEDENT> p1 , p2 = sq <NEWLINE> if p1 [ 0 ] * p1 [ 1 ] > p2 [ 0 ] * p2 [ 1 ] : <NEWLINE> <INDENT> p1 , p2 = p2 , p1 <NEWLINE> <DEDENT> return [ p1 , p2 ] <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( N | W | D ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> square = [ ( D , W ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> p , s = map ( int , input ( ) . split ( ) ) <NEWLINE> d , w = square . pop ( p - 1 ) <NEWLINE> square . extend ( cut ( d , w , s ) ) <NEWLINE> <DEDENT> print ( * sorted ( d * w for d , w in square ) ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> i = 1 <NEWLINE> while x != <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> x = input ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = set ( [ 1 ] ) <NEWLINE> loop = [ 1 ] <NEWLINE> now = 1 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> if now in visited : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( now ) <NEWLINE> visited . add ( now ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = loop . index ( now ) <NEWLINE> <NL> if K < x : <NEWLINE> <INDENT> print ( loop [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= x <NEWLINE> loop = loop [ x : ] <NEWLINE> K %= len ( loop ) <NEWLINE> print ( loop [ K ] ) <NEWLINE> <DEDENT>
m = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans1 = [ ] <NEWLINE> ans = 0 <NEWLINE> if m > 1 : <NEWLINE> <NL> <INDENT> for x in range ( m - 1 ) : <NEWLINE> <INDENT> if h [ x ] < h [ x + 1 ] : <NEWLINE> <INDENT> ans1 . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ans1 . append ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( max ( ans1 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> k = list ( range ( 0 , 100000 ) ) <NEWLINE> k5 = [ ] <NEWLINE> for i in k : <NEWLINE> <INDENT> k5 . append ( i ** 5 ) <NEWLINE> <DEDENT> for j in k5 : <NEWLINE> <INDENT> if X + j in k5 : <NEWLINE> <INDENT> print ( k [ k5 . index ( X + j ) ] , k [ k5 . index ( j ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X - j in k5 : <NEWLINE> <INDENT> print ( k [ k5 . index ( X - j ) ] , - k [ k5 . index ( j ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> Alist . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans *= Alist [ i ] <NEWLINE> if Alist [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> a , b = int ( n [ 0 ] ) , int ( n [ 1 ] ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a == 0 or b == 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
a = str ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b . append ( int ( a [ i ] ) ) <NEWLINE> <DEDENT> if sum ( b ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s in dic : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> S = sorted ( dic . values ( ) ) <NEWLINE> t = S [ - 1 ] <NEWLINE> <NL> X = [ ] <NEWLINE> for key in dic : <NEWLINE> <INDENT> if dic [ key ] == t : <NEWLINE> <INDENT> X . append ( key ) <NEWLINE> <DEDENT> <DEDENT> x = sorted ( X ) <NEWLINE> <NL> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> list_s = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> list_s . append ( ( l , r ) ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> sdp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> sdp [ 0 ] = 0 <NEWLINE> sdp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for l , r in list_s : <NEWLINE> <INDENT> dl = max ( 0 , i - r - 1 ) <NEWLINE> dr = max ( 0 , i - l ) <NEWLINE> dp [ i ] += sdp [ dr ] - sdp [ dl ] <NEWLINE> sdp [ i ] = ( sdp [ i - 1 ] + dp [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> sum = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> sum *= i <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> q = collections . deque ( ) <NEWLINE> cmds = { <STRING> : lambda cmd : q . appendleft ( cmd [ 1 ] ) , <NEWLINE> <INDENT> <STRING> : lambda cmd : q . remove ( cmd [ 1 ] ) if ( q . count ( cmd [ 1 ] ) > 0 ) else <STRING> , <NEWLINE> <STRING> : lambda cmd : q . popleft ( ) , <NEWLINE> <STRING> : lambda cmd : q . pop ( ) <NEWLINE> } <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> cmds [ cmd [ 0 ] ] ( cmd ) <NEWLINE> <DEDENT> print ( * q ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( res , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> s = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . add ( input ( ) ) <NEWLINE> <DEDENT> cnt = len ( s ) <NEWLINE> <NL> print ( cnt ) <NEWLINE>
def f ( a , b ) : <NEWLINE> <INDENT> str_a = str ( a ) <NEWLINE> len_a = len ( str_a ) <NEWLINE> str_b = str ( b ) <NEWLINE> len_b = len ( str_b ) <NEWLINE> <NL> return len_a if len_a > len_b else len_b <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> min = 10 ** 10 <NEWLINE> max_iter = 10 ** ( len ( str ( N ) ) // 2 + 1 ) <NEWLINE> <NL> for i in range ( 1 , max_iter ) : <NEWLINE> <INDENT> a = i <NEWLINE> if N % a == 0 : <NEWLINE> <INDENT> b = int ( N / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ret = f ( a , b ) <NEWLINE> if min > ret : <NEWLINE> <INDENT> min = ret <NEWLINE> if min <= len ( str ( N ) ) // 2 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
n , m , r = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = sorted ( [ n - 1 , r - m * n ] ) <NEWLINE> d = 1 <NEWLINE> for i in range ( a ) : d *= i + 1 <NEWLINE> u = 1 <NEWLINE> for i in range ( b , a + b ) : u *= i + 1 <NEWLINE> print ( 0 if a < 1 else u // d ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> n1 = n ** ( 1 / 5 ) <NEWLINE> if n1 == int ( n1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> l = set ( ) <NEWLINE> l . add ( 0 ) <NEWLINE> i = 1 <NEWLINE> while i ** 5 < 100 * x : <NEWLINE> <INDENT> i1 = i ** 5 <NEWLINE> l . add ( i1 ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> l . add ( - i1 ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> b = i <NEWLINE> a = x + b <NEWLINE> if a in l : <NEWLINE> <INDENT> if a != 0 and b != 0 : <NEWLINE> <INDENT> a1 = ( a / abs ( a ) ) * ( abs ( a ) ** ( 1 / 5 ) ) <NEWLINE> b1 = ( b / abs ( b ) ) * ( abs ( b ) ** ( 1 / 5 ) ) <NEWLINE> print ( int ( a1 ) , int ( b1 ) ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> a1 = ( a / abs ( a ) ) * ( abs ( a ) ** ( 1 / 5 ) ) <NEWLINE> print ( int ( a1 ) , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b1 = ( b / abs ( b ) ) * ( abs ( b ) ** ( 1 / 5 ) ) <NEWLINE> print ( 0 , int ( b1 ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = collections . Counter ( s ) <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ga = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ga = math . gcd ( ga , a [ i ] ) <NEWLINE> <NL> <DEDENT> if ga != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> m = 1000000 <NEWLINE> b = [ 0 ] * ( m + 1 ) <NEWLINE> <COMMENT> <NL> for i in range ( 2 , m ) : <NEWLINE> <INDENT> if b [ i ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = 1 <NEWLINE> while True : <NEWLINE> <INDENT> t = i * j <NEWLINE> if t > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if b [ t ] == 0 : <NEWLINE> <INDENT> b [ t ] = i <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> d = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> p = i <NEWLINE> <COMMENT> <NL> while p != 1 : <NEWLINE> <INDENT> if p in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> d [ p ] = 1 <NEWLINE> p = int ( p / b [ p ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> k = sorted ( list ( c . keys ( ) ) ) <NEWLINE> <NL> kl = k [ - 1 ] <NEWLINE> b = [ 1 ] * kl <NEWLINE> cnt = 0 <NEWLINE> for i in k : <NEWLINE> <INDENT> if c [ i ] == 1 and b [ i - 1 ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> for j in range ( 1 , kl + 1 ) : <NEWLINE> <INDENT> if i * j > kl : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i * j - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> def pr ( n ) : <NEWLINE> <INDENT> L = [ ] <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> n = n // i <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> L . append ( n ) <NEWLINE> <DEDENT> return L <NEWLINE> <DEDENT> dic = { 1 : 1 , 2 : 1 , 3 : 2 , 4 : 2 , 5 : 2 , 6 : 3 , 7 : 3 , 8 : 3 , 9 : 3 , 10 : 4 , 11 : 4 , 12 : 4 , 13 : 4 , 14 : 4 , 15 : 5 , 16 : 5 , 17 : 5 , 18 : 5 , 19 : 5 , 20 : 5 , 21 : 6 , 22 : 6 , 23 : 6 , 24 : 6 , 25 : 6 , 27 : 6 , 28 : 7 , 29 : 7 , 30 : 7 , 31 : 7 , 32 : 7 , 33 : 7 , 34 : 7 , 35 : 7 , 36 : 8 , 39 : 8 , 40 : 8 } <NEWLINE> L = pr ( n ) <NEWLINE> <COMMENT> <NL> L = Counter ( L ) <NEWLINE> num = 0 <NEWLINE> for k , v in L . items ( ) : <NEWLINE> <INDENT> num += dic [ v ] <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
inputs = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( inputs [ 0 ] ) <NEWLINE> b = int ( inputs [ 1 ] ) <NEWLINE> n = int ( inputs [ 2 ] ) + 1 <NEWLINE> <NL> x = ( n if n < b else b ) - 1 <NEWLINE> output = ( a * x // b ) <NEWLINE> <NL> print ( output ) <NEWLINE>
N = input ( ) <NEWLINE> if N . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h_list = [ 0 for _ in range ( H + 1 ) ] <NEWLINE> w_list = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> m_dic = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list [ h ] += 1 <NEWLINE> w_list [ w ] += 1 <NEWLINE> m_dic [ <STRING> . format ( h , w ) ] = 1 <NEWLINE> <NL> <DEDENT> max_h_list = [ ] <NEWLINE> max_h = - 1 <NEWLINE> for i in range ( H + 1 ) : <NEWLINE> <INDENT> if max_h == h_list [ i ] : <NEWLINE> <INDENT> max_h_list . append ( i ) <NEWLINE> <DEDENT> elif max_h < h_list [ i ] : <NEWLINE> <INDENT> max_h = h_list [ i ] <NEWLINE> max_h_list = [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> max_w_list = [ ] <NEWLINE> max_w = - 1 <NEWLINE> for i in range ( W + 1 ) : <NEWLINE> <INDENT> if max_w == w_list [ i ] : <NEWLINE> <INDENT> max_w_list . append ( i ) <NEWLINE> <DEDENT> elif max_w < w_list [ i ] : <NEWLINE> <INDENT> max_w = w_list [ i ] <NEWLINE> max_w_list = [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> adjust_dupl = 1 <NEWLINE> for i in range ( len ( max_h_list ) ) : <NEWLINE> <INDENT> for j in range ( len ( max_w_list ) ) : <NEWLINE> <INDENT> if <STRING> . format ( max_h_list [ i ] , max_w_list [ j ] ) not in m_dic : <NEWLINE> <INDENT> adjust_dupl = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if adjust_dupl == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max_h + max_w - adjust_dupl ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ( ans + L [ i ] * x ) % mod <NEWLINE> x = ( x + L [ i ] % mod ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def binary_search ( lis , item ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = len ( lis ) - 1 <NEWLINE> inRange = high <NEWLINE> <NL> if lis [ 0 ] > item : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess1 = lis [ mid ] <NEWLINE> if mid < inRange : <NEWLINE> <INDENT> guess2 = lis [ mid + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ mid ] <= item : <NEWLINE> <INDENT> return len ( lis ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return len ( lis ) - 1 <NEWLINE> <DEDENT> <DEDENT> if guess1 <= item < guess2 : <NEWLINE> <INDENT> return mid + 1 <NEWLINE> <DEDENT> if guess1 > item : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> n , m , k = iim ( ) <NEWLINE> a = iil ( ) <NEWLINE> cuma = [ ] <NEWLINE> if a [ 0 ] <= k : <NEWLINE> <INDENT> cuma . append ( a [ 0 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> num = cuma [ - 1 ] + a [ i + 1 ] <NEWLINE> if num > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cuma . append ( num ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> b = iil ( ) <NEWLINE> cumb = [ ] <NEWLINE> if b [ 0 ] <= k : <NEWLINE> <INDENT> cumb . append ( b [ 0 ] ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> num = cumb [ - 1 ] + b [ i + 1 ] <NEWLINE> if num > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cumb . append ( num ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = len ( cumb ) <NEWLINE> <COMMENT> <NL> if len ( cuma ) > 0 : <NEWLINE> <INDENT> cnt = len ( cuma ) <NEWLINE> for i , item in enumerate ( cuma [ : : - 1 ] ) : <NEWLINE> <INDENT> tmp = cnt - i <NEWLINE> res = k - item <NEWLINE> plus = binary_search ( cumb , res ) <NEWLINE> ans = max ( ans , tmp + plus ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> s . reverse ( ) <NEWLINE> print ( <STRING> . join ( map ( str , s ) ) ) <NEWLINE>
mod = 998244353 <NEWLINE> fact = [ 1 ] <NEWLINE> for i in range ( 1 , 2 * 10 ** 5 + 1 ) : <COMMENT> <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> <DEDENT> revfact = [ 1 ] <NEWLINE> for i in range ( 1 , 2 * 10 ** 5 + 1 ) : <COMMENT> <NEWLINE> <INDENT> revfact . append ( pow ( fact [ i ] , mod - 2 , mod ) ) <NEWLINE> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k , - 1 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> group = n - i <NEWLINE> tmp = fact [ n - 1 ] * revfact [ group - 1 ] * revfact [ n - 1 - ( group - 1 ) ] <NEWLINE> tmp %= mod <NEWLINE> tmp *= m <NEWLINE> tmp %= mod <NEWLINE> tmp *= pow ( m - 1 , group - 1 , mod ) <NEWLINE> ans += tmp <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> isVisited = [ False ] * n <NEWLINE> <NL> CC = [ None ] * n <NEWLINE> <NL> <NL> def dfs ( u , group ) : <NEWLINE> <INDENT> path = [ ] <NEWLINE> path . append ( u ) <NEWLINE> isVisited [ u ] = True <NEWLINE> CC [ u ] = group <NEWLINE> while path : <NEWLINE> <INDENT> u = path [ - 1 ] <NEWLINE> if adj [ u ] : <NEWLINE> <INDENT> v = adj [ u ] . pop ( 0 ) <NEWLINE> if not isVisited [ v ] : <NEWLINE> <INDENT> isVisited [ v ] = True <NEWLINE> CC [ v ] = group <NEWLINE> path . append ( v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> path . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def makeCC ( group ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if not isVisited [ i ] : <NEWLINE> <INDENT> dfs ( i , group ) <NEWLINE> group += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def isConnected ( v1 , v2 ) : <NEWLINE> <INDENT> if CC [ v1 ] == CC [ v2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> makeCC ( 0 ) <NEWLINE> <NL> <NL> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> isConnected ( s , t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def print_arr ( arr ) : <NEWLINE> <INDENT> ln = <STRING> <NEWLINE> for v in arr : <NEWLINE> <INDENT> ln += str ( v ) + <STRING> <NEWLINE> <NL> <DEDENT> ln = ln . strip ( ) <NEWLINE> print ( ln ) <NEWLINE> <NL> <DEDENT> def insertion_sort ( arr ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( arr ) ) : <NEWLINE> <INDENT> print_arr ( arr ) <NEWLINE> v = arr [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and arr [ j ] > v : <NEWLINE> <INDENT> arr [ j + 1 ] = arr [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> arr [ j + 1 ] = v <NEWLINE> <NL> <DEDENT> print_arr ( arr ) <NEWLINE> <NL> <DEDENT> input0 = sys . stdin . readline ( ) <NEWLINE> input_sample = sys . stdin . readline ( ) <NEWLINE> <COMMENT> <NL> input = input_sample . split ( <STRING> ) <NEWLINE> input = [ int ( i ) for i in input ] <NEWLINE> insertion_sort ( input ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> B . append ( j - A [ j ] ) <NEWLINE> <NL> <DEDENT> C = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( i + A [ i ] ) <NEWLINE> <NL> <DEDENT> d = defaultdict ( int ) <NEWLINE> <NL> for j in C : <NEWLINE> <INDENT> d [ j ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for k in B : <NEWLINE> <INDENT> count += d [ k ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
import string <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> min_cnt = float ( <STRING> ) <NEWLINE> <NL> for c in string . ascii_lowercase : <NEWLINE> <INDENT> if c not in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> s_ = s [ : ] <NEWLINE> while s_ : <NEWLINE> <INDENT> m = len ( s_ ) - 1 <NEWLINE> is_same = True <NEWLINE> for d in s_ : <NEWLINE> <INDENT> if d != c : <NEWLINE> <INDENT> is_same = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_same : <NEWLINE> <INDENT> min_cnt = min ( min_cnt , n - m - 1 ) <NEWLINE> <DEDENT> s_next = [ <STRING> ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if s_ [ i ] == c or s_ [ i + 1 ] == c : <NEWLINE> <INDENT> s_next [ i ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_next [ i ] = s_ [ i ] <NEWLINE> <DEDENT> <DEDENT> s_ = s_next <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_cnt ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> listP = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> listP . sort ( ) <NEWLINE> <NL> minD = 200 <NEWLINE> val = 0 <NEWLINE> bef = None <NEWLINE> for p in listP : <NEWLINE> <INDENT> if bef == None : <NEWLINE> <INDENT> bef = p <NEWLINE> minD = abs ( p - 1 - x ) <NEWLINE> val = p - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p - 1 == bef : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if bef < x < p : <NEWLINE> <INDENT> minD = 0 <NEWLINE> val = x <NEWLINE> <DEDENT> elif x <= bef : <NEWLINE> <INDENT> if abs ( bef + 1 - x ) < minD : <NEWLINE> <INDENT> minD = abs ( bef + 1 - x ) <NEWLINE> val = bef + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if abs ( p - 1 - x ) < minD : <NEWLINE> <INDENT> minD = abs ( p - 1 - x ) <NEWLINE> val = p - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> bef = p <NEWLINE> <DEDENT> <DEDENT> if not x in listP : <NEWLINE> <INDENT> val = x <NEWLINE> minD = 0 <NEWLINE> <DEDENT> elif val == 0 : <NEWLINE> <INDENT> if abs ( 0 - x ) > abs ( 101 - x ) : <NEWLINE> <INDENT> val = 101 <NEWLINE> minD = abs ( 101 - x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = 0 <NEWLINE> minD = abs ( 0 - x ) <NEWLINE> <DEDENT> <DEDENT> elif bef != None and abs ( bef + 1 - x ) < minD : <NEWLINE> <INDENT> val = bef + 1 <NEWLINE> <NL> <DEDENT> print ( val ) <NEWLINE>
get_num = int ( input ( ) ) <NEWLINE> get_list = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( get_num ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> get_list . append ( tmp ) <NEWLINE> <NL> <DEDENT> list = list ( set ( get_list ) ) <NEWLINE> <NL> print ( len ( list ) ) <NEWLINE>
from math import gcd <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> K = INT ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( n , m ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> if ( i - j < 0 or i + j >= N ) : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> l = S [ i - j ] <NEWLINE> m = S [ i ] <NEWLINE> r = S [ i + j ] <NEWLINE> <NL> if l != m and m != r and r != l : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> mod = 10 ** 18 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ans != - 1 : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> p_n = np . array ( p ) <NEWLINE> p_n = p_n . reshape ( - 1 ) <NEWLINE> pp = np . arange ( 0 , 102 ) <NEWLINE> for i in p_n : <NEWLINE> <INDENT> pp [ i ] += 10000 <NEWLINE> <DEDENT> sa = min ( abs ( pp - x ) ) <NEWLINE> if sa <= 101 : <NEWLINE> <INDENT> if pp [ x - sa ] >= 10000 : <NEWLINE> <INDENT> print ( x + sa ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - sa ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ set ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> d = [ 0 ] * n <NEWLINE> for i , j in p : <NEWLINE> <INDENT> d [ i - 1 ] = max ( d [ i - 1 ] , h [ j - 1 ] ) <NEWLINE> d [ j - 1 ] = max ( d [ j - 1 ] , h [ i - 1 ] ) <NEWLINE> <DEDENT> c = [ 0 for i in range ( n ) if d [ i ] < h [ i ] ] <NEWLINE> print ( len ( c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ss = input ( ) . split ( ) <NEWLINE> order , string = ss [ 0 ] , ss [ 1 ] <NEWLINE> if order == <STRING> : <NEWLINE> <INDENT> l [ string ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if string in l else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def soinsu_bunkai ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> <NL> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> pf [ m ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> def cmb ( n , r , p ) : <NEWLINE> <NL> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = mod <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = soinsu_bunkai ( M ) <NEWLINE> ans = 1 <NEWLINE> <NL> n = 10 ** 6 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> for i in a . values ( ) : <NEWLINE> <INDENT> x = cmb ( N + i - 1 , i , mod ) <NEWLINE> ans *= x <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if min ( a_ls ) != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a_ls [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 3 == 0 or <STRING> in str ( i + 1 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
def counting_sort ( A , k ) : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> B = [ 0 for i in range ( n ) ] <NEWLINE> C = [ 0 for i in range ( k + 1 ) ] <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ j ] ] - 1 ] = A [ j ] <NEWLINE> C [ A [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> return B <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> B = counting_sort ( A , 10000 ) <NEWLINE> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> string = list ( input ( ) ) <NEWLINE> if len ( string ) == 1 and string [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> times = int ( input ( ) ) <NEWLINE> tmp = string [ : times ] <NEWLINE> del string [ : times ] <NEWLINE> string += tmp <NEWLINE> <DEDENT> print ( <STRING> . join ( string ) ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> <NL> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ { } for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> to [ u ] [ v ] = ( a , b ) <NEWLINE> to [ v ] [ u ] = ( a , b ) <NEWLINE> <DEDENT> info = tuple ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> <NL> MAX_SILVER = 50 * ( N - 1 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> <COMMENT> <NL> visited = [ [ False ] * ( MAX_SILVER + 1 ) for _ in range ( N ) ] <NEWLINE> cost = [ [ INF ] * ( MAX_SILVER + 1 ) for _ in range ( N ) ] <NEWLINE> q = [ ] <NEWLINE> S = min ( S , MAX_SILVER ) <NEWLINE> heappush ( q , ( 0 , 0 , S ) ) <COMMENT> <NEWLINE> <NL> while q : <NEWLINE> <INDENT> t , now , s = heappop ( q ) <NEWLINE> if visited [ now ] [ s ] : continue <NEWLINE> visited [ now ] [ s ] = True <NEWLINE> cost [ now ] [ s ] = t <NEWLINE> <NL> <COMMENT> <NL> for nv , ( a , b ) in to [ now ] . items ( ) : <NEWLINE> <INDENT> nt = t + b <NEWLINE> rest = s - a <NEWLINE> if rest >= 0 : <NEWLINE> <INDENT> if cost [ nv ] [ rest ] <= nt : continue <NEWLINE> heappush ( q , ( nt , nv , rest ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> rate , time = info [ now ] <NEWLINE> nt = t + time <NEWLINE> ns = min ( s + rate , MAX_SILVER ) <NEWLINE> heappush ( q , ( nt , now , ns ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( cost [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ k ] != s [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <COMMENT> <NL> <INDENT> current_digit = 0 <NEWLINE> pin = <STRING> <NEWLINE> <COMMENT> <NL> k = pin [ current_digit ] <NEWLINE> <NL> for num in s : <NEWLINE> <COMMENT> <NL> <INDENT> if num == k : <NEWLINE> <INDENT> current_digit += 1 <NEWLINE> <COMMENT> <NL> if current_digit <= 2 : <NEWLINE> <INDENT> k = pin [ current_digit ] <NEWLINE> <NL> <DEDENT> elif current_digit == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> max_num = A [ - 1 ] + 1 <NEWLINE> count = [ 0 ] * max_num <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if count [ i ] != 0 : <NEWLINE> <INDENT> count [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i , max_num , i ) : <NEWLINE> <INDENT> count [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sum_num = sum ( count [ i ] == 1 for i in A ) <NEWLINE> print ( sum_num ) <NEWLINE>
def partsum ( n , k ) : <NEWLINE> <INDENT> ret1 = n * ( n + 1 ) / 2 <NEWLINE> ret2 = ( n - k + 1 ) * ( n - k ) / 2 <NEWLINE> return ret1 - ret2 <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ret = 0 <NEWLINE> for k in range ( K , N + 2 ) : <NEWLINE> <INDENT> ret += partsum ( N , k ) - partsum ( k - 1 , k ) + 1 <NEWLINE> <DEDENT> print ( int ( ret ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Room : <NEWLINE> <INDENT> def __init__ ( self , prev = - 1 , dist = 1 << 64 ) : <NEWLINE> <INDENT> self . prev = prev <NEWLINE> self . dist = dist <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> passages = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> passages [ a ] . add ( b ) <NEWLINE> passages [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> opening = { 0 } <NEWLINE> closing = { 0 } <NEWLINE> guide_points = [ - 1 ] * n <NEWLINE> while opening : <NEWLINE> <INDENT> next_opening = set ( ) <NEWLINE> <NL> for curr_room in opening : <NEWLINE> <INDENT> for next_room in passages [ curr_room ] : <NEWLINE> <INDENT> if next_room in closing : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> guide_points [ next_room ] = curr_room <NEWLINE> next_opening . add ( next_room ) <NEWLINE> closing . add ( next_room ) <NEWLINE> <NL> <DEDENT> <DEDENT> opening = next_opening <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( lambda x : str ( x + 1 ) , guide_points [ 1 : ] ) ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( ( <STRING> % ( math . pi * r ** 2 ) ) + <STRING> + ( <STRING> % ( 2 * math . pi * r ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> E = [ input ( ) . split ( ) [ 2 : ] for _ in range ( N ) ] <NEWLINE> Q = [ 0 ] <NEWLINE> L = [ 0 ] + [ - 1 ] * N <NEWLINE> frag = [ 1 ] + [ 0 ] * N <NEWLINE> def func ( ide ) : <NEWLINE> <INDENT> global Q <NEWLINE> for i in E [ ide ] : <NEWLINE> <INDENT> i = int ( i ) - 1 <NEWLINE> if frag [ i ] != 1 : frag [ i ] = 1 ; L [ i ] = L [ ide ] + 1 ; Q . append ( i ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> while Q : top = Q [ 0 ] ; func ( top ) ; del Q [ 0 ] <NEWLINE> <NL> for i in range ( N ) : print ( i + 1 , int ( L [ i ] ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b < 0 : <NEWLINE> <INDENT> S = ( b - a + 1 ) % 2 <NEWLINE> if S == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> student = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> cpoint = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mannmn = 10 ** 10 <NEWLINE> mann = 10 ** 10 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> mann = abs ( student [ i ] [ 0 ] - cpoint [ j ] [ 0 ] ) + abs ( student [ i ] [ 1 ] - cpoint [ j ] [ 1 ] ) <NEWLINE> if mann < mannmn : <NEWLINE> <INDENT> mannmn = mann <NEWLINE> ref = j <NEWLINE> <DEDENT> <DEDENT> print ( ref + 1 ) <NEWLINE> <DEDENT>
stdin = input ( ) <NEWLINE> hw = stdin . split ( <STRING> ) <NEWLINE> h = ( int ) ( hw [ 0 ] ) <NEWLINE> w = ( int ) ( hw [ 1 ] ) <NEWLINE> area = h * w <NEWLINE> perimeter = h * 2 + w * 2 <NEWLINE> <NL> print ( area , perimeter ) <NEWLINE>
a = input ( ) <NEWLINE> emp = 0 <NEWLINE> l = a . split ( <STRING> ) <NEWLINE> while ( <STRING> in l ) : <NEWLINE> <INDENT> l . remove ( <STRING> ) <NEWLINE> <DEDENT> if not l : <NEWLINE> <INDENT> print ( emp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( l [ 0 ] ) ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> answer = answer + ( n - i + 1 ) * i + 1 <NEWLINE> <NL> <DEDENT> print ( answer % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> P = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> P [ b ] . append ( a ) <NEWLINE> P [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> ans [ 1 ] = 1 <NEWLINE> next_numbers = [ 1 ] <NEWLINE> <NL> while next_numbers : <NEWLINE> <INDENT> check_number = next_numbers [ : ] <NEWLINE> next_numbers = [ ] <NEWLINE> for number in check_number : <NEWLINE> <INDENT> for x in P [ number ] : <NEWLINE> <INDENT> if ans [ x ] == 0 : <NEWLINE> <INDENT> ans [ x ] = number <NEWLINE> next_numbers . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 9 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj_list = [ [ ] for _ in range ( N ) ] <NEWLINE> counter = [ 0 for _ in range ( N ) ] <NEWLINE> reached = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj_list [ a ] . append ( b ) <NEWLINE> adj_list [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def df ( current , score ) : <NEWLINE> <INDENT> next_nodes = adj_list [ current ] <NEWLINE> reached [ current ] = 1 <NEWLINE> for node in next_nodes : <NEWLINE> <INDENT> if reached [ node ] == 0 : <NEWLINE> <INDENT> counter [ node ] += score <NEWLINE> df ( node , counter [ node ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <DEDENT> df ( 0 , counter [ 0 ] ) <NEWLINE> print ( * counter ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> def gdc ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> return gdc ( y , x % y ) <NEWLINE> <NL> <DEDENT> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> tmp = gdc ( b + 1 , a + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> total += gdc ( c + 1 , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ke = list ( Counter ( L ) . values ( ) ) <NEWLINE> val = list ( Counter ( L ) . keys ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( val ) ) : <NEWLINE> <INDENT> if val [ i ] > ke [ i ] : <NEWLINE> <INDENT> ans += ke [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ke [ i ] - val [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> H , W = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if V > W and abs ( A - B ) <= abs ( ( W - V ) * T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fflag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> fflag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if fflag == True : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * a [ i ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , prev , next ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . prev = prev <NEWLINE> self . next = next <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class LinkedList : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nil = Node ( None , None , None ) <NEWLINE> self . nil . prev = self . nil <NEWLINE> self . nil . next = self . nil <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def insert ( double_lst , key ) : <NEWLINE> <INDENT> node = Node ( key , double_lst . nil , double_lst . nil . next ) <NEWLINE> double_lst . nil . next . prev = node <NEWLINE> double_lst . nil . next = node <NEWLINE> <NL> <NL> <DEDENT> def search ( double_lst , key ) : <NEWLINE> <INDENT> cur = double_lst . nil . next <NEWLINE> <NL> while cur != double_lst . nil and cur . key != key : <NEWLINE> <INDENT> cur = cur . next <NEWLINE> <NL> <DEDENT> return cur <NEWLINE> <NL> <NL> <DEDENT> def delete_node ( double_lst , node ) : <NEWLINE> <INDENT> if node == double_lst . nil : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <NL> <DEDENT> def delete_first ( double_lst ) : <NEWLINE> <INDENT> delete_node ( double_lst , double_lst . nil . next ) <NEWLINE> <NL> <NL> <DEDENT> def delete_last ( double_lst ) : <NEWLINE> <INDENT> delete_node ( double_lst , double_lst . nil . prev ) <NEWLINE> <NL> <NL> <DEDENT> def delete_key ( double_lst , key ) : <NEWLINE> <INDENT> node = search ( double_lst , key ) <NEWLINE> delete_node ( double_lst , node ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ll = LinkedList ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> order = sys . stdin . readline ( ) . split ( ) <NEWLINE> <NL> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( ll , int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete_key ( ll , int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete_first ( ll ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> delete_last ( ll ) <NEWLINE> <NL> <DEDENT> <DEDENT> cur = ll . nil <NEWLINE> while cur . next != ll . nil : <NEWLINE> <INDENT> cur = cur . next <NEWLINE> if cur . next == ll . nil : <NEWLINE> <INDENT> print ( cur . key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cur . key , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
z = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> re = 0 <NEWLINE> b = 1 <NEWLINE> d = 1 <NEWLINE> while z > i : <NEWLINE> <INDENT> b = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = i * ( i + b ) <NEWLINE> if z > x : <NEWLINE> <INDENT> re += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if d * d < z : <NEWLINE> <INDENT> d += 1 <NEWLINE> re += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> l2 = [ x for x in range ( n ) ] <NEWLINE> base = list ( zip ( l2 , l ) ) <NEWLINE> ans = sorted ( base , key = lambda x : int ( x [ 1 ] [ 1 ] ) , reverse = True ) <NEWLINE> ans = sorted ( ans , key = lambda x : x [ 1 ] [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( 1 + ans [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> a_L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_L = list ( sorted ( a_L ) ) <NEWLINE> if a_L [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a_L [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == N - 2 : <NEWLINE> <INDENT> res = max ( res , cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = max ( res , cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> n , m , r = map ( int , input ( ) . split ( ) ) <NEWLINE> a = r - n * m <NEWLINE> def combination ( p , q ) : <NEWLINE> <INDENT> if q < 0 or p < q : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return math . factorial ( p ) // math . factorial ( q ) // math . factorial ( p - q ) <NEWLINE> <DEDENT> if a < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( combination ( a + n - 1 , a ) ) ) <NEWLINE> <DEDENT>
limit = 10 ** 18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> D = [ 0 ] * 1000000 <NEWLINE> E = [ 0 ] * 1000000 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] < 500000 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> D [ A [ i ] + i ] += 1 <NEWLINE> E [ - A [ i ] + i ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1000000 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += D [ i ] * E [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lst = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> if S not in lst . keys ( ) : <NEWLINE> <INDENT> lst [ S ] = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( lst ) ) <NEWLINE>
import sys <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = ni ( ) <NEWLINE> a = nl ( ) <NEWLINE> lis = [ ( e , i ) for i , e in enumerate ( a ) ] <NEWLINE> lis . sort ( ) <NEWLINE> dp = [ [ - 1 ] * n for _ in range ( n ) ] <NEWLINE> <NL> def solve ( l , r ) : <NEWLINE> <INDENT> if l > r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ l ] [ r ] >= 0 : <NEWLINE> <INDENT> return dp [ l ] [ r ] <NEWLINE> <DEDENT> idx = r - l <NEWLINE> e , i = lis [ idx ] <NEWLINE> dp [ l ] [ r ] = max ( abs ( i - l ) * e + solve ( l + 1 , r ) , abs ( r - i ) * e + solve ( l , r - 1 ) ) <NEWLINE> return dp [ l ] [ r ] <NEWLINE> <NL> <DEDENT> print ( solve ( 0 , n - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> dp = np . full ( n , INF , np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i , e in enumerate ( h [ 1 : ] , 1 ) : <NEWLINE> <INDENT> lb = max ( 0 , i - k ) <NEWLINE> dp [ i ] = np . min ( dp [ lb : i ] + np . abs ( h [ lb : i ] - e ) ) <NEWLINE> <NL> <DEDENT> ans = dp [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
[ n , m ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> chizu = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 1 ] = - 1 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> chizu [ ab [ i ] [ 0 ] ] . append ( ab [ i ] [ 1 ] ) <NEWLINE> chizu [ ab [ i ] [ 1 ] ] . append ( ab [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> kaisu = [ chizu [ 1 ] ] <NEWLINE> for i in chizu [ 1 ] : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> error = 0 <NEWLINE> j = - 1 <NEWLINE> counter = len ( chizu [ 1 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> j += 1 <NEWLINE> if len ( kaisu ) <= j : <NEWLINE> <INDENT> error = 0 <NEWLINE> break <NEWLINE> <DEDENT> for now in kaisu [ j ] : <COMMENT> <NEWLINE> <INDENT> kari = [ ] <NEWLINE> for i in chizu [ now ] : <COMMENT> <NEWLINE> <INDENT> if ans [ i ] == 0 : <COMMENT> <NEWLINE> <INDENT> ans [ i ] = now <NEWLINE> kari . append ( i ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT> <DEDENT> kaisu . append ( kari ) <NEWLINE> <DEDENT> if counter == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if error == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> elif error == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( h ) for h in input ( ) . split ( ) ] <NEWLINE> ans = [ 1 ] * N <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AH = H [ a - 1 ] <NEWLINE> BH = H [ b - 1 ] <NEWLINE> <COMMENT> <NL> if AH >= BH : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> if BH >= AH : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve2 ( x , y ) : <NEWLINE> <INDENT> if x == n : <NEWLINE> <INDENT> S [ y ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve2 ( x + 1 , y ) <NEWLINE> if y + A [ x ] < 2001 : <NEWLINE> <INDENT> solve2 ( x + 1 , y + A [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = [ 0 for i in range ( 2001 ) ] <NEWLINE> <NL> solve2 ( 0 , 0 ) <NEWLINE> <NL> def solve ( x , y ) : <NEWLINE> <INDENT> if y < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x == n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( x + 1 , y ) or solve ( x + 1 , y - A [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if ( i > 50 and ( S [ B [ i ] ] == 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( i > 50 and ( S [ B [ i ] ] == 0 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if solve ( 0 , B [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = factorization ( m ) <NEWLINE> b = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j * ( j + 1 ) // 2 <= i [ 1 ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> ans += j - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in An : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in An : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> b = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b -= a [ i ] <NEWLINE> ans += ( a [ i ] * b ) <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if ( i == 0 or i == a - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif ( j == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif ( j > 0 and j < b - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif ( j == b - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> if K <= int ( X / D ) : <NEWLINE> <INDENT> X -= D * K <NEWLINE> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= int ( X / D ) <NEWLINE> X -= D * int ( X / D ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> <DEDENT>
from copy import deepcopy <NEWLINE> <NL> N , M , X = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> CAS = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> <NL> ok = False <NEWLINE> mi = [ float ( <STRING> ) , * [ 0 ] * ( M ) ] <NEWLINE> <NL> fs = <STRING> + str ( N ) + <STRING> <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> s = fs . format ( i ) <NEWLINE> t = [ 0 ] * ( M + 1 ) <NEWLINE> for i , f in enumerate ( s ) : <NEWLINE> <INDENT> if f == <STRING> : <NEWLINE> <INDENT> t = [ a + b for a , b in zip ( CAS [ i ] , t ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if all ( a >= X for a in t [ 1 : ] ) and mi [ 0 ] > t [ 0 ] : <NEWLINE> <INDENT> mi = t <NEWLINE> ok = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( mi [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> comb = list ( itertools . combinations_with_replacement ( [ i for i in range ( 1 , k + 1 ) ] , 3 ) ) <NEWLINE> ans = 0 <NEWLINE> for a , b , c in comb : <NEWLINE> <INDENT> permutation = len ( set ( [ a , b , c ] ) ) <NEWLINE> r = b % a <NEWLINE> while r > 0 : <NEWLINE> <INDENT> b = a <NEWLINE> a = r <NEWLINE> r = b % a <NEWLINE> <NL> <DEDENT> r = c % a <NEWLINE> while r > 0 : <NEWLINE> <INDENT> c = a <NEWLINE> a = r <NEWLINE> r = c % a <NEWLINE> <NL> <DEDENT> if permutation == 3 : <NEWLINE> <INDENT> ans += 6 * a <NEWLINE> <DEDENT> elif permutation == 2 : <NEWLINE> <INDENT> ans += 3 * a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( C - B ) * cnt [ B ] <NEWLINE> print ( s ) <NEWLINE> cnt [ C ] += cnt [ B ] <NEWLINE> cnt [ B ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = <STRING> + input ( ) <NEWLINE> <NL> cnt_R , cnt_G , cnt_B = 0 , 0 , 0 <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> cnt_R += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cnt_G += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cnt_B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = cnt_R * cnt_G * cnt_B <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = S [ i ] ; b = S [ j ] ; c = S [ k ] <NEWLINE> if a != b and b != c and c != a : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> edges = ( map ( int , readline ( ) . strip ( ) . split ( ) ) for _ in range ( N - 1 ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> for u , v in edges : <NEWLINE> <INDENT> tree [ u - 1 ] . append ( v - 1 ) <NEWLINE> tree [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> inf = 10 ** 18 <NEWLINE> dp = [ inf ] * ( N + 1 ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> def dfs ( node , parent ) : <NEWLINE> <INDENT> v = As [ node ] <NEWLINE> lb = binary_search ( dp , v ) <NEWLINE> old = dp [ lb ] <NEWLINE> dp [ lb ] = v <NEWLINE> ans [ node ] = binary_search ( dp , inf ) <NEWLINE> for child in tree [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( child , node ) <NEWLINE> <DEDENT> dp [ lb ] = old <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def binary_search ( seq , v ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( seq ) - 1 <NEWLINE> center = right // 2 <NEWLINE> <NL> while left != right : <NEWLINE> <INDENT> if v <= seq [ center ] : <NEWLINE> <INDENT> right = center <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = center + 1 <NEWLINE> <DEDENT> center = ( right + left ) // 2 <NEWLINE> <NL> <DEDENT> return center <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> m = 10 ** 6 + 1 <NEWLINE> M = [ 0 ] * m <NEWLINE> g = 0 <NEWLINE> for i in map ( int , input ( ) . split ( ) ) : M [ i ] += 1 ; g = math . gcd ( g , i ) <NEWLINE> if g > 1 : print ( <STRING> ) <NEWLINE> elif all ( sum ( M [ i : : i ] ) <= 1 for i in range ( 2 , m ) ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_num = 0 <NEWLINE> j = 0 <NEWLINE> j_max = M <NEWLINE> A_sums = [ 0 ] <NEWLINE> B_sums = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_sums . append ( A_sums [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B_sums . append ( B_sums [ i ] + B [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> if A_sums [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A_sums [ i ] + B_sums [ j_max ] > K : <NEWLINE> <INDENT> j_max -= 1 <NEWLINE> <NL> <DEDENT> max_num = max ( max_num , i + j_max ) <NEWLINE> <DEDENT> print ( max_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> f = factorization ( n ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( f ) ) : <NEWLINE> <INDENT> m = 2 <COMMENT> <NEWLINE> while f [ i ] [ 1 ] > 0 : <NEWLINE> <INDENT> f [ i ] [ 1 ] -= m <NEWLINE> m += 1 <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
cross_section = input ( ) <NEWLINE> <NL> stack = [ ] <NEWLINE> areas_stack = [ ] <NEWLINE> area = 0 <NEWLINE> for i in range ( len ( cross_section ) ) : <NEWLINE> <INDENT> c = cross_section [ i ] <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> stack . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> and len ( stack ) != 0 : <NEWLINE> <INDENT> j = stack . pop ( ) <NEWLINE> a = i - j <NEWLINE> area += a <NEWLINE> while len ( areas_stack ) != 0 and areas_stack [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> a += areas_stack . pop ( ) [ 1 ] <NEWLINE> <DEDENT> areas_stack . append ( [ j , a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( area ) <NEWLINE> if area == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( areas_stack ) , <STRING> . join ( [ str ( x [ 1 ] ) for x in areas_stack ] ) ) <NEWLINE> <NL> <DEDENT>
import re <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> f = input ( ) . split ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> stack = [ ] <NEWLINE> for c in f : <NEWLINE> <INDENT> if re . match ( <STRING> , c ) is None : <NEWLINE> <INDENT> b , a = str ( stack . pop ( ) ) , str ( stack . pop ( ) ) <NEWLINE> stack . append ( float ( eval ( a + c + b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( stack [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> import math <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> A_cum = np . cumsum ( A ) <NEWLINE> counter = Counter ( A_cum ) <NEWLINE> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( r ) * math . factorial ( n - r ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key , value in counter . items ( ) : <NEWLINE> <INDENT> if value >= 2 : <NEWLINE> <INDENT> ans += cmb ( value , 2 ) <NEWLINE> <DEDENT> if key == 0 : <NEWLINE> <INDENT> ans += value <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> class UnionFindTree : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . cnt = [ ] <NEWLINE> self . par = [ ] <NEWLINE> <NL> <DEDENT> def add ( self , n ) : <NEWLINE> <INDENT> assert n == len ( self . par ) , <STRING> <NEWLINE> self . par . append ( n ) <NEWLINE> self . cnt . append ( 1 ) <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . root ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> cnt = self . cnt [ x ] + self . cnt [ y ] <NEWLINE> self . cnt [ x ] = cnt <NEWLINE> self . cnt [ y ] = cnt <NEWLINE> if x < y : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> return self . cnt [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFindTree ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> uf . add ( i ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> uf . unite ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if uf . same ( x , y ) else 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sq = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> pos = [ [ 0 , 0 , 0 ] ] <NEWLINE> g = True <NEWLINE> <NL> while pos != [ ] : <NEWLINE> <INDENT> y , x , depth = pos . pop ( 0 ) <NEWLINE> <NL> if y == H - 1 and x == W - 1 : <NEWLINE> <INDENT> g = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if x - 1 >= 0 : <NEWLINE> <INDENT> if sq [ y ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x - 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if x + 1 <= W - 1 : <NEWLINE> <INDENT> if sq [ y ] [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x + 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if y - 1 >= 0 : <NEWLINE> <INDENT> if sq [ y - 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y - 1 , x , depth + 1 ] ) <NEWLINE> sq [ y - 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if y + 1 <= H - 1 : <NEWLINE> <INDENT> if sq [ y + 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y + 1 , x , depth + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if g == True : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for k in range ( H ) : <NEWLINE> <INDENT> for m in range ( W ) : <NEWLINE> <INDENT> if sq [ k ] [ m ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( H * W - temp - depth - 1 ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <COMMENT> <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> s = [ 0 ] <NEWLINE> for i in range ( len ( alst ) ) : <NEWLINE> <INDENT> s . append ( s [ i ] + alst [ i ] ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> <NL> for i in range ( len ( alst ) - 1 ) : <NEWLINE> <INDENT> sum += alst [ i ] * ( s [ len ( s ) - 1 ] - s [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( sum % MOD ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = [ int ( inp ) for inp in input ( ) . split ( ) ] <NEWLINE> if t [ 0 ] <= m : <NEWLINE> <INDENT> ab [ t [ 0 ] ] . append ( - t [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> import heapq <NEWLINE> h = ab [ 1 ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if len ( h ) > 0 : <NEWLINE> <INDENT> ans += heapq . heappop ( h ) <NEWLINE> <DEDENT> if i != m : <NEWLINE> <INDENT> for t in ab [ i + 1 ] : <NEWLINE> <INDENT> heapq . heappush ( h , t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( a ) <NEWLINE> ta = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ta [ i ] = t <NEWLINE> t = t - a [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> ans = ans + ( a [ i ] * ta [ i + 1 ] ) <NEWLINE> ans = ( ans ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> x = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x * i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ [ ] for x in range ( n ) ] <NEWLINE> r = [ - 2 ] + [ - 1 ] * ( n - 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> p [ a ] . append ( b ) <NEWLINE> p [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> dq = deque ( ) <NEWLINE> dq . append ( 0 ) <NEWLINE> <NL> def bfs ( room ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> global r <NEWLINE> for iroom in p [ room ] : <NEWLINE> <INDENT> if r [ iroom ] == - 1 : <NEWLINE> <INDENT> r [ iroom ] = room <NEWLINE> l . append ( iroom ) <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> while len ( dq ) > 0 : <NEWLINE> <INDENT> c = dq . popleft ( ) <NEWLINE> ll = bfs ( c ) <NEWLINE> dq . extend ( ll ) <NEWLINE> <NL> <DEDENT> if - 1 in r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in r [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = N // j <NEWLINE> ans += Y * ( Y + 1 ) * j // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = np . array ( [ [ int ( a ) for a in input ( ) . split ( ) ] for j in range ( q ) ] ) <NEWLINE> <NL> u , c = np . unique ( a , return_counts = True ) <NEWLINE> dica = dict ( zip ( u , c ) ) <NEWLINE> <COMMENT> <NL> <NL> keys = dica . keys ( ) <NEWLINE> <NL> tmp = sum ( [ k * dica [ k ] for k in dica . keys ( ) ] ) <NEWLINE> <NL> <NL> for i in range ( q ) : <NEWLINE> <INDENT> t1 , t2 = bc [ i ] <NEWLINE> if not t1 in keys : <NEWLINE> <INDENT> dica [ t1 ] = 0 <NEWLINE> <DEDENT> if not t2 in keys : <NEWLINE> <INDENT> dica [ t2 ] = 0 <NEWLINE> <NL> <DEDENT> tmp += dica [ t1 ] * ( t2 - t1 ) <NEWLINE> print ( tmp ) <NEWLINE> <NL> dica [ t2 ] = dica [ t1 ] + dica [ t2 ] <NEWLINE> dica [ t1 ] = 0 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 7 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if s % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( s * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in t : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( 1 , n ) : <NEWLINE> <INDENT> if 1 <= a * b <= n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if reached [ i ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> reached [ i ] = 1 <NEWLINE> for dic in uv [ i ] : <NEWLINE> <INDENT> to = dic [ <STRING> ] <NEWLINE> w = dic [ <STRING> ] <NEWLINE> if w % 2 == 0 : <NEWLINE> <INDENT> color [ to ] = color [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color [ to ] = int ( not color [ i ] ) <NEWLINE> <DEDENT> dfs ( to ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> color = [ 0 ] * ( n + 1 ) <NEWLINE> reached = [ 0 ] * ( n + 1 ) <NEWLINE> uv = [ [ ] * ( n + 1 ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> uv [ u ] . append ( { <STRING> : v , <STRING> : w } ) <NEWLINE> uv [ v ] . append ( { <STRING> : u , <STRING> : w } ) <NEWLINE> <DEDENT> dfs ( 1 ) <NEWLINE> for i in color [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> sample_input = list ( range ( 3 ) ) <NEWLINE> sample_input [ 0 ] = <STRING> <NEWLINE> sample_input [ 1 ] = <STRING> <NEWLINE> sample_input [ 2 ] = <STRING> <NEWLINE> give_sample_input = None <NEWLINE> if give_sample_input is not None : <NEWLINE> <INDENT> sample_input_list = sample_input [ give_sample_input ] . split ( <STRING> ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sample_input_list . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def print_list ( l ) : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> for elem in l : <NEWLINE> <INDENT> output += str ( elem ) + <STRING> <NEWLINE> <DEDENT> output = output . rstrip ( ) <NEWLINE> print ( output ) <NEWLINE> <NL> <DEDENT> def determine_G ( n ) : <NEWLINE> <INDENT> G = [ ] <NEWLINE> pot = 1 <NEWLINE> while True : <NEWLINE> <INDENT> pot *= 2 <NEWLINE> if pot - 1 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( pot - 1 ) <NEWLINE> <DEDENT> G . reverse ( ) <NEWLINE> return G <NEWLINE> <NL> <DEDENT> def log_m_floor ( n ) : <NEWLINE> <INDENT> m = 2 <NEWLINE> pot = 1 <NEWLINE> power = 0 <NEWLINE> while ( pot < n ) : <NEWLINE> <INDENT> pot *= 2 <NEWLINE> power += 1 <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def insertion_sort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while ( j >= 0 and A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shell_sort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = determine_G ( n ) <NEWLINE> m = len ( G ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> print ( 1 ) <NEWLINE> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print_list ( G ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertion_sort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> num_of_data = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( num_of_data ) : <NEWLINE> <INDENT> data . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shell_sort ( data , num_of_data ) <NEWLINE> for d in data : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> uf . union ( AB [ i ] [ 0 ] - 1 , AB [ i ] [ 1 ] - 1 ) <NEWLINE> <DEDENT> ufr = uf . roots ( ) <NEWLINE> ans = 0 <NEWLINE> for i in ufr : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> max = int ( math . sqrt ( n ) + 1 ) <NEWLINE> L = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , max ) : <NEWLINE> <INDENT> for y in range ( 1 , max ) : <NEWLINE> <INDENT> for z in range ( 1 , max ) : <NEWLINE> <INDENT> tmp = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if tmp > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( L [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = input ( ) <NEWLINE> print ( <STRING> if str ( N ) . count ( <STRING> ) != 0 else <STRING> ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> print ( x * a // b ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import decimal <NEWLINE> import itertools <NEWLINE> from itertools import product <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * M <NEWLINE> c = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if M == 0 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 3 : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if s [ i ] == 1 and c [ i ] == 0 and N > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> z = zip ( s , c ) <NEWLINE> z = sorted ( z ) <NEWLINE> s , c = zip ( * z ) <NEWLINE> s = list ( s ) <NEWLINE> c = list ( c ) <NEWLINE> <NL> for i in range ( M - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> if c [ i ] != c [ i + 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> if i == 1 : <NEWLINE> <INDENT> c . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> z = zip ( s , c ) <NEWLINE> z = sorted ( z ) <NEWLINE> s , c = zip ( * z ) <NEWLINE> s = list ( s ) <NEWLINE> c = list ( c ) <NEWLINE> <NL> k = 1 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == k : <NEWLINE> <INDENT> ans += str ( c [ i ] ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hat_nperson = [ 0 , 0 , 1 ] <NEWLINE> ans = 3 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if a_ls [ 0 ] != 0 or ( n != 1 and a_ls [ 1 ] == 2 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> n_same = a_ls [ i ] <NEWLINE> n_choices = 0 <NEWLINE> choice_ind = - 1 <NEWLINE> for j , person in enumerate ( hat_nperson ) : <NEWLINE> <INDENT> if person == n_same : <NEWLINE> <INDENT> n_choices += 1 <NEWLINE> choice_ind = j <NEWLINE> <DEDENT> <DEDENT> if choice_ind == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> hat_nperson [ choice_ind ] += 1 <NEWLINE> ans *= n_choices <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in numlist : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in numlist : <NEWLINE> <INDENT> result = result * x <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> cur = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cur += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return cur <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ANS = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> tmp = ( x + y + z ) ** 2 - z * ( x + y ) - ( x * y ) <NEWLINE> if tmp > n : continue <NEWLINE> ANS [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ans in ANS [ 1 : ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> city = [ False for i in range ( N ) ] <NEWLINE> city [ 1 - 1 ] = True <NEWLINE> now = 1 <NEWLINE> <NL> counta1 = 0 <NEWLINE> while True : <NEWLINE> <INDENT> counta1 += 1 <NEWLINE> prev = now <NEWLINE> now = A [ now - 1 ] <NEWLINE> <COMMENT> <NL> if city [ now - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif counta1 == K : <NEWLINE> <INDENT> print ( now ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> city [ now - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> counta = 1 <NEWLINE> rout = [ ] <NEWLINE> rout . append ( now ) <NEWLINE> while now != prev : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> rout . append ( now ) <NEWLINE> counta += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = rout [ ( K - counta1 ) % counta ] <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s1 = list ( s ) <NEWLINE> t1 = list ( t ) <NEWLINE> <NL> s2 = len ( s1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( s2 ) : <NEWLINE> <INDENT> if ( s1 [ i ] != t1 [ i ] ) : <NEWLINE> <INDENT> s1 [ i ] == t1 [ i ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> X_bin = readline ( ) . strip ( ) <NEWLINE> n = X_bin . count ( <STRING> ) <NEWLINE> X = int ( X_bin , 2 ) <NEWLINE> <NL> X_pop_p = X % ( n + 1 ) <NEWLINE> if n != 1 : <NEWLINE> <INDENT> X_pop_m = X % ( n - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def count ( x ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while x : <NEWLINE> <INDENT> x %= bin ( x ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X_i = X ^ ( 1 << i ) <NEWLINE> if X_i == 0 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X_bin [ - ( i + 1 ) ] == <STRING> : <NEWLINE> <INDENT> mod = ( X_pop_m - pow ( 2 , i , n - 1 ) ) % ( n - 1 ) <NEWLINE> ans . append ( count ( mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( X_pop_p + pow ( 2 , i , n + 1 ) ) % ( n + 1 ) <NEWLINE> ans . append ( count ( mod ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans [ : : - 1 ] ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> P = 998244353 <NEWLINE> <NL> <NL> def main ( N , S , AS ) : <NEWLINE> <INDENT> DP = np . zeros ( ( S + 1 , N + 1 ) , dtype = np . int64 ) <NEWLINE> DP [ 0 , 0 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( S + 1 ) : <NEWLINE> <INDENT> v = DP [ j , i ] * 2 <NEWLINE> if AS [ i ] <= j : <NEWLINE> <INDENT> v += DP [ j - AS [ i ] , i ] <NEWLINE> <DEDENT> DP [ j , i + 1 ] = v % P <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( DP [ S , N ] ) <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> AS = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> from my_module import main <NEWLINE> main ( N , S , AS ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> c . append ( b [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if b [ i ] == N : <NEWLINE> <INDENT> d . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> e = set ( c ) & set ( d ) <NEWLINE> <NL> if len ( e ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> e , w = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w [ i ] += w [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> e [ i ] += e [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> ans = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , w [ i ] + e [ - 1 ] - e [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if B <= A : <NEWLINE> <INDENT> B *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if C <= B : <NEWLINE> <INDENT> C *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if A < B < C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> while True : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = e <NEWLINE> for z in range ( e ) : <NEWLINE> <INDENT> if ( z ** 3 > e ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> temp = e - z ** 3 <NEWLINE> y = int ( sqrt ( temp ) ) <NEWLINE> x = temp - y ** 2 <NEWLINE> m = min ( m , x + y + z ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> a += int ( n [ i ] ) <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ min ( int ( n ) % a , 1 ) ] ) <NEWLINE>
from bisect import bisect_left <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> xysame , upright , downright = { } , { } , { } <NEWLINE> u_list = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for u in u_list : <NEWLINE> <INDENT> xysame [ u ] = defaultdict ( list ) <NEWLINE> upright [ u ] = defaultdict ( list ) <NEWLINE> downright [ u ] = defaultdict ( list ) <NEWLINE> <NL> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> x , y , u = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> if u == <STRING> or u == <STRING> : <NEWLINE> <INDENT> xysame [ u ] [ x ] . append ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xysame [ u ] [ y ] . append ( x ) <NEWLINE> <DEDENT> upright [ u ] [ y - x ] . append ( x ) <NEWLINE> downright [ u ] [ y + x ] . append ( x ) <NEWLINE> <NL> <DEDENT> for u in u_list : <NEWLINE> <INDENT> for key in xysame [ u ] . keys ( ) : <NEWLINE> <INDENT> xysame [ u ] [ key ] . sort ( ) <NEWLINE> <DEDENT> for key in upright [ u ] . keys ( ) : <NEWLINE> <INDENT> upright [ u ] [ key ] . sort ( ) <NEWLINE> <DEDENT> for key in downright [ u ] . keys ( ) : <NEWLINE> <INDENT> downright [ u ] [ key ] . sort ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> INF = 10 ** 6 <NEWLINE> ans = INF <NEWLINE> <NL> <NL> def line ( low , high , type_ = 1 ) : <NEWLINE> <INDENT> ret = INF <NEWLINE> for k , v in low . items ( ) : <NEWLINE> <INDENT> if high [ k ] == [ ] : continue <NEWLINE> <NL> for vi in v : <NEWLINE> <INDENT> index = bisect_left ( high [ k ] , vi ) <NEWLINE> if index == len ( high [ k ] ) : continue <NEWLINE> ret = min ( ret , ( high [ k ] [ index ] - vi ) / type_ ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ans = min ( ans , line ( xysame [ <STRING> ] , xysame [ <STRING> ] , 2 ) ) <NEWLINE> ans = min ( ans , line ( xysame [ <STRING> ] , xysame [ <STRING> ] , 2 ) ) <NEWLINE> ans = min ( ans , line ( upright [ <STRING> ] , upright [ <STRING> ] , 1 ) ) <NEWLINE> ans = min ( ans , line ( upright [ <STRING> ] , upright [ <STRING> ] , 1 ) ) <NEWLINE> ans = min ( ans , line ( downright [ <STRING> ] , downright [ <STRING> ] , 1 ) ) <NEWLINE> ans = min ( ans , line ( downright [ <STRING> ] , downright [ <STRING> ] , 1 ) ) <NEWLINE> <NL> ans = int ( ans * 10 ) <NEWLINE> if ans == INF * 10 : ans = <STRING> <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = in_nn ( ) <NEWLINE> a = np . array ( read ( ) . split ( ) , np . int32 ) . reshape ( ( H , W ) ) <NEWLINE> <NL> odd_count = np . count_nonzero ( a % 2 == 1 ) <NEWLINE> if odd_count % 2 == 1 : <NEWLINE> <INDENT> odd_count -= 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> x , y = 0 , 0 <NEWLINE> px , py = - 1 , - 1 <NEWLINE> odd_f = False <NEWLINE> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if odd_f : <NEWLINE> <INDENT> ans . append ( ( py + 1 , px + 1 , y + 1 , x + 1 ) ) <NEWLINE> if a [ y ] [ x ] % 2 == 1 : <NEWLINE> <INDENT> odd_f = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ y ] [ x ] % 2 == 1 : <NEWLINE> <INDENT> odd_f = True <NEWLINE> <NL> <DEDENT> <DEDENT> px , py = x , y <NEWLINE> if a [ y ] [ x ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= odd_count : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if y % 2 == 0 : <NEWLINE> <INDENT> if x == W - 1 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if y >= H : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def isPrime ( num ) : <NEWLINE> <INDENT> if num < 2 : return False <NEWLINE> if num == 2 : return True <NEWLINE> if num % 2 == 0 : return False <NEWLINE> sqrtnum = num ** 0.5 <NEWLINE> for i in range ( 3 , int ( sqrtnum + 1 ) , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def prime_number ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if isPrime ( a ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> prime_number ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if a < b : <NEWLINE> <INDENT> if a + t * v >= b + t * w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a - t * v <= b - t * w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
b0 = input ( ) . split ( ) <NEWLINE> book = int ( b0 [ 0 ] ) <NEWLINE> pro = int ( b0 [ 1 ] ) <NEWLINE> norma = int ( b0 [ 2 ] ) <NEWLINE> <NL> bl = [ ] <NEWLINE> for x in range ( book ) : <NEWLINE> <INDENT> bl . append ( [ int ( y ) for y in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> mn = - 1 <NEWLINE> for x in range ( 2 ** book ) : <NEWLINE> <INDENT> if book > 9 : <NEWLINE> <INDENT> k = str ( book ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = <STRING> + str ( book ) + <STRING> <NEWLINE> <DEDENT> x2 = format ( x , k ) <NEWLINE> m = 0 <NEWLINE> exl = [ 0 for i in range ( pro ) ] <NEWLINE> for y in range ( book ) : <NEWLINE> <INDENT> if x2 [ y ] == <STRING> : <NEWLINE> <INDENT> m += bl [ y ] [ 0 ] <NEWLINE> for j in range ( pro ) : <NEWLINE> <INDENT> exl [ j ] += bl [ y ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( exl ) >= norma and ( mn == - 1 or mn > m ) : <NEWLINE> <INDENT> mn = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mn ) <NEWLINE>
<COMMENT> <NL> <NL> def f ( n , p , a ) : <NEWLINE> <INDENT> odd = sum ( i % 2 for i in a ) <NEWLINE> if odd == 0 : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> return 2 ** n <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 2 ** ( n - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( f ( n , p , a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> move = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == n - 2 : <NEWLINE> <INDENT> move . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> move . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( move ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , m , s = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = [ int ( i ) for i in readline ( ) . split ( ) ] <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> g [ u ] . append ( ( v , a , b ) ) <NEWLINE> g [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <NL> <DEDENT> cd = [ int ( i ) for i in read ( ) . split ( ) ] <NEWLINE> c = cd [ : : 2 ] <NEWLINE> d = cd [ 1 : : 2 ] <NEWLINE> <NL> <NL> from heapq import * <NEWLINE> INF = 1 << 61 <NEWLINE> M = 2500 <NEWLINE> if s >= M : s = M - 1 <NEWLINE> dist = [ [ INF ] * M for _ in range ( n ) ] <COMMENT> <NEWLINE> dist [ 0 ] [ s ] = 0 <NEWLINE> q = [ ( 0 , s , 0 ) ] <COMMENT> <NEWLINE> <NL> while q : <NEWLINE> <INDENT> dv , num , v = heappop ( q ) <NEWLINE> if dist [ v ] [ num ] < dv : continue <NEWLINE> if num + c [ v ] < M and dv + d [ v ] < dist [ v ] [ num + c [ v ] ] : <NEWLINE> <INDENT> dist [ v ] [ num + c [ v ] ] = dv + d [ v ] <NEWLINE> heappush ( q , ( dv + d [ v ] , num + c [ v ] , v ) ) <NEWLINE> <DEDENT> for to , a , b in g [ v ] : <NEWLINE> <INDENT> if num >= a and dv + b < dist [ to ] [ num - a ] : <NEWLINE> <INDENT> dist [ to ] [ num - a ] = dv + b <NEWLINE> heappush ( q , ( dv + b , num - a , to ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( min ( dist [ i ] ) ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> w = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> c ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ 2 ] == <STRING> : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> w . append ( a [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( a [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> S . append ( a [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w . append ( a [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> S = w [ : : - 1 ] + S <NEWLINE> print ( <STRING> . join ( S ) if c == 0 else <STRING> . join ( S [ : : - 1 ] ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in v : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for item in v : <NEWLINE> <INDENT> ans = ans * item <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> gcd = math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> if i == j and j == k : <NEWLINE> <INDENT> s += gcd <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> s += gcd * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += gcd * 6 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <NL> def PrintI ( i ) : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def mod ( x ) : <NEWLINE> <INDENT> return int ( x % ( 1e+9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> def combination_dp ( s ) : <NEWLINE> <INDENT> if s < 3 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> dp = [ ] <NEWLINE> dp . append ( 1 ) <NEWLINE> for i in range ( 1 , s + 1 ) : <NEWLINE> <INDENT> if i < 3 : <NEWLINE> <INDENT> dp . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = 0 <NEWLINE> end = i - 3 + 1 <NEWLINE> dp . append ( mod ( sum ( dp [ start : end ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> print ( combination_dp ( S ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> prod = 1 <NEWLINE> max1 = 10 ** 18 <NEWLINE> for i in arr : <NEWLINE> <INDENT> prod *= i <NEWLINE> if ( prod == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ( prod > max1 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return prod <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = set ( ) <NEWLINE> x = 7 <NEWLINE> ans = 1 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x < K : <NEWLINE> <INDENT> x = x * 10 + 7 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> x = x % K <NEWLINE> if x in m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . add ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> ans = N // ( A + B ) * A + min ( A , ( N % ( A + B ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs = [ ] <NEWLINE> hs = [ 0 ] * ( H ) <NEWLINE> ws = [ 0 ] * ( W ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs . append ( tuple ( [ h - 1 , w - 1 ] ) ) <NEWLINE> hs [ h - 1 ] += 1 <NEWLINE> ws [ w - 1 ] += 1 <NEWLINE> <DEDENT> maxh = max ( hs ) <NEWLINE> maxw = max ( ws ) <NEWLINE> ans = maxh + maxw <NEWLINE> <NL> maxhindex = [ i for i , x in enumerate ( hs ) if x == maxh ] <NEWLINE> maxwindex = [ i for i , x in enumerate ( ws ) if x == maxw ] <NEWLINE> <NL> isfound = False <NEWLINE> <NL> bombs = set ( bombs ) <NEWLINE> for i in maxhindex : <NEWLINE> <INDENT> for j in maxwindex : <NEWLINE> <INDENT> if ( i , j ) not in bombs : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def d_friends ( ) : <NEWLINE> <INDENT> class UnionFind ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . num_element = n <NEWLINE> self . parents = [ - 1 ] * n <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> u , v = self . find ( x ) , self . find ( y ) <NEWLINE> <NL> if u == v : <NEWLINE> <INDENT> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if self . parents [ u ] > self . parents [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <NL> <DEDENT> self . parents [ u ] += self . parents [ v ] <COMMENT> <NEWLINE> self . parents [ v ] = u <COMMENT> <NEWLINE> <NL> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> return max ( [ uf . get_size ( r ) for r in range ( N ) ] ) <NEWLINE> <NL> <DEDENT> print ( d_friends ( ) ) <NEWLINE>
<COMMENT> <NL> from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = int ( a [ 0 ] * a [ 1 ] ) <NEWLINE> S = int ( 2 * ( a [ 0 ] + a [ 1 ] ) ) <NEWLINE> print ( str ( A ) + <STRING> + str ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt *= a [ i ] <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mul = 1 <NEWLINE> f = 0 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> mul *= i <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> G = [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G = [ g for g in [ 1 , 4 , 10 , 23 , 57 , 132 , 301 , 701 ] if g < n ] <NEWLINE> while True : <NEWLINE> <INDENT> g = int ( 2.25 * G [ - 1 ] ) <NEWLINE> if g > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( g ) <NEWLINE> <DEDENT> G . reverse ( ) <NEWLINE> <NL> <DEDENT> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for g in G : <NEWLINE> <INDENT> for j , v in enumerate ( A [ g : ] ) : <NEWLINE> <INDENT> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> alphabet = { i - 96 : chr ( i ) for i in range ( 97 , 97 + 26 ) } <NEWLINE> if int ( N ) > 26 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x = N // 26 <NEWLINE> mod = N % 26 <NEWLINE> <COMMENT> <NL> if mod == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <COMMENT> <NL> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans += alphabet [ mod ] <NEWLINE> <DEDENT> N = x <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = alphabet [ int ( N ) ] <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> Z = 0 <NEWLINE> C = { } <NEWLINE> m = 1000000007 <NEWLINE> <NL> def mypow ( dummy , num ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> ans = ( ans * 2 ) % 1000000007 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def rNum ( a , b ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> if a < 0 and b < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> if a > 0 and b < 0 : <NEWLINE> <INDENT> return ( - 1 * ( a // g ) , - 1 * ( b // g ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( a // g , b // g ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> Z += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> B += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> r = rNum ( a , b ) <NEWLINE> if r in C . keys ( ) : <NEWLINE> <INDENT> C [ r ] += 1 <NEWLINE> <DEDENT> else : C [ r ] = 1 <NEWLINE> <NL> <NL> <DEDENT> used = set ( ) <NEWLINE> ans = 1 <NEWLINE> ans *= ( mypow ( 2 , A ) + mypow ( 2 , B ) - 1 ) % m <NEWLINE> <NL> <NL> for c in C . keys ( ) : <NEWLINE> <INDENT> if c in used : continue <NEWLINE> a , b = c <NEWLINE> r = rNum ( b , - 1 * a ) <NEWLINE> if r in C . keys ( ) : <NEWLINE> <INDENT> if c == r : continue <NEWLINE> used . add ( r ) <NEWLINE> score = ( mypow ( 2 , C [ c ] ) + mypow ( 2 , C [ r ] ) - 1 ) <NEWLINE> ans *= score <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans *= mypow ( 2 , C [ c ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans += Z <NEWLINE> <NL> print ( ( ans - 1 ) % m ) <NEWLINE> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = a [ 0 ] <NEWLINE> y = sum ( a [ 1 : ] ) <NEWLINE> ans = abs ( x - y ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> x += a [ i ] <NEWLINE> y -= a [ i ] <NEWLINE> ans = min ( abs ( x - y ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> straight = min ( k , x // d ) <NEWLINE> k -= straight <NEWLINE> x -= straight * d <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - x ) <NEWLINE> <DEDENT>
MODINT = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prodsum = [ 0 ] * n <NEWLINE> prodsum [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> prodsum [ i ] = prodsum [ i - 1 ] + A [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( prodsum [ - 1 ] - prodsum [ i ] ) <NEWLINE> <DEDENT> print ( ans % MODINT ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 100 <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if not i in P : <NEWLINE> <INDENT> if t > abs ( i - x ) : <NEWLINE> <INDENT> t = abs ( i - x ) <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
resident = [ [ [ 0 ] * 10 for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> resident [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , resident [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <NL> <NL>
count = int ( input ( ) ) <NEWLINE> <NL> strlist = set ( ) <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> strlist . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( strlist ) ) <NEWLINE>
data = input ( ) <NEWLINE> a , b , c = [ int ( i ) for i in data . split ( ) ] <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def insertionSort ( a , n , g ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> global cnt <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellsort ( a , n ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = [ i for i in [ 262913 , 65921 , 16577 , 4193 , 1073 , 281 , 77 , 23 , 8 , 1 ] if i <= n ] <NEWLINE> m = len ( g ) <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( a , n , g [ i ] ) <NEWLINE> <DEDENT> return a , m , g <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> a , m , g = shellsort ( a , n ) <NEWLINE> <NL> print ( m ) <NEWLINE> print ( * g ) <NEWLINE> print ( cnt ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 1 <NEWLINE> flag = True <NEWLINE> for i in a : <NEWLINE> <INDENT> k *= i <NEWLINE> if k > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = np . array ( [ np . inf ] * n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i - k > 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - k : i ] + abs ( h [ i ] - h [ i - k : i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ 0 : i ] + abs ( h [ i ] - h [ 0 : i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( dp [ n - 1 ] ) ) <NEWLINE>
inputs = list ( input ( ) ) <NEWLINE> stack = [ ] <NEWLINE> L = [ ] <NEWLINE> tmp_total = 0 <NEWLINE> counter = 0 <NEWLINE> upper = 0 <NEWLINE> for i , x in enumerate ( inputs ) : <NEWLINE> <INDENT> if ( x == <STRING> ) : <NEWLINE> <INDENT> stack . append ( i ) <NEWLINE> <DEDENT> elif ( x == <STRING> ) and stack : <NEWLINE> <INDENT> tmp = stack . pop ( ) <NEWLINE> total_layer = i - tmp <NEWLINE> if L : <NEWLINE> <INDENT> while L and L [ - 1 ] [ 0 ] > tmp : <NEWLINE> <INDENT> cal = L . pop ( ) <NEWLINE> total_layer += cal [ 1 ] <NEWLINE> <DEDENT> <DEDENT> L . append ( ( i , total_layer ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ j [ 1 ] for j in L ] ) ) <NEWLINE> if ( len ( L ) != 0 ) : <NEWLINE> <INDENT> print ( str ( len ( L ) ) + <STRING> + <STRING> . join ( [ str ( i [ 1 ] ) for i in L ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( len ( L ) ) ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , x in enumerate ( A , 1 ) : <NEWLINE> <INDENT> ans += D [ i - x ] <NEWLINE> D [ x + i ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> if a [ i ] >= a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( a , n // a + 1 ) : <NEWLINE> <INDENT> c = n - ( a * b ) <NEWLINE> if c > 0 : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xdic = { } <NEWLINE> ydic = { } <NEWLINE> <NL> for i , a in enumerate ( alist ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> tmpx = ( i + 1 ) + a <NEWLINE> tmpy = ( i + 1 ) - a <NEWLINE> if tmpx in xdic : <NEWLINE> <INDENT> xdic [ tmpx ] = xdic [ tmpx ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xdic [ tmpx ] = 1 <NEWLINE> <DEDENT> if tmpy > 0 : <NEWLINE> <INDENT> if tmpy in ydic : <NEWLINE> <INDENT> ydic [ tmpy ] = ydic [ tmpy ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ydic [ tmpy ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> output = 0 <NEWLINE> for y in ydic : <NEWLINE> <INDENT> if y in xdic : <NEWLINE> <INDENT> output += xdic [ y ] * ydic [ y ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from bisect import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> B = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> C = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> lst = [ N - bisect ( C , b ) for b in B ] <NEWLINE> lst = lst [ : : - 1 ] <NEWLINE> tmp_lst = [ lst [ 0 ] ] <NEWLINE> for i in lst [ 1 : ] : <NEWLINE> <INDENT> tmp_lst . append ( i + tmp_lst [ - 1 ] ) <NEWLINE> <DEDENT> tmp_lst = tmp_lst [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res = bisect ( B , a ) <NEWLINE> ans += tmp_lst [ res ] if res < N else 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def counting_sort ( A , k ) : <NEWLINE> <INDENT> C = [ 0 for i in range ( k ) ] <NEWLINE> <COMMENT> <NL> for l in A : <NEWLINE> <INDENT> C [ l ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> B = [ None for i in range ( len ( A ) ) ] <NEWLINE> for l in A [ : : - 1 ] : <NEWLINE> <INDENT> B [ C [ l ] - 1 ] = l <NEWLINE> C [ l ] -= 1 <NEWLINE> <NL> <DEDENT> return B <NEWLINE> <NL> <DEDENT> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = counting_sort ( a , 10000 ) <NEWLINE> print ( * b ) <NEWLINE>
from math import * <NEWLINE> K = int ( input ( ) ) <NEWLINE> N = 0 <NEWLINE> k = K * K <NEWLINE> d1 = [ 0 ] * int ( k ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for b in range ( K ) : <NEWLINE> <INDENT> for c in range ( K ) : <NEWLINE> <INDENT> d1 [ i ] = gcd ( ( c + 1 ) , ( b + 1 ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> for a in range ( K ) : <NEWLINE> <INDENT> for x in d1 : <NEWLINE> <INDENT> N += gcd ( x , ( a + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> y = N // i <NEWLINE> ans += ( ( y * ( y + 1 ) ) // 2 ) * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> line1 = input ( ) <NEWLINE> line2 = input ( ) <NEWLINE> line3 = input ( ) <NEWLINE> n , m , k = list ( map ( int , line1 . split ( ) ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , line2 . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , line3 . split ( ) ) ) <NEWLINE> mark1 , mark2 = 0 , 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> if a [ i ] > k : <NEWLINE> <INDENT> mark1 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( b ) ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> if b [ i ] > k : <NEWLINE> <INDENT> mark2 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if mark1 : <NEWLINE> <INDENT> a = a [ : mark1 ] <NEWLINE> <DEDENT> if mark2 : <NEWLINE> <INDENT> b = b [ : mark2 ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> target = k - a [ i ] <NEWLINE> tmp = 0 <NEWLINE> low , high = 0 , len ( b ) <NEWLINE> while low < high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if b [ mid ] <= target : <NEWLINE> <INDENT> tmp = mid <NEWLINE> low = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , i + tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> a = list ( itertools . accumulate ( a ) ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> ans = - 100000 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , a [ k ] - a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> nocount = 0 <NEWLINE> Rcount = 0 <NEWLINE> Gcount = 0 <NEWLINE> Bcount = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if S [ k ] == <STRING> : <NEWLINE> <INDENT> Rcount += 1 <NEWLINE> <DEDENT> if S [ k ] == <STRING> : <NEWLINE> <INDENT> Gcount += 1 <NEWLINE> <DEDENT> <DEDENT> Bcount = N - Rcount - Gcount <NEWLINE> count = Rcount * Gcount * Bcount <NEWLINE> for k in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , k - 1 , 2 ) : <NEWLINE> <INDENT> if S [ i - 1 ] != S [ k - 1 ] : <NEWLINE> <INDENT> j = ( i + k ) // 2 <NEWLINE> if S [ i - 1 ] != S [ j - 1 ] and S [ k - 1 ] != S [ j - 1 ] : <NEWLINE> <INDENT> nocount += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if k % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 2 , k - 1 , 2 ) : <NEWLINE> <INDENT> if S [ i - 1 ] != S [ k - 1 ] : <NEWLINE> <INDENT> j = ( i + k ) // 2 <NEWLINE> if S [ i - 1 ] != S [ j - 1 ] and S [ k - 1 ] != S [ j - 1 ] : <NEWLINE> <INDENT> nocount += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count - nocount ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> raw = sum ( A ) <NEWLINE> con = 0 <NEWLINE> <NL> if len ( A ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> if A [ con ] > A [ con + 1 ] : <NEWLINE> <INDENT> A [ con + 1 ] = A [ con ] <NEWLINE> <NL> <DEDENT> if A [ con + 1 ] == A [ - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> con += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( A ) - raw <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> biki = [ ] <NEWLINE> bise = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> biki . append ( S ) <NEWLINE> <DEDENT> bise = set ( biki ) <NEWLINE> print ( len ( bise ) ) <NEWLINE>
ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> k = str ( input ( ) ) <NEWLINE> r = k . count ( <STRING> ) <NEWLINE> b = k . count ( <STRING> ) <NEWLINE> g = k . count ( <STRING> ) <NEWLINE> ans += r * b * g <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> ii = k [ i ] <NEWLINE> for j in range ( i + 1 , ( n - i ) // 2 + 1 + i ) : <NEWLINE> <INDENT> jj = k [ j ] <NEWLINE> l = j + ( j - i ) <NEWLINE> <COMMENT> <NL> if jj != ii and l < n : <NEWLINE> <COMMENT> <NL> <INDENT> ll = k [ l ] <NEWLINE> if ii != ll and jj != ll : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> <COMMENT> <NL> pq = [ ] <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> op = line . strip ( ) . split ( <STRING> ) <NEWLINE> if op [ 0 ] == <STRING> : <NEWLINE> <INDENT> heappush ( pq , - int ( op [ 1 ] ) ) <NEWLINE> <DEDENT> elif op [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( - heappop ( pq ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( la ) <NEWLINE> d = dict ( Counter ( la ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> nb = d . pop ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nb = 0 <NEWLINE> <DEDENT> delta = ( c - b ) * nb <NEWLINE> s += delta <NEWLINE> print ( s ) <NEWLINE> if nb > 0 : <NEWLINE> <INDENT> if c in d : <NEWLINE> <INDENT> d [ c ] += nb <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = nb <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sum = sum ( A ) <NEWLINE> B_sum = 0 <NEWLINE> n , m = N , 0 <NEWLINE> ans = 0 <NEWLINE> while m != M : <NEWLINE> <INDENT> if A_sum + B_sum <= K : <NEWLINE> <INDENT> ans = max ( ans , n + m ) <NEWLINE> m += 1 <NEWLINE> B_sum += B [ m ] <NEWLINE> <DEDENT> elif A_sum + B_sum > K and n >= 0 : <NEWLINE> <INDENT> A_sum -= A [ n ] <NEWLINE> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if A_sum + B_sum <= K : <NEWLINE> <INDENT> ans = max ( ans , n + m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> flag_0 = False <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a_i in a : <NEWLINE> <INDENT> ans *= a_i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> temp_list = [ ] <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp_list . append ( math . gcd ( k , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for item in temp_list : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res += math . gcd ( item , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if i > n or ans == s : break <NEWLINE> if s [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> ans += <STRING> <NEWLINE> if s [ i : i + 1 ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif s [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> ans += <STRING> <NEWLINE> if s [ i : i + 3 ] == <STRING> : continue <NEWLINE> elif s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if ans == s else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * 10 ** 6 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < ( 2 * ( 10 ** 5 ) ) : <NEWLINE> <INDENT> if i - a [ i ] >= 0 : <NEWLINE> <INDENT> ans += b [ i - a [ i ] ] <NEWLINE> <DEDENT> b [ a [ i ] + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class BinaryIndexedTree : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . dat = [ 0 ] * ( size + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= self . size : <NEWLINE> <INDENT> self . dat [ i ] += x <NEWLINE> i += i & - i <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , r ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> ret = 0 <NEWLINE> while r > 0 : <NEWLINE> <INDENT> ret += self . dat [ r ] <NEWLINE> r -= r & - r <COMMENT> <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def init ( self , a ) : <NEWLINE> <INDENT> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> self . add ( i , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def initrng ( self , a ) : <NEWLINE> <INDENT> self . add ( 0 , a [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> self . add ( i , a [ i ] - a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bit = BinaryIndexedTree ( n ) <NEWLINE> bit . init ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> bit . add ( u , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bit . sum ( v - 1 ) - bit . sum ( u - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
mul , f = 1 , 0 <NEWLINE> input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if l . __contains__ ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> mul = mul * i <NEWLINE> if mul > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) ; break ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = al [ i ] - 1 <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> import os <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M = il ( ) <NEWLINE> AB = { m + 1 : [ ] for m in range ( M + 1 ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = il ( ) <NEWLINE> AB [ a ] . append ( b ) <NEWLINE> AB [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ret = [ ] <NEWLINE> visit = [ 0 ] * ( N + 1 ) <NEWLINE> fifoqu = queue . Queue ( ) <NEWLINE> fifoqu . put ( 1 ) <NEWLINE> <NL> while not fifoqu . empty ( ) : <NEWLINE> <INDENT> now = fifoqu . get ( ) <NEWLINE> next = AB [ now ] <NEWLINE> for n in next : <NEWLINE> <INDENT> if visit [ n ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visit [ n ] = visit [ now ] + 1 <NEWLINE> fifoqu . put ( n ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if visit [ 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visit [ 1 ] = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> for n in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> deep = visit [ n ] <NEWLINE> rooms = AB [ n ] <NEWLINE> for room in rooms : <NEWLINE> <INDENT> if visit [ room ] == deep - 1 : <NEWLINE> <INDENT> print ( room ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> left = [ A [ i ] + i for i in range ( N ) ] <NEWLINE> right = collections . Counter ( [ - A [ j ] + j for j in range ( N ) ] ) <NEWLINE> result = 0 <NEWLINE> for l in left : <NEWLINE> <INDENT> result += right [ l ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> from functools import reduce <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , m ) : <NEWLINE> <INDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return a * b % m <NEWLINE> <NL> <DEDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return ( over * pow ( under , m - 2 , m ) ) % m <NEWLINE> <NL> <NL> <DEDENT> r = abs ( x - y ) <NEWLINE> l = ( min ( x , y ) - r ) // 3 <NEWLINE> r += l <NEWLINE> if l * 2 + r * 1 in ( x , y ) and l >= 0 : <NEWLINE> <INDENT> print ( cmb ( r + l , l , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> price = [ 0 ] * m <NEWLINE> typesnum = [ 0 ] * m <NEWLINE> keybit = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> price [ i ] , typesnum [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> keybit [ i ] = sum ( map ( lambda x : 2 ** ( int ( x ) - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> dp = [ 10 ** 9 ] * ( 1 << n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> dp [ bit | keybit [ i ] ] = min ( dp [ bit | keybit [ i ] ] , dp [ bit ] + price [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] == 10 ** 9 : <NEWLINE> <INDENT> dp [ - 1 ] = - 1 <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10010010 ) <NEWLINE> <NL> def abc146_d ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Q = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> deg = [ 0 ] * n <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> color = dict ( ) <NEWLINE> <NL> for a , b in Q : <NEWLINE> <INDENT> deg [ a ] += 1 <NEWLINE> deg [ b ] += 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( s , p ) : <NEWLINE> <INDENT> nouse = - 1 <NEWLINE> if p > - 1 : nouse = color [ ( min ( s , p ) , max ( s , p ) ) ] <NEWLINE> c = 1 <NEWLINE> for t in adj [ s ] : <NEWLINE> <INDENT> if t == p : continue <NEWLINE> if c == nouse : c += 1 <NEWLINE> color [ ( min ( s , t ) , max ( s , t ) ) ] = c <NEWLINE> dfs ( t , s ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , - 1 ) <NEWLINE> <NL> print ( max ( deg ) ) <NEWLINE> for a , b in Q : <NEWLINE> <INDENT> print ( color [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc146_d ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> x = int ( a ) <NEWLINE> y = int ( b ) <NEWLINE> z = int ( c ) <NEWLINE> p = [ x , y , z ] <NEWLINE> p . sort ( ) <NEWLINE> if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> left_W = 0 <NEWLINE> right_R = c . count ( <STRING> ) <NEWLINE> <NL> if c . count ( <STRING> ) == 0 or c . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if c [ n ] == <STRING> : <NEWLINE> <INDENT> right_R -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_W += 1 <NEWLINE> <NL> <NL> <DEDENT> if left_W == right_R : <NEWLINE> <INDENT> ans = right_R <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<NL> import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = collections . defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> D [ a ] += 1 <NEWLINE> <NL> <DEDENT> m = max ( A ) <NEWLINE> S = set ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> <NL> if a in S : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if D [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> num = a <NEWLINE> while num <= m : <NEWLINE> <INDENT> S . add ( num ) <NEWLINE> num += a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , q = rm ( ) <NEWLINE> s = rr ( ) <NEWLINE> cnt_li = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt_li [ i + 1 ] += 1 <NEWLINE> <DEDENT> cnt_li [ i + 1 ] += cnt_li [ i ] <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = rm ( ) <NEWLINE> print ( cnt_li [ r - 1 ] - cnt_li [ l - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> if n != 1 : <NEWLINE> <INDENT> a [ 1 ] = 1 <NEWLINE> <DEDENT> d = [ - 1 ] * ( n + 1 ) <NEWLINE> flg = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = sc [ i ] [ 0 ] <NEWLINE> c = sc [ i ] [ 1 ] <NEWLINE> if d [ s ] == - 1 or a [ s ] == c : <NEWLINE> <INDENT> a [ s ] = c <NEWLINE> d [ s ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> <DEDENT> ans = int ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> if ans >= 10 ** ( n - 1 ) and flg : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif n == 1 and ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> prime = [ 1 ] * 1000010 <NEWLINE> <NL> for i in set ( a ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( i + i , 1000001 , i ) : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> c = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if prime [ i ] and c [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = str ( int ( input ( ) ) ) <NEWLINE> total = 0 <NEWLINE> l = len ( N ) - 1 <NEWLINE> if l == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 ** l ) : <NEWLINE> <INDENT> b = format ( i , <STRING> + str ( l ) + <STRING> ) <NEWLINE> subtotal = 0 <NEWLINE> s = N [ 0 ] <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if int ( b [ j ] ) : <NEWLINE> <INDENT> subtotal += int ( s ) <NEWLINE> s = N [ j + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += N [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> subtotal += int ( s ) <NEWLINE> total += subtotal <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> res . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( len ( set ( res ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = str ( input ( ) ) <NEWLINE> num_one = X . count ( <STRING> ) <NEWLINE> <NL> dp = [ - 1 ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> if dp [ n ] == - 1 : <NEWLINE> <INDENT> dp [ n ] = 1 + dfs ( n % bin ( n ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> return dp [ n ] <NEWLINE> <NL> <DEDENT> num_one = X . count ( <STRING> ) <NEWLINE> bool_arr = np . array ( [ True if X [ N - i - 1 ] == <STRING> else False for i in range ( N ) ] ) <NEWLINE> zero_ver = np . array ( [ pow ( 2 , i , num_one + 1 ) for i in range ( N ) ] ) <NEWLINE> zero_ver_sum = sum ( zero_ver [ bool_arr ] ) <NEWLINE> <NL> one_ver = - 1 <NEWLINE> one_ver_sum = 0 <NEWLINE> flag = False <NEWLINE> if num_one != 1 : <NEWLINE> <INDENT> one_ver = np . array ( [ pow ( 2 , i , num_one - 1 ) for i in range ( N ) ] ) <NEWLINE> one_ver_sum = sum ( one_ver [ bool_arr ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> start = 0 <NEWLINE> if bool_arr [ N - i ] == False : <NEWLINE> <INDENT> start = ( zero_ver_sum + pow ( 2 , N - i , num_one + 1 ) ) % ( num_one + 1 ) <NEWLINE> print ( dfs ( start ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = ( one_ver_sum - pow ( 2 , N - i , num_one - 1 ) ) % ( num_one - 1 ) <NEWLINE> print ( dfs ( start ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> queue = deque ( ) <NEWLINE> seen = [ - 1 ] * N <NEWLINE> steps = [ - 1 ] * N <NEWLINE> steps [ 0 ] = 0 <NEWLINE> parents = [ - 1 ] * N <NEWLINE> queue . append ( 0 ) <NEWLINE> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> <NL> seen [ node ] = 1 <NEWLINE> <COMMENT> <NL> for next in graph [ node ] : <NEWLINE> <INDENT> if seen [ next ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> queue . append ( next ) <NEWLINE> seen [ next ] = 1 <NEWLINE> steps [ next ] = steps [ node ] + 1 <NEWLINE> parents [ next ] = node <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in parents [ 1 : ] : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <DEDENT>
a = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> b = [ 9 - ( i - 1 ) % 10 for i in a ] <NEWLINE> print ( sum ( a ) + sum ( b ) - max ( b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while k <= n + 1 : <NEWLINE> <INDENT> ans += k * ( n - k + 1 ) + 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
dic = { } <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> com , word = input ( ) . split ( ) <NEWLINE> <NL> if com == <STRING> : <NEWLINE> <INDENT> dic [ word ] = True <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if word in dic else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> sum_a = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> sum_a += i <NEWLINE> sum_a %= mod <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum_a -= A [ i ] <NEWLINE> total += A [ i ] * ( sum_a ) <NEWLINE> total %= mod <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
import collections <NEWLINE> <NL> S1 = collections . deque ( ) <NEWLINE> S2 = collections . deque ( ) <NEWLINE> S3 = collections . deque ( ) <NEWLINE> <NL> for i , j in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> if S1 : <NEWLINE> <INDENT> left_edge = S1 . pop ( ) <NEWLINE> new_puddle = i - left_edge <NEWLINE> while True : <NEWLINE> <INDENT> if S2 : <NEWLINE> <INDENT> if S2 [ - 1 ] > left_edge : <NEWLINE> <INDENT> S2 . pop ( ) <NEWLINE> new_puddle += S3 . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> S2 . append ( left_edge ) <NEWLINE> S3 . append ( new_puddle ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( S3 ) ) <NEWLINE> <NL> print ( len ( S3 ) , * list ( S3 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> Rs = 0 <NEWLINE> Gs = 0 <NEWLINE> Bs = 0 <NEWLINE> for il in S : <NEWLINE> <INDENT> if il == <STRING> : <NEWLINE> <INDENT> Rs += 1 <NEWLINE> <DEDENT> if il == <STRING> : <NEWLINE> <INDENT> Gs += 1 <NEWLINE> <DEDENT> if il == <STRING> : <NEWLINE> <INDENT> Bs += 1 <NEWLINE> <DEDENT> <DEDENT> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for step in range ( 1 , N ) : <NEWLINE> <INDENT> j = i + step <NEWLINE> k = i + 2 * step <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( Rs * Gs * Bs - num ) <NEWLINE>
data = input ( ) . split ( ) <NEWLINE> N = int ( data [ 0 ] ) <NEWLINE> K = int ( data [ 1 ] ) <NEWLINE> e = [ n for n in range ( N + 1 ) ] <NEWLINE> count = 0 <NEWLINE> for k in range ( K , N + 2 ) : <NEWLINE> <INDENT> count += k * N - k * ( k - 1 ) + 1 <NEWLINE> <DEDENT> print ( count % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ u ] += v , <NEWLINE> edges [ v ] += u , <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( N + 1 ) <NEWLINE> lastLis = [ ] <NEWLINE> visited = [ False ] * ( N + 1 ) <NEWLINE> parent = { } <NEWLINE> n = 1 <NEWLINE> stack = [ ] <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if not visited [ n ] : <NEWLINE> <INDENT> if len ( lastLis ) == 0 or a [ n - 1 ] > lastLis [ - 1 ] : <NEWLINE> <INDENT> lastLis . append ( a [ n - 1 ] ) <NEWLINE> stack += ( len ( lastLis ) - 1 , - 1 ) , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = bisect_left ( lastLis , a [ n - 1 ] ) <NEWLINE> stack += ( index , lastLis [ index ] ) , <NEWLINE> lastLis [ index ] = a [ n - 1 ] <NEWLINE> <DEDENT> ans [ n ] = len ( lastLis ) <NEWLINE> visited [ n ] = True <NEWLINE> <DEDENT> hasNext = False <NEWLINE> for d in edges [ n ] : <NEWLINE> <INDENT> if not visited [ d ] : <NEWLINE> <INDENT> parent [ d ] = n <NEWLINE> n = d <NEWLINE> hasNext = True <NEWLINE> <DEDENT> <DEDENT> if not hasNext : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> n = 0 <NEWLINE> break <NEWLINE> <DEDENT> n = parent [ n ] <NEWLINE> <COMMENT> <NL> index , value = stack . pop ( len ( stack ) - 1 ) <NEWLINE> if value < 0 : <NEWLINE> <INDENT> lastLis . pop ( index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lastLis [ index ] = value <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b >= k - a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = [ [ 0 ] for _ in range ( n + 1 ) ] <NEWLINE> d1 = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> d1 [ p ] += x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> vi = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> <NL> def dfs ( x , i ) : <NEWLINE> <INDENT> vi [ x ] = i + d1 [ x ] <NEWLINE> for m in d [ x ] : <NEWLINE> <INDENT> if vi [ m ] == - 1 and m != 0 : <NEWLINE> <INDENT> dfs ( m , vi [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , 0 ) <NEWLINE> <NL> <NL> print ( * vi [ 1 : ] ) <NEWLINE>
<COMMENT> <NL> <NL> def construct_gs ( n ) : <NEWLINE> <INDENT> gs = [ ] <NEWLINE> g = 1 <NEWLINE> while g <= n : <NEWLINE> <INDENT> gs . append ( g ) <NEWLINE> g = 3 * g + 1 <NEWLINE> <DEDENT> return gs [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def shell_sort ( xs , n ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> gs = construct_gs ( n ) <NEWLINE> m = len ( gs ) <NEWLINE> def insertion_sort ( g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = xs [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and xs [ j ] > v : <NEWLINE> <INDENT> xs [ j + g ] = xs [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> xs [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> for g in gs : <NEWLINE> <INDENT> insertion_sort ( g ) <NEWLINE> <DEDENT> return m , gs , cnt , xs <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> xs = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> m , gs , cnt , xs = shell_sort ( xs , n ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , gs ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for x in xs : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if N == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ps = set ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> diff = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = X - diff <NEWLINE> if a not in Ps : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> a = X + diff <NEWLINE> if a not in Ps : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT>
import queue <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> ans = [ ( 1e9 , 0 ) for i in range ( n + 1 ) ] <NEWLINE> seen = [ False for _ in range ( n + 1 ) ] <NEWLINE> seen [ 1 ] = True <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> table [ a ] . append ( b ) <NEWLINE> table [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> <NL> q . put ( ( 1 , table [ 1 ] ) ) <NEWLINE> while ( not q . empty ( ) ) : <NEWLINE> <INDENT> element = q . get ( ) <NEWLINE> for i in element [ 1 ] : <NEWLINE> <INDENT> if seen [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = element [ 0 ] <NEWLINE> seen [ i ] = True <NEWLINE> q . put ( ( i , table [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if 1e9 in ans [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> s = list ( map ( int , list ( input ( ) ) ) ) [ : : - 1 ] <NEWLINE> N = len ( s ) <NEWLINE> cusum = [ 0 ] * ( N + 1 ) <NEWLINE> cusum [ 0 ] = s [ 0 ] % 2019 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> power = pow ( 10 , i , 2019 ) <NEWLINE> cusum [ i ] = ( cusum [ i - 1 ] + power * s [ i ] ) % 2019 <NEWLINE> <DEDENT> counter = Counter ( cusum ) <NEWLINE> print ( sum ( x * ( x - 1 ) // 2 for x in counter . values ( ) ) ) <NEWLINE>
n , m , l = input ( ) . split ( ) <NEWLINE> <NL> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> l = int ( l ) <NEWLINE> <NL> matrix_A = [ [ 0 ] * m for i in range ( n ) ] <NEWLINE> matrix_B = [ [ 0 ] * l for j in range ( m ) ] <NEWLINE> matrix_C = [ [ 0 ] * l for k in range ( n ) ] <NEWLINE> box_a = [ ] <NEWLINE> box_b = [ ] <NEWLINE> box_c = 0 <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <NL> <INDENT> box_a = input ( ) . split ( ) <NEWLINE> <NL> for b in range ( m ) : <NEWLINE> <NL> <INDENT> matrix_A [ a ] [ b ] = int ( box_a [ b ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for c in range ( m ) : <NEWLINE> <NL> <INDENT> box_b = input ( ) . split ( ) <NEWLINE> <NL> for d in range ( l ) : <NEWLINE> <NL> <INDENT> matrix_B [ c ] [ d ] = int ( box_b [ d ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for e in range ( n ) : <NEWLINE> <NL> <INDENT> for f in range ( l ) : <NEWLINE> <NL> <INDENT> for g in range ( m ) : <NEWLINE> <INDENT> box_c += matrix_A [ e ] [ g ] * matrix_B [ g ] [ f ] <NEWLINE> <NL> <NL> <DEDENT> matrix_C [ e ] [ f ] = box_c <NEWLINE> box_c = 0 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , matrix_C [ e ] ) ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ans = 7 % k <NEWLINE> <NL> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if ans % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( d . values ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in d . keys ( ) : <NEWLINE> <INDENT> if d [ i ] == m : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> l_s = sorted ( l ) <NEWLINE> for i in l_s : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> X = [ 0 ] * M <NEWLINE> Y = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> X [ i ] , Y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ind = - 1 <NEWLINE> d_min = float ( <STRING> ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> d = abs ( A [ i ] - X [ j ] ) + abs ( B [ i ] - Y [ j ] ) <NEWLINE> if d < d_min : <NEWLINE> <INDENT> d_min = d <NEWLINE> ind = j + 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = ind <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( * solve ( ) , sep = <STRING> ) <NEWLINE>
n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> <NL> for i in range ( n + 2 - k ) : <NEWLINE> <INDENT> ad = 1 + ( n + 1 - k - i ) * ( k + i ) <NEWLINE> s += ad <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( s % M ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> index = 0 <NEWLINE> visited_index = [ 0 ] <NEWLINE> <NL> while K : <NEWLINE> <INDENT> index = A [ index ] <NEWLINE> if visited [ index ] : <NEWLINE> <INDENT> K -= 1 <NEWLINE> start = visited_index . index ( index ) <NEWLINE> loop_index = visited_index [ start : ] <NEWLINE> print ( loop_index [ K % len ( loop_index ) ] + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> visited_index . append ( index ) <NEWLINE> visited [ index ] = True <NEWLINE> K -= 1 <NEWLINE> <DEDENT> print ( index + 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , Y , Z = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = Y <NEWLINE> B = X <NEWLINE> C = Z <NEWLINE> <NL> print ( C , B , A ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( m - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , a ) <NEWLINE> r = min ( r , b ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , r - l + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = A [ i ] + i <COMMENT> <NEWLINE> if x not in m : <NEWLINE> <INDENT> m [ x ] = 0 <COMMENT> <NEWLINE> <DEDENT> m [ x ] += 1 <COMMENT> <NEWLINE> if i - A [ i ] in m : <COMMENT> <NEWLINE> <INDENT> ans += m [ i - A [ i ] ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
inp = input ( ) <NEWLINE> inp = input ( ) <NEWLINE> <NL> def mp ( nums ) : <NEWLINE> <INDENT> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> n = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> for num in nums : <NEWLINE> <INDENT> n *= num <NEWLINE> if n > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> mp ( [ int ( x ) for x in inp . split ( <STRING> ) ] ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if k >= 0 and k <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> N_list = [ i + 1 for i in range ( N ) ] <NEWLINE> cumsum = list ( itertools . accumulate ( N_list ) ) <NEWLINE> aa = cumsum [ - 1 ] <NEWLINE> t_list = [ i for i in N_list if i % 3 == 0 or i % 5 == 0 ] <NEWLINE> if len ( t_list ) != 0 : <NEWLINE> <INDENT> acumsum = list ( itertools . accumulate ( t_list ) ) [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> acumsum = 0 <NEWLINE> <DEDENT> print ( aa - acumsum ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = 7 <NEWLINE> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = ( a * 10 + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xs = [ a , b ] <NEWLINE> if a < b and b == 0 : <NEWLINE> <INDENT> xs . append ( b - 1 ) <NEWLINE> <DEDENT> if a == 0 and a < b : <NEWLINE> <INDENT> xs . append ( a + 1 ) <NEWLINE> <NL> <DEDENT> ys = [ c , d ] <NEWLINE> if c < d and d == 0 : <NEWLINE> <INDENT> ys . append ( d - 1 ) <NEWLINE> <DEDENT> if c == 0 and c < d : <NEWLINE> <INDENT> ys . append ( c + 1 ) <NEWLINE> <NL> <DEDENT> anses = [ ] <NEWLINE> <NL> for x in xs : <NEWLINE> <INDENT> for y in ys : <NEWLINE> <INDENT> anses . append ( x * y ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( anses ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> def add ( a , b ) : <NEWLINE> <INDENT> return ( a + b ) % mod <NEWLINE> <NL> <DEDENT> def sub ( a , b ) : <NEWLINE> <INDENT> return ( a + mod - b ) % mod <NEWLINE> <NL> <DEDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return ( ( a % mod ) * ( b % mod ) ) % mod <NEWLINE> <NL> <DEDENT> def power ( x , y ) : <NEWLINE> <INDENT> if y == 0 : return 1 <NEWLINE> elif y == 1 : return x % mod <NEWLINE> elif y % 2 == 0 : return power ( x , y // 2 ) ** 2 % mod <NEWLINE> else : return power ( x , y // 2 ) ** 2 * x % mod <NEWLINE> <NL> <DEDENT> def div ( a , b ) : <NEWLINE> <INDENT> return mul ( a , power ( b , mod - 2 ) ) <NEWLINE> <NL> <DEDENT> def cc ( ii ) : <NEWLINE> <INDENT> iii = 1 <NEWLINE> for ii in range ( 1 , ii + 1 ) : <NEWLINE> <INDENT> iii = iii * ii <NEWLINE> <DEDENT> return iii <NEWLINE> <NL> <DEDENT> def cmb ( a , b ) : <NEWLINE> <INDENT> iii = 1 <NEWLINE> for ii in range ( a - b + 1 , a + 1 ) : <NEWLINE> <INDENT> iii = ( iii * ii ) % mod <NEWLINE> <DEDENT> iiii = 1 <NEWLINE> for ii in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> iiii = ( iiii * ii ) % mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return div ( iii , iiii ) <NEWLINE> <NL> <DEDENT> from functools import reduce <NEWLINE> <NL> def cmb2 ( n , r ) : <NEWLINE> <INDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : return 1 <NEWLINE> if r == 1 : return n <NEWLINE> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return div ( over , under ) <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ib = k - 1 <NEWLINE> ir = n - ib <NEWLINE> <NL> for i in range ( 1 , ib + 2 ) : <NEWLINE> <INDENT> if i > ir : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cb = cmb2 ( ib , i - 1 ) <NEWLINE> cr = cmb2 ( ir , i ) <NEWLINE> <COMMENT> <NL> print ( mul ( cb , cr ) ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( a ) <NEWLINE> r . append ( b ) <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> dp [ 1 ] = 1 <NEWLINE> dpsum = [ 0 ] * ( n + 1 ) <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> li = i - r [ j ] <NEWLINE> ri = i - l [ j ] <NEWLINE> if ri < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li = max ( 1 , li ) <NEWLINE> <NL> dp [ i ] += ( dpsum [ ri ] - dpsum [ li - 1 ] ) % mod <NEWLINE> <NL> <DEDENT> dpsum [ i ] = dpsum [ i - 1 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 200002 ) <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph [ l - 1 ] . append ( [ r - 1 , d ] ) <NEWLINE> graph [ r - 1 ] . append ( [ l - 1 , - d ] ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> for t , d in graph [ s ] : <NEWLINE> <INDENT> if x [ t ] is None : <NEWLINE> <INDENT> x [ t ] = x [ s ] + d <NEWLINE> if not dfs ( t ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x [ t ] - x [ s ] != d : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> x = [ None ] * n <NEWLINE> ans = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] is None : <NEWLINE> <INDENT> x [ i ] = 0 <NEWLINE> if not dfs ( i ) : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> , <STRING> ) [ ans ] ) <NEWLINE>
class FenwickTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . bit = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . n : <NEWLINE> <INDENT> self . bit [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def get_sum ( self , i , j ) : <NEWLINE> <INDENT> return self . sum ( j ) - self . sum ( i ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bit = FenwickTree ( n ) <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> bit . add ( i + 1 , x ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> query = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if query [ 0 ] == 0 : <NEWLINE> <INDENT> bit . add ( query [ 1 ] + 1 , query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bit . get_sum ( query [ 1 ] , query [ 2 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minus_cnt = 0 <NEWLINE> abs_sum = 0 <NEWLINE> min_abs_val = 1000000000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> abs_val = abs ( A [ i ] ) <NEWLINE> abs_sum = abs_sum + abs_val <NEWLINE> if abs_val < min_abs_val : <NEWLINE> <INDENT> min_abs_val = abs_val <NEWLINE> <DEDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> minus_cnt = minus_cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> B_max_sum = 0 <NEWLINE> if ( minus_cnt % 2 == 0 ) or ( min_abs_val == 0 ) : <NEWLINE> <INDENT> B_max_sum = abs_sum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B_max_sum = abs_sum - min_abs_val * 2 <NEWLINE> <NL> <DEDENT> print ( B_max_sum ) <NEWLINE>
import collections <NEWLINE> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> n = 100001 <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Blist = [ ] <NEWLINE> Clist = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Blist . append ( B ) <NEWLINE> Clist . append ( C ) <NEWLINE> <NL> <DEDENT> Adic = dict ( collections . Counter ( Alist ) ) <NEWLINE> numlist = [ 0 ] * n <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if j in Adic : <NEWLINE> <INDENT> numlist [ j ] = Adic [ j ] <NEWLINE> <DEDENT> <DEDENT> sum = sum ( Alist ) <NEWLINE> for k in range ( Q ) : <NEWLINE> <INDENT> sum += ( Clist [ k ] - Blist [ k ] ) * numlist [ Blist [ k ] ] <NEWLINE> numlist [ Clist [ k ] ] += numlist [ Blist [ k ] ] <NEWLINE> numlist [ Blist [ k ] ] = 0 <NEWLINE> <NL> print ( sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> dp = [ n + 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j <= n : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - j ] + 1 ) <NEWLINE> j *= 6 <NEWLINE> <NL> <DEDENT> k = 1 <NEWLINE> while k <= n : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - k ] + 1 ) <NEWLINE> k *= 9 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( N + K ) % 3 == 0 and N * 2 >= K and K * 2 >= N : <NEWLINE> <INDENT> A = max ( N , K ) - min ( N , K ) <NEWLINE> low = ( min ( N , K ) - A ) // 3 <NEWLINE> all_pt = low * 2 + A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> up , down = 1 , 1 <NEWLINE> for i in range ( low ) : <NEWLINE> <INDENT> up = up * ( all_pt - i ) % mod <NEWLINE> down = down * ( i + 1 ) % mod <NEWLINE> <DEDENT> base = pow ( down , mod - 2 , mod ) <NEWLINE> print ( up * base % mod ) <NEWLINE>
ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> gcd = math . gcd <NEWLINE> n = ni ( ) <NEWLINE> x = input ( ) <NEWLINE> xr = x [ : : - 1 ] <NEWLINE> px = x . count ( <STRING> ) <NEWLINE> def solve ( t ) : <NEWLINE> <INDENT> ret = 1 <COMMENT> <NEWLINE> while t > 0 : <NEWLINE> <INDENT> p = bin ( t ) . count ( <STRING> ) <NEWLINE> t %= p <NEWLINE> ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> x_tp = 0 <NEWLINE> x_tm = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x_tp = ( x_tp + int ( xr [ i ] ) * pow ( 2 , i , px + 1 ) ) % ( px + 1 ) <COMMENT> <NEWLINE> <DEDENT> if px > 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x_tm = ( x_tm + int ( xr [ i ] ) * pow ( 2 , i , px - 1 ) ) % ( px - 1 ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if xr [ i ] == <STRING> : <NEWLINE> <INDENT> x_tmp = ( x_tp + pow ( 2 , i , px + 1 ) ) % ( px + 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if px == 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> x_tmp = ( x_tm - pow ( 2 , i , px - 1 ) ) % ( px - 1 ) <NEWLINE> <DEDENT> t = solve ( x_tmp ) <NEWLINE> ans . append ( t ) <NEWLINE> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt , yep = 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> yep = ( yep * 10 + 7 ) % k <NEWLINE> cnt += 1 <NEWLINE> if yep == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a_list [ i ] <NEWLINE> if len ( str ( ans ) ) > 19 or ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) <NEWLINE> N = int ( x ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = a + A [ i + 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b = b + A [ i ] * a <NEWLINE> a = a - A [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( b % ( 10 ** 9 + 7 ) ) <NEWLINE>
a , b = open ( 0 ) ; c = 1 ; <NEWLINE> for i in sorted ( b . split ( ) ) : c = [ d : = int ( i ) * c , - 1 ] [ 10 ** 18 < d or c < 0 ] <NEWLINE> print ( c ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A >= 2 * K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( A + i ) <NEWLINE> <DEDENT> for j in reversed ( range ( K ) ) : <NEWLINE> <INDENT> print ( B - j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aa = [ 0 ] <NEWLINE> bb = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> aa . append ( a [ i ] + aa [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bb . append ( b [ i ] + bb [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> mstart = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if k - aa [ i ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( mstart , - 1 , - 1 ) : <NEWLINE> <INDENT> if k - aa [ i ] - bb [ j ] >= 0 : <NEWLINE> <INDENT> mstart = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans < i + j : <NEWLINE> <INDENT> ans = i + j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
[ x , n ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> p_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x not in p_list : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( x - i ) not in p_list : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( x + i ) not in p_list : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
def merge ( a , l , m , r ) : <NEWLINE> <INDENT> global cnt <NEWLINE> ll = a [ l : m ] + [ 1e9 + 1 ] <NEWLINE> rl = a [ m : r ] + [ 1e9 + 1 ] <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( l , r ) : <NEWLINE> <INDENT> if ll [ i ] < rl [ j ] : <NEWLINE> <INDENT> a [ k ] = ll [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = rl [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge_sort ( a , l , r ) : <NEWLINE> <INDENT> if l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> merge_sort ( a , l , m ) <NEWLINE> merge_sort ( a , m , r ) <NEWLINE> merge ( a , l , m , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , a , cnt = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , 0 <NEWLINE> merge_sort ( a , 0 , n ) <NEWLINE> print ( * a ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> n = [ i ** 5 for i in range ( 119 + 1 ) ] <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> res = False <NEWLINE> i = 0 <NEWLINE> while not res : <NEWLINE> <INDENT> sign = 1 - 2 * ( n [ i ] < x ) <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if ( n [ i ] - n [ j ] * sign ) == x : <NEWLINE> <INDENT> print ( i , j * sign ) <NEWLINE> res = True <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a_ = k - a <NEWLINE> b_ = k - a - b <NEWLINE> <NL> res = 0 <NEWLINE> if a_ <= 0 : <NEWLINE> <INDENT> res += k <NEWLINE> <DEDENT> elif b_ <= 0 : <NEWLINE> <INDENT> res += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += a - b_ <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> l = [ True for _ in range ( A [ - 1 ] + 1 ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if l [ A [ n ] ] == True : <NEWLINE> <INDENT> if A [ n ] == A [ n + 1 ] : <NEWLINE> <INDENT> l [ A [ n ] ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ A [ n ] ] = False <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> i = 1 <NEWLINE> while i * A [ n ] <= A [ - 1 ] : <NEWLINE> <INDENT> l [ A [ n ] * i ] = False <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if l [ A [ N - 1 ] ] == True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l [ A [ N - 1 ] ] = False <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = collections . deque ( ) <NEWLINE> <NL> flag = True <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> b . append ( x ) <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( x ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * list ( b ) [ : : - 1 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = sum ( a ) <NEWLINE> adiv = make_divisors ( asum ) <NEWLINE> adiv . reverse ( ) <NEWLINE> <NL> a = np . array ( a ) <NEWLINE> ans = 1 <NEWLINE> flg = False <NEWLINE> for i in adiv : <NEWLINE> <INDENT> a_ = np . sort ( a % i ) <NEWLINE> <COMMENT> <NL> msum = a_ . sum ( ) <NEWLINE> msum_ = 0 <NEWLINE> for j in range ( - 1 , - n - 1 , - 1 ) : <NEWLINE> <INDENT> msum -= a_ [ j ] <NEWLINE> msum_ += i - a_ [ j ] <NEWLINE> if msum_ > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if msum < msum_ : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if msum == msum_ : <NEWLINE> <INDENT> ans = i <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return ( a * x ) // b - a * ( x // b ) <NEWLINE> <NL> <DEDENT> if n < b : <NEWLINE> <INDENT> print ( f ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( b - 1 ) ) <NEWLINE> <DEDENT>
<NL> k = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> Sum = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( k ) : <NEWLINE> <INDENT> Sum += gcd ( i + 1 , i + 1 , i + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> Sum += gcd ( i + 1 , j + 1 , j + 1 ) * 3 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> Sum += gcd ( i + 1 , i + 1 , j + 1 ) * 3 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( k - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k - 1 ) : <NEWLINE> <INDENT> for m in range ( j + 1 , k ) : <NEWLINE> <INDENT> Sum += gcd ( i + 1 , j + 1 , m + 1 ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
import statistics <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = statistics . median ( x ) <NEWLINE> xs = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i < y : <NEWLINE> <INDENT> print ( xs [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xs [ n // 2 - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_max = max ( A ) <NEWLINE> B = [ 0 ] * ( a_max + 1 ) <NEWLINE> <NL> for ai in A : <NEWLINE> <INDENT> for multi in range ( ai , a_max + 1 , ai ) : <NEWLINE> <INDENT> B [ multi ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if B [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> sum_ = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> sum_ += A [ i ] <NEWLINE> <DEDENT> node = 2 <NEWLINE> if A [ 0 ] > 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> if A == [ 1 ] and N == 0 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> <DEDENT> if N != 0 : <NEWLINE> <INDENT> sum_ -= A [ 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i != N and node - A [ i ] <= 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> elif i != N : <NEWLINE> <INDENT> sum_ -= A [ i + 1 ] <NEWLINE> ans += node <NEWLINE> if 2 * ( node - A [ i ] ) - A [ i + 1 ] <= sum_ : <NEWLINE> <INDENT> node = 2 * ( node - A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = sum_ + A [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if node - A [ i ] < 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N == 0 and A == [ 0 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> network = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> res = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> distance = [ N + 1 for _ in range ( N + 1 ) ] <NEWLINE> distance [ 1 ] = 0 <NEWLINE> <NL> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> network [ i ] . append ( j ) <NEWLINE> network [ j ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> <NL> n = 0 <NEWLINE> s = [ ] <NEWLINE> queue = deque ( [ 1 ] ) <NEWLINE> while n < N : <NEWLINE> <INDENT> top = queue . popleft ( ) <NEWLINE> for i in network [ top ] : <NEWLINE> <INDENT> if distance [ i ] > distance [ top ] + 1 : <NEWLINE> <INDENT> distance [ i ] = distance [ top ] + 1 <NEWLINE> res [ i ] = top <NEWLINE> queue . append ( i ) <NEWLINE> <DEDENT> <DEDENT> n += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for r in res [ 2 : ] : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) <NEWLINE> y = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> x = i <NEWLINE> while x <= m : <NEWLINE> <INDENT> y [ x ] += 1 <NEWLINE> x += i <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if y [ j ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = 1 <NEWLINE> B = [ 0 ] * ( n + 1 ) <NEWLINE> count = 0 <NEWLINE> <NL> t = len ( A ) - 1 <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> B [ i ] = b <NEWLINE> if 2 * ( b - A [ i ] ) < A [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> b = 2 * ( b - A [ i ] ) <NEWLINE> <DEDENT> B [ n ] = b <NEWLINE> <NL> if n == 0 and A [ 0 ] > 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> while count == 0 and A [ t ] > B [ j ] : <NEWLINE> <INDENT> if j == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( j ) : <NEWLINE> <INDENT> total += B [ i ] <NEWLINE> <NL> <DEDENT> s = A [ t ] <NEWLINE> for i in range ( t - 1 , j - 1 , - 1 ) : <NEWLINE> <INDENT> total += min ( B [ i ] , s + A [ i ] ) <NEWLINE> s += A [ i ] <NEWLINE> <NL> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( total + A [ t ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = list ( range ( n ) ) <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . size [ x ] < self . size [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . size [ x ] += self . size [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def sizeofset ( self , x ) : <NEWLINE> <INDENT> return self . size [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> <NL> cnt = ( N ) * ( N - 1 ) // 2 <NEWLINE> L = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for a , b in L [ : : - 1 ] : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> if not uf . same ( a , b ) : <NEWLINE> <INDENT> cnt -= uf . sizeofset ( a ) * uf . sizeofset ( b ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in ans [ : : - 1 ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> ans = 1 <NEWLINE> x_sardines = [ ] <NEWLINE> ver_sardines = [ ] <NEWLINE> hor_sardines = [ ] <NEWLINE> zero_sardines = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> if ai == 0 and bi != 0 : <NEWLINE> <INDENT> ver_sardines . append ( ( ai , bi ) ) <NEWLINE> <DEDENT> elif ai != 0 and bi == 0 : <NEWLINE> <INDENT> hor_sardines . append ( ( ai , bi ) ) <NEWLINE> <DEDENT> elif ai == 0 and bi == 0 : <NEWLINE> <INDENT> zero_sardines . append ( ( ai , bi ) ) <NEWLINE> <DEDENT> elif bi / ai > 0 : <NEWLINE> <INDENT> x_sardines . append ( ( ai , bi , 1 ) ) <NEWLINE> <DEDENT> elif bi / ai < 0 : <NEWLINE> <INDENT> x_sardines . append ( ( - 1 * bi , ai , - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> x_sardines . sort ( key = lambda x : x [ 1 ] / x [ 0 ] ) <NEWLINE> <NL> if len ( x_sardines ) > 0 : <NEWLINE> <INDENT> pai , pbi , ps = x_sardines [ 0 ] <NEWLINE> p = 1 if ps == 1 else 0 <NEWLINE> n = 1 if ps == - 1 else 0 <NEWLINE> for i , ( ai , bi , s ) in enumerate ( x_sardines [ 1 : ] ) : <NEWLINE> <INDENT> if pai * bi - pbi * ai != 0 : <NEWLINE> <INDENT> ans *= pow ( 2 , p , MOD ) + pow ( 2 , n , MOD ) - 1 <NEWLINE> ans %= MOD <NEWLINE> p = 0 <NEWLINE> n = 0 <NEWLINE> <NL> <DEDENT> if s == 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> elif s == - 1 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> pai , pbi , ps = ai , bi , s <NEWLINE> <NL> <DEDENT> ans *= pow ( 2 , p , MOD ) + pow ( 2 , n , MOD ) - 1 <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> v = len ( ver_sardines ) <NEWLINE> h = len ( hor_sardines ) <NEWLINE> ans *= pow ( 2 , v , MOD ) + pow ( 2 , h , MOD ) - 1 <NEWLINE> ans %= MOD <NEWLINE> <NL> z = len ( zero_sardines ) <NEWLINE> ans += z <NEWLINE> ans -= 1 <NEWLINE> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B <= N : <NEWLINE> <INDENT> lista = ( math . floor ( ( A * ( B - 1 ) ) / B ) - A * ( math . floor ( ( B - 1 ) / B ) ) ) <NEWLINE> print ( lista ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list = ( math . floor ( ( A * N ) / B ) - A * ( math . floor ( N / B ) ) ) <NEWLINE> print ( list ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp += A [ i + 1 ] <NEWLINE> ans += A [ i ] * tmp <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> l . append ( math . gcd ( i + 1 , j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> for h in range ( k ) : <NEWLINE> <INDENT> for n in l : <NEWLINE> <INDENT> s += math . gcd ( h + 1 , n ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> from collections import deque <NEWLINE> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> dll = deque ( ) <NEWLINE> fcode = ord ( <STRING> ) <NEWLINE> lcode = ord ( <STRING> ) <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> cmd = stdin . readline ( ) . rstrip ( ) <NEWLINE> if cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> dll . appendleft ( int ( cmd [ 7 : ] ) ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> c = ord ( cmd [ 6 ] ) <NEWLINE> if c == fcode : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> elif c == lcode : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( int ( cmd [ 7 : ] ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * dll ) <NEWLINE>
import sys <NEWLINE> <NL> tmp = <STRING> * 151 <NEWLINE> <NL> def draw ( H , W ) : <NEWLINE> <INDENT> odd = tmp [ : W ] <NEWLINE> even = tmp [ 1 : W + 1 ] <NEWLINE> print ( ( odd + <STRING> + even + <STRING> ) * ( H // 2 ) + ( odd + <STRING> if H % 2 else <STRING> ) ) <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> draw ( H , W ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> lb = 0 <NEWLINE> rb = N + 1 <NEWLINE> while rb - lb > 1 : <NEWLINE> <INDENT> mid = ( lb + rb ) // 2 <NEWLINE> x = 0 <NEWLINE> for i , s in enumerate ( S [ : mid ] ) : <NEWLINE> <INDENT> x += pow ( 26 , i ) * ( ord ( s ) - ord ( <STRING> ) ) <NEWLINE> <DEDENT> m = pow ( 26 , mid - 1 ) <NEWLINE> a = [ x ] <NEWLINE> for i , s in enumerate ( S [ mid : ] ) : <NEWLINE> <INDENT> x -= ord ( S [ i ] ) - ord ( <STRING> ) <NEWLINE> x //= 26 <NEWLINE> x += m * ( ord ( s ) - ord ( <STRING> ) ) <NEWLINE> a += [ x ] <NEWLINE> <DEDENT> f = 0 <NEWLINE> se = set ( [ ] ) <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> if i >= mid : <NEWLINE> <INDENT> se . add ( a [ i - mid ] ) <NEWLINE> <DEDENT> if x in se : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> lb = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rb = mid <NEWLINE> <DEDENT> <DEDENT> print ( lb ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ s [ : k - 1 ] , s [ k - 1 ] . lower ( ) , s [ k : ] ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL>
n , m , x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = [ [ ] for i in range ( n ) ] <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> sc = 12 * 100001 <NEWLINE> for i in range ( 1 , 2 ** n ) : <NEWLINE> <INDENT> bi = <STRING> * n + bin ( i ) [ 2 : ] <NEWLINE> bi = bi [ len ( bi ) - n : ] <NEWLINE> cc = 0 <NEWLINE> e = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if bi [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> e [ k ] += a [ j ] [ k + 1 ] <NEWLINE> <DEDENT> cc += a [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> su = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> su &= e [ j ] >= x <NEWLINE> <DEDENT> if su : <NEWLINE> <INDENT> sc = min ( sc , cc ) <NEWLINE> <DEDENT> <DEDENT> sc = - 1 if sc > 12 * 100000 else sc <NEWLINE> print ( sc ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> print ( s , end = <STRING> ) <NEWLINE> if j != l - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> alpha = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans = alpha [ n % 26 ] + ans <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> rooms = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> number = int ( input ( ) ) <NEWLINE> <NL> for n in range ( number ) : <NEWLINE> <INDENT> inp = input ( ) . split ( <STRING> ) <NEWLINE> b = int ( inp [ 0 ] ) - 1 <NEWLINE> f = int ( inp [ 1 ] ) - 1 <NEWLINE> r = int ( inp [ 2 ] ) - 1 <NEWLINE> v = int ( inp [ 3 ] ) <NEWLINE> rooms [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> if b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , rooms [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> <DEDENT>
X = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans * 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> c = 1 <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> if i - c - 1 > 0 : <NEWLINE> <INDENT> for _ in range ( i - c - 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> c = i <NEWLINE> count = 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> for _ in range ( n - a [ - 1 ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> kotae = 1 <NEWLINE> listaa = [ int ( n ) for n in a ] <NEWLINE> lista = sorted ( listaa ) <NEWLINE> if lista [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> kotae *= lista [ i ] <NEWLINE> if kotae > 10 ** 18 : <NEWLINE> <INDENT> kotae = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if kotae > 10 ** 18 : <NEWLINE> <INDENT> kotae = - 1 <NEWLINE> <DEDENT> print ( kotae ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for _ in range ( min ( 41 , K ) ) : <NEWLINE> <INDENT> A_cumsum = np . zeros ( shape = N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_cumsum [ max ( 0 , i - A [ i ] ) ] += 1 <NEWLINE> b = i + A [ i ] + 1 <NEWLINE> if N - 1 < b : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_cumsum [ b ] -= 1 <NEWLINE> <DEDENT> <DEDENT> A = np . cumsum ( A_cumsum ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> ans = solve ( N , K , A ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import random <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> ans = 0 <NEWLINE> a = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> res = - float ( <STRING> ) <NEWLINE> index = 0 <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> x = k <NEWLINE> tnplast = last <NEWLINE> tnplast [ x ] = i <NEWLINE> tnp = 0 <NEWLINE> tnp += s [ i - 1 ] [ x ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> tnp -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> if ( tnp > res ) : <NEWLINE> <INDENT> res = tnp <NEWLINE> index = k + 1 <NEWLINE> <DEDENT> <DEDENT> ans += res <NEWLINE> a . append ( index ) <NEWLINE> <NL> <DEDENT> def rec ( t , x , y , ans ) : <NEWLINE> <INDENT> ans -= s [ x - 1 ] [ t [ x - 1 ] - 1 ] <NEWLINE> ans += s [ x - 1 ] [ y - 1 ] <NEWLINE> ma = d + 1 <NEWLINE> mi = 0 <NEWLINE> for j in range ( x + 1 , d + 1 ) : <NEWLINE> <INDENT> if ( t [ j - 1 ] == t [ x - 1 ] ) : <NEWLINE> <INDENT> ma = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( x - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( t [ j - 1 ] == t [ x - 1 ] ) : <NEWLINE> <INDENT> mi = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans -= c [ t [ x - 1 ] - 1 ] * ( x - mi ) * ( ma - x ) <NEWLINE> ma = d + 1 <NEWLINE> mi = 0 <NEWLINE> for j in range ( x + 1 , d + 1 ) : <NEWLINE> <INDENT> if ( t [ j - 1 ] == y ) : <NEWLINE> <INDENT> ma = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( x - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( t [ j - 1 ] == y ) : <NEWLINE> <INDENT> mi = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans += c [ y - 1 ] * ( x - mi ) * ( ma - x ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> for i in range ( 180000 ) : <NEWLINE> <INDENT> x = random . randrange ( 1 , d + 1 ) <NEWLINE> y = random . randrange ( 1 , 27 ) <NEWLINE> t = a <NEWLINE> A = rec ( t , x , y , ans ) <NEWLINE> if ( ans < A ) : <NEWLINE> <INDENT> t [ x - 1 ] = y <NEWLINE> a = t <NEWLINE> ans = A <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a , sep = <STRING> ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def chess ( h , w ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( chess ( i , j ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import Counter <NEWLINE> from sys import exit <NEWLINE> from itertools import product <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> <NL> cnt = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i , j in cnt . items ( ) : <NEWLINE> <INDENT> if i > j : <NEWLINE> <INDENT> ans += j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += j - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 1 ] <NEWLINE> C = [ <STRING> ] * N <NEWLINE> roop = False <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if C [ B [ i ] - 1 ] == <STRING> : <NEWLINE> <INDENT> C [ B [ i ] - 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop = True <NEWLINE> break <NEWLINE> <DEDENT> B . append ( A [ B [ i ] - 1 ] ) <NEWLINE> <DEDENT> if roop == True : <NEWLINE> <INDENT> f = B . index ( B [ i ] ) <NEWLINE> T = i - f <NEWLINE> if T == 0 : <NEWLINE> <INDENT> print ( B [ f ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( K - f ) % T <NEWLINE> print ( B [ f + r ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ K ] ) <NEWLINE> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> operation = [ ] <NEWLINE> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ ih ] [ iw ] % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ ih ] [ iw ] -= 1 <NEWLINE> a [ ih ] [ iw + 1 ] += 1 <NEWLINE> cnt += 1 <NEWLINE> operation . append ( [ ih + 1 , iw + 1 , ih + 1 , iw + 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H - 1 ) : <NEWLINE> <INDENT> if a [ ih ] [ W - 1 ] % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ ih ] [ W - 1 ] -= 1 <NEWLINE> a [ ih + 1 ] [ W - 1 ] += 1 <NEWLINE> cnt += 1 <NEWLINE> operation . append ( [ ih + 1 , W , ih + 2 , W ] ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> for ope in operation : <NEWLINE> <INDENT> print ( * ope ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( tree , n , ans ) : <NEWLINE> <INDENT> for i in tree [ n ] : <NEWLINE> <INDENT> ans [ i ] += ans [ n ] <NEWLINE> tree [ i ] . remove ( n ) <NEWLINE> dfs ( tree , i , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> g [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ px [ i - 1 ] [ 0 ] - 1 ] += px [ i - 1 ] [ 1 ] <NEWLINE> <DEDENT> dfs ( g , 0 , ans ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
import math <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if x % 2 == 0 or x < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i = 3 <NEWLINE> x_sqrt = math . sqrt ( x ) <NEWLINE> while i <= x_sqrt : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if is_prime ( int ( input ( ) ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> r = S [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> g = S [ j ] <NEWLINE> if r == g : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = S [ k ] <NEWLINE> if r != b and g != b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a = set ( a ) <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for now in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> for next_step in range ( now + 1 , min ( n + 1 , now + 3 ) ) : <NEWLINE> <INDENT> if not next_step in a : <NEWLINE> <INDENT> dp [ next_step ] += dp [ now ] <NEWLINE> dp [ next_step ] %= 1000000007 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> HP = [ ] <NEWLINE> for p in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> P = [ p ] * len ( X ) <NEWLINE> delta = sum ( [ ( i - j ) ** 2 for ( i , j ) in zip ( X , P ) ] ) <NEWLINE> HP . append ( delta ) <NEWLINE> <NL> <DEDENT> print ( min ( HP ) ) <NEWLINE>
s = input ( ) <NEWLINE> s_len = len ( s ) <NEWLINE> n = 2019 <NEWLINE> mod_list = [ 0 ] * n <NEWLINE> mod_list [ 0 ] = 1 <NEWLINE> <NL> p = 1 <NEWLINE> d = 0 <NEWLINE> for t in reversed ( s ) : <NEWLINE> <INDENT> d += int ( t ) * p <NEWLINE> m = d % n <NEWLINE> mod_list [ m ] += 1 <NEWLINE> p *= 10 <NEWLINE> p %= 2019 <NEWLINE> <NL> <DEDENT> result = sum ( i * ( i - 1 ) // 2 for i in mod_list ) <NEWLINE> print ( result ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> fin = [ 1 ] * d <NEWLINE> pen = [ 0 ] * 26 <NEWLINE> sattemp = 0 <NEWLINE> sat = 0 <NEWLINE> sl = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> for k in range ( 1 , 20 ) : <NEWLINE> <INDENT> for i in range ( d ) : <NEWLINE> <INDENT> s = sl [ i ] <NEWLINE> sp = sum ( pen ) <NEWLINE> temp = - ( 10 ** 9 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if s [ j ] - ( sp - pen [ j ] ) ** k > temp : <NEWLINE> <INDENT> temp = s [ j ] - ( sp - pen [ j ] ) ** k <NEWLINE> tempans = j + 1 <NEWLINE> <DEDENT> <DEDENT> ans += [ tempans ] <NEWLINE> sattemp += s [ tempans - 1 ] - sp + pen [ tempans - 1 ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> pen [ j ] += c [ j ] <NEWLINE> pen [ tempans - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> if sattemp > sat : <NEWLINE> <INDENT> sat = sattemp <NEWLINE> fin = ans <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> sattemp = 0 <NEWLINE> <DEDENT> for i in fin : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> j = M <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N + 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( <STRING> ) ) <NEWLINE> a = [ ] <NEWLINE> t = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> t = n <NEWLINE> c = i + 1 <NEWLINE> n -= 26 ** ( i + 1 ) <NEWLINE> if ( n <= 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> a += [ n % 26 ] <NEWLINE> n = int ( n / 26 ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> b += [ a [ n - 1 - i ] ] <NEWLINE> <DEDENT> s = <STRING> <NEWLINE> for i in b : <NEWLINE> <INDENT> if ( i == 1 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 2 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 3 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 4 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 5 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 6 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 7 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 8 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 9 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 10 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 11 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 12 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 13 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 14 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 15 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 16 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 17 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 18 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 19 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 20 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 21 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 22 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 23 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 24 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 25 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> elif ( i == 0 ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> r_list = [ ] <NEWLINE> g_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r_list . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g_list . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( s ) - 1 ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> if i < n // 2 : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i < ( n - 1 ) // 2 : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == ( n - 1 ) // 2 : <NEWLINE> <INDENT> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i > ( n - 1 ) // 2 : <NEWLINE> <INDENT> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( r_list ) * len ( g_list ) * len ( b_list ) - count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> blank = 2 <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] * blank <NEWLINE> INF = 10 ** 9 + 1 <NEWLINE> dp = [ INF ] * ( N + blank ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i ] + abs ( h [ i + 1 ] - h [ i ] ) , dp [ i + 1 ] ) <NEWLINE> dp [ i + 2 ] = min ( dp [ i ] + abs ( h [ i + 2 ] - h [ i ] ) , dp [ i + 2 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> board = [ [ 0 for i in range ( 11 ) ] for j in range ( 11 ) ] <NEWLINE> for i , line in enumerate ( f ) : <NEWLINE> <INDENT> for j , c in enumerate ( line . strip ( ) ) : <NEWLINE> <INDENT> board [ i + 1 ] [ 1 + ( i + 1 ) % 2 + j * 2 ] = int ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> step = { ( - 1 , 0 ) : <STRING> , ( 0 , - 1 ) : <STRING> , ( 1 , 0 ) : <STRING> , ( 0 , 1 ) : <STRING> } <NEWLINE> <NL> <NL> start = pre_loc = 1 + 1j <NEWLINE> loc = 3 + 1j <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> while loc != start : <NEWLINE> <INDENT> for direct in [ ( pre_loc - loc ) / 2 * 1j ** ( i + 1 ) for i in range ( 4 ) ] : <NEWLINE> <INDENT> if board [ int ( loc . imag + direct . imag ) ] [ int ( loc . real + direct . real ) ] : <NEWLINE> <INDENT> pre_loc = loc <NEWLINE> loc += direct * 2 <NEWLINE> print ( step [ ( direct . real , direct . imag ) ] , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
def ser ( X , Y ) : <NEWLINE> <INDENT> dp = [ [ 0 ] * ( len ( Y ) + 1 ) for x in range ( len ( X ) + 1 ) ] <NEWLINE> for i , x in enumerate ( X , 1 ) : <NEWLINE> <INDENT> tmp = dp [ i ] <NEWLINE> pre = dp [ i - 1 ] <NEWLINE> for j , y in enumerate ( Y , 1 ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> tmp [ j ] = pre [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif pre [ j ] < tmp [ j - 1 ] : <NEWLINE> <INDENT> tmp [ j ] = tmp [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp [ j ] = pre [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( dp [ - 1 ] [ - 1 ] ) <NEWLINE> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> X , Y = input ( ) , input ( ) <NEWLINE> print ( ser ( X , Y ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> tmp = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum = sum + math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> def ok ( i ) : <NEWLINE> <INDENT> pin = <STRING> . format ( i ) <NEWLINE> j = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == pin [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> if j == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> ans += ok ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> yn = 0 <NEWLINE> if a . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> yn = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if yn == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R = R + 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G = G + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = B + 1 <NEWLINE> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if N <= k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ k ] and S [ k ] != S [ j ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for m in range ( M ) ] <NEWLINE> BC = sorted ( BC , key = lambda x : x [ 1 ] ) [ : : - 1 ] <NEWLINE> <NL> for b , c in BC : <NEWLINE> <INDENT> A . extend ( b * [ c ] ) <NEWLINE> if 2 * N < len ( A ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A = sorted ( A ) [ : : - 1 ] <NEWLINE> print ( sum ( A [ : N ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> n = 7 <NEWLINE> counter = 1 <NEWLINE> remainders = set ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> remainder = n % k <NEWLINE> if remainder == 0 : <NEWLINE> <INDENT> print ( counter ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if remainder in remainders : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> remainders . add ( remainder ) <NEWLINE> <NL> n = remainder * 10 + 7 <NEWLINE> counter += 1 <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> c = [ [ 0 for _ in range ( l ) ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> c [ i ] [ k ] += a [ i ] [ j ] * b [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in c : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , i ) ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( i + i * ( n // i ) ) * ( n // i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <COMMENT> <NEWLINE> <INDENT> result [ Alist [ i ] - 1 ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> s = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> l . append ( math . gcd ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( len ( l ) ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( l [ x ] , y ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i , a in enumerate ( a ) : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> S = list ( S ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <COMMENT> <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = 2 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = 4 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] + S [ j ] + S [ k ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( w , v ) in enumerate ( wv , start = 1 ) : <NEWLINE> <INDENT> dp_i = dp [ i ] <NEWLINE> dp_im = dp [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp_i [ j ] = dp_im [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = dp_im [ j - w ] + v <NEWLINE> b = dp_im [ j ] <NEWLINE> if a > b : <NEWLINE> <INDENT> dp_i [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_i [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> ] * N <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> li = [ - 1 ] * n <NEWLINE> li [ 0 ] = 0 <NEWLINE> town = [ 0 ] <NEWLINE> now = 0 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now ] - 1 <NEWLINE> if li [ now ] != - 1 : <NEWLINE> <INDENT> s = li [ now ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ now ] = i + 1 <NEWLINE> town . append ( now ) <NEWLINE> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> town2 = town [ s : ] <NEWLINE> m = len ( town2 ) <NEWLINE> l = len ( town ) - len ( town2 ) <NEWLINE> <NL> print ( town2 [ ( k - l ) % m ] + 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxi = max ( an ) <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( maxi ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> def judge ( t ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> for i in an : <NEWLINE> <INDENT> if i % t == 0 : <NEWLINE> <INDENT> m += i // t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m += i // t + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if m <= n + k : <NEWLINE> <COMMENT> <NL> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> mini = 0 <NEWLINE> <COMMENT> <NL> <NL> while mini + 1 != maxi : <NEWLINE> <INDENT> check = ( mini + maxi ) // 2 <NEWLINE> <COMMENT> <NL> if judge ( check ) : <NEWLINE> <INDENT> maxi = check <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> mini = check <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( maxi ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d1 = defaultdict ( int ) <NEWLINE> d2 = defaultdict ( int ) <NEWLINE> for i , ae in enumerate ( a ) : <NEWLINE> <INDENT> d1 [ i + ae + 1 ] += 1 <NEWLINE> d2 [ i - ae + 1 ] += 1 <NEWLINE> <DEDENT> r = 0 <NEWLINE> for d1e in d1 . keys ( ) : <NEWLINE> <INDENT> rt = d1 [ d1e ] * d2 [ d1e ] <NEWLINE> r += rt <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> def solve ( k , r ) : <NEWLINE> <INDENT> count = { } <NEWLINE> ans = 0 <NEWLINE> for i , n in enumerate ( r ) : <NEWLINE> <INDENT> target = i - n <NEWLINE> ans += count . get ( target , 0 ) <NEWLINE> count [ i + n ] = count . get ( i + n , 0 ) + 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( k , r ) ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> data [ a - 1 ] . append ( b - 1 ) <NEWLINE> data [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n - 1 ) <NEWLINE> <NL> def bfs ( i , queue , p ) : <NEWLINE> <INDENT> while len ( queue ) > 0 : <NEWLINE> <INDENT> x = queue . popleft ( ) <NEWLINE> pre = p . popleft ( ) <NEWLINE> for j in range ( len ( x ) ) : <NEWLINE> <INDENT> if ans [ x [ j ] - 1 ] == 0 and x [ j ] != 0 : <NEWLINE> <INDENT> ans [ x [ j ] - 1 ] = pre + 1 <NEWLINE> queue . append ( data [ x [ j ] ] ) <NEWLINE> p . append ( x [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> queue = deque ( ) <NEWLINE> pre = deque ( ) <NEWLINE> pre . append ( 0 ) <NEWLINE> queue . append ( data [ 0 ] ) <NEWLINE> bfs ( 0 , queue , pre ) <NEWLINE> <NL> if 0 not in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> GCD = [ [ 0 ] * ( K + 2 ) for _ in range ( K + 2 ) ] <NEWLINE> import math <NEWLINE> def make_GCD ( K ) : <NEWLINE> <INDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> GCD [ a ] [ b ] = math . gcd ( a , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> make_GCD ( K ) <NEWLINE> <NL> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> a = GCD [ a ] [ b ] <NEWLINE> return GCD [ a ] [ c ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> place = 1 <NEWLINE> road = [ 0 for i in range ( N ) ] <NEWLINE> cycle = 0 <NEWLINE> <NL> road [ 0 ] = 1 <NEWLINE> <NL> while K != 0 : <NEWLINE> <INDENT> place = A_i [ place - 1 ] <NEWLINE> K -= 1 <NEWLINE> if road [ place - 1 ] == 1 : <NEWLINE> <INDENT> loop_place = place <NEWLINE> break <NEWLINE> <DEDENT> road [ place - 1 ] = 1 <NEWLINE> <NL> <DEDENT> while K != 0 : <NEWLINE> <INDENT> loop_place = A_i [ loop_place - 1 ] <NEWLINE> cycle += 1 <NEWLINE> <NL> if place == loop_place : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cycle != 0 : <NEWLINE> <INDENT> K = K % cycle <NEWLINE> <NL> <DEDENT> while K != 0 : <NEWLINE> <INDENT> place = A_i [ place - 1 ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( place ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> INF = 10 ** 6 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ INF ] * ( 2 ** n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bit = [ <STRING> ] * n <NEWLINE> for x in set ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> bit [ x - 1 ] = <STRING> <NEWLINE> <DEDENT> bit = int ( <STRING> . join ( bit [ : : - 1 ] ) , 2 ) <NEWLINE> for j in range ( 2 ** n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j | bit ] = min ( dp [ j | bit ] , a + dp [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> xa , ya , xb , yb , xc , yc , xd , yd = map ( float , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if abs ( ( ya - yb ) * ( yc - yd ) + ( xa - xb ) * ( xc - xd ) ) < 1.e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mp = set ( range ( - 1 , 102 ) ) <NEWLINE> p = set ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> lp = list ( mp - p ) <NEWLINE> sub_lp = [ abs ( i - x ) for i in lp ] <NEWLINE> print ( lp [ sub_lp . index ( min ( sub_lp ) ) ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> RL = [ ] <NEWLINE> <COMMENT> <NL> SL = [ ] <NEWLINE> <NL> <COMMENT> <NL> def downer ( index ) : <NEWLINE> <INDENT> RL . append ( index ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def upper ( index ) : <NEWLINE> <INDENT> if len ( RL ) > 0 : <NEWLINE> <INDENT> p = RL . pop ( ) <NEWLINE> q = index <NEWLINE> s = q - p <NEWLINE> if len ( SL ) > 0 : <NEWLINE> <INDENT> QL = SL [ : : - 1 ] <NEWLINE> for i in QL : <NEWLINE> <INDENT> if i [ 0 ] > p : <NEWLINE> <INDENT> s += SL . pop ( ) [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> SL . append ( [ p , s ] ) <NEWLINE> <DEDENT> else : SL . append ( [ p , s ] ) <NEWLINE> <DEDENT> else : return <NEWLINE> <NL> <DEDENT> L = input ( ) <NEWLINE> index = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> downer ( index ) <NEWLINE> index += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> upper ( index ) <NEWLINE> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> <DEDENT> AL = [ ] <NEWLINE> for i in SL : <NEWLINE> <INDENT> AL . append ( i [ 1 ] ) <NEWLINE> <DEDENT> print ( str ( sum ( AL ) ) ) <NEWLINE> if len ( AL ) == 0 : <NEWLINE> <INDENT> print ( len ( AL ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( AL ) , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , AL ) ) ) <NEWLINE> <DEDENT>
def main ( N , K , A ) : <NEWLINE> <INDENT> for i in range ( K , N ) : <COMMENT> <NEWLINE> <INDENT> this = A [ i ] <NEWLINE> before = A [ i - K ] <NEWLINE> <NL> if this > before : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( N , K , A ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 or <STRING> in str ( i ) ) : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def int_mtx ( N ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return np . array ( x ) <NEWLINE> <NL> <DEDENT> def str_mtx ( N ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> return np . array ( x ) <NEWLINE> <NL> <DEDENT> def int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def int_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def print_space ( l ) : <NEWLINE> <INDENT> return print ( <STRING> . join ( [ str ( x ) for x in l ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import collections as col <NEWLINE> <NL> import numpy as np <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> <NL> <COMMENT> <NL> N , M = int_map ( ) <NEWLINE> <NL> i = [ ] <NEWLINE> j = [ ] <NEWLINE> <NL> for z in range ( 0 , M ) : <NEWLINE> <INDENT> a , b = int_map ( ) <NEWLINE> i . append ( a - 1 ) <NEWLINE> j . append ( b - 1 ) <NEWLINE> <NL> <DEDENT> d = [ 1 ] * M <NEWLINE> <NL> csr = csr_matrix ( ( d , ( i , j ) ) , ( N , N ) ) <NEWLINE> <NL> <NL> n , labels = connected_components ( csr ) <NEWLINE> <NL> ll = list ( labels ) <NEWLINE> aa = col . Counter ( ll ) <NEWLINE> print ( aa . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> alist . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h = abs ( alist [ 0 ] [ 0 ] - i ) + abs ( alist [ 0 ] [ 1 ] - j ) + alist [ 0 ] [ 2 ] <NEWLINE> ans = True <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if max ( ( h - abs ( alist [ k ] [ 0 ] - i ) - abs ( alist [ k ] [ 1 ] - j ) ) , 0 ) != alist [ k ] [ 2 ] : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> ansx = i <NEWLINE> ansy = j <NEWLINE> ansh = h <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ansx , ansy , ansh ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> min_A = min ( A ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> if min_A == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if ( N % 1000 != 0 ) : <NEWLINE> <INDENT> print ( 1000 - ( N % 1000 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> result = [ ] <NEWLINE> biggest = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> last = ls . pop ( ) <NEWLINE> if last > biggest : <NEWLINE> <INDENT> biggest = last <NEWLINE> result . append ( last - min ( ls ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( result ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * ( N + 1 ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> dist [ 1 ] = 0 <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = dist [ v ] + 1 <NEWLINE> d . append ( i ) <NEWLINE> ans [ i ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 2 : ] , sep = <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> All = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( All [ i ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> point [ a ] += b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> point [ next ] += point [ now ] <NEWLINE> <COMMENT> <NL> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> bcs = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> j , k = map ( int , input ( ) . split ( ) ) <NEWLINE> bcs . append ( [ j , k ] ) <NEWLINE> <DEDENT> s = sum ( A ) <NEWLINE> cnts = [ 0 ] * 100000 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnts [ a - 1 ] += 1 <NEWLINE> <DEDENT> for b , c in bcs : <NEWLINE> <INDENT> t = cnts [ b - 1 ] <NEWLINE> s -= t * b <NEWLINE> cnts [ b - 1 ] = 0 <NEWLINE> cnts [ c - 1 ] += t <NEWLINE> s += t * c <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = x <NEWLINE> a = [ x ] <NEWLINE> d = { } <NEWLINE> d [ x ] = 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> tmp = a [ - 1 ] ** 2 % m <NEWLINE> if d . get ( tmp , 0 ) == 0 : <NEWLINE> <INDENT> a . append ( tmp ) <NEWLINE> d [ tmp ] = 1 <NEWLINE> ans += tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = a . index ( tmp ) <NEWLINE> if len ( a ) - t >= n - i + 1 : <NEWLINE> <INDENT> ans += sum ( a [ t : t + n - i + 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = a . index ( tmp ) <NEWLINE> tmp_a = ( n - i + 1 ) // ( len ( a ) - t ) <NEWLINE> tmp_b = ( n - i + 1 ) - ( len ( a ) - t ) * tmp_a <NEWLINE> ans += sum ( a [ t : ] ) * tmp_a + sum ( a [ t : t + tmp_b ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = sum ( A ) ** 2 <NEWLINE> <NL> a = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> a += ( i ** 2 ) <NEWLINE> <NL> <DEDENT> ans = ( s - a ) // 2 <NEWLINE> ans = ans % mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> def f ( x , y , z ) : <NEWLINE> <COMMENT> <NL> <INDENT> return math . floor ( x * y / z ) - x * math . floor ( y / z ) <NEWLINE> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( a , b - 1 , b ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = gcd ( a , b ) <NEWLINE> l = make_divisors ( x ) <NEWLINE> print ( l [ - k ] ) <NEWLINE>
import sys <NEWLINE> from math import factorial <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def log ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if ( 2 * x - y ) % 3 != 0 or ( 2 * y - x ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> a = ( 2 * x - y ) // 3 <NEWLINE> b = ( 2 * y - x ) // 3 <NEWLINE> if a < 0 or b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = ( factorial_mod ( a + b , mod ) * pow ( factorial_mod ( min ( a , b ) , mod ) , mod - 2 , mod ) <NEWLINE> <INDENT> * pow ( factorial_mod ( a + b - min ( a , b ) , mod ) , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def factorial_mod ( a , mod ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for v in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def InsertionSort ( A , N , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , N ) : <NEWLINE> <INDENT> key = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = key <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def ShellSort ( A , N ) : <NEWLINE> <INDENT> G = [ ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if 3 ** i - 1 > N * 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . insert ( 0 , int ( ( 3 ** i - 1 ) / 2 ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( G ) ) : <NEWLINE> <INDENT> InsertionSort ( A , N , G [ i ] ) <NEWLINE> <DEDENT> return G <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ShellSort ( A , N ) <NEWLINE> print ( len ( ShellSort ( A , N ) ) ) <NEWLINE> print ( * ShellSort ( A , N ) ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> p_abs = sorted ( list ( map ( lambda k : abs ( k - x ) , p ) ) ) <NEWLINE> <COMMENT> <NL> <NL> if ( len ( p_abs ) == 0 or p_abs [ 0 ] != 0 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ( 2 * i >= len ( p ) ) : <NEWLINE> <INDENT> if ( x - i not in p ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> elif ( p_abs [ 2 * i - 1 ] != i or p_abs [ 2 * i ] != i ) : <NEWLINE> <INDENT> if ( x - i not in p ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> full_root = [ 0 ] + A + [ 0 ] <NEWLINE> full_place = [ abs ( full_root [ i ] - full_root [ i + 1 ] ) for i in range ( N + 1 ) ] <NEWLINE> full_res = sum ( full_place ) <NEWLINE> <COMMENT> <NL> for ind in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res = full_res - sum ( full_place [ ind - 1 : ind + 1 ] ) + abs ( full_root [ ind - 1 ] - full_root [ ind + 1 ] ) <NEWLINE> <NL> print ( res ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n %= k <NEWLINE> <NL> if ( n < k / 2 ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k - n ) <NEWLINE> <DEDENT>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> S = input ( ) <NEWLINE> <NL> if c < d : <NEWLINE> <INDENT> while b < d : <NEWLINE> <INDENT> if S [ b + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif b + 2 <= d and S [ b + 2 ] == <STRING> : <NEWLINE> <INDENT> b += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> while a < c : <NEWLINE> <INDENT> if S [ a + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif a + 2 <= c and S [ a + 2 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while a < c : <NEWLINE> <INDENT> if a + 1 == b and S [ a + 2 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> elif a + 1 == b and a + 3 <= d and S [ a + 3 ] == <STRING> : <NEWLINE> <INDENT> b += 2 <NEWLINE> a += 1 <NEWLINE> <DEDENT> elif S [ a + 1 ] == <STRING> and a + 1 != b : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif a + 2 == b and a + 3 <= d and S [ a + 3 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> b += 1 <NEWLINE> <DEDENT> elif a + 2 == b and a + 4 <= d and S [ a + 4 ] == <STRING> : <NEWLINE> <INDENT> a += 2 <NEWLINE> b += 2 <NEWLINE> <DEDENT> elif S [ a + 2 ] == <STRING> and a + 2 != b : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> while b < d : <NEWLINE> <INDENT> if S [ b + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif b + 2 <= d and S [ b + 2 ] == <STRING> : <NEWLINE> <INDENT> b += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for i in range ( N ) ] <NEWLINE> ans = [ None for i in range ( N ) ] <NEWLINE> visited = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> b = b - 1 <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def bfs ( path , root , visited ) : <NEWLINE> <INDENT> visited [ root ] = 1 <NEWLINE> queue = deque ( [ root ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> cur = queue . popleft ( ) <NEWLINE> for chi in path [ cur ] : <NEWLINE> <INDENT> if visited [ chi ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ chi ] = cur + 1 <NEWLINE> visited [ chi ] = 1 <NEWLINE> queue . append ( chi ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if all ( [ i == 1 for i in visited ] ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> flag = bfs ( path , 0 , visited ) <NEWLINE> <NL> print ( flag ) <NEWLINE> <NL> if flag == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
<NL> def search ( start , N , X , Y ) : <NEWLINE> <INDENT> dist = [ 0 for _ in range ( N ) ] <NEWLINE> if start <= X : <NEWLINE> <INDENT> for i in range ( X ) : <NEWLINE> <INDENT> dist [ i ] = abs ( start - i ) <NEWLINE> <DEDENT> for i in range ( Y , N ) : <NEWLINE> <INDENT> dist [ i ] = ( X - start ) + 1 + ( i - Y ) <NEWLINE> <DEDENT> for i in range ( X , ( Y - X ) // 2 + X + 1 ) : <NEWLINE> <INDENT> dist [ i ] = ( i - start ) <NEWLINE> <DEDENT> for i in range ( ( Y - X ) // 2 + X + 1 , Y ) : <NEWLINE> <INDENT> dist [ i ] = ( X - start ) + 1 + ( Y - i ) <NEWLINE> <DEDENT> <DEDENT> elif start >= Y : <NEWLINE> <INDENT> for i in range ( Y , N ) : <NEWLINE> <INDENT> dist [ i ] = abs ( start - i ) <NEWLINE> <DEDENT> for i in range ( X ) : <NEWLINE> <INDENT> dist [ i ] = ( start - Y ) + 1 + ( X - i ) <NEWLINE> <DEDENT> for i in range ( X , ( Y - X ) // 2 + X ) : <NEWLINE> <INDENT> dist [ i ] = ( start - Y ) + 1 + ( i - X ) <NEWLINE> <DEDENT> for i in range ( ( Y - X ) // 2 + X , Y ) : <NEWLINE> <INDENT> dist [ i ] = ( start - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> toX = min ( start - X , Y - start + 1 ) <NEWLINE> toY = min ( Y - start , start - X + 1 ) <NEWLINE> dist [ start ] = 0 <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> dist [ i ] = ( X - i ) + toX <NEWLINE> <DEDENT> for i in range ( Y , N ) : <NEWLINE> <INDENT> dist [ i ] = toY + ( i - Y ) <NEWLINE> <DEDENT> for i in range ( X , start ) : <NEWLINE> <INDENT> dist [ i ] = min ( start - i , Y - start + 1 + i - X ) <NEWLINE> <DEDENT> for i in range ( start + 1 , Y ) : <NEWLINE> <INDENT> dist [ i ] = min ( i - start , start - X + 1 + Y - i ) <NEWLINE> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , X , Y = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <COMMENT> <NL> <NL> X = X - 1 <NEWLINE> Y = Y - 1 <NEWLINE> <NL> lenD = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d = search ( i , N , X , Y ) <NEWLINE> lenD . append ( d ) <NEWLINE> <NL> <DEDENT> kcounter = [ 0 for _ in range ( N - 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = lenD [ i ] [ j ] <NEWLINE> kcounter [ k - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k in kcounter : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , X , M = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> def f ( a ) : <NEWLINE> <INDENT> return a * a % M <NEWLINE> <NL> <DEDENT> a = X <NEWLINE> <NL> map = { } <NEWLINE> ary = [ a ] <NEWLINE> map [ a ] = 0 <NEWLINE> <NL> sub = [ 0 , a ] <NEWLINE> last_sub = a <NEWLINE> <NL> count = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = f ( a ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a in map : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> map [ a ] = i <NEWLINE> <DEDENT> count += 1 <NEWLINE> last_sub += a <NEWLINE> sub . append ( last_sub ) <NEWLINE> <NL> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( sub [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def naive ( a ) : <NEWLINE> <INDENT> total = a <NEWLINE> ary = [ a ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = f ( a ) <NEWLINE> ary . append ( a ) <NEWLINE> <DEDENT> return ary <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> j = map [ a ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> unit = sub [ - 1 ] - sub [ j ] <NEWLINE> <COMMENT> <NL> <NL> l = count <NEWLINE> i = ( N - j ) % ( l - j ) <NEWLINE> d = ( N - j ) // ( l - j ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( unit * d + sub [ i + j ] ) <NEWLINE> <NL> <COMMENT> <NL>
def find_max ( a ) : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> <NL> if n <= 3 : <NEWLINE> <INDENT> return max ( a ) <NEWLINE> <NL> <DEDENT> dp = [ [ - ( 1 << 64 ) ] * ( 2 + n % 2 ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( 2 + n % 2 ) : <NEWLINE> <INDENT> dp [ i ] [ i ] = a [ i ] <NEWLINE> dp [ i + 1 ] [ i ] = a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> for j in range ( 2 + n % 2 ) : <NEWLINE> <INDENT> for extra_space in range ( j + 1 ) : <NEWLINE> <INDENT> curr_sum = dp [ i - ( 2 + extra_space ) ] [ j - extra_space ] + a [ i ] <NEWLINE> if curr_sum > dp [ i ] [ j ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = curr_sum <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] [ 1 + n % 2 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( find_max ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> line = input ( ) <NEWLINE> for k in range ( 0 , len ( line ) ) : <NEWLINE> <INDENT> print ( line [ len ( line ) - k - 1 ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B , C , K = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> a = min ( A , K ) <NEWLINE> if K - A >= 0 : <NEWLINE> <INDENT> b = min ( abs ( K - A ) , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 0 <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> if K - A - B >= 0 : <NEWLINE> <INDENT> c = min ( abs ( K - A - B ) , C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <NL> <DEDENT> ans = 1 * a + 0 * b - 1 * c <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
<STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aix2 = list ( map ( lambda x : x * 2 , ai ) ) <NEWLINE> <NL> sum_a = sum ( ai ) <NEWLINE> <NL> def ring_get ( xs , s , e , mod ) : <NEWLINE> <INDENT> ys = [ ] <NEWLINE> i = s % mod <NEWLINE> <NL> while i != ( e % mod ) : <NEWLINE> <INDENT> ys . append ( xs [ i ] ) <NEWLINE> i = ( i + 2 ) % mod <NEWLINE> <NL> <DEDENT> return ys <NEWLINE> <NL> <DEDENT> beforeM = sum_a - sum ( ring_get ( aix2 , 1 , 1 + ( n - 1 ) , n ) ) <NEWLINE> <NL> print ( beforeM ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( aix2 [ i - 1 ] - beforeM ) <NEWLINE> beforeM = aix2 [ i - 1 ] - beforeM <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> f = lambda x : int ( x ) - 1 <NEWLINE> l = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( f , input ( ) . split ( ) ) <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <DEDENT> m = 0 <NEWLINE> visit = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i in visit : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue = [ i ] <NEWLINE> visit . add ( i ) <NEWLINE> cnt = 1 <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> now = queue . pop ( 0 ) <NEWLINE> for j in l [ now ] : <NEWLINE> <INDENT> if j not in visit : <NEWLINE> <INDENT> visit . add ( j ) <NEWLINE> queue . append ( j ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> m = max ( m , cnt ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
def inp ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def iinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inps ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def miinps ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def linps ( ) : <NEWLINE> <INDENT> return list ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> def lmiinps ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def lmiinpsf ( n ) : <NEWLINE> <INDENT> return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> n = iinp ( ) <NEWLINE> a = lmiinps ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> count += ( a [ i ] % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> count -= a [ i ] <NEWLINE> ans += ( a [ i ] % ( 10 ** 9 + 7 ) ) * count <NEWLINE> <NL> <NL> <DEDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum -= a [ i ] <NEWLINE> ans += a [ i ] * sum <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
def solve ( alist ) : <NEWLINE> <INDENT> if 0 in alist : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> result = 1 <NEWLINE> for a in alist : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( alist ) ) <NEWLINE>
N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> def judge ( x ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> v = a // x <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> v -= 1 <NEWLINE> <DEDENT> k += v <NEWLINE> <DEDENT> return k <= K <NEWLINE> <NL> <DEDENT> low = 1 <NEWLINE> high = max ( A ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> while low < high - 1 : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if judge ( mid ) : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <NL> <DEDENT> <DEDENT> if judge ( low ) : <NEWLINE> <INDENT> print ( low ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( high ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ta = sum ( a ) <NEWLINE> a . append ( 0 ) <NEWLINE> tb = 0 <NEWLINE> ans = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ta -= a [ n - i ] <NEWLINE> if ta > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while tb + ta <= k : <NEWLINE> <NL> <INDENT> if j == m : <NEWLINE> <INDENT> ans = max ( ans , n - i + j ) <NEWLINE> break <NEWLINE> <DEDENT> ans = max ( ans , n - i + j ) <NEWLINE> tb += b [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> connect_list = [ set ( ) for _ in range ( N ) ] <COMMENT> <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> connect_list [ A - 1 ] . add ( B ) <NEWLINE> connect_list [ B - 1 ] . add ( A ) <NEWLINE> <NL> <DEDENT> root_list = [ 0 ] * N <NEWLINE> root_list [ 0 ] = <STRING> <NEWLINE> <NL> for i in list ( connect_list [ 0 ] ) : <NEWLINE> <INDENT> root_list [ i - 1 ] = 1 <NEWLINE> <DEDENT> now_set = connect_list [ 0 ] <NEWLINE> while len ( now_set ) != 0 : <NEWLINE> <INDENT> for j in list ( now_set ) : <NEWLINE> <INDENT> for i in list ( connect_list [ j - 1 ] ) : <NEWLINE> <INDENT> if root_list [ i - 1 ] == 0 : <NEWLINE> <INDENT> root_list [ i - 1 ] = j <NEWLINE> now_set . add ( i ) <NEWLINE> <DEDENT> <DEDENT> now_set . remove ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in root_list : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; d = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in d : d [ i ] = 1 <NEWLINE> else : d [ i ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ j if i > j else j - i for i , j in d . items ( ) ] ) ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> d = deque ( ) <NEWLINE> d . extend ( list ( input ( ) ) ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> reflag = False <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> query = list ( input ( ) . split ( ) ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> reflag = not reflag <NEWLINE> <DEDENT> elif ( query [ 1 ] == <STRING> and not reflag ) or ( query [ 1 ] == <STRING> and reflag ) : <NEWLINE> <INDENT> d . appendleft ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if reflag : <NEWLINE> <INDENT> print ( <STRING> . join ( reversed ( d ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( d ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> D1 , D2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if D == 3 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if D1 == D2 : <NEWLINE> <INDENT> D += 1 <NEWLINE> <NL> <DEDENT> elif D1 != D2 : <NEWLINE> <INDENT> D = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if D == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> m = int ( math . sqrt ( n ) ) + 1 <NEWLINE> x = y = z = 0 <NEWLINE> <NL> def p ( x , y , z ) : <NEWLINE> <INDENT> return x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> anss = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for x in range ( 1 , m ) : <NEWLINE> <INDENT> for y in range ( 1 , m ) : <NEWLINE> <INDENT> for z in range ( 1 , m ) : <NEWLINE> <INDENT> if p ( x , y , z ) - 1 <= n - 1 : <NEWLINE> <INDENT> anss [ p ( x , y , z ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( anss [ i ] ) <NEWLINE> <DEDENT>
<NL> import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 1 , 2 * 10 ** 6 ) : <NEWLINE> <INDENT> a = 10 * a + 7 <NEWLINE> a %= k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> d += i <NEWLINE> if d <= a [ 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import collections <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> div = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> div [ i + 1 ] = ( div [ i ] + int ( S [ N - 1 - i ] ) * pow ( 10 , i , mod ) ) % mod <NEWLINE> <DEDENT> d = collections . Counter ( div [ 1 : : ] ) <NEWLINE> ans = d [ 0 ] <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> while y != 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE> <NL>
roomsOfBuilding = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for l in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> roomsOfBuilding [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> counter = 0 <NEWLINE> for building in roomsOfBuilding : <NEWLINE> <INDENT> counter += 1 <NEWLINE> for rooms in building : <NEWLINE> <INDENT> for room in rooms : <NEWLINE> <INDENT> print ( <STRING> + str ( room ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if counter < 4 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> i_list = [ 0 ] * N <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> o = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = int ( ( ( i + j ) * ( j + k ) ) + i * i + k * k ) <NEWLINE> if n < ( N + 1 ) : <NEWLINE> <INDENT> o [ n ] += 1 <NEWLINE> <DEDENT> if n > 10001 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( o [ i + 1 ] ) <NEWLINE> <NL> <DEDENT>
from itertools import count <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 0 <NEWLINE> for i in count ( 0 ) : <NEWLINE> <INDENT> m += pow ( 10 , i , k ) * 7 <NEWLINE> m %= k <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] / A [ i - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> table = [ ] <NEWLINE> for rc in range ( r ) : <NEWLINE> <INDENT> table . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> table . append ( [ 0 for _ in range ( c + 1 ) ] ) <NEWLINE> <NL> for rc in range ( r ) : <NEWLINE> <INDENT> row_total = 0 <NEWLINE> for cc in range ( c ) : <NEWLINE> <INDENT> table [ r ] [ cc ] += table [ rc ] [ cc ] <NEWLINE> row_total += table [ rc ] [ cc ] <NEWLINE> <NL> <DEDENT> table [ rc ] . append ( row_total ) <NEWLINE> table [ r ] [ c ] += row_total <NEWLINE> <NL> <DEDENT> for row in table : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( column ) for column in row ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = S ^ a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> b [ i ] = S ^ a [ i ] <NEWLINE> <NL> <DEDENT> print ( * b ) <NEWLINE>
arr = [ 0 for i in range ( 2019 ) ] <NEWLINE> arr [ 0 ] = 1 <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> num = 0 <NEWLINE> for i , ele in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> num += int ( ele ) * pow ( 10 , i , 2019 ) <NEWLINE> arr [ num % 2019 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for m in arr : <NEWLINE> <INDENT> if m == 0 : continue <NEWLINE> ans += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
def get_neg ( neg_list , k , mod ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> neg_list . sort ( reverse = True ) <NEWLINE> for num in neg_list [ : k ] : <NEWLINE> <INDENT> ans = ans * num % mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def get_pos ( pos_list , neg_list , k , mod ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> nums = [ ] <NEWLINE> neg_iter = iter ( sorted ( neg_list ) ) <NEWLINE> pos_iter = iter ( sorted ( pos_list , reverse = True ) ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans *= pos_iter . __next__ ( ) <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> for a , b in zip ( pos_iter , pos_iter ) : <NEWLINE> <INDENT> nums . append ( a * b ) <NEWLINE> <NL> <DEDENT> for a , b in zip ( neg_iter , neg_iter ) : <NEWLINE> <INDENT> nums . append ( a * b ) <NEWLINE> <NL> <DEDENT> nums . sort ( reverse = True ) <NEWLINE> for num in nums [ : k // 2 ] : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def get_all ( num_list , mod ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for num in num_list : <NEWLINE> <INDENT> ans = ans * num % mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> ans = get_all ( A , mod ) <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> pos_list = [ ] <NEWLINE> neg_list = [ ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> pos_list . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg_list . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if k % 2 and not pos_list : <NEWLINE> <INDENT> ans = get_neg ( neg_list , k , mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = get_pos ( pos_list , neg_list , k , mod ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( ( a , b ) ) <NEWLINE> <DEDENT> l2 = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> l2 . append ( ( l [ i ] [ 0 ] - l [ j ] [ 0 ] , l [ i ] [ 1 ] - l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> from collections import Counter <NEWLINE> l2 = max ( Counter ( l2 ) . values ( ) ) <NEWLINE> print ( N - l2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> if N % i == 0 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> def priority ( klr ) : <NEWLINE> <INDENT> return abs ( klr [ 1 ] - klr [ 2 ] ) <NEWLINE> <NL> <DEDENT> def process ( KP ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> for kp in KP : <NEWLINE> <INDENT> if kp [ 0 ] < len ( q ) and len ( q ) > 0 and q [ 0 ] < kp [ 1 ] : <NEWLINE> <INDENT> heapq . heappop ( q ) <NEWLINE> <DEDENT> if kp [ 0 ] >= len ( q ) : <NEWLINE> <INDENT> heapq . heappush ( q , kp [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return sum ( q ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> KLR = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> klr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> klr [ 0 ] -= 1 <COMMENT> <NEWLINE> KLR . append ( klr ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for klr in KLR : <NEWLINE> <INDENT> if klr [ 1 ] > klr [ 2 ] : <NEWLINE> <INDENT> ans += klr [ 2 ] <NEWLINE> L . append ( ( klr [ 0 ] , klr [ 1 ] - klr [ 2 ] ) ) <NEWLINE> <DEDENT> elif klr [ 1 ] < klr [ 2 ] : <NEWLINE> <INDENT> ans += klr [ 1 ] <NEWLINE> R . append ( ( N - 1 - klr [ 0 ] - 1 , klr [ 2 ] - klr [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += klr [ 1 ] <NEWLINE> <DEDENT> <DEDENT> L . sort ( key = lambda kp : kp [ 0 ] ) <NEWLINE> R . sort ( key = lambda kp : kp [ 0 ] ) <NEWLINE> ans += process ( L ) <NEWLINE> ans += process ( R ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> T = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( T ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = 0 ; i = 1 ; b = n // 2 <NEWLINE> while i * i < b : a += ( ( b - 1 ) // i + 1 ) - i - 1 ; i += 1 <NEWLINE> a = ( a + b - 1 ) * 2 + i <NEWLINE> print ( 8 * ( a + n ) ) <NEWLINE> <DEDENT>
import sys , os , io <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( start ) : <NEWLINE> <INDENT> stack = [ start ] <NEWLINE> parent = [ N ] * N <NEWLINE> parent [ start ] = - 1 <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack [ - 1 ] <NEWLINE> marker = 0 <NEWLINE> for u in edge [ v ] : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if parent [ u ] == N : <COMMENT> <NEWLINE> <INDENT> marker = 1 <NEWLINE> parent [ u ] = v <NEWLINE> stack . append ( u ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans [ v ] *= ans [ u ] + 1 <NEWLINE> ans [ v ] %= M <NEWLINE> <DEDENT> <DEDENT> if marker == 0 : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def dfs2 ( start ) : <NEWLINE> <INDENT> stack = [ start ] <NEWLINE> parent = [ N ] * N <NEWLINE> parent [ start ] = - 1 <NEWLINE> p_value = [ 0 ] * N <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> cum1 = [ 1 ] * ( len ( edge [ v ] ) + 1 ) <NEWLINE> cum2 = [ 1 ] * ( len ( edge [ v ] ) + 1 ) <NEWLINE> for i , u in enumerate ( edge [ v ] ) : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> cum1 [ i + 1 ] = cum1 [ i ] * ( p_value [ v ] + 1 ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum1 [ i + 1 ] = cum1 [ i ] * ( ans [ u ] + 1 ) % M <NEWLINE> <DEDENT> <DEDENT> for i , u in enumerate ( edge [ v ] [ : : - 1 ] ) : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> cum2 [ - i - 2 ] = cum2 [ - i - 1 ] * ( p_value [ v ] + 1 ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum2 [ - i - 2 ] = cum2 [ - i - 1 ] * ( ans [ u ] + 1 ) % M <NEWLINE> <DEDENT> <DEDENT> for i , u in enumerate ( edge [ v ] ) : <NEWLINE> <INDENT> if u == parent [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ u ] = v <NEWLINE> p_value [ u ] = cum1 [ i ] * cum2 [ i + 1 ] % M <NEWLINE> ans [ u ] *= ( p_value [ u ] + 1 ) <NEWLINE> ans [ u ] %= M <NEWLINE> stack . append ( u ) <NEWLINE> <DEDENT> ans [ v ] %= M <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> ans = [ 1 ] * N <NEWLINE> dfs ( 0 ) <NEWLINE> dfs2 ( 0 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> res *= a [ i ] <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> S = sorted ( S ) <NEWLINE> <NL> ans = sum ( S ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans = ans - S [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> ans = R * G * B <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if { S [ i ] , S [ j ] , S [ k ] } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans -= count <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sums = sum ( list1 ) <NEWLINE> <NL> for i in list1 : <NEWLINE> <INDENT> sums -= i <NEWLINE> ans += sums * i % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def extgcd ( a , b ) : <NEWLINE> <INDENT> r = [ 1 , 0 , a ] <NEWLINE> w = [ 0 , 1 , b ] <NEWLINE> while w [ 2 ] != 1 : <NEWLINE> <INDENT> q = r [ 2 ] // w [ 2 ] <NEWLINE> r2 = w <NEWLINE> w2 = [ r [ 0 ] - q * w [ 0 ] , r [ 1 ] - q * w [ 1 ] , r [ 2 ] - q * w [ 2 ] ] <NEWLINE> r = r2 <NEWLINE> w = w2 <NEWLINE> <COMMENT> <NL> <DEDENT> return [ w [ 0 ] , w [ 1 ] ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def mod_inv ( a , mod ) : <NEWLINE> <INDENT> x = extgcd ( a , mod ) [ 0 ] <NEWLINE> return ( mod + x % mod ) % mod <NEWLINE> <DEDENT> N = n - k + 1 <NEWLINE> combi = [ 0 for i in range ( n + 1 ) ] <NEWLINE> combi [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> combi [ i ] = ( combi [ i - 1 ] * ( N - i + 1 ) * mod_inv ( i , mod ) ) % mod <NEWLINE> <DEDENT> fact = [ 0 for i in range ( n + 1 ) ] <NEWLINE> fact [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = ( i * fact [ i - 1 ] ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( ( combi [ i ] * fact [ k - 1 ] * pow ( fact [ k - i ] , - 1 , mod ) * pow ( fact [ i - 1 ] , - 1 , mod ) ) % mod ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import statistics <NEWLINE> import unittest <NEWLINE> <NL> <NL> def calculate_standard_deviation ( ) : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> data = [ ] <NEWLINE> i = 0 <NEWLINE> while ( i < len ( lines ) ) : <NEWLINE> <INDENT> if ( int ( lines [ i ] . rstrip ( ) ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data . append ( [ int ( score ) for score in lines [ i + 1 ] . rstrip ( ) . split ( ) ] ) <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> for scores in data : <NEWLINE> <INDENT> mean = statistics . mean ( scores ) <NEWLINE> <NL> print ( statistics . pstdev ( scores ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def __input_error ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> class __TestValueClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def testEqual ( self , func , tuples ) : <NEWLINE> <INDENT> self . testFunction ( self . assertEqual , func , tuples ) <NEWLINE> <NL> <DEDENT> def testFunction ( self , assertfunc , func , tuples ) : <NEWLINE> <COMMENT> <NL> <INDENT> for item in tuples : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if isinstance ( item [ 0 ] , collections . Iterable ) : <NEWLINE> <INDENT> assertfunc ( func ( * item [ 0 ] ) , item [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assertfunc ( func ( item [ 0 ] ) , item [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> except Exception as msg : <NEWLINE> <INDENT> swidth = 15 <NEWLINE> print ( <STRING> * 50 ) <NEWLINE> print ( <STRING> + func . __name__ + <STRING> ) <NEWLINE> print ( <STRING> . ljust ( swidth ) + <STRING> , item [ 0 ] ) <NEWLINE> print ( <STRING> . ljust ( swidth ) + <STRING> , item [ 1 ] ) <NEWLINE> print ( <STRING> . ljust ( swidth ) + <STRING> ) <NEWLINE> print ( msg ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( func . __name__ , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> calculate_standard_deviation ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
def GCD ( m , n ) : <NEWLINE> <INDENT> while n : <NEWLINE> <INDENT> m , n = n , m % n <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> gcd = GCD ( a , b ) <NEWLINE> lcm = ( a * b ) // gcd <NEWLINE> print ( gcd , lcm ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rev = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rev [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * rev ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in b . keys ( ) : <NEWLINE> <INDENT> if b [ i ] % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = [ 0 ] * M , [ 0 ] * M <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> L [ m ] , R [ m ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( max ( min ( R ) - max ( L ) + 1 , 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> c = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> c = c * i <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = g = b = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : r += 1 <NEWLINE> elif i == <STRING> : g += 1 <NEWLINE> else : b += 1 <NEWLINE> <NL> <DEDENT> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k_ = j + ( j - i ) <NEWLINE> if ( k_ >= n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans -= int ( s [ i ] != s [ j ] and s [ i ] != s [ k_ ] and s [ j ] != s [ k_ ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import time <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> <COMMENT> <NL> INF = 1 << 50 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = readInt ( ) <NEWLINE> a = readInt ( ) <NEWLINE> ans = [ <STRING> for i in range ( n - k ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> f = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if b < a or c < a or b > c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a == b and b == c : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( d , c ) <NEWLINE> f += e <NEWLINE> continue <NEWLINE> <DEDENT> elif a == b and b != c : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( d , c ) <NEWLINE> f += e * 3 <NEWLINE> continue <NEWLINE> <DEDENT> elif b == c and b != a : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( d , c ) <NEWLINE> f += e * 3 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == c and b != c : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( d , c ) <NEWLINE> f += e * 3 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> e = math . gcd ( d , c ) <NEWLINE> f += e * 6 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( f ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ 0 ] <NEWLINE> bb = [ 0 ] <NEWLINE> a_sum = 0 <NEWLINE> b_sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( a_sum + a [ i ] ) <= k : <NEWLINE> <INDENT> a_sum += a [ i ] <NEWLINE> aa . append ( a_sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if ( b_sum + b [ i ] ) <= k : <NEWLINE> <INDENT> b_sum += b [ i ] <NEWLINE> bb . append ( b_sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = len ( bb ) - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( aa ) ) : <NEWLINE> <INDENT> for j in range ( cnt , - 1 , - 1 ) : <NEWLINE> <INDENT> if bb [ j ] <= ( k - aa [ i ] ) : <NEWLINE> <INDENT> cnt = j <NEWLINE> ans = max ( ans , ( i + j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> cache = { } <NEWLINE> log = [ ] <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> now = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> log . append ( now ) <NEWLINE> cache [ now ] = 1 <NEWLINE> now = A [ now ] <NEWLINE> if ( cache . get ( now ) ) : break <NEWLINE> <NL> <DEDENT> loop_start = log . index ( now ) <NEWLINE> loop_end = len ( log ) <NEWLINE> loop = loop_end - loop_start <NEWLINE> <NL> if K < len ( log ) : <NEWLINE> <INDENT> print ( log [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( log [ ( K - loop_start ) % loop + loop_start ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> def bfs ( graph , N , source ) : <NEWLINE> <INDENT> visited = [ 0 ] * N <NEWLINE> visited [ source ] = 1 <NEWLINE> q = deque ( [ source ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> for i in graph [ node ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> visited [ i ] = node + 1 <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> aw = bfs ( graph , n , 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( aw [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> p = input ( ) <NEWLINE> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> s = set ( [ x for x in range ( 102 ) ] ) <NEWLINE> s -= set ( p ) <NEWLINE> for i in range ( 0 , 51 ) : <NEWLINE> <INDENT> if x - i in s : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> if x + i in s : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> data = np . array ( p ) + 1 <NEWLINE> <NL> Pcum = np . zeros ( N + 1 , np . int32 ) <NEWLINE> Pcum [ 1 : ] = data . cumsum ( ) <NEWLINE> <NL> length_K_sums = Pcum [ K : ] - Pcum [ 0 : - K ] <NEWLINE> <NL> print ( np . max ( length_K_sums ) / 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lank = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if 1 <= a [ i ] <= 399 : <NEWLINE> <INDENT> lank [ 0 ] = 1 <NEWLINE> <DEDENT> elif 400 <= a [ i ] <= 799 : <NEWLINE> <INDENT> lank [ 1 ] = 1 <NEWLINE> <DEDENT> elif 800 <= a [ i ] <= 1199 : <NEWLINE> <INDENT> lank [ 2 ] = 1 <NEWLINE> <DEDENT> elif 1200 <= a [ i ] <= 1599 : <NEWLINE> <INDENT> lank [ 3 ] = 1 <NEWLINE> <DEDENT> elif 1600 <= a [ i ] <= 1999 : <NEWLINE> <INDENT> lank [ 4 ] = 1 <NEWLINE> <DEDENT> elif 2000 <= a [ i ] <= 2399 : <NEWLINE> <INDENT> lank [ 5 ] = 1 <NEWLINE> <DEDENT> elif 2400 <= a [ i ] <= 2799 : <NEWLINE> <INDENT> lank [ 6 ] = 1 <NEWLINE> <DEDENT> elif 2800 <= a [ i ] <= 3199 : <NEWLINE> <INDENT> lank [ 7 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> number_min = max ( 1 , lank . count ( 1 ) ) <NEWLINE> number_max = lank . count ( 1 ) + cnt <NEWLINE> <NL> print ( number_min , number_max ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] > k - B [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N - 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s = 1 <NEWLINE> hoge = False <NEWLINE> for i in y : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> hoge = True <NEWLINE> <NL> <DEDENT> <DEDENT> def f ( ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in y : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> if not hoge : <NEWLINE> <INDENT> f ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if min ( m ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . sort ( reverse = True ) <NEWLINE> for i in m : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> V , E = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> weight = [ ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> weight . append ( ( s , t , w ) ) <NEWLINE> <NL> <DEDENT> weight . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> <NL> parent = [ i for i in range ( V ) ] <NEWLINE> rank = [ 0 for i in range ( V ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( parent [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> a = find ( x ) <NEWLINE> b = find ( y ) <NEWLINE> if rank [ a ] < rank [ b ] : <NEWLINE> <INDENT> parent [ a ] = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ b ] = a <NEWLINE> if rank [ a ] == rank [ b ] : <NEWLINE> <INDENT> rank [ a ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sum_weight = 0 <NEWLINE> <NL> for i in range ( E ) : <NEWLINE> <INDENT> a , b , c = weight [ i ] <NEWLINE> if find ( a ) != find ( b ) : <NEWLINE> <INDENT> union ( a , b ) <NEWLINE> sum_weight += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_weight ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> same = False <NEWLINE> import math <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ i - 1 ] : <NEWLINE> <INDENT> same = True <NEWLINE> <DEDENT> elif same and S [ i ] != S [ i - 1 ] : <NEWLINE> <INDENT> A [ i ] = 1 <NEWLINE> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same = False <NEWLINE> A [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) + 1 ) <NEWLINE>
import sys <NEWLINE> from math import sqrt <NEWLINE> <NL> <NL> def rec ( state , v ) : <NEWLINE> <INDENT> if state == ( 1 << N ) - 1 : <NEWLINE> <INDENT> return cakes [ v ] <NEWLINE> <DEDENT> if dp [ state ] [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ state ] [ v ] <NEWLINE> <NL> <DEDENT> ret = INF <NEWLINE> for u in range ( N ) : <NEWLINE> <INDENT> if state == 0 : <NEWLINE> <INDENT> ret = min ( ret , rec ( 1 << u , u ) + cakes [ u ] ) <NEWLINE> <DEDENT> elif not ( state >> u & 1 ) : <NEWLINE> <INDENT> ret = min ( ret , rec ( state | 1 << u , u ) + sqrt ( pow ( cakes [ u ] + cakes [ v ] , 2 ) - pow ( cakes [ u ] - cakes [ v ] , 2 ) ) ) <NEWLINE> <DEDENT> <DEDENT> dp [ state ] [ v ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> testcases = [ [ int ( x ) for x in line . split ( ) ] for line in sys . stdin . readlines ( ) ] <NEWLINE> <NL> for testcase in testcases : <NEWLINE> <INDENT> box , * cakes = testcase <NEWLINE> N = len ( cakes ) <NEWLINE> INF = box + 1 <NEWLINE> dp = [ [ - 1 ] * N for _ in range ( 1 << N ) ] <NEWLINE> print ( <STRING> if rec ( 0 , 0 ) <= box else <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 7 % K <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P = <STRING> <NEWLINE> IP = <STRING> <NEWLINE> <NL> M = max ( A ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = gcd ( A [ 0 ] , A [ 0 ] ) <NEWLINE> if N > 1 : <NEWLINE> <INDENT> for a in A [ 1 : ] : <NEWLINE> <INDENT> t = gcd ( t , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if K % t == 0 and K <= M : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( IP ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 1 ] <NEWLINE> temp = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = a [ temp - 1 ] <NEWLINE> result . append ( temp ) <NEWLINE> <DEDENT> temp = result . index ( result [ len ( result ) - 1 ] ) <NEWLINE> c = len ( result ) - temp - 1 <NEWLINE> if k < n : <NEWLINE> <INDENT> print ( result [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result [ temp + ( k - temp ) % c ] ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if any ( i % 2 != 0 for i in [ a , b , c ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if a == b and b == c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> a_list = [ 0 ] * ( 1001001 ) <NEWLINE> b_list = [ 0 ] * ( 1001001 ) <NEWLINE> c_list = [ 0 ] * ( 1001001 ) <NEWLINE> a_list [ 0 ] = a <NEWLINE> b_list [ 0 ] = b <NEWLINE> c_list [ 0 ] = c <NEWLINE> <NL> for i in range ( 1 , 1001001 ) : <NEWLINE> <INDENT> a_list [ i ] = ( b_list [ i - 1 ] + c_list [ i - 1 ] ) // 2 <NEWLINE> b_list [ i ] = ( c_list [ i - 1 ] + a_list [ i - 1 ] ) // 2 <NEWLINE> c_list [ i ] = ( a_list [ i - 1 ] + b_list [ i - 1 ] ) // 2 <NEWLINE> cnt += 1 <NEWLINE> if a_list [ i ] % 2 != 0 or b_list [ i ] % 2 != 0 or c_list [ i ] % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> numer = reduce ( mul , range ( n , n - r , - 1 ) , 1 ) <NEWLINE> denom = reduce ( mul , range ( 1 , r + 1 ) , 1 ) <NEWLINE> return numer // denom <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a not in d . keys ( ) : <NEWLINE> <INDENT> d [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( d ) == n : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> d1 = dict ( ) <NEWLINE> for a in d . keys ( ) : <NEWLINE> <INDENT> d1 [ a ] = combinations_count ( d [ a ] , 2 ) <NEWLINE> <NL> <DEDENT> d2 = dict ( ) <NEWLINE> for a in d . keys ( ) : <NEWLINE> <INDENT> d2 [ a ] = combinations_count ( d [ a ] - 1 , 2 ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> d3 = dict ( ) <NEWLINE> s = sum ( d1 . values ( ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a not in d3 . keys ( ) : <NEWLINE> <INDENT> ans . append ( s - d1 [ a ] + d2 [ a ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( d3 [ a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
H = int ( input ( ) ) <NEWLINE> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i + 1 <NEWLINE> r = 2 * i + 2 <NEWLINE> if l < H and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r < H and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( A ) : <NEWLINE> <INDENT> for i in range ( H // 2 + 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> buildMaxHeap ( A ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
<NL> array = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> z = input ( ) <NEWLINE> if ( int ( z ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array . append ( z ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = 1 <NEWLINE> for i in array : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) + <STRING> + str ( i ) ) <NEWLINE> a += 1 <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> A = [ 1 ] <NEWLINE> for b in range ( 2 , 32 ) : <NEWLINE> <INDENT> for p in range ( 2 , 10 ) : <NEWLINE> <INDENT> if b ** p > X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif b ** p not in A : <NEWLINE> <INDENT> A . append ( b ** p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( A ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sum ( A ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B -= A [ i ] <NEWLINE> cnt += A [ i ] * B <NEWLINE> <NL> <DEDENT> print ( cnt % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] <NEWLINE> di = { } <NEWLINE> di [ 1 ] = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b = a [ l [ - 1 ] - 1 ] <NEWLINE> if b in di : <NEWLINE> <INDENT> x = b <NEWLINE> break <NEWLINE> <DEDENT> l . append ( b ) <NEWLINE> di [ b ] = 1 <NEWLINE> <DEDENT> t1 = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if j == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> t2 = len ( l ) - t1 <NEWLINE> if k <= t1 : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> aa = ( k - t1 ) % t2 <NEWLINE> print ( l [ t1 + aa ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> l = [ 1 ] <NEWLINE> bot = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> bot = a [ bot - 1 ] <NEWLINE> if bot == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
K , S = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> remain = S - x - y <NEWLINE> if 0 <= remain and remain <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if K == 2 : <NEWLINE> <INDENT> print ( 9 ) <NEWLINE> <DEDENT> if K == 3 : <NEWLINE> <INDENT> print ( 30 ) <NEWLINE> <DEDENT> if K == 4 : <NEWLINE> <INDENT> print ( 76 ) <NEWLINE> <DEDENT> if K == 5 : <NEWLINE> <INDENT> print ( 141 ) <NEWLINE> <DEDENT> if K == 6 : <NEWLINE> <INDENT> print ( 267 ) <NEWLINE> <DEDENT> if K == 7 : <NEWLINE> <INDENT> print ( 400 ) <NEWLINE> <DEDENT> if K == 8 : <NEWLINE> <INDENT> print ( 624 ) <NEWLINE> <DEDENT> if K == 9 : <NEWLINE> <INDENT> print ( 885 ) <NEWLINE> <DEDENT> if K == 10 : <NEWLINE> <INDENT> print ( 1249 ) <NEWLINE> <DEDENT> if K == 11 : <NEWLINE> <INDENT> print ( 1590 ) <NEWLINE> <DEDENT> if K == 12 : <NEWLINE> <INDENT> print ( 2208 ) <NEWLINE> <DEDENT> if K == 13 : <NEWLINE> <INDENT> print ( 2689 ) <NEWLINE> <DEDENT> if K == 14 : <NEWLINE> <INDENT> print ( 3411 ) <NEWLINE> <DEDENT> if K == 15 : <NEWLINE> <INDENT> print ( 4248 ) <NEWLINE> <DEDENT> if K == 16 : <NEWLINE> <INDENT> print ( 5248 ) <NEWLINE> <DEDENT> if K == 17 : <NEWLINE> <INDENT> print ( 6081 ) <NEWLINE> <DEDENT> if K == 18 : <NEWLINE> <INDENT> print ( 7485 ) <NEWLINE> <DEDENT> if K == 19 : <NEWLINE> <INDENT> print ( 8530 ) <NEWLINE> <DEDENT> if K == 20 : <NEWLINE> <INDENT> print ( 10248 ) <NEWLINE> <DEDENT> if K == 21 : <NEWLINE> <INDENT> print ( 11889 ) <NEWLINE> <DEDENT> if K == 22 : <NEWLINE> <INDENT> print ( 13687 ) <NEWLINE> <DEDENT> if K == 23 : <NEWLINE> <INDENT> print ( 15228 ) <NEWLINE> <DEDENT> if K == 24 : <NEWLINE> <INDENT> print ( 17988 ) <NEWLINE> <DEDENT> if K == 25 : <NEWLINE> <INDENT> print ( 20053 ) <NEWLINE> <DEDENT> if K == 26 : <NEWLINE> <INDENT> print ( 22569 ) <NEWLINE> <DEDENT> if K == 27 : <NEWLINE> <INDENT> print ( 25242 ) <NEWLINE> <DEDENT> if K == 28 : <NEWLINE> <INDENT> print ( 28588 ) <NEWLINE> <DEDENT> if K == 29 : <NEWLINE> <INDENT> print ( 31053 ) <NEWLINE> <DEDENT> if K == 30 : <NEWLINE> <INDENT> print ( 35463 ) <NEWLINE> <DEDENT> if K == 31 : <NEWLINE> <INDENT> print ( 38284 ) <NEWLINE> <DEDENT> if K == 32 : <NEWLINE> <INDENT> print ( 42540 ) <NEWLINE> <DEDENT> if K == 33 : <NEWLINE> <INDENT> print ( 46581 ) <NEWLINE> <DEDENT> if K == 34 : <NEWLINE> <INDENT> print ( 50893 ) <NEWLINE> <DEDENT> if K == 35 : <NEWLINE> <INDENT> print ( 55362 ) <NEWLINE> <DEDENT> if K == 36 : <NEWLINE> <INDENT> print ( 61824 ) <NEWLINE> <DEDENT> if K == 37 : <NEWLINE> <INDENT> print ( 65857 ) <NEWLINE> <DEDENT> if K == 38 : <NEWLINE> <INDENT> print ( 71247 ) <NEWLINE> <DEDENT> if K == 39 : <NEWLINE> <INDENT> print ( 76884 ) <NEWLINE> <DEDENT> if K == 40 : <NEWLINE> <INDENT> print ( 84388 ) <NEWLINE> <DEDENT> if K == 41 : <NEWLINE> <INDENT> print ( 89349 ) <NEWLINE> <DEDENT> if K == 42 : <NEWLINE> <INDENT> print ( 97881 ) <NEWLINE> <DEDENT> if K == 43 : <NEWLINE> <INDENT> print ( 103342 ) <NEWLINE> <DEDENT> if K == 44 : <NEWLINE> <INDENT> print ( 111528 ) <NEWLINE> <DEDENT> if K == 45 : <NEWLINE> <INDENT> print ( 120141 ) <NEWLINE> <DEDENT> if K == 46 : <NEWLINE> <INDENT> print ( 128047 ) <NEWLINE> <DEDENT> if K == 47 : <NEWLINE> <INDENT> print ( 134580 ) <NEWLINE> <DEDENT> if K == 48 : <NEWLINE> <INDENT> print ( 146316 ) <NEWLINE> <DEDENT> if K == 49 : <NEWLINE> <INDENT> print ( 154177 ) <NEWLINE> <DEDENT> if K == 50 : <NEWLINE> <INDENT> print ( 164817 ) <NEWLINE> <DEDENT> if K == 51 : <NEWLINE> <INDENT> print ( 174438 ) <NEWLINE> <DEDENT> if K == 52 : <NEWLINE> <INDENT> print ( 185836 ) <NEWLINE> <DEDENT> if K == 53 : <NEWLINE> <INDENT> print ( 194157 ) <NEWLINE> <DEDENT> if K == 54 : <NEWLINE> <INDENT> print ( 207927 ) <NEWLINE> <DEDENT> if K == 55 : <NEWLINE> <INDENT> print ( 218812 ) <NEWLINE> <DEDENT> if K == 56 : <NEWLINE> <INDENT> print ( 233268 ) <NEWLINE> <DEDENT> if K == 57 : <NEWLINE> <INDENT> print ( 245277 ) <NEWLINE> <DEDENT> if K == 58 : <NEWLINE> <INDENT> print ( 257857 ) <NEWLINE> <DEDENT> if K == 59 : <NEWLINE> <INDENT> print ( 268182 ) <NEWLINE> <DEDENT> if K == 60 : <NEWLINE> <INDENT> print ( 288216 ) <NEWLINE> <DEDENT> if K == 61 : <NEWLINE> <INDENT> print ( 299257 ) <NEWLINE> <DEDENT> if K == 62 : <NEWLINE> <INDENT> print ( 313635 ) <NEWLINE> <DEDENT> if K == 63 : <NEWLINE> <INDENT> print ( 330204 ) <NEWLINE> <DEDENT> if K == 64 : <NEWLINE> <INDENT> print ( 347836 ) <NEWLINE> <DEDENT> if K == 65 : <NEWLINE> <INDENT> print ( 362973 ) <NEWLINE> <DEDENT> if K == 66 : <NEWLINE> <INDENT> print ( 383709 ) <NEWLINE> <DEDENT> if K == 67 : <NEWLINE> <INDENT> print ( 397042 ) <NEWLINE> <DEDENT> if K == 68 : <NEWLINE> <INDENT> print ( 416448 ) <NEWLINE> <DEDENT> if K == 69 : <NEWLINE> <INDENT> print ( 434025 ) <NEWLINE> <DEDENT> if K == 70 : <NEWLINE> <INDENT> print ( 456967 ) <NEWLINE> <DEDENT> if K == 71 : <NEWLINE> <INDENT> print ( 471948 ) <NEWLINE> <DEDENT> if K == 72 : <NEWLINE> <INDENT> print ( 499740 ) <NEWLINE> <DEDENT> if K == 73 : <NEWLINE> <INDENT> print ( 515581 ) <NEWLINE> <DEDENT> if K == 74 : <NEWLINE> <INDENT> print ( 536073 ) <NEWLINE> <DEDENT> if K == 75 : <NEWLINE> <INDENT> print ( 559758 ) <NEWLINE> <DEDENT> if K == 76 : <NEWLINE> <INDENT> print ( 583960 ) <NEWLINE> <DEDENT> if K == 77 : <NEWLINE> <INDENT> print ( 604833 ) <NEWLINE> <DEDENT> if K == 78 : <NEWLINE> <INDENT> print ( 633651 ) <NEWLINE> <DEDENT> if K == 79 : <NEWLINE> <INDENT> print ( 652216 ) <NEWLINE> <DEDENT> if K == 80 : <NEWLINE> <INDENT> print ( 683712 ) <NEWLINE> <DEDENT> if K == 81 : <NEWLINE> <INDENT> print ( 709065 ) <NEWLINE> <DEDENT> if K == 82 : <NEWLINE> <INDENT> print ( 734233 ) <NEWLINE> <DEDENT> if K == 83 : <NEWLINE> <INDENT> print ( 754734 ) <NEWLINE> <DEDENT> if K == 84 : <NEWLINE> <INDENT> print ( 793188 ) <NEWLINE> <DEDENT> if K == 85 : <NEWLINE> <INDENT> print ( 818917 ) <NEWLINE> <DEDENT> if K == 86 : <NEWLINE> <INDENT> print ( 846603 ) <NEWLINE> <DEDENT> if K == 87 : <NEWLINE> <INDENT> print ( 874512 ) <NEWLINE> <DEDENT> if K == 88 : <NEWLINE> <INDENT> print ( 909496 ) <NEWLINE> <DEDENT> if K == 89 : <NEWLINE> <INDENT> print ( 933081 ) <NEWLINE> <DEDENT> if K == 90 : <NEWLINE> <INDENT> print ( 977145 ) <NEWLINE> <DEDENT> if K == 91 : <NEWLINE> <INDENT> print ( 1006126 ) <NEWLINE> <DEDENT> if K == 92 : <NEWLINE> <INDENT> print ( 1041504 ) <NEWLINE> <DEDENT> if K == 93 : <NEWLINE> <INDENT> print ( 1073385 ) <NEWLINE> <DEDENT> if K == 94 : <NEWLINE> <INDENT> print ( 1106467 ) <NEWLINE> <DEDENT> if K == 95 : <NEWLINE> <INDENT> print ( 1138536 ) <NEWLINE> <DEDENT> if K == 96 : <NEWLINE> <INDENT> print ( 1187112 ) <NEWLINE> <DEDENT> if K == 97 : <NEWLINE> <INDENT> print ( 1215145 ) <NEWLINE> <DEDENT> if K == 98 : <NEWLINE> <INDENT> print ( 1255101 ) <NEWLINE> <DEDENT> if K == 99 : <NEWLINE> <INDENT> print ( 1295142 ) <NEWLINE> <DEDENT> if K == 100 : <NEWLINE> <INDENT> print ( 1342852 ) <NEWLINE> <DEDENT> if K == 101 : <NEWLINE> <INDENT> print ( 1373253 ) <NEWLINE> <DEDENT> if K == 102 : <NEWLINE> <INDENT> print ( 1422195 ) <NEWLINE> <DEDENT> if K == 103 : <NEWLINE> <INDENT> print ( 1453816 ) <NEWLINE> <DEDENT> if K == 104 : <NEWLINE> <INDENT> print ( 1502376 ) <NEWLINE> <DEDENT> if K == 105 : <NEWLINE> <INDENT> print ( 1553361 ) <NEWLINE> <DEDENT> if K == 106 : <NEWLINE> <INDENT> print ( 1595437 ) <NEWLINE> <DEDENT> if K == 107 : <NEWLINE> <INDENT> print ( 1629570 ) <NEWLINE> <DEDENT> if K == 108 : <NEWLINE> <INDENT> print ( 1691292 ) <NEWLINE> <DEDENT> if K == 109 : <NEWLINE> <INDENT> print ( 1726717 ) <NEWLINE> <DEDENT> if K == 110 : <NEWLINE> <INDENT> print ( 1782111 ) <NEWLINE> <DEDENT> if K == 111 : <NEWLINE> <INDENT> print ( 1827492 ) <NEWLINE> <DEDENT> if K == 112 : <NEWLINE> <INDENT> print ( 1887772 ) <NEWLINE> <DEDENT> if K == 113 : <NEWLINE> <INDENT> print ( 1925853 ) <NEWLINE> <DEDENT> if K == 114 : <NEWLINE> <INDENT> print ( 1986837 ) <NEWLINE> <DEDENT> if K == 115 : <NEWLINE> <INDENT> print ( 2033674 ) <NEWLINE> <DEDENT> if K == 116 : <NEWLINE> <INDENT> print ( 2089776 ) <NEWLINE> <DEDENT> if K == 117 : <NEWLINE> <INDENT> print ( 2145333 ) <NEWLINE> <DEDENT> if K == 118 : <NEWLINE> <INDENT> print ( 2197483 ) <NEWLINE> <DEDENT> if K == 119 : <NEWLINE> <INDENT> print ( 2246640 ) <NEWLINE> <DEDENT> if K == 120 : <NEWLINE> <INDENT> print ( 2332104 ) <NEWLINE> <DEDENT> if K == 121 : <NEWLINE> <INDENT> print ( 2379085 ) <NEWLINE> <DEDENT> if K == 122 : <NEWLINE> <INDENT> print ( 2434833 ) <NEWLINE> <DEDENT> if K == 123 : <NEWLINE> <INDENT> print ( 2490534 ) <NEWLINE> <DEDENT> if K == 124 : <NEWLINE> <INDENT> print ( 2554600 ) <NEWLINE> <DEDENT> if K == 125 : <NEWLINE> <INDENT> print ( 2609625 ) <NEWLINE> <DEDENT> if K == 126 : <NEWLINE> <INDENT> print ( 2693919 ) <NEWLINE> <DEDENT> if K == 127 : <NEWLINE> <INDENT> print ( 2742052 ) <NEWLINE> <DEDENT> if K == 128 : <NEWLINE> <INDENT> print ( 2813988 ) <NEWLINE> <DEDENT> if K == 129 : <NEWLINE> <INDENT> print ( 2875245 ) <NEWLINE> <DEDENT> if K == 130 : <NEWLINE> <INDENT> print ( 2952085 ) <NEWLINE> <DEDENT> if K == 131 : <NEWLINE> <INDENT> print ( 3003306 ) <NEWLINE> <DEDENT> if K == 132 : <NEWLINE> <INDENT> print ( 3096024 ) <NEWLINE> <DEDENT> if K == 133 : <NEWLINE> <INDENT> print ( 3157249 ) <NEWLINE> <DEDENT> if K == 134 : <NEWLINE> <INDENT> print ( 3224511 ) <NEWLINE> <DEDENT> if K == 135 : <NEWLINE> <INDENT> print ( 3306240 ) <NEWLINE> <DEDENT> if K == 136 : <NEWLINE> <INDENT> print ( 3388576 ) <NEWLINE> <DEDENT> if K == 137 : <NEWLINE> <INDENT> print ( 3444609 ) <NEWLINE> <DEDENT> if K == 138 : <NEWLINE> <INDENT> print ( 3533637 ) <NEWLINE> <DEDENT> if K == 139 : <NEWLINE> <INDENT> print ( 3591322 ) <NEWLINE> <DEDENT> if K == 140 : <NEWLINE> <INDENT> print ( 3693924 ) <NEWLINE> <DEDENT> if K == 141 : <NEWLINE> <INDENT> print ( 3767085 ) <NEWLINE> <DEDENT> if K == 142 : <NEWLINE> <INDENT> print ( 3842623 ) <NEWLINE> <DEDENT> if K == 143 : <NEWLINE> <INDENT> print ( 3912324 ) <NEWLINE> <DEDENT> if K == 144 : <NEWLINE> <INDENT> print ( 4027884 ) <NEWLINE> <DEDENT> if K == 145 : <NEWLINE> <INDENT> print ( 4102093 ) <NEWLINE> <DEDENT> if K == 146 : <NEWLINE> <INDENT> print ( 4181949 ) <NEWLINE> <DEDENT> if K == 147 : <NEWLINE> <INDENT> print ( 4270422 ) <NEWLINE> <DEDENT> if K == 148 : <NEWLINE> <INDENT> print ( 4361548 ) <NEWLINE> <DEDENT> if K == 149 : <NEWLINE> <INDENT> print ( 4427853 ) <NEWLINE> <DEDENT> if K == 150 : <NEWLINE> <INDENT> print ( 4548003 ) <NEWLINE> <DEDENT> if K == 151 : <NEWLINE> <INDENT> print ( 4616104 ) <NEWLINE> <DEDENT> if K == 152 : <NEWLINE> <INDENT> print ( 4718640 ) <NEWLINE> <DEDENT> if K == 153 : <NEWLINE> <INDENT> print ( 4812789 ) <NEWLINE> <DEDENT> if K == 154 : <NEWLINE> <INDENT> print ( 4918561 ) <NEWLINE> <DEDENT> if K == 155 : <NEWLINE> <INDENT> print ( 5003286 ) <NEWLINE> <DEDENT> if K == 156 : <NEWLINE> <INDENT> print ( 5131848 ) <NEWLINE> <DEDENT> if K == 157 : <NEWLINE> <INDENT> print ( 5205481 ) <NEWLINE> <DEDENT> if K == 158 : <NEWLINE> <INDENT> print ( 5299011 ) <NEWLINE> <DEDENT> if K == 159 : <NEWLINE> <INDENT> print ( 5392008 ) <NEWLINE> <DEDENT> if K == 160 : <NEWLINE> <INDENT> print ( 5521384 ) <NEWLINE> <DEDENT> if K == 161 : <NEWLINE> <INDENT> print ( 5610705 ) <NEWLINE> <DEDENT> if K == 162 : <NEWLINE> <INDENT> print ( 5739009 ) <NEWLINE> <DEDENT> if K == 163 : <NEWLINE> <INDENT> print ( 5818390 ) <NEWLINE> <DEDENT> if K == 164 : <NEWLINE> <INDENT> print ( 5930196 ) <NEWLINE> <DEDENT> if K == 165 : <NEWLINE> <INDENT> print ( 6052893 ) <NEWLINE> <DEDENT> if K == 166 : <NEWLINE> <INDENT> print ( 6156139 ) <NEWLINE> <DEDENT> if K == 167 : <NEWLINE> <INDENT> print ( 6239472 ) <NEWLINE> <DEDENT> if K == 168 : <NEWLINE> <INDENT> print ( 6402720 ) <NEWLINE> <DEDENT> if K == 169 : <NEWLINE> <INDENT> print ( 6493681 ) <NEWLINE> <DEDENT> if K == 170 : <NEWLINE> <INDENT> print ( 6623853 ) <NEWLINE> <DEDENT> if K == 171 : <NEWLINE> <INDENT> print ( 6741078 ) <NEWLINE> <DEDENT> if K == 172 : <NEWLINE> <INDENT> print ( 6864016 ) <NEWLINE> <DEDENT> if K == 173 : <NEWLINE> <INDENT> print ( 6953457 ) <NEWLINE> <DEDENT> if K == 174 : <NEWLINE> <INDENT> print ( 7094451 ) <NEWLINE> <DEDENT> if K == 175 : <NEWLINE> <INDENT> print ( 7215016 ) <NEWLINE> <DEDENT> if K == 176 : <NEWLINE> <INDENT> print ( 7359936 ) <NEWLINE> <DEDENT> if K == 177 : <NEWLINE> <INDENT> print ( 7475145 ) <NEWLINE> <DEDENT> if K == 178 : <NEWLINE> <INDENT> print ( 7593865 ) <NEWLINE> <DEDENT> if K == 179 : <NEWLINE> <INDENT> print ( 7689630 ) <NEWLINE> <DEDENT> if K == 180 : <NEWLINE> <INDENT> print ( 7886244 ) <NEWLINE> <DEDENT> if K == 181 : <NEWLINE> <INDENT> print ( 7984165 ) <NEWLINE> <DEDENT> if K == 182 : <NEWLINE> <INDENT> print ( 8130747 ) <NEWLINE> <DEDENT> if K == 183 : <NEWLINE> <INDENT> print ( 8253888 ) <NEWLINE> <DEDENT> if K == 184 : <NEWLINE> <INDENT> print ( 8403448 ) <NEWLINE> <DEDENT> if K == 185 : <NEWLINE> <INDENT> print ( 8523897 ) <NEWLINE> <DEDENT> if K == 186 : <NEWLINE> <INDENT> print ( 8684853 ) <NEWLINE> <DEDENT> if K == 187 : <NEWLINE> <INDENT> print ( 8802826 ) <NEWLINE> <DEDENT> if K == 188 : <NEWLINE> <INDENT> print ( 8949612 ) <NEWLINE> <DEDENT> if K == 189 : <NEWLINE> <INDENT> print ( 9105537 ) <NEWLINE> <DEDENT> if K == 190 : <NEWLINE> <INDENT> print ( 9267595 ) <NEWLINE> <DEDENT> if K == 191 : <NEWLINE> <INDENT> print ( 9376656 ) <NEWLINE> <DEDENT> if K == 192 : <NEWLINE> <INDENT> print ( 9574704 ) <NEWLINE> <DEDENT> if K == 193 : <NEWLINE> <INDENT> print ( 9686065 ) <NEWLINE> <DEDENT> if K == 194 : <NEWLINE> <INDENT> print ( 9827097 ) <NEWLINE> <DEDENT> if K == 195 : <NEWLINE> <INDENT> print ( 9997134 ) <NEWLINE> <DEDENT> if K == 196 : <NEWLINE> <INDENT> print ( 10174780 ) <NEWLINE> <DEDENT> if K == 197 : <NEWLINE> <INDENT> print ( 10290813 ) <NEWLINE> <DEDENT> if K == 198 : <NEWLINE> <INDENT> print ( 10493367 ) <NEWLINE> <DEDENT> if K == 199 : <NEWLINE> <INDENT> print ( 10611772 ) <NEWLINE> <DEDENT> if K == 200 : <NEWLINE> <INDENT> print ( 10813692 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> sp = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i == 0 : continue <NEWLINE> for j in range ( sp , n - 1 ) : <NEWLINE> <INDENT> if a [ j ] != i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sp += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> ans . append ( c ) <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in T : <NEWLINE> <INDENT> T [ i ] = 0 <NEWLINE> <DEDENT> T [ i ] = T [ i ] + 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( T . get ( i , 0 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> c = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> s . sort ( ) <NEWLINE> <NL> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ j - 1 ] != s [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = abs ( 0.5 * ( H * 60 + M ) - 6 * M ) <NEWLINE> <NL> a = math . radians ( s ) <NEWLINE> h = A ** 2 + B ** 2 <NEWLINE> minus = 2 * A * B * math . cos ( a ) <NEWLINE> ans = ( h - minus ) ** ( 1 / 2 ) <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xa = min ( a , k ) <NEWLINE> k -= xa <NEWLINE> xb = min ( b , k ) <NEWLINE> k -= xb <NEWLINE> xc = k <NEWLINE> print ( xa - xc ) <NEWLINE> <NL> <NL>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> trees = [ [ 0 for i in range ( h + 1 ) ] for j in range ( w + 1 ) ] <NEWLINE> dis = [ [ 0 for i in range ( h + 1 ) ] for j in range ( w + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> trees [ x ] [ y ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dis [ i ] [ j ] = trees [ i ] [ j ] + dis [ i - 1 ] [ j ] + dis [ i ] [ j - 1 ] - dis [ i - 1 ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , w - s + 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , h - t + 2 ) : <NEWLINE> <INDENT> num = dis [ i + s - 1 ] [ j + t - 1 ] - dis [ i + s - 1 ] [ j - 1 ] - dis [ i - 1 ] [ j + t - 1 ] + dis [ i - 1 ] [ j - 1 ] <NEWLINE> ans = max ( ans , num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def cal ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> counts = [ [ True for _ in range ( w + 2 ) ] ] + [ [ True ] + [ False ] * w + [ True ] for _ in range ( h ) ] + [ [ True for _ in range ( w + 2 ) ] ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if a [ j ] == <STRING> : <NEWLINE> <INDENT> q . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> counts [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while q : <NEWLINE> <INDENT> x , y , z = q . popleft ( ) <NEWLINE> if not counts [ x + 1 ] [ y ] : <NEWLINE> <INDENT> counts [ x + 1 ] [ y ] = True <NEWLINE> q . append ( [ x + 1 , y , z + 1 ] ) <NEWLINE> <DEDENT> if not counts [ x - 1 ] [ y ] : <NEWLINE> <INDENT> counts [ x - 1 ] [ y ] = True <NEWLINE> q . append ( [ x - 1 , y , z + 1 ] ) <NEWLINE> <DEDENT> if not counts [ x ] [ y + 1 ] : <NEWLINE> <INDENT> counts [ x ] [ y + 1 ] = True <NEWLINE> q . append ( [ x , y + 1 , z + 1 ] ) <NEWLINE> <DEDENT> if not counts [ x ] [ y - 1 ] : <NEWLINE> <INDENT> counts [ x ] [ y - 1 ] = True <NEWLINE> q . append ( [ x , y - 1 , z + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE> <NL> <NL> <DEDENT> cal ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ True for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> d [ b - 1 ] = False <NEWLINE> <DEDENT> elif h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> d [ a - 1 ] = False <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> d [ a - 1 ] = False <NEWLINE> d [ b - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d . count ( True ) ) <NEWLINE>
_ = input ( ) <NEWLINE> val = 1 <NEWLINE> t = 10 ** 18 <NEWLINE> <NL> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> val *= i <NEWLINE> break <NEWLINE> <DEDENT> if val >= t : continue <NEWLINE> val *= i <NEWLINE> <NL> <DEDENT> if val > t : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( val ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> t = list ( s ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> . join ( t ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> H , W = input ( ) . split ( ) <NEWLINE> H = int ( H ) <NEWLINE> W = int ( W ) <NEWLINE> if ( H == W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( H ) : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> res = 0 <NEWLINE> sum = 0 <NEWLINE> c = { } <NEWLINE> c [ 0 ] = 1 <NEWLINE> p = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum = ( sum + int ( s [ i ] ) * p ) % 2019 <NEWLINE> if sum in c : <NEWLINE> <INDENT> res += c [ sum ] <NEWLINE> <DEDENT> p = ( p * 10 ) % 2019 <NEWLINE> c [ sum ] = c . get ( sum , 0 ) + 1 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
from collections import defaultdict <NEWLINE> def E ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> record = defaultdict ( int ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> cur = i - A [ i ] <NEWLINE> count += record [ cur ] <NEWLINE> record [ i + A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> E ( ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = tuple ( float ( n ) for n in input ( ) . split ( ) ) <NEWLINE> D = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print ( <STRING> . format ( D ) ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : <NEWLINE> <INDENT> minimum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left , right = l % 2019 , r % 2019 <NEWLINE> minimum = 2018 ** 2 <NEWLINE> for i in range ( left , right + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , right + 1 ) : <NEWLINE> <INDENT> minimum = min ( minimum , i * j % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> num7 = 7 <NEWLINE> <NL> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if ( num7 % K ) == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num7 = ( num7 * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = ( a * i ) % ( ( 10 ** 9 ) + 7 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> calc = [ 0 for _ in range ( 26 ) ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> day = i + 1 <NEWLINE> calc [ j ] = c [ j ] * ( day - last [ j ] ) <NEWLINE> <DEDENT> min_idx = calc . index ( max ( calc ) ) <NEWLINE> last [ min_idx ] = day <NEWLINE> print ( min_idx + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def isOk ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += ( a - 1 ) // x <NEWLINE> <DEDENT> return cnt <= K <NEWLINE> <NL> <DEDENT> ok = max ( A ) <NEWLINE> ng = 0 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isOk ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
T = str ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in T : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * ( n + 1 ) * n // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
judge = True <NEWLINE> <NL> while judge : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> C = [ ] <NEWLINE> for c_i in c : <NEWLINE> <INDENT> C . append ( c_i ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> left = N - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i >= left : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> for j in reversed ( range ( left + 1 ) ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> if j == i : <NEWLINE> <INDENT> C [ i ] = <STRING> <NEWLINE> left = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j == i - 1 : <NEWLINE> <INDENT> left = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if C [ j ] == <STRING> : <NEWLINE> <INDENT> C [ i ] = <STRING> <NEWLINE> C [ j ] = <STRING> <NEWLINE> left = j <NEWLINE> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> U = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> U -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( U ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> b [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i + 1 ] = 2 * ( b [ i ] - a [ i ] ) <NEWLINE> <NL> <DEDENT> c = [ 0 ] * ( n + 1 ) <NEWLINE> c [ n ] = a [ n ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> c [ n - 1 - j ] = c [ n - j ] + a [ n - 1 - j ] <NEWLINE> <NL> <DEDENT> d = [ 0 ] * ( n + 1 ) <NEWLINE> flag = 0 <NEWLINE> for k in range ( n + 1 ) : <NEWLINE> <INDENT> if b [ k ] < c [ k ] : <NEWLINE> <INDENT> d [ k ] = b [ k ] <NEWLINE> if d [ k ] <= 0 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d [ k ] = c [ k ] <NEWLINE> if d [ k ] <= 0 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = sum ( d ) if flag == 0 else - 1 <NEWLINE> ans = - 1 if n == 0 and a [ 0 ] > 1 else ans <NEWLINE> ans = - 1 if a [ n ] != d [ n ] else ans <NEWLINE> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> ans += c [ i ] * ( c [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans - ( c [ A [ i ] ] - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a . append ( 0 ) <NEWLINE> <NL> l = [ 0 ] * ( n + 2 ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l [ i ] = max ( l [ i - 1 ] , a [ i ] ) <NEWLINE> <NL> <DEDENT> r = [ 0 ] * ( n + 2 ) <NEWLINE> r [ n ] = 0 <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> r [ i ] = max ( r [ i + 1 ] , a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( max ( l [ i - 1 ] , r [ i + 1 ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> memo = [ - 1 ] * n <NEWLINE> <NL> def dp ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if i < 0 : <NEWLINE> <INDENT> return 10 ** 10 <NEWLINE> <DEDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> if i == 1 : <NEWLINE> <INDENT> memo [ i ] = abs ( h [ i ] - h [ i - 1 ] ) <NEWLINE> return memo [ i ] <NEWLINE> <DEDENT> memo [ i ] = min ( dp ( i - 1 ) + abs ( h [ i ] - h [ i - 1 ] ) , dp ( i - 2 ) + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> return memo [ i ] <NEWLINE> <NL> <DEDENT> print ( dp ( n - 1 ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return a <NEWLINE> <DEDENT> def lcm ( c , d ) : return c * d // gcd ( c , d ) <NEWLINE> def div ( x ) : <NEWLINE> <INDENT> num = x <NEWLINE> num -= x // C <NEWLINE> num -= x // D <NEWLINE> num += x // lcm ( C , D ) <NEWLINE> return num <NEWLINE> <DEDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( div ( B ) - div ( A - 1 ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> k = int ( next ( in_ ) ) <NEWLINE> if not k % 2 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> seven = 7 % k <NEWLINE> <NL> for i in range ( 1 , 1000000 ) : <NEWLINE> <INDENT> if not seven : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> i += 1 <NEWLINE> seven = seven * 10 + 7 <NEWLINE> if seven >= k : <NEWLINE> <INDENT> seven %= k <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> <NL> class Polynomial : <NEWLINE> <INDENT> def __init__ ( self , dim = 0 , const = 1 ) : <NEWLINE> <INDENT> self . values = [ ( dim , const ) ] <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return self . values + other . values <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class PolySolver : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . f = np . zeros ( size , np . int64 ) <NEWLINE> self . f [ 0 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> def multiple ( self , polynomial , MOD ) : <COMMENT> <NEWLINE> <INDENT> new_F = np . zeros ( self . size , np . int64 ) <NEWLINE> for dim , const in polynomial : <NEWLINE> <INDENT> if dim != 0 : <NEWLINE> <INDENT> g = np . zeros ( self . size , np . int64 ) <NEWLINE> g [ dim : ] += self . f [ : - dim ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = const * self . f . copy ( ) <NEWLINE> <DEDENT> new_F += g <NEWLINE> <NL> <DEDENT> self . f = new_F <NEWLINE> self . f %= MOD <NEWLINE> <NL> <NL> <DEDENT> def get_coefficient ( self , dim ) : <NEWLINE> <INDENT> return self . f [ dim ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , S = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> poly = PolySolver ( 3010 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> f = Polynomial ( const = 2 ) + Polynomial ( dim = a ) <NEWLINE> poly . multiple ( f , MOD ) <NEWLINE> <NL> <DEDENT> print ( poly . get_coefficient ( S ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> table = [ 1 ] + [ 0 ] * 2020 <NEWLINE> exp = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> exp += [ exp [ - 1 ] * 10 % 2019 ] <NEWLINE> <NL> <DEDENT> curr = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> curr += int ( S [ N - 1 - i ] ) * exp [ i ] <NEWLINE> curr %= 2019 <NEWLINE> table [ curr ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in table : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( A_list ) + 1 <NEWLINE> cnt = [ 0 for _ in range ( M ) ] <NEWLINE> <NL> for i in A_list : <NEWLINE> <INDENT> if cnt [ i ] != 0 : <NEWLINE> <INDENT> cnt [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i , M , i ) : cnt [ j ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in A_list : <NEWLINE> <INDENT> if cnt [ k ] == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A = input ( ) [ : : - 1 ] <NEWLINE> A = <STRING> + A <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> S = [ 0 ] * len ( A ) <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> <NL> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> S [ i + 1 ] = ( S [ i ] + int ( A [ i + 1 ] ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> cnt [ S [ i + 1 ] % 2019 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = [ ] <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if s + i <= k : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> s += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> a = tmp <NEWLINE> tmp = [ ] <NEWLINE> s = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if s + i <= k : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> s += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> b = tmp <NEWLINE> line = b [ : : - 1 ] + a <NEWLINE> <NL> ans = 0 <NEWLINE> right = 0 <NEWLINE> sum_ = 0 <NEWLINE> for left in range ( len ( line ) ) : <NEWLINE> <INDENT> while right < len ( line ) and sum_ + line [ right ] <= k : <NEWLINE> <INDENT> sum_ += line [ right ] <NEWLINE> right += 1 <NEWLINE> <DEDENT> l = right - left <NEWLINE> if l > ans : <NEWLINE> <INDENT> ans = l <NEWLINE> <NL> <DEDENT> if right == left : right += 1 <NEWLINE> else : sum_ -= line [ left ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> inp = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 1 ; <NEWLINE> for i in range ( inp ) : <NEWLINE> <INDENT> num *= lst [ i ] <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def calc_minkowski_distance ( data_x , data_y , types ) : <NEWLINE> <COMMENT> <NL> <INDENT> distance = list ( map ( lambda x , y : abs ( x - y ) , data_x , data_y ) ) <NEWLINE> <NL> results = [ ] <NEWLINE> for t in types : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> results . append ( max ( distance ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = map ( lambda x : math . pow ( x , t ) , distance ) <NEWLINE> total = sum ( temp ) <NEWLINE> results . append ( math . pow ( total , 1.0 / t ) ) <NEWLINE> <DEDENT> <DEDENT> return results <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> data_x = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> data_y = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> types = [ 1 , 2 , 3 , <STRING> ] <COMMENT> <NEWLINE> results = calc_minkowski_distance ( data_x , data_y , types ) <NEWLINE> <NL> <COMMENT> <NL> for r in results : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> road = { k : [ ] for k in range ( 1 , n + 1 ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a ] . append ( b ) <NEWLINE> road [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> next_visited = [ 1 ] <NEWLINE> visited = { 1 : None } <NEWLINE> temp_next = [ ] <NEWLINE> <NL> visit_num = { } <NEWLINE> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> temp_next = [ ] <NEWLINE> for room in next_visited : <NEWLINE> <INDENT> ava_room = road [ room ] <NEWLINE> for r in ava_room : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> visited [ r ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> visit_num [ r ] = room <NEWLINE> temp_next . append ( r ) <NEWLINE> visited [ r ] = None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if temp_next == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> next_visited = temp_next <NEWLINE> <NL> <DEDENT> if len ( visit_num ) != n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for v in sorted ( visit_num . items ( ) ) : <NEWLINE> <INDENT> print ( v [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> arr = factorization ( N ) <NEWLINE> <NL> min_nums = [ 1 ] <NEWLINE> num_lists = [ 1 ] <NEWLINE> num_dic = { 1 : 1 } <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for Z in arr : <NEWLINE> <INDENT> o = Z [ 1 ] <NEWLINE> for i , num in enumerate ( num_lists ) : <NEWLINE> <INDENT> if num > o : <NEWLINE> <INDENT> ans += num_dic [ num_lists [ i - 1 ] ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if num <= o : <NEWLINE> <INDENT> o = o - num <NEWLINE> _ans = len ( min_nums ) <NEWLINE> n = min_nums [ - 1 ] + 1 <NEWLINE> while o >= n : <NEWLINE> <INDENT> o -= n <NEWLINE> min_nums . append ( n ) <NEWLINE> _ans += 1 <NEWLINE> num_lists . append ( n + num_lists [ - 1 ] ) <NEWLINE> num_dic [ num_lists [ - 1 ] ] = _ans <NEWLINE> n += 1 <NEWLINE> <DEDENT> ans += _ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_lst = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for num in a : <NEWLINE> <INDENT> a_lst [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for X in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> if X == 0 : <NEWLINE> <INDENT> cnt += a_lst [ X ] <NEWLINE> cnt += a_lst [ X + 1 ] <NEWLINE> <DEDENT> elif X == 10 ** 5 : <NEWLINE> <INDENT> cnt += a_lst [ X - 1 ] <NEWLINE> cnt += a_lst [ X ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += a_lst [ X - 1 ] <NEWLINE> cnt += a_lst [ X ] <NEWLINE> cnt += a_lst [ X + 1 ] <NEWLINE> <NL> <DEDENT> if cnt > ans : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> ca = n - bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += aa * ca <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> nu = 0 <NEWLINE> for i in range ( 1 , X ) : <NEWLINE> <INDENT> if i == li [ nu ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> nu += 1 <NEWLINE> <DEDENT> if nu == len ( li ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> b = len ( li ) - a <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> B , C = [ list ( i ) for i in zip ( * BC ) ] <NEWLINE> <NL> sum = 0 <NEWLINE> size = 10 ** 5 + 1 <NEWLINE> list = [ 0 ] * size <NEWLINE> for a in A : <NEWLINE> <INDENT> list [ a ] += 1 <NEWLINE> sum += a <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> sum = sum + C [ i ] * list [ B [ i ] ] - B [ i ] * list [ B [ i ] ] <NEWLINE> list [ C [ i ] ] += list [ B [ i ] ] <NEWLINE> list [ B [ i ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq as h <NEWLINE> <NL> inf = sys . maxsize <NEWLINE> <NL> class heapq : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . q = [ ] <NEWLINE> <NL> <DEDENT> def push ( self , v ) : <NEWLINE> <INDENT> h . heappush ( self . q , v ) <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> return h . heappop ( self . q ) <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return len ( self . q ) == 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def shortestPath0 ( graph , s ) : <NEWLINE> <INDENT> n = len ( graph ) <NEWLINE> <NL> dist = [ inf for _ in range ( n ) ] <NEWLINE> visited = [ False for _ in range ( n ) ] <NEWLINE> dist [ s ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> idx , u = - 1 , inf <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] and dist [ i ] < u : <NEWLINE> <INDENT> idx = i <NEWLINE> u = dist [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if u == inf : break <NEWLINE> <NL> visited [ idx ] = True <NEWLINE> <NL> for ( next , w ) in graph [ idx ] : <NEWLINE> <INDENT> newdist = w + dist [ idx ] <NEWLINE> if newdist < dist [ next ] : <NEWLINE> <INDENT> dist [ next ] = newdist <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> def shortestPath1 ( graph , s ) : <NEWLINE> <INDENT> n = len ( graph ) <NEWLINE> <NL> dist = [ inf for _ in range ( n ) ] <NEWLINE> visited = [ False for _ in range ( n ) ] <NEWLINE> <NL> q = heapq ( ) <NEWLINE> q . push ( ( 0 , s ) ) <NEWLINE> <NL> while not q . is_empty ( ) : <NEWLINE> <INDENT> ( cur_dist , v ) = q . pop ( ) <NEWLINE> <NL> if visited [ v ] or dist [ v ] <= cur_dist : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dist [ v ] = cur_dist <NEWLINE> visited [ v ] = True <NEWLINE> <NL> for next , w in graph [ v ] : <NEWLINE> <INDENT> if not visited [ next ] and dist [ v ] + w < dist [ next ] : <NEWLINE> <INDENT> q . push ( ( dist [ v ] + w , next ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> v , e , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> graph = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> a , b , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , cost ) ) <NEWLINE> <NL> <DEDENT> c_dist = shortestPath1 ( graph , s ) <NEWLINE> <NL> for d in c_dist : <NEWLINE> <INDENT> if d == inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> r = a % b <NEWLINE> a = b <NEWLINE> b = r <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> gcd_ab = [ gcd ( a , b ) for a in range ( 1 , K + 1 ) for b in range ( 1 , K + 1 ) ] <NEWLINE> gcd_abc = [ gcd ( a_b , c ) for a_b in gcd_ab for c in range ( 1 , K + 1 ) ] <NEWLINE> print ( sum ( gcd_abc ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> print ( <STRING> * W + <STRING> + ( <STRING> + <STRING> * ( W - 2 ) + <STRING> + <STRING> ) * ( H - 2 ) + <STRING> * W + <STRING> ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ap = [ a for a in A if a > 0 ] <NEWLINE> Am = [ a for a in A if a < 0 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if len ( Ap ) + len ( Am ) < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( Ap ) + len ( Am ) == K : <NEWLINE> <INDENT> if 0 in A and len ( Am ) % 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda a , b : a * b % mod , Ap + Am , 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> Ap . sort ( reverse = True ) <NEWLINE> Am . sort ( ) <NEWLINE> if len ( Ap ) == 0 : <NEWLINE> <INDENT> if K % 2 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda a , b : a * b % mod , Am [ - K : ] , 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = reduce ( lambda a , b : a * b % mod , Am [ : K ] , 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> idx_Am = 0 <NEWLINE> n = 0 <NEWLINE> ans = 1 <NEWLINE> for idx_Ap , ap in enumerate ( Ap + [ 0 ] ) : <NEWLINE> <INDENT> while idx_Am < len ( Am ) and n < K and - Am [ idx_Am ] > ap : <NEWLINE> <INDENT> ans = ans * Am [ idx_Am ] % mod <NEWLINE> idx_Am += 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> if n == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> idx_Ap += 1 <NEWLINE> ans = ans * ap % mod <NEWLINE> if n == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> assert False <NEWLINE> <DEDENT> if idx_Am % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if idx_Ap == len ( Ap ) or ( idx_Am != len ( Am ) and idx_Ap > 0 and Am [ idx_Am ] * Am [ idx_Am - 1 ] > Ap [ idx_Ap ] * Ap [ idx_Ap - 1 ] ) : <NEWLINE> <INDENT> ans = ans * Am [ idx_Am ] * pow ( Ap [ idx_Ap - 1 ] , mod - 2 , mod ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * Ap [ idx_Ap ] * pow ( Am [ idx_Am - 1 ] , mod - 2 , mod ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if t % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> t = ( t * 10 + 7 ) % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_cd = math . gcd ( c , b ) <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> gcd_abc = math . gcd ( a , gcd_cd ) <NEWLINE> res += gcd_abc <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> c = { } <NEWLINE> t = 0 <NEWLINE> MOD = 1000000007 <NEWLINE> for x in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> q = k // x <NEWLINE> c [ x ] = pow ( q , n , MOD ) - sum ( c [ x * y ] for y in range ( 2 , q + 1 ) ) <NEWLINE> t += c [ x ] * x <NEWLINE> t = t % 1000000007 <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> H2 = copy . copy ( H ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> H2 [ B - 1 ] = False <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> H2 [ A - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H2 [ A - 1 ] = False <NEWLINE> H2 [ B - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> H3 = H2 . count ( False ) <NEWLINE> <NL> print ( len ( H ) - H3 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> y = y ^ a <NEWLINE> <DEDENT> for a in a_list : <NEWLINE> <INDENT> x = y ^ a <NEWLINE> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( - 1 , - n , - 1 ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i - 1 ] ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mtable = [ None ] * N <NEWLINE> cs = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = aa . pop ( 0 ) <NEWLINE> cs . append ( c ) <NEWLINE> ms = aa <NEWLINE> mtable [ n ] = ms <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> idxes = list ( range ( N ) ) <NEWLINE> <NL> prices = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for c in combinations ( idxes , i ) : <NEWLINE> <INDENT> sums = [ 0 ] * M <NEWLINE> for idx in c : <NEWLINE> <INDENT> for i , m in enumerate ( mtable [ idx ] ) : <NEWLINE> <INDENT> sums [ i ] += m <NEWLINE> <DEDENT> <DEDENT> if all ( map ( lambda x : x >= X , sums ) ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> for idx in c : <NEWLINE> <INDENT> price += cs [ idx ] <NEWLINE> <NL> <DEDENT> prices . append ( price ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if prices == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( prices ) ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> from itertools import accumulate , chain <NEWLINE> n , * s = open ( 0 ) . read ( ) . split ( ) <NEWLINE> t = [ 2 * ( i . count ( <STRING> ) ) - len ( i ) for i in s ] <NEWLINE> if sum ( t ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> st = [ [ t_ , min ( accumulate ( s_ , lambda a , b : a + ( 1 if b == <STRING> else - 1 ) , initial = 0 ) ) ] for s_ , t_ in zip ( s , t ) ] <NEWLINE> <NL> now = sum ( map ( lambda x : x [ 0 ] , filter ( lambda x : x [ 1 ] >= 0 , st ) ) ) <NEWLINE> v = list ( filter ( lambda x : x [ 1 ] < 0 and x [ 0 ] >= 0 , st ) ) <NEWLINE> w = list ( filter ( lambda x : x [ 1 ] < 0 and x [ 0 ] < 0 , st ) ) <NEWLINE> v . sort ( reverse = True , key = lambda z : z [ 1 ] ) <NEWLINE> w . sort ( key = lambda z : z [ 0 ] - z [ 1 ] , reverse = True ) <NEWLINE> <NL> for sub in chain ( v , w ) : <NEWLINE> <INDENT> if now + sub [ 1 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) ; exit ( ) <NEWLINE> <DEDENT> now += sub [ 0 ] <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 7 <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> mod_num = num % K <NEWLINE> if mod_num == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> num = mod_num * 10 + 7 <NEWLINE> <DEDENT> <DEDENT>
sx , sy , tx , ty = map ( int , input ( ) . split ( ) ) <NEWLINE> dy = ty - sy <NEWLINE> dx = tx - sx <NEWLINE> ans = dy * <STRING> + dx * <STRING> + dy * <STRING> + dx * <STRING> <NEWLINE> ans += <STRING> + ( dy + 1 ) * <STRING> + ( dx + 1 ) * <STRING> + <STRING> <NEWLINE> ans += <STRING> + ( dy + 1 ) * <STRING> + ( dx + 1 ) * <STRING> + <STRING> <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> total += 1 * K * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> total += 1 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( total ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = input ( ) . split ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = input ( ) . split ( ) <NEWLINE> ta = 0 <NEWLINE> cnta = 0 <NEWLINE> while int ( cnta ) < int ( n ) and ta + int ( a [ cnta ] ) <= int ( k ) : <NEWLINE> <INDENT> ta = ta + int ( a [ cnta ] ) <NEWLINE> cnta = cnta + 1 <NEWLINE> <DEDENT> tb = 0 <NEWLINE> cntb = 0 <NEWLINE> while cntb < int ( m ) and ta + tb + int ( b [ cntb ] ) <= int ( k ) : <NEWLINE> <INDENT> tb = tb + int ( b [ cntb ] ) <NEWLINE> cntb = cntb + 1 <NEWLINE> <DEDENT> ans = cnta + cntb <NEWLINE> <NL> while cnta - 1 >= 0 : <NEWLINE> <INDENT> ta = ta - int ( a [ cnta - 1 ] ) <NEWLINE> cnta = cnta - 1 <NEWLINE> while cntb < int ( m ) and ta + tb + int ( b [ cntb ] ) <= int ( k ) : <NEWLINE> <INDENT> tb = tb + int ( b [ cntb ] ) <NEWLINE> cntb = cntb + 1 <NEWLINE> <DEDENT> ans = max ( ans , cnta + cntb ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> mods = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> mods [ i ] = ( int ( S [ i ] ) * pow ( 10 , N - i - 1 , P ) + mods [ i + 1 ] ) % P <NEWLINE> <DEDENT> c = dict ( ) <NEWLINE> for m in mods : <NEWLINE> <INDENT> c [ m ] = c . get ( m , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> if P == 2 or P == 5 : <NEWLINE> <INDENT> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> s = int ( s ) <NEWLINE> if s % P == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> c [ mods [ i ] ] -= 1 <NEWLINE> ans += c [ mods [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mod = 2019 <NEWLINE> L = [ 0 ] * mod <NEWLINE> n = 0 <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> n += int ( S [ i ] ) * pow ( 10 , len ( S ) - i - 1 , mod ) <NEWLINE> n %= mod <NEWLINE> L [ n ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> L [ 0 ] += 1 <NEWLINE> for l in L : <NEWLINE> <INDENT> ans += l * ( l - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> print ( 15 - sum ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> count_dict = { s : 0 for s in range ( 1 , n + 1 ) } <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> seikaisha = int ( input ( ) ) <NEWLINE> if seikaisha in count_dict : <NEWLINE> <INDENT> count_dict [ seikaisha ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_dict [ seikaisha ] = 0 <NEWLINE> <DEDENT> <DEDENT> count_dict_sorted = sorted ( count_dict . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i , j in count_dict_sorted : <NEWLINE> <INDENT> if k + j - q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
input ( ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> if 0 in lis : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> s = s * lis [ i ] <NEWLINE> if s > 1000000000000000000 : print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> b = b * a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> a , b , n = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> ans = math . floor ( a * min ( n , b - 1 ) / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> sc = list ( reversed ( c ) ) <NEWLINE> ans = 0 <NEWLINE> r = 0 <NEWLINE> flg = False <NEWLINE> <NL> if <STRING> not in set ( c ) or <STRING> not in set ( c ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( r , n ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> if sc [ j ] == <STRING> : <NEWLINE> <INDENT> if n >= i + j + 2 : <NEWLINE> <INDENT> c [ i ] = <STRING> <NEWLINE> c [ - 1 * j - 1 ] = <STRING> <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> output = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li = input ( ) . split ( <STRING> ) <NEWLINE> if ( li [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> output . appendleft ( li [ 1 ] ) <NEWLINE> <DEDENT> elif ( li [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> output . popleft ( ) <NEWLINE> <DEDENT> elif ( li [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> output . pop ( ) <NEWLINE> <DEDENT> elif ( li [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> output . remove ( li [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> <DEDENT> M = len ( factorization ( N ) ) <NEWLINE> num = [ 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ j ] <= factorization ( N ) [ i ] [ 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import fractions <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> n = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> cnt = [ 0 ] * n <NEWLINE> <NL> sa = set ( A ) <NEWLINE> csa = Counter ( A ) <NEWLINE> <NL> for v in sa : <NEWLINE> <INDENT> if cnt [ v - 1 ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ v - 1 ] = csa [ v ] <NEWLINE> <NL> <DEDENT> for c in cnt : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> from dataclasses import * <NEWLINE> @ dataclass <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , pin ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , pin ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> uf . union ( A , B ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( j ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL>
n = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> ans = <STRING> <NEWLINE> while n >= 1 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> zeros = [ 0 for i in range ( 10050 ) ] <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n < 10050 : <NEWLINE> <INDENT> zeros [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( zeros [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> R = [ 0 ] * N <NEWLINE> for i , m in enumerate ( M ) : <NEWLINE> <INDENT> if i + m >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L [ i + m ] += 1 <NEWLINE> <DEDENT> for i , m in enumerate ( M [ : : - 1 ] ) : <NEWLINE> <INDENT> if i + m >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> R [ i + m ] += 1 <NEWLINE> <DEDENT> R = R [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( sum ( [ l * r for l , r in zip ( L , R ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> num = math . factorial ( n ) <NEWLINE> dic = { } <NEWLINE> i = 2 <NEWLINE> ans = 1 <NEWLINE> while num != 1 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while num % i == 0 : <NEWLINE> <INDENT> num = num // i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans = ans * cnt <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> i = 0 ; p = 0 ; q = 0 <NEWLINE> while i != len ( S ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> q = i <NEWLINE> if K < i + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : r += 1 <NEWLINE> elif s == <STRING> : g += 1 <NEWLINE> else : b += 1 <NEWLINE> <NL> <NL> <DEDENT> ng = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : continue <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> ng += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> print ( ans - ng ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> def dfs ( x , y , sym ) : <NEWLINE> <INDENT> tile [ x ] [ y ] = <STRING> <NEWLINE> for i in range ( len ( DX ) ) : <NEWLINE> <INDENT> nx = x + DX [ i ] <NEWLINE> ny = y + DY [ i ] <NEWLINE> if ( 0 <= nx and nx < N and 0 <= ny and ny < M and tile [ nx ] [ ny ] is sym ) : <NEWLINE> <INDENT> dfs ( nx , ny , sym ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> sym = tile [ i ] [ j ] <NEWLINE> if tile [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> if tile [ i ] [ j ] is sym : <NEWLINE> <INDENT> dfs ( i , j , sym ) <NEWLINE> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> DX = [ - 1 , 0 , 1 , 0 ] <NEWLINE> DY = [ 0 , - 1 , 0 , 1 ] <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> nums = line . split ( <STRING> ) <NEWLINE> N = int ( nums [ 0 ] ) <NEWLINE> M = int ( nums [ 1 ] ) <NEWLINE> tile = [ [ 0 for i in range ( M ) ] for j in range ( N ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tile [ counter - 1 ] = list ( line ) <NEWLINE> <DEDENT> if N is 0 and M is 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> counter += 1 <NEWLINE> if counter - 1 is N : <NEWLINE> <INDENT> solve ( ) <NEWLINE> counter = 0 <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> <NL> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = s [ 0 ] <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = s [ 0 ] <NEWLINE> num = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> ans += i <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = s [ 0 ] <NEWLINE> b = s [ 1 ] <NEWLINE> ans = ans - a * num [ a ] - b * num [ b ] <NEWLINE> num [ b ] = num [ a ] + num [ b ] <NEWLINE> ans = ans + b * num [ b ] <NEWLINE> num [ a ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = j - i + j <NEWLINE> if k > n - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] == s [ k ] or s [ j ] == s [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
w = str ( input ( ) ) <NEWLINE> <NL> length = len ( w ) <NEWLINE> z = sorted ( w ) <NEWLINE> i = 1 <NEWLINE> m = 0 <NEWLINE> <NL> if length % 2 == 1 : <NEWLINE> <INDENT> m = 1 <NEWLINE> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i < length : <NEWLINE> <INDENT> if z [ i ] == z [ i - 1 ] : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> row = str ( input ( ) ) <NEWLINE> table . append ( row ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for maskR in range ( 1 << h ) : <NEWLINE> <INDENT> for maskC in range ( 1 << w ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( ( maskR >> i ) & 1 ) == 0 and ( ( maskC >> j ) & 1 ) == 0 and table [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black = black + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == k : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> maxp = 10 ** 18 <NEWLINE> overFlag = False <NEWLINE> if 0 in a : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> p *= a [ i ] <NEWLINE> if p > maxp : <NEWLINE> <INDENT> overFlag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if overFlag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
count = int ( input ( ) ) <NEWLINE> list = input ( ) . split ( <STRING> ) <NEWLINE> state = False <NEWLINE> i = 0 <NEWLINE> num = int ( list [ i ] ) <NEWLINE> i += 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> if <STRING> in list : <NEWLINE> <INDENT> num = 0 <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> while i < count : <NEWLINE> <INDENT> num = num * int ( list [ i ] ) <NEWLINE> <NL> if num > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> state = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if not state : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <STRING> <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i < n - 1 and p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i + 1 ] = p [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif i == n - 1 and p [ i ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> print ( <STRING> * W ) <NEWLINE> print ( ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) * ( H - 2 ) , end = <STRING> ) <NEWLINE> print ( <STRING> * W + <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = set ( k for k in range ( 0 , N ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> f , g = map ( int , input ( ) . split ( ) ) <NEWLINE> x = f - 1 <NEWLINE> y = g - 1 <NEWLINE> if H [ x ] <= H [ y ] : <NEWLINE> <INDENT> S . discard ( x ) <NEWLINE> <DEDENT> if H [ x ] >= H [ y ] : <NEWLINE> <INDENT> S . discard ( y ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( S ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> soinsu = [ ] <NEWLINE> <NL> c = n <NEWLINE> if ( c % 2 == 0 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> soinsu . append ( 2 ) <NEWLINE> c = c // 2 <NEWLINE> if ( c % 2 != 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> len = int ( math . sqrt ( c ) ) + 1 <NEWLINE> for i in range ( 3 , len , 2 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if ( c % i != 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> soinsu . append ( i ) <NEWLINE> c = c // i <NEWLINE> <DEDENT> if ( c == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( c != 1 ) : <NEWLINE> <INDENT> soinsu . append ( c ) <NEWLINE> <NL> <DEDENT> print ( n , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> for i in soinsu : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> X = [ 0 ] * ( 10 ** 5 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> <NL> for j in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = X [ b - 1 ] <NEWLINE> X [ b - 1 ] = 0 <NEWLINE> X [ c - 1 ] += a <NEWLINE> ans = ans - a * b + c * a <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = S [ : : - 1 ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for v in range ( 1000 ) : <NEWLINE> <INDENT> V = str ( v ) . zfill ( 3 ) <NEWLINE> right = - 1 <NEWLINE> left = - 1 <NEWLINE> if V [ 2 ] in R : <NEWLINE> <INDENT> r = R . index ( V [ 2 ] ) + 1 <NEWLINE> right = N - r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if V [ 0 ] in S : <NEWLINE> <INDENT> left = S . index ( V [ 0 ] ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if V [ 1 ] in S [ left : right ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> connect_list = [ set ( ) for _ in range ( N ) ] <COMMENT> <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> connect_list [ A - 1 ] . add ( B ) <NEWLINE> connect_list [ B - 1 ] . add ( A ) <NEWLINE> <NL> <DEDENT> root_list = [ 0 ] * N <NEWLINE> root_list [ 0 ] = <STRING> <NEWLINE> <NL> for i in list ( connect_list [ 0 ] ) : <NEWLINE> <INDENT> root_list [ i - 1 ] = 1 <NEWLINE> <DEDENT> now_set = connect_list [ 0 ] <NEWLINE> <NL> def do_ranking ( now_set ) : <NEWLINE> <INDENT> global connect_list , root_list <NEWLINE> if len ( now_set ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for j in list ( now_set ) : <NEWLINE> <INDENT> for m in list ( connect_list [ j - 1 ] ) : <NEWLINE> <INDENT> if root_list [ m - 1 ] == 0 : <NEWLINE> <INDENT> root_list [ m - 1 ] = j <NEWLINE> now_set . add ( m ) <NEWLINE> <DEDENT> <DEDENT> now_set . remove ( j ) <NEWLINE> <DEDENT> do_ranking ( now_set ) <NEWLINE> <NL> <NL> <DEDENT> do_ranking ( now_set ) <COMMENT> <NEWLINE> <NL> for k in root_list : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
import sys <NEWLINE> prime = [ 0 ] <NEWLINE> isPrime = [ 1 for i in range ( 1000000 ) ] <NEWLINE> isPrime [ 0 ] = 0 <NEWLINE> isPrime [ 1 ] = 0 <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> n = int ( i ) <NEWLINE> if prime [ len ( prime ) - 1 ] < n : <NEWLINE> <INDENT> for i in range ( prime [ len ( prime ) - 1 ] + 1 , n + 1 ) : <NEWLINE> <INDENT> if isPrime [ i ] == 1 : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> for j in range ( i * 2 , 1000000 , i ) : <NEWLINE> <INDENT> isPrime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( isPrime [ : n + 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return { i for i in range ( self . n ) if self . find ( i ) == root } <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> block = [ 0 ] * n <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> block [ a - 1 ] += 1 <NEWLINE> block [ b - 1 ] += 1 <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> uf . find ( 0 ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if uf . same ( c - 1 , d - 1 ) : <NEWLINE> <INDENT> block [ c - 1 ] += 1 <NEWLINE> block [ d - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ uf . size ( i ) - block [ i ] - 1 for i in range ( n ) ] <NEWLINE> print ( * ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( c ) for c in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> c1 , c2 , c3 = [ 0 , 0 , 0 ] <NEWLINE> ma = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if a [ i ] == a [ i - 1 ] + 1 : <NEWLINE> <INDENT> c1 = c2 <NEWLINE> c2 = c3 <NEWLINE> c3 = i <NEWLINE> <DEDENT> elif a [ i ] != a [ i - 1 ] : <NEWLINE> <INDENT> c1 , c2 , c3 = [ i , i , i ] <NEWLINE> <DEDENT> <DEDENT> if ma < i - c1 + 1 : <NEWLINE> <INDENT> ma = i - c1 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> aa = sorted ( a . copy ( ) ) <NEWLINE> mx , sd = aa [ n - 1 ] , aa [ n - 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( mx if i < mx else sd ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = 1 <NEWLINE> r_min = 10 ** 5 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = max ( l , l_max ) <NEWLINE> r_min = min ( r , r_min ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , r_min - l_max + 1 ) ) <NEWLINE> <NL> <NL> <NL>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = len ( A ) <NEWLINE> Adel = list ( set ( A ) ) <NEWLINE> ans = len ( Adel ) - k <NEWLINE> <COMMENT> <NL> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> newA = collections . Counter ( A ) <NEWLINE> count = list ( newA . values ( ) ) <NEWLINE> count . sort ( ) <NEWLINE> <COMMENT> <NL> ans = sum ( count [ : - k ] ) <NEWLINE> print ( ans ) <NEWLINE>
M = 998244353 <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p , c = [ m ] * n , [ 1 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p [ i ] = p [ i - 1 ] * ( m - 1 ) % M <NEWLINE> c [ i ] = c [ i - 1 ] * ( n - i ) * pow ( i , M - 2 , M ) % M <NEWLINE> <DEDENT> print ( sum ( p [ n - i - 1 ] * c [ i ] % M for i in range ( k + 1 ) ) % M ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> c1 = x . count ( <STRING> ) <NEWLINE> if c1 > 1 : <NEWLINE> <INDENT> cc1 = int ( <STRING> + x , 0 ) % ( c1 - 1 ) <NEWLINE> <DEDENT> cc2 = int ( <STRING> + x , 0 ) % ( c1 + 1 ) <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> n = n % bin ( n ) . count ( <STRING> ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if c1 == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( ( pow ( 2 , n - i - 1 , c1 + 1 ) + cc2 ) % ( c1 + 1 ) ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( f ( ( - pow ( 2 , n - i - 1 , c1 - 1 ) + cc1 ) % ( c1 - 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( ( pow ( 2 , n - i - 1 , c1 + 1 ) + cc2 ) % ( c1 + 1 ) ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( i ) - a for i in input ( ) . split ( ) ] <NEWLINE> <NL> dp = { 0 : 1 } <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> tmp = list ( dp . items ( ) ) <NEWLINE> for key , value in tmp : <NEWLINE> <INDENT> dp [ key + i ] = dp . get ( key + i , 0 ) + value <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] - 1 ) <NEWLINE> <NL> <NL>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sub_gcd = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( sub_gcd , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f_max = 0 <NEWLINE> if n >= b - 1 : <NEWLINE> <INDENT> f_max = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f_max = n <NEWLINE> <DEDENT> print ( math . floor ( a * f_max / b ) - a * math . floor ( f_max / b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A += a <NEWLINE> <DEDENT> A_ = set ( A ) <NEWLINE> print ( n - len ( A_ ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a5 = pow ( a , 5 ) <NEWLINE> b5 = pow ( b , 5 ) <NEWLINE> if ( a5 - b5 == x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> break <NEWLINE> <DEDENT> if ( a5 + b5 == x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a , - b ) ) <NEWLINE> break <NEWLINE> <DEDENT> if ( - a5 - b5 == x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( - a , b ) ) <NEWLINE> break <NEWLINE> <DEDENT> if ( - a5 + b5 == x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( - a , - b ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> b += 1 <NEWLINE> if ( a == b - 1 ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> b = 0 <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> val = g . get ( s , [ ] ) <NEWLINE> val . append ( t ) <NEWLINE> g [ s ] = val <NEWLINE> val = g . get ( t , [ ] ) <NEWLINE> val . append ( s ) <NEWLINE> g [ t ] = val <NEWLINE> <NL> <DEDENT> color = 1 <NEWLINE> done = [ - 1 ] + [ - 1 ] * n <NEWLINE> <NL> def dfs ( g , s ) : <NEWLINE> <INDENT> done [ s ] = color <NEWLINE> stack = [ s ] <NEWLINE> while stack != [ ] : <NEWLINE> <INDENT> t = stack . pop ( ) <NEWLINE> <NL> for c in g . get ( t , [ ] ) : <NEWLINE> <INDENT> if done [ c ] == - 1 : <NEWLINE> <INDENT> done [ c ] = color <NEWLINE> stack . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if done [ v ] == - 1 : <NEWLINE> <INDENT> dfs ( g , v ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if done [ s ] == done [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
data = <STRING> <NEWLINE> count = 1 <NEWLINE> end = True <NEWLINE> while end : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> if data == 0 : <NEWLINE> <INDENT> end = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , str ( count ) + <STRING> , data ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> s = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> s += line . lower ( ) <NEWLINE> <DEDENT> A = <STRING> <NEWLINE> for c in A : <NEWLINE> <INDENT> print ( c + <STRING> . format ( s . count ( c ) ) ) <NEWLINE> <DEDENT>
N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> x = 1 <NEWLINE> C = [ None ] * N <NEWLINE> C [ 0 ] = 0 <NEWLINE> c = 0 <NEWLINE> while c < K : <NEWLINE> <INDENT> x = A [ x - 1 ] <NEWLINE> c += 1 <NEWLINE> if C [ x - 1 ] is None : <NEWLINE> <INDENT> C [ x - 1 ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = C [ x - 1 ] <NEWLINE> b = c - a <NEWLINE> K = ( K - a ) % b + a + b <NEWLINE> while c < K : <NEWLINE> <INDENT> x = A [ x - 1 ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> mod_lst = [ 0 ] * mod <NEWLINE> mod_lst [ 0 ] = 1 <NEWLINE> x = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> x += int ( i ) * t <NEWLINE> y = x % mod <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> mod_lst [ y ] += 1 <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for j in mod_lst : <NEWLINE> <INDENT> a = j * ( j - 1 ) // 2 <NEWLINE> count += a <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> reject = 0 <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> if ans >= N : <NEWLINE> <INDENT> reject = ans - N <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if j != reject : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> a = [ 0 ] * 2019 <NEWLINE> a [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> mod = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> k = ( k + int ( s [ i ] ) * mod ) % 2019 <NEWLINE> mod = ( mod * 10 ) % 2019 <NEWLINE> a [ k ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans += i * ( i - 1 ) * 0.5 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import collections <NEWLINE> from math import * <NEWLINE> s = input ( ) <NEWLINE> a = collections . Counter ( s ) <NEWLINE> o = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if a [ x ] & 1 : <NEWLINE> <INDENT> o += 1 <NEWLINE> if o > 1 : print ( 0 ) ; break <NEWLINE> a [ x ] -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b = factorial ( len ( s ) // 2 ) <NEWLINE> for x in a . values ( ) : <NEWLINE> <INDENT> b //= factorial ( x // 2 ) <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> res = a [ 0 ] <NEWLINE> a . pop ( 0 ) <NEWLINE> <NL> num = ( n - 2 ) // 2 <NEWLINE> num1 = ( n - 2 ) % 2 <NEWLINE> res += sum ( a [ : num ] ) * 2 + a [ num ] * num1 <NEWLINE> print ( res ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> for i in [ 2 , 5 ] : <NEWLINE> <INDENT> if K % i == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> t = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> t = ( t * 10 + 7 ) % K <NEWLINE> if t == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * 100001 <NEWLINE> for a_ in a : <NEWLINE> <INDENT> cnt [ a_ ] += 1 <NEWLINE> <NL> <DEDENT> total = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> total += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( total ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> sa = abs ( a - b ) <NEWLINE> sas = abs ( v - w ) <NEWLINE> if w >= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> d = sa // sas <NEWLINE> <NL> if d > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if d == t : <NEWLINE> <INDENT> if sa % sas == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if d < t : <NEWLINE> <INDENT> if sa - ( d * sas ) - sas <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> def solve ( stdin ) : <NEWLINE> <INDENT> n = stdin [ 0 ] <NEWLINE> dp = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> dp *= np . arange ( n + 1 ) <NEWLINE> return dp . sum ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> stdin = np . fromstring ( open ( 0 ) . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> print ( solve ( stdin ) ) <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from heapq import heappush , heappop <NEWLINE> <NL> INF = 10000000000 <NEWLINE> <NL> def solve ( r , v , dic ) : <NEWLINE> <INDENT> dp = [ ] <NEWLINE> q = [ ] <NEWLINE> dp = [ INF ] * v <NEWLINE> dp [ r ] = 0 <NEWLINE> heappush ( q , ( 0 , r ) ) <NEWLINE> while q : <NEWLINE> <INDENT> cost , vtx = heappop ( q ) <NEWLINE> if dp [ vtx ] < cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if vtx not in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for vtx1 , cost1 in dic [ vtx ] : <NEWLINE> <INDENT> if cost + cost1 < dp [ vtx1 ] : <NEWLINE> <INDENT> dp [ vtx1 ] = cost + cost1 <NEWLINE> heappush ( q , ( cost + cost1 , vtx1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> dp = [ ] <NEWLINE> line = input ( ) <NEWLINE> v , e , r = list ( map ( int , line . split ( ) ) ) <NEWLINE> for _ in range ( 0 , e ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s , t , d = list ( map ( int , line . split ( ) ) ) <NEWLINE> if s not in dic : <NEWLINE> <INDENT> dic [ s ] = [ [ t , d ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] += [ [ t , d ] ] <NEWLINE> <DEDENT> <DEDENT> dp = solve ( r , v , dic ) <NEWLINE> for t in range ( 0 , v ) : <NEWLINE> <INDENT> print ( dp [ t ] if dp [ t ] != INF else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> Q , * BC = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> total = sum ( A ) <NEWLINE> d = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> for b , c in zip ( BC [ : : 2 ] , BC [ 1 : : 2 ] ) : <NEWLINE> <INDENT> total += ( c - b ) * d [ b ] <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( total ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in n_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> tho = 10 ** 18 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= n_list [ i ] <NEWLINE> if ans > tho : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= tho : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> A , B = input ( ) . split ( ) <NEWLINE> <NL> x = int ( B [ 0 ] ) <NEWLINE> y = int ( B [ 2 ] ) <NEWLINE> z = int ( B [ 3 ] ) <NEWLINE> <NL> ans = [ 0 ] * 18 <NEWLINE> L = len ( A ) <NEWLINE> <NL> for i in range ( L ) : <NEWLINE> <INDENT> a = int ( A [ L - i - 1 ] ) <NEWLINE> c = a * z <NEWLINE> ans [ 17 - i ] = c <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> a = int ( A [ L - i - 1 ] ) <NEWLINE> c = a * y <NEWLINE> ans [ 16 - i ] += c <NEWLINE> <NL> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> a = int ( A [ L - i - 1 ] ) <NEWLINE> c = a * x <NEWLINE> ans [ 15 - i ] += c <NEWLINE> <NL> <DEDENT> S = 0 <NEWLINE> <NL> for i in range ( 16 ) : <NEWLINE> <INDENT> S += ans [ i ] * 10 ** ( 15 - i ) <NEWLINE> <NL> <DEDENT> if ans [ 16 ] * 10 + ans [ 17 ] > 100 : <NEWLINE> <INDENT> S += ( ans [ 16 ] * 10 + ans [ 17 ] ) // 100 <NEWLINE> <DEDENT> print ( int ( S ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 ) ] <NEWLINE> arr = a [ 0 ] <NEWLINE> list . sort ( arr , reverse = True ) <NEWLINE> <NL> if arr [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( arr [ - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * arr [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( value ) for value in input ( ) . split ( <STRING> ) ] , reverse = True ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for value in A : <NEWLINE> <INDENT> result *= value <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> al = [ - 1 ] * ( m + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if al [ x % m ] >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> al [ x % m ] = cnt <NEWLINE> A . append ( x ) <NEWLINE> cnt += 1 <NEWLINE> x = x ** 2 % m <NEWLINE> <NL> <DEDENT> if n <= al [ x ] : <NEWLINE> <INDENT> print ( sum ( A [ : al [ x ] ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> lena = len ( A ) <NEWLINE> loop = A [ al [ x ] : ] <NEWLINE> lenl = cnt - al [ x ] <NEWLINE> n -= al [ x ] <NEWLINE> cnt = n // lenl <NEWLINE> print ( sum ( A [ : al [ x ] ] ) + sum ( loop ) * cnt + sum ( loop [ : n % lenl ] ) ) <NEWLINE>
import math <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> while n > 9 : <NEWLINE> <INDENT> c += 1 <NEWLINE> n = max ( ( n // ( 10 ** x ) ) * ( n % ( 10 ** x ) ) for x in range ( 1 , int ( math . log10 ( n ) ) + 1 ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_ans = [ ] <NEWLINE> minimum = min ( B - 1 , N ) <NEWLINE> print ( int ( A * minimum / B ) - A * int ( minimum / B ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = UnionFind ( N ) <NEWLINE> not_friend_candidates = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> tree . union ( A , B ) <NEWLINE> not_friend_candidates . append ( [ A , B ] ) <NEWLINE> <NL> <DEDENT> for j in range ( K ) : <NEWLINE> <INDENT> C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C -= 1 <NEWLINE> D -= 1 <NEWLINE> not_friend_candidates . append ( [ C , D ] ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> for i , j in not_friend_candidates : <NEWLINE> <INDENT> if tree . same ( i , j ) : <NEWLINE> <INDENT> ans [ i ] -= 1 <NEWLINE> ans [ j ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i ] += tree . size ( i ) - 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ali = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> opelates = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> opelates . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> numCntList = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for num in ali : <NEWLINE> <INDENT> numCntList [ num ] += 1 <NEWLINE> <DEDENT> total = sum ( ali ) <NEWLINE> <NL> for op in opelates : <NEWLINE> <INDENT> pre = op [ 0 ] <NEWLINE> nex = op [ 1 ] <NEWLINE> preCnt = numCntList [ pre ] <NEWLINE> if preCnt >= 1 : <NEWLINE> <INDENT> numCntList [ pre ] = 0 <NEWLINE> numCntList [ nex ] += preCnt <NEWLINE> total += ( nex - pre ) * preCnt <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import combinations <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ 0 ] * n <NEWLINE> mod = 10 ** 9 <NEWLINE> judge = dict ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if a + i <= 1 or a + i >= h or b + j <= 1 or b + j >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( a + i , b + j ) in judge : <NEWLINE> <INDENT> judge [ ( a + i , b + j ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge [ ( a + i , b + j ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 10 <NEWLINE> <NL> for v in judge . values ( ) : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) - sum ( ans [ 1 : ] ) <NEWLINE> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> tmp += A [ j ] * B [ j ] <NEWLINE> <DEDENT> if tmp + C > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> city_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> th_list = [ ] <NEWLINE> n = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> th_list . append ( n ) <NEWLINE> n = city_list [ n ] - 1 <NEWLINE> <NL> <DEDENT> c = collections . Counter ( th_list ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ th_list [ i ] ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> list = [ x for x , l in enumerate ( th_list ) if l == th_list [ i ] ] <NEWLINE> <NL> if K > N : <NEWLINE> <INDENT> print ( th_list [ ( K - list [ 0 ] ) % ( list [ 1 ] - list [ 0 ] ) + list [ 0 ] ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( th_list [ K ] + 1 ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> if ans == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 1 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * N <NEWLINE> <NL> def judge ( index ) : <NEWLINE> <INDENT> if dp [ index ] != - 1 : <NEWLINE> <INDENT> return dp [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges = 0 <NEWLINE> for i in nodes [ index ] : <NEWLINE> <INDENT> edges = max ( edges , 1 + judge ( i ) ) <NEWLINE> <DEDENT> dp [ index ] = edges <NEWLINE> return edges <NEWLINE> <NL> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer = max ( answer , judge ( i ) ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> l = 0 <NEWLINE> j = 0 <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> a [ l ] = i + 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> l = 0 <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> b [ j ] = i + 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> j = 0 <NEWLINE> while ( a [ l ] < b [ l ] and not ( a [ l ] == 0 or b [ l ] == 0 ) ) : <NEWLINE> <INDENT> a [ l ] = 0 <NEWLINE> b [ l ] = 0 <NEWLINE> l += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> print ( j ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( [ 1 for z in range ( k + 1 ) for y in range ( k + 1 ) if 0 <= s - y - z <= k ] ) ) <NEWLINE>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> b = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> ca = Counter ( a ) <NEWLINE> cb = Counter ( b ) <NEWLINE> for k in cb . keys ( ) : <NEWLINE> <INDENT> if cb [ k ] > n - ca [ k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> while any ( a == b ) : <NEWLINE> <INDENT> s = max ( ca [ k ] for k in cb . keys ( ) ) <NEWLINE> b = np . roll ( b , s ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import * <NEWLINE> def ABC_169_C ( ) : <NEWLINE> <INDENT> getcontext ( ) . prec = 28 <NEWLINE> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> k = Decimal ( str ( A ) ) * Decimal ( str ( B ) ) <NEWLINE> print ( int ( k ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> ABC_169_C ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 1 <NEWLINE> l = [ ] <NEWLINE> s = [ 1 ] * n <NEWLINE> <NL> while s [ num - 1 ] : <NEWLINE> <INDENT> l . append ( num ) <NEWLINE> s [ num - 1 ] = 0 <NEWLINE> num = a [ num - 1 ] <NEWLINE> <NL> <DEDENT> if l . index ( num ) <= k : <NEWLINE> <INDENT> l2 = l [ l . index ( num ) : ] <NEWLINE> kk = ( k - len ( set ( l ) - set ( l2 ) ) ) % len ( l2 ) <NEWLINE> print ( l2 [ kk ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = <STRING> <NEWLINE> aa = list ( a ) <NEWLINE> <NL> stra = <STRING> <NEWLINE> kk = n <NEWLINE> for i in range ( 15 ) : <NEWLINE> <INDENT> ki = ( kk - 1 ) % 26 + 1 <NEWLINE> if ki != 0 : <NEWLINE> <INDENT> stra = aa [ ki - 1 ] + stra <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stra = aa [ 25 ] + stra <NEWLINE> <DEDENT> kk = ( kk - ki ) // 26 <NEWLINE> <COMMENT> <NL> if kk == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stra ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> V . insert ( 0 , 0 ) <NEWLINE> visited = [ False for i in range ( N + 1 ) ] <NEWLINE> inf = 10 ** 18 <NEWLINE> dp = [ inf for i in range ( N + 1 ) ] <NEWLINE> ans = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> stack = deque ( ) <NEWLINE> <NL> G = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( v ) <NEWLINE> G [ v ] . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( s_node ) : <NEWLINE> <INDENT> visited [ s_node ] = True <NEWLINE> <COMMENT> <NL> value = V [ s_node ] <NEWLINE> index = bisect . bisect_left ( dp , value ) <NEWLINE> old_value = dp [ index ] <NEWLINE> dp [ index ] = value <NEWLINE> ans [ s_node ] = bisect . bisect_right ( dp , inf - 1 ) <NEWLINE> stack . append ( ( index , old_value , value ) ) <NEWLINE> for child in G [ s_node ] : <NEWLINE> <INDENT> if visited [ child ] == False : <NEWLINE> <INDENT> dfs ( child ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> index , old_value , value = stack . pop ( ) <NEWLINE> dp [ index ] = old_value <NEWLINE> <NL> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> c = deque ( list ( input ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> def left ( c ) : <NEWLINE> <INDENT> l = c . popleft ( ) <NEWLINE> return l <NEWLINE> <DEDENT> def right ( c ) : <NEWLINE> <INDENT> r = c . pop ( ) <NEWLINE> return r <NEWLINE> <DEDENT> while c : <NEWLINE> <INDENT> l = left ( c ) <NEWLINE> if l == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if not c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r = right ( c ) <NEWLINE> if r == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> sums = [ ] <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tmp += nums [ N - i ] <NEWLINE> sums . append ( tmp ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = nums [ i ] <NEWLINE> b = sums [ N - ( i + 2 ) ] <NEWLINE> total += a * sums [ N - ( i + 2 ) ] <NEWLINE> <NL> <DEDENT> print ( total % ( 1000000000 + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> class Point ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> <DEDENT> x1 , y1 , x2 , y2 = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> point1 = Point ( x1 , y1 ) <NEWLINE> point2 = Point ( x2 , y2 ) <NEWLINE> <NL> x_dist = point1 . x - point2 . x <NEWLINE> y_dist = point1 . y - point2 . y <NEWLINE> <NL> dist = math . sqrt ( x_dist ** 2 + y_dist ** 2 ) <NEWLINE> <NL> print ( dist ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> print ( math . floor ( a / b * ( b - 1 ) ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a / b * n ) - a * math . floor ( n / b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cs = A [ : ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cs [ i ] += cs [ i - 1 ] <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> sum += A [ i ] * ( cs [ - 1 ] - cs [ i ] ) <NEWLINE> <DEDENT> print ( sum % mod ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> n = int ( s [ 0 ] ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> d = [ 0 ] * n <NEWLINE> for i in s : <NEWLINE> <INDENT> d [ int ( i ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SumListA = [ ] <NEWLINE> SumListA . append ( 0 ) <NEWLINE> SumListB = [ ] <NEWLINE> SumListB . append ( 0 ) <NEWLINE> res = 0 <NEWLINE> a = 0 <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> SumListA . append ( SumListA [ i ] + List_A [ i ] ) <NEWLINE> <DEDENT> for i in range ( B ) : <NEWLINE> <INDENT> SumListB . append ( SumListB [ i ] + List_B [ i ] ) <NEWLINE> <NL> <DEDENT> j = B <NEWLINE> for i in range ( A + 1 ) : <NEWLINE> <INDENT> if SumListA [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while K - SumListA [ i ] < SumListB [ j ] : <NEWLINE> <INDENT> j += - 1 <NEWLINE> <DEDENT> res = max ( i + j , res ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
numset = set ( [ ] ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query , x = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if query == 0 : <NEWLINE> <INDENT> numset . add ( x ) <NEWLINE> print ( len ( numset ) ) <NEWLINE> <DEDENT> elif query == 1 : <NEWLINE> <INDENT> if set ( [ x ] ) . issubset ( numset ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if set ( [ x ] ) . issubset ( numset ) : <NEWLINE> <INDENT> numset . remove ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a_log = [ ] <NEWLINE> if 0 not in a : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> i_log = math . log10 ( i ) <NEWLINE> a_log . append ( i_log ) <NEWLINE> <NL> <DEDENT> if sum ( a_log ) > 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a [ i + 1 ] *= a [ i ] <NEWLINE> <DEDENT> if a [ n - 1 ] > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ n - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> def func ( a , b ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for c1 , c2 in zip ( a , b ) : <NEWLINE> <INDENT> if c1 != c2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> t_max = 10000 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> tmp = func ( s [ i : i + len ( t ) ] , t ) <NEWLINE> if tmp < t_max : <NEWLINE> <INDENT> t_max = tmp <NEWLINE> <DEDENT> <DEDENT> print ( t_max ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> edges_r = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n + m - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges_r [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> s = 0 <NEWLINE> ks = [ ] <NEWLINE> for i , e in enumerate ( edges_r ) : <NEWLINE> <INDENT> if len ( e ) == 0 : <NEWLINE> <INDENT> s = i <NEWLINE> <DEDENT> ks . append ( len ( e ) ) <NEWLINE> <NL> <DEDENT> parents = [ - 1 ] * n <NEWLINE> INF = 1 << 60 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in edges [ u ] : <NEWLINE> <COMMENT> <NL> <INDENT> ks [ v ] -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ks [ v ] == 0 : <NEWLINE> <INDENT> parents [ v ] = u <NEWLINE> q . appendleft ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for p in parents : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> suma = 0 <NEWLINE> sumb = 0 <NEWLINE> <NL> As = [ 0 ] * N <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> suma += A [ i ] <NEWLINE> As [ i ] = suma <NEWLINE> <NL> <DEDENT> Bs = [ 0 ] * M <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> sumb += B [ i ] <NEWLINE> Bs [ i ] = sumb <NEWLINE> <DEDENT> sum_time = 0 <NEWLINE> max_count = 0 <NEWLINE> count = 0 <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> sum_time = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_time = As [ i - 1 ] <NEWLINE> count += i <NEWLINE> <DEDENT> if sum_time > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ind = bisect . bisect_right ( Bs , K - sum_time ) <NEWLINE> count += ind <NEWLINE> max_count = max ( max_count , count ) <NEWLINE> <NL> <DEDENT> print ( max_count ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> flag = 0 <NEWLINE> cnt = 0 <NEWLINE> d = deque ( s ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> lis = list ( input ( ) . split ( ) ) <NEWLINE> if lis [ 0 ] == <STRING> : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ 1 ] == <STRING> : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> d . append ( lis [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . appendleft ( lis [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> d . appendleft ( lis [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( lis [ 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> d = list ( d ) <NEWLINE> if cnt % 2 != 0 : <NEWLINE> <INDENT> d = d [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( d ) ) <NEWLINE>
import operator <NEWLINE> from functools import reduce <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * ( r ** 2 ) , 2 * math . pi * r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , ) <NEWLINE> j = 1 <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> j = i * j <NEWLINE> if j > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if j > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> ss = np . array ( S + S ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ss [ i : i + n ] <NEWLINE> if np . array_equal ( a , a . T ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * n ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( A * x ) // B ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> n_num = [ _ for _ in range ( n ) ] <NEWLINE> <NL> l = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> ptns = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ptns += list ( combinations ( n_num , i + 1 ) ) <NEWLINE> <NL> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for j in range ( len ( ptns ) ) : <NEWLINE> <INDENT> tmp = np . array ( [ 0 ] * ( m + 1 ) ) <NEWLINE> for k in range ( len ( ptns [ j ] ) ) : <NEWLINE> <INDENT> tmp += l [ ptns [ j ] [ k ] ] <NEWLINE> <DEDENT> if min ( tmp [ 1 : ] ) >= x : <NEWLINE> <INDENT> ans = min ( ans , tmp [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if ans == float ( <STRING> ) else ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> s = readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> <NL> w = s . count ( <STRING> ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> if r == 0 or w == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i_r = s . index ( <STRING> ) <NEWLINE> r2 = s [ : r : ] . count ( <STRING> ) <NEWLINE> print ( r - r2 ) <NEWLINE>
from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> s_c = Counter ( s ) <NEWLINE> s_c_max = s_c . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> keys = [ k for k , v in s_c . items ( ) if v == s_c_max ] <NEWLINE> keys_s = sorted ( keys ) <NEWLINE> print ( * keys_s , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <COMMENT> <NL> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = y , x <NEWLINE> <COMMENT> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> <COMMENT> <NL> self . parents [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> union = UnionFind ( n ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> union . union ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> for cnt , j in enumerate ( p ) : <NEWLINE> <INDENT> if union . same ( cnt , j - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> Q = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if Q [ 0 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( int ( Q [ 1 ] ) + count ) % 2 == 1 : <NEWLINE> <INDENT> a . append ( Q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( Q [ 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> a = <STRING> . join ( a [ : : - 1 ] ) <NEWLINE> b = <STRING> . join ( b ) <NEWLINE> s = a + s + b <NEWLINE> if count % 2 == 1 and count != 0 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> queue = deque ( [ 1 ] ) <NEWLINE> d = [ None ] * ( N + 1 ) <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = v <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
c = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> c . append ( x ) <NEWLINE> c . append ( y ) <NEWLINE> c . append ( z ) <NEWLINE> <NL> <DEDENT> for a1 in range ( 101 ) : <NEWLINE> <INDENT> for a2 in range ( 101 ) : <NEWLINE> <INDENT> for a3 in range ( 101 ) : <NEWLINE> <INDENT> b1 = c [ 0 ] - a1 <NEWLINE> b2 = c [ 1 ] - a1 <NEWLINE> b3 = c [ 2 ] - a1 <NEWLINE> if c [ 3 ] == a2 + b1 and c [ 4 ] == a2 + b2 and c [ 5 ] == a2 + b3 and c [ 6 ] == a3 + b1 and c [ 7 ] == a3 + b2 and c [ 8 ] == a3 + b3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> M = max ( a ) <NEWLINE> d = [ 1 for i in range ( M + 1 ) ] <NEWLINE> for v in sorted ( a ) : <NEWLINE> <INDENT> for j in range ( 2 * v , M + 1 , v ) : <NEWLINE> <INDENT> d [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> c = Counter ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if c [ i ] == 1 : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def print_solve ( ans ) : <NEWLINE> <INDENT> if <STRING> in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in ans : <NEWLINE> <INDENT> for c in l [ : - 1 ] : <NEWLINE> <INDENT> if c == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if l [ - 1 ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def solve ( graph_data , num_v ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> <NL> for i in range ( num_v ) : <NEWLINE> <INDENT> ans . append ( partial_solve ( graph_data , i , num_v ) ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def partial_solve ( graph_data , source , num_v ) : <NEWLINE> <INDENT> ans = [ 0 if i == source else float ( <STRING> ) for i in range ( num_v ) ] <NEWLINE> <NL> i = 0 <NEWLINE> while ( ans != solver_iteration ( graph_data , ans ) ) : <NEWLINE> <INDENT> ans = solver_iteration ( graph_data , ans ) <NEWLINE> i += 1 <NEWLINE> if i >= num_v : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def solver_iteration ( graph_data , prev_ans ) : <NEWLINE> <INDENT> new_ans = prev_ans [ 0 : ] <NEWLINE> <NL> for i , v in enumerate ( new_ans ) : <NEWLINE> <INDENT> if v == float ( <STRING> ) or i not in graph_data : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for t , w in graph_data [ i ] : <NEWLINE> <INDENT> new_ans [ t ] = min ( new_ans [ t ] , v + w ) <NEWLINE> <NL> <DEDENT> <DEDENT> return new_ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> V = int ( l [ 0 ] ) <NEWLINE> E = int ( l [ 1 ] ) <NEWLINE> <NL> graph = { } <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> s = int ( l [ 0 ] ) <NEWLINE> t = int ( l [ 1 ] ) <NEWLINE> d = int ( l [ 2 ] ) <NEWLINE> <NL> if s in graph : <NEWLINE> <INDENT> graph [ s ] . append ( ( t , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> graph [ s ] = [ ( t , d ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> print_solve ( solve ( graph , V ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> V = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = V [ 0 ] <NEWLINE> for v in V [ 1 : ] : <NEWLINE> <INDENT> ans = ( ans + v ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if l [ l [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
A , B , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> result_list = [ ] <NEWLINE> <NL> def divisor_list ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> array = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> array . append ( i ) <NEWLINE> array . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> array = list ( set ( array ) ) <NEWLINE> return array <NEWLINE> <NL> <DEDENT> for i in divisor_list ( A ) : <NEWLINE> <INDENT> for j in divisor_list ( B ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> result_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sorted ( result_list ) [ - K ] ) <NEWLINE>
import math <NEWLINE> a_h , b_m , hour , minute = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> pi = math . pi <NEWLINE> arg_h = ( hour + minute / 60 ) * 360 / 12 <NEWLINE> arg_m = minute * 360 / 60 <NEWLINE> <NL> diff_arg = abs ( arg_h - arg_m ) <NEWLINE> ans_square = a_h ** 2 + b_m ** 2 - 2 * a_h * b_m * math . cos ( math . radians ( diff_arg ) ) <NEWLINE> ans = math . sqrt ( ans_square ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> DEBUG = False <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if DEBUG : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> term1 = math . floor ( A * x / B ) <NEWLINE> term2 = A * math . floor ( x / B ) <NEWLINE> temp = term1 - term2 <NEWLINE> print ( <STRING> . format ( x , temp , term1 , term2 ) ) <NEWLINE> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> print ( math . floor ( A * min ( B - 1 , N ) / B ) - A * math . floor ( min ( B - 1 , N ) / B ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> h . sort ( ) <NEWLINE> ans = 10 ** 10 <NEWLINE> <NL> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans_ = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( ans , ans_ ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> count = [ 0 ] * 100000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> o = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s += ( o [ 1 ] - o [ 0 ] ) * count [ o [ 0 ] - 1 ] <NEWLINE> count [ o [ 1 ] - 1 ] += count [ o [ 0 ] - 1 ] <NEWLINE> count [ o [ 0 ] - 1 ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> arrey = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> arrey [ b - 1 ] [ f - 1 ] [ r - 1 ] = arrey [ b - 1 ] [ f - 1 ] [ r - 1 ] + v <NEWLINE> <NL> <DEDENT> for b in range ( len ( arrey ) ) : <NEWLINE> <INDENT> for f in range ( len ( arrey [ b ] ) ) : <NEWLINE> <INDENT> for r in range ( len ( arrey [ b ] [ f ] ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( arrey [ b ] [ f ] [ r ] ) , end = <STRING> ) if r != len ( arrey [ b ] [ f ] ) - 1 else print ( <STRING> + str ( arrey [ b ] [ f ] [ r ] ) ) <NEWLINE> <DEDENT> <DEDENT> if b != len ( arrey ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def int1 ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple_minus1 ( ) : <NEWLINE> <INDENT> return tuple ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = input_to_int_map ( ) <NEWLINE> a_array = input_to_int_tuple ( ) <NEWLINE> <NL> for k_val , pre_k_val in zip ( a_array [ k : ] , a_array [ k - k : ] ) : <NEWLINE> <INDENT> if k_val > pre_k_val : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> for xi , yi in xy : <NEWLINE> <INDENT> for xj , yj in xy : <NEWLINE> <INDENT> cnt [ ( xi - xj , yi - yj ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt [ ( 0 , 0 ) ] = 0 <NEWLINE> ans = n - max ( cnt . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> ans = l <NEWLINE> <COMMENT> <NL> for i , s in enumerate ( S [ 1 : ] ) : <NEWLINE> <INDENT> if s != S [ i ] : <NEWLINE> <INDENT> ans = min ( ans , max ( i + 1 , l - 1 - i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> a = <STRING> <NEWLINE> x = str . maketrans ( a , a [ 1 : ] + a [ : 1 ] ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> s = s . translate ( x ) <NEWLINE> if <STRING> in s or <STRING> in s or <STRING> in s : <NEWLINE> <INDENT> print ( s , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> M = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] <= A [ ( i + 1 ) ] and M <= A [ ( i + 1 ) ] : <NEWLINE> <INDENT> M = 0 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if M == 0 : <NEWLINE> <INDENT> s += A [ i ] - A [ ( i + 1 ) ] <NEWLINE> M = A [ ( i + 1 ) ] + ( A [ i ] - A [ ( i + 1 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += M - A [ ( i + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> edges . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> cur = ( ( n - 1 ) * n ) // 2 <NEWLINE> par = { i : i for i in range ( 1 , n + 1 ) } <NEWLINE> size = { i : 1 for i in range ( 1 , n + 1 ) } <NEWLINE> rank = { i : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if x != par [ x ] : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> <DEDENT> return par [ x ] <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> px , py = find ( x ) , find ( y ) <NEWLINE> res = 0 <NEWLINE> if px != py : <NEWLINE> <INDENT> res = size [ px ] * size [ py ] <NEWLINE> if rank [ px ] < rank [ py ] : <NEWLINE> <INDENT> par [ px ] = py <NEWLINE> size [ py ] += size [ px ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ py ] = px <NEWLINE> size [ px ] += size [ py ] <NEWLINE> if rank [ px ] == rank [ py ] : <NEWLINE> <INDENT> rank [ px ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans . append ( cur ) <NEWLINE> x , y = edges [ i ] <NEWLINE> cur -= union ( x , y ) <NEWLINE> <DEDENT> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) . strip ( ) ) <NEWLINE> data = [ 0 for _ in range ( N ) ] <NEWLINE> for i in input ( ) . strip ( ) . split ( <STRING> ) : <NEWLINE> <INDENT> data [ int ( i ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for d in data : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for v in list ( n ) : <NEWLINE> <INDENT> count += int ( v ) <NEWLINE> <NL> <DEDENT> if ( count % 9 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> print ( ( N - 1 ) * N // 2 ) <NEWLINE>
inputEnzan = input ( ) . split ( ) <NEWLINE> <NL> def keisan ( inputEnzan ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> stockFornumber = [ ] <NEWLINE> index = 0 <NEWLINE> length = len ( inputEnzan ) <NEWLINE> if length == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while index < length : <NEWLINE> <INDENT> if inputEnzan [ index ] == <STRING> or inputEnzan [ index ] == <STRING> or inputEnzan [ index ] == <STRING> : <NEWLINE> <INDENT> if len ( stockFornumber ) == 2 : <NEWLINE> <INDENT> if inputEnzan [ index ] == <STRING> : <NEWLINE> <INDENT> inputEnzan [ index ] = stockFornumber [ 0 ] + stockFornumber [ 1 ] <NEWLINE> stockFornumber = [ ] <NEWLINE> inputEnzan [ index - 1 ] = <STRING> <NEWLINE> inputEnzan [ index - 2 ] = <STRING> <NEWLINE> <NL> <DEDENT> elif inputEnzan [ index ] == <STRING> : <NEWLINE> <INDENT> inputEnzan [ index ] = stockFornumber [ 0 ] - stockFornumber [ 1 ] <NEWLINE> stockFornumber = [ ] <NEWLINE> inputEnzan [ index - 1 ] = <STRING> <NEWLINE> inputEnzan [ index - 2 ] = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> inputEnzan [ index ] = stockFornumber [ 0 ] * stockFornumber [ 1 ] <NEWLINE> stockFornumber = [ ] <NEWLINE> inputEnzan [ index - 1 ] = <STRING> <NEWLINE> inputEnzan [ index - 2 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stockFornumber = [ ] <NEWLINE> pass <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( stockFornumber ) == 2 : <NEWLINE> <INDENT> del stockFornumber [ 0 ] <NEWLINE> <DEDENT> stockFornumber . append ( int ( inputEnzan [ index ] ) ) <NEWLINE> <NL> <DEDENT> index += 1 <NEWLINE> <NL> <DEDENT> while <STRING> in inputEnzan : <NEWLINE> <INDENT> inputEnzan . remove ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( inputEnzan [ 0 ] ) <NEWLINE> <NL> <DEDENT> keisan ( inputEnzan ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> uni_count = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( S [ i + 1 ] != S [ i ] ) : <NEWLINE> <INDENT> uni_count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( uni_count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> l . sort ( ) <NEWLINE> dp = [ 0 ] * ( max ( N + 1 , 8 ) ) <NEWLINE> for j in l : <NEWLINE> <INDENT> dp [ w [ j - 1 ] ] = j <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ i ] != 0 : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> if w [ j - 1 ] + i <= N : <NEWLINE> <INDENT> dp [ i + w [ j - 1 ] ] = max ( dp [ i + w [ j - 1 ] ] , dp [ i ] * 10 + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> rui = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> rui [ i ] = tmp <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( rui [ lr [ i ] [ 1 ] - 1 ] - rui [ lr [ i ] [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W = MAP ( ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> dy = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dx = [ 0 , - 1 , 0 , 1 ] <NEWLINE> check = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> for y0 in range ( H ) : <NEWLINE> <INDENT> for x0 in range ( W ) : <NEWLINE> <INDENT> if S [ y0 ] [ x0 ] == <STRING> or check [ y0 ] [ x0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt_black = 1 <NEWLINE> cnt_white = 0 <NEWLINE> check [ y0 ] [ x0 ] = 1 <NEWLINE> q = deque ( [ ( y0 , x0 , 1 ) ] ) <NEWLINE> while q : <NEWLINE> <COMMENT> <NL> <INDENT> y , x , color = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = y + dy [ i ] <NEWLINE> nx = x + dx [ i ] <NEWLINE> if 0 <= ny < H and 0 <= nx < W : <NEWLINE> <INDENT> if color == 1 and S [ ny ] [ nx ] == <STRING> and check [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> check [ ny ] [ nx ] = 1 <NEWLINE> <COMMENT> <NL> cnt_white += 1 <NEWLINE> q . append ( ( ny , nx , 0 ) ) <NEWLINE> <DEDENT> if color == 0 and S [ ny ] [ nx ] == <STRING> and check [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> check [ ny ] [ nx ] = 1 <NEWLINE> cnt_black += 1 <NEWLINE> q . append ( ( ny , nx , 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += cnt_white * cnt_black <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> temp = x . count ( <STRING> ) <NEWLINE> mod1 = [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> mod1 . append ( mod1 [ - 1 ] * 2 % ( temp + 1 ) ) <NEWLINE> <DEDENT> mod1 . reverse ( ) <NEWLINE> num1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> num1 += mod1 [ i ] <NEWLINE> num1 %= ( temp + 1 ) <NEWLINE> <DEDENT> <DEDENT> if temp == 1 or temp == 2 : <NEWLINE> <INDENT> mod2 = [ 0 ] * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod2 = [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> mod2 . append ( mod2 [ - 1 ] * 2 % ( temp - 1 ) ) <NEWLINE> <DEDENT> mod2 . reverse ( ) <NEWLINE> num2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> num2 += mod2 [ i ] <NEWLINE> num2 %= ( temp - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x2 = int ( x , 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if temp == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> elif temp == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = num2 - mod2 [ i ] <NEWLINE> num %= ( temp - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num = num1 + mod1 [ i ] <NEWLINE> num %= ( temp + 1 ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> while num : <NEWLINE> <INDENT> num %= bin ( num ) . count ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mula_now = 0 <NEWLINE> tmp = 0 <NEWLINE> mula_prev = a [ 0 ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> mula_now = a [ i ] <NEWLINE> if mula_now > mula_prev : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> mula_prev = a [ tmp ] <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> M = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> s %= M <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = s - A [ i ] <NEWLINE> if s < 0 : <NEWLINE> <INDENT> s += M <NEWLINE> <DEDENT> ans += A [ i ] * s <NEWLINE> ans %= M <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gakki = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> temp1 = gakki [ i ] <NEWLINE> temp2 = gakki [ K + i ] <NEWLINE> if temp1 < temp2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> temp1 = temp2 <NEWLINE> <NL> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - X // D ) % 2 == 1 : <NEWLINE> <INDENT> print ( D - ( X - X // D * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - X // D * D ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 0 ] * N <NEWLINE> <NL> <COMMENT> <NL> min1 = 0 <NEWLINE> max1 = max ( A ) + 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> X = ( min1 + max1 ) // 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % X == 0 : <NEWLINE> <INDENT> d [ i ] = A [ i ] // X - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = A [ i ] // X <NEWLINE> <DEDENT> <DEDENT> if sum ( d ) <= K : <NEWLINE> <INDENT> max1 = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min1 = X <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if max1 - min1 <= 1 : <NEWLINE> <INDENT> print ( int ( max1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uf . union ( a [ 0 ] - 1 , a [ 1 ] - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for l in range ( j , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( i , j ) <NEWLINE> abc = math . gcd ( ab , l ) <NEWLINE> <COMMENT> <NL> if i == j and j == l : <COMMENT> <NEWLINE> <INDENT> abc = abc <NEWLINE> <COMMENT> <NL> <DEDENT> elif i == j or j == l or i == l : <COMMENT> <NEWLINE> <INDENT> abc = 3 * abc <NEWLINE> <COMMENT> <NL> <DEDENT> elif i != j and i != l and j != l : <COMMENT> <NEWLINE> <INDENT> abc = 6 * abc <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans += abc <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> prod = 0 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> prod = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ <STRING> + input ( ) + <STRING> for _ in range ( H ) ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> S . insert ( 0 , <STRING> * ( W + 4 ) ) <NEWLINE> S . append ( <STRING> * ( W + 4 ) ) <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> cost = [ [ INF for _ in range ( W + 4 ) ] for _ in range ( H + 4 ) ] <NEWLINE> cost0 = deque ( ) <NEWLINE> ans = - 1 <NEWLINE> <NL> cost0 . append ( ( C [ 0 ] + 1 , C [ 1 ] + 1 , 0 ) ) <NEWLINE> cost [ C [ 0 ] + 1 ] [ C [ 1 ] + 1 ] = 0 <NEWLINE> <NL> move = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> warp = [ ( i , j ) for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if ( i , j ) not in [ ( 0 , 0 ) ] + move ] <NEWLINE> <NL> cost1 = deque ( ) <NEWLINE> <NL> while cost0 : <NEWLINE> <INDENT> h , w , c = cost0 . popleft ( ) <NEWLINE> cost1 . append ( ( h , w , c ) ) <NEWLINE> <NL> for i , j in move : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if S [ dh ] [ dw ] == <STRING> and c < cost [ dh ] [ dw ] : <NEWLINE> <INDENT> cost [ dh ] [ dw ] = c <NEWLINE> cost0 . appendleft ( ( dh , dw , cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( cost0 ) == 0 : <NEWLINE> <INDENT> while cost1 : <NEWLINE> <INDENT> h , w , c = cost1 . popleft ( ) <NEWLINE> for i , j in warp : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if S [ dh ] [ dw ] == <STRING> and c + 1 < cost [ dh ] [ dw ] : <NEWLINE> <INDENT> cost [ dh ] [ dw ] = c + 1 <NEWLINE> cost0 . append ( ( dh , dw , cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cost [ D [ 0 ] + 1 ] [ D [ 1 ] + 1 ] != INF : <NEWLINE> <INDENT> ans = cost [ D [ 0 ] + 1 ] [ D [ 1 ] + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> input_line = input ( ) <NEWLINE> inputs = input_line . split ( <STRING> ) <NEWLINE> N , = [ int ( s ) for s in inputs ] <NEWLINE> <NL> input_line = input ( ) <NEWLINE> s = list ( input_line ) <NEWLINE> sl = len ( s ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for ss in s : <NEWLINE> <INDENT> if ss == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif ss == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> num = 0 <NEWLINE> <NL> for i in range ( sl ) : <NEWLINE> <INDENT> for j in range ( i + 1 , sl ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < sl : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans -= num <NEWLINE> <NL> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcount ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> <NL> <COMMENT> <NL> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> <NL> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <COMMENT> <NEWLINE> x = x + ( x >> 8 ) <COMMENT> <NEWLINE> x = x + ( x >> 16 ) <COMMENT> <NEWLINE> x = x + ( x >> 32 ) <COMMENT> <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> f = [ 0 ] * N <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pc = popcount ( i ) <NEWLINE> j = i % pc <NEWLINE> f [ i ] = f [ j ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> X_COUNT = X . count ( <STRING> ) <NEWLINE> X = tuple ( map ( int , tuple ( X ) ) ) <NEWLINE> rem_plus = [ 0 ] * N <NEWLINE> rem_minus = [ 0 ] * N <NEWLINE> two_factor = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rem_plus [ i ] = two_factor <NEWLINE> two_factor *= 2 <NEWLINE> two_factor %= ( X_COUNT + 1 ) <NEWLINE> <NL> <DEDENT> if X_COUNT > 1 : <NEWLINE> <INDENT> two_factor = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rem_minus [ i ] = two_factor <NEWLINE> two_factor *= 2 <NEWLINE> two_factor %= ( X_COUNT - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> X_rem_plus = 0 <NEWLINE> X_rem_minus = 0 <NEWLINE> two_factor = 1 <NEWLINE> for c in X [ : : - 1 ] : <NEWLINE> <INDENT> X_rem_plus += two_factor * c <NEWLINE> X_rem_plus %= ( X_COUNT + 1 ) <NEWLINE> two_factor *= 2 <NEWLINE> two_factor %= ( X_COUNT + 1 ) <NEWLINE> <NL> <DEDENT> if X_COUNT > 1 : <NEWLINE> <INDENT> two_factor = 1 <NEWLINE> for c in X [ : : - 1 ] : <NEWLINE> <INDENT> X_rem_minus += two_factor * c <NEWLINE> X_rem_minus %= ( X_COUNT - 1 ) <NEWLINE> two_factor *= 2 <NEWLINE> two_factor %= ( X_COUNT - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , c in enumerate ( X ) : <NEWLINE> <INDENT> if c : <NEWLINE> <INDENT> if X_COUNT > 1 : <NEWLINE> <INDENT> rem = X_rem_minus - rem_minus [ N - 1 - i ] <NEWLINE> rem %= ( X_COUNT - 1 ) <NEWLINE> ans . append ( f [ rem ] + 1 ) <NEWLINE> <DEDENT> elif X_COUNT == 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> rem = X_rem_plus + rem_plus [ N - 1 - i ] <NEWLINE> rem %= ( X_COUNT + 1 ) <NEWLINE> ans . append ( f [ rem ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( Counter ( s ) ) ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> L = defaultdict ( int ) <NEWLINE> R = defaultdict ( int ) <NEWLINE> for i , x in enumerate ( A , 1 ) : <NEWLINE> <INDENT> l = i + x <NEWLINE> r = i - x <NEWLINE> L [ l ] += 1 <NEWLINE> R [ r ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for key , l_value in L . items ( ) : <NEWLINE> <INDENT> r_value = R [ key ] <NEWLINE> ans += l_value * r_value <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL>
import math <NEWLINE> def eraP ( n ) : <NEWLINE> <INDENT> if n <= 1 : return [ False ] * ( n + 1 ) <NEWLINE> elif n <= 2 : return [ False , False , True ] <NEWLINE> L = [ False if i % 2 == 0 or i % 3 == 0 else True for i in range ( n ) ] <NEWLINE> L [ 0 ] = False ; L [ 1 ] = False ; <NEWLINE> L [ 2 ] = True ; L [ 3 ] = True ; L [ 5 ] = True <NEWLINE> limit = math . sqrt ( n ) <NEWLINE> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if i >= limit : return L <NEWLINE> for s in range ( i ** 2 , n , i ) : <NEWLINE> <INDENT> L [ s ] = False <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> LR = [ [ 0 , 0 ] for _ in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> LR [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> P = eraP ( pow ( 10 , 5 ) + 1 ) [ 1 : ] <NEWLINE> <NL> sumP = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( 2 , pow ( 10 , 5 ) ) : <NEWLINE> <INDENT> sumP . append ( sumP [ - 1 ] + int ( P [ i ] and P [ ( i + 1 ) // 2 ] ) ) <NEWLINE> <NL> <DEDENT> for lr in LR : <NEWLINE> <INDENT> print ( sumP [ lr [ 1 ] ] - sumP [ lr [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> <NL> class unionFind : <NEWLINE> <INDENT> parent = [ ] <NEWLINE> <NL> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( N ) ] <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . root ( self . parent [ x ] ) <NEWLINE> return ( self . parent [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> x , y = x - 1 , y - 1 <NEWLINE> return ( self . root ( x ) == self . root ( y ) ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = x - 1 , y - 1 <NEWLINE> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> G = unionFind ( N ) <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> G . unite ( a , b ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> G . root ( i ) <NEWLINE> <NL> <DEDENT> C = collections . Counter ( G . parent ) . most_common ( ) <NEWLINE> <NL> print ( C [ 0 ] [ 1 ] ) <NEWLINE>
def insertionSortForShell ( lst , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = lst [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and lst [ j ] > v : <NEWLINE> <INDENT> lst [ j + g ] = lst [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> lst [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def cleate_split_lst ( n ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( n / 2 ) <NEWLINE> if n <= 1 : <NEWLINE> <INDENT> lst . append ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return lst <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( lst , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = cleate_split_lst ( n ) <NEWLINE> <NL> for i in range ( 0 , len ( G ) ) : <NEWLINE> <INDENT> cnt += insertionSortForShell ( lst , n , G [ i ] ) <NEWLINE> <NL> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( [ str ( g ) for g in G ] ) ) <NEWLINE> print ( cnt ) <NEWLINE> for n in lst : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> lst . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shellSort ( lst , n ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for a in range ( H ) : <NEWLINE> <INDENT> if a == 0 or a == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> y = [ False ] * h <NEWLINE> x = [ False ] * w <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> y [ i ] = True <NEWLINE> x [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if y [ i ] : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if x [ j ] : <NEWLINE> <INDENT> print ( a [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def kaijou ( x ) : <NEWLINE> <INDENT> y = 1 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> y *= i <NEWLINE> y %= mod <NEWLINE> <DEDENT> return y <NEWLINE> <DEDENT> if abs ( n - m ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == m : <NEWLINE> <INDENT> print ( ( kaijou ( n ) * kaijou ( m ) * 2 ) % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( kaijou ( n ) * kaijou ( m ) ) % mod ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> set_A = set ( ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> set_A . add ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if 1 not in set_A : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> <DEDENT> if 2 not in set_A and n != 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 + dp [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i + 1 not in set_A : <NEWLINE> <INDENT> dp [ i ] += ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = deque ( [ ] ) <NEWLINE> t = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if t == 0 : ans . append ( i ) <NEWLINE> else : ans . appendleft ( i ) <NEWLINE> t = 1 - t <NEWLINE> <NL> <DEDENT> if t == 0 : print ( * ans ) <NEWLINE> else : print ( * reversed ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = 0 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = [ 0 ] * 3 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> ans *= cnt [ i ] <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <NL> <INDENT> if a [ i ] == a [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ j ] == a [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ k ] == a [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> class UnionFindTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = list ( range ( n ) ) <COMMENT> <NEWLINE> self . rank = [ 0 ] * n <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == Q == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> parents = [ 0 ] + [ int ( input ( ) ) - 1 for _ in range ( N - 1 ) ] <NEWLINE> queries = [ ] <NEWLINE> marked = set ( ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> k , v = input ( ) . split ( ) <NEWLINE> v = int ( v ) - 1 <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> queries . append ( ( k , v ) ) <NEWLINE> <DEDENT> elif k == <STRING> and v not in marked : <NEWLINE> <INDENT> marked . add ( v ) <NEWLINE> queries . append ( ( k , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFindTree ( N ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i not in marked : <NEWLINE> <INDENT> p_root = uf . find ( parents [ i ] ) <NEWLINE> uf . par [ i ] = p_root <NEWLINE> uf . rank [ p_root ] = max ( uf . rank [ p_root ] , uf . par [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k , v in reversed ( queries ) : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> ans += uf . find ( v ) + 1 <NEWLINE> <DEDENT> elif not uf . same ( v , parents [ v ] ) : <NEWLINE> <INDENT> p_root = uf . find ( parents [ v ] ) <NEWLINE> uf . par [ v ] = p_root <NEWLINE> uf . rank [ p_root ] = max ( uf . rank [ p_root ] , uf . par [ v ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> li = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> m , last , ans , lm = 10 , li [ 0 ] , 0 , 0 <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> l = li [ i ] <NEWLINE> if 0 < l % 10 < m : <NEWLINE> <INDENT> m = l % 10 <NEWLINE> last = l <NEWLINE> lm = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> l = li [ i ] <NEWLINE> if l == last and i == lm : <NEWLINE> <INDENT> ans += l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . ceil ( l / 10 ) * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> d = { 1 : 0 } <NEWLINE> q = [ 1 ] <NEWLINE> for i in q : <NEWLINE> <INDENT> for j in g [ i ] : <NEWLINE> <INDENT> if j not in d : <NEWLINE> <INDENT> d [ j ] = i <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> prime = [ ] <NEWLINE> insu = { } <NEWLINE> max_itr = math . ceil ( math . sqrt ( n ) ) + 1 <NEWLINE> try_range = [ 2 ] + list ( range ( 3 , max_itr , 2 ) ) <NEWLINE> for i in try_range : <NEWLINE> <INDENT> if i > max_itr : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for p in prime : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> if i in insu : <NEWLINE> <INDENT> insu [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insu [ i ] = 1 <NEWLINE> <DEDENT> n //= i <NEWLINE> <DEDENT> if n < max_itr : <NEWLINE> <INDENT> max_itr = n <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> insu [ n ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for v in insu . values ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while v >= i : <NEWLINE> <INDENT> v -= i <NEWLINE> i += 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> N = len ( s ) <NEWLINE> array = [ 0 ] * 2019 <NEWLINE> array [ 0 ] += 1 <NEWLINE> count = 0 <NEWLINE> d = 1 <NEWLINE> r = 0 <NEWLINE> for i in reversed ( range ( 0 , N ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> r = ( r + int ( s [ i ] ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> array [ r ] += 1 <NEWLINE> <DEDENT> for i in array : <NEWLINE> <INDENT> count += i * ( i - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( count ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for k in range ( K , N + 2 ) : <NEWLINE> <INDENT> min_num = ( ( k - 1 ) * k ) / 2 <NEWLINE> max_num = ( N * ( N + 1 ) ) / 2 - ( ( N - k ) * ( N - k + 1 ) ) / 2 <NEWLINE> ans += max_num - min_num + 1 <NEWLINE> <DEDENT> print ( int ( ans % mod ) ) <NEWLINE>
from numpy import * <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = ( N - K + 1 ) * [ 0 ] <NEWLINE> R = sum ( P [ 0 : K ] ) <NEWLINE> Q [ 0 ] = R <NEWLINE> <NL> for n in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> R += P [ n - 1 + K ] - P [ n - 1 ] <NEWLINE> Q [ n ] = R <NEWLINE> <NL> <DEDENT> S = argmax ( Q ) <NEWLINE> print ( 0.5 * ( sum ( P [ S : S + K ] ) + K ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> res = 1 <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> res *= arr [ i ] <NEWLINE> <DEDENT> if arr [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> answer = 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> answer = answer * a [ i ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r , g , b = S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) <NEWLINE> total = r * g * b <NEWLINE> <NL> count = 0 <NEWLINE> for d in range ( 1 , N ) : <NEWLINE> <INDENT> for i in range ( N - 2 * d ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + d ] and S [ i + d ] != S [ i + 2 * d ] and S [ i + 2 * d ] != S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total - count ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ret = [ 0 for _ in range ( 1 , n + 1 ) ] <NEWLINE> def f ( x , y , z ) : <NEWLINE> <INDENT> return x * x + y * y + z * z + x * y + y * z + x * z <NEWLINE> <NL> <DEDENT> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if f ( x , y , z ) > n : <NEWLINE> <INDENT> z = 1 <NEWLINE> break <NEWLINE> <DEDENT> ret [ f ( x , y , z ) - 1 ] += 1 <NEWLINE> <DEDENT> if f ( x , y , z ) > n : <NEWLINE> <INDENT> y = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f ( x , y , z ) > n : <NEWLINE> <INDENT> x = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ret : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> maxa = max ( a ) <NEWLINE> cnt = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> num [ i * cnt ] += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cnt = 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if num [ a [ i ] ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for _ in range ( h ) : print ( <STRING> * w ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N < B ) : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> print ( int ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) ) <NEWLINE>
S = lambda : input ( ) <NEWLINE> I = lambda : int ( input ( ) ) <NEWLINE> L = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , k = L ( ) <NEWLINE> a = L ( ) <NEWLINE> visited = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> now = 0 <NEWLINE> visited [ 0 ] = 1 <NEWLINE> loopat = - 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = i + 2 <NEWLINE> now = a [ now ] - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if visited [ now ] == 0 : <NEWLINE> <INDENT> visited [ now ] = i + 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loopat = now <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if loopat == - 1 : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif tmp - visited [ loopat ] == 0 : <NEWLINE> <INDENT> tmp2 = k <NEWLINE> dist = 1 <NEWLINE> now = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp2 = ( k - ( visited [ loopat ] - 1 ) ) % ( tmp - visited [ loopat ] ) <NEWLINE> dist = loopat + 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( tmp2 ) : <NEWLINE> <INDENT> now = a [ now ] - 1 <NEWLINE> dist = now + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( dist ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> K = list ( str ( input ( ) ) ) <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if K [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> if K [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> if K [ i ] == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( ( N - 3 - i ) // 2 + 1 ) : <NEWLINE> <INDENT> if K [ i ] != K [ i + j + 1 ] : <NEWLINE> <INDENT> if K [ i + j + 1 ] != K [ i + j + j + 2 ] : <NEWLINE> <INDENT> if K [ i + j + j + 2 ] != K [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( R * G * B - count ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> order = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> tmp += int ( i ) * order <NEWLINE> mods [ tmp % 2019 ] += 1 <NEWLINE> order *= 10 <NEWLINE> order %= 2019 <NEWLINE> <DEDENT> ans = sum ( n * ( n - 1 ) // 2 for n in mods ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> if ( b - 1 ) <= n : <NEWLINE> <INDENT> t = ( a * ( b - 1 ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( a * n ) // b <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( t ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += d [ i + 1 - p [ i ] ] <NEWLINE> d [ i + 1 + p [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> NL = [ ] <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> NL . append ( i ) <NEWLINE> <NL> <DEDENT> for l in L : <NEWLINE> <INDENT> NL . remove ( l ) <NEWLINE> <NL> <DEDENT> NL . append ( X ) <NEWLINE> NL . sort ( ) <NEWLINE> <NL> LR = NL . index ( X ) + 1 <NEWLINE> LL = NL . index ( X ) - 1 <NEWLINE> <NL> <NL> if ( NL [ LR ] - X ) < ( X - NL [ LL ] ) : <NEWLINE> <INDENT> print ( NL [ LR ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NL [ LL ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) ; <NEWLINE> <NL> <DEDENT> A = deque ( A ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> ans_right = A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_right = 1 <NEWLINE> <NL> <DEDENT> ans_left = 1 <NEWLINE> <NL> for i in range ( N // 2 ) : <NEWLINE> <INDENT> right = A . pop ( ) <NEWLINE> left = A . popleft ( ) <NEWLINE> <NL> ans_right = ans_right * right <NEWLINE> ans_left = ans_left * left <NEWLINE> <NL> if ans_right > 10 ** 18 or ans_left > 10 ** 18 or ans_left * ans_right > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_right * ans_left ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> cost = A [ i ] <NEWLINE> c = i <NEWLINE> if cost > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost = k - cost <NEWLINE> c += bisect . bisect_right ( B , cost ) - 1 <NEWLINE> if c > ans : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> ai = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> if ai == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> print ( a * x // b ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> checkNum = [ 0 for j in range ( 102 ) ] <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> checkNum [ p [ i ] ] = 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> while ( X - i >= 0 or X + i <= 101 ) : <NEWLINE> <INDENT> if X - i >= 0 : <NEWLINE> <INDENT> if checkNum [ X - i ] == 0 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if X + i <= 101 : <NEWLINE> <INDENT> if checkNum [ X + i ] == 0 : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> aa = [ 0 ] <NEWLINE> bb = [ 0 ] <NEWLINE> <NL> for s in range ( n ) : <NEWLINE> <INDENT> aa . append ( aa [ s ] + a [ s ] ) <NEWLINE> <DEDENT> for s in range ( m ) : <NEWLINE> <INDENT> bb . append ( bb [ s ] + b [ s ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while bb [ j ] > k - aa [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> for j in range ( 15 ) : <NEWLINE> <INDENT> if 4 * i + 7 * j == n : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> ans3 = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k and j <= s - i - j : <NEWLINE> <INDENT> if i == j == s - i - j : <NEWLINE> <INDENT> ans1 += 1 <NEWLINE> <DEDENT> elif i == s - i - j or i == j or j == s - i - j : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans3 += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans1 + ans2 * 3 + ans3 * 6 ) <NEWLINE> <COMMENT> <NL>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> c = collections . Counter ( l ) <NEWLINE> ans = 0 <NEWLINE> <NL> for x , y in c . items ( ) : <NEWLINE> <INDENT> if y % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( w , h ) : <NEWLINE> <INDENT> w2 = w + 2 <NEWLINE> la = [ <STRING> * w2 ] <NEWLINE> ra = [ <STRING> * w2 ] <NEWLINE> ls = rs = None <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> lt , rt = LS ( ) <NEWLINE> if <STRING> in lt : <NEWLINE> <INDENT> ls = ( i , lt . index ( <STRING> ) + 1 ) <NEWLINE> <DEDENT> if <STRING> in rt : <NEWLINE> <INDENT> rs = ( i , rt . index ( <STRING> ) + 1 ) <NEWLINE> <DEDENT> la . append ( <STRING> + lt + <STRING> ) <NEWLINE> ra . append ( <STRING> + rt + <STRING> ) <NEWLINE> <DEDENT> la . append ( <STRING> * w2 ) <NEWLINE> ra . append ( <STRING> * w2 ) <NEWLINE> <NL> q = collections . deque ( [ ( ls [ 0 ] , ls [ 1 ] , rs [ 0 ] , rs [ 1 ] ) ] ) <NEWLINE> v = collections . defaultdict ( bool ) <NEWLINE> v [ ( ls [ 0 ] , ls [ 1 ] , rs [ 0 ] , rs [ 1 ] ) ] = 1 <NEWLINE> while q : <NEWLINE> <INDENT> ly , lx , ry , rx = q . pop ( ) <NEWLINE> for dy , dx in dd : <NEWLINE> <INDENT> lty = ly + dy <NEWLINE> ltx = lx + dx <NEWLINE> rty = ry + dy <NEWLINE> rtx = rx - dx <NEWLINE> if la [ lty ] [ ltx ] == <STRING> : <NEWLINE> <INDENT> lty = ly <NEWLINE> ltx = lx <NEWLINE> <DEDENT> if ra [ rty ] [ rtx ] == <STRING> : <NEWLINE> <INDENT> rty = ry <NEWLINE> rtx = rx <NEWLINE> <DEDENT> if v [ ( lty , ltx , rty , rtx ) ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v [ ( lty , ltx , rty , rtx ) ] = 1 <NEWLINE> if la [ lty ] [ ltx ] == <STRING> and ra [ rty ] [ rtx ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if la [ lty ] [ ltx ] != <STRING> and ra [ rty ] [ rtx ] != <STRING> : <NEWLINE> <INDENT> q . append ( ( lty , ltx , rty , rtx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = LI ( ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( w , h ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( rr ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
s = str ( input ( ) ) <NEWLINE> count = [ ] <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> count . append ( x ) <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> count . append ( x ) <NEWLINE> x = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( count ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def cumsum ( K , A , cA ) : <NEWLINE> <INDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> cA [ i ] += cA [ i - 1 ] + A [ i ] <NEWLINE> if cA [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> cA = cA [ cA != 0 ] <NEWLINE> cA = np . append ( 0 , cA ) <NEWLINE> return cA <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( K , cA , cB ) : <NEWLINE> <INDENT> ans = np . searchsorted ( cA , K - cB , side = <STRING> ) - 1 <NEWLINE> ans += np . arange ( len ( cB ) ) <NEWLINE> return ans . max ( ) <NEWLINE> <NL> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> B = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> cA = np . zeros ( N , dtype = np . int64 ) <NEWLINE> cB = np . zeros ( M , dtype = np . int64 ) <NEWLINE> <NL> <COMMENT> <NL> cA = cumsum ( K , A , cA ) <NEWLINE> cB = cumsum ( K , B , cB ) <NEWLINE> <NL> ans = solve ( K , cA , cB ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K , Q , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> if Q >= K + b : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for n in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % n == 0 : <NEWLINE> <INDENT> for a in range ( int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if 5 * a ** 4 - 10 * a ** 3 * n + 10 * a ** 2 * n ** 2 - 5 * a * n ** 3 + n ** 4 == x // n : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( a - n ) ) <NEWLINE> break <NEWLINE> <DEDENT> a = - a <NEWLINE> if 5 * a ** 4 - 10 * a ** 3 * n + 10 * a ** 2 * n ** 2 - 5 * a * n ** 3 + n ** 4 == x // n : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( a - n ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
import queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> root = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> root [ 0 ] = 1 <NEWLINE> count += 1 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> p = q . get ( ) <NEWLINE> for i in g [ p + 1 ] : <NEWLINE> <INDENT> if root [ i - 1 ] <= 0 : <NEWLINE> <INDENT> q . put ( i - 1 ) <NEWLINE> root [ i - 1 ] = p + 1 <NEWLINE> count += 1 <NEWLINE> <COMMENT> <NL> if count >= n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count < n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( root [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ - 1 for _ in range ( q ) ] <NEWLINE> c = [ - 1 for _ in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def innerproduct ( d ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for key , value in d . items ( ) : <NEWLINE> <INDENT> ans += int ( key ) * int ( value ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> d = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if b [ i ] in d : <NEWLINE> <INDENT> ans -= b [ i ] * d [ b [ i ] ] <NEWLINE> tmp = d [ b [ i ] ] <NEWLINE> if c [ i ] not in d : <NEWLINE> <INDENT> d [ c [ i ] ] = d [ b [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c [ i ] ] += d [ b [ i ] ] <NEWLINE> <DEDENT> d [ b [ i ] ] = 0 <NEWLINE> ans += tmp * c [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
class CountingSort : <NEWLINE> <INDENT> def countingSort ( self , a , b , k ) : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> c = [ 0 ] * ( k + 1 ) <NEWLINE> for j in a : <NEWLINE> <INDENT> c [ j ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i ] + c [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in a [ : : - 1 ] : <NEWLINE> <INDENT> b [ c [ j ] ] = j <NEWLINE> c [ j ] -= 1 <NEWLINE> <DEDENT> return b [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> k = max ( a ) <NEWLINE> x = CountingSort ( ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in x . countingSort ( a , b , k ) ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> s = set ( [ a , b , c ] ) <NEWLINE> if len ( s ) == 3 : <NEWLINE> <INDENT> result += 6 * math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> if len ( s ) == 2 : <NEWLINE> <INDENT> result += 3 * math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> result += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . bit = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def sumB ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while ( i > 0 ) : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def addB ( self , i , x ) : <NEWLINE> <INDENT> while ( i < len ( self . bit ) ) : <NEWLINE> <INDENT> self . bit [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ ( i + 1 , int ( j ) ) for i , j in enumerate ( input ( ) . split ( ) ) ] <NEWLINE> A = sorted ( A , key = lambda x : x [ 1 ] ) <NEWLINE> b = BIT ( n ) <NEWLINE> for i in range ( n ) : b . addB ( i + 1 , 1 ) <NEWLINE> ans = 0 <NEWLINE> for i , j in A : <NEWLINE> <INDENT> ans += b . sumB ( i ) <NEWLINE> b . addB ( i , - 1 ) <NEWLINE> <DEDENT> print ( ans - n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> flag = False <NEWLINE> for num in nums : <NEWLINE> <INDENT> s = s * num <NEWLINE> if s > limit : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> if 0 not in nums : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> mul_a = 0 <NEWLINE> mod = 1000000007 <NEWLINE> <NL> for a in a_s : <NEWLINE> <INDENT> sum_a += a <NEWLINE> mul_a += a * a <NEWLINE> sum_a %= mod <NEWLINE> mul_a %= mod <NEWLINE> <NL> <DEDENT> ans = sum_a * sum_a <NEWLINE> ans %= mod <NEWLINE> ans -= mul_a <NEWLINE> ans %= mod <NEWLINE> <NL> n = mod - 2 <NEWLINE> inv = 1 <NEWLINE> base = 2 <NEWLINE> <NL> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> inv = inv * base % mod <NEWLINE> <DEDENT> base = base * base % mod <NEWLINE> n >>= 1 <NEWLINE> <NL> <DEDENT> ans *= inv <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> A = int ( s [ 0 ] ) <NEWLINE> B = int ( s [ 1 ] ) <NEWLINE> C = int ( s [ 2 ] ) <NEWLINE> D = int ( s [ 3 ] ) <NEWLINE> <NL> flag = [ 0 ] * 3 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> flag [ 0 ] = ( i >> 2 ) & 1 <NEWLINE> flag [ 1 ] = ( i >> 1 ) & 1 <NEWLINE> flag [ 2 ] = ( i ) & 1 <NEWLINE> <NL> tmp = A + ( - 1 ) ** flag [ 0 ] * B + ( - 1 ) ** flag [ 1 ] * C + ( - 1 ) ** flag [ 2 ] * D <NEWLINE> if tmp == 7 : <NEWLINE> <INDENT> ans = s [ 0 ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if flag [ j ] : <NEWLINE> <INDENT> ans += <STRING> + s [ j + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> + s [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> ans += <STRING> <NEWLINE> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X , K , D = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if D * K < abs ( X ) : <NEWLINE> <INDENT> print ( abs ( X ) - D * K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - abs ( X ) // D ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) % D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - abs ( X ) % D ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ a + i for i , a in enumerate ( A ) ] <NEWLINE> C = [ j - a for j , a in enumerate ( A ) ] <NEWLINE> B , C = Counter ( B ) , Counter ( C ) <NEWLINE> ans = 0 <NEWLINE> for k in B . keys ( ) : <NEWLINE> <INDENT> ans += B [ k ] * C [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> for i in range ( h - 1 ) : <NEWLINE> <INDENT> for j in range ( w - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j : j + 2 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> if a [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , w ) : <NEWLINE> <INDENT> if a [ i ] [ k ] == <STRING> : <NEWLINE> <INDENT> if a [ i + 1 ] [ k - 2 : k ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a [ h - 2 ] [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if a [ h - 1 ] [ - 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a = float ( input ( ) ) <NEWLINE> <NL> S = round ( a * a * math . pi , 6 ) <NEWLINE> R = round ( a * 2 * math . pi , 6 ) <NEWLINE> <NL> print ( S , R ) <NEWLINE>
import numba <NEWLINE> <NL> @ numba . njit <NEWLINE> def main ( N ) : <NEWLINE> <INDENT> dp = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while i * k <= N : <NEWLINE> <INDENT> dp [ i * k ] += 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * dp [ i ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( main ( N ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ ( a [ i ] - i - 1 ) for i in range ( n ) ] <NEWLINE> b = sorted ( b ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> res = b [ ( n - 1 ) // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = ( b [ n // 2 - 1 ] + b [ n // 2 ] ) // 2 <NEWLINE> <NL> <DEDENT> print ( sum ( map ( abs , [ b [ i ] - res for i in range ( n ) ] ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> time = sum ( A ) <NEWLINE> count = len ( A ) <NEWLINE> ans = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( N , - 1 , - 1 ) : <NEWLINE> <INDENT> if i != N : <NEWLINE> <INDENT> time -= A [ i ] <NEWLINE> count -= 1 <NEWLINE> <DEDENT> if time > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if time <= K and j < M : <NEWLINE> <INDENT> while time + B [ j ] <= K : <NEWLINE> <INDENT> time += B [ j ] <NEWLINE> j += 1 <NEWLINE> count += 1 <NEWLINE> if j >= M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from math import gcd <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> M = pow ( 10 , 6 ) + 1 <NEWLINE> divs = [ False ] * M <NEWLINE> cnt = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if divs [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if i == N - 1 or a != A [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> acc = a <NEWLINE> while acc < M : <NEWLINE> <INDENT> divs [ acc ] = True <NEWLINE> acc += a <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import defaultdict <NEWLINE> import numpy as np <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = defaultdict ( int ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for index , A in enumerate ( As ) : <NEWLINE> <INDENT> ans += B [ index - A ] <NEWLINE> <NL> B [ index + A ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def loop ( i ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> N = int ( ( i * 2 ) ** ( 1 / 2 ) ) + 1 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if ( j + k ) ** 2 + ( k + l ) ** 2 + ( l + j ) ** 2 == 2 * i : <NEWLINE> <INDENT> if j == k == l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif j > k > l : <NEWLINE> <INDENT> ans += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 3 <NEWLINE> <DEDENT> <DEDENT> if ( j + k ) ** 2 + ( k + l ) ** 2 + ( l + j ) ** 2 >= 2 * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( j + k ) ** 2 > 2 * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( ans ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( loop ( i ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> maxi = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans += max ( 0 , maxi - i ) <NEWLINE> maxi = max ( maxi , i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> l = len ( t ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> print ( t [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def depth ( adj , node , parent = None ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for child in adj [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = depth ( adj , child , node ) + 1 <NEWLINE> ret = max ( ret , d ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , U , V = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> U -= 1 <NEWLINE> V -= 1 <NEWLINE> adj = defaultdict ( list ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( <STRING> ) ) ) <NEWLINE> adj [ A ] . append ( B ) <NEWLINE> adj [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> path = [ - 1 ] * N <NEWLINE> <NL> def find_path_on_tree ( to_node , node , parent = None , d = 0 ) : <NEWLINE> <INDENT> if node == to_node : <NEWLINE> <INDENT> path [ d ] = node <NEWLINE> return True <NEWLINE> <DEDENT> for child in adj [ node ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not find_path_on_tree ( to_node , child , node , d + 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> path [ d ] = node <NEWLINE> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> find_path_on_tree ( U , V ) <COMMENT> <NEWLINE> path = [ node for node in path if node != - 1 ] <NEWLINE> dist = len ( path ) - 1 <NEWLINE> partial_depth = depth ( adj , path [ ( dist // 2 ) + 1 ] , path [ dist // 2 ] ) <NEWLINE> print ( partial_depth + ( dist // 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s1 = sum ( a ) <NEWLINE> s2 = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s2 += a [ i ] <NEWLINE> ans += a [ i ] * ( s1 - s2 ) <NEWLINE> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> if str ( i ) in s [ : - 2 ] : <NEWLINE> <INDENT> index_1 = s . index ( str ( i ) ) <NEWLINE> <NL> for j in range ( 0 , 10 ) : <NEWLINE> <INDENT> if str ( j ) in s [ index_1 + 1 : - 1 ] : <NEWLINE> <INDENT> index_2 = s [ index_1 + 1 : - 1 ] . index ( str ( j ) ) + index_1 + 1 <NEWLINE> <NL> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> if str ( k ) in s [ index_2 + 1 : ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = x * k <NEWLINE> if a % 360 == 0 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> M_sorted = [ <STRING> . join ( sorted ( m ) ) for m in M ] <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> <NL> for m in M_sorted : <NEWLINE> <INDENT> d . setdefault ( m , 0 ) <NEWLINE> ans += d [ m ] <NEWLINE> d [ m ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import fractions <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> return int ( a * b / fractions . gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print ( int ( fractions . gcd ( a , b ) ) , lcm ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for p in range ( k ) : <NEWLINE> <INDENT> for q in range ( k ) : <NEWLINE> <INDENT> g = math . gcd ( p + 1 , q + 1 ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> r = math . gcd ( g , i + 1 ) <NEWLINE> s = s + r <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math as m <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> if N > 5 : <NEWLINE> <INDENT> for x in range ( 1 , int ( m . sqrt ( N - 5 ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + x * y + x + y + 1 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + x * y + x * z + y * z + z ** 2 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( list ( set ( [ x , y , z ] ) ) ) == 3 : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + x * y + x * z + y * z + z ** 2 - 1 ] += 6 <NEWLINE> <DEDENT> elif len ( list ( set ( [ x , y , z ] ) ) ) == 2 : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + x * y + x * z + y * z + z ** 2 - 1 ] += 3 <NEWLINE> <DEDENT> elif len ( list ( set ( [ x , y , z ] ) ) ) == 1 : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + x * y + x * z + y * z + z ** 2 - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
line = list ( input ( ) ) <NEWLINE> for k , v in enumerate ( line ) : <NEWLINE> <INDENT> line [ k ] = v . swapcase ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( line ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> max_cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for div in range ( 0 , 7 ) : <NEWLINE> <INDENT> if n % 2 ** div == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt > max_cnt : <NEWLINE> <INDENT> max_cnt = cnt <NEWLINE> ans = n <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = int ( math . sqrt ( n ) + 1 ) <NEWLINE> a = [ ] <NEWLINE> for x in range ( 1 , m ) : <NEWLINE> <INDENT> for y in range ( 1 , m ) : <NEWLINE> <INDENT> for z in range ( 1 , m ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= n : <NEWLINE> <INDENT> a . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = [ LS ( ) for _ in range ( n ) ] <NEWLINE> d = collections . defaultdict ( int ) <NEWLINE> ed = collections . defaultdict ( lambda : None ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , di = a [ i ] <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> d [ ( x , y ) ] = i + 1 <NEWLINE> if di == <STRING> : <NEWLINE> <INDENT> d [ ( x + 1 , y ) ] = i + 1 <NEWLINE> ed [ ( x , y ) ] = ( x + 1 , y ) <NEWLINE> ed [ ( x + 1 , y ) ] = ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( x , y + 1 ) ] = i + 1 <NEWLINE> ed [ ( x , y ) ] = ( x , y + 1 ) <NEWLINE> ed [ ( x , y + 1 ) ] = ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> ee = collections . defaultdict ( set ) <NEWLINE> dka = list ( d . keys ( ) ) <NEWLINE> for x , y in list ( d . keys ( ) ) : <NEWLINE> <INDENT> dt = d [ ( x , y ) ] <NEWLINE> for di , dj in dd : <NEWLINE> <INDENT> ni = x + di <NEWLINE> nj = y + dj <NEWLINE> if d [ ( ni , nj ) ] > 0 and d [ ( ni , nj ) ] != dt : <NEWLINE> <INDENT> ee [ ( x , y ) ] . add ( ( ni , nj ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> v = collections . defaultdict ( bool ) <NEWLINE> f = True <NEWLINE> for k in dka : <NEWLINE> <INDENT> if v [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s1 = set ( ) <NEWLINE> s2 = set ( ) <NEWLINE> ns1 = set ( [ k ] ) <NEWLINE> ns2 = set ( ) <NEWLINE> while ns1 : <NEWLINE> <INDENT> na = list ( ns1 ) <NEWLINE> s1 |= ns1 <NEWLINE> ns1 = set ( ) <NEWLINE> for k in na : <NEWLINE> <INDENT> ns1 |= ee [ k ] <NEWLINE> ns2 . add ( ed [ k ] ) <NEWLINE> <DEDENT> ns2 -= s2 <NEWLINE> <NL> while ns2 : <NEWLINE> <INDENT> na = list ( ns2 ) <NEWLINE> s2 |= ns2 <NEWLINE> ns2 = set ( ) <NEWLINE> for k in na : <NEWLINE> <INDENT> ns2 |= ee [ k ] <NEWLINE> ns1 . add ( ed [ k ] ) <NEWLINE> <DEDENT> ns2 -= s2 <NEWLINE> <NL> <DEDENT> ns1 -= s1 <NEWLINE> <NL> <DEDENT> if s1 & s2 : <NEWLINE> <INDENT> f = False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if f : <NEWLINE> <INDENT> for k in s1 : <NEWLINE> <INDENT> v [ k ] = 1 <NEWLINE> <DEDENT> for k in s2 : <NEWLINE> <INDENT> v [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
class Residents : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . official_house = [ ] <NEWLINE> <NL> for b in range ( 4 ) : <NEWLINE> <INDENT> self . official_house . append ( [ ] ) <NEWLINE> for f in range ( 3 ) : <NEWLINE> <INDENT> self . official_house [ b ] . append ( [ ] ) <NEWLINE> for r in range ( 10 ) : <NEWLINE> <INDENT> self . official_house [ b ] [ f ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def move_in ( self , building , floor , room , num ) : <NEWLINE> <INDENT> building -= 1 <NEWLINE> floor -= 1 <NEWLINE> room -= 1 <NEWLINE> if self . official_house [ building ] [ floor ] [ room ] + num > 9 : <NEWLINE> <INDENT> self . official_house [ building ] [ floor ] [ room ] = 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . official_house [ building ] [ floor ] [ room ] += num <NEWLINE> <NL> <DEDENT> <DEDENT> def move_out ( self , building , floor , room , num ) : <NEWLINE> <INDENT> building -= 1 <NEWLINE> floor -= 1 <NEWLINE> room -= 1 <NEWLINE> if self . official_house [ building ] [ floor ] [ room ] < num : <NEWLINE> <INDENT> self . official_house [ building ] [ floor ] [ room ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . official_house [ building ] [ floor ] [ room ] -= num <NEWLINE> <NL> <DEDENT> <DEDENT> def show ( self , building , floor , room ) : <NEWLINE> <INDENT> building -= 1 <NEWLINE> floor -= 1 <NEWLINE> room -= 1 <NEWLINE> return self . official_house [ building ] [ floor ] [ room ] <NEWLINE> <NL> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> for b in range ( 4 ) : <NEWLINE> <INDENT> if b > 0 : <NEWLINE> <INDENT> result += <STRING> * 20 + <STRING> <NEWLINE> <DEDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> result += <STRING> + str ( self . official_house [ b ] [ f ] [ r ] ) <NEWLINE> <DEDENT> result += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> residents = Residents ( ) <NEWLINE> rows = int ( input ( ) ) <NEWLINE> <NL> for i in range ( rows ) : <NEWLINE> <INDENT> ( b , f , r , num ) = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if num > 0 : <NEWLINE> <INDENT> residents . move_in ( b , f , r , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> residents . move_out ( b , f , r , num * - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( residents . output ( ) , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> <DEDENT> del ans [ 0 ] <NEWLINE> ans . append ( A . count ( N ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ct = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i * i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = int ( ( N - 1 ) / i ) <NEWLINE> ct += ( x - i ) * 2 + 1 <NEWLINE> <DEDENT> print ( ct ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> A , B , N = map ( int , pin ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> ans = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> a = set ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a . add ( s [ i : i + j ] ) <NEWLINE> <DEDENT> <DEDENT> a = sorted ( a ) <NEWLINE> print ( a [ k - 1 ] ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lww = 0 <NEWLINE> lee = s [ 1 : ] . count ( <STRING> ) <NEWLINE> ans = lww + lee <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> lee -= 1 <NEWLINE> <DEDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> lww += 1 <NEWLINE> <NL> <DEDENT> ans = min ( ans , lee + lww ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> sum = 0 <NEWLINE> K = int ( input ( ) ) + 1 <NEWLINE> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( 1 , K ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K ) : <NEWLINE> <INDENT> sum += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = N // i <NEWLINE> y = i * x * ( x + 1 ) / 2 <NEWLINE> A . append ( y ) <NEWLINE> <DEDENT> print ( int ( sum ( A ) ) ) <NEWLINE>
def cal ( ) : <NEWLINE> <INDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 2 ** d ) : <NEWLINE> <INDENT> b = [ <STRING> ] * d <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> b [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> count0 , count1 = 0 , 0 <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> count0 += 100 * ( j + 1 ) * a [ j ] [ 0 ] + a [ j ] [ 1 ] <NEWLINE> count1 += a [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if count0 < g : <NEWLINE> <INDENT> for j in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( a [ j ] [ 0 ] ) : <NEWLINE> <INDENT> if count0 >= g : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count0 += 100 * ( j + 1 ) <NEWLINE> count1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , count1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> cal ( ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> K1 = K + 1 <NEWLINE> tgt = 0 <NEWLINE> for i in range ( 1 , K1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K1 ) : <NEWLINE> <INDENT> tgt += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tgt ) <NEWLINE>
from heapq import heapify , heappush , heappop <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> tmp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> U = [ 0 for _ in range ( M ) ] <NEWLINE> V = [ 0 for _ in range ( M ) ] <NEWLINE> A = [ 0 for _ in range ( M ) ] <NEWLINE> B = [ 0 for _ in range ( M ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> U [ i ] = tmp [ i ] [ 0 ] - 1 <NEWLINE> V [ i ] = tmp [ i ] [ 1 ] - 1 <NEWLINE> A [ i ] = tmp [ i ] [ 2 ] <NEWLINE> B [ i ] = tmp [ i ] [ 3 ] <NEWLINE> <DEDENT> A_m = max ( A ) <NEWLINE> S = min ( N * A_m , S ) <NEWLINE> <COMMENT> <NL> <NL> I = [ [ ] for _ in range ( N * ( N * A_m + 1 ) ) ] <NEWLINE> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( A [ i ] , N * A_m + 1 ) : <NEWLINE> <INDENT> I [ U [ i ] * ( N * A_m + 1 ) + j ] . append ( ( V [ i ] * ( N * A_m + 1 ) + j - A [ i ] , B [ i ] ) ) <NEWLINE> I [ V [ i ] * ( N * A_m + 1 ) + j ] . append ( ( U [ i ] * ( N * A_m + 1 ) + j - A [ i ] , B [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( N * A_m + 1 ) : <NEWLINE> <INDENT> I [ i * ( N * A_m + 1 ) + j ] . append ( ( i * ( N * A_m + 1 ) + min ( C + j , N * A_m ) , D ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def dijkstra ( I ) : <COMMENT> <NEWLINE> <INDENT> N = len ( I ) <NEWLINE> task = [ ] <NEWLINE> visited = [ 0 for _ in range ( N ) ] <NEWLINE> min_cost = [ 0 for _ in range ( N ) ] <NEWLINE> cost = [ 10 ** 20 for _ in range ( N ) ] <NEWLINE> prev_points = [ 0 for _ in range ( N ) ] <NEWLINE> heappush ( task , ( 0 , S , - 1 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> flag = 0 <NEWLINE> while task : <NEWLINE> <INDENT> while task : <NEWLINE> <INDENT> c , p , prev = heappop ( task ) <NEWLINE> if visited [ p ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( task ) == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> visited [ p ] = 1 <NEWLINE> min_cost [ p ] = c <NEWLINE> prev_points [ p ] = prev <NEWLINE> <NL> for j , c_ad in I [ p ] : <COMMENT> <NEWLINE> <INDENT> if visited [ j ] == 1 : continue <NEWLINE> <COMMENT> <NL> cost_next = next_cost ( I , p , j , c , c_ad ) <NEWLINE> if cost [ j ] > cost_next : <NEWLINE> <INDENT> cost [ j ] = cost_next <NEWLINE> heappush ( task , ( cost_next , j , p ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ( min_cost , prev_points ) <NEWLINE> <NL> <DEDENT> def next_cost ( I , p , j , c , c_ad ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> return c + c_ad <NEWLINE> <NL> <DEDENT> min_cost , prev_points = dijkstra ( I ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( min_cost [ i * ( N * A_m + 1 ) : ( i + 1 ) * ( N * A_m + 1 ) ] ) ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> num = int ( str ) <NEWLINE> if num % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> j = 7 <NEWLINE> while j % num != 0 and i <= num : <NEWLINE> <INDENT> j = ( j % num ) * 10 + 7 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if i > num : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) ; <NEWLINE> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> judge = 0 <NEWLINE> dic = { } <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in dic : <NEWLINE> <INDENT> dic [ a [ i ] ] += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a [ i ] ] = b [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> dic = list ( dic . items ( ) ) <NEWLINE> dic . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> <NL> for i in range ( 10 ** 9 ) : <NEWLINE> <INDENT> if judge >= k : <NEWLINE> <INDENT> print ( dic [ i - 1 ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge += int ( dic [ i ] [ 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = sorted ( L ) <NEWLINE> <NL> ln = len ( L ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( ln - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ln - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , ln ) : <NEWLINE> <INDENT> if L [ i ] + L [ j ] > L [ k ] and L [ i ] != L [ j ] and L [ j ] != L [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Factorial ( ) : <NEWLINE> <INDENT> def __init__ ( self , n , mod ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . fct = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> self . inv = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> self . fct [ 0 ] = 1 <NEWLINE> self . inv [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> self . fct [ i + 1 ] = self . fct [ i ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> self . inv [ n ] = pow ( self . fct [ n ] , mod - 2 , mod ) <NEWLINE> for i in range ( n ) [ : : - 1 ] : <NEWLINE> <INDENT> self . inv [ i ] = self . inv [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def comb ( self , m , k ) : <NEWLINE> <INDENT> if m < k : return 0 <NEWLINE> return self . fct [ m ] * self . inv [ k ] * self . inv [ m - k ] % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 998244353 <NEWLINE> N , A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f = Factorial ( N , MOD ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( K - A * i ) % B == 0 : <NEWLINE> <INDENT> j = ( K - A * i ) // B <NEWLINE> if 0 <= j <= N : <NEWLINE> <INDENT> res += f . comb ( N , i ) * f . comb ( N , j ) <NEWLINE> res %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . add ( b - 1 ) <NEWLINE> tree [ b - 1 ] . add ( a - 1 ) <NEWLINE> <DEDENT> count = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> stack = [ [ 0 , 0 , - 1 ] ] <COMMENT> <NEWLINE> while stack : <NEWLINE> <INDENT> num , cnt , pr = stack . pop ( ) <NEWLINE> count [ num ] += cnt <NEWLINE> for k in tree [ num ] : <NEWLINE> <INDENT> if k == pr : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack . append ( [ k , count [ num ] , num ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * count ) <NEWLINE>
y = [ int ( z ) for z in input ( ) . split ( ) ] <NEWLINE> l = [ int ( z ) for z in input ( ) . split ( ) ] <NEWLINE> d = [ 0 ] * ( y [ 0 ] + 1 ) <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , y [ 0 ] + 1 ) : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] + l [ i - 1 ] <NEWLINE> if ( d [ i ] <= y [ 1 ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 5 ) <NEWLINE> for c in a : <NEWLINE> <INDENT> cnt [ c ] += 1 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> bdif = c - b <NEWLINE> s += cnt [ b ] * bdif <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sumA = [ 0 ] <NEWLINE> sumB = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> answer = 0 <NEWLINE> st = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp = tmp + A [ i ] <NEWLINE> sumA . append ( tmp ) <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp = tmp + B [ i ] <NEWLINE> sumB . append ( tmp ) <NEWLINE> <NL> <DEDENT> for i in range ( N , - 1 , - 1 ) : <NEWLINE> <INDENT> booktmp = 0 <NEWLINE> <NL> for j in range ( st , M + 1 ) : <NEWLINE> <NL> <INDENT> if sumA [ i ] + sumB [ j ] <= K : <NEWLINE> <INDENT> booktmp = i + j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> answer = max ( answer , booktmp ) <NEWLINE> if j == M : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop = [ ] <NEWLINE> trace = [ 0 ] * ( N + 1 ) <NEWLINE> visited = set ( ) <NEWLINE> <NL> ai = 1 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ai in visited : <NEWLINE> <INDENT> ind = trace . index ( ai ) <NEWLINE> loop = trace [ ind : i ] <NEWLINE> trace = trace [ : ind ] <NEWLINE> break <NEWLINE> <DEDENT> visited . add ( ai ) <NEWLINE> <NL> trace [ i ] = ai <COMMENT> <NEWLINE> ai = A_list [ ai - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if len ( trace ) > K : <NEWLINE> <INDENT> print ( trace [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = K - len ( trace ) <NEWLINE> ind = ind % len ( loop ) <NEWLINE> print ( loop [ ind ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = tuple ( [ int ( e ) for e in input ( ) . split ( ) ] ) <NEWLINE> arr = [ 0 ] + [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> seen = set ( ) <NEWLINE> actual = 1 <NEWLINE> seen . add ( 1 ) <NEWLINE> pos = [ 1 ] <NEWLINE> mp = { 1 : 1 } <NEWLINE> while k > 0 : <NEWLINE> <INDENT> actual = arr [ actual ] <NEWLINE> k -= 1 <NEWLINE> if actual in seen : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> seen . add ( actual ) <NEWLINE> pos . append ( actual ) <NEWLINE> mp [ actual ] = len ( pos ) <NEWLINE> <NL> <DEDENT> c = 1 + len ( pos ) - mp [ actual ] <NEWLINE> k = k % c <NEWLINE> print ( pos [ mp [ actual ] + k - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> boms = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <COMMENT> <NL> <NL> hBom = [ 0 ] * H <NEWLINE> wBom = [ 0 ] * W <NEWLINE> <NL> <COMMENT> <NL> for h , w in boms : <NEWLINE> <INDENT> hBom [ h - 1 ] += 1 <NEWLINE> wBom [ w - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> maxHBom = max ( hBom ) <NEWLINE> maxWBom = max ( wBom ) <NEWLINE> maxHBomIndex = [ index for index , h in enumerate ( hBom ) if h == maxHBom ] <NEWLINE> maxWBomIndex = [ index for index , w in enumerate ( wBom ) if w == maxWBom ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> boms = set ( boms ) <NEWLINE> for h in maxHBomIndex : <NEWLINE> <INDENT> for w in maxWBomIndex : <NEWLINE> <INDENT> if ( h + 1 , w + 1 ) not in boms : <NEWLINE> <INDENT> print ( maxHBom + maxWBom ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( maxHBom + maxWBom - 1 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = 7 % K <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> if i > 10 ** 6 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = a * b <NEWLINE> sum = a * 2 + b * 2 <NEWLINE> <NL> print ( s , sum ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n >= b : <NEWLINE> <INDENT> print ( ( ( a * ( - 1 ) ) // b ) - ( a * ( ( - 1 ) // b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( a * n ) // b ) - ( a * ( n // b ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> class Edge : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , v , w ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . w = w <NEWLINE> <NL> <DEDENT> def either ( self ) : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <DEDENT> def other ( self , v ) : <NEWLINE> <INDENT> if v == self . v : <NEWLINE> <INDENT> return self . w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , v ) : <NEWLINE> <INDENT> self . v = v <NEWLINE> self . _edges = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> <DEDENT> def add ( self , e ) : <NEWLINE> <INDENT> self . _edges [ e . v ] . append ( e ) <NEWLINE> self . _edges [ e . w ] . append ( e ) <NEWLINE> <NL> <DEDENT> def adj ( self , v ) : <NEWLINE> <INDENT> return self . _edges [ v ] <NEWLINE> <NL> <DEDENT> def edges ( self ) : <NEWLINE> <INDENT> for es in self . _edges : <NEWLINE> <INDENT> for e in es : <NEWLINE> <INDENT> yield e <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class HeavyLightDecomposition : <NEWLINE> <INDENT> class _Path : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . nodes = [ ] <NEWLINE> self . _index = None <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def head ( self ) : <NEWLINE> <INDENT> return self . nodes [ 0 ] <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def size ( self ) : <NEWLINE> <INDENT> return len ( self . nodes ) <NEWLINE> <NL> <DEDENT> def append ( self , v ) : <NEWLINE> <INDENT> self . nodes . append ( v ) <NEWLINE> <NL> <DEDENT> def index ( self , v ) : <NEWLINE> <INDENT> if self . _index is None : <NEWLINE> <INDENT> self . _index = { v : i for i , v in enumerate ( self . nodes ) } <NEWLINE> <DEDENT> return self . _index [ v ] <NEWLINE> <NL> <DEDENT> def next ( self , v ) : <NEWLINE> <INDENT> return self . nodes [ self . index ( v ) + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self , graph , root ) : <NEWLINE> <INDENT> self . _paths = { } <NEWLINE> self . _parent = [ root ] * graph . v <NEWLINE> self . _head = [ - 1 ] * graph . v <NEWLINE> self . _find_paths ( graph , root ) <NEWLINE> <NL> <DEDENT> def _find_paths ( self , graph , root ) : <NEWLINE> <INDENT> def create_path ( v ) : <NEWLINE> <INDENT> path = self . _Path ( ) <NEWLINE> u = v <NEWLINE> while u != - 1 : <NEWLINE> <INDENT> path . append ( u ) <NEWLINE> self . _head [ u ] = v <NEWLINE> u = heavy [ u ] <NEWLINE> <DEDENT> return path <NEWLINE> <NL> <DEDENT> size = [ 1 ] * graph . v <NEWLINE> maxsize = [ 0 ] * graph . v <NEWLINE> heavy = [ - 1 ] * graph . v <NEWLINE> visited = [ False ] * graph . v <NEWLINE> <NL> stack = [ root ] <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if not visited [ v ] : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> stack . append ( v ) <NEWLINE> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if not visited [ w ] : <NEWLINE> <INDENT> self . _parent [ w ] = v <NEWLINE> stack . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v != root : <NEWLINE> <INDENT> p = self . _parent [ v ] <NEWLINE> if size [ v ] > maxsize [ p ] : <NEWLINE> <INDENT> maxsize [ p ] = size [ v ] <NEWLINE> heavy [ p ] = v <NEWLINE> <DEDENT> size [ p ] += size [ v ] <NEWLINE> <DEDENT> for e in graph . adj ( v ) : <NEWLINE> <INDENT> w = e . other ( v ) <NEWLINE> if w != self . _parent [ v ] and w != heavy [ v ] : <NEWLINE> <INDENT> self . _paths [ w ] = create_path ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> self . _paths [ root ] = create_path ( root ) <NEWLINE> <NL> <DEDENT> def parent ( self , v ) : <NEWLINE> <INDENT> return self . _parent [ v ] <NEWLINE> <NL> <DEDENT> def paths ( self ) : <NEWLINE> <INDENT> return self . _paths . values ( ) <NEWLINE> <NL> <DEDENT> def get_path ( self , v ) : <NEWLINE> <INDENT> return self . _paths [ self . _head [ v ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class PathSum2 : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , graph , root ) : <NEWLINE> <INDENT> self . root = root <NEWLINE> self . hld = HeavyLightDecomposition ( graph , root ) <NEWLINE> self . rq = { p . head : RangeQuery ( p . size ) for p in self . hld . paths ( ) } <NEWLINE> <NL> <DEDENT> def add ( self , v , val ) : <NEWLINE> <INDENT> u = v <NEWLINE> while u != self . root : <NEWLINE> <INDENT> path = self . hld . get_path ( u ) <NEWLINE> head = path . head <NEWLINE> if head != self . root : <NEWLINE> <INDENT> i = path . index ( head ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = path . index ( path . next ( head ) ) <NEWLINE> <DEDENT> j = path . index ( u ) <NEWLINE> self . rq [ head ] . add ( i + 1 , j + 1 , val ) <NEWLINE> u = self . hld . parent ( head ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get ( self , v ) : <NEWLINE> <INDENT> weight = 0 <NEWLINE> u = v <NEWLINE> while u != self . root : <NEWLINE> <INDENT> path = self . hld . get_path ( u ) <NEWLINE> head = path . head <NEWLINE> i = path . index ( head ) <NEWLINE> j = path . index ( u ) <NEWLINE> weight += self . rq [ head ] . sum ( i + 1 , j + 1 ) <NEWLINE> u = self . hld . parent ( head ) <NEWLINE> <NL> <DEDENT> return weight <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> class BinaryIndexedTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . bit = [ 0 ] * ( self . size + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , i , v ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . bit [ i ] += v <NEWLINE> i += ( i & - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= ( i & - i ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class RangeQuery : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . bit1 = BinaryIndexedTree ( n + 1 ) <NEWLINE> self . bit2 = BinaryIndexedTree ( n + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , i , j , v ) : <NEWLINE> <INDENT> self . bit1 . add ( i , v * - i ) <NEWLINE> self . bit1 . add ( j + 1 , v * ( j + 1 ) ) <NEWLINE> self . bit2 . add ( i , v ) <NEWLINE> self . bit2 . add ( j + 1 , - v ) <NEWLINE> <NL> <DEDENT> def sum ( self , i , j ) : <NEWLINE> <INDENT> s = self . bit1 . sum ( j + 1 ) + ( j + 1 ) * self . bit2 . sum ( j + 1 ) <NEWLINE> s -= self . bit1 . sum ( i ) + i * self . bit2 . sum ( i ) <NEWLINE> return s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> g = Graph ( n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k , * cs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if k > 0 : <NEWLINE> <INDENT> for j in cs : <NEWLINE> <INDENT> g . add ( Edge ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ps = PathSum2 ( g , 0 ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> com , * args = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if com == 0 : <NEWLINE> <INDENT> u , val = args <NEWLINE> ps . add ( u , val ) <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> u , = args <NEWLINE> print ( ps . get ( u ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> s = list ( s ) <NEWLINE> <NL> k = r = b = g = count = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> rbg = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> print ( rbg - count ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> a1n = a . argmax ( ) <NEWLINE> a_s = sorted ( a ) <NEWLINE> a1 = a_s [ - 1 ] <NEWLINE> a2 = a_s [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == a1n : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
from heapq import heapify , heappop , heappush <NEWLINE> from operator import add <NEWLINE> <NL> SENTINEL = 100000 <NEWLINE> while True : <NEWLINE> <INDENT> n , m , s , g1 , g2 = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> g1 -= 1 <NEWLINE> g2 -= 1 <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pipes = [ set ( ) for _ in range ( n ) ] <NEWLINE> rpipes = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b1 , b2 , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b1 -= 1 <NEWLINE> b2 -= 1 <NEWLINE> pipes [ b1 ] . add ( ( c , b2 ) ) <NEWLINE> rpipes [ b2 ] . add ( ( c , b1 ) ) <NEWLINE> <NL> <DEDENT> dists = [ [ SENTINEL ] * n for _ in range ( 2 ) ] <NEWLINE> <NL> for i in ( 0 , 1 ) : <NEWLINE> <INDENT> g = ( g1 , g2 ) [ i ] <NEWLINE> dist = dists [ i ] <NEWLINE> dist [ g ] = 0 <NEWLINE> queue = list ( rpipes [ g ] ) <NEWLINE> heapify ( queue ) <NEWLINE> while queue : <NEWLINE> <INDENT> total_cost , base = heappop ( queue ) <NEWLINE> if dist [ base ] < SENTINEL : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ base ] = total_cost <NEWLINE> for next_cost , next_base in rpipes [ base ] : <NEWLINE> <INDENT> if dist [ next_base ] == SENTINEL : <NEWLINE> <INDENT> heappush ( queue , ( total_cost + next_cost , next_base ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dists = list ( map ( add , * dists ) ) <NEWLINE> <NL> current_best = dists [ s ] <NEWLINE> queue = list ( pipes [ s ] ) <NEWLINE> heapify ( queue ) <NEWLINE> visited = { s } <NEWLINE> while queue : <NEWLINE> <INDENT> total_cost , base = heappop ( queue ) <NEWLINE> if base in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( base ) <NEWLINE> current_best = min ( current_best , total_cost + dists [ base ] ) <NEWLINE> for next_cost , next_base in pipes [ base ] : <NEWLINE> <INDENT> if next_base not in visited : <NEWLINE> <INDENT> heappush ( queue , ( total_cost + next_cost , next_base ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( current_best ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i_ = s [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] == i_ : continue <NEWLINE> k = 2 * j - i <NEWLINE> j_ = s [ j ] <NEWLINE> if k >= n or s [ k ] == i_ or s [ k ] == j_ : continue <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans - cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr ) <COMMENT> <NEWLINE> ans = 1 <NEWLINE> for val in arr : <NEWLINE> <INDENT> ans *= val <COMMENT> <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> b = sorted ( a ) <NEWLINE> a1 = b [ - 1 ] <NEWLINE> a2 = b [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a1 : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ a * d , a * c , b * c , b * d ] <NEWLINE> print ( max ( l ) ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> a . insert ( 0 , 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> <NL> data = input ( ) . split ( ) <NEWLINE> data . reverse ( ) <NEWLINE> print ( <STRING> . join ( data ) ) <NEWLINE>
x , k , d = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> k = int ( k ) <NEWLINE> d = int ( d ) <NEWLINE> if ( abs ( x ) > k * d ) : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = abs ( x ) // d <NEWLINE> a = abs ( x ) % d <NEWLINE> k = k - i <NEWLINE> if ( k == 0 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif ( k % 2 == 0 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( a - d ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
P = 2019 <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = 0 <NEWLINE> <NL> rem = [ 0 ] * P <NEWLINE> mod = 0 <NEWLINE> ten = 1 <NEWLINE> rem [ mod ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mod = ( mod + int ( S [ N - i - 1 ] ) * ten ) % P <NEWLINE> ten = ten * 10 % P <NEWLINE> rem [ mod ] += 1 <NEWLINE> <DEDENT> for j in rem : <NEWLINE> <INDENT> ans += ( j * ( j - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> d = [ 0 for i in range ( pow ( 10 , 5 ) + 1 ) ] <NEWLINE> s = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s += ( bc [ i ] [ 1 ] - bc [ i ] [ 0 ] ) * d [ bc [ i ] [ 0 ] ] <NEWLINE> print ( s ) <NEWLINE> d [ bc [ i ] [ 1 ] ] += d [ bc [ i ] [ 0 ] ] <NEWLINE> d [ bc [ i ] [ 0 ] ] = 0 <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if S [ : K ] . count ( <STRING> ) == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = S . lstrip ( <STRING> ) <NEWLINE> print ( A [ 0 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import collections <NEWLINE> <NL> <NL> def process ( commands ) : <NEWLINE> <INDENT> queue = collections . deque ( ) <NEWLINE> for c in commands : <NEWLINE> <INDENT> if <STRING> in c : <NEWLINE> <INDENT> queue . appendleft ( int ( c [ 7 : ] ) ) <NEWLINE> <DEDENT> elif <STRING> in c : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> _ = queue . popleft ( ) <NEWLINE> <DEDENT> except IndexError as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif <STRING> in c : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> _ = queue . pop ( ) <NEWLINE> <DEDENT> except IndexError as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif <STRING> in c : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> queue . remove ( int ( c [ 7 : ] ) ) <NEWLINE> <DEDENT> except ValueError as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( map ( str , queue ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> process ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> Hs = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> Rs = [ ] <COMMENT> <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Rs . append ( ( a - 1 , b - 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> goods = [ True ] * N <NEWLINE> <NL> for r in Rs : <NEWLINE> <INDENT> a , b = r <NEWLINE> if goods [ a ] : <NEWLINE> <INDENT> goods [ a ] = Hs [ a ] > Hs [ b ] <COMMENT> <NEWLINE> <DEDENT> if goods [ b ] : <NEWLINE> <INDENT> goods [ b ] = Hs [ b ] > Hs [ a ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> counter = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if goods [ i ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> cm = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cm += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cm = 1000 <NEWLINE> for i in range ( len ( s ) - len ( t ) ) : <NEWLINE> <INDENT> cn = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> cn += 1 <NEWLINE> <DEDENT> <DEDENT> cm = min ( cm , cn ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cm ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs1 ( pos , before_pos ) : <NEWLINE> <INDENT> for next_pos in ab [ pos ] : <NEWLINE> <INDENT> if next_pos == before_pos : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if next_pos == u : <NEWLINE> <INDENT> return True , [ pos ] <NEWLINE> <DEDENT> tf , root = dfs1 ( next_pos , pos ) <NEWLINE> if tf : <NEWLINE> <INDENT> root . append ( pos ) <NEWLINE> return True , root <NEWLINE> <DEDENT> <DEDENT> return False , [ ] <NEWLINE> <NL> <DEDENT> root = dfs1 ( v , - 1 ) [ 1 ] <NEWLINE> root = root [ : : - 1 ] <NEWLINE> root . append ( u ) <NEWLINE> n = ( len ( root ) + 1 ) // 2 <NEWLINE> pos = root [ n ] <NEWLINE> before_pos = root [ n - 1 ] <NEWLINE> <NL> max_len = n <NEWLINE> <NL> def dfs2 ( pos , before_pos , cnt ) : <NEWLINE> <INDENT> global max_len <NEWLINE> cnt += 1 <NEWLINE> max_len = max ( max_len , cnt ) <NEWLINE> if cnt < n - 1 : <NEWLINE> <INDENT> dfs2 ( root [ cnt + 1 ] , pos , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for next_pos in ab [ pos ] : <NEWLINE> <INDENT> if next_pos == before_pos : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs2 ( next_pos , pos , cnt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs2 ( pos , before_pos , n - 1 ) <NEWLINE> ans = max_len - 1 <NEWLINE> ans = max ( ans , 0 ) <NEWLINE> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = 7 <NEWLINE> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = ( a * 10 + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , N = LI ( ) [ : ] <NEWLINE> if N > 0 : <NEWLINE> <INDENT> P = LI ( ) <NEWLINE> P . sort ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> index = bisect . bisect_left ( P , X ) <NEWLINE> <COMMENT> <NL> if index >= N : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = index <NEWLINE> r = index <NEWLINE> for i in range ( 0 , 200 ) : <NEWLINE> <INDENT> up = X + i <NEWLINE> down = X - i <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if l < 0 or P [ l ] != down : <NEWLINE> <INDENT> print ( down ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if r >= N or P [ r ] != up : <NEWLINE> <INDENT> print ( up ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> l -= 1 <NEWLINE> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> arr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> arr = set ( arr ) <NEWLINE> <NL> print ( len ( arr ) ) <NEWLINE>
import collections <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> strA = input ( ) . split ( ) <NEWLINE> ans = collections . Counter ( strA ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ str ( i ) ] ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> for v in A : <NEWLINE> <INDENT> d [ v ] = d . get ( v , 0 ) + 1 <NEWLINE> <DEDENT> if 1 in d : <NEWLINE> <INDENT> if d [ 1 ] == 1 : return 1 <NEWLINE> else : return 0 <NEWLINE> <NL> <DEDENT> A = list ( set ( A ) ) <NEWLINE> A . sort ( ) <NEWLINE> s = set ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if d [ A [ i ] ] == 1 : <NEWLINE> <INDENT> if A [ i ] not in s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> k = 1 <NEWLINE> while k * A [ i ] <= A [ - 1 ] : <NEWLINE> <INDENT> s . add ( k * A [ i ] ) <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
<NL> flag = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> before = a [ - 1 ] <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <NL> <INDENT> ans += ( a [ i - 1 ] * before ) % mod <NEWLINE> before += a [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == i + 1 : <NEWLINE> <INDENT> A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] <NEWLINE> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if A [ N - 1 ] == N : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> t [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> t [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ a - 1 ] , t [ b - 1 ] = 0 , 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( t ) ) <NEWLINE>
def solve ( d , c , s , k ) : <NEWLINE> <INDENT> last = [ 0 ] * 27 <NEWLINE> srate = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for j in range ( 1 , 27 ) : <NEWLINE> <INDENT> a -= c [ j - 1 ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> pa = 0 <NEWLINE> mlast = [ 0 ] * 2 <NEWLINE> for t in range ( 1 , 27 ) : <NEWLINE> <INDENT> if s [ i - 1 ] [ t - 1 ] + c [ t - 1 ] * ( min ( k * ( k - 1 ) / 2 , ( 366 - d ) * ( ( 366 - d ) - 1 ) / 2 ) ) > pa : <NEWLINE> <INDENT> mlast = [ t , i ] <NEWLINE> pa = s [ i - 1 ] [ t - 1 ] + c [ t - 1 ] * ( i - last [ t ] ) <NEWLINE> <DEDENT> <DEDENT> a += pa <NEWLINE> last [ mlast [ 0 ] ] = mlast [ 1 ] <NEWLINE> ans . append ( mlast [ 0 ] ) <NEWLINE> srate . append ( a ) <NEWLINE> <DEDENT> return ans , srate <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> mrate = 0 <NEWLINE> ans , srate = solve ( d , c , s , 3 ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> H , W , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> S = np . zeros ( ( H + 1 , W + 1 ) , dtype = int ) <NEWLINE> S [ 1 : , 1 : ] = [ [ int ( _ ) for _ in input ( ) ] for _ in range ( H ) ] <NEWLINE> cum = S . cumsum ( axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> <COMMENT> <NL> <NL> ans = 10 ** 10 <NEWLINE> for bs in itertools . product ( [ True , False ] , repeat = H - 1 ) : <NEWLINE> <INDENT> bs = [ True ] + list ( bs ) + [ True ] <NEWLINE> <COMMENT> <NL> idxs = [ ] <NEWLINE> for i , b in enumerate ( bs ) : <NEWLINE> <INDENT> if b : <NEWLINE> <INDENT> idxs += [ i ] <NEWLINE> <DEDENT> <DEDENT> cum2 = np . array ( [ cum [ i2 ] - cum [ i1 ] for i1 , i2 in zip ( idxs , idxs [ 1 : ] ) ] ) <NEWLINE> i = 0 <NEWLINE> cnt = sum ( bs ) - 3 <NEWLINE> while i < W : <NEWLINE> <INDENT> di = min ( <NEWLINE> <INDENT> np . searchsorted ( c [ i + 1 : ] - c [ i ] , K , side = <STRING> ) for c in cum2 ) <NEWLINE> <DEDENT> if di == 0 : <NEWLINE> <INDENT> cnt = 10 ** 10 <NEWLINE> break <NEWLINE> <DEDENT> i += di <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( l ) <NEWLINE> a *= a <NEWLINE> b = sum ( [ i * i for i in l ] ) <NEWLINE> a = ( a - b ) // 2 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( a % mod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> s = sorted ( s ) <NEWLINE> t = sorted ( t ) <NEWLINE> x = s [ 0 ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> x = x + s [ i + 1 ] <NEWLINE> <DEDENT> y = t [ - 1 ] <NEWLINE> for i in range ( len ( t ) - 1 ) : <NEWLINE> <INDENT> y = y + t [ - i - 2 ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> l = [ ] <NEWLINE> l . append ( x ) <NEWLINE> l . append ( y ) <NEWLINE> l = sorted ( l ) <NEWLINE> <NL> if l . index ( x ) < l . index ( y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def my_dot ( lhs , rhs ) : <NEWLINE> <INDENT> return [ sum ( a [ i ] [ j ] * b [ j ] [ 0 ] for j in range ( len ( rhs ) ) ) for i in range ( len ( lhs ) ) ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <NL> n , m = ( int ( n ) for n in stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for cnt in range ( n ) : <NEWLINE> <INDENT> a . append ( [ int ( n ) for n in stdin . readline ( ) . rstrip ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for cnt in range ( m ) : <NEWLINE> <INDENT> b . append ( [ int ( n ) for n in stdin . readline ( ) . rstrip ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> c = my_dot ( a , b ) <NEWLINE> <NL> for cn in c : <NEWLINE> <INDENT> print ( int ( cn ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , x . split ( ) ) <NEWLINE> ans [ a ] += b <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> cnt += ans [ i ] <NEWLINE> if cnt >= k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> class mf_graph : <NEWLINE> <INDENT> n = 1 <NEWLINE> g = [ [ ] for i in range ( 1 ) ] <NEWLINE> pos = [ ] <NEWLINE> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . n = N <NEWLINE> self . g = [ [ ] for i in range ( N ) ] <NEWLINE> <DEDENT> def add_edge ( self , From , To , cap ) : <NEWLINE> <INDENT> assert 0 <= From and From < self . n <NEWLINE> assert 0 <= To and To < self . n <NEWLINE> assert 0 <= cap <NEWLINE> m = len ( self . pos ) <NEWLINE> self . pos . append ( ( From , len ( self . g [ From ] ) ) ) <NEWLINE> self . g [ From ] . append ( { <STRING> : To , <STRING> : len ( self . g [ To ] ) , <STRING> : cap } ) <NEWLINE> self . g [ To ] . append ( { <STRING> : From , <STRING> : len ( self . g [ From ] ) - 1 , <STRING> : 0 } ) <NEWLINE> return m <NEWLINE> <DEDENT> def get_edge ( self , i ) : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> assert 0 <= i and i < m <NEWLINE> _e = self . g [ self . pos [ i ] [ 0 ] ] [ self . pos [ i ] [ 1 ] ] <NEWLINE> _re = self . g [ _e [ <STRING> ] ] [ _e [ <STRING> ] ] <NEWLINE> return { <STRING> : self . pos [ i ] [ 0 ] , <NEWLINE> <INDENT> <STRING> : _e [ <STRING> ] , <NEWLINE> <STRING> : _e [ <STRING> ] + _re [ <STRING> ] , <NEWLINE> <STRING> : _re [ <STRING> ] } <NEWLINE> <DEDENT> <DEDENT> def edges ( self ) : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> result . append ( self . get_edge ( i ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> def change_edge ( self , i , new_cap , new_flow ) : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> assert 0 <= i and i < m <NEWLINE> assert 0 <= new_flow and new_flow <= new_cap <NEWLINE> _e = self . g [ self . pos [ i ] [ 0 ] ] [ self . pos [ i ] [ 1 ] ] <NEWLINE> _re = self . g [ _e [ <STRING> ] ] [ _e [ <STRING> ] ] <NEWLINE> _e [ <STRING> ] = new_cap - new_flow <NEWLINE> _re [ <STRING> ] = new_flow <NEWLINE> <DEDENT> def flow ( self , s , t , flow_limit = ( 2 ** 31 ) - 1 ) : <NEWLINE> <INDENT> assert 0 <= s and s < self . n <NEWLINE> assert 0 <= t and t < self . n <NEWLINE> level = [ 0 for i in range ( self . n ) ] <NEWLINE> Iter = [ 0 for i in range ( self . n ) ] <NEWLINE> que = deque ( [ ] ) <NEWLINE> def bfs ( ) : <NEWLINE> <INDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> level [ i ] = - 1 <NEWLINE> <DEDENT> level [ s ] = 0 <NEWLINE> que = deque ( [ ] ) <NEWLINE> que . append ( s ) <NEWLINE> while ( len ( que ) > 0 ) : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> for e in self . g [ v ] : <NEWLINE> <INDENT> if e [ <STRING> ] == 0 or level [ e [ <STRING> ] ] >= 0 : continue <NEWLINE> level [ e [ <STRING> ] ] = level [ v ] + 1 <NEWLINE> if e [ <STRING> ] == t : return <NEWLINE> que . append ( e [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def dfs ( func , v , up ) : <NEWLINE> <INDENT> if ( v == s ) : return up <NEWLINE> res = 0 <NEWLINE> level_v = level [ v ] <NEWLINE> for i in range ( Iter [ v ] , len ( self . g [ v ] ) ) : <NEWLINE> <INDENT> e = self . g [ v ] [ i ] <NEWLINE> if ( level_v <= level [ e [ <STRING> ] ] or self . g [ e [ <STRING> ] ] [ e [ <STRING> ] ] [ <STRING> ] == 0 ) : continue <NEWLINE> d = func ( func , e [ <STRING> ] , min ( up - res , self . g [ e [ <STRING> ] ] [ e [ <STRING> ] ] [ <STRING> ] ) ) <NEWLINE> if d <= 0 : continue <NEWLINE> self . g [ v ] [ i ] [ <STRING> ] += d <NEWLINE> self . g [ e [ <STRING> ] ] [ e [ <STRING> ] ] [ <STRING> ] -= d <NEWLINE> res += d <NEWLINE> if res == up : break <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> flow = 0 <NEWLINE> while ( flow < flow_limit ) : <NEWLINE> <INDENT> bfs ( ) <NEWLINE> if level [ t ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> Iter [ i ] = 0 <NEWLINE> <DEDENT> while ( flow < flow_limit ) : <NEWLINE> <INDENT> f = dfs ( dfs , t , flow_limit - flow ) <NEWLINE> if not ( f ) : break <NEWLINE> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <DEDENT> def min_cut ( s ) : <NEWLINE> <INDENT> visited = [ False for i in range ( self . n ) ] <NEWLINE> que = deque ( [ ] ) <NEWLINE> que . append ( s ) <NEWLINE> while ( len ( que ) > 0 ) : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> visited [ p ] = True <NEWLINE> for e in self . g [ p ] : <NEWLINE> <INDENT> if e [ <STRING> ] and not ( visited [ e [ <STRING> ] ] ) : <NEWLINE> <INDENT> visited [ e [ <STRING> ] ] = True <NEWLINE> que . append ( e [ <STRING> ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for i in range ( N ) ] <NEWLINE> G = mf_graph ( N * M + 2 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : continue <NEWLINE> v = i * M + j <NEWLINE> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> G . add_edge ( N * M , v , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . add_edge ( v , N * M + 1 , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if ( i + j ) % 2 or S [ i ] [ j ] == <STRING> : continue <NEWLINE> v0 = i * M + j <NEWLINE> if i > 0 and S [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> v1 = ( i - 1 ) * M + j <NEWLINE> G . add_edge ( v0 , v1 , 1 ) <NEWLINE> <DEDENT> if j > 0 and S [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> v1 = i * M + ( j - 1 ) <NEWLINE> G . add_edge ( v0 , v1 , 1 ) <NEWLINE> <DEDENT> if i + 1 < N and S [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> v1 = ( i + 1 ) * M + j <NEWLINE> G . add_edge ( v0 , v1 , 1 ) <NEWLINE> <DEDENT> if j + 1 < M and S [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> v1 = i * M + ( j + 1 ) <NEWLINE> G . add_edge ( v0 , v1 , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( G . flow ( N * M , N * M + 1 ) ) <NEWLINE> <NL> T = [ [ S [ i ] [ j ] for j in range ( M ) ] for i in range ( N ) ] <NEWLINE> for e in G . edges ( ) : <NEWLINE> <INDENT> if e [ <STRING> ] == N * M or e [ <STRING> ] == N * M + 1 or e [ <STRING> ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i0 = e [ <STRING> ] // M <NEWLINE> j0 = e [ <STRING> ] % M <NEWLINE> i1 = e [ <STRING> ] // M <NEWLINE> j1 = e [ <STRING> ] % M <NEWLINE> if i0 == i1 + 1 : <NEWLINE> <INDENT> T [ i1 ] [ j1 ] = <STRING> <NEWLINE> T [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> elif j0 == j1 + 1 : <NEWLINE> <INDENT> T [ i1 ] [ j1 ] = <STRING> ; T [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> elif i0 == i1 - 1 : <NEWLINE> <INDENT> T [ i0 ] [ j0 ] = <STRING> <NEWLINE> T [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i0 ] [ j0 ] = <STRING> ; T [ i1 ] [ j1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . join ( T [ i ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> R = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] ^ a [ i ] <NEWLINE> R [ N - i - 1 ] = R [ N - i ] ^ a [ N - i - 1 ] <NEWLINE> <DEDENT> ans = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i ] = L [ i ] ^ R [ i + 1 ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W , N = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import defaultdict as dd <NEWLINE> Grid = dd ( lambda : 0 ) <COMMENT> <NEWLINE> Draw = lambda x , y : [ ( x - i , y - j ) for i in range ( 3 ) for j in range ( 3 ) if 0 <= x - i < H - 2 and 0 <= y - j < W - 2 ] <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for x , y in Draw ( a - 1 , b - 1 ) : <COMMENT> <NEWLINE> <INDENT> Grid [ x , y ] += 1 <NEWLINE> <DEDENT> <DEDENT> Ans = [ ( H - 2 ) * ( W - 2 ) - len ( Grid ) if i == 0 else sum ( v == i for v in Grid . values ( ) ) for i in range ( 10 ) ] <NEWLINE> for ans in Ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> th = pow ( 10 , 18 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > th : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ X ] <NEWLINE> As = set ( A ) <NEWLINE> Lstart = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> An = A [ - 1 ] ** 2 % M <NEWLINE> if An in As : <NEWLINE> <INDENT> Lstart = A . index ( An ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( An ) <NEWLINE> As . add ( An ) <NEWLINE> <DEDENT> <DEDENT> LenBefL = Lstart <NEWLINE> LenLoop = len ( A ) - Lstart <NEWLINE> if LenLoop > 0 : <NEWLINE> <INDENT> ans = sum ( A [ : Lstart ] ) + sum ( A [ Lstart : ] ) * ( ( N - LenBefL ) // LenLoop ) + sum ( A [ Lstart : Lstart + ( N - LenBefL ) % LenLoop ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * x * x , 2 * math . pi * x ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> num_0 = s . count ( <STRING> ) <NEWLINE> num_1 = s . count ( <STRING> ) <NEWLINE> print ( min ( num_0 , num_1 ) * 2 ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> i = 1 <NEWLINE> p = int ( ( N + 1 ) / B ) <NEWLINE> if p == 0 : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B * p - 1 <NEWLINE> <DEDENT> print ( int ( ( ( x / B ) - ( x // B ) ) * A ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i ** 2 <= n : <NEWLINE> <INDENT> ans = i ** 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) <NEWLINE> if len ( x ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> k = int ( x [ 0 : - 2 ] ) <NEWLINE> x = int ( x [ - 2 : ] ) <NEWLINE> <NL> k -= x / 5 <NEWLINE> if x % 5 == 0 and k >= 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif k > 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> a = 7 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> a = ( 10 * a + 7 ) % k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <COMMENT> <NL> N , M = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> ABs = [ map ( int , ( input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> ds = [ INF ] * ( N + 1 ) <NEWLINE> marks = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> nodes = [ None ] * ( N + 1 ) <NEWLINE> <NL> for AB in ABs : <NEWLINE> <INDENT> A , B = AB <NEWLINE> if nodes [ A ] is None : <NEWLINE> <INDENT> nodes [ A ] = [ ] <NEWLINE> <DEDENT> nodes [ A ] . append ( B ) <NEWLINE> <NL> B , A = A , B <NEWLINE> if nodes [ A ] is None : <NEWLINE> <INDENT> nodes [ A ] = [ ] <NEWLINE> <DEDENT> nodes [ A ] . append ( B ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> visited = [ 0 ] * ( N + 1 ) <NEWLINE> visited [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> marks = [ 0 ] * ( N + 1 ) <NEWLINE> parent = 1 <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> p = queue . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for n in nodes [ p ] : <NEWLINE> <INDENT> if visited [ n ] == 0 : <NEWLINE> <INDENT> visited [ n ] = 1 <NEWLINE> marks [ n ] = p <NEWLINE> queue . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for mark in marks [ 2 : ] : <NEWLINE> <INDENT> print ( mark ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = { } <NEWLINE> ans = 0 <NEWLINE> for a in input ( ) . split ( ) : <NEWLINE> <INDENT> a = int ( a ) <NEWLINE> if a not in A : <NEWLINE> <INDENT> A [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ a ] += 1 <NEWLINE> <DEDENT> ans += a <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if B in A : <NEWLINE> <INDENT> ans += ( C - B ) * A [ B ] <NEWLINE> if C not in A : <NEWLINE> <INDENT> A [ C ] = A [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ C ] += A [ B ] <NEWLINE> <DEDENT> A [ B ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <DEDENT> <DEDENT> a = len ( r ) * len ( b ) * len ( g ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> k = abs ( i - j ) <NEWLINE> if i + k in g : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> if i - k in g : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> if j + k in g : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> if j - k in g : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> if ( i + j ) / 2 in g : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def gcd ( num1 , num2 ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while r > 0 : <NEWLINE> <INDENT> r = num1 % num2 <NEWLINE> num1 = num2 <NEWLINE> num2 = r <NEWLINE> <DEDENT> return num1 <NEWLINE> <NL> <DEDENT> def lcm ( num1 , num2 ) : <NEWLINE> <INDENT> gcd1 = gcd ( num1 , num2 ) <NEWLINE> return num1 * num2 // gcd1 <NEWLINE> <NL> <DEDENT> lcm1 = a [ 0 ] // 2 <NEWLINE> lcm2 = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> lcm1 = lcm ( lcm1 , t // 2 ) <NEWLINE> lcm2 = lcm ( lcm2 , t ) <NEWLINE> ta = max ( t // 2 , lcm1 ) <NEWLINE> tb = min ( t // 2 , lcm1 ) <NEWLINE> if ta != tb and ta // tb % 2 == 0 : <NEWLINE> <INDENT> lcm1 = 0 <NEWLINE> lcm2 = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if lcm1 != 0 : <NEWLINE> <INDENT> ans1 = m // lcm1 <NEWLINE> ans2 = m // lcm2 <NEWLINE> ans = ans1 - ans2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> for x in range ( len ( a ) ) : <NEWLINE> <INDENT> if x == len ( a ) - 1 : <NEWLINE> <INDENT> print ( a [ x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ x ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR_L = [ [ int ( x ) for x in input ( ) . split ( ) ] for y in range ( K ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for li , ri in LR_L : <NEWLINE> <INDENT> if i + li < N + 1 : <NEWLINE> <INDENT> dp [ i + li ] += dp [ i ] <NEWLINE> dp [ i + li ] %= MOD <NEWLINE> <DEDENT> if i + ri + 1 < N + 1 : <NEWLINE> <INDENT> dp [ i + ri + 1 ] -= dp [ i ] <NEWLINE> dp [ i + ri + 1 ] %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> c *= i <NEWLINE> <NL> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> kind = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> <NL> if S not in kind : <NEWLINE> <INDENT> kind [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( kind ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <NL> fline = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> N , Q = int ( fline [ 0 ] ) , int ( fline [ 1 ] ) <NEWLINE> <NL> list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tlist = [ ] <NEWLINE> line = input ( ) . split ( <STRING> ) <NEWLINE> tlist = [ line [ 0 ] , line [ 1 ] ] <NEWLINE> <COMMENT> <NL> list . append ( tlist ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> current = 0 <NEWLINE> while len ( list ) != 0 : <NEWLINE> <INDENT> if int ( list [ 0 ] [ 1 ] ) <= Q : <NEWLINE> <INDENT> current += int ( list [ 0 ] [ 1 ] ) <NEWLINE> print ( list [ 0 ] [ 0 ] + <STRING> + str ( current ) ) <NEWLINE> del list [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ 0 ] [ 1 ] = str ( ( int ) ( list [ 0 ] [ 1 ] ) - Q ) <NEWLINE> list . append ( list [ 0 ] ) <NEWLINE> del list [ 0 ] <NEWLINE> current += Q <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> A . sort ( ) <NEWLINE> c = 0 <NEWLINE> <STRING> <NEWLINE> saidai = A [ - 1 ] <NEWLINE> foo = [ 0 for k in range ( saidai + 1 ) ] <NEWLINE> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> if foo [ A [ k ] ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( A [ k ] , saidai + 1 , A [ k ] ) : <NEWLINE> <INDENT> foo [ j ] = 1 <NEWLINE> <DEDENT> if k < len ( A ) - 1 : <NEWLINE> <INDENT> if A [ k ] == A [ k + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if 0 < k < len ( A ) : <NEWLINE> <INDENT> if A [ k ] == A [ k - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import copy <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> <NL> cl = sum ( c ) <NEWLINE> D = [ 0 ] * 26 <NEWLINE> ans = [ 0 ] * d <NEWLINE> T = [ 0 ] * d <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> D [ j ] += 1 <NEWLINE> <DEDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> sas = 0 <NEWLINE> S = s [ i ] [ j ] <NEWLINE> C = c [ j ] <NEWLINE> Ds = copy . copy ( D ) <NEWLINE> Ds [ j ] = 0 <NEWLINE> dc = 0 <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> dc += Ds [ k ] * c [ k ] <NEWLINE> <DEDENT> sas = S - dc + sum ( T [ : i ] ) <NEWLINE> if sas > count : <NEWLINE> <INDENT> count = sas <NEWLINE> ans [ i ] = j + 1 <NEWLINE> T [ i ] = count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x *= lis [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
numbers = [ 0 ] * 2019 <NEWLINE> numbers [ 0 ] = 1 <NEWLINE> s = input ( ) <NEWLINE> t = 0 <NEWLINE> mod = 2019 <NEWLINE> u = 1 <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> t = ( t + int ( s [ - i ] ) * u ) % mod <NEWLINE> numbers [ t ] += 1 <NEWLINE> u = 10 * u % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for n in numbers : <NEWLINE> <INDENT> ans += n * ( n - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import functools <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> m = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in arr : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> n = input ( ) <NEWLINE> <NL> r = n . count ( <STRING> ) <NEWLINE> g = n . count ( <STRING> ) <NEWLINE> b = n . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <NL> <INDENT> for j in range ( i + 1 , math . ceil ( ( k + i ) / 2 ) ) : <NEWLINE> <NL> <INDENT> if ( n [ i ] != n [ j ] ) and ( n [ 2 * j - i ] != n [ i ] ) and ( n [ j ] != n [ 2 * j - i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> from difflib import SequenceMatcher <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cumsumA = np . cumsum ( A ) <NEWLINE> p = bisect . bisect_left ( cumsumA , K + 0.1 ) <NEWLINE> time = cumsumA [ p - 1 ] <NEWLINE> tmp = p <NEWLINE> ans = tmp <NEWLINE> <NL> cntA = 0 <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> <DEDENT> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> from difflib import SequenceMatcher <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cumsumA = np . cumsum ( A ) <NEWLINE> a = bisect . bisect_left ( cumsumA , K + 0.1 ) - 1 <NEWLINE> time = cumsumA [ a ] <NEWLINE> tmp = a + 1 <NEWLINE> ans = tmp <NEWLINE> <NL> b = 0 <NEWLINE> while ( b < len ( B ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if time + B [ b ] <= K : <NEWLINE> <INDENT> time += B [ b ] <NEWLINE> tmp += 1 <NEWLINE> b += 1 <NEWLINE> if tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> time -= A [ a ] <NEWLINE> tmp += - 1 <NEWLINE> a += - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = [ False ] * 102 <NEWLINE> for i in p : <NEWLINE> <INDENT> flag [ i ] = True <NEWLINE> <DEDENT> for j in range ( 0 , 102 ) : <NEWLINE> <INDENT> l = max ( 0 , x - j ) <NEWLINE> r = min ( 101 , x + j ) <NEWLINE> if not flag [ l ] : <NEWLINE> <INDENT> print ( l ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if not flag [ r ] : <NEWLINE> <INDENT> print ( r ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> ranges = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ranges . append ( ( l , r ) ) <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> counts = [ 0 ] * ( n + 1 ) <NEWLINE> sum_dp = [ 0 ] * ( n + 2 ) <NEWLINE> counts [ 0 ] = 1 <NEWLINE> sum_dp [ 1 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for r in ranges : <NEWLINE> <INDENT> left = max ( 0 , i - r [ 1 ] ) <NEWLINE> right = max ( 0 , i - r [ 0 ] + 1 ) <NEWLINE> counts [ i ] += ( sum_dp [ right ] - sum_dp [ left ] ) <NEWLINE> counts [ i ] = counts [ i ] % mod <NEWLINE> <DEDENT> sum_dp [ i + 1 ] = sum_dp [ i ] + counts [ i ] <NEWLINE> <NL> <NL> <DEDENT> print ( counts [ n - 1 ] % mod ) <NEWLINE>
<COMMENT> <NL> <NL> surplus = [ 0 ] * 2019 <NEWLINE> surplus [ 0 ] += 1 <NEWLINE> <NL> d = 1 <NEWLINE> n = 0 <NEWLINE> for i in reversed ( input ( ) ) : <NEWLINE> <INDENT> n = ( n + int ( i ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> surplus [ n ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in surplus ] ) ) <NEWLINE>
<NL> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> v = - v <NEWLINE> if w > 0 : <NEWLINE> <INDENT> w = - w <NEWLINE> <DEDENT> <DEDENT> if a < b and w < 0 : <NEWLINE> <INDENT> w = - w <NEWLINE> <NL> <NL> <NL> <DEDENT> A = t * v + a <NEWLINE> B = t * w + b <NEWLINE> <NL> if A > B : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A < B : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> ( N , K ) = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for j in range ( 0 , K ) : <NEWLINE> <INDENT> B = np . zeros ( N , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> f = max ( 0 , i - A [ i ] ) <NEWLINE> t = min ( N - 1 , i + A [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> B [ f ] += 1 <NEWLINE> if t + 1 < N : <NEWLINE> <INDENT> B [ t + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> A = np . cumsum ( B ) <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( map ( str , solve ( N , K , A ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in arr : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> boo = True <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> boo = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if boo : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += A [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i != 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT> found = False <NEWLINE> for y in range ( a , b + 1 ) : <NEWLINE> <INDENT> if y % 4 == 0 and ( y % 100 != 0 or y % 400 == 0 ) : <NEWLINE> <INDENT> found = True <NEWLINE> print ( y ) <NEWLINE> <DEDENT> <DEDENT> if not found : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( b ) <NEWLINE> j = m - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> t += a [ i ] <NEWLINE> while j >= 0 and t > k : <NEWLINE> <INDENT> t -= b [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> if t > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , j + i + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = 1 <NEWLINE> tl = [ 1 ] <NEWLINE> ts = { 1 } <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <NL> <INDENT> t = a [ t - 1 ] <NEWLINE> if t in ts : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl . append ( t ) <NEWLINE> ts . add ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> tl2 = tl [ tl . index ( t ) : len ( tl ) ] <NEWLINE> <NL> <NL> if k < len ( tl ) : <NEWLINE> <INDENT> ans = tl [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - ( len ( tl ) - len ( tl2 ) ) <NEWLINE> j = k % len ( tl2 ) <NEWLINE> ans = tl2 [ j ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( n // 1000 ) + 1 ) * 1000 - n ) <NEWLINE> <DEDENT>
from heapq import nlargest <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> l1 , l2 = nlargest ( 2 , a ) <NEWLINE> <NL> if l1 == l2 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> if i == l1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l1 ) <NEWLINE> <DEDENT> <DEDENT>
def kk ( n , m ) : <NEWLINE> <INDENT> if n < m : <NEWLINE> <INDENT> n , m = m , n <NEWLINE> <DEDENT> while n % m != 0 : <NEWLINE> <INDENT> n = n % m <NEWLINE> n , m = m , n <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( p , k + 1 ) : <NEWLINE> <INDENT> pq = kk ( p , q ) <NEWLINE> for r in range ( q , k + 1 ) : <NEWLINE> <INDENT> pqr = kk ( pq , r ) <NEWLINE> if p == r : <NEWLINE> <INDENT> pqr = pqr <NEWLINE> <DEDENT> elif p == q or q == r : <NEWLINE> <INDENT> pqr = pqr * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pqr = pqr * 6 <NEWLINE> <DEDENT> count = count + pqr <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> f1 = 0 <NEWLINE> f2 = 0 <NEWLINE> l = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a *= int ( l [ i ] ) <NEWLINE> if a > 1000000000000000000 : <NEWLINE> <INDENT> f1 = 1 <NEWLINE> a = 1 <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> f2 = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if f2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif f1 == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
from random import randint <NEWLINE> <NL> <NL> class RollingHash : <NEWLINE> <INDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> self . base = [ 7073 , 7577 , 5445 , 2742 , 6972 , 7547 , 2267 , 286 , 6396 , 7147 , <NEWLINE> <INDENT> 3307 , 188 , 266 , 8253 , 2818 , 9527 , 5110 , 1207 , 4633 , 6196 , <NEWLINE> 309 , 2646 , 7533 , 85 , 9870 , 4730 , 6862 , 9213 , 7456 , 7098 , <NEWLINE> 6805 , 674 , 5821 , 4864 , 8061 , 1826 , 2219 , 459 , 5937 , 5667 , <NEWLINE> 9033 , 5552 , 7263 , 2402 , 9809 , 3701 , 7048 , 2874 , 8350 , 6006 , <NEWLINE> 973 , 3317 , 2522 , 5546 , 1669 , 1545 , 7972 , 4979 , 9905 , 173 , <NEWLINE> 6812 , 7715 , 5006 , 6068 , 6340 , 4989 , 5510 , 6380 , 1200 , 6739 , <NEWLINE> 5527 , 4000 , 6519 , 3448 , 2933 , 6048 , 3133 , 1667 , 9086 , 8368 , <NEWLINE> 4914 , 7142 , 2770 , 7752 , 391 , 7052 , 5476 , 3105 , 8322 , 3501 , <NEWLINE> 7454 , 3167 , 8730 , 9002 , 4564 , 138 , 2197 , 7238 , 3411 , 7433 ] [ randint ( 0 , 99 ) ] <NEWLINE> <DEDENT> self . mod = 4611686018427387903 <NEWLINE> self . size = len ( s ) <NEWLINE> self . string = s <NEWLINE> <NL> self . hash = self . make_hashtable ( s ) <NEWLINE> self . pow = self . make_powtable ( ) <NEWLINE> <NL> <DEDENT> def make_hashtable ( self , _s ) : <NEWLINE> <INDENT> hashtable = [ 0 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> hashtable [ i + 1 ] = ( hashtable [ i ] * self . base + ord ( _s [ i ] ) ) % self . mod <NEWLINE> <DEDENT> return hashtable <NEWLINE> <NL> <DEDENT> def make_powtable ( self ) : <NEWLINE> <INDENT> power = [ 1 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> power [ i + 1 ] = ( self . base * power [ i ] ) % self . mod <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def get_hash ( self , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . hash [ right ] - self . hash [ left ] * self . pow [ right - left ] ) % self . mod <NEWLINE> <NL> <DEDENT> def contain ( self , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m = len ( a ) <NEWLINE> if m > self . size : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> hashs = self . get_hash ( 0 , m ) <NEWLINE> hasha = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hasha = ( hasha * self . base + ord ( a [ i ] ) ) % self . mod <NEWLINE> <DEDENT> for i in range ( self . size - m + 1 ) : <NEWLINE> <INDENT> if hasha == hashs : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> hashs = self . get_hash ( i , m + i ) <NEWLINE> <DEDENT> return hasha == hashs <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from collections import defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> n , s = int ( input ( ) ) , input ( ) <NEWLINE> rh = RollingHash ( s ) <NEWLINE> <NL> <NL> def check ( m ) : <NEWLINE> <INDENT> d = defaultdict ( lambda : 10000000 ) <NEWLINE> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> h = rh . get_hash ( i , i + m ) <NEWLINE> d [ h ] = min ( d [ h ] , i ) <NEWLINE> <COMMENT> <NL> if i - d [ h ] >= m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> l , r = 0 , n // 2 + 1 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( l [ 1 : ] ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> for v , u in zip ( l [ : - 1 ] , l [ 1 : ] ) : <NEWLINE> <INDENT> s += v * a <NEWLINE> a -= u <NEWLINE> <DEDENT> print ( s % m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> items = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> items [ item ] = True <NEWLINE> <NL> <DEDENT> print ( len ( items ) ) <NEWLINE>
def CountingSort ( A ) : <NEWLINE> <INDENT> B = [ 0 ] * len ( A ) <NEWLINE> maxnumber = 0 <NEWLINE> for n in range ( len ( A ) ) : <NEWLINE> <INDENT> if maxnumber < A [ n ] : <NEWLINE> <INDENT> maxnumber = A [ n ] <NEWLINE> <DEDENT> <DEDENT> C = [ 0 ] * ( maxnumber + 1 ) <NEWLINE> <NL> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <DEDENT> for r in range ( 1 , maxnumber + 1 ) : <NEWLINE> <INDENT> C [ r ] = C [ r ] + C [ r - 1 ] <NEWLINE> <NL> <DEDENT> for s in range ( len ( A ) ) [ : : - 1 ] : <NEWLINE> <INDENT> B [ C [ A [ s ] ] - 1 ] = A [ s ] <NEWLINE> C [ A [ s ] ] -= 1 <NEWLINE> <NL> <DEDENT> return B <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> cnt = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ans = list ( map ( str , CountingSort ( A ) ) ) <NEWLINE> print ( <STRING> . join ( Ans ) ) <NEWLINE> <DEDENT>
def dwacon5th_prelims_b ( ) : <NEWLINE> <INDENT> n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cum = 0 <NEWLINE> for a in A [ i : ] : <NEWLINE> <INDENT> cum += a <NEWLINE> B . append ( cum ) <NEWLINE> <DEDENT> <DEDENT> B . sort ( reverse = True ) <NEWLINE> <NL> bit = [ 0 ] * 41 <NEWLINE> cand = B . copy ( ) <NEWLINE> for i in range ( 40 , - 1 , - 1 ) : <NEWLINE> <INDENT> nx = [ ] <NEWLINE> for b in cand : <NEWLINE> <INDENT> if ( b >> i ) & 1 : nx . append ( b ) <NEWLINE> <DEDENT> if len ( nx ) >= k : <NEWLINE> <INDENT> cand = nx . copy ( ) <NEWLINE> bit [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = int ( <STRING> . join ( [ str ( x ) for x in reversed ( bit ) ] ) , base = 2 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dwacon5th_prelims_b ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( s ) <NEWLINE> values , counts = zip ( * c . most_common ( ) ) <NEWLINE> temp = list ( counts ) <NEWLINE> l = len ( temp ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> ans = ans * ( temp [ i ] + 1 ) <NEWLINE> <DEDENT> print ( ( ans - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from bisect import bisect_right <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> <NL> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> d = int ( input ( ) ) <COMMENT> <NEWLINE> if d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( input ( ) ) <COMMENT> <NEWLINE> m = int ( input ( ) ) <COMMENT> <NEWLINE> cw_pos = [ int ( input ( ) ) for _ in range ( n - 1 ) ] <NEWLINE> dests = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> cw_pos . append ( 0 ) <NEWLINE> cw_pos . append ( d ) <NEWLINE> cw_pos . sort ( ) <NEWLINE> <NL> ccw_pos = [ d - x for x in cw_pos ] <NEWLINE> ccw_pos . sort ( ) <NEWLINE> <NL> <NL> total_distance = 0 <NEWLINE> for t in dests : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = bisect_right ( cw_pos , t ) <NEWLINE> a1 = min ( t - cw_pos [ i - 1 ] , cw_pos [ i ] - t ) <NEWLINE> <NL> j = bisect_right ( ccw_pos , d - t ) <NEWLINE> a2 = min ( d - t - ccw_pos [ j - 1 ] , ccw_pos [ j ] - ( d - t ) ) <NEWLINE> <NL> ans = min ( a1 , a2 ) <NEWLINE> total_distance += ans <NEWLINE> <NL> <DEDENT> print ( total_distance ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( g , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if n >= b - 1 : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> print ( a * x // b - a * ( x // b ) ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> def comb ( N , A , MOD ) : <NEWLINE> <INDENT> num = reduce ( lambda x , y : x * y % MOD , range ( N , N - A , - 1 ) ) <NEWLINE> den = reduce ( lambda x , y : x * y % MOD , range ( 1 , A + 1 ) ) <NEWLINE> return num * pow ( den , MOD - 2 , MOD ) % MOD <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ( pow ( 2 , n , mod = mod ) - 1 - comb ( n , a , mod ) - comb ( n , b , mod ) ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> cur_max = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if cur_max > x : <NEWLINE> <INDENT> ans += cur_max - x <NEWLINE> <DEDENT> cur_max = max ( cur_max , x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> s = set ( s ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> l = [ 0 ] * 1000000 <NEWLINE> ans = sum ( A ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans + ( c - b ) * l [ b ] <NEWLINE> l [ c ] += l [ b ] <NEWLINE> l [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> ls = [ False for _ in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> ls [ A [ j ] - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ls [ i ] == False : <NEWLINE> <INDENT> S += 1 <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def sol ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> cnt = 0 <NEWLINE> t = [ ] <NEWLINE> for a , b in tmp : <NEWLINE> <INDENT> t += [ b ] * a <NEWLINE> cnt = cnt + a <NEWLINE> if cnt >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += t <NEWLINE> A . sort ( reverse = 1 ) <NEWLINE> print ( sum ( A [ : N ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sol ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> sum = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> sum = sum ^ a <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans . append ( sum ^ a ) <NEWLINE> <DEDENT> ans = <STRING> . join ( map ( str , ans ) ) <NEWLINE> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> c = 1 <NEWLINE> result = False <NEWLINE> <NL> <NL> while not result : <NEWLINE> <INDENT> for i in range ( c ) : <NEWLINE> <INDENT> a = c - i <NEWLINE> b = i <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> result = True <NEWLINE> A = a <NEWLINE> B = b <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> b = c - i <NEWLINE> a = - i <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> result = True <NEWLINE> A = a <NEWLINE> B = b <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> a = - c + i <NEWLINE> b = - i <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> result = True <NEWLINE> A = a <NEWLINE> B = b <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = - c + i <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> result = True <NEWLINE> A = a <NEWLINE> B = b <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> print ( A , B ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> f = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> x *= a <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( 0 if 0 in A else - 1 if f else x ) <NEWLINE>
stock = { } <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> try : <NEWLINE> <INDENT> stock [ s ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> stock [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( stock ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def solve ( G , p , ans , st , fst , arr , x ) : <NEWLINE> <INDENT> arr [ p ] = x <NEWLINE> cnt_1 = 0 <NEWLINE> z = - 1 <NEWLINE> for nxt in G [ p ] : <NEWLINE> <INDENT> if nxt in st : <NEWLINE> <INDENT> cnt_1 += 1 <NEWLINE> z = nxt <NEWLINE> <DEDENT> <DEDENT> cnt_2 = 0 <NEWLINE> for v in st : <NEWLINE> <INDENT> if p in G [ v ] : <NEWLINE> <INDENT> cnt_2 += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt_1 > 1 or cnt_2 > 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif cnt_1 == 1 and cnt_2 == 1 : <NEWLINE> <INDENT> if fst in G [ p ] : <NEWLINE> <INDENT> for v in st : <NEWLINE> <INDENT> ans . append ( v ) <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = arr [ z ] <NEWLINE> for v in st : <NEWLINE> <INDENT> if arr [ v ] >= k : <NEWLINE> <INDENT> ans . append ( v ) <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT> for nxt in G [ p ] : <NEWLINE> <INDENT> st . add ( nxt ) <NEWLINE> if solve ( G , nxt , ans , st , fst , arr , x + 1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> st . remove ( nxt ) <NEWLINE> <DEDENT> arr [ p ] = 0 <NEWLINE> return False <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> f = False <NEWLINE> st = set ( ) <NEWLINE> arr = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> st . add ( i ) <NEWLINE> if solve ( G , i , ans , st , i , arr , 1 ) : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> st . remove ( i ) <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def gcd ( a , b , c ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> return ( math . gcd ( x , c ) ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> sum += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += 6 * gcd ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = n <NEWLINE> keta = 1 <NEWLINE> x = 26 <NEWLINE> while k > x : <NEWLINE> <INDENT> k -= x <NEWLINE> keta += 1 <NEWLINE> x *= 26 <NEWLINE> <NL> <DEDENT> book = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> l = [ ] <NEWLINE> <NL> for i in reversed ( range ( 1 , keta ) ) : <NEWLINE> <INDENT> s = ( k - 1 ) // ( 26 ** i ) <NEWLINE> k -= s * ( 26 ** i ) <NEWLINE> l . append ( book [ s ] ) <NEWLINE> <NL> <DEDENT> l . append ( book [ k - 1 ] ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ input ( ) for _ in range ( n ) ] <NEWLINE> AS = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in AS : <NEWLINE> <INDENT> AS . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AS . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( AS ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def log ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> _n , _m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ns = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ms = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> count = 0 <NEWLINE> for v in ns : <NEWLINE> <INDENT> if sum + v > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += v <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_now = count <NEWLINE> ans = ans_now <NEWLINE> i = count - 1 <NEWLINE> for v in ms : <NEWLINE> <INDENT> if sum + v > k : <NEWLINE> <INDENT> while sum + v > k : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum -= ns [ i ] <NEWLINE> i -= 1 <NEWLINE> ans_now -= 1 <NEWLINE> <DEDENT> if sum + v > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum += v <NEWLINE> ans_now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += v <NEWLINE> ans_now += 1 <NEWLINE> <DEDENT> ans = max ( ans , ans_now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> if c >= b : <NEWLINE> <INDENT> print ( ( a * ( b - 1 ) ) // b ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = c <NEWLINE> c_amari = c % b <NEWLINE> c_sho = c // b <NEWLINE> ans = ( a * c_amari ) // b <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ ( i + 1 , int ( j ) ) for i , j in enumerate ( input ( ) . split ( ) ) ] <NEWLINE> A . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . data = [ 0 ] * ( n + 1 ) <NEWLINE> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> self . data [ i ] += x <NEWLINE> <COMMENT> <NL> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def get ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i : <NEWLINE> <INDENT> s += self . data [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> <DEDENT> b = BIT ( n ) <NEWLINE> ans = 0 <NEWLINE> for i , j in A : <NEWLINE> <INDENT> ans += b . get ( i ) <NEWLINE> b . add ( i , 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_c = Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = [ 0 ] * Q <NEWLINE> bc = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> bc . append ( ( x , y ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> sum_A = [ 0 ] * ( Q + 1 ) <NEWLINE> sum_A [ 0 ] = sum ( A ) <NEWLINE> ind = 0 <NEWLINE> for k , v in bc : <NEWLINE> <INDENT> sum_A [ ind + 1 ] = sum_A [ ind ] - A_c [ k ] * k + A_c [ k ] * v <NEWLINE> A_c [ v ] += A_c [ k ] <NEWLINE> A_c [ k ] = 0 <NEWLINE> <COMMENT> <NL> print ( sum_A [ ind + 1 ] ) <NEWLINE> ind += 1 <NEWLINE> <DEDENT>
list = input ( ) . split ( ) <NEWLINE> N = int ( list [ 0 ] ) <NEWLINE> K = int ( list [ 1 ] ) <NEWLINE> i = K <NEWLINE> s = 0 <NEWLINE> <NL> def sum ( a , b ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> i = ( a + b ) * ( b - a + 1 ) / 2 <NEWLINE> return i <NEWLINE> <NL> <DEDENT> while i <= N + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> s = s + sum ( N - i + 1 , N ) - sum ( 0 , i - 1 ) + 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( int ( s % ( 10 ** 9 + 7 ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <NL> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = <STRING> <NEWLINE> S += input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = r * g * b <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= N : <NEWLINE> <INDENT> if S [ j ] != S [ i ] and S [ k ] != S [ j ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def findProductSum ( A , n ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum += A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> array_sum_square = ( array_sum * array_sum ) <NEWLINE> <NL> <COMMENT> <NL> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += ( A [ i ] * A [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return ( array_sum_square - individual_square_sum ) // 2 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> print ( int ( findProductSum ( a , n ) ) % MOD ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = ( S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) ) - ans <NEWLINE> print ( ans ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> dp = [ 0 ] * MOD <NEWLINE> dp [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> for c in reversed ( S ) : <NEWLINE> <INDENT> r += int ( c ) * t <NEWLINE> r %= MOD <NEWLINE> t *= 10 <NEWLINE> t %= MOD <NEWLINE> dp [ r ] += 1 <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in dp ) ) <NEWLINE>
def ReversePolishNotation ( string ) : <NEWLINE> <NL> <INDENT> priority = { <STRING> : 0 , <STRING> : 0 , <STRING> : 1 , <STRING> : 1 , <STRING> : 2 , <STRING> : 2 } <NEWLINE> <NL> stack = [ ] <NEWLINE> signStack = [ ] <NEWLINE> isContinue = False <NEWLINE> <NL> for item in string [ : - 1 ] : <NEWLINE> <NL> <INDENT> if str . isdigit ( item ) : <NEWLINE> <INDENT> if not isContinue : <NEWLINE> <INDENT> stack . append ( item ) <NEWLINE> isContinue = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack [ - 1 ] += item <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> signStack . append ( item ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> while signStack [ - 1 ] != <STRING> : <NEWLINE> <INDENT> stack . append ( signStack . pop ( ) ) <NEWLINE> <DEDENT> signStack . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while len ( signStack ) != 0 and priority [ item ] <= priority [ signStack [ - 1 ] ] : <NEWLINE> <INDENT> stack . append ( signStack . pop ( ) ) <NEWLINE> <NL> <DEDENT> signStack . append ( item ) <NEWLINE> <NL> <DEDENT> isContinue = False <NEWLINE> <NL> <DEDENT> while len ( signStack ) != 0 : <NEWLINE> <INDENT> stack . append ( signStack . pop ( ) ) <NEWLINE> <NL> <DEDENT> return stack <NEWLINE> <NL> <NL> <DEDENT> def Calculate ( formulaList ) : <NEWLINE> <NL> <INDENT> signs = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> stack = [ ] <NEWLINE> <NL> for item in formulaList : <NEWLINE> <NL> <INDENT> if item not in signs : <NEWLINE> <INDENT> stack . append ( item ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num1 = int ( stack . pop ( ) ) <NEWLINE> num2 = int ( stack . pop ( ) ) <NEWLINE> <NL> if item == <STRING> : <NEWLINE> <INDENT> result = num2 + num1 <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> result = num2 - num1 <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> result = num2 * num1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = int ( num2 / num1 ) <NEWLINE> <NL> <DEDENT> stack . append ( result ) <NEWLINE> <NL> <DEDENT> <DEDENT> return int ( stack [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> inputCount = int ( input ( ) ) <NEWLINE> <NL> for lp in range ( inputCount ) : <NEWLINE> <INDENT> formula = input ( ) <NEWLINE> <NL> rpn = ReversePolishNotation ( formula ) <NEWLINE> answer = Calculate ( rpn ) <NEWLINE> <NL> print ( answer ) <NEWLINE> <NL> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def Cum ( X ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> Cum = [ 0 ] * len ( X ) <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> temp += X [ i ] <NEWLINE> Cum [ i ] += temp <NEWLINE> <DEDENT> return Cum <NEWLINE> <NL> <DEDENT> a = Cum ( A ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> b = Cum ( B ) <NEWLINE> b . insert ( 0 , 0 ) <NEWLINE> <NL> na = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i == N and a [ i ] <= K : <NEWLINE> <INDENT> na = N <NEWLINE> <DEDENT> elif a [ i ] <= K and a [ i + 1 ] > K : <NEWLINE> <INDENT> na = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = na <NEWLINE> <NL> nb = 0 <NEWLINE> for i in range ( na , - 1 , - 1 ) : <NEWLINE> <INDENT> temp = K - a [ i ] <NEWLINE> for j in range ( nb , M + 1 ) : <NEWLINE> <INDENT> if j == M and b [ j ] <= temp : <NEWLINE> <INDENT> nb = M <NEWLINE> ans = max ( ans , i + nb ) <NEWLINE> <DEDENT> elif b [ j ] <= temp and b [ j + 1 ] > temp : <NEWLINE> <INDENT> nb = j <NEWLINE> ans = max ( ans , i + nb ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for p in range ( 0 , i [ 0 ] - i [ 1 ] ) : <NEWLINE> <INDENT> if j [ p ] < j [ p + i [ 1 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> num = np . array ( list ( range ( 1 , n + 1 ) ) ) <NEWLINE> <NL> x = n // num <NEWLINE> ans = num * ( x + 1 ) * x / 2 <NEWLINE> print ( int ( np . sum ( ans ) ) ) <NEWLINE>
from operator import add <NEWLINE> <NL> <NL> def fold_right ( v , length ) : <NEWLINE> <INDENT> global white_right <NEWLINE> for i in range ( white_right , len ( v [ 0 ] ) ) : <NEWLINE> <INDENT> if not any ( list ( zip ( * v ) ) [ i ] ) : <NEWLINE> <INDENT> white_right += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( length - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for yoko in range ( len ( v ) ) : <NEWLINE> <INDENT> v [ yoko ] [ i + j + length ] += v [ yoko ] [ i + ( length - 1 - j ) ] <NEWLINE> v [ yoko ] [ i + ( length - 1 - j ) ] = 0 <NEWLINE> <DEDENT> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def fold_up ( v , length ) : <NEWLINE> <INDENT> global white_up <NEWLINE> for i in range ( white_up , - 1 , - 1 ) : <NEWLINE> <INDENT> if not any ( v [ i ] ) : <NEWLINE> <INDENT> white_up -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( length - 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> v [ i - j - length ] = list ( <NEWLINE> <INDENT> map ( add , v [ i - j - length ] , v [ i - ( length - 1 - j ) ] ) <NEWLINE> <DEDENT> ) <NEWLINE> v [ i - ( length - 1 - j ) ] = [ 0 ] * len ( v [ i - j ] ) <NEWLINE> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def cut_cut_cut ( v ) : <NEWLINE> <INDENT> global white_right <NEWLINE> global white_up <NEWLINE> for i in range ( len ( v ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if not any ( v [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> white_up = i <NEWLINE> break <NEWLINE> <DEDENT> for i in range ( len ( v [ 0 ] ) ) : <NEWLINE> <INDENT> if not any ( list ( zip ( * v ) ) [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> white_right = i <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , m , t , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 and t == 0 and p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> origami = [ [ 0 ] * 500 for _ in range ( 500 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> origami [ len ( origami ) - 1 - i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> white_right = 0 <NEWLINE> white_up = len ( origami ) - 1 <NEWLINE> <COMMENT> <NL> for i in range ( t ) : <NEWLINE> <INDENT> d , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> origami = fold_right ( origami , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> origami = fold_up ( origami , c ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> cut_cut_cut ( origami ) <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( origami [ white_up - y ] [ white_right + x ] ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> g = 9.8 <NEWLINE> ESP = 1e-6 <NEWLINE> <NL> <NL> def calc ( vy , t ) : <NEWLINE> <INDENT> return vy * t - g * t * t / 2 <NEWLINE> <NL> <NL> <DEDENT> def cmp ( lb , ub , a ) : <NEWLINE> <INDENT> if a < lb + ESP : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> elif ub - ESP < a : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def check ( qx , qy ) : <NEWLINE> <INDENT> a = ( g * g ) / 4 <NEWLINE> b = g * qy - V * V <NEWLINE> c = qx * qx + qy * qy <NEWLINE> D = b * b - 4 * a * c <NEWLINE> <NL> if D < 0 and - ESP < D : <NEWLINE> <INDENT> D = 0 <NEWLINE> <NL> <DEDENT> if D < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for d in range ( - 1 , 2 , 2 ) : <NEWLINE> <INDENT> t2 = ( - b + d * math . sqrt ( D ) ) / ( 2 * a ) <NEWLINE> if t2 <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> t = math . sqrt ( t2 ) <NEWLINE> vx = qx / t <NEWLINE> vy = ( qy + g * t * t / 2 ) / t <NEWLINE> <NL> yt = calc ( vy , X / vx ) <NEWLINE> if yt < Y - ESP : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ok = True <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if L [ i ] >= X : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if R [ i ] == X and Y <= T [ i ] and B [ i ] <= yt : <NEWLINE> <INDENT> ok = False <NEWLINE> <NL> <DEDENT> yL = cmp ( B [ i ] , T [ i ] , calc ( vy , L [ i ] / vx ) ) <NEWLINE> yR = cmp ( B [ i ] , T [ i ] , calc ( vy , R [ i ] / vx ) ) <NEWLINE> <NL> xH = cmp ( L [ i ] , R [ i ] , vx * ( vy / g ) ) <NEWLINE> yH = cmp ( B [ i ] , T [ i ] , calc ( vy , vy / g ) ) <NEWLINE> if xH == 0 and yH >= 0 and yL < 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> if yL * yR <= 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , V , X , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> B = [ ] <NEWLINE> R = [ ] <NEWLINE> T = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp_L , tmp_B , tmp_R , tmp_T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . append ( tmp_L ) <NEWLINE> B . append ( tmp_B ) <NEWLINE> R . append ( tmp_R ) <NEWLINE> T . append ( tmp_T ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> R [ i ] = min ( R [ i ] , X ) <NEWLINE> <NL> <DEDENT> ok = check ( X , Y ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if L [ i ] == 0 and T [ i ] != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok |= check ( L [ i ] , T [ i ] ) <NEWLINE> <NL> <DEDENT> if R [ i ] == 0 and T [ i ] != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok |= check ( R [ i ] , T [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if ok else <STRING> ) <NEWLINE> <DEDENT>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> def solve ( N , dic , S ) : <NEWLINE> <INDENT> ans = [ <STRING> ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dic [ S [ i ] [ 0 ] ] > dic [ S [ i ] [ 1 ] ] : <NEWLINE> <INDENT> dic [ S [ i ] [ 0 ] ] -= 1 <NEWLINE> dic [ S [ i ] [ 1 ] ] += 1 <NEWLINE> ans . append ( S [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif dic [ S [ i ] [ 0 ] ] < dic [ S [ i ] [ 1 ] ] or dic [ S [ i ] [ 0 ] ] > 1 : <NEWLINE> <INDENT> dic [ S [ i ] [ 1 ] ] -= 1 <NEWLINE> dic [ S [ i ] [ 0 ] ] += 1 <NEWLINE> ans . append ( S [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif dic [ S [ i ] [ 0 ] ] == 0 : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> dic [ S [ i ] [ 0 ] ] += 1 <NEWLINE> dic [ S [ i ] [ 1 ] ] -= 1 <NEWLINE> ans . append ( S [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] [ 0 ] in S [ i + 1 ] : <NEWLINE> <INDENT> dic [ S [ i ] [ 0 ] ] += 1 <NEWLINE> dic [ S [ i ] [ 1 ] ] -= 1 <NEWLINE> ans . append ( S [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ S [ i ] [ 1 ] ] += 1 <NEWLINE> dic [ S [ i ] [ 0 ] ] -= 1 <NEWLINE> ans . append ( S [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( * solve ( N , dic , S ) , sep = <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp [ a - 1 ] = max ( tmp [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> tmp [ b - 1 ] = max ( tmp [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > tmp [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> import numpy as np <NEWLINE> done = np . array ( [ 0 ] * N ) <NEWLINE> X = [ 0 ] * 2 <NEWLINE> L = [ ] <NEWLINE> F = [ True ] <NEWLINE> def dfs ( start , steps ) : <NEWLINE> <INDENT> done [ start - 1 ] += 1 <NEWLINE> L . append ( start ) <NEWLINE> if done [ start - 1 ] == 3 : <NEWLINE> <INDENT> X [ 1 ] = steps <NEWLINE> return <NEWLINE> <DEDENT> elif done [ start - 1 ] == 2 and F [ 0 ] : <NEWLINE> <INDENT> X [ 0 ] = steps <NEWLINE> F [ 0 ] = False <NEWLINE> <DEDENT> nex = A [ start - 1 ] <NEWLINE> dfs ( nex , steps + 1 ) <NEWLINE> <DEDENT> dfs ( 1 , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> first = L [ : X [ 0 ] - ( X [ 1 ] - X [ 0 ] ) ] <NEWLINE> sec = L [ X [ 0 ] - ( X [ 1 ] - X [ 0 ] ) : X [ 0 ] - ( X [ 1 ] - X [ 0 ] ) + ( X [ 1 ] - X [ 0 ] ) ] <NEWLINE> <COMMENT> <NL> if len ( first ) == 0 : <NEWLINE> <INDENT> first = sec <NEWLINE> <DEDENT> if K + 1 <= len ( first ) : <NEWLINE> <INDENT> print ( first [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - len ( first ) <NEWLINE> print ( sec [ ( K % len ( sec ) ) ] ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SUM_A = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> SUM_A [ i + 1 ] = A [ i ] + SUM_A [ i ] <NEWLINE> if SUM_A [ i + 1 ] > K : <NEWLINE> <INDENT> N = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> SUM_B = [ 0 for _ in range ( M + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> SUM_B [ i + 1 ] = B [ i ] + SUM_B [ i ] <NEWLINE> if SUM_B [ i + 1 ] > K : <NEWLINE> <INDENT> M = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = N <NEWLINE> for i in range ( N + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> V = K - SUM_A [ i ] <NEWLINE> j = cnt - i <NEWLINE> while j < M + 1 and SUM_B [ j ] <= V : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> if i + j > cnt : <NEWLINE> <INDENT> cnt = i + j <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a_ls = [ ] <NEWLINE> b_ls = [ ] <NEWLINE> c_ls = [ ] <NEWLINE> d_ls = [ ] <NEWLINE> <NL> for vnwrjvnwakn in range ( Q ) : <NEWLINE> <INDENT> abcd = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_ls += [ abcd [ 0 ] ] <NEWLINE> b_ls += [ abcd [ 1 ] ] <NEWLINE> c_ls += [ abcd [ 2 ] ] <NEWLINE> d_ls += [ abcd [ 3 ] ] <NEWLINE> <NL> <NL> <NL> <DEDENT> import itertools <NEWLINE> As = itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) <NEWLINE> ans = 0 <NEWLINE> for A in As : <NEWLINE> <INDENT> score = 0 <NEWLINE> Als = list ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if Als [ b_ls [ i ] - 1 ] - Als [ a_ls [ i ] - 1 ] == c_ls [ i ] : <NEWLINE> <INDENT> score += d_ls [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> L = [ ] <NEWLINE> for line in stdin : <NEWLINE> <INDENT> if not line . strip ( ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n = int ( line ) <NEWLINE> if not n : <NEWLINE> <INDENT> print ( L . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( n ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r * r , 2 * math . pi * r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums = [ 0 ] * n <NEWLINE> nums [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : nums [ i ] = a [ i ] + nums [ i - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( nums [ n - 1 ] - nums [ i ] ) <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> if checked [ v ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> checked [ v ] = 1 <NEWLINE> dp [ v ] [ 0 ] = 1 <NEWLINE> dp [ v ] [ 1 ] = 1 <NEWLINE> for u in g [ v ] : <NEWLINE> <INDENT> if checked [ u ] == 0 : <NEWLINE> <INDENT> dfs ( u ) <NEWLINE> dp [ v ] [ 0 ] = ( dp [ v ] [ 0 ] * ( dp [ u ] [ 0 ] + dp [ u ] [ 1 ] ) ) % mod <NEWLINE> dp [ v ] [ 1 ] = ( dp [ v ] [ 1 ] * dp [ u ] [ 0 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> dp = [ [ 0 , 0 ] for _ in range ( n + 1 ) ] <NEWLINE> checked = [ 0 ] * ( n + 1 ) <NEWLINE> dfs ( 1 ) <NEWLINE> print ( ( dp [ 1 ] [ 0 ] + dp [ 1 ] [ 1 ] ) % mod ) <NEWLINE>
import sys <NEWLINE> <NL> A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> c . append ( list ( map ( int , e . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = min ( a ) + min ( b ) <NEWLINE> <NL> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> temp_val = a [ c [ i ] [ 0 ] - 1 ] + b [ c [ i ] [ 1 ] - 1 ] - c [ i ] [ 2 ] <NEWLINE> if temp_val < ans : <NEWLINE> <INDENT> ans = temp_val <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> def p ( * _a ) : <NEWLINE> <INDENT> _s = <STRING> . join ( map ( str , _a ) ) <NEWLINE> <COMMENT> <NL> sys . stderr . write ( _s + <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <NL> M = [ [ 0 , 0 ] for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> <NL> p ( M ) <NEWLINE> <NL> i = 1 <NEWLINE> x = y = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> x , y = M [ i ] <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> M [ i ] [ 0 ] = A [ i ] <NEWLINE> M [ i ] [ 1 ] = k <NEWLINE> i = A [ i ] <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> a = K - y <NEWLINE> b = a % ( k - y ) <NEWLINE> for _ in range ( b ) : <NEWLINE> <INDENT> i = A [ i ] <NEWLINE> <NL> <DEDENT> p ( x , y , k ) <NEWLINE> p ( <STRING> , M [ 1 : ] ) <NEWLINE> <NL> break <NEWLINE> <NL> <DEDENT> ans = i <NEWLINE> print ( ans ) <NEWLINE> <NL>
<NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> nizi = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> nizi [ A [ i ] ] += 1 <NEWLINE> <DEDENT> sumall = sum ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> sumall += ( C - B ) * nizi [ B ] <NEWLINE> nizi [ C ] += nizi [ B ] <NEWLINE> nizi [ B ] = 0 <NEWLINE> print ( sumall ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A_sum -= A [ i ] <NEWLINE> ans += A_sum * ( A [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> m = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = B - A <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
tmp = input ( ) . split ( ) <NEWLINE> N = int ( tmp [ 0 ] ) <NEWLINE> <NL> ListG = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ListG . append ( input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ListG . sort ( ) <NEWLINE> p = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ListG [ i ] == ListG [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = a [ 0 ] <NEWLINE> n = a [ 1 ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> out_p = [ ] <NEWLINE> for i in range ( p [ n - 1 ] - p [ 0 ] + 1 ) : <NEWLINE> <INDENT> if not i + p [ 0 ] in p : <NEWLINE> <INDENT> out_p . append ( i + p [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if min ( p ) > x or max ( p ) < x : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_p = [ ] <NEWLINE> for j in range ( len ( out_p ) ) : <NEWLINE> <INDENT> re_p . append ( abs ( out_p [ j ] - x ) ) <NEWLINE> <DEDENT> if re_p : <NEWLINE> <INDENT> print ( out_p [ re_p . index ( min ( re_p ) ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( max ( p ) - x ) >= abs ( min ( p ) - x ) : <NEWLINE> <INDENT> print ( min ( p ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( p ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> s_r = s [ : : - 1 ] <NEWLINE> lmod = [ 0 ] <NEWLINE> cmod = 0 <NEWLINE> for n , i in enumerate ( s_r ) : <NEWLINE> <INDENT> cmod += int ( i ) * pow ( 10 , n , 2019 ) % 2019 <NEWLINE> cmod = cmod % 2019 <NEWLINE> lmod . append ( cmod ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> r = 0 <NEWLINE> for _ , i in Counter ( lmod ) . items ( ) : <NEWLINE> <INDENT> r += i * ( i - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = sum ( A [ 1 : ] ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * tmp <NEWLINE> tmp -= A [ i + 1 ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
<STRING> <NEWLINE> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> seq = list ( range ( 1 , N + 1 ) ) <NEWLINE> comb = list ( itertools . combinations_with_replacement ( seq , 3 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> i = 1 <NEWLINE> for c in comb : <NEWLINE> <INDENT> if i == 1 or ( c [ 0 ] == c [ 1 ] and c [ 1 ] == c [ 2 ] ) : <NEWLINE> <INDENT> s += gcd ( c [ 0 ] , c [ 1 ] , c [ 2 ] ) <NEWLINE> <DEDENT> elif c [ 0 ] != c [ 1 ] and c [ 1 ] != c [ 2 ] and c [ 0 ] != c [ 2 ] : <NEWLINE> <INDENT> s = s + gcd ( c [ 0 ] , c [ 1 ] , c [ 2 ] ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + gcd ( c [ 0 ] , c [ 1 ] , c [ 2 ] ) * 3 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ab = l [ i ] + l [ j ] <NEWLINE> right = bisect . bisect ( l , ab - 1 ) <NEWLINE> left = j + 1 <NEWLINE> count += ( right - left ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> queue . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> import itertools <NEWLINE> l = itertools . combinations ( range ( 1 , n + m ) , n ) <NEWLINE> for i in l : <NEWLINE> <INDENT> a = [ x - y for y , x in enumerate ( i ) ] <NEWLINE> x = 0 <NEWLINE> for j in queue : <NEWLINE> <INDENT> if a [ j [ 1 ] - 1 ] - a [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> x += j [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> x = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> count += math . gcd ( x , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ i for i in range ( 0 , 102 ) ] <NEWLINE> <NL> p . sort ( ) <NEWLINE> diff = list ( set ( t ) ^ set ( p ) ) <NEWLINE> <NL> for i in range ( len ( diff ) ) : <NEWLINE> <INDENT> diff [ i ] -= x <NEWLINE> <NL> <DEDENT> ans = diff [ 0 ] <NEWLINE> for i in range ( 1 , len ( diff ) ) : <NEWLINE> <INDENT> if abs ( ans ) > abs ( diff [ i ] ) : <NEWLINE> <INDENT> ans = diff [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans += x <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> def l ( s , n ) : <NEWLINE> <INDENT> o = ord ( s . lower ( ) ) <NEWLINE> if not 97 <= o <= 122 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> if 97 <= o + n <= 122 : <NEWLINE> <INDENT> if 97 <= ord ( s ) <= 122 : <NEWLINE> <INDENT> return chr ( o + n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return chr ( o + n ) . upper ( ) <NEWLINE> <DEDENT> <DEDENT> elif o + n > 122 : <NEWLINE> <INDENT> if 97 <= ord ( s ) <= 122 : <NEWLINE> <INDENT> return chr ( o + n - 26 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return chr ( o + n - 26 ) . upper ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if 97 <= ord ( s ) <= 122 : <NEWLINE> <INDENT> return chr ( o + n + 26 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return chr ( o + n + 26 ) . upper ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for t in sys . stdin : <NEWLINE> <INDENT> s = t [ : - 1 ] <NEWLINE> u = s . lower ( ) <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> cv = lambda y : <STRING> . join ( map ( lambda x : l ( x , i ) , y ) ) <NEWLINE> if cv ( <STRING> ) in u or cv ( <STRING> ) in u or cv ( <STRING> ) in u : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( lambda x : l ( x , - i ) , s ) ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> L_0 = 2 <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> L_1 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L_2 = L_0 + L_1 <NEWLINE> L_0 = L_1 <NEWLINE> L_1 = L_2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( L_2 ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( ( <STRING> + <STRING> * ( w - 2 ) + <STRING> + <STRING> ) * ( h - 2 ) + <STRING> * w ) if h > 2 and w >= 2 else 0 <NEWLINE> print ( <STRING> * w ) if h == 2 else 0 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mx = 1e18 <NEWLINE> pr = 1 <NEWLINE> done = True <NEWLINE> zero = False <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> zero = True <NEWLINE> <NL> <DEDENT> <DEDENT> if zero == False : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> pr = pr * i <NEWLINE> if pr > mx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pr = 0 <NEWLINE> <DEDENT> if zero or pr <= mx : <NEWLINE> <INDENT> print ( pr ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( 3 * N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> <NL> G [ u ] . append ( v + N ) <NEWLINE> G [ u + N ] . append ( v + 2 * N ) <NEWLINE> G [ u + 2 * N ] . append ( v ) <NEWLINE> <NL> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> <NL> dist = [ INF ] * ( 3 * N ) <NEWLINE> dist [ s ] = 0 <NEWLINE> <NL> Q = deque ( [ s ] ) <NEWLINE> while len ( Q ) > 0 : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if dist [ v ] == INF : <NEWLINE> <INDENT> dist [ v ] = dist [ u ] + 1 <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if dist [ t ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ t ] // 3 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> X_L = [ None ] * N <NEWLINE> Y_L = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _x , _y = map ( int , input ( ) . split ( ) ) <NEWLINE> X_L [ i ] = [ _x , i ] <NEWLINE> Y_L [ i ] = [ _y , i ] <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> X_L . sort ( ) <NEWLINE> Y_L . sort ( ) <NEWLINE> dx_l = [ None ] * ( N - 1 ) <NEWLINE> dy_l = [ None ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> dx_l [ i ] = [ X_L [ i + 1 ] [ 0 ] - X_L [ i ] [ 0 ] , X_L [ i ] [ 1 ] , X_L [ i + 1 ] [ 1 ] ] <NEWLINE> dy_l [ i ] = [ Y_L [ i + 1 ] [ 0 ] - Y_L [ i ] [ 0 ] , Y_L [ i ] [ 1 ] , Y_L [ i + 1 ] [ 1 ] ] <NEWLINE> <NL> <DEDENT> tmp_l = dx_l + dy_l <NEWLINE> tmp_l . sort ( ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> ans = 0 <NEWLINE> <NL> for _ in range ( 2 * N - 2 ) : <NEWLINE> <INDENT> _d , _i , _j = tmp_l [ _ ] <NEWLINE> if UF . same ( _i , _j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> UF . unite ( _i , _j ) <NEWLINE> ans += _d <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if ( 0 < i < a - 1 and 0 < j < b - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> p = [ 1 ] * ( n + 1 ) <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> <NL> for i in range ( math . ceil ( ( n + 1 ) ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( p ) , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def prime_factor ( n ) : <NEWLINE> <INDENT> p = sieve ( int ( n ** 0.5 ) ) <NEWLINE> factor = [ ] <NEWLINE> for pi in compress ( count ( 0 ) , p ) : <NEWLINE> <INDENT> while n % pi == 0 : <NEWLINE> <INDENT> n //= pi <NEWLINE> factor . append ( pi ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> factor . append ( n ) <NEWLINE> <DEDENT> return factor <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> from itertools import compress , count <NEWLINE> <NL> readline = stdin . readline <NEWLINE> <NL> <NL> n = int ( readline ( ) ) <NEWLINE> print ( <STRING> . format ( n ) + <STRING> . join ( map ( str , prime_factor ( n ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> k = 0 <NEWLINE> flg = False <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai == k + 1 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> <DEDENT> <DEDENT> if k == 0 and flg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - k ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> it = lambda : list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N , K = it ( ) <NEWLINE> A = it ( ) <NEWLINE> <NL> zero = 0 <NEWLINE> neg = [ ] <NEWLINE> pos = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> neg . append ( A [ i ] ) <NEWLINE> <DEDENT> elif A [ i ] > 0 : <NEWLINE> <INDENT> pos . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if not neg and not pos : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> pos . sort ( ) <NEWLINE> neg . sort ( reverse = True ) <NEWLINE> <NL> if not pos and K % 2 == 1 : <NEWLINE> <INDENT> if zero > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * neg [ i ] % MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for _ in range ( K >> 1 ) : <NEWLINE> <INDENT> if len ( pos ) >= 2 and len ( neg ) >= 2 : <NEWLINE> <INDENT> if neg [ - 1 ] * neg [ - 2 ] >= pos [ - 1 ] * pos [ - 2 ] : <NEWLINE> <INDENT> ans = ans * neg . pop ( ) % MOD * neg . pop ( ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * pos . pop ( ) % MOD * pos . pop ( ) % MOD <NEWLINE> <DEDENT> <DEDENT> elif len ( pos ) >= 2 : <NEWLINE> <INDENT> ans = ans * pos . pop ( ) % MOD * pos . pop ( ) % MOD <NEWLINE> <DEDENT> elif len ( neg ) >= 2 : <NEWLINE> <INDENT> ans = ans * neg . pop ( ) % MOD * neg . pop ( ) % MOD <NEWLINE> <DEDENT> elif len ( pos ) == 1 and len ( neg ) == 1 : <NEWLINE> <INDENT> ans = ans * pos . pop ( ) % MOD * neg . pop ( ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if K % 2 == 1 : <NEWLINE> <INDENT> if pos : <NEWLINE> <INDENT> ans = ans * pos . pop ( ) % MOD <NEWLINE> <DEDENT> elif neg : <NEWLINE> <INDENT> ans = ans * neg . pop ( ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> if zero > 1 and ans < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> class WeightedUnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> self . weight = [ 0 ] * ( n + 1 ) <NEWLINE> self . added = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . find ( self . par [ x ] ) <NEWLINE> <COMMENT> <NL> self . weight [ x ] += self . weight [ self . par [ x ] ] <NEWLINE> self . par [ x ] = y <NEWLINE> return y <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y , w ) : <NEWLINE> <INDENT> rx = self . find ( x ) <NEWLINE> ry = self . find ( y ) <NEWLINE> self . added [ x ] += w <NEWLINE> self . added [ y ] += w <NEWLINE> <COMMENT> <NL> if self . rank [ rx ] < self . rank [ ry ] : <NEWLINE> <INDENT> self . par [ rx ] = ry <NEWLINE> <COMMENT> <NL> self . weight [ rx ] = w - self . diff ( x , y ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . par [ ry ] = rx <NEWLINE> <COMMENT> <NL> self . weight [ ry ] = - w + self . diff ( x , y ) <NEWLINE> <COMMENT> <NL> if self . rank [ rx ] == self . rank [ ry ] : <NEWLINE> <INDENT> self . rank [ rx ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def diff ( self , x , y ) : <NEWLINE> <INDENT> return self . weight [ x ] - self . weight [ y ] + self . added [ x ] - self . added [ y ] <NEWLINE> <NL> <DEDENT> def added_diff ( self , x , y ) : <NEWLINE> <INDENT> return self . diff ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dealIn ( l ) : <NEWLINE> <INDENT> a , b , c = l <NEWLINE> Un . union ( b , a , c ) <NEWLINE> <NL> <NL> <DEDENT> def compare ( l ) : <NEWLINE> <INDENT> a , b = l <NEWLINE> if Un . same ( a , b ) : <NEWLINE> <INDENT> diff = Un . added_diff ( b , a ) <NEWLINE> return diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> Un = WeightedUnionFind ( N + 1 ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> s , * l = input ( ) . split ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> dealIn ( list ( map ( int , l ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = compare ( list ( map ( int , l ) ) ) <NEWLINE> ans . append ( ret ) <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for b in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while b % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> b /= 2 <NEWLINE> <DEDENT> a . append ( count ) <NEWLINE> <NL> <DEDENT> print ( a . index ( max ( a ) ) + 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> <NL> max_l = 0 <NEWLINE> min_r = f_inf <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> max_l = max ( max_l , l ) <NEWLINE> min_r = min ( min_r , r ) <NEWLINE> <NL> <DEDENT> if min_r >= max_l : <NEWLINE> <INDENT> print ( min_r - max_l + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> W , H , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if ( ( x - r ) >= 0 ) and ( ( x + r ) <= W ) and ( ( y - r ) >= 0 ) and ( ( y + r ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans_list = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> temp = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if temp <= n : <NEWLINE> <INDENT> ans_list [ temp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> str = input ( ) <NEWLINE> <NL> r = str . count ( <STRING> ) <NEWLINE> g = str . count ( <STRING> ) <NEWLINE> b = str . count ( <STRING> ) <NEWLINE> sum = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if str [ i ] != str [ j ] and str [ i ] != str [ k ] and str [ j ] != str [ k ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> length = int ( input ( ) ) <NEWLINE> targ = [ ] <NEWLINE> cnt = 0 <NEWLINE> mcnt = 1 <NEWLINE> for l in range ( length ) : <NEWLINE> <INDENT> targ . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> m = 1 <NEWLINE> mlist = [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> m = math . ceil ( 2.25 * m + 1 ) <NEWLINE> if length <= m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mcnt += 1 <NEWLINE> mlist . append ( m ) <NEWLINE> <DEDENT> print ( mcnt ) <NEWLINE> print ( <STRING> . join ( [ str ( n ) for n in reversed ( mlist ) ] ) ) <NEWLINE> mlength = mcnt - 1 <NEWLINE> while mlength >= 0 : <NEWLINE> <INDENT> m = mlist [ mlength ] <NEWLINE> divided = length // m <NEWLINE> for inh in range ( m , length ) : <NEWLINE> <INDENT> inlength = inh - m <NEWLINE> temp = targ [ inh ] <NEWLINE> while inlength >= 0 and temp < targ [ inlength ] : <NEWLINE> <INDENT> targ [ inlength + m ] = targ [ inlength ] <NEWLINE> cnt += 1 <NEWLINE> inlength -= m <NEWLINE> <DEDENT> targ [ inlength + m ] = temp <NEWLINE> <DEDENT> mlength -= 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> for l in range ( length ) : <NEWLINE> <INDENT> print ( targ [ l ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ca = [ 0 ] * ( n + 1 ) <NEWLINE> ca [ 1 ] = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca [ i + 1 ] = ca [ i ] + a [ i ] <NEWLINE> <DEDENT> cb = [ 0 ] * ( m + 1 ) <NEWLINE> cb [ 1 ] = b [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cb [ i + 1 ] = cb [ i ] + b [ i ] <NEWLINE> <DEDENT> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> t = ca [ i ] <NEWLINE> while j >= 0 : <NEWLINE> <INDENT> if t + cb [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in ans ] <NEWLINE>
x , n = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> value = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> value . append ( [ a - 1 , b - 1 , c , d ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for comb in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for v in value : <NEWLINE> <INDENT> if comb [ v [ 1 ] ] == comb [ v [ 0 ] ] + v [ 2 ] : <NEWLINE> <INDENT> temp += v [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( a , l ) <NEWLINE> ans += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> group_list = [ ] <NEWLINE> group_index = [ 0 ] * N <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if group_index [ a - 1 ] == 0 and group_index [ b - 1 ] == 0 : <NEWLINE> <INDENT> group_index [ a - 1 ] = len ( group_list ) + 1 <NEWLINE> group_index [ b - 1 ] = len ( group_list ) + 1 <NEWLINE> group_list . append ( set ( [ a , b ] ) ) <NEWLINE> <NL> <DEDENT> elif group_index [ a - 1 ] == 0 : <NEWLINE> <INDENT> group_index [ a - 1 ] = group_index [ b - 1 ] <NEWLINE> group_list [ group_index [ b - 1 ] - 1 ] . add ( a ) <NEWLINE> <NL> <DEDENT> elif group_index [ b - 1 ] == 0 : <NEWLINE> <INDENT> group_index [ b - 1 ] = group_index [ a - 1 ] <NEWLINE> group_list [ group_index [ a - 1 ] - 1 ] . add ( b ) <NEWLINE> <NL> <DEDENT> elif group_index [ a - 1 ] != group_index [ b - 1 ] : <NEWLINE> <INDENT> if len ( group_list [ group_index [ a - 1 ] - 1 ] ) > len ( group_list [ group_index [ b - 1 ] - 1 ] ) : <NEWLINE> <INDENT> group_id_b = group_index [ b - 1 ] - 1 <NEWLINE> for p in group_list [ group_id_b ] : <NEWLINE> <INDENT> group_index [ p - 1 ] = group_index [ a - 1 ] <NEWLINE> group_list [ group_index [ a - 1 ] - 1 ] . add ( p ) <NEWLINE> <DEDENT> group_list [ group_id_b ] = set ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> group_id_a = group_index [ a - 1 ] - 1 <NEWLINE> for p in group_list [ group_id_a ] : <NEWLINE> <INDENT> group_index [ p - 1 ] = group_index [ b - 1 ] <NEWLINE> group_list [ group_index [ b - 1 ] - 1 ] . add ( p ) <NEWLINE> <DEDENT> group_list [ group_id_a ] = set ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ len ( g ) for g in group_list ] ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def merge ( x , y ) : <NEWLINE> <INDENT> a , b = dp [ x ] <NEWLINE> c , d = dp [ y ] <NEWLINE> if a >= c : <NEWLINE> <INDENT> return ( a , max ( c , b ) ) <NEWLINE> <DEDENT> return ( c , max ( a , d ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ ( a , 0 ) for a in A ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> if i & ( 1 << j ) : <NEWLINE> <INDENT> dp [ i ] = merge ( i , i & ~ ( 1 << j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> L = tuple ( accumulate ( ( sum ( d ) for d in dp ) , max ) ) <NEWLINE> print ( * L [ 1 : ] , sep = <STRING> ) <NEWLINE>
from bisect import bisect_left <NEWLINE> A , B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( A ) ] <NEWLINE> t = [ int ( input ( ) ) for _ in range ( B ) ] <NEWLINE> <NL> s . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> <NL> for k in range ( Q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> ms = bisect_left ( s , x ) <NEWLINE> for i in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= ms + i <= A - 1 : <NEWLINE> <INDENT> mt = bisect_left ( t , s [ ms + i ] ) <NEWLINE> for j in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= mt + j <= B - 1 : <NEWLINE> <INDENT> ans . append ( abs ( s [ ms + i ] - x ) + abs ( t [ mt + j ] - s [ ms + i ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> mt = bisect_left ( t , x ) <NEWLINE> for i in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= mt + i <= B - 1 : <NEWLINE> <INDENT> ms = bisect_left ( s , t [ mt + i ] ) <NEWLINE> for j in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= ms + j <= A - 1 : <NEWLINE> <INDENT> ans . append ( abs ( t [ mt + i ] - x ) + abs ( s [ ms + j ] - t [ mt + i ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> print ( min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) * 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> if b - a < k : <NEWLINE> <INDENT> k = b - a + 1 <NEWLINE> <DEDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> x = list ( set ( x ) ) <NEWLINE> x . sort ( ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
M = 2147483647 <NEWLINE> a = [ M for i in range ( 1000000 ) ] <NEWLINE> <NL> def j_min ( x , y ) : <NEWLINE> <INDENT> if x < y : return x <NEWLINE> else : return y <NEWLINE> <NL> <DEDENT> def find ( x , y , i , l , r ) : <NEWLINE> <INDENT> if r <= x or y <= l : return M <NEWLINE> if x <= l and r <= y : return a [ i ] <NEWLINE> return j_min ( find ( x , y , i * 2 , l , ( l + r ) / 2 ) , find ( x , y , i * 2 + 1 , ( l + r ) / 2 , r ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> t = 1 <NEWLINE> while t < n : t *= 2 <NEWLINE> <NL> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> com , x , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if com : <NEWLINE> <COMMENT> <NL> <INDENT> print ( find ( x , y + 1 , 1 , 0 , t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += t <NEWLINE> a [ x ] = y <NEWLINE> while isinstance ( x , int ) or x >= 2 : <NEWLINE> <INDENT> a [ int ( x / 2 ) ] = j_min ( a [ int ( x ) ] , a [ int ( x ) ^ 1 ] ) <NEWLINE> x /= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
T = input ( ) <NEWLINE> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> max_num = 0 <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( int ( ( A * x ) / B ) - ( A * int ( x / B ) ) ) <NEWLINE>
import sys <NEWLINE> from itertools import groupby <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = readline ( ) . strip ( ) <NEWLINE> <NL> idx = 0 <NEWLINE> ans = [ 0 ] * len ( S ) <NEWLINE> for k , g in groupby ( S ) : <NEWLINE> <INDENT> L = len ( list ( g ) ) <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if ( L - i ) % 2 == 0 : <NEWLINE> <INDENT> ans [ idx + L ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ idx + L - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k == <STRING> : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans [ idx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ idx - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> idx += L <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def agcd ( l ) : <NEWLINE> <INDENT> a = math . gcd ( l [ 0 ] , l [ 1 ] ) <NEWLINE> for i in range ( 2 , len ( l ) ) : <NEWLINE> <INDENT> a = math . gcd ( a , l [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ abs ( i - X ) for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> print ( agcd ( x ) if 1 < N else x [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = l [ i ] - i - 1 <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( sum ( list ( map ( lambda x : abs ( x - l [ ( ( n // 2 ) ) ] ) , l ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( sum ( list ( map ( lambda x : abs ( x - l [ ( n // 2 ) - 1 ] ) , l ) ) ) , sum ( list ( map ( lambda x : abs ( x - l [ ( n // 2 ) ] ) , l ) ) ) ) ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> MOD_t_MAX = 5 * 10 ** 5 + 10 <NEWLINE> <NL> fac = [ None ] * MOD_t_MAX <NEWLINE> finv = [ None ] * MOD_t_MAX <NEWLINE> inv = [ None ] * MOD_t_MAX <NEWLINE> def MOD_COM_init ( ) : <NEWLINE> <INDENT> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MOD_t_MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <DEDENT> <DEDENT> def MOD_COM ( n , k ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD <NEWLINE> <NL> <DEDENT> def MOD_perm ( n , r ) : <NEWLINE> <INDENT> rtn = 1 <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> rtn *= n <NEWLINE> rtn %= MOD <NEWLINE> n -= 1 <NEWLINE> <DEDENT> return rtn <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> perm = MOD_perm ( m , n ) <NEWLINE> MOD_COM_init ( ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> tmp = perm * MOD_COM ( n , i ) % MOD <NEWLINE> ans += ( - 1 ) ** i * tmp <NEWLINE> ans %= MOD <NEWLINE> if i < n : <NEWLINE> <INDENT> perm *= inv [ m - i ] <NEWLINE> perm %= MOD <NEWLINE> <DEDENT> <DEDENT> print ( ans * MOD_perm ( m , n ) % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B > N : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - A * math . floor ( N / B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( math . floor ( A * ( B - 1 ) / B ) - A * math . floor ( ( B - 1 ) / B ) ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def is_ok ( arg ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for item in a : <NEWLINE> <INDENT> i += math . ceil ( item / arg ) - 1 <NEWLINE> <DEDENT> return i <= K <NEWLINE> <NL> <DEDENT> def meguru_bisect ( ng , ok ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> print ( meguru_bisect ( 0 , 10 ** 9 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> from collections import OrderedDict , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ret = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = N // i <NEWLINE> left = i <NEWLINE> right = i * tmp <NEWLINE> ret += ( left + right ) * tmp // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxi = 10 ** 18 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> mult = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> mult *= a <NEWLINE> if mult > maxi : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( mult ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def binarySearch ( A , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( A ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> print ( sum ( map ( lambda t : binarySearch ( S , t ) >= 0 , T ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == W / 2 and y == H / 2 : <NEWLINE> <INDENT> print ( ( W * H ) / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( W * H ) / 2 , 0 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> A = set ( A ) <NEWLINE> MAX_A = 10 ** 6 <NEWLINE> X = [ 0 ] * ( MAX_A + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( a , MAX_A + 1 , a ) : <NEWLINE> <INDENT> X [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( [ a for a in A if ( X [ a ] == 1 ) and ( C [ a ] == 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> def div ( x , y ) : <COMMENT> <NEWLINE> <INDENT> A = 1 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 and y % i == 0 : <NEWLINE> <INDENT> A = max ( A , i ) <NEWLINE> <DEDENT> j = int ( x / i ) <NEWLINE> if x % j == 0 and y % j == 0 : <NEWLINE> <INDENT> A = max ( A , j ) <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <DEDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( div ( x , y ) ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> t = 0 <NEWLINE> res = <STRING> <NEWLINE> while n > 26 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> res += s [ n % 26 ] <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> res += s [ n - 1 ] <NEWLINE> print ( res [ : : - 1 ] ) <NEWLINE>
import itertools <NEWLINE> import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aa = [ 0 ] + list ( itertools . accumulate ( A ) ) <NEWLINE> bb = [ 0 ] + list ( itertools . accumulate ( B ) ) <NEWLINE> <NL> ans = bisect . bisect_left ( aa , K ) - 1 <NEWLINE> ans = max ( ans , bisect . bisect_left ( bb , K ) - 1 ) <NEWLINE> <NL> for i in reversed ( range ( N + 1 ) ) : <NEWLINE> <INDENT> tmp_K = K - aa [ i ] <NEWLINE> if tmp_K == 0 : <NEWLINE> <INDENT> ans = max ( ans , i ) <NEWLINE> <DEDENT> elif tmp_K < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if i + M <= ans : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if tmp_K >= bb [ - 1 ] : <NEWLINE> <INDENT> ans = max ( ans , i + M ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> ans = max ( ans , bisect . bisect_left ( bb , tmp_K ) - 1 + i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> ans += k * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> tmp = a <NEWLINE> if tmp == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> if tmp == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r_count = s . count ( <STRING> ) <NEWLINE> g_count = s . count ( <STRING> ) <NEWLINE> b_count = s . count ( <STRING> ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if ( 2 * j - i ) > ( n - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = s [ j ] <NEWLINE> c = s [ 2 * j - i ] <NEWLINE> if a != b and b != c and a != c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r_count * g_count * b_count - count ) <NEWLINE>
S = input ( ) <NEWLINE> mod_list = [ 0 for i in range ( 2019 ) ] <NEWLINE> mod_list [ 0 ] += 1 <NEWLINE> number = 0 <NEWLINE> ten_count = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> number += pow ( 10 , ten_count , 2019 ) * int ( s ) <NEWLINE> ten_count += 1 <NEWLINE> mod_list [ number % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in mod_list : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
li1 = [ ] <NEWLINE> li2 = [ ] <NEWLINE> ans = 0 <NEWLINE> for i , s in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> li1 . append ( i ) <NEWLINE> <DEDENT> elif s == <STRING> and li1 : <NEWLINE> <INDENT> j = li1 . pop ( ) <NEWLINE> c = i - j <NEWLINE> ans += c <NEWLINE> while li2 and li2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> c += li2 [ - 1 ] [ 1 ] <NEWLINE> li2 . pop ( ) <NEWLINE> <DEDENT> li2 . append ( ( j , c ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> if li2 : <NEWLINE> <INDENT> print ( len ( li2 ) , * list ( zip ( * li2 ) ) [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> plus = [ A [ i ] + ( i + 1 ) for i in range ( N ) ] <NEWLINE> diff = [ - A [ i ] + ( i + 1 ) for i in range ( N ) ] <NEWLINE> <NL> plusc = defaultdict ( list ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> plusc [ plus [ i ] ] . append ( i ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( plusc [ diff [ i ] ] , i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a1 = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> from collections import Counter <NEWLINE> a = Counter ( a1 ) . most_common ( ) <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> MOD2 = 998244353 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N , M = NMI ( ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> A , B = NMI ( ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( n ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> am = max ( a ) <NEWLINE> dp = [ [ True , 0 ] for _ in range ( am + 1 ) ] <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if dp [ i ] [ 0 ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dp [ i ] [ 1 ] == 1 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = False <NEWLINE> count -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = 1 <NEWLINE> count += 1 <NEWLINE> for j in range ( 2 * i , am + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] [ 0 ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> for _ in range ( 1 , Q ) : <NEWLINE> <INDENT> BC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> num = [ 0 ] * 10 ** 5 <NEWLINE> <NL> <COMMENT> <NL> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> num [ A [ k ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> counter = 0 <COMMENT> <NEWLINE> s = sum ( A ) <COMMENT> <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> counter = num [ BC [ q ] [ 0 ] - 1 ] <NEWLINE> num [ BC [ q ] [ 1 ] - 1 ] += counter <COMMENT> <NEWLINE> num [ BC [ q ] [ 0 ] - 1 ] = 0 <COMMENT> <NEWLINE> s += ( BC [ q ] [ 1 ] - BC [ q ] [ 0 ] ) * counter <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if K - A <= 0 : <NEWLINE> <INDENT> ans = K <NEWLINE> <NL> <DEDENT> elif K - A - B <= 0 : <NEWLINE> <INDENT> ans = A <NEWLINE> <NL> <DEDENT> elif K - A - B - C <= 0 : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ input ( ) for i in range ( N ) ] <NEWLINE> result = 12 * 10 ** 5 + 1 <NEWLINE> for i in range ( 1 , 1 << N ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> skill = [ 0 for i in range ( M ) ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> book = books [ j ] . split ( ) <NEWLINE> cost += int ( book [ 0 ] ) <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> skill [ k ] += int ( book [ k + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( j >= X for j in skill ) : <NEWLINE> <INDENT> result = min ( result , cost ) <NEWLINE> <DEDENT> <DEDENT> if result == 12 * 10 ** 5 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = input ( ) <NEWLINE> A_str = input ( ) . split ( ) <NEWLINE> <NL> if <STRING> in A_str : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> c = Counter ( sorted ( A_str ) ) <NEWLINE> res = 1 <NEWLINE> for i , v in c . items ( ) : <NEWLINE> <INDENT> res *= int ( i ) ** v <NEWLINE> <NL> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum_gcd = [ 0 ] * 201 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum_gcd [ gcd ( i , j ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += sum_gcd [ i ] * gcd ( i , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) . rstrip ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += 0.5 * n * ( 2 * i + i * ( n - 1 ) ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_len = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> d = [ 0 ] * mod <NEWLINE> d [ 0 ] = 1 <NEWLINE> rev_num = 0 <NEWLINE> t = 1 <NEWLINE> <COMMENT> <NL> for i in reversed ( s ) : <NEWLINE> <INDENT> rev_num += int ( i ) * t <NEWLINE> rev_num %= mod <NEWLINE> d [ rev_num ] += 1 <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in d ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> V = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> V [ a - 1 ] . append ( b - 1 ) <NEWLINE> V [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> state = [ 0 ] * N <NEWLINE> q = deque ( ) <NEWLINE> ans = [ 0 ] * ( N ) <NEWLINE> <NL> state [ 0 ] = 1 <NEWLINE> q . append ( 0 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for u in V [ v ] : <NEWLINE> <INDENT> if state [ u ] == 0 : <NEWLINE> <INDENT> state [ u ] = 1 <NEWLINE> ans [ u ] = v + 1 <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
house = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> input_4 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> house [ input_4 [ 0 ] - 1 ] [ input_4 [ 1 ] - 1 ] [ input_4 [ 2 ] - 1 ] += input_4 [ 3 ] <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , house [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if s <= t : <NEWLINE> <INDENT> a . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if len ( a ) == 0 else min ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> m = 1 <NEWLINE> for e in a : <NEWLINE> <INDENT> m *= e <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
from queue import Queue <NEWLINE> <NL> def bfs ( AB , N ) : <NEWLINE> <INDENT> S = [ None for _ in range ( N + 1 ) ] <NEWLINE> <COMMENT> <NL> AB_N = [ set ( ) for _ in range ( N + 1 ) ] <NEWLINE> for ab in AB : <NEWLINE> <INDENT> a , b = ab [ 0 ] , ab [ 1 ] <NEWLINE> AB_N [ a ] . add ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> q = Queue ( ) <NEWLINE> q . put ( 1 ) <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> p = q . get ( ) <NEWLINE> for ab in AB_N [ p ] : <NEWLINE> <INDENT> a , b = ab [ 0 ] , ab [ 1 ] <NEWLINE> if a == p : <NEWLINE> <INDENT> if S [ b ] == None : <NEWLINE> <INDENT> q . put ( b ) <NEWLINE> S [ b ] = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> can = True <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if S [ i ] == None : <NEWLINE> <INDENT> can = False <NEWLINE> <NL> <DEDENT> <DEDENT> if can : <NEWLINE> <INDENT> return S [ 2 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> AB_ = set ( AB ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> AB_ . add ( ( AB [ i ] [ 1 ] , AB [ i ] [ 0 ] ) ) <NEWLINE> <DEDENT> AB = AB_ <NEWLINE> <NL> ans = bfs ( AB , N ) <NEWLINE> if ans == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> threshold = 10 ** 18 <NEWLINE> n = input ( ) <NEWLINE> list_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in list_ : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in list_ : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > threshold : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> sapp = [ [ 0 ] * n for _ in range ( 10 ) ] <NEWLINE> for idx , s in enumerate ( S ) : <NEWLINE> <INDENT> sapp [ int ( s ) ] [ idx ] = 1 <NEWLINE> <NL> <DEDENT> from itertools import accumulate <NEWLINE> sacc = [ list ( accumulate ( sa ) ) for sa in sapp ] <NEWLINE> <NL> pins = set ( ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for lnum in range ( 10 ) : <NEWLINE> <INDENT> if sacc [ lnum ] [ i - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for rnum in range ( 10 ) : <NEWLINE> <COMMENT> <NL> <INDENT> rnumc = sacc [ rnum ] [ - 1 ] - sacc [ rnum ] [ i ] <NEWLINE> if rnumc > 0 : <NEWLINE> <INDENT> pins . add ( 100 * lnum + 10 * int ( S [ i ] ) + rnum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( pins ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> H , W = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> grid = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> grid . append ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> q = deque ( ) <NEWLINE> q . append ( ( 0 , 0 , 0 ) ) <NEWLINE> visited = set ( ) <NEWLINE> while q : <NEWLINE> <INDENT> x , y , c = q . popleft ( ) <NEWLINE> if x == W - 1 and y == H - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( x , y ) in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( ( x , y ) ) <NEWLINE> <NL> for dx , dy in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> if 0 <= nx < W and 0 <= ny < H and grid [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> q . append ( ( nx , ny , c + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if x == W - 1 and y == H - 1 : <NEWLINE> <INDENT> print ( H * W - black - c - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 != n % 2 : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = d * a [ i ] <NEWLINE> if d > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> Q , A , B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> N = A + B + C <NEWLINE> S = read ( ) . split ( ) <NEWLINE> <NL> S = tuple ( 0 if s == <STRING> else 1 if s == <STRING> else 2 for s in S ) <NEWLINE> <NL> def solve_1 ( N , A , B , C , S ) : <NEWLINE> <INDENT> nums = [ A , B , C ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if nums [ s ] == N : <NEWLINE> <INDENT> raise Exception <NEWLINE> <DEDENT> i , j = ( 0 , 1 ) if s == 2 else ( 0 , 2 ) if s == 1 else ( 1 , 2 ) <NEWLINE> if nums [ i ] < nums [ j ] : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> yield j <NEWLINE> nums [ j ] += 1 <NEWLINE> nums [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def solve_2 ( N , A , B , C , S ) : <NEWLINE> <INDENT> nums = [ A , B , C ] <NEWLINE> s = S [ 0 ] <NEWLINE> <COMMENT> <NL> if nums [ s ] == N : <NEWLINE> <INDENT> raise Exception <NEWLINE> <COMMENT> <NL> <DEDENT> S = S + ( 0 , ) <NEWLINE> for s , t in zip ( S , S [ 1 : ] ) : <NEWLINE> <INDENT> i , j = ( 0 , 1 ) if s == 2 else ( 0 , 2 ) if s == 1 else ( 1 , 2 ) <NEWLINE> if ( nums [ i ] , nums [ j ] ) != ( 1 , 1 ) : <NEWLINE> <INDENT> if nums [ i ] < nums [ j ] : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> <DEDENT> elif s != t : <NEWLINE> <INDENT> i , j = t , 3 - s - t <NEWLINE> <DEDENT> yield j <NEWLINE> nums [ j ] += 1 <NEWLINE> nums [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def large ( N , A , B , C , S ) : <NEWLINE> <INDENT> nums = [ A , B , C ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if nums [ s ] == N : <NEWLINE> <INDENT> raise Exception <NEWLINE> <DEDENT> i , j = ( 0 , 1 ) if s == 2 else ( 0 , 2 ) if s == 1 else ( 1 , 2 ) <NEWLINE> if nums [ i ] < nums [ j ] : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> yield j <NEWLINE> nums [ j ] += 1 <NEWLINE> nums [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> f = solve_1 if N == 1 else solve_2 if N == 2 else large <NEWLINE> <NL> try : <NEWLINE> <INDENT> cmds = list ( f ( N , A , B , C , S ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> answer = ( <STRING> [ i ] for i in cmds ) <NEWLINE> print ( <STRING> . join ( answer ) ) <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod_value = 10 ** 9 + 7 <NEWLINE> sum_ = 0 <NEWLINE> b_sum = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> b_sum = b_sum + A [ len ( A ) - i - 1 ] <NEWLINE> sum_ = sum_ + ( A [ len ( A ) - i - 2 ] * b_sum ) % mod_value <NEWLINE> <DEDENT> print ( sum_ % mod_value ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> mod = 2019 <NEWLINE> tc = [ 0 ] * 2019 <NEWLINE> <NL> lens = len ( s ) <NEWLINE> <NL> tc [ 0 ] = 1 <NEWLINE> tim = 0 <NEWLINE> p10 = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ti = ( tim + int ( s [ i ] ) * p10 ) % mod <NEWLINE> tc [ ti ] += 1 <NEWLINE> <COMMENT> <NL> tim = ti <NEWLINE> p10 = p10 * 10 % mod <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> tsum = 0 <NEWLINE> for i in tc : <NEWLINE> <INDENT> tsum += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( tsum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def solve2 ( N , A ) : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> amax = A [ - 1 ] <NEWLINE> dp = [ True ] * ( amax + 1 ) <NEWLINE> cnt = [ 0 ] * ( amax + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( amax ) : <NEWLINE> <INDENT> x = i + 1 <NEWLINE> if cnt [ x ] > 1 : <NEWLINE> <INDENT> dp [ x ] = False <NEWLINE> <NL> <DEDENT> if cnt [ x ] > 0 : <NEWLINE> <INDENT> y = x * 2 <NEWLINE> while y <= amax : <NEWLINE> <INDENT> dp [ y ] = False <NEWLINE> y += x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ansval = [ x for x in A if dp [ x ] ] <NEWLINE> <NL> <COMMENT> <NL> ans = len ( ansval ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <NL> <DEDENT> def solve1 ( N , A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> is_ans = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> if A [ i ] % A [ j ] == 0 : <NEWLINE> <INDENT> is_ans = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if is_ans : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve2 ( N , A ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> <NL> def fuctrization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> tmp = n <NEWLINE> for i in range ( 2 , math . ceil ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> j = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> arr . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <NEWLINE> <DEDENT> if arr : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr = fuctrization ( n ) <NEWLINE> nn = 0 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> k = arr [ i ] [ 1 ] <NEWLINE> nnn = 1 <NEWLINE> while k - nnn >= 0 : <NEWLINE> <INDENT> k -= nnn <NEWLINE> nnn += 1 <NEWLINE> nn += 1 <NEWLINE> <DEDENT> <DEDENT> print ( nn ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> max = 0 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> b . append ( B ) <NEWLINE> c . append ( C ) <NEWLINE> d . append ( D ) <NEWLINE> <NL> <DEDENT> nums = range ( 1 , m + 1 ) <NEWLINE> <NL> for retsu in itertools . combinations_with_replacement ( nums , n ) : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if int ( retsu [ b [ i ] - 1 ] ) - int ( retsu [ a [ i ] - 1 ] ) == c [ i ] : <NEWLINE> <INDENT> tmp = tmp + d [ i ] <NEWLINE> <DEDENT> if max < tmp : <NEWLINE> <INDENT> max = tmp <NEWLINE> <DEDENT> <DEDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> init = 7 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if init % k == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> init = ( init * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for k in a : <NEWLINE> <INDENT> count ^= k <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> count ^= a [ i ] <NEWLINE> print ( count , end = <STRING> ) <NEWLINE> count ^= a [ i ] <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> check = 10 ** 18 <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > check : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for v in a : <NEWLINE> <INDENT> ans *= v <NEWLINE> if 1000000000000000000 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if any ( [ v == 0 for v in a ] ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * x , = map ( int , input ( ) . split ( ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i < y [ n // 2 ] : <NEWLINE> <INDENT> print ( y [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> rgb = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <NL> if k >= n or s [ i ] == s [ j ] or s [ j ] == s [ k ] or s [ i ] == s [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> rgb -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rgb ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> out = <STRING> <NEWLINE> <NL> if V == W : <NEWLINE> <INDENT> if B == A : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> print ( out ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( out ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if B < A : <NEWLINE> <INDENT> t = ( B - A ) / ( W - V ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( B - A ) / ( V - W ) <NEWLINE> <NL> <DEDENT> if t >= 0 : <NEWLINE> <INDENT> if t <= T : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> snum = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = input ( ) <NEWLINE> qnum = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in qnum : <NEWLINE> <INDENT> if i in snum : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if ( V > W ) : <NEWLINE> <INDENT> if ( - ( V - W ) * T <= A - B <= ( V - W ) * T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
L = list ( input ( ) ) <NEWLINE> L = list ( set ( L ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> R = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( min ( 26 , len ( L ) ) ) : <NEWLINE> <INDENT> if L [ i ] != R [ i ] : <NEWLINE> <INDENT> print ( R [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if len ( L ) < 26 : <NEWLINE> <INDENT> print ( R [ len ( L ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= N : <NEWLINE> <INDENT> dp . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dpc = collections . Counter ( dp ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( dpc [ i ] ) <NEWLINE> <DEDENT>
def get_input ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield <STRING> . join ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> words = input ( ) . split ( ) <NEWLINE> ans = <STRING> <NEWLINE> flag = True <NEWLINE> for i in range ( len ( words ) ) : <NEWLINE> <INDENT> s = words [ i ] <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> if len ( s ) > 2 and len ( s ) < 7 : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> ans = s <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> + s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def Partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if ( A [ j ] <= x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def qsort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = Partition ( A , p , r ) <NEWLINE> qsort ( A , p , q - 1 ) <NEWLINE> qsort ( A , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def marge ( A , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( left , n1 + left ) : <NEWLINE> <INDENT> L . append ( A [ i ] ) <NEWLINE> <DEDENT> for i in range ( mid , n2 + mid ) : <NEWLINE> <INDENT> R . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> L . append ( card ( <STRING> ) ) <NEWLINE> R . append ( card ( <STRING> ) ) <NEWLINE> <NL> r_id , l_id = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if ( L [ l_id ] <= R [ r_id ] ) : <NEWLINE> <INDENT> A [ k ] = L [ l_id ] <NEWLINE> l_id += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ r_id ] <NEWLINE> r_id += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def margeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> margeSort ( A , left , mid ) <NEWLINE> margeSort ( A , mid , right ) <NEWLINE> marge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class card ( object ) : <NEWLINE> <INDENT> def __init__ ( self , str ) : <NEWLINE> <INDENT> data = str . split ( ) <NEWLINE> self . symbol , self . num = data [ 0 ] , int ( data [ 1 ] ) <NEWLINE> <NL> <DEDENT> def __le__ ( self , obj ) : <NEWLINE> <INDENT> if ( self . num <= obj . num ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> def __ge__ ( self , obj ) : <NEWLINE> <INDENT> if ( self . num >= obj . num ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def display_card ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . symbol , self . num ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> while ( n > 0 ) : <NEWLINE> <INDENT> c . append ( card ( input ( ) ) ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> c_marge = c . copy ( ) <NEWLINE> margeSort ( c_marge , 0 , len ( c ) ) <NEWLINE> <NL> qsort ( c , 0 , len ( c ) - 1 ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> is_stable = True <NEWLINE> for i in range ( 0 , len ( c ) ) : <NEWLINE> <INDENT> if ( c [ i ] != c_marge [ i ] ) : <NEWLINE> <INDENT> is_stable = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( is_stable == True ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in c : <NEWLINE> <INDENT> i . display_card ( ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> n , m = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ab = [ [ ] for i in range ( 10 ** 5 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if a <= m : <NEWLINE> <INDENT> ab [ m - a ] . append ( - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> l = [ ] <NEWLINE> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for b in ab [ i ] : <NEWLINE> <INDENT> heappush ( l , b ) <NEWLINE> <NL> <DEDENT> if l : <NEWLINE> <INDENT> ans -= heappop ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAP = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> IN = lambda : int ( input ( ) ) <NEWLINE> S = lambda : input ( ) <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> <NL> n = IN ( ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> b = n % 26 <NEWLINE> if b == 0 : <NEWLINE> <INDENT> ans = <STRING> + ans <NEWLINE> n = n // 26 <NEWLINE> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = chr ( ord ( <STRING> ) + b - 1 ) + ans <NEWLINE> n //= 26 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def search_next ( l , r , SC ) : <NEWLINE> <INDENT> ll , lc = l <NEWLINE> rr , rc = r <NEWLINE> nexts = [ ] <NEWLINE> if len ( ll ) > len ( rr ) : <NEWLINE> <INDENT> part = ll [ : : - 1 ] <NEWLINE> for s , c in SC : <NEWLINE> <INDENT> if s [ - len ( part ) : ] == part : <NEWLINE> <INDENT> r_n = ( s [ : - len ( ll ) ] , rc + c ) <NEWLINE> l_n = ( <STRING> , lc ) <NEWLINE> nexts . append ( ( rc + c + lc , ( l_n , r_n ) ) ) <NEWLINE> <DEDENT> elif s == part [ - len ( s ) : ] : <NEWLINE> <INDENT> l_n = ( ll [ len ( s ) : ] , lc ) <NEWLINE> r_n = ( <STRING> , rc + c ) <NEWLINE> nexts . append ( ( rc + c + lc , ( l_n , r_n ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> part = rr [ : : - 1 ] <NEWLINE> for s , c in SC : <NEWLINE> <INDENT> if s [ : len ( part ) ] == part : <NEWLINE> <INDENT> l_n = ( s [ len ( rr ) : ] , lc + c ) <NEWLINE> r_n = ( <STRING> , rc ) <NEWLINE> nexts . append ( ( lc + rc + c , ( l_n , r_n ) ) ) <NEWLINE> <DEDENT> elif s == part [ : len ( s ) ] : <NEWLINE> <INDENT> r_n = ( rr [ : - len ( s ) ] , rc ) <NEWLINE> l_n = ( <STRING> , lc + c ) <NEWLINE> nexts . append ( ( lc + rc + c , ( l_n , r_n ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return nexts <NEWLINE> <NL> <DEDENT> def palindrome ( l , r ) : <NEWLINE> <INDENT> if l + r == ( l + r ) [ : : - 1 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> totalL = 0 <NEWLINE> N = int ( sysread ( ) ) <NEWLINE> SC = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s , c = input ( ) . split ( ) <NEWLINE> c = int ( c ) <NEWLINE> SC . append ( ( s , c ) ) <NEWLINE> totalL += len ( s ) <NEWLINE> <NL> <DEDENT> min_val = INF <NEWLINE> for s , c in SC : <NEWLINE> <INDENT> queue = [ ] <NEWLINE> left = ( s , c ) <NEWLINE> right = ( <STRING> , 0 ) <NEWLINE> heappush ( queue , ( c , ( left , right ) ) ) <NEWLINE> done = False <NEWLINE> count = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count > 200000 : break <NEWLINE> <COMMENT> <NL> cost , ( l , r ) = heappop ( queue ) <NEWLINE> if palindrome ( l [ 0 ] , r [ 0 ] ) : <NEWLINE> <INDENT> done = True <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> nexts = search_next ( l , r , SC ) <NEWLINE> for n in nexts : <NEWLINE> <INDENT> heappush ( queue , n ) <NEWLINE> <DEDENT> <DEDENT> if done : <NEWLINE> <INDENT> min_val = min ( min_val , cost ) <NEWLINE> <DEDENT> <DEDENT> if min_val == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_val ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _i in range ( m ) ] <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> for i , j in ab : <NEWLINE> <INDENT> uf . union ( i - 1 , j - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> lines = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lines . append ( line . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> field = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] <NEWLINE> <NL> def drop ( x , y , z ) : <NEWLINE> <INDENT> if z == 1 : <NEWLINE> <INDENT> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if abs ( i ) + abs ( j ) < 2 and 0 <= y + j <= 9 and 0 <= x + i <= 9 : <NEWLINE> <INDENT> field [ y + j ] [ x + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif z == 2 : <NEWLINE> <INDENT> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if 0 <= y + j <= 9 and 0 <= x + i <= 9 : <NEWLINE> <INDENT> field [ y + j ] [ x + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for j in range ( - 2 , 3 ) : <NEWLINE> <INDENT> if abs ( i ) + abs ( j ) < 3 and 0 <= y + j <= 9 and 0 <= x + i <= 9 : <NEWLINE> <INDENT> field [ y + j ] [ x + i ] += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for line in lines : <NEWLINE> <INDENT> x , y , z = map ( int , line ) <NEWLINE> drop ( x , y , z ) <NEWLINE> <NL> <DEDENT> n = 0 <NEWLINE> m = 0 <NEWLINE> for f in field : <NEWLINE> <INDENT> for e in f : <NEWLINE> <INDENT> if e > m : <NEWLINE> <INDENT> m = e <NEWLINE> <DEDENT> if e == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> print ( m ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> n = 0 <NEWLINE> if M != 0 : <NEWLINE> <INDENT> a = b = A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b = - 2 <NEWLINE> <DEDENT> c = 0 <NEWLINE> ans = [ 0 , 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == a : <NEWLINE> <INDENT> c = 0 <NEWLINE> n += 1 <NEWLINE> b = a <NEWLINE> if n <= M - 1 : <NEWLINE> <INDENT> a = A [ n ] <NEWLINE> <DEDENT> <DEDENT> elif i - 2 == b : <NEWLINE> <INDENT> c = ans [ - 1 ] <NEWLINE> <DEDENT> elif i - 1 == b : <NEWLINE> <INDENT> c = ans [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ans [ - 1 ] + ans [ - 2 ] <NEWLINE> <DEDENT> c %= 10 ** 9 + 7 <NEWLINE> ans . append ( c ) <NEWLINE> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( int ( N * ( N - 1 ) // 2 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] . append ( h [ b - 1 ] ) <NEWLINE> l [ b - 1 ] . append ( h [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == [ ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> elif h [ i ] > max ( l [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , Q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> mxc = max ( c ) <NEWLINE> p = [ 0 ] * ( mxc + 1 ) <NEWLINE> for i in c : <NEWLINE> <INDENT> p [ i ] = 1 <NEWLINE> <NL> <DEDENT> l = [ 0 ] * ( mxc + 1 ) <NEWLINE> num = 0 <NEWLINE> for i in range ( mxc + 1 ) : <NEWLINE> <INDENT> l [ i ] = num <NEWLINE> if p [ i ] : <NEWLINE> <INDENT> num = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> q = int ( raw_input ( ) ) <NEWLINE> sp = mxc <NEWLINE> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> r = sp % q <NEWLINE> ans = max ( ans , r ) <NEWLINE> if sp - r <= 0 : break <NEWLINE> sp = l [ sp - r ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> w = 0 <NEWLINE> r = c . count ( <STRING> ) <NEWLINE> ans = r <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> if c [ k ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> elif c [ k ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> cnt = max ( w , r ) <NEWLINE> if ans > cnt : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import combinations <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x = [ 0 ] * N <NEWLINE> y = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> vector = defaultdict ( int ) <NEWLINE> for a , b in combinations ( range ( N ) , 2 ) : <NEWLINE> <INDENT> dx = x [ a ] - x [ b ] <NEWLINE> dy = y [ a ] - y [ b ] <NEWLINE> if dx == 0 : <NEWLINE> <INDENT> vector [ ( 0 , abs ( dy ) ) ] += 1 <NEWLINE> <DEDENT> elif dx > 0 : <NEWLINE> <INDENT> vector [ ( dx , dy ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vector [ ( - dx , - dy ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = N - max ( vector . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> N2 = int ( N ** 0.5 ) <NEWLINE> <NL> cnt = [ 0 ] * ( 90000 ) <NEWLINE> <NL> for x in range ( 1 , N2 + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , N2 + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , N2 + 1 ) : <NEWLINE> <INDENT> xyz = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> cnt [ xyz ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> if ( a == k ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif ( a > k ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a < k ) : <NEWLINE> <INDENT> max += a <NEWLINE> k = k - a <NEWLINE> <DEDENT> if ( b > k ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - b <NEWLINE> if ( k <= 0 ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( c >= k ) : <NEWLINE> <INDENT> max -= k <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif ( c < k ) : <NEWLINE> <INDENT> max -= c <NEWLINE> print ( max ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> step_n , max_jump = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> step_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_table = [ math . inf ] * ( step_n ) <NEWLINE> dp_table [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , step_n ) : <NEWLINE> <INDENT> min_from = max ( 0 , i - max_jump ) <NEWLINE> dp_table [ i ] = min ( dp_table [ j ] + abs ( step_list [ i ] - step_list [ j ] ) for j in range ( min_from , i ) ) <NEWLINE> <NL> <DEDENT> print ( dp_table [ step_n - 1 ] ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> start , end = min ( A ) , max ( A ) + 1 <NEWLINE> for v in range ( start , end ) : <NEWLINE> <INDENT> ans = max ( C [ v - 1 ] + C [ v ] + C [ v + 1 ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ls . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ls . sort ( ) <NEWLINE> <NL> ans = [ int ( str ( i ) + str ( j ) ) for i in ls [ : 3 + 1 ] for j in ls [ : 3 + 1 ] if i != j ] if n > 3 else [ int ( str ( i ) + str ( j ) ) for i in ls for j in ls if i != j ] <NEWLINE> print ( sorted ( ans ) [ 2 ] ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> t = <STRING> . join ( sorted ( t ) ) <NEWLINE> if t in d : <NEWLINE> <INDENT> ans += d [ t ] <NEWLINE> d [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ t ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ir = range ( 1 , k + 1 ) <NEWLINE> jr = range ( 1 , k + 1 ) <NEWLINE> lr = range ( 1 , k + 1 ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in ir : <NEWLINE> <INDENT> for j in jr : <NEWLINE> <INDENT> for l in lr : <NEWLINE> <INDENT> count += gcd ( i , gcd ( j , l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = 10001 <NEWLINE> <NL> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if ( i in p ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( x - i ) ** 2 <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> c = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> lcm = ( N * M ) // math . gcd ( N , M ) <NEWLINE> ans = lcm <NEWLINE> Sp = lcm // N <NEWLINE> Tp = lcm // M <NEWLINE> lcmlcm = ( Sp * Tp ) // math . gcd ( Sp , Tp ) <NEWLINE> owari = min ( Sp * N , M * Tp ) <NEWLINE> for i in range ( 0 , owari , lcmlcm ) : <NEWLINE> <INDENT> if S [ i // Sp ] != T [ i // Tp ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] += 1 <NEWLINE> sd = 0 <NEWLINE> d = 1 <NEWLINE> for c in s : <NEWLINE> <INDENT> sd += int ( c ) * d <NEWLINE> sd %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> count [ sd ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in count : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> m = l [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if m >= l [ i ] : <NEWLINE> <INDENT> m = l [ i ] <NEWLINE> s += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> D = abs ( A - B ) <NEWLINE> S = V - W <NEWLINE> if ( S <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( D / S <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> class BinaryIndexedTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . bit = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= ( i & - i ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . bit [ i ] += x <NEWLINE> i += ( i & - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def reset ( self ) : <NEWLINE> <INDENT> self . bit = [ 0 ] * ( self . size + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> BIT = BinaryIndexedTree ( N ) <NEWLINE> <NL> A_sorted = { a : i for i , a in enumerate ( sorted ( A ) , start = 1 ) } <NEWLINE> ans = 0 <NEWLINE> for j , a in enumerate ( A ) : <NEWLINE> <INDENT> ans += j - BIT . sum ( A_sorted [ a ] ) <NEWLINE> BIT . add ( A_sorted [ a ] , 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= 0 : plus . append ( i ) <NEWLINE> if i < 0 : minus . append ( - i ) <NEWLINE> <DEDENT> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> if k == n : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> ans = ( ans * x ) % mod <NEWLINE> <DEDENT> <DEDENT> elif n == len ( plus ) : <NEWLINE> <INDENT> for x in plus [ : k ] : <NEWLINE> <INDENT> ans = ( ans * x ) % mod <NEWLINE> <DEDENT> <DEDENT> elif n == len ( minus ) : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> minus . sort ( ) <NEWLINE> <DEDENT> for x in minus [ : k ] : <NEWLINE> <INDENT> ans = ( ans * x ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i , j = 0 , 0 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans = plus [ 0 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> while i + j != k : <NEWLINE> <INDENT> x_p = plus [ i ] * plus [ i + 1 ] if i < len ( plus ) - 1 else 0 <NEWLINE> x_m = minus [ j ] * minus [ j + 1 ] if j < len ( minus ) - 1 else 0 <NEWLINE> if x_p > x_m : <NEWLINE> <INDENT> ans = ( ans * x_p ) % mod <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * x_m ) % mod <NEWLINE> j += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a . update ( { i : 0 } ) <NEWLINE> <DEDENT> for j in A : <NEWLINE> <INDENT> a [ j ] += 1 <NEWLINE> <DEDENT> for k , l in a . items ( ) : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> springs = [ ] <NEWLINE> tile_cnt = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if mp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> springs . append ( ( x , y ) ) <NEWLINE> <DEDENT> if mp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> gx , gy = x , y <NEWLINE> <DEDENT> if mp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> sx , sy = x , y <NEWLINE> tile_cnt += 1 <NEWLINE> <DEDENT> if mp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> tile_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> vec = ( ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) , ( 0 , 1 ) ) <NEWLINE> INF = 10 ** 10 <NEWLINE> <NL> g_dist = [ [ INF ] * w for _ in range ( h ) ] <NEWLINE> que = deque ( ) <NEWLINE> que . append ( ( 0 , gx , gy ) ) <NEWLINE> g_dist [ gy ] [ gx ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> score , x , y = que . popleft ( ) <NEWLINE> for dx , dy in vec : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if mp [ ny ] [ nx ] in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> if g_dist [ ny ] [ nx ] == INF : <NEWLINE> <INDENT> g_dist [ ny ] [ nx ] = score + 1 <NEWLINE> que . append ( ( score + 1 , nx , ny ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s_dist = [ [ INF ] * w for _ in range ( h ) ] <NEWLINE> que = deque ( ) <NEWLINE> for x , y in springs : <NEWLINE> <INDENT> s_dist [ y ] [ x ] = 0 <NEWLINE> que . append ( ( 0 , x , y ) ) <NEWLINE> <DEDENT> while que : <NEWLINE> <INDENT> score , x , y = que . popleft ( ) <NEWLINE> for dx , dy in vec : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if mp [ ny ] [ nx ] in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> if s_dist [ ny ] [ nx ] == INF : <NEWLINE> <INDENT> s_dist [ ny ] [ nx ] = score + 1 <NEWLINE> que . append ( ( score + 1 , nx , ny ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sorted_tiles = sorted ( [ ( g_dist [ y ] [ x ] - s_dist [ y ] [ x ] if g_dist [ y ] [ x ] != INF else INF , x , y ) for y in range ( h ) for x in range ( w ) if mp [ y ] [ x ] in ( <STRING> , <STRING> ) ] ) <NEWLINE> <NL> acc_g = 0 <NEWLINE> acc_s = 0 <NEWLINE> acc_t = 0 <NEWLINE> acc_g_dic = { } <NEWLINE> acc_s_dic = { } <NEWLINE> acc_t_dic = { } <NEWLINE> keys = set ( ) <NEWLINE> for key , x , y in sorted_tiles : <NEWLINE> <INDENT> acc_g += g_dist [ y ] [ x ] <NEWLINE> acc_s += s_dist [ y ] [ x ] <NEWLINE> acc_t += 1 <NEWLINE> acc_g_dic [ key ] = acc_g <NEWLINE> acc_s_dic [ key ] = acc_s <NEWLINE> acc_t_dic [ key ] = acc_t <NEWLINE> keys . add ( key ) <NEWLINE> <DEDENT> keys = sorted ( list ( keys ) ) <NEWLINE> <NL> length = len ( keys ) <NEWLINE> for i in range ( length - 1 ) : <NEWLINE> <INDENT> key = keys [ i ] <NEWLINE> next_key = keys [ i + 1 ] <NEWLINE> E = ( acc_g_dic [ key ] + acc_s - acc_s_dic [ key ] ) / acc_t_dic [ key ] <NEWLINE> if key <= E < next_key : <NEWLINE> <INDENT> print ( min ( g_dist [ sy ] [ sx ] , s_dist [ sy ] [ sx ] + E ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( g_dist [ sy ] [ sx ] ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> if x - k * d >= 0 : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = x // d <NEWLINE> k -= n <NEWLINE> a = x - n * d <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( min ( a , 2 * d - a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( d - a , a + d ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> answer = A [ 0 ] <NEWLINE> <NL> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> answer = answer * A [ i ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inf = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> sorted ( a , reverse = True ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> A = sorted ( enumerate ( A ) , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( p , a ) in enumerate ( A ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + a * ( p - j ) ) <NEWLINE> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] + a * ( N - ( i - j ) - 1 - p ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ N ] ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ 1 ] * n <NEWLINE> <NL> import sys <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if H [ a ] >= H [ b ] : <NEWLINE> <INDENT> G [ b ] = 0 <NEWLINE> <DEDENT> if H [ b ] >= H [ a ] : <NEWLINE> <INDENT> G [ a ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( G ) ) <NEWLINE>
<NL> k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 7 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> n = ( n * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for a in t : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if a == s [ mid ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif a < s [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> color = [ [ ] , [ ] , [ ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> color [ 0 ] . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> color [ 1 ] . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> color [ 2 ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> rn = len ( color [ 0 ] ) <NEWLINE> gn = len ( color [ 1 ] ) <NEWLINE> bn = len ( color [ 2 ] ) <NEWLINE> mi = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> while i + 2 * p <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ i + p ] and S [ i + p ] != S [ i + 2 * p ] and S [ i ] != S [ i + 2 * p ] : <NEWLINE> <INDENT> mi += 1 <NEWLINE> <DEDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( rn * gn * bn - mi ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = set ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = set ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> print ( len ( S & T ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> def solve ( N , A ) : <NEWLINE> <INDENT> P = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = A [ i ] <NEWLINE> if n % 2 == 0 and 2 in P : break <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> P . add ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <NL> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> if f in P : break <NEWLINE> P . add ( f ) <NEWLINE> while n % f == 0 : <NEWLINE> <INDENT> n //= f <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n != 1 : <NEWLINE> <INDENT> if n in P : break <NEWLINE> P . add ( n ) <NEWLINE> <NL> <DEDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> return 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> A = np . array ( list ( mi ( ) ) ) <NEWLINE> <NL> flag = solve ( N , A ) <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = np . gcd . reduce ( A ) <NEWLINE> if gcd == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> try : <NEWLINE> <INDENT> from my_module import solve <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( int ( n / 3600 ) , int ( ( n % 3600 ) / 60 ) , ( n % 3600 ) % 60 ) ) <NEWLINE>
<COMMENT> <NL> from heapq import heapify , heappop , heappush <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> d = [ INF for n in range ( N ) ] <NEWLINE> d [ 0 ] = 0 <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> searched = [ False for _ in range ( N ) ] <NEWLINE> searched [ 0 ] = True <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> inp = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> assert n == inp [ 0 ] <NEWLINE> adj [ n ] = list ( zip ( inp [ 2 : : 2 ] , inp [ 3 : : 2 ] ) ) <NEWLINE> <NL> <DEDENT> heap = [ [ 0 , 0 ] ] <NEWLINE> <NL> while len ( heap ) : <NEWLINE> <INDENT> pcost , p = heappop ( heap ) <NEWLINE> searched [ p ] = True <NEWLINE> <NL> if d [ p ] < pcost : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for v , c in adj [ p ] : <NEWLINE> <INDENT> if not searched [ v ] : <NEWLINE> <INDENT> new_cost = pcost + c <NEWLINE> if new_cost < d [ v ] : <NEWLINE> <INDENT> d [ v ] = new_cost <NEWLINE> heappush ( heap , [ new_cost , v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( n , d [ n ] ) ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> arr = [ [ 0 for i in range ( c + 1 ) ] for i in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> row = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> arr [ i ] [ j ] = row [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> arr [ i ] [ - 1 ] += arr [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> arr [ - 1 ] [ i ] += arr [ j ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> for i in range ( r ) : <NEWLINE> <INDENT> arr [ - 1 ] [ - 1 ] += arr [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> elif r == 1 : <NEWLINE> <INDENT> for i in range ( c ) : <NEWLINE> <INDENT> arr [ - 1 ] [ - 1 ] += arr [ 0 ] [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( r ) : <NEWLINE> <INDENT> arr [ - 1 ] [ - 1 ] += arr [ i ] [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> print ( arr [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( arr [ i ] [ - 1 ] ) <NEWLINE> <DEDENT>
a = [ [ 0 ] * 3 for x in range ( 3 ) ] <NEWLINE> s = [ [ 0 ] * 3 for x in range ( 3 ) ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if b [ i ] == a [ j ] [ k ] : <NEWLINE> <INDENT> s [ j ] [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = <STRING> <NEWLINE> if s [ 0 ] [ 0 ] == 1 and s [ 0 ] [ 1 ] == 1 and s [ 0 ] [ 2 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 1 ] [ 0 ] == 1 and s [ 1 ] [ 1 ] == 1 and s [ 1 ] [ 2 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 2 ] [ 0 ] == 1 and s [ 2 ] [ 1 ] == 1 and s [ 2 ] [ 2 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 0 ] [ 0 ] == 1 and s [ 1 ] [ 0 ] == 1 and s [ 2 ] [ 0 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 0 ] [ 1 ] == 1 and s [ 1 ] [ 1 ] == 1 and s [ 2 ] [ 1 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 0 ] [ 2 ] == 1 and s [ 1 ] [ 2 ] == 1 and s [ 2 ] [ 2 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 0 ] [ 0 ] == 1 and s [ 1 ] [ 1 ] == 1 and s [ 2 ] [ 2 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> if s [ 2 ] [ 0 ] == 1 and s [ 1 ] [ 1 ] == 1 and s [ 0 ] [ 2 ] == 1 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l . sort ( ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> c_i = bisect . bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> if c_i > j : <NEWLINE> <INDENT> ans += c_i - j - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sum = pow ( 2 , n , mod ) - 1 <COMMENT> <NEWLINE> <NL> def comb ( m ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> y = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x = x * ( n - i ) % mod <COMMENT> <NEWLINE> y = y * ( i + 1 ) % mod <COMMENT> <NEWLINE> <DEDENT> return ( x * pow ( y , mod - 2 , mod ) % mod ) <NEWLINE> <NL> <DEDENT> print ( ( sum - comb ( a ) - comb ( b ) ) % mod ) <NEWLINE>
a = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ( ans + int ( i ) ) % 9 <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans > 0 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> arr = deque ( [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , ] ) <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( arr . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dictionary = set ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> order , code = input ( ) . split ( ) <NEWLINE> if order == <STRING> : <NEWLINE> <INDENT> dictionary . add ( code ) <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> if code in dictionary : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq as hq <NEWLINE> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> hq . heappush ( ab , - a - b ) <NEWLINE> <DEDENT> <DEDENT> abc = [ ] <NEWLINE> cnt = 0 <NEWLINE> while cnt < k and ab : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a = hq . heappop ( ab ) <NEWLINE> for b in C : <NEWLINE> <INDENT> hq . heappush ( abc , a - b ) <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> while cnt < k : <NEWLINE> <INDENT> print ( - hq . heappop ( abc ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> jd = a [ i ] <NEWLINE> if jd % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> B = [ A [ 0 ] ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> B . append ( A [ j ] + B [ j - 1 ] ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( B [ - 1 ] - B [ i ] ) <NEWLINE> ans %= M <NEWLINE> <DEDENT> ans %= M <NEWLINE> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import itertools <NEWLINE> from math import gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> k = gcd ( i , j ) <NEWLINE> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = gcd ( k , l ) <NEWLINE> ans += a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> [ N , W ] , * h = [ list ( map ( int , i . split ( ) ) ) for i in open ( 0 ) ] <NEWLINE> <NL> dp = np . zeros ( W + 1 , dtype = int ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w = h [ i ] [ 0 ] <NEWLINE> v = h [ i ] [ 1 ] <NEWLINE> dp [ w : ] = np . maximum ( dp [ : - w ] + v , dp [ w : ] ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
h , w , h0 , w0 = map ( int , input ( ) . split ( ) ) <NEWLINE> if h0 == w0 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x , y = h // h0 , w // w0 <NEWLINE> a1cnt = h0 * w0 - 1 <NEWLINE> a1sum , a2sum = h * w - x * y , x * y <NEWLINE> a1 = ( ( pow ( 10 , 9 ) - 1 ) // a1cnt ) <NEWLINE> a2 = - ( a1 * a1cnt + 1 ) <NEWLINE> asum = a1 * a1sum + a2 * a2sum <NEWLINE> print ( <STRING> if asum > 0 else <STRING> ) <NEWLINE> if asum > 0 : <NEWLINE> <INDENT> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> a = [ 0 ] * w <NEWLINE> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> a [ j - 1 ] = a2 if i % h0 == j % w0 == 0 else a1 <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = lcm ( c , d ) <NEWLINE> <NL> total = b - ( a - 1 ) <NEWLINE> cc = b // c - ( a - 1 ) // c <NEWLINE> dd = b // d - ( a - 1 ) // d <NEWLINE> ee = b // e - ( a - 1 ) // e <NEWLINE> <NL> ans = total - cc - dd + ee <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> upper = 1e18 <NEWLINE> res = 1 <NEWLINE> generator = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in generator : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > upper : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for x in generator : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 if res > upper else res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 0 <NEWLINE> su = sum ( li_a ) <NEWLINE> mo = ( 10 ** 9 ) + 7 <NEWLINE> for idx , a in enumerate ( li_a ) : <NEWLINE> <INDENT> su = su - a <NEWLINE> answer += ( a * su ) <NEWLINE> <DEDENT> print ( answer % mo ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> import math <NEWLINE> mod = 1000000007 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A < 0 : <NEWLINE> <INDENT> A , B = - A , - B <NEWLINE> <DEDENT> if A == 0 : <NEWLINE> <INDENT> if B == 0 : <NEWLINE> <INDENT> dic [ ( 0 , 0 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ( 0 , 1 ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> dic [ ( 1 , 0 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = math . gcd ( A , B ) <NEWLINE> A , B = A // gcd , B // gcd <NEWLINE> dic [ ( A , B ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> N -= dic [ ( 0 , 0 ) ] <NEWLINE> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if k == ( 0 , 0 ) or k == ( 0 , 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if k == ( 1 , 0 ) : <NEWLINE> <INDENT> if not ( 0 , 1 ) in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v_dash = dic [ ( 0 , 1 ) ] <NEWLINE> ans *= ( ( pow ( 2 , v , mod ) - 1 ) + ( pow ( 2 , v_dash , mod ) - 1 ) + 1 ) <NEWLINE> ans %= mod <NEWLINE> N -= v + v_dash <NEWLINE> continue <NEWLINE> <DEDENT> a , b = k <NEWLINE> if not ( b , - a ) in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v_dash = dic [ ( b , - a ) ] <NEWLINE> ans *= ( ( pow ( 2 , v , mod ) - 1 ) + ( pow ( 2 , v_dash , mod ) - 1 ) + 1 ) <NEWLINE> ans %= mod <NEWLINE> N -= v + v_dash <NEWLINE> <DEDENT> ans *= pow ( 2 , N , mod ) <NEWLINE> ans += dic [ ( 0 , 0 ) ] - 1 <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> A = Counter ( a ) <NEWLINE> s = set ( a ) <NEWLINE> S = sorted ( list ( s ) ) <NEWLINE> S . reverse ( ) <NEWLINE> h = 0 <NEWLINE> w = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> res = A [ i ] <NEWLINE> if res >= 4 : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> h = i <NEWLINE> <DEDENT> if w == 0 : <NEWLINE> <INDENT> w = i <NEWLINE> <DEDENT> <DEDENT> elif 2 <= res < 4 : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> w = i <NEWLINE> <DEDENT> elif w != 0 and h == 0 : <NEWLINE> <INDENT> h = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h * w ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in A : <NEWLINE> <INDENT> A [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> s_max = max ( A . values ( ) ) <NEWLINE> for j in sorted ( k for k in A if A [ k ] == s_max ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def count ( dic , x ) : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic1 = { } <NEWLINE> dic2 = { } <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count ( dic1 , i - A [ i ] ) <NEWLINE> count ( dic2 , i + A [ i ] ) <NEWLINE> <DEDENT> for x in dic1 : <NEWLINE> <INDENT> if x in dic2 : <NEWLINE> <INDENT> s += dic1 [ x ] * dic2 [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if 1000000000000000000 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n = readInt ( ) <NEWLINE> xyu = [ readChars ( ) for i in range ( n ) ] <NEWLINE> <NL> class mydict : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . d = { } <NEWLINE> <DEDENT> def add ( self , key , value ) : <NEWLINE> <INDENT> if key in self . d : <NEWLINE> <INDENT> self . d [ key ] . append ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . d [ key ] = [ value ] <NEWLINE> <DEDENT> <DEDENT> def p ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for key in self . d : <NEWLINE> <INDENT> print ( key , self . d [ key ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def mysort ( self ) : <NEWLINE> <INDENT> for i in self . d : <NEWLINE> <INDENT> self . d [ i ] . sort ( ) <NEWLINE> <DEDENT> <DEDENT> def getDict ( self ) : <NEWLINE> <INDENT> return self . d ; <NEWLINE> <NL> <DEDENT> <DEDENT> ud = mydict ( ) <NEWLINE> rl = mydict ( ) <NEWLINE> for x , y , u in xyu : <NEWLINE> <INDENT> if u == <STRING> or u == <STRING> : <NEWLINE> <INDENT> ud . add ( int ( x ) , [ int ( y ) , u ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rl . add ( int ( y ) , [ int ( x ) , u ] ) <NEWLINE> <DEDENT> <DEDENT> ud . mysort ( ) <NEWLINE> rl . mysort ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> tar = ud . getDict ( ) <NEWLINE> for key in tar : <NEWLINE> <INDENT> beu = <STRING> <NEWLINE> bev = <STRING> <NEWLINE> for v in tar [ key ] : <NEWLINE> <INDENT> if beu == <STRING> and v [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = min ( ans , ( int ( v [ 0 ] ) - int ( bev ) ) * 5 ) <NEWLINE> <DEDENT> beu = v [ 1 ] <NEWLINE> bev = v [ 0 ] <NEWLINE> <DEDENT> <DEDENT> tar = rl . getDict ( ) <NEWLINE> for key in tar : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> beu = <STRING> <NEWLINE> bev = <STRING> <NEWLINE> for v in tar [ key ] : <NEWLINE> <INDENT> if beu == <STRING> and v [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = min ( ans , ( int ( v [ 0 ] ) - int ( bev ) ) * 5 ) <NEWLINE> <DEDENT> beu = v [ 1 ] <NEWLINE> bev = v [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> xy = mydict ( ) <NEWLINE> for x , y , u in xyu : <NEWLINE> <INDENT> xy . add ( int ( x ) + int ( y ) , [ int ( x ) , u ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> xy . mysort ( ) <NEWLINE> d = xy . getDict ( ) <NEWLINE> for key in d : <NEWLINE> <INDENT> beu = <STRING> <NEWLINE> bex = - 1 <NEWLINE> for arr in d [ key ] : <NEWLINE> <INDENT> if beu == <STRING> and arr [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = min ( ans , ( arr [ 0 ] - bex ) * 10 ) <NEWLINE> <DEDENT> if beu == <STRING> and arr [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = min ( ans , ( arr [ 0 ] - bex ) * 10 ) <NEWLINE> <DEDENT> beu = arr [ 1 ] <NEWLINE> bex = arr [ 0 ] <NEWLINE> <DEDENT> <DEDENT> mxy = mydict ( ) <NEWLINE> for x , y , u in xyu : <NEWLINE> <INDENT> mxy . add ( int ( y ) - int ( x ) , [ int ( x ) , u ] ) <NEWLINE> <DEDENT> mxy . mysort ( ) <NEWLINE> <COMMENT> <NL> d = mxy . getDict ( ) <NEWLINE> for key in d : <NEWLINE> <INDENT> beu = <STRING> <NEWLINE> bex = - 1 <NEWLINE> for arr in d [ key ] : <NEWLINE> <INDENT> if beu == <STRING> and arr [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = min ( ans , ( arr [ 0 ] - bex ) * 10 ) <NEWLINE> <DEDENT> if beu == <STRING> and arr [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = min ( ans , ( arr [ 0 ] - bex ) * 10 ) <NEWLINE> <DEDENT> beu = arr [ 1 ] <NEWLINE> bex = arr [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> count = Counter ( a ) <NEWLINE> <NL> b = [ 1 ] * ( max ( a ) + 1 ) <NEWLINE> <NL> for aa in a : <NEWLINE> <INDENT> for j in range ( 2 * aa , len ( b ) , aa ) : <NEWLINE> <INDENT> b [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for d in count . items ( ) : <NEWLINE> <INDENT> if d [ 1 ] == 1 and b [ d [ 0 ] ] == 1 : c += 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
def check ( A , mid , K ) : <NEWLINE> <INDENT> return A [ mid ] <= K <NEWLINE> <NL> <NL> <DEDENT> def binMax ( A , K ) : <NEWLINE> <INDENT> ok = - 1 <COMMENT> <NEWLINE> ng = len ( A ) <COMMENT> <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if check ( A , mid , K ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N , M , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> presumA = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> presumA [ i + 1 ] = presumA [ i ] + A [ i ] <NEWLINE> <DEDENT> presumB = [ 0 for _ in range ( M + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> presumB [ i + 1 ] = presumB [ i ] + B [ i ] <NEWLINE> <DEDENT> startA = binMax ( presumA , K ) <NEWLINE> maxA = 0 <NEWLINE> for ai in range ( startA , - 1 , - 1 ) : <NEWLINE> <INDENT> maxA = max ( maxA , ai + binMax ( presumB , K - presumA [ ai ] ) ) <NEWLINE> <DEDENT> print ( maxA ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
class BinaryTreeNode ( ) : <NEWLINE> <INDENT> def __init__ ( self , left = None , right = None , val = None ) : <NEWLINE> <INDENT> self . left = left <NEWLINE> self . right = right <NEWLINE> self . val = val <NEWLINE> <NL> <DEDENT> <DEDENT> class BinarySearchTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , val ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if val < x . val : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> node = BinaryTreeNode ( val = val ) <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> elif node . val < y . val : <NEWLINE> <INDENT> y . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , val ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> while x != None : <NEWLINE> <INDENT> if x . val == val : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x . val < val : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> self . preorder_list = [ ] <NEWLINE> self . preorder_bfs ( self . root ) <NEWLINE> return self . preorder_list <NEWLINE> <NL> <DEDENT> def preorder_bfs ( self , u ) : <NEWLINE> <INDENT> if u == None : return <NEWLINE> self . preorder_list . append ( u . val ) <NEWLINE> self . preorder_bfs ( u . left ) <NEWLINE> self . preorder_bfs ( u . right ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> self . inorder_list = [ ] <NEWLINE> self . inorder_dfs ( self . root ) <NEWLINE> return self . inorder_list <NEWLINE> <NL> <DEDENT> def inorder_dfs ( self , u ) : <NEWLINE> <INDENT> if u == None : return <NEWLINE> self . inorder_dfs ( u . left ) <NEWLINE> self . inorder_list . append ( u . val ) <NEWLINE> self . inorder_dfs ( u . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_elements ( arr ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( item ) for item in arr ] ) ) <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> bst = BinarySearchTree ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> op = input ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print_elements ( bst . inorder ( ) ) <NEWLINE> print_elements ( bst . preorder ( ) ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> ope , num = op . split ( <STRING> ) <NEWLINE> num = int ( num ) <NEWLINE> if ope == <STRING> : <NEWLINE> <INDENT> bst . insert ( num ) <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> if bst . find ( num ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = n // x <NEWLINE> <NL> if n % x == 0 : <NEWLINE> <INDENT> print ( t * p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t * ( p + 1 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> array = [ 0 for i in range ( ( 10 ** 6 ) + 1 ) ] <NEWLINE> for v in a : <NEWLINE> <INDENT> array [ v ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( array ) ) : <NEWLINE> <INDENT> if array [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( i * 2 , len ( array ) , i ) : <NEWLINE> <INDENT> array [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for v in array : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = [ ] <NEWLINE> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> i += 1 <NEWLINE> if a [ i - 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( i - 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( j + 1 , a [ j ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( n ) ) ) : <NEWLINE> <INDENT> a = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if n >= a >= 1 : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <NL> <DEDENT> b_cnt = m <NEWLINE> ans = 0 <NEWLINE> <NL> for a_cnt in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ a_cnt ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ a_cnt ] + b [ b_cnt ] > k : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a_cnt + b_cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> L = np . zeros ( ( H , W ) , int ) <NEWLINE> R = np . zeros ( ( H , W ) , int ) <NEWLINE> D = np . zeros ( ( H , W ) , int ) <NEWLINE> U = np . zeros ( ( H , W ) , int ) <NEWLINE> S = np . array ( [ list ( input ( ) ) for h in range ( H ) ] ) == <STRING> <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> U [ h ] = S [ h ] * ( U [ h - 1 ] + 1 ) <NEWLINE> D [ - h - 1 ] = S [ - h - 1 ] * ( D [ - h ] + 1 ) <NEWLINE> <NL> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> L [ : , w ] = S [ : , w ] * ( L [ : , w - 1 ] + 1 ) <NEWLINE> R [ : , - w - 1 ] = S [ : , - w - 1 ] * ( R [ : , - w ] + 1 ) <NEWLINE> <NL> <DEDENT> print ( np . max ( U + D + L + R ) - 3 ) <NEWLINE>
import collections , sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> N = I ( ) <NEWLINE> A = sorted ( LI ( ) ) <NEWLINE> counter_A = collections . Counter ( A ) <NEWLINE> sequence = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> for k , v in counter_A . items ( ) : <NEWLINE> <INDENT> if sequence [ k ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( k , 10 ** 6 + 1 , k ) : <NEWLINE> <INDENT> sequence [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { 1 : 0 } <NEWLINE> now = 1 <NEWLINE> flag = 0 <NEWLINE> T = 0 <NEWLINE> log = [ 1 ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> <COMMENT> <NL> if now in dic : <NEWLINE> <INDENT> flag = 1 <NEWLINE> T = i + 1 - dic [ now ] <NEWLINE> log = log [ dic [ now ] : ] <NEWLINE> break <NEWLINE> <DEDENT> dic [ now ] = i + 1 <NEWLINE> log . append ( now ) <NEWLINE> <DEDENT> if flag != 1 : <NEWLINE> <INDENT> print ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( log [ ( K - dic [ now ] ) % T ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> t = a // i <NEWLINE> if b % t == 0 : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = sorted ( map ( int , line . split ( ) ) ) <NEWLINE> gcdab = gcd ( a , b ) <NEWLINE> print ( gcdab , a // gcdab * b ) <NEWLINE> <DEDENT>
N , S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> S = list ( map ( int , list ( S ) ) ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> for j in range ( 0 , 10 ) : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = S . index ( i ) <NEWLINE> m = S [ n + 1 : ] . index ( j ) <NEWLINE> o = S [ n + m + 2 : ] . index ( k ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> s = Counter ( c ) <NEWLINE> if s [ <STRING> ] == 0 or s [ <STRING> ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> pos_w = 0 <NEWLINE> pos_r = n - 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( pos_w , n ) : <NEWLINE> <INDENT> if c [ i ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pos_w = i <NEWLINE> for j in range ( pos_r , - 1 , - 1 ) : <NEWLINE> <INDENT> if c [ j ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pos_r = j <NEWLINE> if pos_w > pos_r : <NEWLINE> <INDENT> print ( count ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> c [ i ] = <STRING> <NEWLINE> c [ j ] = <STRING> <NEWLINE> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = stdin . readline ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> count1 = r * g * b <NEWLINE> count2 = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if 2 * j - i <= n - 1 : <NEWLINE> <INDENT> if ( s [ i ] != s [ j ] ) and ( s [ i ] != s [ 2 * j - i ] ) and ( s [ j ] != s [ 2 * j - i ] ) : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count1 - count2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in a : <NEWLINE> <INDENT> A [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
r = float ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( <STRING> % ( math . pi * ( r ** 2 ) , math . pi * r * 2 ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b > a : <NEWLINE> <INDENT> temp = b <NEWLINE> b = a <NEWLINE> a = temp <NEWLINE> <DEDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> def sum_of_gcd ( k ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i < j and j < k : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , k ) ) * 6 <NEWLINE> <DEDENT> elif i < j and j == k : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , k ) ) * 3 <NEWLINE> <DEDENT> elif i == j and j < k : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , k ) ) * 3 <NEWLINE> <DEDENT> elif i == j and j == k : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( sum_of_gcd ( n ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> if ( K % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A = 7 <NEWLINE> ans = 1 <NEWLINE> while ( A < K ) : <COMMENT> <NEWLINE> <INDENT> A = A * 10 + 7 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <COMMENT> <NL> <INDENT> A = A % K <COMMENT> <NEWLINE> if ( ans > K ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( A == 0 ) : <COMMENT> <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = A * 10 + 7 <COMMENT> <NEWLINE> ans += 1 <COMMENT> <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys , collections <NEWLINE> <NL> A , B , C , K = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( 1 * min ( A , K ) + 0 * min ( B , max ( K - A , 0 ) ) - 1 * min ( C , max ( K - A - B , 0 ) ) ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> and S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = sorted ( temp ) <NEWLINE> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a * temp [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xor_arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xor_of_xor = 0 <NEWLINE> for elm in xor_arr : <NEWLINE> <INDENT> xor_of_xor = xor_of_xor ^ elm <NEWLINE> <DEDENT> scarf_val = [ xor_of_xor ^ elm for elm in xor_arr ] <NEWLINE> <NL> print ( <STRING> . join ( str ( x ) for x in scarf_val ) ) <NEWLINE>
from math import ceil <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( rm , gm , bm , R , G , B , n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for r in range ( rm + 1 ) : <NEWLINE> <INDENT> for g in range ( gm + 1 ) : <NEWLINE> <INDENT> x = n - ( r * R + g * G ) <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> ans += ( x % B == 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> rm = ceil ( n / R ) <NEWLINE> gm = ceil ( n / G ) <NEWLINE> bm = ceil ( n / B ) <NEWLINE> <NL> print ( solve ( rm , gm , bm , R , G , B , n ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def multiple ( A , st , ed ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in range ( st , ed ) : <NEWLINE> <INDENT> res = res * A [ i ] <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> st = - 1 <NEWLINE> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> st += 1 <NEWLINE> if A [ i - 1 ] > A [ st ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> def factorial ( x ) : <NEWLINE> <INDENT> max_num = int ( 2 * ( 10 ** 9 ) ** ( 1 / 5 ) ) <NEWLINE> for a in range ( - 1 * max_num , max_num ) : <NEWLINE> <INDENT> for b in range ( - 1 * max_num , max_num ) : <NEWLINE> <INDENT> check = math . pow ( a , 5 ) - math . pow ( b , 5 ) <NEWLINE> if check == x : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> print ( factorial ( x ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = n // i <NEWLINE> if n % i == 0 : <NEWLINE> <INDENT> count += a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( i , m_i ) : <NEWLINE> <INDENT> if m_i == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m_i ) or solve ( i + 1 , m_i - a [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m_tmp in m : <NEWLINE> <INDENT> if sum ( a ) < m_tmp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif solve ( 0 , m_tmp ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> rep = s . replace ( <STRING> , <STRING> ) <NEWLINE> if len ( rep ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s . index ( rep [ 0 ] ) < k : <NEWLINE> <INDENT> print ( rep [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s_list = [ 0 ] * ( n + 1 ) <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> s_list [ i + 1 ] = s_list [ i ] + a <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> ans += a * ( s_list [ n ] - s_list [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while j < N and S [ i : j ] in S [ j : ] : <NEWLINE> <INDENT> ans = max ( ans , j - i ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> <NL> while i <= n : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> A . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = { } <NEWLINE> pair = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i + A [ i ] in B : <NEWLINE> <INDENT> B [ i + A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ i + A [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if j - A [ j ] in B : <NEWLINE> <INDENT> pair += B [ j - A [ j ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( pair ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = s [ k - 1 ] <NEWLINE> if l == <STRING> : <NEWLINE> <INDENT> x = s [ : ( k - 1 ) ] + <STRING> + s [ k : ] <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> x = s [ : ( k - 1 ) ] + <STRING> + s [ k : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ : ( k - 1 ) ] + <STRING> + s [ k : ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
ni = lambda : int ( input ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ni ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> rs = 0 <NEWLINE> gs = 0 <NEWLINE> bs = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rs += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> gs += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bs += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = rs * gs * bs <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = [ ] <NEWLINE> array += map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> premax = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> premax = max ( array [ n ] , premax ) <NEWLINE> ans += premax - array [ n ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> l = 0 <NEWLINE> r = a [ - 1 ] + 1 <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt += ( i - 1 ) // mid <NEWLINE> <DEDENT> if cnt <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import math <NEWLINE> H = int ( input ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 * f ( x // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( f ( H ) ) <NEWLINE>
big = 10 ** 18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> things = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> good = True <NEWLINE> if 0 in things : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in things : <NEWLINE> <INDENT> result *= x <NEWLINE> if result > big : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> good = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if good : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
from math import floor , ceil <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += floor ( ( n - 1 ) / a ) - ceil ( 1 / a ) + 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def count_up ( x , n ) : <NEWLINE> <INDENT> x [ n ] += 1 <NEWLINE> if x [ n ] > m : <NEWLINE> <INDENT> count_up ( x , n - 1 ) <NEWLINE> x [ n ] = x [ n - 1 ] <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> a , b , c , d = [ list ( i ) for i in zip ( * abcd ) ] <NEWLINE> x = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] <NEWLINE> ans = 0 <NEWLINE> if m == 1 : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if x [ b [ i ] ] - x [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> temp += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x [ 1 ] == 1 : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if x [ b [ i ] ] - x [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> temp += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> count_up ( x , n ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> an = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( set ( an ) ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 1 <NEWLINE> <NL> new_array = sorted ( array ) <NEWLINE> for i in range ( len ( new_array ) ) : <NEWLINE> <INDENT> sum *= new_array [ i ] <NEWLINE> if ( sum > 10 ** 18 or sum == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( sum > 10 ** 18 ) : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> length = int ( input ( ) ) <NEWLINE> stone = input ( ) <NEWLINE> red = [ 0 ] * ( length + 1 ) <NEWLINE> white = [ 0 ] * ( length + 1 ) <NEWLINE> [ red_num , white_num ] = [ 0 , 0 ] <NEWLINE> for i in range ( 1 , length + 1 ) : <NEWLINE> <INDENT> if ( stone [ i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> white_num += 1 <NEWLINE> <DEDENT> if ( stone [ length - i ] == <STRING> ) : <NEWLINE> <INDENT> red_num += 1 <NEWLINE> <DEDENT> white [ i ] = white_num <NEWLINE> red [ length - i ] = red_num <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mini = 200000 <NEWLINE> for i in range ( 0 , length + 1 ) : <NEWLINE> <INDENT> trial = max ( white [ i ] , red [ i ] ) <NEWLINE> mini = min ( mini , trial ) <NEWLINE> <DEDENT> print ( mini ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , Q = MAP ( ) <NEWLINE> LR = [ LIST ( ) for _ in range ( M ) ] <NEWLINE> pq = [ LIST ( ) for _ in range ( Q ) ] <NEWLINE> <NL> x = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for L , R in LR : <NEWLINE> <INDENT> x [ L ] [ R ] += 1 <NEWLINE> <NL> <DEDENT> for l in range ( N + 1 ) : <NEWLINE> <INDENT> x [ l ] = list ( accumulate ( x [ l ] ) ) <NEWLINE> <NL> <DEDENT> for l in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for r in range ( N + 1 ) : <NEWLINE> <INDENT> x [ l ] [ r ] += x [ l - 1 ] [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> print ( x [ q ] [ q ] - x [ q ] [ p - 1 ] - x [ p - 1 ] [ q ] + x [ p - 1 ] [ p - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> print ( re . sub ( <STRING> , lambda m : m . group ( 2 ) * int ( m . group ( 1 ) ) , s . rstrip ( ) ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> temp = 7 <NEWLINE> juu = 7 <NEWLINE> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> temp = temp % k <NEWLINE> if temp == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> juu = ( juu * 10 ) % k <NEWLINE> temp += juu % k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i , a in enumerate ( x [ : : - 1 ] ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( str ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> n = [ input ( ) . split ( ) for _ in range ( N ) ] <NEWLINE> <NL> all_info = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> def change_room ( info ) : <NEWLINE> <INDENT> info = [ int ( i ) for i in info ] <NEWLINE> info_dic = { <STRING> : all_info , <NEWLINE> <INDENT> <STRING> : info [ 0 ] - 1 , <NEWLINE> <STRING> : info [ 1 ] - 1 , <NEWLINE> <STRING> : info [ 2 ] - 1 , <NEWLINE> <STRING> : info [ 3 ] } <NEWLINE> <NL> <DEDENT> exec ( <STRING> , info_dic ) <NEWLINE> <NL> <DEDENT> for i in n : <NEWLINE> <INDENT> change_room ( i ) <NEWLINE> <NL> <DEDENT> for num , i in enumerate ( all_info ) : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> j = [ str ( i ) for i in j ] <NEWLINE> print ( <STRING> + ( <STRING> . join ( j ) ) ) <NEWLINE> <DEDENT> if num < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cs = [ i for i in input ( ) ] <NEWLINE> n_R = 0 <NEWLINE> for c in cs : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> n_R += 1 <NEWLINE> <DEDENT> <DEDENT> n_n_R = 0 <NEWLINE> for i in range ( n_R ) : <NEWLINE> <INDENT> if cs [ i ] == <STRING> : <NEWLINE> <INDENT> n_n_R += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n_R - n_n_R ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in array : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <NL> <DEDENT> dict_num = { i : 0 for i in range ( 100050 ) } <NEWLINE> Q = int ( input ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> matrix . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dict_num [ A [ i ] ] += 1 <NEWLINE> sum += A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in matrix : <NEWLINE> <INDENT> sum += ( i [ 1 ] - i [ 0 ] ) * dict_num [ i [ 0 ] ] <NEWLINE> dict_num [ i [ 1 ] ] += dict_num [ i [ 0 ] ] <NEWLINE> dict_num [ i [ 0 ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_1 = sum ( A ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> A [ i + 1 ] = A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ 0 ] = A [ 0 ] <NEWLINE> A [ i + 1 ] = A [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> a_2 = sum ( A ) <NEWLINE> print ( a_2 - a_1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> fact = { } <NEWLINE> i = 2 <NEWLINE> while n != 1 : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n = n / i <NEWLINE> if i in fact : <NEWLINE> <INDENT> fact [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fact [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i > ( n ** ( 1 / 2 ) + 1 ) : <NEWLINE> <INDENT> if n in fact : <NEWLINE> <INDENT> fact [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fact [ n ] = 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if fact == { } : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for v in fact . values ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> if v - i >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> v = v - i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> a *= int ( i ) <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) - 1 <NEWLINE> x = 26 <NEWLINE> d = 1 <NEWLINE> while n >= x : <NEWLINE> <INDENT> n -= x <NEWLINE> d += 1 <NEWLINE> x *= 26 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> al = list ( <STRING> ) <NEWLINE> tmp = pow ( 26 , d ) <NEWLINE> for i in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp //= 26 <NEWLINE> ans += al [ n // tmp ] <NEWLINE> n %= tmp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = deque ( maxlen = 2 * 10 ** 5 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans . append ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans . appendleft ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( str ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> multi = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> multi *= i <NEWLINE> if multi > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( multi ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : a [ i ] = a [ i ] + a [ i - 1 ] <NEWLINE> for i in range ( 1 , m + 1 ) : b [ i ] = b [ i ] + b [ i - 1 ] <NEWLINE> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if j < 0 : break <NEWLINE> while a [ i ] + b [ j ] > k and j >= 0 : j -= 1 <NEWLINE> ans = max ( i + j , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dic = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in dic : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> val = max ( dic . values ( ) ) <NEWLINE> for kv in dic . items ( ) : <NEWLINE> <INDENT> if kv [ 1 ] == val : <NEWLINE> <INDENT> ans . append ( kv [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sorted ( ans ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import numpy <NEWLINE> <NL> MAX = 10 ** 9 + 7 <NEWLINE> <NL> def prod_mod ( la , mod ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> for a in la : <NEWLINE> <INDENT> x *= a <NEWLINE> x %= mod <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> la = numpy . array ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> la . sort ( ) <NEWLINE> if n == k : <NEWLINE> <INDENT> print ( prod_mod ( la , MAX ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 1 and ( la >= 0 ) . sum ( ) == 0 : <NEWLINE> <INDENT> print ( prod_mod ( la [ - k : ] , MAX ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> il , ir = 0 , n - 1 <NEWLINE> cnt = 0 <NEWLINE> l = [ ] <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> l . append ( la [ ir ] ) <NEWLINE> ir -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> while k - ( cnt + 2 ) >= 0 : <NEWLINE> <INDENT> if la [ il ] * la [ il + 1 ] > la [ ir - 1 ] * la [ ir ] : <NEWLINE> <INDENT> l . extend ( [ la [ il ] , la [ il + 1 ] ] ) <NEWLINE> il += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . extend ( [ la [ ir - 1 ] , la [ ir ] ] ) <NEWLINE> ir -= 2 <NEWLINE> <DEDENT> cnt += 2 <NEWLINE> <DEDENT> print ( prod_mod ( l , MAX ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import itertools <NEWLINE> import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> als = list ( itertools . accumulate ( al ) ) <NEWLINE> als . insert ( 0 , 0 ) <NEWLINE> bls = list ( itertools . accumulate ( bl ) ) <NEWLINE> bls . insert ( 0 , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> nokori = K - als [ i ] <NEWLINE> if nokori >= 0 : <NEWLINE> <INDENT> index = bisect . bisect_right ( bls , nokori ) <NEWLINE> if index > 0 : <NEWLINE> <INDENT> index -= 1 <NEWLINE> <DEDENT> tmp = i + index <NEWLINE> <COMMENT> <NL> if tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> mx = a [ - 1 ] <NEWLINE> <NL> dp = [ True for _ in range ( mx ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if dp [ ai - 1 ] : <NEWLINE> <INDENT> if i >= len ( a ) - 1 or ai != a [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> for j in range ( ai - 1 , mx , ai ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> T = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> A = [ ] <NEWLINE> def parentSearch ( ) : <NEWLINE> <INDENT> numList = [ ] <NEWLINE> for t in T : <NEWLINE> <INDENT> if t [ 1 ] != 0 : <NEWLINE> <INDENT> for num in t [ 2 : ] : <NEWLINE> <INDENT> numList . append ( num ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> numList . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if numList [ i ] != i : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def rootedTrees ( node , parent , depth ) : <NEWLINE> <INDENT> t = T [ node ] <NEWLINE> if t [ 1 ] != 0 : <NEWLINE> <INDENT> if parent == - 1 : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> A . append ( [ t [ 0 ] , parent , depth , kind , t [ 2 : ] ] ) <NEWLINE> parent = node <NEWLINE> for i in t [ 2 : ] : <NEWLINE> <INDENT> rootedTrees ( i , parent , depth + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if parent == - 1 : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> A . append ( [ t [ 0 ] , parent , depth , kind , [ ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def Merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( [ 510000 ] ) <NEWLINE> R . append ( [ 510000 ] ) <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] [ 0 ] <= R [ j ] [ 0 ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def MergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> MergeSort ( A , left , mid ) <NEWLINE> MergeSort ( A , mid , right ) <NEWLINE> Merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> MergeSort ( T , 0 , n ) <NEWLINE> node = parentSearch ( ) <NEWLINE> if node == None : <NEWLINE> <INDENT> node = 0 <NEWLINE> <DEDENT> depth = 0 <NEWLINE> parent = - 1 <NEWLINE> rootedTrees ( node , parent , depth ) <NEWLINE> MergeSort ( A , 0 , n ) <NEWLINE> <NL> for t in A : <NEWLINE> <INDENT> print ( <STRING> . format ( t [ 0 ] , t [ 1 ] , t [ 2 ] , t [ 3 ] , t [ 4 ] ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> for x in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 or <STRING> in str ( x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Amax = A [ - 1 ] + 1 <NEWLINE> B = np . zeros ( Amax , dtype = int ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in A : <NEWLINE> <INDENT> for j in range ( i , Amax , i ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> if B [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x < 2 : return False <COMMENT> <NEWLINE> if x == 2 or x == 3 or x == 5 : return True <COMMENT> <NEWLINE> if x % 2 == 0 or x % 3 == 0 or x % 5 == 0 : return False <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> prime = 7 <NEWLINE> step = 4 <NEWLINE> while prime <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % prime == 0 : return False <NEWLINE> <NL> prime += step <NEWLINE> step = 6 - step <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if is_prime ( x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( * a [ : : - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = [ ] <NEWLINE> w = { } <NEWLINE> now = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ now ] <NEWLINE> now = p - 1 <NEWLINE> if p in w : <NEWLINE> <INDENT> j = v . index ( p ) <NEWLINE> df = i - j <NEWLINE> Kn = ( K - i - 1 ) % df <NEWLINE> p = v [ j + Kn ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v . append ( p ) <NEWLINE> w [ p ] = p <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = B - 1 <NEWLINE> print ( int ( A * x / B ) if x <= N else int ( A * N / B ) ) <NEWLINE>
def insertionSort ( A , n , g , in_cnt ) : <NEWLINE> <INDENT> lo_cnt = in_cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> lo_cnt = lo_cnt + 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return [ A , lo_cnt ] <NEWLINE> <NL> <NL> <DEDENT> A = [ ] <NEWLINE> G = [ ] <NEWLINE> data_num = int ( input ( ) ) <NEWLINE> for i in range ( data_num ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) . rstrip ( ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> gap = data_num <NEWLINE> while True : <NEWLINE> <INDENT> if gap > 1 : <NEWLINE> <INDENT> gap = gap // 2 <NEWLINE> <NL> <DEDENT> G . append ( gap ) <NEWLINE> A , cnt = insertionSort ( A , data_num , gap , cnt ) <NEWLINE> if gap == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( len ( G ) ) ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( str ( cnt ) ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
from collections import deque <NEWLINE> class DoublyLinkedKist : <NEWLINE> <INDENT> DLlist = deque ( ) <NEWLINE> <NL> def command ( self , cmd ) : <NEWLINE> <INDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> self . DLlist . appendleft ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> if cmd [ 1 ] in self . DLlist : <NEWLINE> <INDENT> self . DLlist . remove ( cmd [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> self . DLlist . popleft ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> self . DLlist . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> DL = DoublyLinkedKist ( ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> DL . command ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( * DL . DLlist ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 6500 ) <NEWLINE> <NL> def find ( n ) : <NEWLINE> <INDENT> if d [ n ] < 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ n ] = find ( d [ n ] ) <NEWLINE> return d [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( a , b ) : <NEWLINE> <INDENT> a = find ( a ) <NEWLINE> b = find ( b ) <NEWLINE> if a == b : return False <NEWLINE> if d [ a ] <= d [ b ] : <NEWLINE> <INDENT> d [ a ] += d [ b ] <NEWLINE> d [ b ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ b ] += d [ a ] <NEWLINE> d [ a ] = b <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def members ( n ) : <NEWLINE> <INDENT> p = find ( n ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if find ( i ) == p : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def same ( a , b ) : <NEWLINE> <INDENT> if find ( a ) == find ( b ) : return True <NEWLINE> else : return False <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ - 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> union ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if same ( i , p [ i ] - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , bisect <NEWLINE> <NL> <NL> <NL> def solve ( W_N , V_N , bombs , H , W ) : <NEWLINE> <NL> <INDENT> max_x = 1 <NEWLINE> xs = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if ( W_N [ i ] > max_x ) : <NEWLINE> <INDENT> max_x = W_N [ i ] <NEWLINE> xs = [ i ] <NEWLINE> <DEDENT> elif ( W_N [ i ] == max_x ) : <NEWLINE> <INDENT> xs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> max_y = 1 <NEWLINE> ys = [ ] <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> if ( V_N [ j ] > max_y ) : <NEWLINE> <INDENT> max_y = V_N [ j ] <NEWLINE> ys = [ j ] <NEWLINE> <DEDENT> elif ( V_N [ j ] == max_y ) : <NEWLINE> <INDENT> ys . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> value = max_x + max_y <NEWLINE> <NL> for j in ys : <NEWLINE> <NL> <INDENT> bombs [ j ] . sort ( ) <NEWLINE> for i in xs : <NEWLINE> <INDENT> index = bisect . bisect_left ( bombs [ j ] , i ) <NEWLINE> if ( index == V_N [ j ] or i != bombs [ j ] [ index ] ) : <NEWLINE> <INDENT> return value <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return value - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> H , W , N_bombs = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <NL> V_N = [ 0 ] * H <NEWLINE> W_N = [ 0 ] * W <NEWLINE> bombs = [ [ ] for _ in range ( H ) ] <NEWLINE> <NL> <NL> for i in range ( N_bombs ) : <NEWLINE> <INDENT> y , x = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> V_N [ y - 1 ] += 1 <NEWLINE> W_N [ x - 1 ] += 1 <NEWLINE> bombs [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( solve ( W_N , V_N , bombs , H , W ) ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N >= B : <NEWLINE> <INDENT> ans = int ( A * ( 2 * B - 1 ) / B ) - A * int ( ( 2 * B - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( A * N / B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from _collections import deque <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( h ) ] <NEWLINE> A = deque ( [ ] ) <NEWLINE> cnt = 1 <NEWLINE> <NL> def func ( X ) : <NEWLINE> <INDENT> global cnt <NEWLINE> ANS = [ ] <NEWLINE> c = X . count ( <STRING> ) <NEWLINE> a = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> ANS . append ( cnt ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a += 1 <NEWLINE> if a == c : <NEWLINE> <INDENT> for _ in range ( w - len ( ANS ) ) : <NEWLINE> <INDENT> ANS . append ( cnt - 1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A . append ( ANS ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if S [ i ] . count ( <STRING> ) == 0 and i != 0 and len ( A ) != 0 : <NEWLINE> <INDENT> A . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> elif S [ i ] . count ( <STRING> ) != 0 : <NEWLINE> <INDENT> func ( S [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( A ) != h : <NEWLINE> <INDENT> for _ in range ( h - len ( A ) ) : <NEWLINE> <INDENT> A . appendleft ( A [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in A : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> nl = [ 0 for i in range ( n ) ] <NEWLINE> for a in a_list : <NEWLINE> <INDENT> nl [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in nl : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mod = 0 <NEWLINE> ten = 1 <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> mod = ( mod + int ( S [ i ] ) * ten ) % 2019 <NEWLINE> ten = ten * 10 % 2019 <NEWLINE> count [ mod ] += 1 <NEWLINE> <DEDENT> for c in count : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> dp_list = [ { 0 , 0 } , { 0 : 0 , 1 : A [ 1 ] } , { 0 : 0 , 1 : A [ 1 ] if A [ 1 ] > A [ 2 ] else A [ 2 ] } ] <NEWLINE> <NL> for i in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> b = ( i - 1 ) // 2 <NEWLINE> f = ( i + 1 ) // 2 <NEWLINE> dp_list . append ( { } ) <NEWLINE> for j in range ( b , f + 1 ) : <NEWLINE> <INDENT> if j in dp_list [ i - 1 ] : <NEWLINE> <INDENT> dp_list [ i ] [ j ] = dp_list [ i - 2 ] [ j - 1 ] + A [ i ] if dp_list [ i - <NEWLINE> <INDENT> 2 ] [ j - 1 ] + A [ i ] > dp_list [ i - 1 ] [ j ] else dp_list [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp_list [ i ] [ j ] = dp_list [ i - 2 ] [ j - 1 ] + A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp_list [ - 1 ] [ N // 2 ] ) <NEWLINE>
import bisect <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( bisect . bisect ( a , r - 1.5 ) - bisect . bisect ( a , l - 1.5 ) ) <NEWLINE> <DEDENT>
<NL> <NL> r = [ ] <NEWLINE> for i in range ( 230 ) : <NEWLINE> <INDENT> A = i - 125 <NEWLINE> for j in range ( 230 ) : <NEWLINE> <INDENT> B = j - 125 <NEWLINE> r . append ( ( A ** 5 - B ** 5 , A , B ) ) <NEWLINE> <DEDENT> <DEDENT> r . sort ( ) <NEWLINE> <NL> target = int ( input ( ) ) <NEWLINE> lwbd = 0 <NEWLINE> upbd = len ( r ) <NEWLINE> <NL> <NL> while lwbd <= upbd : <NEWLINE> <INDENT> middle = lwbd + ( upbd - lwbd ) // 2 <NEWLINE> if ( r [ middle ] [ 0 ] == target ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif r [ middle ] [ 0 ] > target : <NEWLINE> <INDENT> upbd = middle - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lwbd = middle + 1 <NEWLINE> <DEDENT> <DEDENT> print ( r [ middle ] [ 1 ] , r [ middle ] [ 2 ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a != 0 ) and ( b != 0 ) : <NEWLINE> <INDENT> print ( str ( int ( a * ( a - 1 ) / 2 + b * ( b - 1 ) / 2 ) ) ) <NEWLINE> <DEDENT> elif ( a == 0 ) and ( b == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a == 0 ) and ( b != 0 ) : <NEWLINE> <INDENT> print ( str ( int ( b * ( b - 1 ) / 2 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( int ( a * ( a - 1 ) / 2 ) ) ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = int ( l [ i ] ) <NEWLINE> <NL> <DEDENT> cnt = 1 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> if sum > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> lis = [ 0 ] * ( 2 * 10 ** 5 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if - a - i >= - 2 * 10 ** 5 : <NEWLINE> <INDENT> lis [ - a - i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a - i < 0 : <NEWLINE> <INDENT> ans += lis [ a - i ] <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( N , A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( ( n + 1 ) * n ) // 2 - n ) <NEWLINE>
import math <NEWLINE> l = input ( ) . split ( ) <NEWLINE> x1 = float ( l [ 0 ] ) <NEWLINE> y1 = float ( l [ 1 ] ) <NEWLINE> x2 = float ( l [ 2 ] ) <NEWLINE> y2 = float ( l [ 3 ] ) <NEWLINE> <NL> a = pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) <NEWLINE> ans = math . sqrt ( a ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def str2list ( str ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for value in str . split ( <STRING> ) : <NEWLINE> <INDENT> result . append ( int ( value ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def distance1 ( n , x , y ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result += abs ( x [ i ] - y [ i ] ) <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def distance2 ( n , x , y ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result += ( x [ i ] - y [ i ] ) * ( x [ i ] - y [ i ] ) <NEWLINE> <NL> <DEDENT> return math . sqrt ( result ) if result != 0 else 0 <NEWLINE> <NL> <DEDENT> def distance3 ( n , x , y ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result += math . pow ( abs ( x [ i ] - y [ i ] ) , 3 ) <NEWLINE> <NL> <DEDENT> return math . exp ( math . log ( result ) / 3 ) if result != 0 else 0 <NEWLINE> <NL> <DEDENT> def distanceInf ( n , x , y ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> new_result = abs ( x [ i ] - y [ i ] ) <NEWLINE> result = new_result if new_result > result else result <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) ; <NEWLINE> x = str2list ( input ( ) ) <NEWLINE> y = str2list ( input ( ) ) <NEWLINE> <NL> print ( <STRING> % distance1 ( n , x , y ) ) <NEWLINE> print ( <STRING> % distance2 ( n , x , y ) ) <NEWLINE> print ( <STRING> % distance3 ( n , x , y ) ) <NEWLINE> print ( <STRING> % distanceInf ( n , x , y ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ 100 ] * 26 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = [ 0 ] * 26 <NEWLINE> for s in S [ i ] : <NEWLINE> <INDENT> key = ord ( s ) - ord ( <STRING> ) <NEWLINE> if tmp [ key ] < ans [ key ] : <NEWLINE> <INDENT> tmp [ key ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = tmp . copy ( ) <NEWLINE> <NL> <DEDENT> res = <STRING> <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> res += chr ( ord ( <STRING> ) + i ) * tmp [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
ans = { <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> st = <STRING> . join ( [ input ( ) for _ in range ( 8 ) ] ) <NEWLINE> <NL> st = st [ st . find ( <STRING> ) : st . rfind ( <STRING> ) + 1 ] <NEWLINE> for k , v in ans . items ( ) : <NEWLINE> <INDENT> if st == k : <NEWLINE> <INDENT> print ( v ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
def WalkingTakahashi ( ) : <NEWLINE> <NL> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> position = abs ( data [ 0 ] ) <NEWLINE> <NL> m = min ( data [ 1 ] , position // data [ 2 ] ) <NEWLINE> <NL> position = position - data [ 2 ] * m <NEWLINE> <NL> data [ 1 ] = data [ 1 ] - m <NEWLINE> <NL> data [ 1 ] %= 2 <NEWLINE> <NL> position = position - data [ 2 ] * data [ 1 ] <NEWLINE> <NL> print ( abs ( position ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> WalkingTakahashi ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> print ( <STRING> * w ) <NEWLINE> print ( ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) , end = <STRING> ) <NEWLINE> print ( <STRING> * w + <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = 1 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> M = max ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> l [ i ] = 1 <NEWLINE> for j in range ( i * 2 , M + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( l . count ( 1 ) ) <NEWLINE>
from collections import Counter as c <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) for _ in range ( N ) ) <NEWLINE> S . sort ( ) <NEWLINE> C , i = c ( S ) . most_common ( ) , 0 <NEWLINE> l , n = len ( C ) , C [ 0 ] [ 1 ] <NEWLINE> while i < l : <NEWLINE> <INDENT> if n == C [ i ] [ 1 ] : print ( C [ i ] [ 0 ] ) <NEWLINE> else : break <NEWLINE> i += 1 <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( X ) <NEWLINE> <NL> li = [ ] <NEWLINE> x . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <NL> <DEDENT> li . sort ( ) <NEWLINE> while len ( li ) > 1 : <NEWLINE> <INDENT> l = [ ] <NEWLINE> div = li [ 0 ] <NEWLINE> for n in li : <NEWLINE> <INDENT> mod = n % div <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> l . append ( mod ) <NEWLINE> <DEDENT> <DEDENT> l . append ( div ) <NEWLINE> l . sort ( ) <NEWLINE> li = l <NEWLINE> <DEDENT> print ( * li ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> b . append ( a [ i ] [ 0 ] . upper ( ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( b [ 0 ] + b [ 1 ] + b [ 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sorted_a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sorted_a . append ( [ a [ i ] , i ] ) <NEWLINE> <NL> <DEDENT> sorted_a . sort ( ) <NEWLINE> <COMMENT> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( sorted_a [ i ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> item = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> item [ r - 1 ] [ c - 1 ] = v <NEWLINE> <NL> <NL> <DEDENT> @ njit ( i8 ( i8 [ : , : ] , i8 , i8 ) , cache = True ) <NEWLINE> def solve ( item , R , C ) : <NEWLINE> <INDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , np . int64 ) <NEWLINE> for ri in range ( R ) : <NEWLINE> <INDENT> for ci in range ( C ) : <NEWLINE> <INDENT> dp [ ri + 1 ] [ ci + 1 ] [ 0 ] = max ( dp [ ri + 1 ] [ ci ] [ 0 ] , dp [ ri ] [ ci + 1 ] [ 3 ] ) <NEWLINE> dp [ ri + 1 ] [ ci + 1 ] [ 1 ] = max ( dp [ ri + 1 ] [ ci ] [ 1 ] , dp [ ri + 1 ] [ ci ] [ 0 ] + item [ ri ] [ ci ] , dp [ ri ] [ ci + 1 ] [ 3 ] + item [ ri ] [ ci ] , dp [ ri + 1 ] [ ci + 1 ] [ 0 ] ) <NEWLINE> dp [ ri + 1 ] [ ci + 1 ] [ 2 ] = max ( dp [ ri + 1 ] [ ci ] [ 2 ] , dp [ ri + 1 ] [ ci ] [ 1 ] + item [ ri ] [ ci ] , dp [ ri + 1 ] [ ci + 1 ] [ 1 ] ) <NEWLINE> dp [ ri + 1 ] [ ci + 1 ] [ 3 ] = max ( dp [ ri + 1 ] [ ci ] [ 3 ] , dp [ ri + 1 ] [ ci ] [ 2 ] + item [ ri ] [ ci ] , dp [ ri + 1 ] [ ci + 1 ] [ 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return dp [ - 1 ] [ - 1 ] [ 3 ] <NEWLINE> <NL> <DEDENT> print ( solve ( item , R , C ) ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A = A + [ 0 ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> max = A [ - 2 ] <NEWLINE> memo = [ <STRING> ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if memo [ A [ i ] ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( A [ i ] , max + 1 , A [ i ] ) : <NEWLINE> <INDENT> memo [ j ] = <STRING> <NEWLINE> <DEDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 1 <NEWLINE> mod = pow ( 10 , 18 ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> s = s * i <NEWLINE> if s > mod : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> dictionary = set ( ) <NEWLINE> for making in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> action = input ( ) . split ( ) <NEWLINE> if action [ 0 ] == <STRING> : dictionary . add ( action [ 1 ] ) <NEWLINE> else : <NEWLINE> <INDENT> if action [ 1 ] in dictionary : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> def NIJIGEN ( H ) : return [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( ) <NEWLINE> B = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> c = collections . Counter ( A ) <NEWLINE> s = c . most_common ( ) <NEWLINE> k = s [ 0 ] [ 0 ] <NEWLINE> t = s [ 0 ] [ 1 ] <NEWLINE> L = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if A [ i ] != k : <NEWLINE> <INDENT> L . append ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT> c = collections . Counter ( L ) <NEWLINE> s = c . most_common ( ) <NEWLINE> if len ( s ) != 0 : <NEWLINE> <INDENT> ans = s [ 0 ] [ 1 ] + t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = t <NEWLINE> <DEDENT> c = collections . Counter ( B ) <NEWLINE> s = c . most_common ( ) <NEWLINE> k = s [ 0 ] [ 0 ] <NEWLINE> t = s [ 0 ] [ 1 ] <NEWLINE> L = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if B [ i ] != k : <NEWLINE> <INDENT> L . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> c = collections . Counter ( L ) <NEWLINE> s = c . most_common ( ) <NEWLINE> if len ( s ) != 0 : <NEWLINE> <INDENT> q = s [ 0 ] [ 1 ] + t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = t <NEWLINE> <DEDENT> ans = max ( ans , q ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> enemy = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> enemy . sort ( reverse = True ) <NEWLINE> <NL> if k >= n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <NL> <INDENT> for x in range ( k ) : <NEWLINE> <INDENT> enemy [ x ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( enemy ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def dfs ( x , cnt ) : <NEWLINE> <INDENT> global ans <NEWLINE> if cnt != n : <NEWLINE> <INDENT> for i in range ( x [ - 1 ] , m + 1 ) : <NEWLINE> <INDENT> dfs ( x + [ i ] , cnt + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a , b , c , d in lis : <NEWLINE> <INDENT> if x [ a - 1 ] + c == x [ b - 1 ] : <NEWLINE> <INDENT> cnt += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> dfs ( [ 1 ] , 0 ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> MOD = int ( 1e9 + 7 ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> SQ = S * S <NEWLINE> IS = sum ( a * a for a in A ) <NEWLINE> <NL> print ( ( ( SQ - IS ) // 2 ) % MOD ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yoi = np . ones ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> yoi [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ B - 1 ] > H [ A - 1 ] : <NEWLINE> <INDENT> yoi [ A - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A - 1 ] == H [ B - 1 ] : <NEWLINE> <INDENT> yoi [ A - 1 ] = 0 <NEWLINE> yoi [ B - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( int ( np . sum ( yoi ) ) ) <NEWLINE>
import sys <NEWLINE> d = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> a = <STRING> . join ( d [ c ] for c in e [ : - 1 ] ) <NEWLINE> a += <STRING> * ( - len ( a ) % 5 ) <NEWLINE> print ( <STRING> . join ( <STRING> [ int ( a [ i : i + 5 ] , 2 ) ] for i in range ( 0 , len ( a ) , 5 ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans [ a [ i - 1 ] - 1 ] = i <NEWLINE> <DEDENT> [ print ( ans [ i ] , end = <STRING> ) for i in range ( n ) ] <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> Line = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> c = collections . Counter ( Line ) <NEWLINE> <NL> <COMMENT> <NL> v = 0 <NEWLINE> <NL> for i in c : <NEWLINE> <COMMENT> <NL> <INDENT> v += i * c [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> Line = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> try : <NEWLINE> <INDENT> c [ Line [ 1 ] ] += c [ Line [ 0 ] ] <NEWLINE> <NL> <COMMENT> <NL> v += c [ Line [ 0 ] ] * ( Line [ 1 ] - Line [ 0 ] ) <NEWLINE> c . pop ( Line [ 0 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( v ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> alphabets = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def run ( n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 1 , 12 ) : <NEWLINE> <INDENT> if math . pow ( 26 , i ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n -= int ( math . pow ( 26 , i ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for j in range ( i - 1 ) : <NEWLINE> <INDENT> b = n // int ( math . pow ( 26 , i - j - 1 ) ) <NEWLINE> amari = n % int ( math . pow ( 26 , i - j - 1 ) ) <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> ans += alphabets [ b ] <NEWLINE> n = n % int ( math . pow ( 26 , i - j - 1 ) ) <NEWLINE> <DEDENT> ans += alphabets [ n - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( run ( N ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> temp = 0 <NEWLINE> bk_temp = 0 <NEWLINE> <NL> if B <= N : <NEWLINE> <INDENT> max = math . floor ( A * ( B - 1 ) / B ) - ( A * math . floor ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> max = math . floor ( A * N / B ) - ( A * math . floor ( ( N ) / B ) ) <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> li = [ 0 ] * 2019 <NEWLINE> ans = 0 <NEWLINE> li [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> s = 0 <NEWLINE> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> s += int ( i ) * d <NEWLINE> s = s % 2019 <NEWLINE> li [ s ] += 1 <NEWLINE> d *= 10 <NEWLINE> d = d % 2019 <NEWLINE> <NL> <DEDENT> for l in li : <NEWLINE> <INDENT> ans += l * ( l - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in X : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= X [ i ] <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = a [ i ] <NEWLINE> <NL> <DEDENT> sort_L = sorted ( L . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> for j in sort_L : <NEWLINE> <INDENT> print ( j [ 0 ] + 1 , end = <STRING> ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = X <NEWLINE> if N > 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P . sort ( ) <NEWLINE> if X in P : <NEWLINE> <INDENT> ans = 0 <NEWLINE> x = P . index ( X ) <NEWLINE> i = 1 <NEWLINE> a = x - 1 <NEWLINE> b = x + 1 <NEWLINE> m = min ( P [ N - 1 ] - X , X - P [ 0 ] ) <NEWLINE> for i in range ( 1 , m + 2 ) : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> if b > N - 1 : <NEWLINE> <INDENT> b = N - 1 <NEWLINE> <DEDENT> if X - i != P [ a ] : <NEWLINE> <INDENT> ans = X - i <NEWLINE> break <NEWLINE> <DEDENT> elif X + i != P [ b ] : <NEWLINE> <INDENT> ans = X + i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for p in range ( k ) : <NEWLINE> <INDENT> for q in range ( k ) : <NEWLINE> <INDENT> n = math . gcd ( p + 1 , q + 1 ) <NEWLINE> for r in range ( k ) : <NEWLINE> <INDENT> sum += math . gcd ( n , r + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * ( n - 1 ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> used = { 0 } <NEWLINE> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> for next_node in graph [ node ] : <NEWLINE> <INDENT> if next_node in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( next_node ) <NEWLINE> used . add ( next_node ) <NEWLINE> ans [ next_node - 1 ] = node + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
def bit ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = 99999999999999999 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> level = [ 0 ] * ( m ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> cost += books [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> level [ k ] += books [ j ] [ k + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if level and min ( level ) >= x : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 99999999999999999 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> bit ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> import sys <NEWLINE> k = sys . stdin . readline ( ) <NEWLINE> k = int ( k ) <NEWLINE> sum = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( x , k + 1 ) : <NEWLINE> <INDENT> for z in range ( y , k + 1 ) : <NEWLINE> <INDENT> if len ( set ( [ x , y , z ] ) ) is 1 : <NEWLINE> <INDENT> sum = sum + math . gcd ( math . gcd ( x , y ) , math . gcd ( y , z ) ) <NEWLINE> <DEDENT> elif len ( set ( [ x , y , z ] ) ) is 2 : <NEWLINE> <INDENT> sum = sum + 3 * math . gcd ( math . gcd ( x , y ) , math . gcd ( y , z ) ) <NEWLINE> <DEDENT> elif len ( set ( [ x , y , z ] ) ) is 3 : <NEWLINE> <INDENT> sum = sum + 6 * math . gcd ( math . gcd ( x , y ) , math . gcd ( y , z ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> nodes = [ 0 ] * N <NEWLINE> visit = [ 0 ] * N <NEWLINE> edges_dic = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A in edges_dic : <NEWLINE> <INDENT> edges_dic [ A ] . append ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges_dic [ A ] = [ B ] <NEWLINE> <NL> <DEDENT> if B in edges_dic : <NEWLINE> <INDENT> edges_dic [ B ] . append ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges_dic [ B ] = [ A ] <NEWLINE> <DEDENT> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> while len ( queue ) >= 1 : <NEWLINE> <INDENT> q = queue . popleft ( ) <NEWLINE> visit [ q - 1 ] = 1 <NEWLINE> next_n = edges_dic [ q ] <NEWLINE> for n in next_n : <NEWLINE> <INDENT> if visit [ n - 1 ] == 0 : <NEWLINE> <INDENT> nodes [ n - 1 ] = q <NEWLINE> visit [ n - 1 ] = 1 <NEWLINE> queue . append ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( nodes [ i ] ) <NEWLINE> <DEDENT>
n , k = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> la = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> cond = la [ i ] > la [ i - k ] <NEWLINE> print ( <STRING> if cond else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> nmax = int ( 2e5 + 1 ) <NEWLINE> X = [ 0 ] * nmax <NEWLINE> Y = [ 0 ] * nmax <NEWLINE> for n , a in enumerate ( A ) : <NEWLINE> <INDENT> x = n - a <NEWLINE> y = n + a <NEWLINE> if x >= 0 and x < nmax : <NEWLINE> <INDENT> X [ x ] += 1 <NEWLINE> <DEDENT> if y >= 0 and y < nmax : <NEWLINE> <INDENT> Y [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x , y in zip ( X , Y ) : <NEWLINE> <INDENT> ret += x * y <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
import math <NEWLINE> def isPrime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> m = math . floor ( n / 2 ) + 1 <NEWLINE> for p in range ( 3 , m , 2 ) : <COMMENT> <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( X , 10 ** 10 ) : <NEWLINE> <INDENT> if isPrime ( i ) : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> if K <= N : <NEWLINE> <INDENT> p = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> t = [ - 1 ] * N <COMMENT> <NEWLINE> t [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> p = A [ p ] <COMMENT> <NEWLINE> if t [ p ] != - 1 : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t [ p ] = i <NEWLINE> <DEDENT> d = i - t [ p ] <COMMENT> <NEWLINE> K -= i <COMMENT> <NEWLINE> K %= d <COMMENT> <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> diff = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( a [ i - 1 ] > a [ i ] ) : <NEWLINE> <INDENT> diff = a [ i - 1 ] - a [ i ] <NEWLINE> a [ i ] += diff <NEWLINE> ans += diff <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = set ( [ ] ) <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = tuple ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> A . add ( ( u , v ) ) <NEWLINE> <NL> <DEDENT> V = 0 <NEWLINE> for l in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> V += ( N - l + 1 ) * ( N - l + 2 ) // 2 <NEWLINE> <NL> <DEDENT> E = 0 <NEWLINE> for u , v in A : <NEWLINE> <INDENT> a = min ( u , v ) <NEWLINE> b = max ( u , v ) <NEWLINE> E += a * ( N - b + 1 ) <NEWLINE> <NL> <DEDENT> print ( V - E ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if W >= V or abs ( A - B ) / abs ( W - V ) > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import collections <NEWLINE> from math import ceil , floor , sqrt , pi , factorial , gcd <NEWLINE> from copy import deepcopy <NEWLINE> from collections import Counter , deque <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , product , combinations , combinations_with_replacement <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from functools import reduce <NEWLINE> from decimal import Decimal , getcontext <NEWLINE> <COMMENT> <NL> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> def lcm ( a , b ) : return a * b // gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> num_list = [ ] <NEWLINE> str_list = [ ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = i_input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sum += ( N - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = n % 9 <NEWLINE> if cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> def fanc ( N ) : <NEWLINE> <INDENT> return N * ( N + 1 ) // 2 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * fanc ( N // i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def fibonacci ( n , memo = None ) : <NEWLINE> <INDENT> if memo == None : <NEWLINE> <INDENT> memo = [ None ] * n <NEWLINE> <DEDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if memo [ n - 2 ] == None : <NEWLINE> <INDENT> memo [ n - 2 ] = fibonacci ( n - 2 , memo ) <NEWLINE> <DEDENT> if memo [ n - 1 ] == None : <NEWLINE> <INDENT> memo [ n - 1 ] = fibonacci ( n - 1 , memo ) <NEWLINE> <DEDENT> <DEDENT> return memo [ n - 1 ] + memo [ n - 2 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( fibonacci ( n ) ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( <STRING> ) ) <NEWLINE> L = ( list ( map ( int , input ( <STRING> ) . split ( <STRING> ) ) ) ) <NEWLINE> L = np . array ( sorted ( L ) ) <NEWLINE> set_L = set ( L ) <NEWLINE> <NL> if len ( set_L ) <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = { i : len ( L [ L == i ] ) for i in set_L } <NEWLINE> <NL> i = 0 <NEWLINE> for team in itertools . combinations ( K . keys ( ) , 3 ) : <NEWLINE> <INDENT> if ( team [ 0 ] < team [ 1 ] + team [ 2 ] ) & ( team [ 1 ] < team [ 0 ] + team [ 2 ] ) & ( team [ 2 ] < team [ 0 ] + team [ 1 ] ) : <NEWLINE> <INDENT> i += K [ team [ 0 ] ] * K [ team [ 1 ] ] * K [ team [ 2 ] ] <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while i < H : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < W : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> X = [ 0 for i in range ( 100 ) ] <NEWLINE> G = [ [ 0 for i in range ( 100 ) ] for i in range ( 100 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X [ i ] = stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( int ( X [ i ] [ 1 ] ) ) : <NEWLINE> <INDENT> G [ i ] [ int ( X [ i ] [ j + 2 ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j != n - 1 : print ( G [ i ] [ j ] , end = <STRING> ) <NEWLINE> else : print ( G [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> s = <STRING> <NEWLINE> list = [ ] <NEWLINE> temp = <STRING> <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> list . append ( s ) <NEWLINE> n = n - 1 <NEWLINE> <NL> <DEDENT> list . sort ( ) <NEWLINE> for item in list : <NEWLINE> <INDENT> if item == temp : <NEWLINE> <INDENT> counter = counter - 1 <NEWLINE> <DEDENT> counter = counter + 1 <NEWLINE> temp = item <NEWLINE> <NL> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ln = max ( a ) + 1 <NEWLINE> l = [ 0 ] * ln <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> for j in range ( i , ln , i ) : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <NL> class UnionFind ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> max_ = 0 <NEWLINE> roots = uf . roots ( ) <NEWLINE> <NL> for r in roots : <NEWLINE> <INDENT> max_ = max ( max_ , uf . size ( r ) ) <NEWLINE> <NL> <DEDENT> print ( max_ ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = 0 <NEWLINE> y = s . count ( <STRING> ) <NEWLINE> c = min ( n - y , y ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = s [ i ] == <STRING> <COMMENT> <NEWLINE> x += t <NEWLINE> y -= 1 - t <NEWLINE> c = min ( c , x + y ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
from math import gcd , ceil <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] // 2 <NEWLINE> <NL> <DEDENT> lcm_v = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> lcm_v = lcm ( lcm_v , a [ i ] ) <NEWLINE> <NL> <DEDENT> ok = True <NEWLINE> for aa in a : <NEWLINE> <INDENT> if ( lcm_v // aa ) % 2 != 1 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if ok : <NEWLINE> <INDENT> ans = ( ( m // lcm_v ) + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def combination ( n , r ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def count_list ( lst ) : <NEWLINE> <INDENT> count_lst = [ 0 ] * ( max ( lst ) + 1 ) <NEWLINE> <NL> for i in lst : <NEWLINE> <INDENT> count_lst [ i ] += 1 <NEWLINE> <NL> <DEDENT> return count_lst <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst1 = count_list ( a_lst ) <NEWLINE> lst2 = [ 0 ] * len ( lst1 ) <NEWLINE> for i in range ( len ( lst1 ) ) : <NEWLINE> <INDENT> lst2 [ i ] = combination ( lst1 [ i ] , 2 ) <NEWLINE> <DEDENT> tmp = sum ( lst2 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = a_lst [ i ] <NEWLINE> print ( tmp - ( lst1 [ a ] - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> keiro = [ 1 ] <NEWLINE> visit_town = [ 0 ] * N <NEWLINE> <NL> town = 1 <NEWLINE> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> visit_town [ town - 1 ] = c <NEWLINE> c += 1 <NEWLINE> town = A_list [ town - 1 ] <NEWLINE> <COMMENT> <NL> <NL> if len ( keiro ) > 1 and visit_town [ town - 1 ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> keiro . append ( town ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> first_visit = keiro [ : visit_town [ A_list [ keiro [ - 1 ] - 1 ] - 1 ] - 1 ] <NEWLINE> loop_visit = keiro [ visit_town [ A_list [ keiro [ - 1 ] - 1 ] - 1 ] - 1 : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if K <= len ( first_visit ) - 1 : <NEWLINE> <INDENT> print ( first_visit [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = K - len ( first_visit ) <NEWLINE> <COMMENT> <NL> c = ( l ) % len ( loop_visit ) <NEWLINE> <COMMENT> <NL> print ( loop_visit [ c ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> dabu = 1 <NEWLINE> <DEDENT> elif a != b and b != c and c != a : <NEWLINE> <INDENT> dabu = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dabu = 3 <NEWLINE> <DEDENT> if a * b * c != 0 : <NEWLINE> <INDENT> s = math . gcd ( math . gcd ( a , b ) , c ) * dabu <NEWLINE> ans = ans + s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> A , B = [ 0 ] * M , [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ A [ i ] - 1 ] . append ( B [ i ] - 1 ) <NEWLINE> g [ B [ i ] - 1 ] . append ( A [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> ans_list = [ - 1 ] * N <NEWLINE> <NL> queue = [ 0 ] <NEWLINE> seen = [ False ] * N <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> qi = queue . pop ( 0 ) <NEWLINE> <COMMENT> <NL> for gi in g [ qi ] : <NEWLINE> <INDENT> if seen [ gi ] == False : <NEWLINE> <INDENT> queue . append ( gi ) <NEWLINE> if ans_list [ gi ] == - 1 : <NEWLINE> <INDENT> ans_list [ gi ] = qi <NEWLINE> seen [ gi ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for ans in ans_list [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = r ** 2 * math . pi <NEWLINE> circumference = r * 2 * math . pi <NEWLINE> print ( <STRING> . format ( area , circumference ) ) <NEWLINE>
import math <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = s [ 0 ] <NEWLINE> b = s [ 1 ] <NEWLINE> n = s [ 2 ] <NEWLINE> x = 0 <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> ans = math . floor ( a * x / b ) - n * math . floor ( x / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> ans = math . floor ( a * x / b ) - n * math . floor ( x / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = set ( [ ] ) <NEWLINE> things = int ( input ( ) ) <NEWLINE> <NL> for i in range ( things ) : <NEWLINE> <INDENT> p = input ( ) <NEWLINE> s . add ( p ) <NEWLINE> <NL> <DEDENT> print ( len ( s ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> H . sort ( ) <NEWLINE> df = 0 <NEWLINE> min_h = H [ K - 1 ] - H [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> new_h = H [ i + K - 1 ] - H [ i ] <NEWLINE> if new_h < min_h : <NEWLINE> <INDENT> min_h = new_h <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_h ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ln1 = [ ] <NEWLINE> ln2 = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> if i [ 0 ] == 1 : <NEWLINE> <INDENT> ln1 . append ( i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for j in p : <NEWLINE> <INDENT> if j [ 1 ] == n : <NEWLINE> <INDENT> ln2 . append ( j [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( set ( ln1 ) & set ( ln2 ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> prace = [ ] <NEWLINE> know = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prace . append ( acc [ 0 ] ) <NEWLINE> know . append ( acc [ 1 : ] ) <NEWLINE> <NL> <DEDENT> ans = 10 ** 10 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> und = [ 0 for i in range ( m ) ] <NEWLINE> f = <STRING> . format ( i ) <NEWLINE> s = f . zfill ( n ) <NEWLINE> mm = 0 <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> und [ k ] += know [ j ] [ k ] <NEWLINE> <DEDENT> mm += prace [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if und [ j ] < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , mm ) <NEWLINE> <DEDENT> <DEDENT> if ans == 10 ** 10 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def primes ( n ) : <NEWLINE> <INDENT> prs = [ ] <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( is_prime ) ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> prs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prs <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = 10 ** 6 <NEWLINE> nlis = [ 0 ] * A <NEWLINE> flg_pairwise = True <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nlis [ lis [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in primes ( A ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i - 1 , A , i ) : <NEWLINE> <INDENT> cnt += nlis [ j ] <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> flg_pairwise = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg_pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> tmp = gcd ( lis [ i ] , lis [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = gcd ( tmp , lis [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = [ <STRING> ] <NEWLINE> <NL> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> elif <STRING> in list ( str ( i ) ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * result ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> A = s . index ( <STRING> ) <NEWLINE> for i in range ( A , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B == 1 : print ( 0 ) ; exit ( ) <NEWLINE> if N <= B : <NEWLINE> <INDENT> print ( max ( ( A * ( N - 1 ) ) // B - A * ( ( N - 1 ) // B ) , ( A * N ) // B - A * ( N // B ) ) ) <NEWLINE> <DEDENT> else : print ( A - 1 ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K < A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K < A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> md = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> while j < n : <NEWLINE> <INDENT> if A [ j ] - A [ i ] <= 2 : <NEWLINE> <INDENT> md = max ( j - i , md ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( md + 1 ) <NEWLINE> <NL>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b == c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a_ = b + c <NEWLINE> b_ = a + c <NEWLINE> c_ = a + b <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_ - b_ ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> % ( r * r * pi , 2 * r * pi ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( start ) : <NEWLINE> <INDENT> q = deque ( [ [ start ] ] ) <NEWLINE> visited = set ( ) <NEWLINE> while q : <NEWLINE> <INDENT> path = q . popleft ( ) <NEWLINE> i , j = path [ - 1 ] <NEWLINE> if ( i , j ) == ( H - 1 , W - 1 ) : <NEWLINE> <INDENT> return path <NEWLINE> <DEDENT> for di , dj in [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> ni , nj = i + di , j + dj <NEWLINE> if ( <NEWLINE> <INDENT> 0 <= ni < H <NEWLINE> and 0 <= nj < W <NEWLINE> and field [ ni ] [ nj ] != <STRING> <NEWLINE> and ( ni , nj ) not in visited <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> q . append ( path + [ ( ni , nj ) ] ) <NEWLINE> visited . add ( ( ni , nj ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ input ( ) for _ in range ( H ) ] <NEWLINE> shortest_path = bfs ( ( 0 , 0 ) ) <NEWLINE> if shortest_path is None : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> and ( i , j ) not in shortest_path : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> li = [ ] <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> if i == len ( s ) - 1 : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i > 0 and li [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> li . append ( c ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( li ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> plist = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 , 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 , 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 , 13513 , 13523 , 13537 , 13553 , 13567 , 13577 , 13591 , 13597 , 13613 , 13619 , 13627 , 13633 , 13649 , 13669 , 13679 , 13681 , 13687 , 13691 , 13693 , 13697 , 13709 , 13711 , 13721 , 13723 , 13729 , 13751 , 13757 , 13759 , 13763 , 13781 , 13789 , 13799 , 13807 , 13829 , 13831 , 13841 , 13859 , 13873 , 13877 , 13879 , 13883 , 13901 , 13903 , 13907 , 13913 , 13921 , 13931 , 13933 , 13963 , 13967 , 13997 , 13999 , 14009 , 14011 , 14029 , 14033 , 14051 , 14057 , 14071 , 14081 , 14083 , 14087 , 14107 , 14143 , 14149 , 14153 , 14159 , 14173 , 14177 , 14197 , 14207 , 14221 , 14243 , 14249 , 14251 , 14281 , 14293 , 14303 , 14321 , 14323 , 14327 , 14341 , 14347 , 14369 , 14387 , 14389 , 14401 , 14407 , 14411 , 14419 , 14423 , 14431 , 14437 , 14447 , 14449 , 14461 , 14479 , 14489 , 14503 , 14519 , 14533 , 14537 , 14543 , 14549 , 14551 , 14557 , 14561 , 14563 , 14591 , 14593 , 14621 , 14627 , 14629 , 14633 , 14639 , 14653 , 14657 , 14669 , 14683 , 14699 , 14713 , 14717 , 14723 , 14731 , 14737 , 14741 , 14747 , 14753 , 14759 , 14767 , 14771 , 14779 , 14783 , 14797 , 14813 , 14821 , 14827 , 14831 , 14843 , 14851 , 14867 , 14869 , 14879 , 14887 , 14891 , 14897 , 14923 , 14929 , 14939 , 14947 , 14951 , 14957 , 14969 , 14983 , 15013 , 15017 , 15031 , 15053 , 15061 , 15073 , 15077 , 15083 , 15091 , 15101 , 15107 , 15121 , 15131 , 15137 , 15139 , 15149 , 15161 , 15173 , 15187 , 15193 , 15199 , 15217 , 15227 , 15233 , 15241 , 15259 , 15263 , 15269 , 15271 , 15277 , 15287 , 15289 , 15299 , 15307 , 15313 , 15319 , 15329 , 15331 , 15349 , 15359 , 15361 , 15373 , 15377 , 15383 , 15391 , 15401 , 15413 , 15427 , 15439 , 15443 , 15451 , 15461 , 15467 , 15473 , 15493 , 15497 , 15511 , 15527 , 15541 , 15551 , 15559 , 15569 , 15581 , 15583 , 15601 , 15607 , 15619 , 15629 , 15641 , 15643 , 15647 , 15649 , 15661 , 15667 , 15671 , 15679 , 15683 , 15727 , 15731 , 15733 , 15737 , 15739 , 15749 , 15761 , 15767 , 15773 , 15787 , 15791 , 15797 , 15803 , 15809 , 15817 , 15823 , 15859 , 15877 , 15881 , 15887 , 15889 , 15901 , 15907 , 15913 , 15919 , 15923 , 15937 , 15959 , 15971 , 15973 , 15991 , 16001 , 16007 , 16033 , 16057 , 16061 , 16063 , 16067 , 16069 , 16073 , 16087 , 16091 , 16097 , 16103 , 16111 , 16127 , 16139 , 16141 , 16183 , 16187 , 16189 , 16193 , 16217 , 16223 , 16229 , 16231 , 16249 , 16253 , 16267 , 16273 , 16301 , 16319 , 16333 , 16339 , 16349 , 16361 , 16363 , 16369 , 16381 , 16411 , 16417 , 16421 , 16427 , 16433 , 16447 , 16451 , 16453 , 16477 , 16481 , 16487 , 16493 , 16519 , 16529 , 16547 , 16553 , 16561 , 16567 , 16573 , 16603 , 16607 , 16619 , 16631 , 16633 , 16649 , 16651 , 16657 , 16661 , 16673 , 16691 , 16693 , 16699 , 16703 , 16729 , 16741 , 16747 , 16759 , 16763 , 16787 , 16811 , 16823 , 16829 , 16831 , 16843 , 16871 , 16879 , 16883 , 16889 , 16901 , 16903 , 16921 , 16927 , 16931 , 16937 , 16943 , 16963 , 16979 , 16981 , 16987 , 16993 , 17011 , 17021 , 17027 , 17029 , 17033 , 17041 , 17047 , 17053 , 17077 , 17093 , 17099 , 17107 , 17117 , 17123 , 17137 , 17159 , 17167 , 17183 , 17189 , 17191 , 17203 , 17207 , 17209 , 17231 , 17239 , 17257 , 17291 , 17293 , 17299 , 17317 , 17321 , 17327 , 17333 , 17341 , 17351 , 17359 , 17377 , 17383 , 17387 , 17389 , 17393 , 17401 , 17417 , 17419 , 17431 , 17443 , 17449 , 17467 , 17471 , 17477 , 17483 , 17489 , 17491 , 17497 , 17509 , 17519 , 17539 , 17551 , 17569 , 17573 , 17579 , 17581 , 17597 , 17599 , 17609 , 17623 , 17627 , 17657 , 17659 , 17669 , 17681 , 17683 , 17707 , 17713 , 17729 , 17737 , 17747 , 17749 , 17761 , 17783 , 17789 , 17791 , 17807 , 17827 , 17837 , 17839 , 17851 , 17863 , 17881 , 17891 , 17903 , 17909 , 17911 , 17921 , 17923 , 17929 , 17939 , 17957 , 17959 , 17971 , 17977 , 17981 , 17987 , 17989 , 18013 , 18041 , 18043 , 18047 , 18049 , 18059 , 18061 , 18077 , 18089 , 18097 , 18119 , 18121 , 18127 , 18131 , 18133 , 18143 , 18149 , 18169 , 18181 , 18191 , 18199 , 18211 , 18217 , 18223 , 18229 , 18233 , 18251 , 18253 , 18257 , 18269 , 18287 , 18289 , 18301 , 18307 , 18311 , 18313 , 18329 , 18341 , 18353 , 18367 , 18371 , 18379 , 18397 , 18401 , 18413 , 18427 , 18433 , 18439 , 18443 , 18451 , 18457 , 18461 , 18481 , 18493 , 18503 , 18517 , 18521 , 18523 , 18539 , 18541 , 18553 , 18583 , 18587 , 18593 , 18617 , 18637 , 18661 , 18671 , 18679 , 18691 , 18701 , 18713 , 18719 , 18731 , 18743 , 18749 , 18757 , 18773 , 18787 , 18793 , 18797 , 18803 , 18839 , 18859 , 18869 , 18899 , 18911 , 18913 , 18917 , 18919 , 18947 , 18959 , 18973 , 18979 , 19001 , 19009 , 19013 , 19031 , 19037 , 19051 , 19069 , 19073 , 19079 , 19081 , 19087 , 19121 , 19139 , 19141 , 19157 , 19163 , 19181 , 19183 , 19207 , 19211 , 19213 , 19219 , 19231 , 19237 , 19249 , 19259 , 19267 , 19273 , 19289 , 19301 , 19309 , 19319 , 19333 , 19373 , 19379 , 19381 , 19387 , 19391 , 19403 , 19417 , 19421 , 19423 , 19427 , 19429 , 19433 , 19441 , 19447 , 19457 , 19463 , 19469 , 19471 , 19477 , 19483 , 19489 , 19501 , 19507 , 19531 , 19541 , 19543 , 19553 , 19559 , 19571 , 19577 , 19583 , 19597 , 19603 , 19609 , 19661 , 19681 , 19687 , 19697 , 19699 , 19709 , 19717 , 19727 , 19739 , 19751 , 19753 , 19759 , 19763 , 19777 , 19793 , 19801 , 19813 , 19819 , 19841 , 19843 , 19853 , 19861 , 19867 , 19889 , 19891 , 19913 , 19919 , 19927 , 19937 , 19949 , 19961 , 19963 , 19973 , 19979 , 19991 , 19993 , 19997 , 20011 , 20021 , 20023 , 20029 , 20047 , 20051 , 20063 , 20071 , 20089 , 20101 , 20107 , 20113 , 20117 , 20123 , 20129 , 20143 , 20147 , 20149 , 20161 , 20173 , 20177 , 20183 , 20201 , 20219 , 20231 , 20233 , 20249 , 20261 , 20269 , 20287 , 20297 , 20323 , 20327 , 20333 , 20341 , 20347 , 20353 , 20357 , 20359 , 20369 , 20389 , 20393 , 20399 , 20407 , 20411 , 20431 , 20441 , 20443 , 20477 , 20479 , 20483 , 20507 , 20509 , 20521 , 20533 , 20543 , 20549 , 20551 , 20563 , 20593 , 20599 , 20611 , 20627 , 20639 , 20641 , 20663 , 20681 , 20693 , 20707 , 20717 , 20719 , 20731 , 20743 , 20747 , 20749 , 20753 , 20759 , 20771 , 20773 , 20789 , 20807 , 20809 , 20849 , 20857 , 20873 , 20879 , 20887 , 20897 , 20899 , 20903 , 20921 , 20929 , 20939 , 20947 , 20959 , 20963 , 20981 , 20983 , 21001 , 21011 , 21013 , 21017 , 21019 , 21023 , 21031 , 21059 , 21061 , 21067 , 21089 , 21101 , 21107 , 21121 , 21139 , 21143 , 21149 , 21157 , 21163 , 21169 , 21179 , 21187 , 21191 , 21193 , 21211 , 21221 , 21227 , 21247 , 21269 , 21277 , 21283 , 21313 , 21317 , 21319 , 21323 , 21341 , 21347 , 21377 , 21379 , 21383 , 21391 , 21397 , 21401 , 21407 , 21419 , 21433 , 21467 , 21481 , 21487 , 21491 , 21493 , 21499 , 21503 , 21517 , 21521 , 21523 , 21529 , 21557 , 21559 , 21563 , 21569 , 21577 , 21587 , 21589 , 21599 , 21601 , 21611 , 21613 , 21617 , 21647 , 21649 , 21661 , 21673 , 21683 , 21701 , 21713 , 21727 , 21737 , 21739 , 21751 , 21757 , 21767 , 21773 , 21787 , 21799 , 21803 , 21817 , 21821 , 21839 , 21841 , 21851 , 21859 , 21863 , 21871 , 21881 , 21893 , 21911 , 21929 , 21937 , 21943 , 21961 , 21977 , 21991 , 21997 , 22003 , 22013 , 22027 , 22031 , 22037 , 22039 , 22051 , 22063 , 22067 , 22073 , 22079 , 22091 , 22093 , 22109 , 22111 , 22123 , 22129 , 22133 , 22147 , 22153 , 22157 , 22159 , 22171 , 22189 , 22193 , 22229 , 22247 , 22259 , 22271 , 22273 , 22277 , 22279 , 22283 , 22291 , 22303 , 22307 , 22343 , 22349 , 22367 , 22369 , 22381 , 22391 , 22397 , 22409 , 22433 , 22441 , 22447 , 22453 , 22469 , 22481 , 22483 , 22501 , 22511 , 22531 , 22541 , 22543 , 22549 , 22567 , 22571 , 22573 , 22613 , 22619 , 22621 , 22637 , 22639 , 22643 , 22651 , 22669 , 22679 , 22691 , 22697 , 22699 , 22709 , 22717 , 22721 , 22727 , 22739 , 22741 , 22751 , 22769 , 22777 , 22783 , 22787 , 22807 , 22811 , 22817 , 22853 , 22859 , 22861 , 22871 , 22877 , 22901 , 22907 , 22921 , 22937 , 22943 , 22961 , 22963 , 22973 , 22993 , 23003 , 23011 , 23017 , 23021 , 23027 , 23029 , 23039 , 23041 , 23053 , 23057 , 23059 , 23063 , 23071 , 23081 , 23087 , 23099 , 23117 , 23131 , 23143 , 23159 , 23167 , 23173 , 23189 , 23197 , 23201 , 23203 , 23209 , 23227 , 23251 , 23269 , 23279 , 23291 , 23293 , 23297 , 23311 , 23321 , 23327 , 23333 , 23339 , 23357 , 23369 , 23371 , 23399 , 23417 , 23431 , 23447 , 23459 , 23473 , 23497 , 23509 , 23531 , 23537 , 23539 , 23549 , 23557 , 23561 , 23563 , 23567 , 23581 , 23593 , 23599 , 23603 , 23609 , 23623 , 23627 , 23629 , 23633 , 23663 , 23669 , 23671 , 23677 , 23687 , 23689 , 23719 , 23741 , 23743 , 23747 , 23753 , 23761 , 23767 , 23773 , 23789 , 23801 , 23813 , 23819 , 23827 , 23831 , 23833 , 23857 , 23869 , 23873 , 23879 , 23887 , 23893 , 23899 , 23909 , 23911 , 23917 , 23929 , 23957 , 23971 , 23977 , 23981 , 23993 , 24001 , 24007 , 24019 , 24023 , 24029 , 24043 , 24049 , 24061 , 24071 , 24077 , 24083 , 24091 , 24097 , 24103 , 24107 , 24109 , 24113 , 24121 , 24133 , 24137 , 24151 , 24169 , 24179 , 24181 , 24197 , 24203 , 24223 , 24229 , 24239 , 24247 , 24251 , 24281 , 24317 , 24329 , 24337 , 24359 , 24371 , 24373 , 24379 , 24391 , 24407 , 24413 , 24419 , 24421 , 24439 , 24443 , 24469 , 24473 , 24481 , 24499 , 24509 , 24517 , 24527 , 24533 , 24547 , 24551 , 24571 , 24593 , 24611 , 24623 , 24631 , 24659 , 24671 , 24677 , 24683 , 24691 , 24697 , 24709 , 24733 , 24749 , 24763 , 24767 , 24781 , 24793 , 24799 , 24809 , 24821 , 24841 , 24847 , 24851 , 24859 , 24877 , 24889 , 24907 , 24917 , 24919 , 24923 , 24943 , 24953 , 24967 , 24971 , 24977 , 24979 , 24989 , 25013 , 25031 , 25033 , 25037 , 25057 , 25073 , 25087 , 25097 , 25111 , 25117 , 25121 , 25127 , 25147 , 25153 , 25163 , 25169 , 25171 , 25183 , 25189 , 25219 , 25229 , 25237 , 25243 , 25247 , 25253 , 25261 , 25301 , 25303 , 25307 , 25309 , 25321 , 25339 , 25343 , 25349 , 25357 , 25367 , 25373 , 25391 , 25409 , 25411 , 25423 , 25439 , 25447 , 25453 , 25457 , 25463 , 25469 , 25471 , 25523 , 25537 , 25541 , 25561 , 25577 , 25579 , 25583 , 25589 , 25601 , 25603 , 25609 , 25621 , 25633 , 25639 , 25643 , 25657 , 25667 , 25673 , 25679 , 25693 , 25703 , 25717 , 25733 , 25741 , 25747 , 25759 , 25763 , 25771 , 25793 , 25799 , 25801 , 25819 , 25841 , 25847 , 25849 , 25867 , 25873 , 25889 , 25903 , 25913 , 25919 , 25931 , 25933 , 25939 , 25943 , 25951 , 25969 , 25981 , 25997 , 25999 , 26003 , 26017 , 26021 , 26029 , 26041 , 26053 , 26083 , 26099 , 26107 , 26111 , 26113 , 26119 , 26141 , 26153 , 26161 , 26171 , 26177 , 26183 , 26189 , 26203 , 26209 , 26227 , 26237 , 26249 , 26251 , 26261 , 26263 , 26267 , 26293 , 26297 , 26309 , 26317 , 26321 , 26339 , 26347 , 26357 , 26371 , 26387 , 26393 , 26399 , 26407 , 26417 , 26423 , 26431 , 26437 , 26449 , 26459 , 26479 , 26489 , 26497 , 26501 , 26513 , 26539 , 26557 , 26561 , 26573 , 26591 , 26597 , 26627 , 26633 , 26641 , 26647 , 26669 , 26681 , 26683 , 26687 , 26693 , 26699 , 26701 , 26711 , 26713 , 26717 , 26723 , 26729 , 26731 , 26737 , 26759 , 26777 , 26783 , 26801 , 26813 , 26821 , 26833 , 26839 , 26849 , 26861 , 26863 , 26879 , 26881 , 26891 , 26893 , 26903 , 26921 , 26927 , 26947 , 26951 , 26953 , 26959 , 26981 , 26987 , 26993 , 27011 , 27017 , 27031 , 27043 , 27059 , 27061 , 27067 , 27073 , 27077 , 27091 , 27103 , 27107 , 27109 , 27127 , 27143 , 27179 , 27191 , 27197 , 27211 , 27239 , 27241 , 27253 , 27259 , 27271 , 27277 , 27281 , 27283 , 27299 , 27329 , 27337 , 27361 , 27367 , 27397 , 27407 , 27409 , 27427 , 27431 , 27437 , 27449 , 27457 , 27479 , 27481 , 27487 , 27509 , 27527 , 27529 , 27539 , 27541 , 27551 , 27581 , 27583 , 27611 , 27617 , 27631 , 27647 , 27653 , 27673 , 27689 , 27691 , 27697 , 27701 , 27733 , 27737 , 27739 , 27743 , 27749 , 27751 , 27763 , 27767 , 27773 , 27779 , 27791 , 27793 , 27799 , 27803 , 27809 , 27817 , 27823 , 27827 , 27847 , 27851 , 27883 , 27893 , 27901 , 27917 , 27919 , 27941 , 27943 , 27947 , 27953 , 27961 , 27967 , 27983 , 27997 , 28001 , 28019 , 28027 , 28031 , 28051 , 28057 , 28069 , 28081 , 28087 , 28097 , 28099 , 28109 , 28111 , 28123 , 28151 , 28163 , 28181 , 28183 , 28201 , 28211 , 28219 , 28229 , 28277 , 28279 , 28283 , 28289 , 28297 , 28307 , 28309 , 28319 , 28349 , 28351 , 28387 , 28393 , 28403 , 28409 , 28411 , 28429 , 28433 , 28439 , 28447 , 28463 , 28477 , 28493 , 28499 , 28513 , 28517 , 28537 , 28541 , 28547 , 28549 , 28559 , 28571 , 28573 , 28579 , 28591 , 28597 , 28603 , 28607 , 28619 , 28621 , 28627 , 28631 , 28643 , 28649 , 28657 , 28661 , 28663 , 28669 , 28687 , 28697 , 28703 , 28711 , 28723 , 28729 , 28751 , 28753 , 28759 , 28771 , 28789 , 28793 , 28807 , 28813 , 28817 , 28837 , 28843 , 28859 , 28867 , 28871 , 28879 , 28901 , 28909 , 28921 , 28927 , 28933 , 28949 , 28961 , 28979 , 29009 , 29017 , 29021 , 29023 , 29027 , 29033 , 29059 , 29063 , 29077 , 29101 , 29123 , 29129 , 29131 , 29137 , 29147 , 29153 , 29167 , 29173 , 29179 , 29191 , 29201 , 29207 , 29209 , 29221 , 29231 , 29243 , 29251 , 29269 , 29287 , 29297 , 29303 , 29311 , 29327 , 29333 , 29339 , 29347 , 29363 , 29383 , 29387 , 29389 , 29399 , 29401 , 29411 , 29423 , 29429 , 29437 , 29443 , 29453 , 29473 , 29483 , 29501 , 29527 , 29531 , 29537 , 29567 , 29569 , 29573 , 29581 , 29587 , 29599 , 29611 , 29629 , 29633 , 29641 , 29663 , 29669 , 29671 , 29683 , 29717 , 29723 , 29741 , 29753 , 29759 , 29761 , 29789 , 29803 , 29819 , 29833 , 29837 , 29851 , 29863 , 29867 , 29873 , 29879 , 29881 , 29917 , 29921 , 29927 , 29947 , 29959 , 29983 , 29989 , 30011 , 30013 , 30029 , 30047 , 30059 , 30071 , 30089 , 30091 , 30097 , 30103 , 30109 , 30113 , 30119 , 30133 , 30137 , 30139 , 30161 , 30169 , 30181 , 30187 , 30197 , 30203 , 30211 , 30223 , 30241 , 30253 , 30259 , 30269 , 30271 , 30293 , 30307 , 30313 , 30319 , 30323 , 30341 , 30347 , 30367 , 30389 , 30391 , 30403 , 30427 , 30431 , 30449 , 30467 , 30469 , 30491 , 30493 , 30497 , 30509 , 30517 , 30529 , 30539 , 30553 , 30557 , 30559 , 30577 , 30593 , 30631 , 30637 , 30643 , 30649 , 30661 , 30671 , 30677 , 30689 , 30697 , 30703 , 30707 , 30713 , 30727 , 30757 , 30763 , 30773 , 30781 , 30803 , 30809 , 30817 , 30829 , 30839 , 30841 , 30851 , 30853 , 30859 , 30869 , 30871 , 30881 , 30893 , 30911 , 30931 , 30937 , 30941 , 30949 , 30971 , 30977 , 30983 , 31013 , 31019 , 31033 , 31039 , 31051 , 31063 , 31069 , 31079 , 31081 , 31091 , 31121 , 31123 , 31139 , 31147 , 31151 , 31153 , 31159 , 31177 , 31181 , 31183 , 31189 , 31193 , 31219 , 31223 , 31231 , 31237 , 31247 , 31249 , 31253 , 31259 , 31267 , 31271 , 31277 , 31307 , 31319 , 31321 , 31327 , 31333 , 31337 , 31357 , 31379 , 31387 , 31391 , 31393 , 31397 , 31469 , 31477 , 31481 , 31489 , 31511 , 31513 , 31517 , 31531 , 31541 , 31543 , 31547 , 31567 , 31573 , 31583 , 31601 , 31607 , 31627 , 31643 , 31649 , 31657 , 31663 , 31667 , 31687 , 31699 , 31721 , 31723 , 31727 , 31729 , 31741 , 31751 , 31769 , 31771 , 31793 , 31799 , 31817 , 31847 , 31849 , 31859 , 31873 , 31883 , 31891 , 31907 , 31957 , 31963 , 31973 , 31981 , 31991 , 32003 , 32009 , 32027 , 32029 , 32051 , 32057 , 32059 , 32063 , 32069 , 32077 , 32083 , 32089 , 32099 , 32117 , 32119 , 32141 , 32143 , 32159 , 32173 , 32183 , 32189 , 32191 , 32203 , 32213 , 32233 , 32237 , 32251 , 32257 , 32261 , 32297 , 32299 , 32303 , 32309 , 32321 , 32323 , 32327 , 32341 , 32353 , 32359 , 32363 , 32369 , 32371 , 32377 , 32381 , 32401 , 32411 , 32413 , 32423 , 32429 , 32441 , 32443 , 32467 , 32479 , 32491 , 32497 , 32503 , 32507 , 32531 , 32533 , 32537 , 32561 , 32563 , 32569 , 32573 , 32579 , 32587 , 32603 , 32609 , 32611 , 32621 , 32633 , 32647 , 32653 , 32687 , 32693 , 32707 , 32713 , 32717 , 32719 , 32749 , 32771 , 32779 , 32783 , 32789 , 32797 , 32801 , 32803 , 32831 , 32833 , 32839 , 32843 , 32869 , 32887 , 32909 , 32911 , 32917 , 32933 , 32939 , 32941 , 32957 , 32969 , 32971 , 32983 , 32987 , 32993 , 32999 , 33013 , 33023 , 33029 , 33037 , 33049 , 33053 , 33071 , 33073 , 33083 , 33091 , 33107 , 33113 , 33119 , 33149 , 33151 , 33161 , 33179 , 33181 , 33191 , 33199 , 33203 , 33211 , 33223 , 33247 , 33287 , 33289 , 33301 , 33311 , 33317 , 33329 , 33331 , 33343 , 33347 , 33349 , 33353 , 33359 , 33377 , 33391 , 33403 , 33409 , 33413 , 33427 , 33457 , 33461 , 33469 , 33479 , 33487 , 33493 , 33503 , 33521 , 33529 , 33533 , 33547 , 33563 , 33569 , 33577 , 33581 , 33587 , 33589 , 33599 , 33601 , 33613 , 33617 , 33619 , 33623 , 33629 , 33637 , 33641 , 33647 , 33679 , 33703 , 33713 , 33721 , 33739 , 33749 , 33751 , 33757 , 33767 , 33769 , 33773 , 33791 , 33797 , 33809 , 33811 , 33827 , 33829 , 33851 , 33857 , 33863 , 33871 , 33889 , 33893 , 33911 , 33923 , 33931 , 33937 , 33941 , 33961 , 33967 , 33997 , 34019 , 34031 , 34033 , 34039 , 34057 , 34061 , 34123 , 34127 , 34129 , 34141 , 34147 , 34157 , 34159 , 34171 , 34183 , 34211 , 34213 , 34217 , 34231 , 34253 , 34259 , 34261 , 34267 , 34273 , 34283 , 34297 , 34301 , 34303 , 34313 , 34319 , 34327 , 34337 , 34351 , 34361 , 34367 , 34369 , 34381 , 34403 , 34421 , 34429 , 34439 , 34457 , 34469 , 34471 , 34483 , 34487 , 34499 , 34501 , 34511 , 34513 , 34519 , 34537 , 34543 , 34549 , 34583 , 34589 , 34591 , 34603 , 34607 , 34613 , 34631 , 34649 , 34651 , 34667 , 34673 , 34679 , 34687 , 34693 , 34703 , 34721 , 34729 , 34739 , 34747 , 34757 , 34759 , 34763 , 34781 , 34807 , 34819 , 34841 , 34843 , 34847 , 34849 , 34871 , 34877 , 34883 , 34897 , 34913 , 34919 , 34939 , 34949 , 34961 , 34963 , 34981 , 35023 , 35027 , 35051 , 35053 , 35059 , 35069 , 35081 , 35083 , 35089 , 35099 , 35107 , 35111 , 35117 , 35129 , 35141 , 35149 , 35153 , 35159 , 35171 , 35201 , 35221 , 35227 , 35251 , 35257 , 35267 , 35279 , 35281 , 35291 , 35311 , 35317 , 35323 , 35327 , 35339 , 35353 , 35363 , 35381 , 35393 , 35401 , 35407 , 35419 , 35423 , 35437 , 35447 , 35449 , 35461 , 35491 , 35507 , 35509 , 35521 , 35527 , 35531 , 35533 , 35537 , 35543 , 35569 , 35573 , 35591 , 35593 , 35597 , 35603 , 35617 , 35671 , 35677 , 35729 , 35731 , 35747 , 35753 , 35759 , 35771 , 35797 , 35801 , 35803 , 35809 , 35831 , 35837 , 35839 , 35851 , 35863 , 35869 , 35879 , 35897 , 35899 , 35911 , 35923 , 35933 , 35951 , 35963 , 35969 , 35977 , 35983 , 35993 , 35999 , 36007 , 36011 , 36013 , 36017 , 36037 , 36061 , 36067 , 36073 , 36083 , 36097 , 36107 , 36109 , 36131 , 36137 , 36151 , 36161 , 36187 , 36191 , 36209 , 36217 , 36229 , 36241 , 36251 , 36263 , 36269 , 36277 , 36293 , 36299 , 36307 , 36313 , 36319 , 36341 , 36343 , 36353 , 36373 , 36383 , 36389 , 36433 , 36451 , 36457 , 36467 , 36469 , 36473 , 36479 , 36493 , 36497 , 36523 , 36527 , 36529 , 36541 , 36551 , 36559 , 36563 , 36571 , 36583 , 36587 , 36599 , 36607 , 36629 , 36637 , 36643 , 36653 , 36671 , 36677 , 36683 , 36691 , 36697 , 36709 , 36713 , 36721 , 36739 , 36749 , 36761 , 36767 , 36779 , 36781 , 36787 , 36791 , 36793 , 36809 , 36821 , 36833 , 36847 , 36857 , 36871 , 36877 , 36887 , 36899 , 36901 , 36913 , 36919 , 36923 , 36929 , 36931 , 36943 , 36947 , 36973 , 36979 , 36997 , 37003 , 37013 , 37019 , 37021 , 37039 , 37049 , 37057 , 37061 , 37087 , 37097 , 37117 , 37123 , 37139 , 37159 , 37171 , 37181 , 37189 , 37199 , 37201 , 37217 , 37223 , 37243 , 37253 , 37273 , 37277 , 37307 , 37309 , 37313 , 37321 , 37337 , 37339 , 37357 , 37361 , 37363 , 37369 , 37379 , 37397 , 37409 , 37423 , 37441 , 37447 , 37463 , 37483 , 37489 , 37493 , 37501 , 37507 , 37511 , 37517 , 37529 , 37537 , 37547 , 37549 , 37561 , 37567 , 37571 , 37573 , 37579 , 37589 , 37591 , 37607 , 37619 , 37633 , 37643 , 37649 , 37657 , 37663 , 37691 , 37693 , 37699 , 37717 , 37747 , 37781 , 37783 , 37799 , 37811 , 37813 , 37831 , 37847 , 37853 , 37861 , 37871 , 37879 , 37889 , 37897 , 37907 , 37951 , 37957 , 37963 , 37967 , 37987 , 37991 , 37993 , 37997 , 38011 , 38039 , 38047 , 38053 , 38069 , 38083 , 38113 , 38119 , 38149 , 38153 , 38167 , 38177 , 38183 , 38189 , 38197 , 38201 , 38219 , 38231 , 38237 , 38239 , 38261 , 38273 , 38281 , 38287 , 38299 , 38303 , 38317 , 38321 , 38327 , 38329 , 38333 , 38351 , 38371 , 38377 , 38393 , 38431 , 38447 , 38449 , 38453 , 38459 , 38461 , 38501 , 38543 , 38557 , 38561 , 38567 , 38569 , 38593 , 38603 , 38609 , 38611 , 38629 , 38639 , 38651 , 38653 , 38669 , 38671 , 38677 , 38693 , 38699 , 38707 , 38711 , 38713 , 38723 , 38729 , 38737 , 38747 , 38749 , 38767 , 38783 , 38791 , 38803 , 38821 , 38833 , 38839 , 38851 , 38861 , 38867 , 38873 , 38891 , 38903 , 38917 , 38921 , 38923 , 38933 , 38953 , 38959 , 38971 , 38977 , 38993 , 39019 , 39023 , 39041 , 39043 , 39047 , 39079 , 39089 , 39097 , 39103 , 39107 , 39113 , 39119 , 39133 , 39139 , 39157 , 39161 , 39163 , 39181 , 39191 , 39199 , 39209 , 39217 , 39227 , 39229 , 39233 , 39239 , 39241 , 39251 , 39293 , 39301 , 39313 , 39317 , 39323 , 39341 , 39343 , 39359 , 39367 , 39371 , 39373 , 39383 , 39397 , 39409 , 39419 , 39439 , 39443 , 39451 , 39461 , 39499 , 39503 , 39509 , 39511 , 39521 , 39541 , 39551 , 39563 , 39569 , 39581 , 39607 , 39619 , 39623 , 39631 , 39659 , 39667 , 39671 , 39679 , 39703 , 39709 , 39719 , 39727 , 39733 , 39749 , 39761 , 39769 , 39779 , 39791 , 39799 , 39821 , 39827 , 39829 , 39839 , 39841 , 39847 , 39857 , 39863 , 39869 , 39877 , 39883 , 39887 , 39901 , 39929 , 39937 , 39953 , 39971 , 39979 , 39983 , 39989 , 40009 , 40013 , 40031 , 40037 , 40039 , 40063 , 40087 , 40093 , 40099 , 40111 , 40123 , 40127 , 40129 , 40151 , 40153 , 40163 , 40169 , 40177 , 40189 , 40193 , 40213 , 40231 , 40237 , 40241 , 40253 , 40277 , 40283 , 40289 , 40343 , 40351 , 40357 , 40361 , 40387 , 40423 , 40427 , 40429 , 40433 , 40459 , 40471 , 40483 , 40487 , 40493 , 40499 , 40507 , 40519 , 40529 , 40531 , 40543 , 40559 , 40577 , 40583 , 40591 , 40597 , 40609 , 40627 , 40637 , 40639 , 40693 , 40697 , 40699 , 40709 , 40739 , 40751 , 40759 , 40763 , 40771 , 40787 , 40801 , 40813 , 40819 , 40823 , 40829 , 40841 , 40847 , 40849 , 40853 , 40867 , 40879 , 40883 , 40897 , 40903 , 40927 , 40933 , 40939 , 40949 , 40961 , 40973 , 40993 , 41011 , 41017 , 41023 , 41039 , 41047 , 41051 , 41057 , 41077 , 41081 , 41113 , 41117 , 41131 , 41141 , 41143 , 41149 , 41161 , 41177 , 41179 , 41183 , 41189 , 41201 , 41203 , 41213 , 41221 , 41227 , 41231 , 41233 , 41243 , 41257 , 41263 , 41269 , 41281 , 41299 , 41333 , 41341 , 41351 , 41357 , 41381 , 41387 , 41389 , 41399 , 41411 , 41413 , 41443 , 41453 , 41467 , 41479 , 41491 , 41507 , 41513 , 41519 , 41521 , 41539 , 41543 , 41549 , 41579 , 41593 , 41597 , 41603 , 41609 , 41611 , 41617 , 41621 , 41627 , 41641 , 41647 , 41651 , 41659 , 41669 , 41681 , 41687 , 41719 , 41729 , 41737 , 41759 , 41761 , 41771 , 41777 , 41801 , 41809 , 41813 , 41843 , 41849 , 41851 , 41863 , 41879 , 41887 , 41893 , 41897 , 41903 , 41911 , 41927 , 41941 , 41947 , 41953 , 41957 , 41959 , 41969 , 41981 , 41983 , 41999 , 42013 , 42017 , 42019 , 42023 , 42043 , 42061 , 42071 , 42073 , 42083 , 42089 , 42101 , 42131 , 42139 , 42157 , 42169 , 42179 , 42181 , 42187 , 42193 , 42197 , 42209 , 42221 , 42223 , 42227 , 42239 , 42257 , 42281 , 42283 , 42293 , 42299 , 42307 , 42323 , 42331 , 42337 , 42349 , 42359 , 42373 , 42379 , 42391 , 42397 , 42403 , 42407 , 42409 , 42433 , 42437 , 42443 , 42451 , 42457 , 42461 , 42463 , 42467 , 42473 , 42487 , 42491 , 42499 , 42509 , 42533 , 42557 , 42569 , 42571 , 42577 , 42589 , 42611 , 42641 , 42643 , 42649 , 42667 , 42677 , 42683 , 42689 , 42697 , 42701 , 42703 , 42709 , 42719 , 42727 , 42737 , 42743 , 42751 , 42767 , 42773 , 42787 , 42793 , 42797 , 42821 , 42829 , 42839 , 42841 , 42853 , 42859 , 42863 , 42899 , 42901 , 42923 , 42929 , 42937 , 42943 , 42953 , 42961 , 42967 , 42979 , 42989 , 43003 , 43013 , 43019 , 43037 , 43049 , 43051 , 43063 , 43067 , 43093 , 43103 , 43117 , 43133 , 43151 , 43159 , 43177 , 43189 , 43201 , 43207 , 43223 , 43237 , 43261 , 43271 , 43283 , 43291 , 43313 , 43319 , 43321 , 43331 , 43391 , 43397 , 43399 , 43403 , 43411 , 43427 , 43441 , 43451 , 43457 , 43481 , 43487 , 43499 , 43517 , 43541 , 43543 , 43573 , 43577 , 43579 , 43591 , 43597 , 43607 , 43609 , 43613 , 43627 , 43633 , 43649 , 43651 , 43661 , 43669 , 43691 , 43711 , 43717 , 43721 , 43753 , 43759 , 43777 , 43781 , 43783 , 43787 , 43789 , 43793 , 43801 , 43853 , 43867 , 43889 , 43891 , 43913 , 43933 , 43943 , 43951 , 43961 , 43963 , 43969 , 43973 , 43987 , 43991 , 43997 , 44017 , 44021 , 44027 , 44029 , 44041 , 44053 , 44059 , 44071 , 44087 , 44089 , 44101 , 44111 , 44119 , 44123 , 44129 , 44131 , 44159 , 44171 , 44179 , 44189 , 44201 , 44203 , 44207 , 44221 , 44249 , 44257 , 44263 , 44267 , 44269 , 44273 , 44279 , 44281 , 44293 , 44351 , 44357 , 44371 , 44381 , 44383 , 44389 , 44417 , 44449 , 44453 , 44483 , 44491 , 44497 , 44501 , 44507 , 44519 , 44531 , 44533 , 44537 , 44543 , 44549 , 44563 , 44579 , 44587 , 44617 , 44621 , 44623 , 44633 , 44641 , 44647 , 44651 , 44657 , 44683 , 44687 , 44699 , 44701 , 44711 , 44729 , 44741 , 44753 , 44771 , 44773 , 44777 , 44789 , 44797 , 44809 , 44819 , 44839 , 44843 , 44851 , 44867 , 44879 , 44887 , 44893 , 44909 , 44917 , 44927 , 44939 , 44953 , 44959 , 44963 , 44971 , 44983 , 44987 , 45007 , 45013 , 45053 , 45061 , 45077 , 45083 , 45119 , 45121 , 45127 , 45131 , 45137 , 45139 , 45161 , 45179 , 45181 , 45191 , 45197 , 45233 , 45247 , 45259 , 45263 , 45281 , 45289 , 45293 , 45307 , 45317 , 45319 , 45329 , 45337 , 45341 , 45343 , 45361 , 45377 , 45389 , 45403 , 45413 , 45427 , 45433 , 45439 , 45481 , 45491 , 45497 , 45503 , 45523 , 45533 , 45541 , 45553 , 45557 , 45569 , 45587 , 45589 , 45599 , 45613 , 45631 , 45641 , 45659 , 45667 , 45673 , 45677 , 45691 , 45697 , 45707 , 45737 , 45751 , 45757 , 45763 , 45767 , 45779 , 45817 , 45821 , 45823 , 45827 , 45833 , 45841 , 45853 , 45863 , 45869 , 45887 , 45893 , 45943 , 45949 , 45953 , 45959 , 45971 , 45979 , 45989 , 46021 , 46027 , 46049 , 46051 , 46061 , 46073 , 46091 , 46093 , 46099 , 46103 , 46133 , 46141 , 46147 , 46153 , 46171 , 46181 , 46183 , 46187 , 46199 , 46219 , 46229 , 46237 , 46261 , 46271 , 46273 , 46279 , 46301 , 46307 , 46309 , 46327 , 46337 , 46349 , 46351 , 46381 , 46399 , 46411 , 46439 , 46441 , 46447 , 46451 , 46457 , 46471 , 46477 , 46489 , 46499 , 46507 , 46511 , 46523 , 46549 , 46559 , 46567 , 46573 , 46589 , 46591 , 46601 , 46619 , 46633 , 46639 , 46643 , 46649 , 46663 , 46679 , 46681 , 46687 , 46691 , 46703 , 46723 , 46727 , 46747 , 46751 , 46757 , 46769 , 46771 , 46807 , 46811 , 46817 , 46819 , 46829 , 46831 , 46853 , 46861 , 46867 , 46877 , 46889 , 46901 , 46919 , 46933 , 46957 , 46993 , 46997 , 47017 , 47041 , 47051 , 47057 , 47059 , 47087 , 47093 , 47111 , 47119 , 47123 , 47129 , 47137 , 47143 , 47147 , 47149 , 47161 , 47189 , 47207 , 47221 , 47237 , 47251 , 47269 , 47279 , 47287 , 47293 , 47297 , 47303 , 47309 , 47317 , 47339 , 47351 , 47353 , 47363 , 47381 , 47387 , 47389 , 47407 , 47417 , 47419 , 47431 , 47441 , 47459 , 47491 , 47497 , 47501 , 47507 , 47513 , 47521 , 47527 , 47533 , 47543 , 47563 , 47569 , 47581 , 47591 , 47599 , 47609 , 47623 , 47629 , 47639 , 47653 , 47657 , 47659 , 47681 , 47699 , 47701 , 47711 , 47713 , 47717 , 47737 , 47741 , 47743 , 47777 , 47779 , 47791 , 47797 , 47807 , 47809 , 47819 , 47837 , 47843 , 47857 , 47869 , 47881 , 47903 , 47911 , 47917 , 47933 , 47939 , 47947 , 47951 , 47963 , 47969 , 47977 , 47981 , 48017 , 48023 , 48029 , 48049 , 48073 , 48079 , 48091 , 48109 , 48119 , 48121 , 48131 , 48157 , 48163 , 48179 , 48187 , 48193 , 48197 , 48221 , 48239 , 48247 , 48259 , 48271 , 48281 , 48299 , 48311 , 48313 , 48337 , 48341 , 48353 , 48371 , 48383 , 48397 , 48407 , 48409 , 48413 , 48437 , 48449 , 48463 , 48473 , 48479 , 48481 , 48487 , 48491 , 48497 , 48523 , 48527 , 48533 , 48539 , 48541 , 48563 , 48571 , 48589 , 48593 , 48611 , 48619 , 48623 , 48647 , 48649 , 48661 , 48673 , 48677 , 48679 , 48731 , 48733 , 48751 , 48757 , 48761 , 48767 , 48779 , 48781 , 48787 , 48799 , 48809 , 48817 , 48821 , 48823 , 48847 , 48857 , 48859 , 48869 , 48871 , 48883 , 48889 , 48907 , 48947 , 48953 , 48973 , 48989 , 48991 , 49003 , 49009 , 49019 , 49031 , 49033 , 49037 , 49043 , 49057 , 49069 , 49081 , 49103 , 49109 , 49117 , 49121 , 49123 , 49139 , 49157 , 49169 , 49171 , 49177 , 49193 , 49199 , 49201 , 49207 , 49211 , 49223 , 49253 , 49261 , 49277 , 49279 , 49297 , 49307 , 49331 , 49333 , 49339 , 49363 , 49367 , 49369 , 49391 , 49393 , 49409 , 49411 , 49417 , 49429 , 49433 , 49451 , 49459 , 49463 , 49477 , 49481 , 49499 , 49523 , 49529 , 49531 , 49537 , 49547 , 49549 , 49559 , 49597 , 49603 , 49613 , 49627 , 49633 , 49639 , 49663 , 49667 , 49669 , 49681 , 49697 , 49711 , 49727 , 49739 , 49741 , 49747 , 49757 , 49783 , 49787 , 49789 , 49801 , 49807 , 49811 , 49823 , 49831 , 49843 , 49853 , 49871 , 49877 , 49891 , 49919 , 49921 , 49927 , 49937 , 49939 , 49943 , 49957 , 49991 , 49993 , 49999 , 50021 , 50023 , 50033 , 50047 , 50051 , 50053 , 50069 , 50077 , 50087 , 50093 , 50101 , 50111 , 50119 , 50123 , 50129 , 50131 , 50147 , 50153 , 50159 , 50177 , 50207 , 50221 , 50227 , 50231 , 50261 , 50263 , 50273 , 50287 , 50291 , 50311 , 50321 , 50329 , 50333 , 50341 , 50359 , 50363 , 50377 , 50383 , 50387 , 50411 , 50417 , 50423 , 50441 , 50459 , 50461 , 50497 , 50503 , 50513 , 50527 , 50539 , 50543 , 50549 , 50551 , 50581 , 50587 , 50591 , 50593 , 50599 , 50627 , 50647 , 50651 , 50671 , 50683 , 50707 , 50723 , 50741 , 50753 , 50767 , 50773 , 50777 , 50789 , 50821 , 50833 , 50839 , 50849 , 50857 , 50867 , 50873 , 50891 , 50893 , 50909 , 50923 , 50929 , 50951 , 50957 , 50969 , 50971 , 50989 , 50993 , 51001 , 51031 , 51043 , 51047 , 51059 , 51061 , 51071 , 51109 , 51131 , 51133 , 51137 , 51151 , 51157 , 51169 , 51193 , 51197 , 51199 , 51203 , 51217 , 51229 , 51239 , 51241 , 51257 , 51263 , 51283 , 51287 , 51307 , 51329 , 51341 , 51343 , 51347 , 51349 , 51361 , 51383 , 51407 , 51413 , 51419 , 51421 , 51427 , 51431 , 51437 , 51439 , 51449 , 51461 , 51473 , 51479 , 51481 , 51487 , 51503 , 51511 , 51517 , 51521 , 51539 , 51551 , 51563 , 51577 , 51581 , 51593 , 51599 , 51607 , 51613 , 51631 , 51637 , 51647 , 51659 , 51673 , 51679 , 51683 , 51691 , 51713 , 51719 , 51721 , 51749 , 51767 , 51769 , 51787 , 51797 , 51803 , 51817 , 51827 , 51829 , 51839 , 51853 , 51859 , 51869 , 51871 , 51893 , 51899 , 51907 , 51913 , 51929 , 51941 , 51949 , 51971 , 51973 , 51977 , 51991 , 52009 , 52021 , 52027 , 52051 , 52057 , 52067 , 52069 , 52081 , 52103 , 52121 , 52127 , 52147 , 52153 , 52163 , 52177 , 52181 , 52183 , 52189 , 52201 , 52223 , 52237 , 52249 , 52253 , 52259 , 52267 , 52289 , 52291 , 52301 , 52313 , 52321 , 52361 , 52363 , 52369 , 52379 , 52387 , 52391 , 52433 , 52453 , 52457 , 52489 , 52501 , 52511 , 52517 , 52529 , 52541 , 52543 , 52553 , 52561 , 52567 , 52571 , 52579 , 52583 , 52609 , 52627 , 52631 , 52639 , 52667 , 52673 , 52691 , 52697 , 52709 , 52711 , 52721 , 52727 , 52733 , 52747 , 52757 , 52769 , 52783 , 52807 , 52813 , 52817 , 52837 , 52859 , 52861 , 52879 , 52883 , 52889 , 52901 , 52903 , 52919 , 52937 , 52951 , 52957 , 52963 , 52967 , 52973 , 52981 , 52999 , 53003 , 53017 , 53047 , 53051 , 53069 , 53077 , 53087 , 53089 , 53093 , 53101 , 53113 , 53117 , 53129 , 53147 , 53149 , 53161 , 53171 , 53173 , 53189 , 53197 , 53201 , 53231 , 53233 , 53239 , 53267 , 53269 , 53279 , 53281 , 53299 , 53309 , 53323 , 53327 , 53353 , 53359 , 53377 , 53381 , 53401 , 53407 , 53411 , 53419 , 53437 , 53441 , 53453 , 53479 , 53503 , 53507 , 53527 , 53549 , 53551 , 53569 , 53591 , 53593 , 53597 , 53609 , 53611 , 53617 , 53623 , 53629 , 53633 , 53639 , 53653 , 53657 , 53681 , 53693 , 53699 , 53717 , 53719 , 53731 , 53759 , 53773 , 53777 , 53783 , 53791 , 53813 , 53819 , 53831 , 53849 , 53857 , 53861 , 53881 , 53887 , 53891 , 53897 , 53899 , 53917 , 53923 , 53927 , 53939 , 53951 , 53959 , 53987 , 53993 , 54001 , 54011 , 54013 , 54037 , 54049 , 54059 , 54083 , 54091 , 54101 , 54121 , 54133 , 54139 , 54151 , 54163 , 54167 , 54181 , 54193 , 54217 , 54251 , 54269 , 54277 , 54287 , 54293 , 54311 , 54319 , 54323 , 54331 , 54347 , 54361 , 54367 , 54371 , 54377 , 54401 , 54403 , 54409 , 54413 , 54419 , 54421 , 54437 , 54443 , 54449 , 54469 , 54493 , 54497 , 54499 , 54503 , 54517 , 54521 , 54539 , 54541 , 54547 , 54559 , 54563 , 54577 , 54581 , 54583 , 54601 , 54617 , 54623 , 54629 , 54631 , 54647 , 54667 , 54673 , 54679 , 54709 , 54713 , 54721 , 54727 , 54751 , 54767 , 54773 , 54779 , 54787 , 54799 , 54829 , 54833 , 54851 , 54869 , 54877 , 54881 , 54907 , 54917 , 54919 , 54941 , 54949 , 54959 , 54973 , 54979 , 54983 , 55001 , 55009 , 55021 , 55049 , 55051 , 55057 , 55061 , 55073 , 55079 , 55103 , 55109 , 55117 , 55127 , 55147 , 55163 , 55171 , 55201 , 55207 , 55213 , 55217 , 55219 , 55229 , 55243 , 55249 , 55259 , 55291 , 55313 , 55331 , 55333 , 55337 , 55339 , 55343 , 55351 , 55373 , 55381 , 55399 , 55411 , 55439 , 55441 , 55457 , 55469 , 55487 , 55501 , 55511 , 55529 , 55541 , 55547 , 55579 , 55589 , 55603 , 55609 , 55619 , 55621 , 55631 , 55633 , 55639 , 55661 , 55663 , 55667 , 55673 , 55681 , 55691 , 55697 , 55711 , 55717 , 55721 , 55733 , 55763 , 55787 , 55793 , 55799 , 55807 , 55813 , 55817 , 55819 , 55823 , 55829 , 55837 , 55843 , 55849 , 55871 , 55889 , 55897 , 55901 , 55903 , 55921 , 55927 , 55931 , 55933 , 55949 , 55967 , 55987 , 55997 , 56003 , 56009 , 56039 , 56041 , 56053 , 56081 , 56087 , 56093 , 56099 , 56101 , 56113 , 56123 , 56131 , 56149 , 56167 , 56171 , 56179 , 56197 , 56207 , 56209 , 56237 , 56239 , 56249 , 56263 , 56267 , 56269 , 56299 , 56311 , 56333 , 56359 , 56369 , 56377 , 56383 , 56393 , 56401 , 56417 , 56431 , 56437 , 56443 , 56453 , 56467 , 56473 , 56477 , 56479 , 56489 , 56501 , 56503 , 56509 , 56519 , 56527 , 56531 , 56533 , 56543 , 56569 , 56591 , 56597 , 56599 , 56611 , 56629 , 56633 , 56659 , 56663 , 56671 , 56681 , 56687 , 56701 , 56711 , 56713 , 56731 , 56737 , 56747 , 56767 , 56773 , 56779 , 56783 , 56807 , 56809 , 56813 , 56821 , 56827 , 56843 , 56857 , 56873 , 56891 , 56893 , 56897 , 56909 , 56911 , 56921 , 56923 , 56929 , 56941 , 56951 , 56957 , 56963 , 56983 , 56989 , 56993 , 56999 , 57037 , 57041 , 57047 , 57059 , 57073 , 57077 , 57089 , 57097 , 57107 , 57119 , 57131 , 57139 , 57143 , 57149 , 57163 , 57173 , 57179 , 57191 , 57193 , 57203 , 57221 , 57223 , 57241 , 57251 , 57259 , 57269 , 57271 , 57283 , 57287 , 57301 , 57329 , 57331 , 57347 , 57349 , 57367 , 57373 , 57383 , 57389 , 57397 , 57413 , 57427 , 57457 , 57467 , 57487 , 57493 , 57503 , 57527 , 57529 , 57557 , 57559 , 57571 , 57587 , 57593 , 57601 , 57637 , 57641 , 57649 , 57653 , 57667 , 57679 , 57689 , 57697 , 57709 , 57713 , 57719 , 57727 , 57731 , 57737 , 57751 , 57773 , 57781 , 57787 , 57791 , 57793 , 57803 , 57809 , 57829 , 57839 , 57847 , 57853 , 57859 , 57881 , 57899 , 57901 , 57917 , 57923 , 57943 , 57947 , 57973 , 57977 , 57991 , 58013 , 58027 , 58031 , 58043 , 58049 , 58057 , 58061 , 58067 , 58073 , 58099 , 58109 , 58111 , 58129 , 58147 , 58151 , 58153 , 58169 , 58171 , 58189 , 58193 , 58199 , 58207 , 58211 , 58217 , 58229 , 58231 , 58237 , 58243 , 58271 , 58309 , 58313 , 58321 , 58337 , 58363 , 58367 , 58369 , 58379 , 58391 , 58393 , 58403 , 58411 , 58417 , 58427 , 58439 , 58441 , 58451 , 58453 , 58477 , 58481 , 58511 , 58537 , 58543 , 58549 , 58567 , 58573 , 58579 , 58601 , 58603 , 58613 , 58631 , 58657 , 58661 , 58679 , 58687 , 58693 , 58699 , 58711 , 58727 , 58733 , 58741 , 58757 , 58763 , 58771 , 58787 , 58789 , 58831 , 58889 , 58897 , 58901 , 58907 , 58909 , 58913 , 58921 , 58937 , 58943 , 58963 , 58967 , 58979 , 58991 , 58997 , 59009 , 59011 , 59021 , 59023 , 59029 , 59051 , 59053 , 59063 , 59069 , 59077 , 59083 , 59093 , 59107 , 59113 , 59119 , 59123 , 59141 , 59149 , 59159 , 59167 , 59183 , 59197 , 59207 , 59209 , 59219 , 59221 , 59233 , 59239 , 59243 , 59263 , 59273 , 59281 , 59333 , 59341 , 59351 , 59357 , 59359 , 59369 , 59377 , 59387 , 59393 , 59399 , 59407 , 59417 , 59419 , 59441 , 59443 , 59447 , 59453 , 59467 , 59471 , 59473 , 59497 , 59509 , 59513 , 59539 , 59557 , 59561 , 59567 , 59581 , 59611 , 59617 , 59621 , 59627 , 59629 , 59651 , 59659 , 59663 , 59669 , 59671 , 59693 , 59699 , 59707 , 59723 , 59729 , 59743 , 59747 , 59753 , 59771 , 59779 , 59791 , 59797 , 59809 , 59833 , 59863 , 59879 , 59887 , 59921 , 59929 , 59951 , 59957 , 59971 , 59981 , 59999 , 60013 , 60017 , 60029 , 60037 , 60041 , 60077 , 60083 , 60089 , 60091 , 60101 , 60103 , 60107 , 60127 , 60133 , 60139 , 60149 , 60161 , 60167 , 60169 , 60209 , 60217 , 60223 , 60251 , 60257 , 60259 , 60271 , 60289 , 60293 , 60317 , 60331 , 60337 , 60343 , 60353 , 60373 , 60383 , 60397 , 60413 , 60427 , 60443 , 60449 , 60457 , 60493 , 60497 , 60509 , 60521 , 60527 , 60539 , 60589 , 60601 , 60607 , 60611 , 60617 , 60623 , 60631 , 60637 , 60647 , 60649 , 60659 , 60661 , 60679 , 60689 , 60703 , 60719 , 60727 , 60733 , 60737 , 60757 , 60761 , 60763 , 60773 , 60779 , 60793 , 60811 , 60821 , 60859 , 60869 , 60887 , 60889 , 60899 , 60901 , 60913 , 60917 , 60919 , 60923 , 60937 , 60943 , 60953 , 60961 , 61001 , 61007 , 61027 , 61031 , 61043 , 61051 , 61057 , 61091 , 61099 , 61121 , 61129 , 61141 , 61151 , 61153 , 61169 , 61211 , 61223 , 61231 , 61253 , 61261 , 61283 , 61291 , 61297 , 61331 , 61333 , 61339 , 61343 , 61357 , 61363 , 61379 , 61381 , 61403 , 61409 , 61417 , 61441 , 61463 , 61469 , 61471 , 61483 , 61487 , 61493 , 61507 , 61511 , 61519 , 61543 , 61547 , 61553 , 61559 , 61561 , 61583 , 61603 , 61609 , 61613 , 61627 , 61631 , 61637 , 61643 , 61651 , 61657 , 61667 , 61673 , 61681 , 61687 , 61703 , 61717 , 61723 , 61729 , 61751 , 61757 , 61781 , 61813 , 61819 , 61837 , 61843 , 61861 , 61871 , 61879 , 61909 , 61927 , 61933 , 61949 , 61961 , 61967 , 61979 , 61981 , 61987 , 61991 , 62003 , 62011 , 62017 , 62039 , 62047 , 62053 , 62057 , 62071 , 62081 , 62099 , 62119 , 62129 , 62131 , 62137 , 62141 , 62143 , 62171 , 62189 , 62191 , 62201 , 62207 , 62213 , 62219 , 62233 , 62273 , 62297 , 62299 , 62303 , 62311 , 62323 , 62327 , 62347 , 62351 , 62383 , 62401 , 62417 , 62423 , 62459 , 62467 , 62473 , 62477 , 62483 , 62497 , 62501 , 62507 , 62533 , 62539 , 62549 , 62563 , 62581 , 62591 , 62597 , 62603 , 62617 , 62627 , 62633 , 62639 , 62653 , 62659 , 62683 , 62687 , 62701 , 62723 , 62731 , 62743 , 62753 , 62761 , 62773 , 62791 , 62801 , 62819 , 62827 , 62851 , 62861 , 62869 , 62873 , 62897 , 62903 , 62921 , 62927 , 62929 , 62939 , 62969 , 62971 , 62981 , 62983 , 62987 , 62989 , 63029 , 63031 , 63059 , 63067 , 63073 , 63079 , 63097 , 63103 , 63113 , 63127 , 63131 , 63149 , 63179 , 63197 , 63199 , 63211 , 63241 , 63247 , 63277 , 63281 , 63299 , 63311 , 63313 , 63317 , 63331 , 63337 , 63347 , 63353 , 63361 , 63367 , 63377 , 63389 , 63391 , 63397 , 63409 , 63419 , 63421 , 63439 , 63443 , 63463 , 63467 , 63473 , 63487 , 63493 , 63499 , 63521 , 63527 , 63533 , 63541 , 63559 , 63577 , 63587 , 63589 , 63599 , 63601 , 63607 , 63611 , 63617 , 63629 , 63647 , 63649 , 63659 , 63667 , 63671 , 63689 , 63691 , 63697 , 63703 , 63709 , 63719 , 63727 , 63737 , 63743 , 63761 , 63773 , 63781 , 63793 , 63799 , 63803 , 63809 , 63823 , 63839 , 63841 , 63853 , 63857 , 63863 , 63901 , 63907 , 63913 , 63929 , 63949 , 63977 , 63997 , 64007 , 64013 , 64019 , 64033 , 64037 , 64063 , 64067 , 64081 , 64091 , 64109 , 64123 , 64151 , 64153 , 64157 , 64171 , 64187 , 64189 , 64217 , 64223 , 64231 , 64237 , 64271 , 64279 , 64283 , 64301 , 64303 , 64319 , 64327 , 64333 , 64373 , 64381 , 64399 , 64403 , 64433 , 64439 , 64451 , 64453 , 64483 , 64489 , 64499 , 64513 , 64553 , 64567 , 64577 , 64579 , 64591 , 64601 , 64609 , 64613 , 64621 , 64627 , 64633 , 64661 , 64663 , 64667 , 64679 , 64693 , 64709 , 64717 , 64747 , 64763 , 64781 , 64783 , 64793 , 64811 , 64817 , 64849 , 64853 , 64871 , 64877 , 64879 , 64891 , 64901 , 64919 , 64921 , 64927 , 64937 , 64951 , 64969 , 64997 , 65003 , 65011 , 65027 , 65029 , 65033 , 65053 , 65063 , 65071 , 65089 , 65099 , 65101 , 65111 , 65119 , 65123 , 65129 , 65141 , 65147 , 65167 , 65171 , 65173 , 65179 , 65183 , 65203 , 65213 , 65239 , 65257 , 65267 , 65269 , 65287 , 65293 , 65309 , 65323 , 65327 , 65353 , 65357 , 65371 , 65381 , 65393 , 65407 , 65413 , 65419 , 65423 , 65437 , 65447 , 65449 , 65479 , 65497 , 65519 , 65521 , 65537 , 65539 , 65543 , 65551 , 65557 , 65563 , 65579 , 65581 , 65587 , 65599 , 65609 , 65617 , 65629 , 65633 , 65647 , 65651 , 65657 , 65677 , 65687 , 65699 , 65701 , 65707 , 65713 , 65717 , 65719 , 65729 , 65731 , 65761 , 65777 , 65789 , 65809 , 65827 , 65831 , 65837 , 65839 , 65843 , 65851 , 65867 , 65881 , 65899 , 65921 , 65927 , 65929 , 65951 , 65957 , 65963 , 65981 , 65983 , 65993 , 66029 , 66037 , 66041 , 66047 , 66067 , 66071 , 66083 , 66089 , 66103 , 66107 , 66109 , 66137 , 66161 , 66169 , 66173 , 66179 , 66191 , 66221 , 66239 , 66271 , 66293 , 66301 , 66337 , 66343 , 66347 , 66359 , 66361 , 66373 , 66377 , 66383 , 66403 , 66413 , 66431 , 66449 , 66457 , 66463 , 66467 , 66491 , 66499 , 66509 , 66523 , 66529 , 66533 , 66541 , 66553 , 66569 , 66571 , 66587 , 66593 , 66601 , 66617 , 66629 , 66643 , 66653 , 66683 , 66697 , 66701 , 66713 , 66721 , 66733 , 66739 , 66749 , 66751 , 66763 , 66791 , 66797 , 66809 , 66821 , 66841 , 66851 , 66853 , 66863 , 66877 , 66883 , 66889 , 66919 , 66923 , 66931 , 66943 , 66947 , 66949 , 66959 , 66973 , 66977 , 67003 , 67021 , 67033 , 67043 , 67049 , 67057 , 67061 , 67073 , 67079 , 67103 , 67121 , 67129 , 67139 , 67141 , 67153 , 67157 , 67169 , 67181 , 67187 , 67189 , 67211 , 67213 , 67217 , 67219 , 67231 , 67247 , 67261 , 67271 , 67273 , 67289 , 67307 , 67339 , 67343 , 67349 , 67369 , 67391 , 67399 , 67409 , 67411 , 67421 , 67427 , 67429 , 67433 , 67447 , 67453 , 67477 , 67481 , 67489 , 67493 , 67499 , 67511 , 67523 , 67531 , 67537 , 67547 , 67559 , 67567 , 67577 , 67579 , 67589 , 67601 , 67607 , 67619 , 67631 , 67651 , 67679 , 67699 , 67709 , 67723 , 67733 , 67741 , 67751 , 67757 , 67759 , 67763 , 67777 , 67783 , 67789 , 67801 , 67807 , 67819 , 67829 , 67843 , 67853 , 67867 , 67883 , 67891 , 67901 , 67927 , 67931 , 67933 , 67939 , 67943 , 67957 , 67961 , 67967 , 67979 , 67987 , 67993 , 68023 , 68041 , 68053 , 68059 , 68071 , 68087 , 68099 , 68111 , 68113 , 68141 , 68147 , 68161 , 68171 , 68207 , 68209 , 68213 , 68219 , 68227 , 68239 , 68261 , 68279 , 68281 , 68311 , 68329 , 68351 , 68371 , 68389 , 68399 , 68437 , 68443 , 68447 , 68449 , 68473 , 68477 , 68483 , 68489 , 68491 , 68501 , 68507 , 68521 , 68531 , 68539 , 68543 , 68567 , 68581 , 68597 , 68611 , 68633 , 68639 , 68659 , 68669 , 68683 , 68687 , 68699 , 68711 , 68713 , 68729 , 68737 , 68743 , 68749 , 68767 , 68771 , 68777 , 68791 , 68813 , 68819 , 68821 , 68863 , 68879 , 68881 , 68891 , 68897 , 68899 , 68903 , 68909 , 68917 , 68927 , 68947 , 68963 , 68993 , 69001 , 69011 , 69019 , 69029 , 69031 , 69061 , 69067 , 69073 , 69109 , 69119 , 69127 , 69143 , 69149 , 69151 , 69163 , 69191 , 69193 , 69197 , 69203 , 69221 , 69233 , 69239 , 69247 , 69257 , 69259 , 69263 , 69313 , 69317 , 69337 , 69341 , 69371 , 69379 , 69383 , 69389 , 69401 , 69403 , 69427 , 69431 , 69439 , 69457 , 69463 , 69467 , 69473 , 69481 , 69491 , 69493 , 69497 , 69499 , 69539 , 69557 , 69593 , 69623 , 69653 , 69661 , 69677 , 69691 , 69697 , 69709 , 69737 , 69739 , 69761 , 69763 , 69767 , 69779 , 69809 , 69821 , 69827 , 69829 , 69833 , 69847 , 69857 , 69859 , 69877 , 69899 , 69911 , 69929 , 69931 , 69941 , 69959 , 69991 , 69997 , 70001 , 70003 , 70009 , 70019 , 70039 , 70051 , 70061 , 70067 , 70079 , 70099 , 70111 , 70117 , 70121 , 70123 , 70139 , 70141 , 70157 , 70163 , 70177 , 70181 , 70183 , 70199 , 70201 , 70207 , 70223 , 70229 , 70237 , 70241 , 70249 , 70271 , 70289 , 70297 , 70309 , 70313 , 70321 , 70327 , 70351 , 70373 , 70379 , 70381 , 70393 , 70423 , 70429 , 70439 , 70451 , 70457 , 70459 , 70481 , 70487 , 70489 , 70501 , 70507 , 70529 , 70537 , 70549 , 70571 , 70573 , 70583 , 70589 , 70607 , 70619 , 70621 , 70627 , 70639 , 70657 , 70663 , 70667 , 70687 , 70709 , 70717 , 70729 , 70753 , 70769 , 70783 , 70793 , 70823 , 70841 , 70843 , 70849 , 70853 , 70867 , 70877 , 70879 , 70891 , 70901 , 70913 , 70919 , 70921 , 70937 , 70949 , 70951 , 70957 , 70969 , 70979 , 70981 , 70991 , 70997 , 70999 , 71011 , 71023 , 71039 , 71059 , 71069 , 71081 , 71089 , 71119 , 71129 , 71143 , 71147 , 71153 , 71161 , 71167 , 71171 , 71191 , 71209 , 71233 , 71237 , 71249 , 71257 , 71261 , 71263 , 71287 , 71293 , 71317 , 71327 , 71329 , 71333 , 71339 , 71341 , 71347 , 71353 , 71359 , 71363 , 71387 , 71389 , 71399 , 71411 , 71413 , 71419 , 71429 , 71437 , 71443 , 71453 , 71471 , 71473 , 71479 , 71483 , 71503 , 71527 , 71537 , 71549 , 71551 , 71563 , 71569 , 71593 , 71597 , 71633 , 71647 , 71663 , 71671 , 71693 , 71699 , 71707 , 71711 , 71713 , 71719 , 71741 , 71761 , 71777 , 71789 , 71807 , 71809 , 71821 , 71837 , 71843 , 71849 , 71861 , 71867 , 71879 , 71881 , 71887 , 71899 , 71909 , 71917 , 71933 , 71941 , 71947 , 71963 , 71971 , 71983 , 71987 , 71993 , 71999 , 72019 , 72031 , 72043 , 72047 , 72053 , 72073 , 72077 , 72089 , 72091 , 72101 , 72103 , 72109 , 72139 , 72161 , 72167 , 72169 , 72173 , 72211 , 72221 , 72223 , 72227 , 72229 , 72251 , 72253 , 72269 , 72271 , 72277 , 72287 , 72307 , 72313 , 72337 , 72341 , 72353 , 72367 , 72379 , 72383 , 72421 , 72431 , 72461 , 72467 , 72469 , 72481 , 72493 , 72497 , 72503 , 72533 , 72547 , 72551 , 72559 , 72577 , 72613 , 72617 , 72623 , 72643 , 72647 , 72649 , 72661 , 72671 , 72673 , 72679 , 72689 , 72701 , 72707 , 72719 , 72727 , 72733 , 72739 , 72763 , 72767 , 72797 , 72817 , 72823 , 72859 , 72869 , 72871 , 72883 , 72889 , 72893 , 72901 , 72907 , 72911 , 72923 , 72931 , 72937 , 72949 , 72953 , 72959 , 72973 , 72977 , 72997 , 73009 , 73013 , 73019 , 73037 , 73039 , 73043 , 73061 , 73063 , 73079 , 73091 , 73121 , 73127 , 73133 , 73141 , 73181 , 73189 , 73237 , 73243 , 73259 , 73277 , 73291 , 73303 , 73309 , 73327 , 73331 , 73351 , 73361 , 73363 , 73369 , 73379 , 73387 , 73417 , 73421 , 73433 , 73453 , 73459 , 73471 , 73477 , 73483 , 73517 , 73523 , 73529 , 73547 , 73553 , 73561 , 73571 , 73583 , 73589 , 73597 , 73607 , 73609 , 73613 , 73637 , 73643 , 73651 , 73673 , 73679 , 73681 , 73693 , 73699 , 73709 , 73721 , 73727 , 73751 , 73757 , 73771 , 73783 , 73819 , 73823 , 73847 , 73849 , 73859 , 73867 , 73877 , 73883 , 73897 , 73907 , 73939 , 73943 , 73951 , 73961 , 73973 , 73999 , 74017 , 74021 , 74027 , 74047 , 74051 , 74071 , 74077 , 74093 , 74099 , 74101 , 74131 , 74143 , 74149 , 74159 , 74161 , 74167 , 74177 , 74189 , 74197 , 74201 , 74203 , 74209 , 74219 , 74231 , 74257 , 74279 , 74287 , 74293 , 74297 , 74311 , 74317 , 74323 , 74353 , 74357 , 74363 , 74377 , 74381 , 74383 , 74411 , 74413 , 74419 , 74441 , 74449 , 74453 , 74471 , 74489 , 74507 , 74509 , 74521 , 74527 , 74531 , 74551 , 74561 , 74567 , 74573 , 74587 , 74597 , 74609 , 74611 , 74623 , 74653 , 74687 , 74699 , 74707 , 74713 , 74717 , 74719 , 74729 , 74731 , 74747 , 74759 , 74761 , 74771 , 74779 , 74797 , 74821 , 74827 , 74831 , 74843 , 74857 , 74861 , 74869 , 74873 , 74887 , 74891 , 74897 , 74903 , 74923 , 74929 , 74933 , 74941 , 74959 , 75011 , 75013 , 75017 , 75029 , 75037 , 75041 , 75079 , 75083 , 75109 , 75133 , 75149 , 75161 , 75167 , 75169 , 75181 , 75193 , 75209 , 75211 , 75217 , 75223 , 75227 , 75239 , 75253 , 75269 , 75277 , 75289 , 75307 , 75323 , 75329 , 75337 , 75347 , 75353 , 75367 , 75377 , 75389 , 75391 , 75401 , 75403 , 75407 , 75431 , 75437 , 75479 , 75503 , 75511 , 75521 , 75527 , 75533 , 75539 , 75541 , 75553 , 75557 , 75571 , 75577 , 75583 , 75611 , 75617 , 75619 , 75629 , 75641 , 75653 , 75659 , 75679 , 75683 , 75689 , 75703 , 75707 , 75709 , 75721 , 75731 , 75743 , 75767 , 75773 , 75781 , 75787 , 75793 , 75797 , 75821 , 75833 , 75853 , 75869 , 75883 , 75913 , 75931 , 75937 , 75941 , 75967 , 75979 , 75983 , 75989 , 75991 , 75997 , 76001 , 76003 , 76031 , 76039 , 76079 , 76081 , 76091 , 76099 , 76103 , 76123 , 76129 , 76147 , 76157 , 76159 , 76163 , 76207 , 76213 , 76231 , 76243 , 76249 , 76253 , 76259 , 76261 , 76283 , 76289 , 76303 , 76333 , 76343 , 76367 , 76369 , 76379 , 76387 , 76403 , 76421 , 76423 , 76441 , 76463 , 76471 , 76481 , 76487 , 76493 , 76507 , 76511 , 76519 , 76537 , 76541 , 76543 , 76561 , 76579 , 76597 , 76603 , 76607 , 76631 , 76649 , 76651 , 76667 , 76673 , 76679 , 76697 , 76717 , 76733 , 76753 , 76757 , 76771 , 76777 , 76781 , 76801 , 76819 , 76829 , 76831 , 76837 , 76847 , 76871 , 76873 , 76883 , 76907 , 76913 , 76919 , 76943 , 76949 , 76961 , 76963 , 76991 , 77003 , 77017 , 77023 , 77029 , 77041 , 77047 , 77069 , 77081 , 77093 , 77101 , 77137 , 77141 , 77153 , 77167 , 77171 , 77191 , 77201 , 77213 , 77237 , 77239 , 77243 , 77249 , 77261 , 77263 , 77267 , 77269 , 77279 , 77291 , 77317 , 77323 , 77339 , 77347 , 77351 , 77359 , 77369 , 77377 , 77383 , 77417 , 77419 , 77431 , 77447 , 77471 , 77477 , 77479 , 77489 , 77491 , 77509 , 77513 , 77521 , 77527 , 77543 , 77549 , 77551 , 77557 , 77563 , 77569 , 77573 , 77587 , 77591 , 77611 , 77617 , 77621 , 77641 , 77647 , 77659 , 77681 , 77687 , 77689 , 77699 , 77711 , 77713 , 77719 , 77723 , 77731 , 77743 , 77747 , 77761 , 77773 , 77783 , 77797 , 77801 , 77813 , 77839 , 77849 , 77863 , 77867 , 77893 , 77899 , 77929 , 77933 , 77951 , 77969 , 77977 , 77983 , 77999 , 78007 , 78017 , 78031 , 78041 , 78049 , 78059 , 78079 , 78101 , 78121 , 78137 , 78139 , 78157 , 78163 , 78167 , 78173 , 78179 , 78191 , 78193 , 78203 , 78229 , 78233 , 78241 , 78259 , 78277 , 78283 , 78301 , 78307 , 78311 , 78317 , 78341 , 78347 , 78367 , 78401 , 78427 , 78437 , 78439 , 78467 , 78479 , 78487 , 78497 , 78509 , 78511 , 78517 , 78539 , 78541 , 78553 , 78569 , 78571 , 78577 , 78583 , 78593 , 78607 , 78623 , 78643 , 78649 , 78653 , 78691 , 78697 , 78707 , 78713 , 78721 , 78737 , 78779 , 78781 , 78787 , 78791 , 78797 , 78803 , 78809 , 78823 , 78839 , 78853 , 78857 , 78877 , 78887 , 78889 , 78893 , 78901 , 78919 , 78929 , 78941 , 78977 , 78979 , 78989 , 79031 , 79039 , 79043 , 79063 , 79087 , 79103 , 79111 , 79133 , 79139 , 79147 , 79151 , 79153 , 79159 , 79181 , 79187 , 79193 , 79201 , 79229 , 79231 , 79241 , 79259 , 79273 , 79279 , 79283 , 79301 , 79309 , 79319 , 79333 , 79337 , 79349 , 79357 , 79367 , 79379 , 79393 , 79397 , 79399 , 79411 , 79423 , 79427 , 79433 , 79451 , 79481 , 79493 , 79531 , 79537 , 79549 , 79559 , 79561 , 79579 , 79589 , 79601 , 79609 , 79613 , 79621 , 79627 , 79631 , 79633 , 79657 , 79669 , 79687 , 79691 , 79693 , 79697 , 79699 , 79757 , 79769 , 79777 , 79801 , 79811 , 79813 , 79817 , 79823 , 79829 , 79841 , 79843 , 79847 , 79861 , 79867 , 79873 , 79889 , 79901 , 79903 , 79907 , 79939 , 79943 , 79967 , 79973 , 79979 , 79987 , 79997 , 79999 , 80021 , 80039 , 80051 , 80071 , 80077 , 80107 , 80111 , 80141 , 80147 , 80149 , 80153 , 80167 , 80173 , 80177 , 80191 , 80207 , 80209 , 80221 , 80231 , 80233 , 80239 , 80251 , 80263 , 80273 , 80279 , 80287 , 80309 , 80317 , 80329 , 80341 , 80347 , 80363 , 80369 , 80387 , 80407 , 80429 , 80447 , 80449 , 80471 , 80473 , 80489 , 80491 , 80513 , 80527 , 80537 , 80557 , 80567 , 80599 , 80603 , 80611 , 80621 , 80627 , 80629 , 80651 , 80657 , 80669 , 80671 , 80677 , 80681 , 80683 , 80687 , 80701 , 80713 , 80737 , 80747 , 80749 , 80761 , 80777 , 80779 , 80783 , 80789 , 80803 , 80809 , 80819 , 80831 , 80833 , 80849 , 80863 , 80897 , 80909 , 80911 , 80917 , 80923 , 80929 , 80933 , 80953 , 80963 , 80989 , 81001 , 81013 , 81017 , 81019 , 81023 , 81031 , 81041 , 81043 , 81047 , 81049 , 81071 , 81077 , 81083 , 81097 , 81101 , 81119 , 81131 , 81157 , 81163 , 81173 , 81181 , 81197 , 81199 , 81203 , 81223 , 81233 , 81239 , 81281 , 81283 , 81293 , 81299 , 81307 , 81331 , 81343 , 81349 , 81353 , 81359 , 81371 , 81373 , 81401 , 81409 , 81421 , 81439 , 81457 , 81463 , 81509 , 81517 , 81527 , 81533 , 81547 , 81551 , 81553 , 81559 , 81563 , 81569 , 81611 , 81619 , 81629 , 81637 , 81647 , 81649 , 81667 , 81671 , 81677 , 81689 , 81701 , 81703 , 81707 , 81727 , 81737 , 81749 , 81761 , 81769 , 81773 , 81799 , 81817 , 81839 , 81847 , 81853 , 81869 , 81883 , 81899 , 81901 , 81919 , 81929 , 81931 , 81937 , 81943 , 81953 , 81967 , 81971 , 81973 , 82003 , 82007 , 82009 , 82013 , 82021 , 82031 , 82037 , 82039 , 82051 , 82067 , 82073 , 82129 , 82139 , 82141 , 82153 , 82163 , 82171 , 82183 , 82189 , 82193 , 82207 , 82217 , 82219 , 82223 , 82231 , 82237 , 82241 , 82261 , 82267 , 82279 , 82301 , 82307 , 82339 , 82349 , 82351 , 82361 , 82373 , 82387 , 82393 , 82421 , 82457 , 82463 , 82469 , 82471 , 82483 , 82487 , 82493 , 82499 , 82507 , 82529 , 82531 , 82549 , 82559 , 82561 , 82567 , 82571 , 82591 , 82601 , 82609 , 82613 , 82619 , 82633 , 82651 , 82657 , 82699 , 82721 , 82723 , 82727 , 82729 , 82757 , 82759 , 82763 , 82781 , 82787 , 82793 , 82799 , 82811 , 82813 , 82837 , 82847 , 82883 , 82889 , 82891 , 82903 , 82913 , 82939 , 82963 , 82981 , 82997 , 83003 , 83009 , 83023 , 83047 , 83059 , 83063 , 83071 , 83077 , 83089 , 83093 , 83101 , 83117 , 83137 , 83177 , 83203 , 83207 , 83219 , 83221 , 83227 , 83231 , 83233 , 83243 , 83257 , 83267 , 83269 , 83273 , 83299 , 83311 , 83339 , 83341 , 83357 , 83383 , 83389 , 83399 , 83401 , 83407 , 83417 , 83423 , 83431 , 83437 , 83443 , 83449 , 83459 , 83471 , 83477 , 83497 , 83537 , 83557 , 83561 , 83563 , 83579 , 83591 , 83597 , 83609 , 83617 , 83621 , 83639 , 83641 , 83653 , 83663 , 83689 , 83701 , 83717 , 83719 , 83737 , 83761 , 83773 , 83777 , 83791 , 83813 , 83833 , 83843 , 83857 , 83869 , 83873 , 83891 , 83903 , 83911 , 83921 , 83933 , 83939 , 83969 , 83983 , 83987 , 84011 , 84017 , 84047 , 84053 , 84059 , 84061 , 84067 , 84089 , 84121 , 84127 , 84131 , 84137 , 84143 , 84163 , 84179 , 84181 , 84191 , 84199 , 84211 , 84221 , 84223 , 84229 , 84239 , 84247 , 84263 , 84299 , 84307 , 84313 , 84317 , 84319 , 84347 , 84349 , 84377 , 84389 , 84391 , 84401 , 84407 , 84421 , 84431 , 84437 , 84443 , 84449 , 84457 , 84463 , 84467 , 84481 , 84499 , 84503 , 84509 , 84521 , 84523 , 84533 , 84551 , 84559 , 84589 , 84629 , 84631 , 84649 , 84653 , 84659 , 84673 , 84691 , 84697 , 84701 , 84713 , 84719 , 84731 , 84737 , 84751 , 84761 , 84787 , 84793 , 84809 , 84811 , 84827 , 84857 , 84859 , 84869 , 84871 , 84913 , 84919 , 84947 , 84961 , 84967 , 84977 , 84979 , 84991 , 85009 , 85021 , 85027 , 85037 , 85049 , 85061 , 85081 , 85087 , 85091 , 85093 , 85103 , 85109 , 85121 , 85133 , 85147 , 85159 , 85193 , 85199 , 85201 , 85213 , 85223 , 85229 , 85237 , 85243 , 85247 , 85259 , 85297 , 85303 , 85313 , 85331 , 85333 , 85361 , 85363 , 85369 , 85381 , 85411 , 85427 , 85429 , 85439 , 85447 , 85451 , 85453 , 85469 , 85487 , 85513 , 85517 , 85523 , 85531 , 85549 , 85571 , 85577 , 85597 , 85601 , 85607 , 85619 , 85621 , 85627 , 85639 , 85643 , 85661 , 85667 , 85669 , 85691 , 85703 , 85711 , 85717 , 85733 , 85751 , 85781 , 85793 , 85817 , 85819 , 85829 , 85831 , 85837 , 85843 , 85847 , 85853 , 85889 , 85903 , 85909 , 85931 , 85933 , 85991 , 85999 , 86011 , 86017 , 86027 , 86029 , 86069 , 86077 , 86083 , 86111 , 86113 , 86117 , 86131 , 86137 , 86143 , 86161 , 86171 , 86179 , 86183 , 86197 , 86201 , 86209 , 86239 , 86243 , 86249 , 86257 , 86263 , 86269 , 86287 , 86291 , 86293 , 86297 , 86311 , 86323 , 86341 , 86351 , 86353 , 86357 , 86369 , 86371 , 86381 , 86389 , 86399 , 86413 , 86423 , 86441 , 86453 , 86461 , 86467 , 86477 , 86491 , 86501 , 86509 , 86531 , 86533 , 86539 , 86561 , 86573 , 86579 , 86587 , 86599 , 86627 , 86629 , 86677 , 86689 , 86693 , 86711 , 86719 , 86729 , 86743 , 86753 , 86767 , 86771 , 86783 , 86813 , 86837 , 86843 , 86851 , 86857 , 86861 , 86869 , 86923 , 86927 , 86929 , 86939 , 86951 , 86959 , 86969 , 86981 , 86993 , 87011 , 87013 , 87037 , 87041 , 87049 , 87071 , 87083 , 87103 , 87107 , 87119 , 87121 , 87133 , 87149 , 87151 , 87179 , 87181 , 87187 , 87211 , 87221 , 87223 , 87251 , 87253 , 87257 , 87277 , 87281 , 87293 , 87299 , 87313 , 87317 , 87323 , 87337 , 87359 , 87383 , 87403 , 87407 , 87421 , 87427 , 87433 , 87443 , 87473 , 87481 , 87491 , 87509 , 87511 , 87517 , 87523 , 87539 , 87541 , 87547 , 87553 , 87557 , 87559 , 87583 , 87587 , 87589 , 87613 , 87623 , 87629 , 87631 , 87641 , 87643 , 87649 , 87671 , 87679 , 87683 , 87691 , 87697 , 87701 , 87719 , 87721 , 87739 , 87743 , 87751 , 87767 , 87793 , 87797 , 87803 , 87811 , 87833 , 87853 , 87869 , 87877 , 87881 , 87887 , 87911 , 87917 , 87931 , 87943 , 87959 , 87961 , 87973 , 87977 , 87991 , 88001 , 88003 , 88007 , 88019 , 88037 , 88069 , 88079 , 88093 , 88117 , 88129 , 88169 , 88177 , 88211 , 88223 , 88237 , 88241 , 88259 , 88261 , 88289 , 88301 , 88321 , 88327 , 88337 , 88339 , 88379 , 88397 , 88411 , 88423 , 88427 , 88463 , 88469 , 88471 , 88493 , 88499 , 88513 , 88523 , 88547 , 88589 , 88591 , 88607 , 88609 , 88643 , 88651 , 88657 , 88661 , 88663 , 88667 , 88681 , 88721 , 88729 , 88741 , 88747 , 88771 , 88789 , 88793 , 88799 , 88801 , 88807 , 88811 , 88813 , 88817 , 88819 , 88843 , 88853 , 88861 , 88867 , 88873 , 88883 , 88897 , 88903 , 88919 , 88937 , 88951 , 88969 , 88993 , 88997 , 89003 , 89009 , 89017 , 89021 , 89041 , 89051 , 89057 , 89069 , 89071 , 89083 , 89087 , 89101 , 89107 , 89113 , 89119 , 89123 , 89137 , 89153 , 89189 , 89203 , 89209 , 89213 , 89227 , 89231 , 89237 , 89261 , 89269 , 89273 , 89293 , 89303 , 89317 , 89329 , 89363 , 89371 , 89381 , 89387 , 89393 , 89399 , 89413 , 89417 , 89431 , 89443 , 89449 , 89459 , 89477 , 89491 , 89501 , 89513 , 89519 , 89521 , 89527 , 89533 , 89561 , 89563 , 89567 , 89591 , 89597 , 89599 , 89603 , 89611 , 89627 , 89633 , 89653 , 89657 , 89659 , 89669 , 89671 , 89681 , 89689 , 89753 , 89759 , 89767 , 89779 , 89783 , 89797 , 89809 , 89819 , 89821 , 89833 , 89839 , 89849 , 89867 , 89891 , 89897 , 89899 , 89909 , 89917 , 89923 , 89939 , 89959 , 89963 , 89977 , 89983 , 89989 , 90001 , 90007 , 90011 , 90017 , 90019 , 90023 , 90031 , 90053 , 90059 , 90067 , 90071 , 90073 , 90089 , 90107 , 90121 , 90127 , 90149 , 90163 , 90173 , 90187 , 90191 , 90197 , 90199 , 90203 , 90217 , 90227 , 90239 , 90247 , 90263 , 90271 , 90281 , 90289 , 90313 , 90353 , 90359 , 90371 , 90373 , 90379 , 90397 , 90401 , 90403 , 90407 , 90437 , 90439 , 90469 , 90473 , 90481 , 90499 , 90511 , 90523 , 90527 , 90529 , 90533 , 90547 , 90583 , 90599 , 90617 , 90619 , 90631 , 90641 , 90647 , 90659 , 90677 , 90679 , 90697 , 90703 , 90709 , 90731 , 90749 , 90787 , 90793 , 90803 , 90821 , 90823 , 90833 , 90841 , 90847 , 90863 , 90887 , 90901 , 90907 , 90911 , 90917 , 90931 , 90947 , 90971 , 90977 , 90989 , 90997 , 91009 , 91019 , 91033 , 91079 , 91081 , 91097 , 91099 , 91121 , 91127 , 91129 , 91139 , 91141 , 91151 , 91153 , 91159 , 91163 , 91183 , 91193 , 91199 , 91229 , 91237 , 91243 , 91249 , 91253 , 91283 , 91291 , 91297 , 91303 , 91309 , 91331 , 91367 , 91369 , 91373 , 91381 , 91387 , 91393 , 91397 , 91411 , 91423 , 91433 , 91453 , 91457 , 91459 , 91463 , 91493 , 91499 , 91513 , 91529 , 91541 , 91571 , 91573 , 91577 , 91583 , 91591 , 91621 , 91631 , 91639 , 91673 , 91691 , 91703 , 91711 , 91733 , 91753 , 91757 , 91771 , 91781 , 91801 , 91807 , 91811 , 91813 , 91823 , 91837 , 91841 , 91867 , 91873 , 91909 , 91921 , 91939 , 91943 , 91951 , 91957 , 91961 , 91967 , 91969 , 91997 , 92003 , 92009 , 92033 , 92041 , 92051 , 92077 , 92083 , 92107 , 92111 , 92119 , 92143 , 92153 , 92173 , 92177 , 92179 , 92189 , 92203 , 92219 , 92221 , 92227 , 92233 , 92237 , 92243 , 92251 , 92269 , 92297 , 92311 , 92317 , 92333 , 92347 , 92353 , 92357 , 92363 , 92369 , 92377 , 92381 , 92383 , 92387 , 92399 , 92401 , 92413 , 92419 , 92431 , 92459 , 92461 , 92467 , 92479 , 92489 , 92503 , 92507 , 92551 , 92557 , 92567 , 92569 , 92581 , 92593 , 92623 , 92627 , 92639 , 92641 , 92647 , 92657 , 92669 , 92671 , 92681 , 92683 , 92693 , 92699 , 92707 , 92717 , 92723 , 92737 , 92753 , 92761 , 92767 , 92779 , 92789 , 92791 , 92801 , 92809 , 92821 , 92831 , 92849 , 92857 , 92861 , 92863 , 92867 , 92893 , 92899 , 92921 , 92927 , 92941 , 92951 , 92957 , 92959 , 92987 , 92993 , 93001 , 93047 , 93053 , 93059 , 93077 , 93083 , 93089 , 93097 , 93103 , 93113 , 93131 , 93133 , 93139 , 93151 , 93169 , 93179 , 93187 , 93199 , 93229 , 93239 , 93241 , 93251 , 93253 , 93257 , 93263 , 93281 , 93283 , 93287 , 93307 , 93319 , 93323 , 93329 , 93337 , 93371 , 93377 , 93383 , 93407 , 93419 , 93427 , 93463 , 93479 , 93481 , 93487 , 93491 , 93493 , 93497 , 93503 , 93523 , 93529 , 93553 , 93557 , 93559 , 93563 , 93581 , 93601 , 93607 , 93629 , 93637 , 93683 , 93701 , 93703 , 93719 , 93739 , 93761 , 93763 , 93787 , 93809 , 93811 , 93827 , 93851 , 93871 , 93887 , 93889 , 93893 , 93901 , 93911 , 93913 , 93923 , 93937 , 93941 , 93949 , 93967 , 93971 , 93979 , 93983 , 93997 , 94007 , 94009 , 94033 , 94049 , 94057 , 94063 , 94079 , 94099 , 94109 , 94111 , 94117 , 94121 , 94151 , 94153 , 94169 , 94201 , 94207 , 94219 , 94229 , 94253 , 94261 , 94273 , 94291 , 94307 , 94309 , 94321 , 94327 , 94331 , 94343 , 94349 , 94351 , 94379 , 94397 , 94399 , 94421 , 94427 , 94433 , 94439 , 94441 , 94447 , 94463 , 94477 , 94483 , 94513 , 94529 , 94531 , 94541 , 94543 , 94547 , 94559 , 94561 , 94573 , 94583 , 94597 , 94603 , 94613 , 94621 , 94649 , 94651 , 94687 , 94693 , 94709 , 94723 , 94727 , 94747 , 94771 , 94777 , 94781 , 94789 , 94793 , 94811 , 94819 , 94823 , 94837 , 94841 , 94847 , 94849 , 94873 , 94889 , 94903 , 94907 , 94933 , 94949 , 94951 , 94961 , 94993 , 94999 , 95003 , 95009 , 95021 , 95027 , 95063 , 95071 , 95083 , 95087 , 95089 , 95093 , 95101 , 95107 , 95111 , 95131 , 95143 , 95153 , 95177 , 95189 , 95191 , 95203 , 95213 , 95219 , 95231 , 95233 , 95239 , 95257 , 95261 , 95267 , 95273 , 95279 , 95287 , 95311 , 95317 , 95327 , 95339 , 95369 , 95383 , 95393 , 95401 , 95413 , 95419 , 95429 , 95441 , 95443 , 95461 , 95467 , 95471 , 95479 , 95483 , 95507 , 95527 , 95531 , 95539 , 95549 , 95561 , 95569 , 95581 , 95597 , 95603 , 95617 , 95621 , 95629 , 95633 , 95651 , 95701 , 95707 , 95713 , 95717 , 95723 , 95731 , 95737 , 95747 , 95773 , 95783 , 95789 , 95791 , 95801 , 95803 , 95813 , 95819 , 95857 , 95869 , 95873 , 95881 , 95891 , 95911 , 95917 , 95923 , 95929 , 95947 , 95957 , 95959 , 95971 , 95987 , 95989 , 96001 , 96013 , 96017 , 96043 , 96053 , 96059 , 96079 , 96097 , 96137 , 96149 , 96157 , 96167 , 96179 , 96181 , 96199 , 96211 , 96221 , 96223 , 96233 , 96259 , 96263 , 96269 , 96281 , 96289 , 96293 , 96323 , 96329 , 96331 , 96337 , 96353 , 96377 , 96401 , 96419 , 96431 , 96443 , 96451 , 96457 , 96461 , 96469 , 96479 , 96487 , 96493 , 96497 , 96517 , 96527 , 96553 , 96557 , 96581 , 96587 , 96589 , 96601 , 96643 , 96661 , 96667 , 96671 , 96697 , 96703 , 96731 , 96737 , 96739 , 96749 , 96757 , 96763 , 96769 , 96779 , 96787 , 96797 , 96799 , 96821 , 96823 , 96827 , 96847 , 96851 , 96857 , 96893 , 96907 , 96911 , 96931 , 96953 , 96959 , 96973 , 96979 , 96989 , 96997 , 97001 , 97003 , 97007 , 97021 , 97039 , 97073 , 97081 , 97103 , 97117 , 97127 , 97151 , 97157 , 97159 , 97169 , 97171 , 97177 , 97187 , 97213 , 97231 , 97241 , 97259 , 97283 , 97301 , 97303 , 97327 , 97367 , 97369 , 97373 , 97379 , 97381 , 97387 , 97397 , 97423 , 97429 , 97441 , 97453 , 97459 , 97463 , 97499 , 97501 , 97511 , 97523 , 97547 , 97549 , 97553 , 97561 , 97571 , 97577 , 97579 , 97583 , 97607 , 97609 , 97613 , 97649 , 97651 , 97673 , 97687 , 97711 , 97729 , 97771 , 97777 , 97787 , 97789 , 97813 , 97829 , 97841 , 97843 , 97847 , 97849 , 97859 , 97861 , 97871 , 97879 , 97883 , 97919 , 97927 , 97931 , 97943 , 97961 , 97967 , 97973 , 97987 , 98009 , 98011 , 98017 , 98041 , 98047 , 98057 , 98081 , 98101 , 98123 , 98129 , 98143 , 98179 , 98207 , 98213 , 98221 , 98227 , 98251 , 98257 , 98269 , 98297 , 98299 , 98317 , 98321 , 98323 , 98327 , 98347 , 98369 , 98377 , 98387 , 98389 , 98407 , 98411 , 98419 , 98429 , 98443 , 98453 , 98459 , 98467 , 98473 , 98479 , 98491 , 98507 , 98519 , 98533 , 98543 , 98561 , 98563 , 98573 , 98597 , 98621 , 98627 , 98639 , 98641 , 98663 , 98669 , 98689 , 98711 , 98713 , 98717 , 98729 , 98731 , 98737 , 98773 , 98779 , 98801 , 98807 , 98809 , 98837 , 98849 , 98867 , 98869 , 98873 , 98887 , 98893 , 98897 , 98899 , 98909 , 98911 , 98927 , 98929 , 98939 , 98947 , 98953 , 98963 , 98981 , 98993 , 98999 , 99013 , 99017 , 99023 , 99041 , 99053 , 99079 , 99083 , 99089 , 99103 , 99109 , 99119 , 99131 , 99133 , 99137 , 99139 , 99149 , 99173 , 99181 , 99191 , 99223 , 99233 , 99241 , 99251 , 99257 , 99259 , 99277 , 99289 , 99317 , 99347 , 99349 , 99367 , 99371 , 99377 , 99391 , 99397 , 99401 , 99409 , 99431 , 99439 , 99469 , 99487 , 99497 , 99523 , 99527 , 99529 , 99551 , 99559 , 99563 , 99571 , 99577 , 99581 , 99607 , 99611 , 99623 , 99643 , 99661 , 99667 , 99679 , 99689 , 99707 , 99709 , 99713 , 99719 , 99721 , 99733 , 99761 , 99767 , 99787 , 99793 , 99809 , 99817 , 99823 , 99829 , 99833 , 99839 , 99859 , 99871 , 99877 , 99881 , 99901 , 99907 , 99923 , 99929 , 99961 , 99971 , 99989 , 99991 , 100003 , 100019 , 100043 , 100049 , 100057 , 100069 ] <NEWLINE> if plist . count ( X ) == 1 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plist . append ( X ) <NEWLINE> ans = sorted ( plist ) <NEWLINE> a = ans . index ( X ) <NEWLINE> <DEDENT> print ( ans [ a + 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( 0 in A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if ( len ( str ( ans ) ) >= 2 ) : <NEWLINE> <INDENT> if ( str ( ans ) [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def combs_mod ( n , k , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> inv = [ 1 ] * ( k + 1 ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> inv [ i ] = pow ( i , - 1 , mod ) <NEWLINE> <DEDENT> ans = [ 1 ] * ( k + 1 ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] * ( n + 1 - i ) * inv [ i ] % mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K < N : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> com = combs_mod ( K , K , mod ) <NEWLINE> com2 = combs_mod ( K - 1 , K - 1 , mod ) <NEWLINE> for r in range ( K + 1 ) : <NEWLINE> <INDENT> b = K - r <NEWLINE> dif = r - b <NEWLINE> if dif < 0 or r < N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dif == 0 : <NEWLINE> <INDENT> ans += com2 [ r ] <NEWLINE> if N >= 2 : <NEWLINE> <INDENT> ans -= com2 [ N - 2 ] <NEWLINE> <DEDENT> <DEDENT> elif dif < N : <NEWLINE> <INDENT> ans += com [ r ] - com [ N - 1 - dif ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += com [ r ] <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def sum_inc ( n ) : <NEWLINE> <INDENT> return int ( n * ( n + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> half = int ( N / 2 ) + 1 <NEWLINE> <NL> each_result = [ n * sum_inc ( int ( N / n ) ) for n in range ( 1 , half ) ] <NEWLINE> <NL> print ( sum ( each_result ) + sum_inc ( N ) - sum_inc ( half - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> br = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> <NL> for ind , rux in enumerate ( A ) : <NEWLINE> <INDENT> br [ max ( ind - rux , 0 ) ] += 1 <NEWLINE> br [ min ( ind + rux + 1 , N ) ] -= 1 <NEWLINE> <DEDENT> A = br . cumsum ( ) [ : - 1 ] <NEWLINE> <NL> if br [ 0 ] == N and br [ - 1 ] == - N : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> ans = solve ( n , k , a ) <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT>
def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( - min ( par ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> ans *= a [ i + 1 ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> max = int ( 10e5 + 1 ) <NEWLINE> l = [ 0 ] * ( max + 1 ) <NEWLINE> for n in A : <NEWLINE> <INDENT> if l [ n ] != 0 : <NEWLINE> <INDENT> l [ n ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( n , max + 1 , n ) : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for n in A : <NEWLINE> <INDENT> if l [ n ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> seven = 7 <NEWLINE> ans = - 1 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> seven %= k <NEWLINE> if seven == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seven = seven * 10 + 7 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> maxs = int ( X ** ( 1 / 5 ) ) <NEWLINE> <NL> l = np . arange ( - 126 , 127 ) <NEWLINE> <NL> comb = np . array ( list ( itertools . combinations_with_replacement ( l , 2 ) ) ) <NEWLINE> <NL> sum1 = comb [ : , 0 ] ** 5 - comb [ : , 1 ] ** 5 <NEWLINE> sum2 = comb [ : , 1 ] ** 5 - comb [ : , 0 ] ** 5 <NEWLINE> <NL> if len ( np . where ( sum1 == X ) [ 0 ] ) != 0 : <NEWLINE> <INDENT> result1 = np . where ( sum1 == X ) [ 0 ] [ 0 ] <NEWLINE> print ( comb [ result1 ] [ 0 ] , comb [ result1 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result2 = np . where ( sum2 == X ) [ 0 ] [ 0 ] <NEWLINE> print ( comb [ result2 ] [ 1 ] , comb [ result2 ] [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ <STRING> ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> _a = sorted ( a , reverse = 1 ) <NEWLINE> a_max = _a [ 0 ] <NEWLINE> a_second = _a [ 1 ] <NEWLINE> ans = [ a_max ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a_max : <NEWLINE> <INDENT> ans [ i ] = a_second <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> a_pre , b_pre = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_pre . append ( a_pre [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_pre . append ( b_pre [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_pre [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_pre [ j ] > k - a_pre [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> P [ i + 1 ] *= P [ i ] * 2 <NEWLINE> P [ i + 1 ] %= MOD <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> l , r = i , N - i - 1 <NEWLINE> now = P [ r ] <NEWLINE> if r != 0 : <NEWLINE> <INDENT> now += P [ r - 1 ] * r <NEWLINE> <DEDENT> now *= P [ l ] <NEWLINE> now *= C [ i ] <NEWLINE> ans += now <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans *= P [ N ] <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> def dfs ( ring , chain_len = 1 ) : <NEWLINE> <INDENT> unchecked [ ring ] = False <NEWLINE> unvisited [ ring ] = False <NEWLINE> len_rec [ ring ] = max ( len_rec [ ring ] , chain_len ) <NEWLINE> for r in adj_list [ ring ] : <NEWLINE> <INDENT> if unvisited [ r ] : <NEWLINE> <INDENT> dfs ( r , chain_len + 1 ) <NEWLINE> <DEDENT> <DEDENT> unvisited [ ring ] = True <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> file_input = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( file_input . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> rings = [ ] <NEWLINE> adj_list = [ [ ] for _ in range ( 101 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> adj_list [ a ] . append ( b ) <NEWLINE> adj_list [ b ] . append ( a ) <NEWLINE> rings . extend ( [ a , b ] ) <NEWLINE> <DEDENT> rings = set ( rings ) <NEWLINE> <NL> len_rec = [ 1 ] * 101 <NEWLINE> unchecked = [ True ] * 101 <NEWLINE> unvisited = [ True ] * 101 <NEWLINE> <NL> for r in rings : <NEWLINE> <INDENT> if unchecked [ r ] : <NEWLINE> <INDENT> dfs ( r ) <NEWLINE> <DEDENT> <DEDENT> dfs ( len_rec . index ( max ( len_rec ) ) ) <NEWLINE> <NL> print ( max ( len_rec ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
from sys import stdin <NEWLINE> <COMMENT> <NL> <NL> <NL> def merge_sort ( lst , low , high ) : <NEWLINE> <INDENT> if low >= high : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> mid = int ( ( low + high ) / 2 ) <NEWLINE> merge_sort ( lst , low , mid ) <NEWLINE> merge_sort ( lst , mid + 1 , high ) <NEWLINE> for i in range ( low , mid + 1 ) : <NEWLINE> <INDENT> tmp_array [ i ] = lst [ i ] <NEWLINE> <DEDENT> j = high <NEWLINE> for i in range ( mid + 1 , high + 1 ) : <NEWLINE> <INDENT> tmp_array [ i ] = lst [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> i = low <NEWLINE> j = high <NEWLINE> for k in range ( low , high + 1 ) : <NEWLINE> <INDENT> if tmp_array [ i ] <= tmp_array [ j ] : <NEWLINE> <INDENT> lst [ k ] = tmp_array [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ k ] = tmp_array [ j ] <NEWLINE> j -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> S = stdin . readline ( ) . rstrip ( ) <NEWLINE> N = len ( S ) <NEWLINE> Sp = S <NEWLINE> <NL> res_map = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> aa_list2 = [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> aa_list2 . append ( ( aa_list2 [ i - 1 ] * 10 ) % 2019 ) <NEWLINE> <NL> <DEDENT> tmp_array = [ None for _ in range ( N ) ] <NEWLINE> res_map [ N - 1 ] = int ( S [ N - 1 ] ) <NEWLINE> index = 1 <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> res_map [ i ] = ( int ( S [ i ] ) * aa_list2 [ index ] + res_map [ i + 1 ] ) % 2019 <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> res_map . sort ( ) <NEWLINE> temp_num = int ( res_map [ 0 ] ) <NEWLINE> index = 1 <NEWLINE> tot = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if temp_num == int ( res_map [ i ] ) : <NEWLINE> <INDENT> index += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if temp_num == 0 : <NEWLINE> <INDENT> tot += int ( index * ( index + 1 ) / 2 ) <NEWLINE> <DEDENT> elif index > 1 : <NEWLINE> <INDENT> tot += int ( index * ( index - 1 ) / 2 ) <NEWLINE> <DEDENT> index = 1 <NEWLINE> temp_num = int ( res_map [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> aa_table = [ 0 for i in range ( 2019 ) ] <NEWLINE> for i in range ( len ( res_map ) ) : <NEWLINE> <INDENT> aa_table [ res_map [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> aa_table [ 0 ] += 1 <NEWLINE> <NL> tot = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> tot += int ( ( aa_table [ i ] - 1 ) * aa_table [ i ] / 2 ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( tot ) <NEWLINE> <NL>
<NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s1 = deque ( ) <NEWLINE> s2 = deque ( ) <NEWLINE> total = 0 <NEWLINE> <NL> string = input ( ) <NEWLINE> <NL> for i in range ( len ( string ) ) : <NEWLINE> <INDENT> if string [ i ] == <STRING> : <NEWLINE> <INDENT> s1 . append ( i ) <NEWLINE> <DEDENT> elif string [ i ] == <STRING> and len ( s1 ) > 0 : <NEWLINE> <INDENT> j = s1 . pop ( ) <NEWLINE> a = i - j <NEWLINE> total += a <NEWLINE> <NL> while ( len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] > j ) : <NEWLINE> <INDENT> a += s2 [ - 1 ] [ 1 ] <NEWLINE> s2 . pop ( ) <NEWLINE> <NL> <DEDENT> s2 . append ( ( j , a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> while ( len ( s2 ) > 0 ) : <NEWLINE> <INDENT> ans . append ( s2 [ - 1 ] [ 1 ] ) <NEWLINE> s2 . pop ( ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <NL> print ( len ( ans ) , * ans [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = deque ( ) <NEWLINE> for _i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> order = line [ 0 ] <NEWLINE> if order in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> key = line [ 1 ] <NEWLINE> <DEDENT> if order == <STRING> : <NEWLINE> <INDENT> d . appendleft ( key ) <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d . remove ( key ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( d ) ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> history = [ 0 ] * ( K + 1 ) <NEWLINE> total = 0 <NEWLINE> <NL> divide = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> history [ i ] = pow ( K // i , N , divide ) <NEWLINE> for j in range ( 2 , K // i + 1 ) : <NEWLINE> <INDENT> history [ i ] -= history [ i * j ] <NEWLINE> <DEDENT> total += ( ( i * history [ i ] ) % divide ) <NEWLINE> <NL> <DEDENT> total = total % divide <NEWLINE> print ( total ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = N // i <NEWLINE> ans += Y * ( Y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<NL> X = int ( input ( ) ) <NEWLINE> <NL> def make_div ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> def f ( x , y ) : <NEWLINE> <INDENT> return x ** 5 - y ** 5 - X <NEWLINE> <NL> <DEDENT> Flag = True <NEWLINE> <NL> for A in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if Flag : <NEWLINE> <INDENT> for i in make_div ( X ) : <NEWLINE> <INDENT> B = A - i <NEWLINE> if f ( A , B ) == 0 : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - i - j <NEWLINE> if 0 <= z <= k and i + j + z == s : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B_n , C_n = [ ] , [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B_n . append ( B ) <NEWLINE> C_n . append ( C ) <NEWLINE> <NL> <DEDENT> dic = Counter ( A_n ) <NEWLINE> <NL> sum0 = sum ( A_n ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> count = dic [ B_n [ i ] ] <NEWLINE> sum0 += ( C_n [ i ] - B_n [ i ] ) * count <NEWLINE> dic [ B_n [ i ] ] = 0 <NEWLINE> dic [ C_n [ i ] ] += count <NEWLINE> print ( sum0 ) <NEWLINE> <DEDENT>
def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( ( <STRING> , 1000000001 ) ) <NEWLINE> R . append ( ( <STRING> , 1000000001 ) ) <NEWLINE> i = 0 <COMMENT> <NEWLINE> j = 0 <COMMENT> <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] [ 1 ] <= R [ j ] [ 1 ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def partition ( A , p , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> temp = A [ i ] <NEWLINE> A [ i ] = A [ j ] <NEWLINE> A [ j ] = temp <NEWLINE> <DEDENT> <DEDENT> temp = A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ r ] <NEWLINE> A [ r ] = temp <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> def quick_sort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quick_sort ( A , p , q - 1 ) <NEWLINE> quick_sort ( A , q + 1 , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num_of_cards = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> for i in range ( num_of_cards ) : <NEWLINE> <INDENT> suit , rank = input ( ) . split ( <STRING> ) <NEWLINE> cards . append ( ( suit , int ( rank ) ) ) <NEWLINE> <DEDENT> comp_cards = cards [ : ] <NEWLINE> <NL> <NL> <COMMENT> <NL> data_length = len ( cards ) <NEWLINE> quick_sort ( cards , 0 , data_length - 1 ) <NEWLINE> merge_sort ( comp_cards , 0 , data_length ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> stable = True <COMMENT> <NEWLINE> for x , y in zip ( cards , comp_cards ) : <NEWLINE> <INDENT> if x != y : <NEWLINE> <INDENT> stable = False <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if stable is True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for c in cards : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> . format ( c [ 0 ] , c [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] != A [ i - 1 ] : <NEWLINE> <INDENT> X . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> S = [ ] <NEWLINE> n = len ( X ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> status = 0 <NEWLINE> result = 1000 <NEWLINE> now_m = 1000 <NEWLINE> k = 0 <NEWLINE> if X [ 0 ] < X [ 1 ] : <NEWLINE> <INDENT> S . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if ( X [ i - 1 ] < X [ i ] and X [ i ] > X [ i + 1 ] ) or ( X [ i - 1 ] > X [ i ] and X [ i ] < X [ i + 1 ] ) : <NEWLINE> <INDENT> S . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if X [ n - 2 ] < X [ n - 1 ] : <NEWLINE> <INDENT> S . append ( n - 1 ) <NEWLINE> <DEDENT> for s in S : <NEWLINE> <INDENT> if status == 0 : <NEWLINE> <INDENT> k = now_m // X [ s ] <NEWLINE> result = max ( result , now_m ) <NEWLINE> now_m -= k * X [ s ] <NEWLINE> status = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_m += k * X [ s ] <NEWLINE> result = max ( result , now_m ) <NEWLINE> k = 0 <NEWLINE> status = 0 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> for b in range ( 1 , 32 ) : <NEWLINE> <INDENT> for p in range ( 2 , 10 ) : <NEWLINE> <INDENT> if b ** p <= x : <NEWLINE> <INDENT> c = max ( c , b ** p ) <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( H [ 1 ] - H [ 0 ] ) <NEWLINE> <NL> for n in range ( 2 , N ) : <NEWLINE> <INDENT> if n - K > 0 : <NEWLINE> <INDENT> dp [ n ] = min ( [ ( dp [ i ] + abs ( H [ n ] - H [ i ] ) ) for i in range ( n - K , n ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ n ] = min ( [ dp [ i ] + abs ( H [ n ] - H [ i ] ) for i in range ( 0 , n ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] in d : <NEWLINE> <INDENT> d [ arr [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ arr [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> sums = sum ( arr ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> sums -= ( b * d [ b ] ) <NEWLINE> sums += ( c * d [ b ] ) <NEWLINE> <DEDENT> if c not in d and b in d : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> <DEDENT> elif b in d : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> if b in d : <NEWLINE> <INDENT> d [ b ] = 0 <NEWLINE> <DEDENT> print ( sums ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> prime = prime_factorize ( N ) <NEWLINE> for x in prime : <NEWLINE> <INDENT> q . append ( x ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> done = [ ] <NEWLINE> while N != 1 : <NEWLINE> <INDENT> break_flag = False <NEWLINE> if len ( q ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = q . popleft ( ) <NEWLINE> <COMMENT> <NL> if x == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if x in done : <NEWLINE> <INDENT> mul = x <NEWLINE> while mul in done : <NEWLINE> <INDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> break_flag = True <NEWLINE> break <NEWLINE> <DEDENT> pop = q . popleft ( ) <NEWLINE> <COMMENT> <NL> if x != pop : <NEWLINE> <COMMENT> <NL> <INDENT> q . appendleft ( pop ) <NEWLINE> <COMMENT> <NL> break_flag = True <NEWLINE> break <NEWLINE> <DEDENT> mul *= pop <NEWLINE> <DEDENT> x = mul <NEWLINE> if break_flag : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if N % x == 0 : <NEWLINE> <INDENT> N = N // x <NEWLINE> count += 1 <NEWLINE> done . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
from sys import stdin <NEWLINE> A , B , C , K = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> if K <= A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - K + A + B <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = A [ - 1 ] <NEWLINE> B = [ 0 ] * m <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> if B [ a - 1 ] == 1 : <NEWLINE> <INDENT> for j in range ( a * 2 , m + 1 , a ) : <NEWLINE> <INDENT> B [ j - 1 ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( B . count ( 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = { } <NEWLINE> y = { } <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x . setdefault ( ( i + a [ i ] ) , [ ] ) . append ( i ) <NEWLINE> y . setdefault ( ( i - a [ i ] ) , [ ] ) . append ( i ) <NEWLINE> <NL> <DEDENT> z = list ( set ( x . keys ( ) ) & set ( y . keys ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in z : <NEWLINE> <INDENT> if x [ i ] [ len ( x [ i ] ) - 1 ] < y [ i ] [ 0 ] : <NEWLINE> <INDENT> n = len ( y [ i ] ) * len ( x [ i ] ) <NEWLINE> ans += n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( x [ i ] ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += sum ( 1 for k in y [ i ] if x [ i ] [ j ] < k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
[ n , k ] = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i - k ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <NL> def print2d ( m ) : <NEWLINE> <INDENT> for r in m : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> . format ( x ) for x in r ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( [ int ( x ) for x in sys . stdin . readline ( ) . split ( <STRING> ) ] ) <NEWLINE> <DEDENT> for r in range ( n ) : <NEWLINE> <INDENT> m [ r ] . append ( sum ( m [ r ] ) ) <NEWLINE> <DEDENT> lastRow = [ ] <NEWLINE> for c in range ( n + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for r in range ( n ) : <NEWLINE> <INDENT> s += m [ r ] [ c ] <NEWLINE> <DEDENT> lastRow . append ( s ) <NEWLINE> <DEDENT> m . append ( lastRow ) <NEWLINE> print2d ( m ) <NEWLINE> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ax = [ 0 ] * ( n + 1 ) <NEWLINE> bx = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ax [ i ] = ax [ i - 1 ] + a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> bx [ i ] = bx [ i - 1 ] + b [ i - 1 ] <NEWLINE> <NL> <DEDENT> c = bisect . bisect_right ( ax , k ) <NEWLINE> ma = 0 <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> d = bisect . bisect_right ( bx , k - ax [ i ] ) <NEWLINE> ma = max ( ma , i + d - 1 ) <NEWLINE> <DEDENT> print ( ma ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> Mh = [ 0 ] * H <NEWLINE> Mw = [ 0 ] * W <NEWLINE> B = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> Mh [ h - 1 ] += 1 <NEWLINE> Mw [ w - 1 ] += 1 <NEWLINE> B . append ( ( h - 1 , w - 1 ) ) <NEWLINE> <NL> <DEDENT> nh = max ( Mh ) <NEWLINE> nw = max ( Mw ) <NEWLINE> <NL> <COMMENT> <NL> lh = Counter ( Mh ) [ nh ] <NEWLINE> lw = Counter ( Mw ) [ nw ] <NEWLINE> <NL> out = 0 <NEWLINE> for ( h , w ) in B : <NEWLINE> <INDENT> if Mh [ h ] == nh and Mw [ w ] == nw : <NEWLINE> <INDENT> out += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if out == lh * lw : <NEWLINE> <INDENT> print ( nh + nw - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nh + nw ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , a = int ( input ( ) ) , <STRING> <NEWLINE> while 0 < N : N -= 1 ; a += chr ( ord ( <STRING> ) + N % 26 ) ; N //= 26 <NEWLINE> print ( a [ : : - 1 ] ) <NEWLINE>
v = input ( ) . split ( <STRING> ) <NEWLINE> x = int ( v [ 0 ] ) <NEWLINE> k = int ( v [ 1 ] ) <NEWLINE> d = int ( v [ 2 ] ) <NEWLINE> <NL> if ( x == 0 ) : <NEWLINE> <INDENT> if ( k % 2 == 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = d <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( ( k * d ) > abs ( x ) ) : <NEWLINE> <INDENT> y = abs ( x ) // d <NEWLINE> ans = abs ( abs ( x ) - y * d ) <NEWLINE> if ( ( k - y ) % 2 == 1 ) : <NEWLINE> <INDENT> ans = abs ( d - ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( x ) - k * d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
print ( <STRING> , <STRING> . join ( [ str ( x ) for x in range ( 1 , int ( input ( ) ) + 1 ) <NEWLINE> <INDENT> if x % 3 == 0 or <STRING> in str ( x ) ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a = sorted ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) ; <NEWLINE> q = int ( input ( ) ) <NEWLINE> aa = 0 ; <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa += a [ i ] ; <NEWLINE> <NL> <DEDENT> b = [ input ( ) . split ( ) for l in range ( q ) ] <NEWLINE> <NL> bu = [ 0 ] * ( 100000 ) ; <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> bu [ a [ i ] - 1 ] += 1 ; <NEWLINE> <NL> <DEDENT> for x in range ( q ) : <NEWLINE> <INDENT> c = int ( b [ x ] [ 0 ] ) <NEWLINE> d = int ( b [ x ] [ 1 ] ) <NEWLINE> aa += ( d - c ) * ( bu [ c - 1 ] ) ; <NEWLINE> bu [ d - 1 ] += bu [ c - 1 ] ; <NEWLINE> bu [ c - 1 ] = 0 ; <NEWLINE> print ( aa ) ; <NEWLINE> <DEDENT>
<COMMENT> <NL> x = float ( input ( ) ) <NEWLINE> print ( 3.141592653589793 * x ** 2 , 3.141592653589793 * 2 * x ) <NEWLINE>
<STRING> <NEWLINE> <NL> from numpy import ceil , array , sum <NEWLINE> import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def is_ok ( m ) : <NEWLINE> <INDENT> tmp = h - m * B <NEWLINE> tmp [ tmp < 0 ] = 0 <NEWLINE> <NL> if ceil ( tmp / ( A - B ) ) . sum ( ) > m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> h = array ( list ( int ( input ( ) ) for _ in range ( N ) ) ) <NEWLINE> <COMMENT> <NL> <NL> r = 10 ** 9 <NEWLINE> l = 0 <NEWLINE> <NL> while abs ( l - r ) > 1 : <NEWLINE> <NL> <INDENT> m = ( r + l ) // 2 <NEWLINE> <NL> if is_ok ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def count ( nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _count ( i , j ) : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> mid = ( i + j ) // 2 <NEWLINE> i1 , li1 = _count ( i , mid ) <NEWLINE> i2 , li2 = _count ( mid + 1 , j ) <NEWLINE> <NL> return _merge ( li1 , li2 , i1 + i2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 0 , nums [ i : i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _merge ( li1 , li2 , invs ) : <NEWLINE> <INDENT> i = j = 0 <NEWLINE> result = [ ] <NEWLINE> sums = inv = 0 <NEWLINE> while i < len ( li1 ) and j < len ( li2 ) : <NEWLINE> <INDENT> if li1 [ i ] > li2 [ j ] : <NEWLINE> <INDENT> result . append ( li2 [ j ] ) <NEWLINE> inv += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( li1 [ i ] ) <NEWLINE> invs += sums + inv <NEWLINE> sums += inv <NEWLINE> inv = 0 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while i < len ( li1 ) : <NEWLINE> <INDENT> result . append ( li1 [ i ] ) <NEWLINE> invs += sums + inv <NEWLINE> sums += inv <NEWLINE> inv = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if j < len ( li2 ) : <NEWLINE> <INDENT> result . extend ( li2 [ j : ] ) <NEWLINE> <NL> <DEDENT> return ( invs , result ) <NEWLINE> <NL> <DEDENT> invs , _ = _count ( 0 , len ( nums ) ) <NEWLINE> return invs <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <COMMENT> <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( count ( nums ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> def readstr ( ) : return readline ( ) . rstrip ( ) . decode ( ) <NEWLINE> def readstrs ( ) : return list ( readline ( ) . decode ( ) . split ( ) ) <NEWLINE> def readint ( ) : return int ( readline ( ) ) <NEWLINE> def readints ( ) : return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> def printrows ( x ) : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> def printline ( x ) : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <NL> from itertools import accumulate <NEWLINE> <NL> def circle_sum_max ( circle , num ) : <NEWLINE> <INDENT> n = len ( circle ) <NEWLINE> s = sum ( circle ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif num == 1 : <NEWLINE> <INDENT> ans = max ( circle ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ac = list ( accumulate ( [ 0 ] + circle ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = 1 <NEWLINE> ans = ac [ r ] - ac [ l ] <NEWLINE> i = 0 <NEWLINE> while r != n or i % 2 == 1 : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> r = ac [ r + 1 : l + num + 1 ] . index ( max ( ac [ r + 1 : l + num + 1 ] ) ) + r + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = ac [ l + 1 : r ] . index ( min ( ac [ l + 1 : r ] ) ) + l + 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> ans = max ( ans , ac [ r ] - ac [ l ] ) <NEWLINE> <NL> <DEDENT> num = n - num <NEWLINE> l = 0 <NEWLINE> r = num <NEWLINE> i = 0 <NEWLINE> ans = max ( ans , s - ac [ r ] + ac [ l ] ) <NEWLINE> while r != n or i % 2 == 1 : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> r = ac [ r + 1 : l + n ] . index ( min ( ac [ r + 1 : l + n ] ) ) + r + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = ac [ l + 1 : r - num + 1 ] . index ( max ( ac [ l + 1 : r - num + 1 ] ) ) + l + 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> ans = max ( ans , s - ac [ r ] + ac [ l ] ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n , k = readints ( ) <NEWLINE> p = [ x - 1 for x in readints ( ) ] <NEWLINE> c = readints ( ) <NEWLINE> <NL> circles = [ ] <NEWLINE> used = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if not used [ i ] : <NEWLINE> <INDENT> circles . append ( [ c [ i ] ] ) <NEWLINE> used [ i ] = 1 <NEWLINE> j = p [ i ] <NEWLINE> while not used [ j ] : <NEWLINE> <INDENT> circles [ - 1 ] . append ( c [ j ] ) <NEWLINE> used [ j ] = 1 <NEWLINE> j = p [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> score = - 10 ** 20 <NEWLINE> <NL> for cir in circles : <NEWLINE> <INDENT> m = len ( cir ) <NEWLINE> a = sum ( cir ) <NEWLINE> if k > m : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> score = max ( score , ( k // m ) * a + circle_sum_max ( cir , k % m ) , ( k // m - 1 ) * a + circle_sum_max ( cir , m ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = max ( score , circle_sum_max ( cir , m ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> score = max ( score , circle_sum_max ( cir , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( score ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> A = [ [ [ 0 for k in range ( 10 ) ] for j in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> format ( A ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for m in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> S = A [ b - 1 ] [ f - 1 ] [ r - 1 ] + v <NEWLINE> A [ b - 1 ] [ f - 1 ] [ r - 1 ] = S <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , A [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i <NEWLINE> while j > 0 : <NEWLINE> <INDENT> if j % 10 == 3 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j //= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in l : <NEWLINE> <INDENT> print ( <STRING> + str ( p ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s [ 0 ] == s [ n - 1 ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] and d == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> d = 0 <NEWLINE> <DEDENT> elif s [ i - 1 ] == s [ i ] and d == 0 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> <DEDENT> if d == 0 : <NEWLINE> <INDENT> print ( ans * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] and d == 1 : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> d = 0 <NEWLINE> <DEDENT> elif s [ i - 1 ] == s [ i ] and d == 0 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> <DEDENT> if d == 1 : <NEWLINE> <INDENT> print ( ans + ans2 * ( k - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( ( ans + ans2 ) * k // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ans + ans2 ) * ( k // 2 ) + ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif s [ 0 ] != s [ n - 1 ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] and d == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> d = 0 <NEWLINE> <DEDENT> elif s [ i - 1 ] == s [ i ] and d == 0 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] != s [ i ] : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * k ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> data = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> data [ i ] = int ( data [ i ] ) <NEWLINE> if data [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> res = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res *= data [ i ] <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> u = [ ] <NEWLINE> v = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> u . append ( x + y ) <NEWLINE> v . append ( x - y ) <NEWLINE> <DEDENT> ans = max ( max ( u ) - min ( u ) , max ( v ) - min ( v ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> B , C = [ list ( i ) for i in zip ( * BC ) ] <NEWLINE> sum = 0 <NEWLINE> D = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> D [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> D [ C [ i ] ] += D [ B [ i ] ] <NEWLINE> sum += D [ B [ i ] ] * ( C [ i ] - B [ i ] ) <NEWLINE> D [ B [ i ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> judge_str = { True : <STRING> , False : <STRING> } <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> print ( judge_str [ A [ i - K - 1 ] < A [ i - 1 ] ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = tuple ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = tuple ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> <NL> def binary_search ( array , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> size = len ( array ) <NEWLINE> start = 0 <NEWLINE> end = size - 1 <NEWLINE> found = False <NEWLINE> while True : <NEWLINE> <INDENT> middle = ( start + end ) // 2 <NEWLINE> <COMMENT> <NL> v = array [ middle ] <NEWLINE> if v == value : <NEWLINE> <COMMENT> <NL> <INDENT> return True <NEWLINE> <DEDENT> elif start == end : <NEWLINE> <COMMENT> <NL> <INDENT> return False <NEWLINE> <DEDENT> elif v > value : <NEWLINE> <COMMENT> <NL> <INDENT> end = middle <NEWLINE> <DEDENT> elif v < value : <NEWLINE> <COMMENT> <NL> <INDENT> start = middle + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if binary_search ( s , t [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def quick_sort ( plices ) : <NEWLINE> <INDENT> if len ( plices ) == 1 : <NEWLINE> <INDENT> return plices <NEWLINE> <NL> <NL> <DEDENT> cri = plices [ 0 ] <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> <NL> for i in range ( 1 , len ( plices ) ) : <NEWLINE> <INDENT> if plices [ i ] < cri : <NEWLINE> <INDENT> left . append ( plices [ i ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> right . append ( plices [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> left . append ( cri ) <NEWLINE> <NL> return quick_sort ( left ) + quick_sort ( right ) <NEWLINE> <NL> <DEDENT> def cal_sum ( sorted_plices , K ) : <NEWLINE> <INDENT> min_sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> min_sum += sorted_plices [ i ] <NEWLINE> <NL> <DEDENT> return min_sum <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> N , K = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> plices = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> sorted_plices = sorted ( plices ) <NEWLINE> <COMMENT> <NL> min_sum = cal_sum ( sorted_plices , K ) <NEWLINE> <NL> print ( min_sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> area = sum ( l ) * sum ( l ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> area -= i * i <NEWLINE> <NL> <DEDENT> ans = area // 2 <NEWLINE> ans = ans % mod <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> count *= i <NEWLINE> if 10 ** 18 < count : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 10 ** 18 < count : <NEWLINE> <INDENT> count = - 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
[ A , B , N ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N < B - 1 : <NEWLINE> <INDENT> print ( A * N // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A * ( B - 1 ) // B ) <NEWLINE> <NL> <NL> <DEDENT>
import heapq <NEWLINE> <NL> l = input ( ) . split ( ) <NEWLINE> V = int ( l [ 0 ] ) <NEWLINE> E = int ( l [ 1 ] ) <NEWLINE> r = int ( l [ 2 ] ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> graph [ int ( l [ 0 ] ) ] . append ( ( int ( l [ 2 ] ) , int ( l [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> heap = [ ( 0 , r ) ] <NEWLINE> dist = [ float ( <STRING> ) for _ in range ( V ) ] <NEWLINE> while heap : <NEWLINE> <INDENT> pop = heapq . heappop ( heap ) <NEWLINE> if dist [ pop [ 1 ] ] < pop [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ pop [ 1 ] ] = pop [ 0 ] <NEWLINE> for ( w , i ) in graph [ pop [ 1 ] ] : <NEWLINE> <INDENT> if i != pop [ 1 ] and w >= 0 and dist [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> heapq . heappush ( heap , ( pop [ 0 ] + w , i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for d in dist : <NEWLINE> <INDENT> if d == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT>
x1 , y1 , x2 , y2 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 <NEWLINE> <NL> print ( d ) <NEWLINE>
def greatest_common_divisor ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return greatest_common_divisor ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( greatest_common_divisor ( x , y ) ) <NEWLINE> <DEDENT>
def kruskal ( g , size ) : <NEWLINE> <INDENT> g . sort ( key = itemgetter ( 2 ) , reverse = True ) <NEWLINE> uf = union_find ( size ) <NEWLINE> tree = [ ] <NEWLINE> while len ( tree ) < size - 1 : <NEWLINE> <INDENT> u , v , d = g . pop ( ) <NEWLINE> if not uf . union ( u , v ) : <NEWLINE> <INDENT> tree . append ( ( u , v , d ) ) <NEWLINE> <DEDENT> <DEDENT> return tree <NEWLINE> <NL> <DEDENT> class union_find : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . table = [ - 1 for _ in range ( size ) ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return True <NEWLINE> <NL> if self . table [ y ] < self . table [ x ] : x , y = y , x <NEWLINE> <NL> self . table [ x ] += self . table [ y ] <NEWLINE> self . table [ y ] = x <NEWLINE> return False <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . table [ x ] < 0 : return x <NEWLINE> self . table [ x ] = self . find ( self . table [ x ] ) <NEWLINE> return self . table [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> from sys import stdin <NEWLINE> from operator import itemgetter <NEWLINE> <NL> import heapq <NEWLINE> <NL> readline = stdin . readline <NEWLINE> <NL> <NL> v , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> g = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( e ) ] <NEWLINE> <NL> tree = kruskal ( g , v ) <NEWLINE> <NL> print ( sum ( d for s , t , d in tree ) ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> X = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> X = sorted ( X , reverse = True ) <NEWLINE> <NL> S = sum ( X [ : K ] ) <NEWLINE> <NL> ans = N - S <NEWLINE> <NL> print ( ans ) <NEWLINE>
T = input ( ) <NEWLINE> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Query = [ input ( ) . split ( ) for q in range ( Q ) ] <NEWLINE> cnt = 0 <NEWLINE> prefix , suffix = <STRING> , <STRING> <NEWLINE> for q in Query : <NEWLINE> <INDENT> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt = 1 ^ cnt <NEWLINE> prefix , suffix = suffix , prefix <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> : <NEWLINE> <INDENT> prefix = prefix + q [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suffix = suffix + q [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> print ( prefix [ : : - 1 ] + S + suffix ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> pw = <STRING> <NEWLINE> for i in range ( len ( o ) + len ( e ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> pw = pw + o [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pw = pw + e [ i // 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( pw ) <NEWLINE>
input ( ) <NEWLINE> cards = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> a = sum ( cards [ 1 : ] ) <NEWLINE> s = cards [ 0 ] <NEWLINE> diff_min = abs ( a - s ) <NEWLINE> <NL> for card in cards [ 1 : - 1 ] : <NEWLINE> <INDENT> a -= card <NEWLINE> s += card <NEWLINE> diff_min = min ( diff_min , abs ( a - s ) ) <NEWLINE> <NL> <DEDENT> print ( diff_min ) <NEWLINE>
import sys <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1000 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 101 , - 101 , - 1 ) : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> if len ( p ) == len ( set ( p ) ) : <NEWLINE> <INDENT> if res >= abs ( x - i ) : <NEWLINE> <INDENT> res = abs ( x - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> del p [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = ( n + 1 ) // b <NEWLINE> c = p * b - 1 <NEWLINE> if c < 0 : <NEWLINE> <INDENT> print ( a * n // b - a * ( n // b ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = max ( a * n // b - a * ( n // b ) , a * c // b - a * ( c // b ) ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> num = list ( range ( 1 , n + 1 ) ) <NEWLINE> num = np . array ( num ) <NEWLINE> x = n // num <NEWLINE> ans = num * ( x + 1 ) * x / 2 <NEWLINE> print ( int ( np . sum ( ans ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , * v = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> vo = Counter ( v [ : : 2 ] ) <NEWLINE> ve = Counter ( v [ 1 : : 2 ] ) <NEWLINE> vo_mc = vo . most_common ( ) [ 0 ] <NEWLINE> ve_mc = ve . most_common ( ) [ 0 ] <NEWLINE> if vo_mc [ 0 ] == ve_mc [ 0 ] : <NEWLINE> <INDENT> if vo_mc [ 1 ] > ve_mc [ 1 ] : <NEWLINE> <INDENT> ans = n // 2 - vo_mc [ 1 ] <NEWLINE> if ve_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans += n // 2 - ve . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // 2 <NEWLINE> <DEDENT> <DEDENT> elif vo_mc [ 1 ] < ve_mc [ 1 ] : <NEWLINE> <INDENT> ans = n // 2 - ve_mc [ 1 ] <NEWLINE> if vo_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans += n // 2 - vo . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = n <NEWLINE> if ve_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans = min ( n // 2 - vo_mc [ 1 ] + n // 2 - ve . most_common ( ) [ 1 ] [ 1 ] , ans ) <NEWLINE> <DEDENT> if vo_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans = min ( n // 2 - vo . most_common ( ) [ 1 ] [ 1 ] + n // 2 - ve_mc [ 1 ] , ans ) <NEWLINE> <DEDENT> ans = min ( n // 2 - vo_mc [ 1 ] + n // 2 , ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = n // 2 - vo_mc [ 1 ] + n // 2 - ve_mc [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> s = max ( 4 , n - 2 ) <NEWLINE> import math <NEWLINE> t = math . sqrt ( s ) <NEWLINE> t = math . floor ( t ) <NEWLINE> for i in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> for j in range ( i , t + 2 ) : <NEWLINE> <INDENT> for k in range ( j , t + 3 ) : <NEWLINE> <INDENT> x = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if x <= n : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans [ x - 1 ] += 1 <NEWLINE> <DEDENT> elif i == j != k or i != j == k or i == k != j : <NEWLINE> <INDENT> ans [ x - 1 ] += 3 <NEWLINE> <DEDENT> elif i != k != j : <NEWLINE> <INDENT> ans [ x - 1 ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import Counter , defaultdict , deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> import sys , math , itertools , fractions , pprint <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> keta = 1 <NEWLINE> su = 0 <NEWLINE> while True : <NEWLINE> <INDENT> su += 26 ** keta <NEWLINE> if su >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> keta += 1 <NEWLINE> <DEDENT> n -= su - pow ( 26 , keta ) + 1 <NEWLINE> <COMMENT> <NL> res = [ ] <NEWLINE> for i in range ( keta ) : <NEWLINE> <INDENT> now = keta - i - 1 <NEWLINE> d , m = divmod ( n , pow ( 26 , now ) ) <NEWLINE> res . append ( chr ( ord ( <STRING> ) + d ) ) <NEWLINE> n = m <NEWLINE> <DEDENT> print ( <STRING> . join ( res ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num = sorted ( [ int ( e ) for e in input ( ) . split ( <STRING> ) ] ) <NEWLINE> lim = 10 ** 18 <NEWLINE> i = - 1 <NEWLINE> ans = 1 <NEWLINE> for a in num : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ( ans > lim ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( ans == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
class Combination : <NEWLINE> <INDENT> def __init__ ( self , n , mod ) : <NEWLINE> <INDENT> self . fact = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> self . fact . append ( self . fact [ - 1 ] * i % mod ) <NEWLINE> <DEDENT> self . inv_fact = [ 0 ] * ( n + 1 ) <NEWLINE> self . inv_fact [ n ] = pow ( self . fact [ n ] , mod - 2 , mod ) <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> self . inv_fact [ i ] = self . inv_fact [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> self . mod = mod <NEWLINE> <NL> <DEDENT> def factorial ( self , k ) : <NEWLINE> <NL> <INDENT> return self . fact [ k ] <NEWLINE> <NL> <DEDENT> def inverse_factorial ( self , k ) : <NEWLINE> <INDENT> return self . inv_fact [ k ] <NEWLINE> <NL> <DEDENT> def permutation ( self , k , r ) : <NEWLINE> <INDENT> if k < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return ( self . fact [ k ] * self . inv_fact [ k - r ] ) % self . mod <NEWLINE> <NL> <DEDENT> def combination ( self , k , r ) : <NEWLINE> <INDENT> if k < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return ( self . fact [ k ] * self . inv_fact [ k - r ] * self . inv_fact [ r ] ) % self . mod <NEWLINE> <NL> <DEDENT> def combination_large ( self , k , r ) : <NEWLINE> <INDENT> if k < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = 1 <NEWLINE> for l in range ( r ) : <NEWLINE> <INDENT> res *= ( k - l ) <NEWLINE> res %= self . mod <NEWLINE> <DEDENT> return ( res * self . inv_fact [ r ] ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> cmb = Combination ( 10 ** 6 , mod ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += m * cmb . combination ( n - 1 , i ) * pow ( m - 1 , n - 1 - i , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x = a [ i ] * x <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x if x <= 10 ** 18 else - 1 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> sys . setrecursionlimit ( pow ( 10 , 6 ) ) <NEWLINE> <NL> def set_route ( start , goal ) : <NEWLINE> <INDENT> global routes <NEWLINE> <NL> routes [ goal ] . append ( start ) <NEWLINE> <NL> <NL> <DEDENT> def search ( que ) : <NEWLINE> <INDENT> global routes <NEWLINE> global guides <NEWLINE> <NL> if len ( que ) > 0 : <NEWLINE> <INDENT> goal = que . popleft ( ) <NEWLINE> <NL> for start in routes [ goal ] : <NEWLINE> <INDENT> if guides [ start ] == 0 : <NEWLINE> <INDENT> guides [ start ] = goal <NEWLINE> que . append ( start ) <NEWLINE> <NL> <DEDENT> <DEDENT> search ( que ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> routes = dict ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> routes [ i ] = [ ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> set_route ( a , b ) <NEWLINE> set_route ( b , a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> guides = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( 1 ) <NEWLINE> search ( que ) <NEWLINE> <NL> ans = guides [ 2 : ] <NEWLINE> <NL> if 0 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> A = [ 0 ] * 1000000 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> A [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans + ( ( c - b ) * ( A [ b ] ) ) <NEWLINE> print ( ans ) <NEWLINE> A [ c ] += A [ b ] <NEWLINE> A [ b ] = 0 <NEWLINE> <DEDENT>
def kmpTable ( w ) : <NEWLINE> <INDENT> lw = len ( w ) <NEWLINE> nx = [ - 1 ] * ( lw + 1 ) <NEWLINE> j = - 1 <NEWLINE> for i in range ( lw ) : <NEWLINE> <INDENT> while j >= 0 and w [ i ] != w [ j ] : <NEWLINE> <INDENT> j = nx [ j ] <NEWLINE> <DEDENT> j += 1 <NEWLINE> nx [ i + 1 ] = j <NEWLINE> <DEDENT> return tuple ( nx ) <NEWLINE> <DEDENT> def kmpSearch ( s , w ) : <NEWLINE> <INDENT> ls = len ( s ) <NEWLINE> start = 0 <NEWLINE> w_idx = 0 <NEWLINE> ret = [ ] <NEWLINE> nx = kmpTable ( w ) <NEWLINE> while start + w_idx < ls : <NEWLINE> <INDENT> if s [ start + w_idx ] == w [ w_idx ] : <NEWLINE> <INDENT> w_idx += 1 <NEWLINE> if w_idx == len ( w ) : <NEWLINE> <INDENT> ret . append ( start ) <NEWLINE> start = start + w_idx - nx [ w_idx ] <NEWLINE> w_idx = nx [ w_idx ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if w_idx == 0 : <NEWLINE> <INDENT> start += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = start + w_idx - nx [ w_idx ] <NEWLINE> w_idx = nx [ w_idx ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return tuple ( ret ) <NEWLINE> <DEDENT> T = input ( ) <NEWLINE> P = input ( ) <NEWLINE> ans = kmpSearch ( T , P ) <NEWLINE> <NL> if ans : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> s = input ( ) <NEWLINE> for j in s : <NEWLINE> <INDENT> temp += ( 12 ** ( ord ( j ) - ord ( <STRING> ) + 1 ) ) <NEWLINE> <DEDENT> dic . setdefault ( temp , 0 ) <NEWLINE> dic [ temp ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> res = 0 <NEWLINE> for i in dic : <NEWLINE> <INDENT> if dic [ i ] >= 2 : <NEWLINE> <INDENT> res += ( ( dic [ i ] * ( dic [ i ] - 1 ) ) // 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in A : <NEWLINE> <INDENT> K *= num <NEWLINE> if K > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( K ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> X , Y , H = [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( x ) , Y . append ( y ) , H . append ( h ) <NEWLINE> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for x , y , h in zip ( X , Y , H ) : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> hh = h + abs ( x - cx ) + abs ( y - cy ) <NEWLINE> res . append ( hh ) <NEWLINE> <DEDENT> if len ( set ( res ) ) == 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> for x , y , h in zip ( X , Y , H ) : <NEWLINE> <INDENT> if h != max ( res [ 0 ] - abs ( x - cx ) - abs ( y - cy ) , 0 ) : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( cx , cy , res [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = X <NEWLINE> A = X <NEWLINE> TF = True <NEWLINE> srt = 1000000 <NEWLINE> retu = [ X ] <NEWLINE> d = dict ( ) <NEWLINE> d [ X ] = 0 <NEWLINE> loop = X <NEWLINE> flag = False <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if TF : <NEWLINE> <INDENT> A = A ** 2 % M <NEWLINE> if d . get ( A ) != None : <NEWLINE> <INDENT> srt = d [ A ] <NEWLINE> goal = i <NEWLINE> TF = False <NEWLINE> <NL> <DEDENT> if TF : <NEWLINE> <INDENT> retu . append ( A ) <NEWLINE> d [ A ] = i + 1 <NEWLINE> loop += A <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> n = ( N - srt ) // ( goal - srt + 1 ) <NEWLINE> saisyo = sum ( retu [ : srt ] ) <NEWLINE> loop -= saisyo <NEWLINE> print ( saisyo + loop * n + sum ( retu [ srt : N - n * ( goal - srt + 1 ) ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( retu [ : N ] ) ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> if X . count ( <STRING> ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> base_1_count = X . count ( <STRING> ) <NEWLINE> if base_1_count == 0 : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> X_int = int ( X , 2 ) <NEWLINE> X_int_p = X_int % ( base_1_count + 1 ) <NEWLINE> <NL> <COMMENT> <NL> if base_1_count == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> Xi = X_int_p + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xi = X_int_p <NEWLINE> <DEDENT> count = 1 <NEWLINE> while Xi != 0 : <NEWLINE> <INDENT> Xi %= bin ( Xi ) . count ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> X_int_m = X_int % ( base_1_count - 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> temp_1_count = base_1_count - 1 <NEWLINE> pow_2 = pow ( 2 , N - i - 1 , base_1_count - 1 ) <NEWLINE> if X_int_m <= pow_2 : <NEWLINE> <INDENT> Xi = X_int_m - pow_2 + base_1_count - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xi = X_int_m - pow_2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp_1_count = base_1_count + 1 <NEWLINE> Xi = X_int_p + pow ( 2 , N - i - 1 , base_1_count + 1 ) <NEWLINE> while Xi >= base_1_count + 1 : <NEWLINE> <INDENT> Xi %= base_1_count + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if temp_1_count == Xi : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> while Xi != 0 : <NEWLINE> <INDENT> num_of_1 = bin ( Xi ) . count ( <STRING> ) <NEWLINE> Xi %= num_of_1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i1 in range ( n - 2 ) : <NEWLINE> <INDENT> for i2 in range ( i1 + 1 , n - 1 ) : <NEWLINE> <INDENT> k = i2 * 2 - i1 <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i1 ] != s [ i2 ] and s [ i1 ] != s [ k ] and s [ i2 ] != s [ k ] : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> prenodes = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> G = [ [ ] for i in range ( n ) ] <NEWLINE> ab = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> G [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> G [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> prenodes [ 0 ] = 0 <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> <NL> while len ( que ) != 0 : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> <NL> for vi in G [ v ] : <NEWLINE> <INDENT> if prenodes [ vi ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . append ( vi ) <NEWLINE> <COMMENT> <NL> prenodes [ vi ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if prenodes [ i ] == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( prenodes [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> p = 2019 <NEWLINE> ans = [ 0 ] * p <NEWLINE> <NL> x10 , S = 1 , 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> S += x10 * int ( i ) <NEWLINE> S %= p <NEWLINE> x10 *= 10 <NEWLINE> x10 %= p <NEWLINE> ans [ S ] += 1 <NEWLINE> <NL> <DEDENT> cnt = ans [ 0 ] <NEWLINE> for a in ans : <NEWLINE> <INDENT> cnt += ( a * ( a - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> a = p [ 0 ] <NEWLINE> for x in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ x ] <= a : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = p [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_list = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> y = np . argsort ( a_list ) <NEWLINE> if a_list [ y [ 0 ] ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flag = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans *= int ( a_list [ y [ n - 1 - i ] ] ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if abs ( A - B ) <= ( V - W ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif R - L == 1 : <NEWLINE> <INDENT> print ( ( R * L ) % 2019 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 4000 <NEWLINE> <NL> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> number = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , number ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> nbOperation = 0 <NEWLINE> <NL> sentenceS = list ( input ( ) ) <NEWLINE> sentenceToT = input ( ) <NEWLINE> <NL> for i in range ( len ( sentenceS ) ) : <NEWLINE> <INDENT> if sentenceS [ i ] != sentenceToT [ i ] : <NEWLINE> <NL> <INDENT> sentenceS [ i ] = sentenceToT [ i ] <NEWLINE> nbOperation += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( nbOperation ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> dp = [ 0 for _ in range ( a [ - 1 ] + 1 ) ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> for j in range ( x , a [ - 1 ] + 1 , x ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in set ( a ) : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = range ( 1 , k + 1 ) <NEWLINE> <NL> for a , b , c in combinations_with_replacement ( l , 3 ) : <NEWLINE> <INDENT> ans = gcd ( a , b , c ) <NEWLINE> if a == b and a == c : <NEWLINE> <INDENT> sum += ans <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> sum += 3 * ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += 6 * ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = [ 1 ] * ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ls [ a - 1 ] > ls [ b - 1 ] : <NEWLINE> <INDENT> pos [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif ls [ a - 1 ] < ls [ b - 1 ] : <NEWLINE> <INDENT> pos [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos [ a - 1 ] = 0 <NEWLINE> pos [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( pos ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> room_list = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> room_list [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> output = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> output = list ( map ( str , room_list [ i ] [ j ] ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( output ) ) <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ i - 1 for i in a ] <NEWLINE> <NL> d = [ 1 ] * n <NEWLINE> p = 0 <NEWLINE> b = [ ] <NEWLINE> while d [ p ] : <NEWLINE> <INDENT> b . append ( p ) <NEWLINE> d [ p ] = 0 <NEWLINE> p = a [ p ] <NEWLINE> <DEDENT> avant = b . index ( p ) <NEWLINE> loop_count = len ( b ) - avant <NEWLINE> c = b [ avant : ] <NEWLINE> <NL> if k <= avant : <NEWLINE> <INDENT> print ( b [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= avant <NEWLINE> k %= loop_count <NEWLINE> print ( c [ k ] + 1 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> k = K <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> k *= i <NEWLINE> if k >= A and k <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> a = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = K <NEWLINE> a = False <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if a != True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> def isPrime ( number ) : <NEWLINE> <INDENT> for i in range ( 2 , math . floor ( math . sqrt ( number ) ) + 1 ) : <NEWLINE> <INDENT> if number % ( i ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> numbers . append ( int ( input ( ) ) ) <NEWLINE> pass <NEWLINE> <DEDENT> count = 0 <NEWLINE> for number in numbers : <NEWLINE> <INDENT> if isPrime ( number ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> if ab == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S1 = list ( input ( ) ) <NEWLINE> S2 = list ( input ( ) ) <NEWLINE> <NL> if len ( S1 ) == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif len ( S1 ) == 2 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S1 [ 0 ] != S2 [ 0 ] : <NEWLINE> <INDENT> t = 2 <NEWLINE> i = 2 <NEWLINE> a = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 1 <NEWLINE> i = 1 <NEWLINE> a = 3 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if S1 [ i ] != S2 [ i ] : <NEWLINE> <INDENT> if t == 2 : <NEWLINE> <INDENT> a *= 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a *= 2 <NEWLINE> <DEDENT> i += 2 <NEWLINE> t = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t == 2 : <NEWLINE> <INDENT> a *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a *= 2 <NEWLINE> <DEDENT> i += 1 <NEWLINE> t = 1 <NEWLINE> <DEDENT> a %= 1000000007 <NEWLINE> if i == len ( S1 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] <NEWLINE> s = set ( ) <NEWLINE> s . add ( 0 ) <NEWLINE> cur = a [ 0 ] - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if cur in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( cur ) <NEWLINE> l . append ( cur ) <NEWLINE> cur = a [ cur ] - 1 <NEWLINE> <DEDENT> <DEDENT> i = l . index ( cur ) <NEWLINE> if k <= i : <NEWLINE> <INDENT> print ( l [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ ( k - i ) % ( len ( l ) - i ) + i ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> cnt = A [ 0 ] - 1 <NEWLINE> cant_use = 1 <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> wk = a <NEWLINE> if wk == cant_use + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> cant_use += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if wk % ( cant_use + 1 ) == 0 : <NEWLINE> <INDENT> wk -= cant_use + 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> cnt += wk // ( cant_use + 1 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( - 100 , 102 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> L = [ ] <NEWLINE> for i in l : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> l = [ ] <NEWLINE> for i in L : <NEWLINE> <INDENT> l . append ( [ i , abs ( x - i ) ] ) <NEWLINE> <DEDENT> a = min ( l , key = lambda t : t [ 1 ] ) <NEWLINE> print ( list ( a ) [ 0 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> path = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ a - 1 ] . append ( b ) <NEWLINE> path [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> d = deque ( [ 0 ] ) <NEWLINE> dis = [ - 1 for _ in range ( n ) ] <NEWLINE> dis [ 0 ] = 0 <NEWLINE> <NL> while d : <NEWLINE> <INDENT> hop = d . popleft ( ) <NEWLINE> for i in path [ hop ] : <NEWLINE> <INDENT> if dis [ i - 1 ] == - 1 : <NEWLINE> <INDENT> d . append ( i - 1 ) <NEWLINE> dis [ i - 1 ] = hop + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in dis : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( dis ) ) : <NEWLINE> <INDENT> print ( dis [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . array ( a ) <NEWLINE> a += np . arange ( n ) + 1 <NEWLINE> b -= np . arange ( n ) + 1 <NEWLINE> b *= - 1 <NEWLINE> a = np . sort ( a ) <NEWLINE> b = np . sort ( b ) <NEWLINE> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> l = np . searchsorted ( b , i , side = <STRING> ) <NEWLINE> r = np . searchsorted ( b , i , side = <STRING> ) <NEWLINE> c += r - l <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
from itertools import permutations , accumulate , combinations , combinations_with_replacement <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] -= 1 <NEWLINE> b [ i ] -= 1 <NEWLINE> <DEDENT> for A in combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] ] - A [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sum_A = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans += i * ( sum_A : = sum_A - i ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> x = l // 2019 <NEWLINE> if 2019 * x < l and r < 2019 * ( x + 1 ) : <NEWLINE> <INDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> power = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power %= mod <NEWLINE> <DEDENT> print ( power ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> original_pop_count = x . count ( <STRING> ) <NEWLINE> one_pop_count = original_pop_count - 1 <NEWLINE> zero_pop_count = original_pop_count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_pop_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_pop_count <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> pop_count = [ 0 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> pop_count [ i ] = pop_count [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % pop_count [ i ] ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> one_pow2 = [ 1 ] * 220000 <NEWLINE> zero_pow2 = [ 1 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> one_pow2 [ i ] = one_pow2 [ i - 1 ] * 2 % one_pop_count <NEWLINE> <DEDENT> zero_pow2 [ i ] = zero_pow2 [ i - 1 ] * 2 % zero_pop_count <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= one_pow2 [ i ] <NEWLINE> nxt %= one_pop_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += zero_pow2 [ i ] <NEWLINE> nxt %= zero_pop_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> from typing import Iterable <NEWLINE> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> N = ri ( ) <NEWLINE> A = rmi ( ) <NEWLINE> num = tuple ( range ( 1 , N + 1 ) ) <NEWLINE> cand = 0 <NEWLINE> log = { } <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if i + 1 - A [ i ] in log : <NEWLINE> <INDENT> cand += log [ i + 1 - A [ i ] ] <NEWLINE> <DEDENT> if i + 1 + A [ i ] in log : <NEWLINE> <INDENT> log [ i + 1 + A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log [ i + 1 + A [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> w ( cand ) <NEWLINE> <NL> <NL> <DEDENT> def r ( ) -> str : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def ri ( ) -> int : <NEWLINE> <INDENT> return int ( r ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rmi ( delim : str = <STRING> ) -> int : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( delim ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def w ( data ) -> None : <NEWLINE> <INDENT> print ( data ) <NEWLINE> <NL> <NL> <DEDENT> def wm ( data : Iterable ) -> None : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , data ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> N = ir ( ) <NEWLINE> A = lr ( ) <NEWLINE> <COMMENT> <NL> INF = 10 ** 17 <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def F ( index , n ) : <NEWLINE> <INDENT> if index >= N : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if N - index + 2 < 2 * n : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return max ( A [ index : ] ) <NEWLINE> <DEDENT> ret = max ( A [ index ] + F ( index + 2 , n - 1 ) , F ( index + 1 , n ) ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> answer = F ( 0 , N // 2 ) <NEWLINE> print ( answer ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a1 = 7 <NEWLINE> ai = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ai = a1 % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % K <NEWLINE> <DEDENT> if ai == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = - 2 <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE>
import heapq as pq <NEWLINE> inf = float ( <STRING> ) <NEWLINE> n , e , r = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> M [ s ] . append ( [ t , d ] ) <NEWLINE> <NL> <DEDENT> def dijkstra ( s ) : <NEWLINE> <INDENT> color = [ 0 ] * n <NEWLINE> d = [ inf ] * n <NEWLINE> d [ s ] = 0 <NEWLINE> H = [ ] <NEWLINE> pq . heappush ( H , [ 0 , s ] ) <NEWLINE> <NL> while len ( H ) != 0 : <NEWLINE> <INDENT> u2 , u1 = pq . heappop ( H ) <NEWLINE> color [ u1 ] = 1 <NEWLINE> if d [ u1 ] < u2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v1 , v2 in M [ u1 ] : <NEWLINE> <INDENT> if color [ v1 ] == 1 : continue <NEWLINE> if d [ u1 ] + v2 < d [ v1 ] : <NEWLINE> <INDENT> d [ v1 ] = d [ u1 ] + v2 <NEWLINE> pq . heappush ( H , [ d [ v1 ] , v1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> d = dijkstra ( r ) <NEWLINE> for i in d : <NEWLINE> <INDENT> if i == inf : print ( <STRING> ) <NEWLINE> else : print ( i ) <NEWLINE> <DEDENT>
import math <NEWLINE> pi = math . pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * pi * r , 2 * r * pi ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> ( N , M ) = map ( int , input ( ) . split ( ) ) <NEWLINE> neighbor = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> ( A , B ) = map ( int , input ( ) . split ( ) ) <NEWLINE> neighbor [ A ] += B , <NEWLINE> neighbor [ B ] += A , <NEWLINE> <NL> <DEDENT> guide = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> target = [ 1 ] <NEWLINE> checked = [ 1 ] <NEWLINE> while len ( target ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> n = target . pop ( 0 ) <NEWLINE> <COMMENT> <NL> dests = neighbor [ n ] <NEWLINE> <COMMENT> <NL> dests = filter ( lambda d : guide [ d ] == 0 , dests ) <NEWLINE> <COMMENT> <NL> for d in dests : <NEWLINE> <INDENT> guide [ d ] = n <NEWLINE> checked += d , <NEWLINE> <COMMENT> <NL> target += d , <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( guide [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : break <NEWLINE> d = [ [ 0.0 for j in range ( n ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : d [ i ] = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> dp = [ [ 0.0 for j in range ( n ) ] for k in range ( m ) ] <NEWLINE> for i in range ( n ) : dp [ 0 ] [ i ] = 1 <NEWLINE> for k in range ( 1 , m ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> dp [ k ] [ j ] = max ( dp [ k ] [ j ] , dp [ k - 1 ] [ i ] * d [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ m - 1 ] [ i ] > ans : ans = dp [ m - 1 ] [ i ] <NEWLINE> <DEDENT> print ( format ( ans , <STRING> ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( sum ( i * ( n // i * ( n // i + 1 ) ) // 2 for i in range ( 1 , n + 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) ; <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) ; <NEWLINE> <NL> ok = True ; <NEWLINE> ans = 1 ; <NEWLINE> a . sort ( ) ; <NEWLINE> for val in a : <NEWLINE> <INDENT> ans *= val ; <NEWLINE> if ( ans > 1e18 ) : <NEWLINE> <INDENT> ok = False ; <NEWLINE> break ; <NEWLINE> <DEDENT> elif ( ans == 0 ) : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ok ) : <NEWLINE> <INDENT> print ( ans ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) ; <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> passed = [ - 1 ] * ( n + 1 ) <NEWLINE> route = [ ] <NEWLINE> v = 1 <NEWLINE> while passed [ v ] == - 1 : <NEWLINE> <INDENT> passed [ v ] = len ( route ) <NEWLINE> route . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <NL> <DEDENT> c = len ( route ) - passed [ v ] <NEWLINE> l = passed [ v ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( route [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( route [ l + k ] ) <NEWLINE> <DEDENT>
from collections import deque , defaultdict <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = defaultdict ( set ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . add ( B ) <NEWLINE> graph [ B ] . add ( A ) <NEWLINE> <DEDENT> if len ( set ( graph . keys ( ) ) ) != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> tokens = [ - 1 ] * N <NEWLINE> tokens [ 0 ] = N <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if tokens [ nv ] < 0 : <NEWLINE> <INDENT> tokens [ nv ] = v <NEWLINE> q . append ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> [ print ( t + 1 ) for t in tokens [ 1 : ] ] <NEWLINE>
def bubbleSort ( lst , n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> count = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if lst [ i ] < lst [ i - 1 ] : <NEWLINE> <INDENT> lst [ i ] , lst [ i - 1 ] = lst [ i - 1 ] , lst [ i ] <NEWLINE> count += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return lst , count <NEWLINE> <NL> <NL> <DEDENT> num = int ( input ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> lst = bubbleSort ( lst , num ) <NEWLINE> print ( * lst [ 0 ] ) <NEWLINE> print ( lst [ 1 ] ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> s . add ( x ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
string = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = [ x for x in input ( ) . split ( ) ] <NEWLINE> a = int ( inp [ 1 ] ) <NEWLINE> b = int ( inp [ 2 ] ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( string [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> string = string [ : a ] + string [ a : b + 1 ] [ : : - 1 ] + string [ b + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> string = string [ : a ] + inp [ 3 ] + string [ b + 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT>
l = input ( ) <NEWLINE> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> if l [ i ] == l [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , t = input ( ) , input ( ) <NEWLINE> <NL> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> is_double = False <NEWLINE> c = len ( s ) <NEWLINE> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> _c = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if not s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> _c += 1 <NEWLINE> <DEDENT> <DEDENT> if c > _c : <NEWLINE> <INDENT> c = _c <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import heapq <NEWLINE> from collections import Counter <NEWLINE> inf = 10 ** 10 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dset = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> dset [ t - 1 ] . append ( d ) <NEWLINE> <NL> <DEDENT> for dd in dset : <NEWLINE> <INDENT> if dd : dd . sort ( reverse = True ) <NEWLINE> else : dd . append ( - inf ) <NEWLINE> <NL> <DEDENT> dset . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> <NL> cur = 0 <NEWLINE> hq = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( k ) : <NEWLINE> <INDENT> cur += dset [ i ] [ 0 ] <NEWLINE> for d in dset [ i ] [ 1 : ] : heapq . heappush ( hq , - d ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for dd in dset [ k : ] : <NEWLINE> <INDENT> for d in dd : <NEWLINE> <INDENT> heapq . heappush ( hq , - d ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = cur + k * k <NEWLINE> for i in range ( k - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> v = dset [ i ] [ 0 ] <COMMENT> <NEWLINE> if hq : <NEWLINE> <INDENT> w = - heapq . heappop ( hq ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if v < w : <NEWLINE> <INDENT> cur += w - v <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( hq , - w ) <NEWLINE> <DEDENT> ans = max ( ans , cur + i * i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> gcdlist = [ [ math . inf ] * ( k + 1 ) for i in range ( k + 1 ) ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcdlist [ i ] [ j ] = math . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcdlist [ gcdlist [ a ] [ b ] ] [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> popcount_X = X . count ( <STRING> ) <NEWLINE> numX = int ( X , 2 ) <NEWLINE> a , b = numX % ( popcount_X + 1 ) , numX % ( popcount_X - 1 ) if popcount_X != 1 else 0 <NEWLINE> for i , x in enumerate ( X , 1 ) : <NEWLINE> <INDENT> if x == <STRING> and popcount_X == 1 : <NEWLINE> <INDENT> print ( 0 ) ; continue <NEWLINE> <DEDENT> ans = 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> temp = ( b - pow ( 2 , N - i , popcount_X - 1 ) ) % ( popcount_X - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( a + pow ( 2 , N - i , popcount_X + 1 ) ) % ( popcount_X + 1 ) <NEWLINE> <DEDENT> while temp : <NEWLINE> <INDENT> p = format ( temp , <STRING> ) . count ( <STRING> ) <NEWLINE> temp %= p <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = r * r * math . pi <NEWLINE> b = 2 * r * math . pi <NEWLINE> print ( a , b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = 0 <NEWLINE> is_include_zero = False <NEWLINE> too_big = False <NEWLINE> for i in a : <NEWLINE> <INDENT> if int ( i ) > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> too_big = True <NEWLINE> <DEDENT> if int ( i ) == 0 : <NEWLINE> <INDENT> is_include_zero = True <NEWLINE> <DEDENT> <DEDENT> if too_big : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif is_include_zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if b > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> b = int ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b * int ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( b ) ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> mentors = input ( ) . split ( <STRING> ) <NEWLINE> <NL> a = collections . Counter ( mentors ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if str ( i ) in a . keys ( ) : <NEWLINE> <INDENT> print ( a [ str ( i ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ <STRING> * ( W + 4 ) ] <NEWLINE> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> <NL> ans = [ [ - 1 ] * ( W + 4 ) for _ in range ( H + 4 ) ] <NEWLINE> for i in range ( H + 4 ) : <NEWLINE> <INDENT> for j in range ( W + 4 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ch += 1 ; cw += 1 <NEWLINE> dh += 1 ; dw += 1 <NEWLINE> ans [ ch ] [ cw ] = 0 <NEWLINE> <NL> move = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> magic = [ <NEWLINE> <INDENT> [ - 2 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 2 , 2 ] , [ - 1 , - 2 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 1 , 2 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , - 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] <NEWLINE> ] <NEWLINE> <NL> <DEDENT> mylist = deque ( [ [ ch , cw ] ] ) <NEWLINE> mylist2 = deque ( [ ] ) <NEWLINE> while len ( mylist ) > 0 : <NEWLINE> <INDENT> x , y = mylist . popleft ( ) <NEWLINE> mylist2 . append ( [ x , y ] ) <NEWLINE> for p , q in move : <NEWLINE> <INDENT> v1 , v2 = x + p , y + q <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <NEWLINE> <INDENT> mylist . append ( [ v1 , v2 ] ) <NEWLINE> ans [ v1 ] [ v2 ] = ans [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> if len ( mylist ) == 0 : <NEWLINE> <INDENT> while len ( mylist2 ) > 0 : <NEWLINE> <INDENT> x2 , y2 = mylist2 . popleft ( ) <NEWLINE> for v1 , v2 in magic : <NEWLINE> <INDENT> i , j = x2 + v1 , y2 + v2 <NEWLINE> if ans [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> mylist . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
