n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> print ( s [ : k - 1 ] + s [ k - 1 ] . lower ( ) + s [ k : ] ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> x = l // 2019 <NEWLINE> if 2019 * x < l and r < 2019 * ( x + 1 ) : <NEWLINE> <INDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> copy_X = X . copy ( ) <NEWLINE> X . sort ( ) <NEWLINE> for i in copy_X : <NEWLINE> <INDENT> if ( i < X [ N // 2 ] ) : <NEWLINE> <INDENT> print ( X [ N // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X [ ( N // 2 ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
def digitSum ( n ) : <NEWLINE> <INDENT> s = str ( bin ( n ) ) <NEWLINE> s = s [ 2 : ] <NEWLINE> array = list ( map ( int , s ) ) <NEWLINE> return sum ( array ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> X_temp = [ ] <NEWLINE> Y_temp = [ ] <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X_temp . append ( x ) <NEWLINE> Y_temp . append ( y ) <NEWLINE> <DEDENT> X . append ( X_temp ) <NEWLINE> Y . append ( Y_temp ) <NEWLINE> <DEDENT> for i in range ( 1 << N ) : <NEWLINE> <INDENT> judge = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <COMMENT> <NEWLINE> <INDENT> for k in range ( A [ j ] ) : <NEWLINE> <INDENT> if ( i >> X [ j ] [ k ] - 1 ) & 1 != Y [ j ] [ k ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <DEDENT> if judge : <NEWLINE> <INDENT> res = max ( res , digitSum ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ [ ] for i in range ( n ) ] <NEWLINE> e = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b -= 1 <NEWLINE> c -= 1 <NEWLINE> a [ b ] . append ( c ) <NEWLINE> e . append ( c ) <NEWLINE> <DEDENT> col = [ 0 for i in range ( n ) ] <NEWLINE> v = deque ( [ 0 ] ) <NEWLINE> <NL> while v : <NEWLINE> <INDENT> d = v . popleft ( ) <NEWLINE> k = 1 <NEWLINE> for i in a [ d ] : <NEWLINE> <INDENT> if col [ d ] == k : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> col [ i ] = k <NEWLINE> v . append ( i ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( col ) ) <NEWLINE> for i in e : <NEWLINE> <INDENT> print ( col [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( ( v , w ) ) <NEWLINE> G [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> color = [ - 1 ] * ( N + 1 ) <NEWLINE> color [ 1 ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def dfs ( now ) : <NEWLINE> <INDENT> for next_ , w in G [ now ] : <NEWLINE> <INDENT> if color [ next_ ] == - 1 : <NEWLINE> <INDENT> color [ next_ ] = ( w % 2 ) ^ color [ now ] <NEWLINE> dfs ( next_ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( color [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if reached [ i ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> reached [ i ] = 1 <NEWLINE> for dic in uv [ i ] : <NEWLINE> <INDENT> to = dic [ <STRING> ] <NEWLINE> w = dic [ <STRING> ] <NEWLINE> if w % 2 == 0 : <NEWLINE> <INDENT> color [ to ] = color [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color [ to ] = int ( not color [ i ] ) <NEWLINE> <DEDENT> dfs ( to ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> color = [ 0 ] * ( n + 1 ) <NEWLINE> reached = [ 0 ] * ( n + 1 ) <NEWLINE> uv = [ [ ] * ( n + 1 ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> uv [ u ] . append ( { <STRING> : v , <STRING> : w } ) <NEWLINE> uv [ v ] . append ( { <STRING> : u , <STRING> : w } ) <NEWLINE> <DEDENT> dfs ( 1 ) <NEWLINE> for i in color [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ <STRING> ] * W for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> grid [ i ] = list ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> d = deque ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d . append ( ( i , j ) ) <NEWLINE> grid [ i ] [ j ] = <STRING> <NEWLINE> tmp = 1 <NEWLINE> while d : <NEWLINE> <INDENT> p , q = d . popleft ( ) <NEWLINE> for x , y in ( ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nx = p + x <NEWLINE> ny = q + y <NEWLINE> if nx < 0 or nx >= H or ny < 0 or ny >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if grid [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d . append ( ( nx , ny ) ) <NEWLINE> grid [ nx ] [ ny ] = <STRING> <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> if tmp == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> ans = l <NEWLINE> <COMMENT> <NL> for i , s in enumerate ( S [ 1 : ] ) : <NEWLINE> <INDENT> if s != S [ i ] : <NEWLINE> <INDENT> ans = min ( ans , max ( i + 1 , l - 1 - i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a , b = abs ( x2 - x1 ) , abs ( y1 - y2 ) <NEWLINE> <NL> if ( x1 <= x2 ) and ( y1 <= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 - b , y2 + a <NEWLINE> x4 , y4 = x3 - a , y3 - b <NEWLINE> <DEDENT> elif ( x1 >= x2 ) and ( y1 <= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 - b , y2 - a <NEWLINE> x4 , y4 = x3 + a , y3 - b <NEWLINE> <DEDENT> elif ( x1 >= x2 ) and ( y1 >= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 + b , y2 - a <NEWLINE> x4 , y4 = x3 + a , y3 + b <NEWLINE> <DEDENT> elif ( x1 <= x2 ) and ( y1 >= y2 ) : <NEWLINE> <INDENT> x3 , y3 = x2 + b , y2 + a <NEWLINE> x4 , y4 = x3 - a , y3 + b <NEWLINE> <NL> <DEDENT> print ( x3 , y3 , x4 , y4 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bs = [ ls [ i ] - i - 1 for i in range ( n ) ] <NEWLINE> bs . sort ( ) <NEWLINE> <COMMENT> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> a = round ( n / 2 ) <NEWLINE> <COMMENT> <NL> can = [ bs [ a ] , bs [ a - 1 ] , math . floor ( ( bs [ a ] + bs [ a - 1 ] ) / 2 ) , math . ceil ( ( bs [ a ] + bs [ a - 1 ] ) / 2 ) ] <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> can = [ bs [ 0 ] , bs [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = math . floor ( n / 2 ) <NEWLINE> <COMMENT> <NL> can = [ bs [ a + 1 ] , bs [ a - 1 ] , bs [ a ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = 10 ** 27 <NEWLINE> for k in can : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for kn in bs : <NEWLINE> <INDENT> ans += abs ( kn - k ) <NEWLINE> <COMMENT> <NL> <DEDENT> result = min ( result , ans ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from heapq import heappop , heapify <NEWLINE> <NL> <NL> N , K , * V = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( min ( N + 1 , i + 1 ) ) : <NEWLINE> <INDENT> for k in range ( j + 1 ) : <NEWLINE> <INDENT> right = N - j + k <NEWLINE> tmp = V [ : k ] + V [ right : ] <NEWLINE> <NL> put_out_cnt = i - j <NEWLINE> heapify ( tmp ) <NEWLINE> while tmp and put_out_cnt > 0 : <NEWLINE> <INDENT> heappop ( tmp ) <NEWLINE> put_out_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , sum ( tmp ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> X = count [ i - 1 ] + count [ i ] + count [ i + 1 ] <NEWLINE> ans = max ( ans , X ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> h = h [ k : ] <NEWLINE> print ( sum ( h ) ) <NEWLINE>
input ( ) <NEWLINE> cards = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> a = sum ( cards [ 1 : ] ) <NEWLINE> s = cards [ 0 ] <NEWLINE> diff_min = abs ( a - s ) <NEWLINE> <NL> for card in cards [ 1 : - 1 ] : <NEWLINE> <INDENT> a -= card <NEWLINE> s += card <NEWLINE> diff_min = min ( diff_min , abs ( a - s ) ) <NEWLINE> <NL> <DEDENT> print ( diff_min ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> S = sum ( A ) - A [ 0 ] <NEWLINE> X = A [ 0 ] <NEWLINE> ans = abs ( S - X ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> X += A [ i ] <NEWLINE> S -= A [ i ] <NEWLINE> ans = min ( ans , abs ( S - X ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S [ 0 ] != T [ 0 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> lcm = N * M // math . gcd ( N , M ) <NEWLINE> <COMMENT> <NL> tekito = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tekito . append ( i * ( lcm // N ) + 1 ) <NEWLINE> <DEDENT> tekitu = [ ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> tekitu . append ( i * ( lcm // M ) + 1 ) <NEWLINE> <NL> <DEDENT> gattai = set ( tekito ) & set ( tekitu ) <NEWLINE> for k in gattai : <NEWLINE> <INDENT> i1 = ( k - 1 ) // ( lcm // N ) <NEWLINE> i2 = ( k - 1 ) // ( lcm // M ) <NEWLINE> if S [ i1 ] != T [ i2 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans += O [ i ] + E [ i ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> ans += O [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import minimum_spanning_tree <NEWLINE> from scipy . sparse import csr_matrix , coo_matrix , lil_matrix <NEWLINE> from operator import itemgetter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( ( x , y , i ) ) <NEWLINE> <NL> <DEDENT> data = [ 10 , 20 , 30 , 40 ] <NEWLINE> row = [ 0 , 0 , 1 , 1 ] <NEWLINE> col = [ 1 , 2 , 0 , 2 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> data = [ ] <NEWLINE> row = [ ] <NEWLINE> col = [ ] <NEWLINE> <NL> P . sort ( ) <NEWLINE> D = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , p = P [ i ] <NEWLINE> c , d , q = P [ i + 1 ] <NEWLINE> cost = min ( abs ( a - c ) , abs ( b - d ) ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( p ) <NEWLINE> col . append ( q ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( q ) <NEWLINE> col . append ( p ) <NEWLINE> D [ ( p , q ) ] = cost <NEWLINE> D [ ( q , p ) ] = cost <NEWLINE> <NL> <DEDENT> P . sort ( key = itemgetter ( 1 ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , p = P [ i ] <NEWLINE> c , d , q = P [ i + 1 ] <NEWLINE> if ( p , q ) in D : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost = min ( abs ( a - c ) , abs ( b - d ) ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( p ) <NEWLINE> col . append ( q ) <NEWLINE> data . append ( cost ) <NEWLINE> row . append ( q ) <NEWLINE> col . append ( p ) <NEWLINE> D [ ( p , q ) ] = cost <NEWLINE> D [ ( q , p ) ] = cost <NEWLINE> <NL> <DEDENT> coo = coo_matrix ( ( data , ( row , col ) ) , ( N , N ) ) <NEWLINE> mst = minimum_spanning_tree ( coo ) <NEWLINE> print ( int ( mst . sum ( ) ) ) <NEWLINE>
import collections , itertools , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> xy = [ LI ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> x_coord = [ i [ 0 ] for i in xy ] <NEWLINE> x_coord . sort ( ) <NEWLINE> x_val_num = { x_coord [ i ] : i for i in range ( N ) } <NEWLINE> y_coord = [ i [ 1 ] for i in xy ] <NEWLINE> y_coord . sort ( ) <NEWLINE> y_val_num = { y_coord [ i ] : i for i in range ( N ) } <NEWLINE> <NL> <COMMENT> <NL> xy_cnt = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> xy_cnt [ y_val_num [ y ] ] [ x_val_num [ x ] ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> xy_acm = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> xy_acm [ i + 1 ] [ j + 1 ] = xy_cnt [ i ] [ j ] + xy_acm [ i + 1 ] [ j ] + xy_acm [ i ] [ j + 1 ] - xy_acm [ i ] [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = INF <NEWLINE> for yl , yu in itertools . combinations ( range ( N + 1 ) , 2 ) : <NEWLINE> <INDENT> for xl , xu in itertools . combinations ( range ( N + 1 ) , 2 ) : <NEWLINE> <INDENT> cnt = xy_acm [ yu ] [ xu ] - xy_acm [ yu ] [ xl ] - xy_acm [ yl ] [ xu ] + xy_acm [ yl ] [ xl ] <NEWLINE> <COMMENT> <NL> if cnt >= K : <NEWLINE> <INDENT> ans = min ( ( x_coord [ xu - 1 ] - x_coord [ xl ] ) * ( y_coord [ yu - 1 ] - y_coord [ yl ] ) , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] <NEWLINE> ans_ = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> ans_ += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ans_ ) <NEWLINE> ans_ = 0 <NEWLINE> <DEDENT> <DEDENT> ans . append ( ans_ ) <NEWLINE> print ( max ( ans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> H . sort ( ) <NEWLINE> df = 0 <NEWLINE> min_h = H [ K - 1 ] - H [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> new_h = H [ i + K - 1 ] - H [ i ] <NEWLINE> if new_h < min_h : <NEWLINE> <INDENT> min_h = new_h <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_h ) <NEWLINE>
<NL> n , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> _10000 , _5000 , _1000 = 0 , 0 , 0 <NEWLINE> <NL> exist = False <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <INDENT> if ( i * 10000 ) + ( j * 5000 ) + ( ( n - i - j ) * 1000 ) == y : <NEWLINE> <COMMENT> <NL> <INDENT> _10000 , _5000 , _1000 = i , j , n - i - j <NEWLINE> exist = True <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if exist == True : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if exist == True : <NEWLINE> <INDENT> print ( <STRING> . format ( _10000 , _5000 , _1000 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , q = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] . append ( b - 1 ) <NEWLINE> l [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( ) : <NEWLINE> <INDENT> que = [ 0 ] <NEWLINE> done = [ 0 ] * n <NEWLINE> done [ 0 ] = 1 <NEWLINE> while ( que ) : <NEWLINE> <INDENT> now = que . pop ( ) <NEWLINE> <NL> for i in l [ now ] : <NEWLINE> <INDENT> if done [ i ] == 0 : <NEWLINE> <INDENT> done [ i ] = 1 <NEWLINE> que . append ( i ) <NEWLINE> ans [ i ] += ans [ now ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( ) <NEWLINE> print ( * ans ) <NEWLINE>
s = input ( ) <NEWLINE> x = list ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> x . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( x ) ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : return x <NEWLINE> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = gcd ( a , A [ i + 1 ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import bisect <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = N - bisect . bisect_right ( C , b ) <NEWLINE> ans += a * c <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del a [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> <NL> for a in al : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> ans [ a + 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> price = [ 0 ] * m <NEWLINE> typesnum = [ 0 ] * m <NEWLINE> keybit = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> price [ i ] , typesnum [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> keybit [ i ] = sum ( map ( lambda x : 2 ** ( int ( x ) - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> dp = [ 10 ** 9 ] * ( 1 << n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> dp [ bit | keybit [ i ] ] = min ( dp [ bit | keybit [ i ] ] , dp [ bit ] + price [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] == 10 ** 9 : <NEWLINE> <INDENT> dp [ - 1 ] = - 1 <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ ] <NEWLINE> amax = 10 ** 5 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ab . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> amax = max ( a for a , b in ab ) <NEWLINE> p = [ 0 ] * ( h + amax + 1 ) <NEWLINE> for i in range ( 1 , h + amax ) : <NEWLINE> <INDENT> p [ i ] = min ( p [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( p [ h ] ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k and x + y + z == s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> chk1 = [ 0 ] * 10 <NEWLINE> chk2 = [ 0 ] * 100 <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if chk1 [ int ( s [ i ] ) ] == 0 : <NEWLINE> <INDENT> chk1 [ int ( s [ i ] ) ] = 1 <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> x = s [ i ] + s [ j ] <NEWLINE> if chk2 [ int ( x ) ] == 0 : <NEWLINE> <INDENT> chk2 [ int ( x ) ] = 1 <NEWLINE> if x in l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( x ) <NEWLINE> ans += len ( set ( s [ j + 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] <NEWLINE> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ c - 1 ] - a [ b - 1 ] ) <NEWLINE> <DEDENT>
def lrCount ( rCount , lCount , ansList , i ) : <NEWLINE> <INDENT> count = rCount + lCount <NEWLINE> c = 0 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> if count % 2 == 0 : <NEWLINE> <INDENT> ansList [ i - lCount + c ] = count // 2 <NEWLINE> ansList [ i - lCount - 1 + c ] = count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rCount % 2 == 1 : <NEWLINE> <INDENT> ansList [ i - lCount + c ] = count // 2 <NEWLINE> ansList [ i - lCount - 1 + c ] = count // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ansList [ i - lCount + c ] = count // 2 + 1 <NEWLINE> ansList [ i - lCount - 1 + c ] = count // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> check = <STRING> <NEWLINE> ansList = [ 0 for i in range ( len ( s ) ) ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if check == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> check = <STRING> <NEWLINE> rCount = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == check and i != len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rCount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lCount += 1 <NEWLINE> <DEDENT> <DEDENT> elif i == len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> lCount = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lCount += 1 <NEWLINE> <DEDENT> lrCount ( rCount , lCount , ansList , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> check = <STRING> <NEWLINE> lCount = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> lrCount ( rCount , lCount , ansList , i ) <NEWLINE> check = <STRING> <NEWLINE> rCount = 1 <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ansList ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = str ( ansList [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> + str ( ansList [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> n = math . ceil ( ( math . sqrt ( 1 + 8 * X ) - 1 ) / 2 ) <NEWLINE> ans = n <NEWLINE> print ( ans ) <NEWLINE>
from random import randint <NEWLINE> <NL> <NL> class RollingHash : <NEWLINE> <INDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> self . base = [ 7073 , 7577 , 5445 , 2742 , 6972 , 7547 , 2267 , 286 , 6396 , 7147 , <NEWLINE> <INDENT> 3307 , 188 , 266 , 8253 , 2818 , 9527 , 5110 , 1207 , 4633 , 6196 , <NEWLINE> 309 , 2646 , 7533 , 85 , 9870 , 4730 , 6862 , 9213 , 7456 , 7098 , <NEWLINE> 6805 , 674 , 5821 , 4864 , 8061 , 1826 , 2219 , 459 , 5937 , 5667 , <NEWLINE> 9033 , 5552 , 7263 , 2402 , 9809 , 3701 , 7048 , 2874 , 8350 , 6006 , <NEWLINE> 973 , 3317 , 2522 , 5546 , 1669 , 1545 , 7972 , 4979 , 9905 , 173 , <NEWLINE> 6812 , 7715 , 5006 , 6068 , 6340 , 4989 , 5510 , 6380 , 1200 , 6739 , <NEWLINE> 5527 , 4000 , 6519 , 3448 , 2933 , 6048 , 3133 , 1667 , 9086 , 8368 , <NEWLINE> 4914 , 7142 , 2770 , 7752 , 391 , 7052 , 5476 , 3105 , 8322 , 3501 , <NEWLINE> 7454 , 3167 , 8730 , 9002 , 4564 , 138 , 2197 , 7238 , 3411 , 7433 ] [ randint ( 0 , 99 ) ] <NEWLINE> <DEDENT> self . mod = 4611686018427387903 <NEWLINE> self . size = len ( s ) <NEWLINE> self . string = s <NEWLINE> <NL> self . hash = self . make_hashtable ( s ) <NEWLINE> self . pow = self . make_powtable ( ) <NEWLINE> <NL> <DEDENT> def make_hashtable ( self , _s ) : <NEWLINE> <INDENT> hashtable = [ 0 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> hashtable [ i + 1 ] = ( hashtable [ i ] * self . base + ord ( _s [ i ] ) ) % self . mod <NEWLINE> <DEDENT> return hashtable <NEWLINE> <NL> <DEDENT> def make_powtable ( self ) : <NEWLINE> <INDENT> power = [ 1 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> power [ i + 1 ] = ( self . base * power [ i ] ) % self . mod <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def get_hash ( self , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . hash [ right ] - self . hash [ left ] * self . pow [ right - left ] ) % self . mod <NEWLINE> <NL> <DEDENT> def contain ( self , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m = len ( a ) <NEWLINE> if m > self . size : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> hashs = self . get_hash ( 0 , m ) <NEWLINE> hasha = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hasha = ( hasha * self . base + ord ( a [ i ] ) ) % self . mod <NEWLINE> <DEDENT> for i in range ( self . size - m + 1 ) : <NEWLINE> <INDENT> if hasha == hashs : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> hashs = self . get_hash ( i , m + i ) <NEWLINE> <DEDENT> return hasha == hashs <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from collections import defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> n , s = int ( input ( ) ) , input ( ) <NEWLINE> rh = RollingHash ( s ) <NEWLINE> <NL> <NL> def check ( m ) : <NEWLINE> <INDENT> d = defaultdict ( lambda : 10000000 ) <NEWLINE> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> h = rh . get_hash ( i , i + m ) <NEWLINE> d [ h ] = min ( d [ h ] , i ) <NEWLINE> <COMMENT> <NL> if i - d [ h ] >= m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> l , r = 0 , n // 2 + 1 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> g_l = [ [ ] for i in range ( N ) ] <NEWLINE> check_l = [ - 1 ] * N <NEWLINE> num_l = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> g_l [ ai - 1 ] . append ( bi - 1 ) <NEWLINE> g_l [ bi - 1 ] . append ( ai - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( n ) : <NEWLINE> <INDENT> d = 1 <NEWLINE> if check_l [ n ] > 0 : <NEWLINE> <INDENT> return num_l [ n ] <NEWLINE> <DEDENT> check_l [ n ] = 1 <NEWLINE> for next_n in g_l [ n ] : <NEWLINE> <INDENT> d += dfs ( next_n ) <NEWLINE> <DEDENT> num_l [ n ] = d <NEWLINE> return d <NEWLINE> <NL> <NL> <DEDENT> def modinv ( a ) : <NEWLINE> <COMMENT> <NL> <INDENT> return pow ( a , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> dfs ( 0 ) <NEWLINE> pow_l = [ None ] * ( N + 1 ) <NEWLINE> pow_l [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> pow_l [ i ] = ( pow_l [ i - 1 ] * 2 ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ( ans + ( pow_l [ num_l [ i ] ] - 1 ) * <NEWLINE> <INDENT> ( pow_l [ N - num_l [ i ] ] - 1 ) % MOD ) % MOD <NEWLINE> <DEDENT> <DEDENT> ans = ( ans + ( pow_l [ N ] - 1 ) - ( N * pow_l [ N - 1 ] ) % MOD ) % MOD <NEWLINE> y = ans <NEWLINE> x = pow ( 2 , N , MOD ) <NEWLINE> <NL> z = ( y * modinv ( x ) ) % MOD <NEWLINE> <NL> print ( z ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
from math import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> T = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> ans = T [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * T [ i ] // gcd ( ans , T [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : ( int ( x ) + 1 ) / 2 , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = sum ( p [ : k ] ) <NEWLINE> ans = t <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> t += p [ i ] - p [ i - k ] <NEWLINE> if ans < t : ans = t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> <NL> over4 = [ ] <NEWLINE> over2 = [ ] <NEWLINE> <NL> for k , v in c . items ( ) : <NEWLINE> <INDENT> if v >= 4 : <NEWLINE> <INDENT> over4 . append ( k ) <NEWLINE> <DEDENT> elif v >= 2 : <NEWLINE> <INDENT> over2 . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> over4 . sort ( reverse = True ) <NEWLINE> over2 . sort ( reverse = True ) <NEWLINE> <NL> s1 , s2 , s3 = 0 , 0 , 0 <NEWLINE> if len ( over4 ) > 0 : <NEWLINE> <INDENT> s1 = over4 [ 0 ] ** 2 <NEWLINE> <DEDENT> if len ( over2 ) >= 2 : <NEWLINE> <INDENT> s2 = over2 [ 0 ] * over2 [ 1 ] <NEWLINE> <DEDENT> if len ( over4 ) > 0 and len ( over2 ) > 0 : <NEWLINE> <INDENT> s3 = over4 [ 0 ] * over2 [ 0 ] <NEWLINE> <NL> <DEDENT> print ( max ( s1 , s2 , s3 ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> a , b , c , d , e , f = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> def searints ( m , n , l ) : <COMMENT> <NEWLINE> <INDENT> mask = ( 1 << l + 1 ) - 1 <NEWLINE> s = sum ( [ 1 << n * i for i in range ( 1 , l // n + 1 ) ] ) & mask <NEWLINE> for i in range ( 1 , l // m + 1 ) : <NEWLINE> <INDENT> s = ( s + 1 << m * i | s ) & mask <NEWLINE> <DEDENT> return [ x for x in range ( 0 , l + 1 ) if ( ( s + 1 ) >> x ) & 1 == 1 ] <NEWLINE> <NL> <DEDENT> w = searints ( 100 * a , 100 * b , f ) <NEWLINE> s = searints ( c , d , f ) <NEWLINE> candidates = [ ( 100 * y / ( x + y ) , x + y , y ) for x in w for y in s if e * x >= 100 * y and x * y > 0 and x + y <= f ] <NEWLINE> if candidates : <NEWLINE> <INDENT> print ( * max ( candidates ) [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 * a , 0 ) <NEWLINE> <DEDENT>
n , m , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xl . append ( x ) <NEWLINE> yl . append ( y ) <NEWLINE> xl . sort ( ) <NEWLINE> yl . sort ( ) <NEWLINE> <NL> if xl [ - 1 ] < yl [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ptr = <STRING> <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ptr == <STRING> : <NEWLINE> <INDENT> if a == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ptr = a . pop ( 0 ) <NEWLINE> <DEDENT> if ptr == <STRING> : <NEWLINE> <INDENT> if b == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ptr = b . pop ( 0 ) <NEWLINE> <DEDENT> if ptr == <STRING> : <NEWLINE> <INDENT> if c == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ptr = c . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> m = np . array ( [ [ 0 if i == <STRING> else 1 for i in input ( ) ] for i in range ( H ) ] ) <NEWLINE> l , r , u , d = np . zeros ( ( 4 , H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * m [ i ] <NEWLINE> d [ - i - 1 ] = ( d [ - i ] + 1 ) * m [ - i - 1 ] <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> r [ : , i ] = ( r [ : , i - 1 ] + 1 ) * m [ : , i ] <NEWLINE> l [ : , - i - 1 ] = ( l [ : , - i ] + 1 ) * m [ : , - i - 1 ] <NEWLINE> <DEDENT> print ( int ( np . max ( u + r + l + d ) ) - 3 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> ans_num = 0 <NEWLINE> ans_list = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = N - i <NEWLINE> s = 0 <NEWLINE> for j in range ( tmp , N + 1 , tmp ) : <NEWLINE> <INDENT> s += ans [ j - 1 ] <NEWLINE> <NL> <DEDENT> if s % 2 != A [ tmp - 1 ] : <NEWLINE> <INDENT> ans [ tmp - 1 ] = 1 <NEWLINE> ans_num += 1 <NEWLINE> ans_list += str ( tmp ) <NEWLINE> ans_list += <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans_num ) <NEWLINE> print ( ans_list [ : - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if s == 3 * k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif s > 3 * k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif s == k : <NEWLINE> <INDENT> ans = int ( ( k + 1 ) * ( k + 2 ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = k <NEWLINE> <NL> while l >= 0 : <NEWLINE> <INDENT> t_sum = s - l <NEWLINE> m = s - t_sum <NEWLINE> <NL> if t_sum > 2 * k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if m < k : <NEWLINE> <INDENT> m = k <NEWLINE> <NL> <DEDENT> while m >= 0 : <NEWLINE> <INDENT> n = s - l - m <NEWLINE> <NL> if n > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if n >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> m -= 1 <NEWLINE> <DEDENT> l -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt , x = 0 , 0 <NEWLINE> for y in range ( k + 1 ) : <NEWLINE> <INDENT> for z in range ( k + 1 ) : <NEWLINE> <INDENT> x = s - y - z <NEWLINE> if 0 <= x <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n_str = str ( n ) <NEWLINE> l = len ( n_str ) <NEWLINE> a = [ i for i in range ( 10 ) if i not in d ] <NEWLINE> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in a : <NEWLINE> <INDENT> if j == int ( n_str [ i ] ) : <NEWLINE> <INDENT> ans += str ( j ) <NEWLINE> break <NEWLINE> <DEDENT> elif j > int ( n_str [ i ] ) : <NEWLINE> <INDENT> ans += str ( j ) + str ( a [ 0 ] ) * ( l - i - 1 ) <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> if int ( ans ) >= n : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = str ( a [ 1 ] ) + str ( a [ 0 ] ) * l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = str ( a [ 0 ] ) * ( l + 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> a_cnt = collections . Counter ( A ) <NEWLINE> p = sorted ( [ i for i in a_cnt . items ( ) if i [ 1 ] >= 2 ] , reverse = True ) <NEWLINE> if len ( p ) > 0 : <NEWLINE> <INDENT> if p [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( p [ 0 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> elif len ( p ) > 1 : <NEWLINE> <INDENT> print ( p [ 0 ] [ 0 ] * p [ 1 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> f = sorted ( f , reverse = True ) <NEWLINE> <NL> <NL> def is_lessthanK ( X ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for A , F in zip ( a , f ) : <NEWLINE> <INDENT> if A * F > X : <NEWLINE> <INDENT> ans += A - X // F <NEWLINE> <DEDENT> if ans > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> ng = - 1 <NEWLINE> ok = a [ - 1 ] * f [ 0 ] <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_lessthanK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ken = [ 1 for i in range ( n + 1 ) ] <NEWLINE> inf = [ [ ] for i in range ( m ) ] <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> x = x // 10 <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> inf [ i ] . append ( i + 1 ) <NEWLINE> inf [ i ] . append ( p ) <NEWLINE> inf [ i ] . append ( y ) <NEWLINE> <DEDENT> inf = sorted ( inf , key = lambda x : x [ 2 ] ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> inf [ i ] . append ( ken [ inf [ i ] [ 1 ] ] ) <NEWLINE> ken [ inf [ i ] [ 1 ] ] += 1 <NEWLINE> <DEDENT> inf = sorted ( inf ) <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> p = inf [ i ] [ 1 ] <NEWLINE> y = inf [ i ] [ 3 ] <NEWLINE> for j in range ( 6 - f ( p ) ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> ans = ans + str ( p ) <NEWLINE> <NL> for j in range ( 6 - f ( y ) ) : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> ans = ans + str ( y ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> print ( ( N - 1 ) * N // 2 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> num_0 = s . count ( <STRING> ) <NEWLINE> num_1 = s . count ( <STRING> ) <NEWLINE> print ( min ( num_0 , num_1 ) * 2 ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dx = [ - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 ] <NEWLINE> dy = [ 1 , 1 , 1 , 0 , 0 , - 1 , - 1 , - 1 ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for t in range ( 8 ) : <NEWLINE> <INDENT> ni = i + dx [ t ] <NEWLINE> nj = j + dy [ t ] <NEWLINE> if ni < 0 or h <= ni : continue <NEWLINE> if nj < 0 or w <= nj : continue <NEWLINE> if s [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s [ i ] [ j ] = str ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> black = 0 <NEWLINE> white = 0 <NEWLINE> <NL> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += i + 1 - white <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for x in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] : <NEWLINE> <INDENT> if x in S : <NEWLINE> <INDENT> x_index = S . index ( x ) <NEWLINE> for y in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] : <NEWLINE> <INDENT> if y in S [ x_index + 1 : ] : <NEWLINE> <INDENT> y_index = S [ x_index + 1 : ] . index ( y ) <NEWLINE> for z in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] : <NEWLINE> <INDENT> if z in S [ x_index + 1 + y_index + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , M , Q , LR , pq ) : <NEWLINE> <INDENT> S = np . zeros ( shape = ( N + 1 , N + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = LR [ i ] <NEWLINE> S [ L ] [ R ] += 1 <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> S [ i ] = np . cumsum ( S [ i ] ) <NEWLINE> <NL> <DEDENT> ans = np . zeros ( shape = Q , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , q = pq [ i ] <NEWLINE> for j in range ( p , q + 1 ) : <NEWLINE> <INDENT> ans [ i ] += S [ j ] [ q ] - S [ j ] [ p - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = np . zeros ( shape = ( M , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> LR [ i ] = input ( ) . split ( ) <NEWLINE> <DEDENT> pq = np . zeros ( shape = ( Q , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> pq [ i ] = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> ans = solve ( N , M , Q , LR , pq ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = copy . copy ( a ) <NEWLINE> sum_odd = sum ( a [ 1 : : 2 ] ) <NEWLINE> sum_eve = sum ( a [ : : 2 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum_a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> sum_a = sum_a + a [ i ] <NEWLINE> <NL> if sum_a * ( - 1 ) ** ( i + 1 ) < 1 : <NEWLINE> <INDENT> kari = 1 - sum_a * ( - 1 ) ** ( i + 1 ) <NEWLINE> a [ i ] += 1 * ( - 1 ) ** ( i + 1 ) * ( kari ) <NEWLINE> sum_a += 1 * ( - 1 ) ** ( i + 1 ) * ( kari ) <NEWLINE> <NL> ans = ans + abs ( kari ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 = 0 <NEWLINE> sum_b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> sum_b = sum_b + b [ i ] <NEWLINE> if sum_b * ( - 1 ) ** ( i ) < 1 : <NEWLINE> <INDENT> kari = ( 1 - sum_b * ( - 1 ) ** ( i ) ) <NEWLINE> b [ i ] += 1 * ( - 1 ) ** ( i ) * kari <NEWLINE> sum_b += 1 * ( - 1 ) ** ( i ) * kari <NEWLINE> <NL> ans1 = ans1 + abs ( kari ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( min ( ans , ans1 ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( S [ : k - 1 ] + S [ k - 1 ] . lower ( ) + S [ k : ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> str_i = str ( i ) <NEWLINE> i_index = S . find ( str_i ) <NEWLINE> if i_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> str_j = str ( j ) <NEWLINE> j_index = S . find ( str_j , i_index + 1 ) <NEWLINE> if j_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> str_k = str ( k ) <NEWLINE> k_index = S . find ( str_k , j_index + 1 ) <NEWLINE> if k_index != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> mi = 0 <NEWLINE> ma = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> mi = max ( mi , lr [ i ] [ 0 ] ) <NEWLINE> ma = min ( ma , lr [ i ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if ma - mi >= 0 : <NEWLINE> <INDENT> print ( ma - mi + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> loc = None <NEWLINE> for i in range ( ls - lt , - 1 , - 1 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if not ( S [ i + j ] == T [ j ] or S [ i + j ] == <STRING> ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> loc = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if loc == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < ls : <NEWLINE> <INDENT> if i == loc : <NEWLINE> <INDENT> ans += T <NEWLINE> i += lt <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += S [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ppl = list ( input ( ) ) <NEWLINE> <NL> buff = [ ] <NEWLINE> w = 0 <NEWLINE> e = ppl [ 1 : ] . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> w += ( ppl [ i - 1 ] == <STRING> and 1 or 0 ) <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> e -= ( ppl [ i ] == <STRING> and 1 or 0 ) <NEWLINE> <DEDENT> n = w + e <NEWLINE> buff . append ( n ) <NEWLINE> <NL> <DEDENT> print ( min ( buff ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> step = [ 0 ] * ( n + 1 ) <NEWLINE> step [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> step [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> step [ i ] = ( step [ i - 1 ] + step [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> print ( step [ - 1 ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = min ( a , b ) <NEWLINE> d = max ( a , b ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( c ) : <NEWLINE> <INDENT> if c % ( i + 1 ) == 0 and d % ( i + 1 ) == 0 : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ - k ] ) <NEWLINE>
def I ( ) : return int ( input ( ) ) <NEWLINE> N = I ( ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> num = str ( i ) . zfill ( 3 ) <NEWLINE> if S . find ( num [ 0 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S1 = S [ S . find ( num [ 0 ] ) + 1 : ] <NEWLINE> if S1 . find ( num [ 1 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S2 = S1 [ S1 . find ( num [ 1 ] ) + 1 : ] <NEWLINE> if S2 . find ( num [ 2 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = input ( ) <NEWLINE> answer = len ( n ) <NEWLINE> number = int ( n ) <NEWLINE> for a in range ( int ( math . sqrt ( int ( n ) ) ) , 1 , - 1 ) : <NEWLINE> <INDENT> if number % a != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = number // a <NEWLINE> answer = min ( answer , max ( len ( str ( a ) ) , len ( str ( b ) ) ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_l = [ ] <NEWLINE> lst_r = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_l . append ( l ) <NEWLINE> lst_r . append ( r ) <NEWLINE> <NL> <DEDENT> max_l = max ( lst_l ) <NEWLINE> min_r = min ( lst_r ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if max_l <= i + 1 <= min_r : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> list10 = [ ] <NEWLINE> head = S [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> <COMMENT> <NL> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> list10 . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == head : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list10 . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> head = S [ i ] <NEWLINE> <NL> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> list10 . append ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> list10 . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> cumsum = [ 0 ] <NEWLINE> for li in list10 : <NEWLINE> <INDENT> cumsum . append ( cumsum [ - 1 ] + li ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( 1 , len ( cumsum ) , 2 ) : <NEWLINE> <INDENT> h = j <NEWLINE> t = min ( j + 2 * K , len ( cumsum ) - 1 ) <NEWLINE> ans = max ( ans , cumsum [ t ] - cumsum [ max ( h - 1 , 0 ) ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from numpy import * ; N , K = map ( int , input ( ) . split ( ) ) ; m = zeros ( ( 3 * K , 3 * K ) , dtype = int ) ; L = 2 * K ; o = 0 <NEWLINE> for _ in [ 0 ] * N : x , y , c = input ( ) . split ( ) ; t = c == <STRING> ; m [ int ( x ) % L , int ( y ) % L ] += 2 * t - 1 ; o += t <NEWLINE> for _ in [ 0 , 0 ] : m [ L : ] = m [ : K ] ; m = cumsum ( m , axis = 0 ) ; m [ : L ] -= m [ K : ] ; m = m . T <NEWLINE> m = m [ : L , : L ] ; print ( o - int ( ( m + roll ( roll ( m , K , axis = 0 ) , K , axis = 1 ) ) . min ( ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> S [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> <NL> print ( <STRING> . join ( S ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from itertools import product <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> problem = [ list ( map ( int , list ( input ( ) . split ( ) ) ) ) for i in range ( D ) ] <NEWLINE> <NL> for p in product ( [ True , False ] , repeat = D ) : <NEWLINE> <NL> <INDENT> point = 0 <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> point += ( i + 1 ) * 100 * problem [ i ] [ 0 ] + problem [ i ] [ 1 ] <NEWLINE> num += problem [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if point >= G : <NEWLINE> <INDENT> ans = min ( ans , num ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( D ) ) : <NEWLINE> <INDENT> if p [ i ] == False : <NEWLINE> <INDENT> if point >= G : <NEWLINE> <INDENT> ans = min ( ans , num ) <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( problem [ i ] [ 0 ] ) : <NEWLINE> <INDENT> point += ( i + 1 ) * 100 <NEWLINE> num += 1 <NEWLINE> if point >= G : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if point >= G : <NEWLINE> <INDENT> ans = min ( ans , num ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 or a == N or b == 1 or b == N : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = False <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if 1 in G [ i ] and N in G [ i ] : <NEWLINE> <INDENT> res = True <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if res : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> words = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while len ( S ) > 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> for word in words : <NEWLINE> <INDENT> if S . endswith ( word ) : <NEWLINE> <INDENT> flag = False <NEWLINE> S = S [ : - len ( word ) ] <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> march = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> prefix = [ ] <NEWLINE> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> pre = input ( ) [ 0 ] <NEWLINE> if pre in march : <NEWLINE> <INDENT> if pre not in prefix : <NEWLINE> <INDENT> prefix . append ( pre ) <NEWLINE> d [ pre ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ pre ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t = len ( prefix ) <NEWLINE> if t < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( t - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , t - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , t ) : <NEWLINE> <INDENT> ans += d [ prefix [ i ] ] * d [ prefix [ j ] ] * d [ prefix [ k ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n < 10 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> <DEDENT> b = n // a <NEWLINE> j = 1 <NEWLINE> while True : <NEWLINE> <INDENT> m = b / ( 10 ** j ) <NEWLINE> if m >= 1 and m < 10 : <NEWLINE> <INDENT> ans = j + 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> B = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> C = [ [ abs ( A [ i ] [ j ] - B [ i ] [ j ] ) for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> <NL> X = ( H + W ) * 80 <NEWLINE> L = X + X + 1 <NEWLINE> dp = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> dp [ 0 ] [ 0 ] |= 1 << ( X - C [ 0 ] [ 0 ] ) <NEWLINE> dp [ 0 ] [ 0 ] |= 1 << ( X + C [ 0 ] [ 0 ] ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= dp [ i - 1 ] [ j ] << C [ i ] [ j ] <NEWLINE> dp [ i ] [ j ] |= dp [ i - 1 ] [ j ] >> C [ i ] [ j ] <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= dp [ i ] [ j - 1 ] << C [ i ] [ j ] <NEWLINE> dp [ i ] [ j ] |= dp [ i ] [ j - 1 ] >> C [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = L <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> if dp [ - 1 ] [ - 1 ] & 1 << i > 0 : <NEWLINE> <INDENT> ans = min ( ans , abs ( i - X ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> asum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = ( p [ i ] + 1 ) / 2 + asum <NEWLINE> asum = a [ i ] <NEWLINE> <DEDENT> ans = a [ k - 1 ] <NEWLINE> for f in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( [ ans , a [ f + k - 1 ] - a [ f - 1 ] ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p , q = 1 , 1 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = max ( ( p + t - 1 ) // t , ( q + a - 1 ) // a ) <NEWLINE> p , q = n * t , n * a <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( p + q ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> nums = [ i for i in range ( n + 1 ) ] <NEWLINE> judge = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> price = i * 10000 + j * 5000 + ( n - i - j ) * 1000 <NEWLINE> if y == price : <NEWLINE> <INDENT> judge += 1 <NEWLINE> print ( str ( i ) + <STRING> + str ( j ) + <STRING> + str ( n - i - j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if judge == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if judge == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> G = defaultdict ( list ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for n , item in enumerate ( l ) : <NEWLINE> <INDENT> G [ item ] = [ n , i ] <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> dp = [ 0 for i in range ( h * w + 1 ) ] <NEWLINE> for i in range ( d ) : <COMMENT> <NEWLINE> <INDENT> current_place = i + 1 <NEWLINE> while current_place + d <= h * w : <NEWLINE> <INDENT> x , y = G [ current_place ] <NEWLINE> next_place = current_place + d <NEWLINE> x1 , y1 = G [ next_place ] <NEWLINE> magic = abs ( x - x1 ) + abs ( y - y1 ) <NEWLINE> dp [ next_place ] = magic + dp [ current_place ] <NEWLINE> current_place = next_place <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dp [ r ] - dp [ l ] , flush = True ) <NEWLINE> <NL> <DEDENT>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = [ ( int ( i ) + 1 ) / 2 for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> sum_num = sum ( p [ : k ] ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sum_num = sum ( p [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_num += p [ i + k - 1 ] - p [ i - 1 ] <NEWLINE> <DEDENT> ans = max ( ans , sum_num ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if i + 1 == a [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class Union_Find : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( self . parent [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> px = self . find ( x ) <NEWLINE> py = self . find ( y ) <NEWLINE> if px == py : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . rank [ px ] == self . rank [ py ] : <NEWLINE> <INDENT> self . parent [ py ] = px <NEWLINE> self . rank [ px ] += 1 <NEWLINE> <DEDENT> elif self . rank [ px ] > self . rank [ py ] : <NEWLINE> <INDENT> self . parent [ py ] = px <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ px ] = py <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> uftree = Union_Find ( N + 1 ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y , _ = map ( int , input ( ) . split ( ) ) <NEWLINE> uftree . unite ( x , y ) <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if uftree . find ( i ) == i : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = S . find ( str ( k ) , b + 1 ) <NEWLINE> if c == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( a ) % 10 == 0 : <NEWLINE> <INDENT> if a [ i ] % 10 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
N , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> cost [ i ] = min ( [ cost [ j ] + abs ( l [ i ] - l [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ] ) <NEWLINE> <DEDENT> print ( cost [ N - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> l_s = len ( s ) <NEWLINE> l_t = len ( t ) <NEWLINE> <NL> s2 = s + s <NEWLINE> l_s2 = len ( s2 ) <NEWLINE> <NL> next_idx = [ [ l_s2 ] * 26 for i in range ( l_s2 ) ] <NEWLINE> <NL> for i in reversed ( range ( 1 , l_s2 ) ) : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> next_idx [ i - 1 ] [ j ] = next_idx [ i ] [ j ] <NEWLINE> <DEDENT> next_idx [ i - 1 ] [ ord ( s2 [ i ] ) - ord ( <STRING> ) ] = i <NEWLINE> <NL> <DEDENT> cur_idx = 0 <NEWLINE> for i in range ( l_t ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> for j in range ( l_s ) : <NEWLINE> <INDENT> if t [ i ] == s [ j ] : <NEWLINE> <INDENT> cur_idx += j <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = next_idx [ cur_idx % l_s ] [ ord ( t [ i ] ) - ord ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> if idx == l_s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cur_idx += idx - ( cur_idx % l_s ) <NEWLINE> <NL> <DEDENT> print ( cur_idx + 1 ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w - 1 ) : <NEWLINE> <INDENT> if arr [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> arr [ i ] [ j ] -= 1 <NEWLINE> arr [ i ] [ j + 1 ] += 1 <NEWLINE> ans . append ( [ i + 1 , j + 1 , i + 1 , j + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h - 1 ) : <NEWLINE> <INDENT> if arr [ i ] [ w - 1 ] % 2 == 1 : <NEWLINE> <INDENT> arr [ i ] [ w - 1 ] -= 1 <NEWLINE> arr [ i + 1 ] [ w - 1 ] += 1 <NEWLINE> ans . append ( [ i + 1 , w , i + 2 , w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( s ) > 0 : <NEWLINE> <INDENT> s = s [ 0 : - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul , add <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> print ( abs ( A [ 1 ] - A [ 0 ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> t = list ( accumulate ( A , add ) ) <NEWLINE> r = list ( accumulate ( reversed ( A ) , add ) ) <NEWLINE> <NL> ans = INF <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( t [ i ] - r [ - 2 - i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for m in range ( M ) ] <NEWLINE> BC = sorted ( BC , key = lambda x : x [ 1 ] ) [ : : - 1 ] <NEWLINE> <NL> for b , c in BC : <NEWLINE> <INDENT> A . extend ( b * [ c ] ) <NEWLINE> if 2 * N < len ( A ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A = sorted ( A ) [ : : - 1 ] <NEWLINE> print ( sum ( A [ : N ] ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( S - K <= X + Y <= S for X in range ( K + 1 ) for Y in range ( K + 1 ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n , m = LI ( ) <NEWLINE> s = S ( ) <NEWLINE> t = S ( ) <NEWLINE> <NL> gcd = math . gcd ( n , m ) <NEWLINE> lcm = n * m // gcd <NEWLINE> i_s = n // gcd <NEWLINE> i_t = m // gcd <NEWLINE> for i in range ( gcd ) : <NEWLINE> <INDENT> if s [ i * i_s ] != t [ i * i_t ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
from math import gcd <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> g = gcd ( n , m ) <NEWLINE> ans = n * m // g <NEWLINE> <NL> <STRING> <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if not s [ i * n // g ] == t [ i * m // g ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ss = sorted ( [ sorted ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> ans = 0 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ss [ i ] != ss [ i + 1 ] : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xy_pos = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for k in range ( - 2 , 1 ) : <NEWLINE> <INDENT> for l in range ( - 2 , 1 ) : <NEWLINE> <INDENT> x = ( a - 1 ) + k <NEWLINE> y = ( b - 1 ) + l <NEWLINE> if ( 0 <= x <= h - 3 and 0 <= y <= w - 3 ) : <NEWLINE> <INDENT> xy = str ( x ) + <STRING> + str ( y ) <NEWLINE> if xy in xy_pos : <NEWLINE> <INDENT> xy_pos [ xy ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xy_pos [ xy ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 10 <NEWLINE> for v in xy_pos . values ( ) : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) - sum ( ans ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
A , B , K = input ( ) . split ( <STRING> ) <NEWLINE> A , B , K = int ( A ) , int ( B ) , int ( K ) <NEWLINE> <NL> res = [ ] <NEWLINE> <NL> for i in range ( A , 0 , - 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res [ K - 1 ] ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ [ i , a [ i ] ] for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> aa . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( aa [ i ] [ 0 ] + 1 , end = <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans * 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> min_card , max_card = 0 , n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> min_card = max ( min_card , l ) <NEWLINE> max_card = min ( max_card , r ) <NEWLINE> <COMMENT> <NL> <DEDENT> if min_card <= max_card : <NEWLINE> <INDENT> print ( max_card - min_card + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L_sorted = sorted ( L , reverse = False ) <COMMENT> <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <COMMENT> <NEWLINE> <INDENT> a = L_sorted [ i ] <NEWLINE> b = L_sorted [ j ] <COMMENT> <NEWLINE> count += bisect . bisect_left ( L_sorted , a + b ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == c : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - c + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) - 1 ) <NEWLINE> <DEDENT> flag = True <NEWLINE> step = [ ] <NEWLINE> pivot = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> step . append ( pivot ) <NEWLINE> if a [ pivot ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pivot = a [ pivot ] <NEWLINE> <NL> <DEDENT> if len ( step ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( step ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> total = n * ( n - 1 ) // 2 <NEWLINE> print ( total ) <NEWLINE>
a , b , x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( ( b // x ) - ( ( a - 1 ) // x ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> apple = [ L + i for i in range ( N ) ] <NEWLINE> min = 500 <NEWLINE> for k in range ( len ( apple ) ) : <NEWLINE> <INDENT> if abs ( apple [ k ] ) < abs ( min ) : <NEWLINE> <INDENT> min = apple [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> apple . remove ( min ) <NEWLINE> print ( sum ( apple ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( H [ i ] < H [ i - 1 ] ) : <NEWLINE> <INDENT> H [ i - 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( H [ i ] > H [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> ac = 0 <NEWLINE> p = 0 <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) - 1 <NEWLINE> <NL> if ans [ a ] != - 1 and b == <STRING> : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> if ans [ a ] != - 1 and b == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> p += ans [ a ] <NEWLINE> ans [ a ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , p ) <NEWLINE>
from queue import Queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <DEDENT> def bfs ( ) : <NEWLINE> <INDENT> queue = Queue ( ) <NEWLINE> queue . put ( 1 ) <NEWLINE> distance = [ 10 ** 6 ] * ( n + 1 ) <NEWLINE> distance [ 1 ] = 0 <NEWLINE> while not queue . empty ( ) : <NEWLINE> <INDENT> u = queue . get ( ) <NEWLINE> if u == n and distance [ u ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for a in adj [ u ] : <NEWLINE> <INDENT> if distance [ u ] + 1 <= 2 and distance [ a ] > distance [ u ] + 1 : <NEWLINE> <INDENT> distance [ a ] = distance [ u ] + 1 <NEWLINE> queue . put ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> bfs ( ) <NEWLINE>
n = list ( input ( ) ) <NEWLINE> l = len ( n ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> n [ i ] = int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> score = 0 <NEWLINE> <NL> if l == 1 : <NEWLINE> <INDENT> print ( n [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n . count ( 9 ) == l : <NEWLINE> <INDENT> score = sum ( n ) <NEWLINE> <DEDENT> elif n . count ( 9 ) == l - 1 : <NEWLINE> <INDENT> if n [ 0 ] != 9 : <NEWLINE> <INDENT> score += sum ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score += 8 + 9 * ( l - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n [ 0 ] != 9 : <NEWLINE> <INDENT> score += n [ 0 ] - 1 + 9 * ( l - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> if n [ j ] != 9 : <NEWLINE> <INDENT> n [ j - 1 ] = 8 <NEWLINE> score += 8 + 9 * ( l - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> <NL> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> result = n * ( n - 1 ) // 2 <NEWLINE> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_value = P [ 0 ] <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] < min_value : <NEWLINE> <INDENT> min_value = P [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( 1 , 50000 ) : <NEWLINE> <INDENT> dic [ int ( i * 1.08 ) ] = i <NEWLINE> <NL> <DEDENT> if n in dic : <NEWLINE> <INDENT> print ( dic [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( w * h / 2 , int ( h == 2 * y and w == 2 * x ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> xy = [ LI ( ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> interval = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> interval . append ( ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] , xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = collections . Counter ( interval ) <NEWLINE> nocost = max ( cnt . values ( ) ) <NEWLINE> ans = N - nocost <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import collections , itertools , copy <NEWLINE> <NL> <NL> class MaximumFlow : <NEWLINE> <INDENT> def ford_fulkerson ( self , G , s , t ) : <NEWLINE> <INDENT> G_residue = copy . deepcopy ( G ) <NEWLINE> <NL> def dfs ( start , used ) : <NEWLINE> <INDENT> if start == t : <NEWLINE> <INDENT> return [ start ] <NEWLINE> <DEDENT> for end , cap in G_residue [ start ] . items ( ) : <NEWLINE> <INDENT> if cap > 0 and end not in used : <NEWLINE> <INDENT> used . add ( end ) <NEWLINE> ret = dfs ( end , used ) <NEWLINE> if ret : <NEWLINE> <INDENT> return ret + [ start ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ ] <NEWLINE> <NL> <DEDENT> flow_value = 0 <NEWLINE> while True : <NEWLINE> <INDENT> root = dfs ( s , set ( [ s ] ) ) <NEWLINE> if root : <NEWLINE> <INDENT> root = root [ : : - 1 ] <NEWLINE> residue = min ( <NEWLINE> <INDENT> [ G_residue [ a ] [ b ] for a , b in zip ( root , root [ 1 : ] ) ] ) <NEWLINE> <DEDENT> flow_value += residue <NEWLINE> for a , b in zip ( root , root [ 1 : ] ) : <NEWLINE> <INDENT> G_residue [ a ] [ b ] -= residue <NEWLINE> G_residue [ b ] [ a ] += residue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ( flow_value , G_residue ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> AB = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> CD = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> G = collections . defaultdict ( lambda : collections . defaultdict ( int ) ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> G [ - 1 ] [ 1000 * a + b ] = 1 <NEWLINE> <DEDENT> for c , d in CD : <NEWLINE> <INDENT> G [ 1000 * c + d ] [ - 2 ] = 1 <NEWLINE> <DEDENT> for ab , cd in itertools . product ( AB , CD ) : <NEWLINE> <INDENT> a , b = ab <NEWLINE> c , d = cd <NEWLINE> if a < c and b < d : <NEWLINE> <INDENT> G [ 1000 * a + b ] [ 1000 * c + d ] = 1 <NEWLINE> <DEDENT> <DEDENT> flow_value , flow_dict = MaximumFlow ( ) . ford_fulkerson ( G , - 1 , - 2 ) <NEWLINE> print ( flow_value ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XYList = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> XY = [ ] <NEWLINE> for j in range ( A ) : <NEWLINE> <INDENT> XY . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> XYList . append ( XY ) <NEWLINE> <DEDENT> maxSum = 0 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> honest = True <NEWLINE> for XY in XYList [ j ] : <NEWLINE> <INDENT> if ( ( i >> ( XY [ 0 ] - 1 ) ) & 1 ) != XY [ 1 ] : <NEWLINE> <INDENT> honest = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if honest : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if maxSum < sum : <NEWLINE> <INDENT> maxSum = sum <NEWLINE> <DEDENT> <DEDENT> print ( maxSum ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> class DAG : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , parent , child ) : <NEWLINE> <INDENT> self . adj [ parent ] . append ( child ) <NEWLINE> <NL> <DEDENT> def dfs ( self , node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> ans = max ( ans , 1 + self . dfs ( child ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def dfsWithMemo ( self , node , memo , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return memo [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> memo [ node ] = max ( <NEWLINE> <INDENT> memo [ node ] , 1 + self . dfsWithMemo ( child , memo , visited ) ) <NEWLINE> <DEDENT> <DEDENT> return memo [ node ] <NEWLINE> <NL> <DEDENT> def dfsWithDp ( self , node , dp , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return dp [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> self . dfsWithDp ( child , dp , visited ) <NEWLINE> <DEDENT> dp [ node ] = max ( dp [ node ] , 1 + self . dfsWithDp ( child , dp , visited ) ) <NEWLINE> <DEDENT> return dp [ node ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathNaive ( self ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfs ( i ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithMemo ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> memo = [ 0 ] * self . n <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithMemo ( i , memo , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithDp ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> dp = [ 0 ] * self . n <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithDp ( i , dp , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dag = DAG ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> parent , child = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> dag . addEdge ( parent , child ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( dag . findLongestPathWithMemo ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( v , seen ) : <NEWLINE> <INDENT> if all ( seen ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for vv in graph [ v ] : <NEWLINE> <INDENT> if seen [ vv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ vv ] = True <NEWLINE> ans += dfs ( vv , seen ) <NEWLINE> seen [ vv ] = False <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> seen [ 0 ] = True <NEWLINE> print ( dfs ( 0 , seen ) ) <NEWLINE>
import sys <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> square = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> a = list ( map ( str , input ( ) ) ) <NEWLINE> square += a <NEWLINE> <NL> <DEDENT> if H == W == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( H * W ) : <NEWLINE> <INDENT> if square [ i ] == <STRING> : <NEWLINE> <INDENT> if i % W != W - 1 : <NEWLINE> <INDENT> if square [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i % W != 0 : <NEWLINE> <INDENT> if square [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if i - W >= 0 : <NEWLINE> <INDENT> if square [ i - W ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i + W <= H * W : <NEWLINE> <INDENT> if square [ i + W ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
import queue <NEWLINE> import copy <NEWLINE> q = queue . Queue ( ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( <STRING> + input ( ) + <STRING> ) for _ in range ( h ) ] <NEWLINE> a = [ [ <STRING> ] * ( w + 2 ) ] + a + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> a1 = copy . deepcopy ( a ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> a = copy . deepcopy ( a1 ) <NEWLINE> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . put ( [ i , j , 0 ] ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> <NL> if a [ now [ 0 ] ] [ now [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> ans . append ( now [ 2 ] ) <NEWLINE> a [ now [ 0 ] ] [ now [ 1 ] ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if a [ now [ 0 ] + 1 ] [ now [ 1 ] ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] + 1 , now [ 1 ] , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> if a [ now [ 0 ] - 1 ] [ now [ 1 ] ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] - 1 , now [ 1 ] , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> if a [ now [ 0 ] ] [ now [ 1 ] + 1 ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] , now [ 1 ] + 1 , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> if a [ now [ 0 ] ] [ now [ 1 ] - 1 ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] , now [ 1 ] - 1 , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> a1 [ i ] [ j ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> old = A [ 0 ] <NEWLINE> a = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cur = A [ i ] <NEWLINE> if cur == old : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if old <= a : <NEWLINE> <INDENT> ans += a - old <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> a = 1 <NEWLINE> <DEDENT> old = cur <NEWLINE> <DEDENT> if old <= a : <NEWLINE> <INDENT> ans += a - old <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> L = lcm ( N , M ) <NEWLINE> d = { } <NEWLINE> s = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ str ( i * ( L // N ) ) ] = S [ i ] <NEWLINE> s . add ( str ( i * ( L // N ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> key = str ( i * ( L // M ) ) <NEWLINE> if key in s : <NEWLINE> <INDENT> if d [ key ] != T [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( L ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mm = 10 ** 5 + 5 <NEWLINE> c = [ [ 0 ] for i in range ( mm ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ a ] . append ( b ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> h = [ ] <NEWLINE> for i in reversed ( range ( m ) ) : <NEWLINE> <INDENT> d = m - i <NEWLINE> for j in c [ d ] : <NEWLINE> <INDENT> heapq . heappush ( h , - j ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans += - heapq . heappop ( h ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = [ i for i in range ( 1 , n ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> if p [ i - 1 ] == i : <NEWLINE> <INDENT> p [ i - 1 ] = p [ i ] <NEWLINE> p [ i ] = i <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 0 <NEWLINE> for item in a : <NEWLINE> <INDENT> if item == ( num + 1 ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if num != 0 : <NEWLINE> <INDENT> print ( N - num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if len ( C ) == 1 and C [ 0 ] == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( C ) == 2 and N % 3 == 0 and C [ 0 ] == N // 3 and N - C [ 0 ] == 2 * N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( C ) == 3 and N % 3 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> for c in C . most_common ( ) : <NEWLINE> <INDENT> if c [ 1 ] != N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> b ^= c [ 0 ] <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> n = len ( s ) - 7 <NEWLINE> for i in range ( n , len ( s ) ) : <NEWLINE> <INDENT> if s [ : i - n ] + s [ i : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> p . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> q = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q [ p [ i ] - 1 ] = i <NEWLINE> <DEDENT> m , cnt = 1 , 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if q [ i ] > q [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt > m : <NEWLINE> <INDENT> m = cnt <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - m ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> if b <= A [ 0 ] or b >= C [ N - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> l , r = - 1 , N <NEWLINE> while abs ( l - r ) > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if A [ mid ] < b : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> l2 , r2 = - 1 , N <NEWLINE> while abs ( l2 - r2 ) > 1 : <NEWLINE> <INDENT> mid = ( l2 + r2 ) // 2 <NEWLINE> if C [ mid ] > b : <NEWLINE> <INDENT> r2 = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 = mid <NEWLINE> <DEDENT> <DEDENT> ans += ( l + 1 ) * ( N - r2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> def dfs ( m ) : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 2 : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 3 : <NEWLINE> <INDENT> ans . append ( 2 ) <NEWLINE> ans . append ( 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 4 : <NEWLINE> <INDENT> ans . append ( 3 ) <NEWLINE> ans . append ( 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif m == 5 : <NEWLINE> <INDENT> ans . append ( 3 ) <NEWLINE> ans . append ( 2 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ceil ( sqrt ( 1 + 8 * m ) ) // 2 <NEWLINE> ans . append ( k ) <NEWLINE> dfs ( m - k ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = INT ( ) <NEWLINE> dfs ( n ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if t * ( t + 1 ) / 2 >= x : <NEWLINE> <INDENT> print ( t ) <NEWLINE> break <NEWLINE> <DEDENT> t += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = 1 <NEWLINE> b = p [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p [ i - 1 ] < b : <NEWLINE> <INDENT> b = p [ i - 1 ] <NEWLINE> <DEDENT> if p [ i ] <= b : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = 0 <NEWLINE> y = s . count ( <STRING> ) <NEWLINE> c = min ( n - y , y ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = s [ i ] == <STRING> <COMMENT> <NEWLINE> x += t <NEWLINE> y -= 1 - t <NEWLINE> c = min ( c , x + y ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( 0 , 2 * max ( X , Y ) + 1 , 2 ) : <NEWLINE> <INDENT> ans = min ( ans , int ( A * max ( 0 , X - i / 2 ) + B * max ( 0 , Y - i / 2 ) + C * i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> m = min ( s , k ) <NEWLINE> for x in range ( m + 1 ) : <NEWLINE> <INDENT> for y in range ( m + 1 ) : <NEWLINE> <INDENT> if s < x + y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s > x + y + k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 9 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <NL> if S % i == 0 and S // i <= 9 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> import numba as nb <NEWLINE> <NL> @ nb . njit ( ) <NEWLINE> def solve ( n , w , weights , values ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( w + 1 ) ] for k in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if weights [ i ] <= j : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , <NEWLINE> <INDENT> dp [ i - 1 ] [ j - weights [ i ] ] + values [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ n ] [ w ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values = [ ] <NEWLINE> weights = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> v , a = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values . append ( a ) <NEWLINE> weights . append ( v ) <NEWLINE> <NL> <DEDENT> values = [ 0 ] + values <NEWLINE> weights = [ 0 ] + weights <NEWLINE> print ( solve ( n , w , weights , values ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a < x + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> test = A [ 0 ] <NEWLINE> l = 0 <NEWLINE> <NL> while test % 2 == 0 : <NEWLINE> <INDENT> test = test // 2 <NEWLINE> c *= 2 <NEWLINE> <NL> <DEDENT> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> for i in np . arange ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] % c != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i + 1 ] % ( c * 2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = A [ i + 1 ] // c <NEWLINE> test = lcm_base ( test , k ) <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> k = test * c // 2 <NEWLINE> print ( M // k // 2 + M // k % 2 ) <NEWLINE> <DEDENT>
def abc144_e ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> low = - 1 <NEWLINE> up = 10 ** 12 <NEWLINE> while up - low > 1 : <NEWLINE> <INDENT> v = ( up + low ) // 2 <NEWLINE> x = A - v // F <NEWLINE> if x [ x > 0 ] . sum ( ) > K : <NEWLINE> <INDENT> low = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up = v <NEWLINE> <DEDENT> <DEDENT> print ( up ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc144_e ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> c = Counter ( S ) <NEWLINE> ans = 1 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans = ( ans * ( v + 1 ) ) % P <NEWLINE> <NL> <DEDENT> ans = ( ans - 1 ) % P <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> X = input ( ) <NEWLINE> stack = deque ( [ X [ 0 ] ] ) <NEWLINE> for i in range ( 1 , len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> stack . appendleft ( X [ i ] ) <NEWLINE> <NL> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if stack : <NEWLINE> <INDENT> check = stack . popleft ( ) <NEWLINE> if check == <STRING> : <NEWLINE> <INDENT> stack . appendleft ( check ) <NEWLINE> stack . appendleft ( X [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stack . appendleft ( X [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( stack ) ) <NEWLINE>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def acc ( li , n ) : <NEWLINE> <INDENT> res = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if li [ i ] == <STRING> : <NEWLINE> <INDENT> res [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif li [ i ] == <STRING> : <NEWLINE> <INDENT> res [ i + 1 ] = 2 <NEWLINE> <DEDENT> <DEDENT> return list ( accumulate ( res ) ) <NEWLINE> <NL> <NL> <DEDENT> def restore ( x , y , li ) : <NEWLINE> <INDENT> return ( li [ y ] - li [ x - 1 ] ) % 3 <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> M = len ( T ) <NEWLINE> <NL> acc_S = acc ( S , N ) <NEWLINE> acc_T = acc ( T , M ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> v_S = restore ( a , b , acc_S ) <NEWLINE> v_T = restore ( c , d , acc_T ) <NEWLINE> print ( <STRING> ) if v_S == v_T else print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = collections . Counter ( A ) <NEWLINE> A = sorted ( A . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> cnt = A [ : len ( A ) - K ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for c in cnt : <NEWLINE> <INDENT> ans . append ( c [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ 0 ] + A + [ 0 ] <NEWLINE> dist = [ 0 ] * ( N + 1 ) <NEWLINE> S = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> S += abs ( A [ i ] - A [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dist [ i ] = S + abs ( A [ i - 1 ] - A [ i + 1 ] ) - ( abs ( A [ i - 1 ] - A [ i ] ) + abs ( A [ i ] - A [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( dist [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> m_list = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> if m_list and i == m_list [ 0 ] : <NEWLINE> <INDENT> m_list . pop ( 0 ) <NEWLINE> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> elif m_list and i == m_list [ 0 ] : <NEWLINE> <INDENT> m_list . pop ( 0 ) <NEWLINE> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ind = [ ] <NEWLINE> for i , char in enumerate ( s ) : <NEWLINE> <INDENT> if char == <STRING> : <NEWLINE> <INDENT> ind . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lst = 0 <NEWLINE> <COMMENT> <NL> for i in ind : <NEWLINE> <INDENT> ans += ( i - lst ) <NEWLINE> lst += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
from itertools import product <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> visited = [ ] <NEWLINE> <NL> def dfs ( p ) : <NEWLINE> <INDENT> if s [ p [ 0 ] ] [ p [ 1 ] ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> temp = [ 1 if s [ p [ 0 ] + y ] [ p [ 1 ] + x ] == <STRING> else 0 for ( x , y ) in [ [ 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] if 0 <= y + p [ 0 ] < h and 0 <= x + p [ 1 ] < w ] <NEWLINE> if sum ( temp ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( s [ 0 ] ) ) : <NEWLINE> <INDENT> dfs ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy <NEWLINE> from numpy . core . defchararray import count <NEWLINE> S = numpy . array ( [ 0 if s == <STRING> else 1 for s in input ( ) ] ) <NEWLINE> <NL> count = 0 <NEWLINE> bcount = 0 <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> bcount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += bcount <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> heapq . heappush ( a , ( ( heapq . heappop ( a ) * ( - 1 ) ) // 2 ) * ( - 1 ) ) <NEWLINE> <DEDENT> print ( abs ( sum ( a ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A [ : : - 2 ] , * A [ N % 2 : : 2 ] ) <NEWLINE>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < 3 : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> num_1 = 2 <NEWLINE> num_2 = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans = num_1 + num_2 <NEWLINE> num_1 , num_2 = num_2 , ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> heappush ( B , - A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a = heappop ( B ) <NEWLINE> a /= 2 <NEWLINE> heappush ( B , a ) <NEWLINE> <NL> <DEDENT> print ( sum ( [ int ( - B [ i ] ) for i in range ( N ) ] ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> ans = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 : <NEWLINE> <INDENT> ans . appendleft ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( str ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = list ( ans ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * ans [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT>
li = [ 1 , 2 , 3 ] <NEWLINE> li . pop ( li . index ( int ( input ( ) ) ) ) <NEWLINE> li . pop ( li . index ( int ( input ( ) ) ) ) <NEWLINE> print ( li [ 0 ] ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if ( 0 <= z < K + 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> if checked [ v ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> checked [ v ] = 1 <NEWLINE> dp [ v ] [ 0 ] = 1 <NEWLINE> dp [ v ] [ 1 ] = 1 <NEWLINE> for u in g [ v ] : <NEWLINE> <INDENT> if checked [ u ] == 0 : <NEWLINE> <INDENT> dfs ( u ) <NEWLINE> dp [ v ] [ 0 ] = ( dp [ v ] [ 0 ] * ( dp [ u ] [ 0 ] + dp [ u ] [ 1 ] ) ) % mod <NEWLINE> dp [ v ] [ 1 ] = ( dp [ v ] [ 1 ] * dp [ u ] [ 0 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> dp = [ [ 0 , 0 ] for _ in range ( n + 1 ) ] <NEWLINE> checked = [ 0 ] * ( n + 1 ) <NEWLINE> dfs ( 1 ) <NEWLINE> print ( ( dp [ 1 ] [ 0 ] + dp [ 1 ] [ 1 ] ) % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( M * 1900 + 100 * ( N - M ) ) * ( 2 ** M ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for m in b : <NEWLINE> <INDENT> l_idx = bisect . bisect_left ( a , m ) <NEWLINE> u_idx = bisect . bisect_right ( c , m ) <NEWLINE> ans += l_idx * ( n - u_idx ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = x // 11 <NEWLINE> chk = x % 11 <NEWLINE> if chk == 0 : <NEWLINE> <INDENT> print ( 2 * ans ) <NEWLINE> <DEDENT> elif chk <= 6 : <NEWLINE> <INDENT> print ( 2 * ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * ans + 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> e_s = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> e = ( p [ i ] + 1 ) / 2 <NEWLINE> e_s [ i + 1 ] = e_s [ i ] + e <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , e_s [ j + K ] - e_s [ j ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> ss = [ input ( ) for _ in range ( n ) ] <NEWLINE> s = sorted ( ss ) <NEWLINE> ans = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> if power >= 10 ** 9 + 7 : <NEWLINE> <INDENT> power %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> YES = <STRING> <COMMENT> <NEWLINE> NO = <STRING> <COMMENT> <NEWLINE> <NL> <NL> def solve ( N : int , M : int , a : <STRING> , b : <STRING> ) : <NEWLINE> <INDENT> AB = sorted ( zip ( a , b ) ) <NEWLINE> s = set ( [ b for a , b in AB if a == 1 ] ) <NEWLINE> g = set ( [ a for a , b in AB if b == N ] ) <NEWLINE> return YES if s & g else NO <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) <NEWLINE> b [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> print ( solve ( N , M , a , b ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> def perf ( ) : <NEWLINE> <INDENT> import cProfile <NEWLINE> cProfile . run ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = p = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> one = sum ( [ a >> p & 1 for a in A ] ) <NEWLINE> zero = N - one <NEWLINE> p += 1 <NEWLINE> ans += ( one * zero ) * 2 ** i <NEWLINE> ans %= M <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for p in range ( 2 , x ) : <NEWLINE> <INDENT> a = b ** p <NEWLINE> if a == a // 1 and a > ans and a <= x : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if a > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if a > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> data = np . array ( p ) + 1 <NEWLINE> <NL> Pcum = np . zeros ( N + 1 , np . int32 ) <NEWLINE> Pcum [ 1 : ] = data . cumsum ( ) <NEWLINE> <NL> length_K_sums = Pcum [ K : ] - Pcum [ 0 : - K ] <NEWLINE> <NL> print ( np . max ( length_K_sums ) / 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bc = sorted ( bc , key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> sub = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sub += [ bc [ i ] [ 1 ] ] * bc [ i ] [ 0 ] <NEWLINE> if len ( sub ) > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += sub <NEWLINE> <NL> print ( sum ( sorted ( A , reverse = True ) [ : n ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Hi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> temp = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if Hi [ i ] <= Hi [ i - 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if temp > ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> temp = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if temp > ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> l = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = lcm ( l , a [ i ] ) <NEWLINE> <DEDENT> l %= mod <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inv = pow ( a [ i ] , mod - 2 , mod ) <NEWLINE> ans += ( l * inv ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> ans = N <NEWLINE> <NL> left_W = 0 <NEWLINE> right_E = S [ 1 : ] . count ( <STRING> ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans = min ( ans , S [ 1 : ] . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> elif n == N - 1 : <NEWLINE> <INDENT> ans = min ( ans , S [ : n ] . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if S [ n ] == <STRING> : <NEWLINE> <INDENT> right_E -= 1 <NEWLINE> <DEDENT> if S [ n - 1 ] == <STRING> : <NEWLINE> <INDENT> left_W += 1 <NEWLINE> <DEDENT> ans = min ( ans , left_W + right_E ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> two = 1 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> one = np . count_nonzero ( a & 1 ) <NEWLINE> a = a >> 1 <NEWLINE> ans = ( ans + ( one * ( n - one ) ) * two ) % mod <NEWLINE> two = ( two * 2 ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> a = [ str ( c ) for c in s ] <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> and a [ i + 1 ] == <STRING> and a [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> b = math . factorial ( a ) <NEWLINE> print ( b % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( list ) : <NEWLINE> <INDENT> return reduce ( lcm_base , list , 1 ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> print ( lcm_list ( T ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( int ( input ( ) ) - 1 ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if now == 1 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> if c >= n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> now = arr [ now ] <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans [ A [ i - 1 ] - 1 ] = i <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if s <= k : <NEWLINE> <INDENT> ans = ( s + 2 ) * ( s + 1 ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> ans = ans + ( 0 <= s - i - j <= k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> amax = max ( a for a , b in ab ) <NEWLINE> dp = [ 0 ] + [ 0 ] * ( h + amax ) <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( dp [ h ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> <NL> <COMMENT> <NL> if c [ 0 ] [ 0 ] + c [ 1 ] [ 1 ] == c [ 0 ] [ 1 ] + c [ 1 ] [ 0 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 1 ] + c [ 1 ] [ 2 ] == c [ 0 ] [ 2 ] + c [ 1 ] [ 1 ] : <NEWLINE> <INDENT> if c [ 1 ] [ 0 ] + c [ 2 ] [ 1 ] == c [ 1 ] [ 1 ] + c [ 2 ] [ 0 ] : <NEWLINE> <INDENT> if c [ 1 ] [ 1 ] + c [ 2 ] [ 2 ] == c [ 1 ] [ 2 ] + c [ 2 ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> taste_lists = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> taste = l + i <NEWLINE> taste_lists . append ( taste ) <NEWLINE> <NL> <DEDENT> eat = 0 <NEWLINE> if taste_lists [ 0 ] > 0 and taste_lists [ - 1 ] > 0 : <NEWLINE> <INDENT> eat = taste_lists [ 0 ] <NEWLINE> <DEDENT> elif taste_lists [ 0 ] < 0 and taste_lists [ - 1 ] < 0 : <NEWLINE> <INDENT> eat = taste_lists [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> eat = 0 <NEWLINE> <NL> <DEDENT> taste_lists . remove ( eat ) <NEWLINE> ans = 0 <NEWLINE> for i in taste_lists : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for ai in range ( a + 1 ) : <NEWLINE> <INDENT> for bi in range ( b + 1 ) : <NEWLINE> <INDENT> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> y = 500 * ai + 100 * bi + 50 * ci <NEWLINE> if x == y : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if y > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) - 1 <NEWLINE> <NL> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> or i == k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s [ i ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , A ) ) <COMMENT> <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> num = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> heapq . heappush ( a , - 1 * ( int ( num / 2 ) ) ) <NEWLINE> <COMMENT> <NL> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> height = 0 <NEWLINE> res = 1 <NEWLINE> def checkF ( k , x ) : <NEWLINE> <INDENT> if k > x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> height += List [ i ] <NEWLINE> res += 1 <NEWLINE> if checkF ( height , X ) : <NEWLINE> <INDENT> res = res - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> c = 0 <NEWLINE> MAX = 0 <NEWLINE> a1 = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] <= a1 : <NEWLINE> <INDENT> a1 = A [ i ] <NEWLINE> <DEDENT> a2 = A [ i + 1 ] <NEWLINE> if MAX == a2 - a1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif MAX < a2 - a1 : <NEWLINE> <INDENT> MAX = a2 - a1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = S . find ( str ( k ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a + 1 < 2 * k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> up = 10 ** 5 + 1 <NEWLINE> lo = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if lo < l [ i ] [ 0 ] : <NEWLINE> <INDENT> lo = l [ i ] [ 0 ] <NEWLINE> <DEDENT> if up > l [ i ] [ 1 ] : <NEWLINE> <INDENT> up = l [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i >= lo and i <= up : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> qn = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> S = <STRING> + S <NEWLINE> cnt = [ ] <NEWLINE> cnt . append ( 0 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( S [ i - 1 : i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> cnt . append ( cnt [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( cnt [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for q in qn : <NEWLINE> <INDENT> ans = cnt [ q [ 1 ] ] - cnt [ q [ 0 ] - 1 ] <NEWLINE> if S [ q [ 0 ] - 1 : q [ 0 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> dum = round ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( dum , - 1 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from itertools import accumulate <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> btfl = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> btfl . append ( a [ j ] - a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 50 ) [ : : - 1 ] : <NEWLINE> <INDENT> num , cnt = ans + pow ( 2 , i ) , 0 <NEWLINE> for b in btfl : <NEWLINE> <INDENT> if num == num & b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> ans = num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_sorted = sorted ( L , reverse = False ) <COMMENT> <NEWLINE> count = 0 <NEWLINE> import bisect <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = L_sorted [ i ] <NEWLINE> b = L_sorted [ j ] <NEWLINE> bisect . bisect_left ( L_sorted , a + b ) <NEWLINE> count += bisect . bisect_left ( L_sorted , a + b ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> A . sort ( ) <NEWLINE> A = deque ( A ) <NEWLINE> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> fin = False <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> if fin == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = 0 <NEWLINE> while i < BC [ m ] [ 0 ] : <NEWLINE> <INDENT> if A : <NEWLINE> <INDENT> if BC [ m ] [ 1 ] >= A [ 0 ] : <NEWLINE> <INDENT> ans += BC [ m ] [ 1 ] <NEWLINE> A . popleft ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum ( A ) <NEWLINE> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if fin == False and A : <NEWLINE> <INDENT> ans += sum ( A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> I = [ H [ i + 1 ] - H [ i ] for i in range ( N - 1 ) ] <NEWLINE> N = len ( I ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if I [ i ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif I [ i ] < - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if I [ j ] >= 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif I [ j ] <= - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) for _ in range ( n ) ] <NEWLINE> A . sort ( ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
r = input ( ) . split ( ) <NEWLINE> H = int ( r [ 0 ] ) <NEWLINE> N = int ( r [ 1 ] ) <NEWLINE> data_pre = input ( ) . split ( ) <NEWLINE> data = [ int ( s ) for s in data_pre ] <NEWLINE> if sum ( data ) >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A >= 2 * K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( A + i ) <NEWLINE> <DEDENT> for j in reversed ( range ( K ) ) : <NEWLINE> <INDENT> print ( B - j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = deque ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if n % 2 == i % 2 : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> <NL> for elem in b : <NEWLINE> <INDENT> ans . append ( elem ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dd = defaultdict ( lambda : 0 ) <NEWLINE> for aa in a : dd [ aa ] += 1 <NEWLINE> <NL> ans = 0 <NEWLINE> for aa in dd . keys ( ) : <NEWLINE> <INDENT> ca = dd [ aa ] <NEWLINE> if ca >= aa : <NEWLINE> <INDENT> ans += ca - aa <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ca <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ sorted ( input ( ) ) for i in range ( N ) ] <NEWLINE> SS = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> SS . append ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> c = collections . Counter ( SS ) <NEWLINE> <NL> for i in c . values ( ) : <NEWLINE> <INDENT> count += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P_min = [ ] <NEWLINE> a = 200000 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> val = sum ( a [ : K ] ) <NEWLINE> max_val = val <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> val += a [ K + i ] <NEWLINE> val -= a [ i ] <NEWLINE> max_val = max ( val , max_val ) <NEWLINE> <DEDENT> print ( max_val / 2 + K * 0.5 ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> A [ i ] = list ( map ( lambda x : x - 1 , map ( int , readline ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> candi = set ( range ( N ) ) <NEWLINE> <NL> day = 0 <NEWLINE> while candi : <NEWLINE> <INDENT> day += 1 <NEWLINE> nex = set ( ) <NEWLINE> done = set ( ) <NEWLINE> for player in candi : <NEWLINE> <INDENT> if player in done : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if len ( A [ player ] ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rival = A [ player ] [ - 1 ] <NEWLINE> if rival in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ rival ] [ - 1 ] == player : <NEWLINE> <COMMENT> <NL> <INDENT> A [ player ] . pop ( ) <NEWLINE> A [ rival ] . pop ( ) <NEWLINE> if A [ player ] : <NEWLINE> <INDENT> nex . add ( player ) <NEWLINE> <DEDENT> done . add ( player ) <NEWLINE> if A [ rival ] : <NEWLINE> <INDENT> nex . add ( rival ) <NEWLINE> <DEDENT> done . add ( rival ) <NEWLINE> <DEDENT> <DEDENT> if len ( done ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> candi = nex <NEWLINE> <NL> <DEDENT> print ( day ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> temp = sorted ( list ( input ( ) ) ) <NEWLINE> s . append ( <STRING> . join ( temp ) ) <NEWLINE> <DEDENT> s_count = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in s_count : <NEWLINE> <INDENT> ans += ( ( s_count [ i ] ) * ( s_count [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( 0 , int ( N // R ) + 1 ) : <NEWLINE> <INDENT> for g in range ( 0 , int ( ( N - R * r ) // G ) + 1 ) : <NEWLINE> <INDENT> if ( N - R * r - G * g ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> a , b = sorted ( A , reverse = True ) [ 0 : 2 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> all_price = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( i == N ) : <NEWLINE> <INDENT> all_price += abs ( A [ i - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> all_price += abs ( A [ i ] - now ) <NEWLINE> now = A [ i ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> print ( all_price + abs ( A [ i + 1 ] - 0 ) - <NEWLINE> <INDENT> ( abs ( A [ i ] - 0 ) + abs ( A [ i + 1 ] - A [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( i == N - 1 ) : <NEWLINE> <INDENT> print ( all_price + abs ( A [ i - 1 ] - 0 ) - <NEWLINE> <INDENT> ( abs ( A [ i ] - A [ i - 1 ] ) + abs ( abs ( A [ i ] - 0 ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( all_price + abs ( A [ i - 1 ] - A [ i + 1 ] ) - <NEWLINE> <INDENT> ( abs ( A [ i - 1 ] - A [ i ] ) + abs ( A [ i ] - A [ i + 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> ans = ( m - 1 ) / n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( n - d ) * 2 * ( m - 1 ) / ( n * n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> value = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> value [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> value [ nv ] += value [ v ] <NEWLINE> dfs ( nv ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * value ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= k : <NEWLINE> <INDENT> k -= a <NEWLINE> a = 0 <NEWLINE> if b <= k : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a -= k <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> print ( math . factorial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = N_List [ i ] <NEWLINE> ans [ s - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
L , R = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_mod = 2019 <NEWLINE> for a in range ( L , R ) : <NEWLINE> <INDENT> for b in range ( a + 1 , R + 1 ) : <NEWLINE> <INDENT> min_mod = min ( min_mod , ( a * b ) % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_mod ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , min ( b , a + k - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a + k ) , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nums = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : nums [ i ] += 1 <NEWLINE> <DEDENT> if i != n - 1 : nums [ i + 1 ] = nums [ i ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( nums [ r ] - nums [ l ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> F = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> move = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> seen = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def dfs ( sy , sx ) : <NEWLINE> <INDENT> seen [ sy ] [ sx ] = 1 <NEWLINE> b , w = 1 , 0 <NEWLINE> <NL> for dy , dx in move : <NEWLINE> <INDENT> ny = sy + dy <NEWLINE> nx = sx + dx <NEWLINE> if 0 <= ny < H and 0 <= nx < W and F [ ny ] [ nx ] != F [ sy ] [ sx ] and not seen [ ny ] [ nx ] : <NEWLINE> <INDENT> p = dfs ( ny , nx ) <NEWLINE> b += p [ 1 ] <COMMENT> <NEWLINE> w += p [ 0 ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return ( b , w ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if not seen [ i ] [ j ] : <NEWLINE> <INDENT> b , w = dfs ( i , j ) <NEWLINE> count += b * w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import re <NEWLINE> S = input ( ) <NEWLINE> string = re . findall ( <STRING> , S ) <NEWLINE> <NL> if len ( string ) != 0 : <NEWLINE> <INDENT> lenst = [ len ( x ) for x in string ] <NEWLINE> print ( max ( lenst ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> count += x . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> b = [ [ - 1 for i in range ( m ) ] for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> x = [ 0 , 0 , - 1 , 1 ] <NEWLINE> y = [ - 1 , 1 , 0 , 0 ] <NEWLINE> queue = deque ( [ [ 0 , 0 ] ] ) <NEWLINE> b [ 0 ] [ 0 ] = 1 <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> if now == [ n - 1 , m - 1 ] : <NEWLINE> <INDENT> print ( n * m - ( b [ n - 1 ] [ m - 1 ] + count ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a [ now [ 0 ] ] [ now [ 1 ] ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if 0 <= now [ 0 ] + y [ i ] < n and 0 <= now [ 1 ] + x [ i ] < m and b [ now [ 0 ] + y [ i ] ] [ now [ 1 ] + x [ i ] ] == - 1 : <NEWLINE> <INDENT> if a [ now [ 0 ] + y [ i ] ] [ now [ 1 ] + x [ i ] ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ now [ 0 ] + y [ i ] , now [ 1 ] + x [ i ] ] ) <NEWLINE> b [ now [ 0 ] + y [ i ] ] [ now [ 1 ] + x [ i ] ] = b [ now [ 0 ] ] [ now [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ x , y ] ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> s = set ( ) <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> s . add ( ( l [ k ] [ 0 ] - l [ j ] [ 0 ] , l [ k ] [ 1 ] - l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> s_l = sorted ( list ( s ) ) <NEWLINE> cnt = [ 0 ] * len ( s_l ) <NEWLINE> dic = { } <NEWLINE> for i in range ( len ( s_l ) ) : <NEWLINE> <INDENT> dic [ s_l [ i ] ] = i <NEWLINE> <DEDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> cnt [ dic [ ( l [ k ] [ 0 ] - l [ j ] [ 0 ] , l [ k ] [ 1 ] - l [ j ] [ 1 ] ) ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( n - max ( cnt ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = Counter ( D ) <NEWLINE> T = Counter ( T ) <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> D_count = D [ i ] <NEWLINE> T_count = T [ i ] <NEWLINE> if T_count > D_count : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> <NL> if sum ( s ) % 10 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( s ) - s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( sum ( s ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> for i in range ( h - 1 ) : <NEWLINE> <INDENT> for j in range ( w - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j : j + 2 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> if a [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , w ) : <NEWLINE> <INDENT> if a [ i ] [ k ] == <STRING> : <NEWLINE> <INDENT> if a [ i + 1 ] [ k - 2 : k ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a [ h - 2 ] [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if a [ h - 1 ] [ - 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> import heapq <NEWLINE> <NL> from typing import List , Tuple <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ ] <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> v . append ( ( p , c ) ) <NEWLINE> <NL> <DEDENT> print ( ag ( v , g ) ) <NEWLINE> <NL> <NL> <DEDENT> def ag ( v : List [ Tuple [ int , int ] ] , g : int ) -> int : <NEWLINE> <INDENT> rs = [ ] <NEWLINE> <COMMENT> <NL> v = [ ( i , p , c ) for i , ( p , c ) in enumerate ( v , 1 ) ] <NEWLINE> <NL> for j in range ( 2 ** len ( v ) ) : <NEWLINE> <INDENT> cb = [ ] <NEWLINE> for k in range ( len ( v ) ) : <NEWLINE> <INDENT> if ( ( j >> k ) & 1 ) : <NEWLINE> <INDENT> cb . append ( v [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> sc = 0 <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> for ( i , p , c ) in cb : <NEWLINE> <INDENT> sc += i * 100 * p + c <NEWLINE> cnt += p <NEWLINE> <NL> <DEDENT> vv = [ x for x in copy . copy ( v ) if not x in cb ] <NEWLINE> while sc < g : <NEWLINE> <INDENT> if not vv : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i , p , _ = vv . pop ( ) <NEWLINE> for _ in range ( p - 1 ) : <NEWLINE> <INDENT> if sc >= g : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sc += i * 100 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if sc >= g : <NEWLINE> <INDENT> heapq . heappush ( rs , cnt ) <NEWLINE> <DEDENT> <DEDENT> return heapq . heappop ( rs ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( int ( input ( ) ) for i in range ( m ) ) <NEWLINE> x = ( 10 ** 9 ) + 7 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ - 1 ] % x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> order = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> order [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , order ) ) ) <NEWLINE>
N , H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = 0 <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = max ( A , a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> B = sorted ( [ b for b in B if b > A ] , reverse = True ) <NEWLINE> from itertools import accumulate <NEWLINE> B = list ( accumulate ( B ) ) <NEWLINE> total_throw_damage = ( B [ - 1 ] if len ( B ) > 0 else 0 ) <NEWLINE> <NL> HP_after_throw = H - total_throw_damage <NEWLINE> if HP_after_throw <= 0 : <NEWLINE> <INDENT> for i , b in enumerate ( B , 1 ) : <NEWLINE> <INDENT> if H <= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> raise AssertionError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q , r = divmod ( HP_after_throw , A ) <NEWLINE> print ( len ( B ) + q + min ( 1 , r ) ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] ; b = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> a . append ( c ) <NEWLINE> b [ c - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> if k - ( q - i ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : a += [ a [ - 1 ] + 1 ] <NEWLINE> else : a += [ a [ - 1 ] ] <NEWLINE> <DEDENT> w = s . count ( <STRING> ) <NEWLINE> print ( min ( i - a [ i ] * 2 + w for i in range ( n + 1 ) ) ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , k = MAP ( ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> flag = 1 <NEWLINE> que = deque ( [ 0 ] * ( 2 * k + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> que . append ( count ) <NEWLINE> tmp += count - que . popleft ( ) <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> flag = 0 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag == 0 : <NEWLINE> <INDENT> que . append ( count ) <NEWLINE> tmp += count - que . popleft ( ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> flag = 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> que . append ( count ) <NEWLINE> tmp += count - que . popleft ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> tmp -= que . popleft ( ) <NEWLINE> <DEDENT> ans = max ( ans , sum ( que ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> SA = sum ( A ) <NEWLINE> SB = sum ( B ) <NEWLINE> S = SA - SB <NEWLINE> cnt = 0 <NEWLINE> ns = 0 <NEWLINE> if SB > SA : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> C . append ( a - b ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> ns += b - a <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> C . sort ( reverse = True ) <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> if ns > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ns -= C [ i ] <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 0 ] = 1 <NEWLINE> ans [ 1 ] = 1 <NEWLINE> <NL> broken = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> broken [ i ] = - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if broken [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> ans [ i + 1 ] = ans [ i - 1 ] % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + 1 ] = ( ans [ i - 1 ] + ans [ i ] ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> l = [ lr [ i ] [ 0 ] for i in range ( Q ) ] <NEWLINE> r = [ lr [ i ] [ 1 ] for i in range ( Q ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> c = [ 0 ] * N <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i , j in zip ( l , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( c [ j - 1 ] - c [ i - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def biser ( lst , func ) : <NEWLINE> <INDENT> n = len ( lst ) <NEWLINE> nh = n // 2 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if func ( lst [ 0 ] ) : <NEWLINE> <INDENT> return lst [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> if func ( lst [ nh ] ) : <NEWLINE> <INDENT> return biser ( lst [ nh : ] , func ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return biser ( lst [ : nh ] , func ) <NEWLINE> <NL> <DEDENT> <DEDENT> def mkns ( a , s , m ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( ( s + 1 ) << a ) | s ) & m <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ss = [ 0 ] * ( N + 1 ) <NEWLINE> pm = ( 1 << K ) - 1 <NEWLINE> mask = lambda c : ( 1 << K ) - ( 1 << c ) <NEWLINE> nn = 0 <NEWLINE> def isunnec ( i ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if a [ j ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i ] = ( ( ( ss [ i ] + 1 ) << a [ j ] ) | ss [ i ] ) & pm <NEWLINE> <DEDENT> if ss [ i ] & mask ( K - a [ i ] ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss [ i + 1 ] = ( ( ( ss [ i ] + 1 ) << a [ i ] ) | ss [ i ] ) & pm <NEWLINE> <DEDENT> nn = biser ( list ( range ( N ) ) , isunnec ) + 1 <NEWLINE> print ( nn ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> SMs = [ ] <NEWLINE> for i in range ( 2 , n // 2 + 2 ) : <NEWLINE> <INDENT> SMs . append ( sum ( list ( map ( int , str ( i ) ) ) ) + sum ( list ( map ( int , str ( n - i ) ) ) ) ) <NEWLINE> <DEDENT> print ( min ( SMs ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> A = s . index ( <STRING> ) <NEWLINE> for i in range ( A , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = i ( ) <NEWLINE> p = l ( ) <NEWLINE> count = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
def combs_mod ( n , k , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> inv = [ 1 ] * ( k + 1 ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> inv [ i ] = pow ( i , - 1 , mod ) <NEWLINE> <DEDENT> ans = [ 1 ] * ( k + 1 ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] * ( n + 1 - i ) * inv [ i ] % mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K < N : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> com = combs_mod ( K , K , mod ) <NEWLINE> com2 = combs_mod ( K - 1 , K - 1 , mod ) <NEWLINE> for r in range ( K + 1 ) : <NEWLINE> <INDENT> b = K - r <NEWLINE> dif = r - b <NEWLINE> if dif < 0 or r < N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif dif == 0 : <NEWLINE> <INDENT> ans += com2 [ r ] <NEWLINE> if N >= 2 : <NEWLINE> <INDENT> ans -= com2 [ N - 2 ] <NEWLINE> <DEDENT> <DEDENT> elif dif < N : <NEWLINE> <INDENT> ans += com [ r ] - com [ N - 1 - dif ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += com [ r ] <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
import numpy as np <NEWLINE> from numpy . fft import rfft , irfft <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> class Polynomial : <NEWLINE> <INDENT> def __init__ ( self , coefficient = None , dim = 0 , const = 1 ) : <NEWLINE> <INDENT> if coefficient == None : <NEWLINE> <INDENT> self . coefficient = np . zeros ( dim + 1 , np . int64 ) <NEWLINE> self . coefficient [ dim ] = const <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . coefficient = coefficient <NEWLINE> <NL> <DEDENT> <DEDENT> def __add__ ( self , other ) : <COMMENT> <NEWLINE> <INDENT> f , g = self . coefficient , other . coefficient <NEWLINE> if len ( f ) > len ( g ) : f , g = g , f <NEWLINE> <NL> h = Polynomial ( dim = len ( g ) - 1 , const = 0 ) <NEWLINE> h . coefficient [ len ( f ) : ] += g [ len ( f ) : ] <NEWLINE> h . coefficient [ : len ( f ) ] += f + g [ : len ( f ) ] <NEWLINE> return h <NEWLINE> <NL> <DEDENT> def __iadd__ ( self , other ) : <COMMENT> <NEWLINE> <INDENT> h = self . __add__ ( other ) <NEWLINE> self . coefficient = h . coefficient <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def __mul__ ( self , other ) : <COMMENT> <NEWLINE> <INDENT> f = self . coefficient <NEWLINE> g = other . coefficient <NEWLINE> h = Polynomial ( ) <NEWLINE> h . coefficient = self . fft ( f , g ) [ : len ( f ) + len ( g ) - 1 ] <NEWLINE> return h <NEWLINE> <NL> <DEDENT> def __len__ ( self ) : <NEWLINE> <INDENT> return len ( self . coefficient ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , key ) : <NEWLINE> <INDENT> return self . coefficient [ key ] <NEWLINE> <NL> <DEDENT> def get_coefficient ( self , x ) : <NEWLINE> <INDENT> return self . coefficient [ x ] <NEWLINE> <NL> <NL> <DEDENT> def fft ( self , A , B , fft_len = 1 << 18 ) : <NEWLINE> <INDENT> x = irfft ( rfft ( A , fft_len ) * rfft ( B , fft_len ) ) <NEWLINE> return np . rint ( x ) . astype ( np . int64 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> A = list ( mi ( ) ) <NEWLINE> <NL> coefficient = [ 0 ] * ( 2 * 10 ** 5 + 10 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> coefficient [ a ] += 1 <NEWLINE> <NL> <DEDENT> f = Polynomial ( coefficient = coefficient ) <NEWLINE> <NL> g = f * f <NEWLINE> ans = 0 <NEWLINE> handshake = M <NEWLINE> for x in range ( len ( g ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> count = g [ x ] <NEWLINE> if count <= 0 : continue <NEWLINE> <NL> if count > handshake : <NEWLINE> <INDENT> ans += handshake * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += count * x <NEWLINE> <NL> <DEDENT> handshake = max ( handshake - count , 0 ) <NEWLINE> if handshake == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from decimal import Decimal , ROUND_HALF_UP <NEWLINE> def lcm ( a ) : <NEWLINE> <INDENT> x = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> x = ( x * a [ i ] ) // math . gcd ( x , a [ i ] ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def gcd ( a ) : <NEWLINE> <INDENT> temp = math . gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in a : <NEWLINE> <INDENT> temp = math . gcd ( temp , i ) <NEWLINE> <DEDENT> return temp <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> zero = False <NEWLINE> count = 0 <NEWLINE> <COMMENT> <NL> mini = lcm ( a ) <NEWLINE> if len ( a ) != 1 : <NEWLINE> <INDENT> maxi = gcd ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxi = a [ 0 ] <NEWLINE> <DEDENT> maxi2 = maxi <NEWLINE> nibai = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if maxi2 % 2 == 0 : <NEWLINE> <INDENT> nibai *= 2 <NEWLINE> maxi2 //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if i % ( 2 * nibai ) == 0 : <NEWLINE> <INDENT> zero = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if not zero : <NEWLINE> <INDENT> t = Decimal ( str ( ( m * 2 // mini ) / 2 ) ) <NEWLINE> <COMMENT> <NL> print ( t . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import re <NEWLINE> pattern = re . compile ( <STRING> ) <NEWLINE> S = input ( ) <NEWLINE> print ( len ( max ( re . findall ( pattern , S ) , key = len , default = <STRING> ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 == p [ i ] : <NEWLINE> <INDENT> if i + 1 == n : <NEWLINE> <INDENT> p [ i ] , p [ i - 1 ] = p [ i - 1 ] , p [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ct = [ i [ 0 ] for i in ct if i [ 1 ] <= t ] <NEWLINE> if not ct : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ct ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for i in range ( 200000 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ x - 1 ] . append ( y + 99999 ) <NEWLINE> edges [ y + 99999 ] . append ( x - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> visited = [ 0 ] * ( 200000 ) <NEWLINE> cntx , cnty = 0 , 0 <NEWLINE> def dfs ( u ) : <NEWLINE> <INDENT> global cntx , cnty <NEWLINE> visited [ u ] = 1 <NEWLINE> if u // 100000 >= 1 : <NEWLINE> <INDENT> cnty += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cntx += 1 <NEWLINE> <DEDENT> for i in edges [ u ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = - 1 * n <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> cntx , cnty = 0 , 0 <NEWLINE> dfs ( i ) <NEWLINE> ans += cntx * cnty <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import numpy as np <NEWLINE> n , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> v = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w_ , v_ = map ( int , input ( ) . split ( ) ) <NEWLINE> w . append ( w_ ) <NEWLINE> v . append ( v_ ) <NEWLINE> <DEDENT> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ w [ i ] : ] = np . maximum ( dp [ : - w [ i ] ] + v [ i ] , dp [ w [ i ] : ] ) <NEWLINE> <DEDENT> print ( dp [ W ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> G [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> SD = [ 0 ] * N <NEWLINE> seen = [ 0 ] * N <NEWLINE> stack = [ ] <NEWLINE> stack . append ( [ K - 1 , 0 ] ) <NEWLINE> seen [ K - 1 ] = 1 <NEWLINE> while stack : <NEWLINE> <INDENT> x , d = stack . pop ( ) <NEWLINE> for y , d0 in G [ x ] : <NEWLINE> <INDENT> if seen [ y ] == 0 : <NEWLINE> <INDENT> SD [ y ] = d + d0 <NEWLINE> stack . append ( [ y , d + d0 ] ) <NEWLINE> seen [ y ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = SD [ x - 1 ] + SD [ y - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = list ( range ( A , min ( B , A + K ) ) ) + list ( range ( max ( A , B - K + 1 ) , B + 1 ) ) <NEWLINE> L_no_duplication = set ( L ) <NEWLINE> print ( * sorted ( L_no_duplication ) , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = set ( a ) <NEWLINE> if len ( set ( a ) ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_limit = b - a + 1 <NEWLINE> if num_limit <= k * 2 : <NEWLINE> <INDENT> ans_list = [ i for i in range ( a , b + 1 , 1 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list = [ ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> low = a + j <NEWLINE> high = b - j <NEWLINE> ans_list . append ( low ) <NEWLINE> ans_list . append ( high ) <NEWLINE> <DEDENT> ans_list . sort ( ) <NEWLINE> <NL> <DEDENT> for l in ans_list : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> k = n <NEWLINE> <DEDENT> h2 = h [ k : ] <NEWLINE> <NL> print ( sum ( h2 ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in reversed ( range ( len ( s ) ) ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] : <NEWLINE> <INDENT> a [ i ] = max ( a [ i ] , a [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
from math import gcd <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( set ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a . sort ( ) ; b = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : b = gcd ( b , a [ i ] ) <NEWLINE> if len ( a ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) if k == a [ 0 ] else print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) if k <= a [ - 1 ] and k % b == 0 else print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + k - 1 >= b - k + 1 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mini = 10 ** 9 <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] <= mini : <NEWLINE> <INDENT> mini = P [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> n = inint ( ) <NEWLINE> P = inintl ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = P [ i ] <NEWLINE> b = P [ i + 1 ] <NEWLINE> if a == i + 1 : <NEWLINE> <INDENT> P [ i ] = b <NEWLINE> P [ i + 1 ] = a <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if P [ - 1 ] == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = v [ 0 : : 2 ] <NEWLINE> b = v [ 1 : : 2 ] <NEWLINE> <NL> aa = Counter ( a ) <NEWLINE> bb = Counter ( b ) <NEWLINE> <NL> aaa = aa . most_common ( ) <NEWLINE> bbb = bb . most_common ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if aaa [ 0 ] [ 0 ] != bbb [ 0 ] [ 0 ] : <NEWLINE> <INDENT> ans = n - aaa [ 0 ] [ 1 ] - bbb [ 0 ] [ 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if len ( aa ) == len ( bb ) == 1 : <NEWLINE> <INDENT> ans = min ( aaa [ 0 ] [ 1 ] , bbb [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aaa . append ( ( <STRING> , 0 ) ) <NEWLINE> bbb . append ( ( <STRING> , 0 ) ) <NEWLINE> ans = n - max ( aaa [ 0 ] [ 1 ] + bbb [ 1 ] [ 1 ] , aaa [ 1 ] [ 1 ] + bbb [ 0 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
sequence = ( ( 1 , 3 , 5 , 7 , 8 , 10 , 12 ) , ( 4 , 6 , 9 , 11 ) , ( 2 , ) ) <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for s in sequence : <NEWLINE> <INDENT> if x in s and y in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 10 ** 5 + 1 <NEWLINE> for a in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> a , b = list ( str ( a ) ) , list ( str ( n - a ) ) <NEWLINE> ans = min ( ans , sum ( list ( map ( int , a ) ) ) + sum ( list ( map ( int , b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ls [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> ls . sort ( ) <NEWLINE> <COMMENT> <NL> if n == 2 : <NEWLINE> <INDENT> print ( abs ( ls [ 0 ] - ls [ 1 ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> smaller = ls [ : n // 2 + 1 ] <NEWLINE> bigger = ls [ n // 2 + 1 : ] <NEWLINE> diff_1 = 2 * sum ( bigger ) - 2 * sum ( smaller ) + smaller [ - 1 ] + smaller [ - 2 ] <NEWLINE> <COMMENT> <NL> smaller = ls [ : n // 2 ] <NEWLINE> bigger = ls [ n // 2 : ] <NEWLINE> diff_2 = - 2 * sum ( smaller ) + 2 * sum ( bigger ) - bigger [ 0 ] - bigger [ 1 ] <NEWLINE> diff = max ( diff_1 , diff_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> smaller = ls [ : n // 2 ] <NEWLINE> bigger = ls [ n // 2 : ] <NEWLINE> diff = 2 * sum ( bigger ) - min ( bigger ) - 2 * sum ( smaller ) + max ( smaller ) <NEWLINE> <NL> <DEDENT> print ( diff ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = 2 <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numval = list ( ) <NEWLINE> for data in range ( n ) : <NEWLINE> <INDENT> numval . append ( 1000000000 ) <NEWLINE> <DEDENT> numval [ 0 ] = 0 <NEWLINE> i = 0 <NEWLINE> if ( n < k ) : <NEWLINE> <INDENT> k = n - 1 <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for data in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if ( i + data ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> numval [ i + data ] = min ( numval [ i + data ] , numval [ i ] + abs ( num [ i ] - num [ i + data ] ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( numval [ n - 1 ] ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> <NL> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> t = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> <NL> <NL> hands = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> hands [ a ] += 1 <NEWLINE> hands [ b ] += 1 <NEWLINE> <NL> <DEDENT> number_of_colors = max ( * hands ) <NEWLINE> <NL> def next_color ( i ) : <NEWLINE> <INDENT> return i + 1 if i < number_of_colors else 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> class edge ( ) : <NEWLINE> <INDENT> def __init__ ( self , en ) : <NEWLINE> <INDENT> self . ends = en <NEWLINE> self . color = 0 <NEWLINE> <NL> <DEDENT> def set_color ( self , co ) : <NEWLINE> <INDENT> self . color = co <NEWLINE> <NL> <DEDENT> <DEDENT> class nord ( ) : <NEWLINE> <INDENT> def __init__ ( self , tr ) : <NEWLINE> <INDENT> self . parent = tr <NEWLINE> self . edges = [ ] <NEWLINE> <NL> <DEDENT> def add ( self , ed ) : <NEWLINE> <INDENT> self . edges . append ( ed ) <NEWLINE> <NL> <DEDENT> def set_color ( self , previous_color ) : <NEWLINE> <INDENT> co = next_color ( previous_color ) <NEWLINE> for ed in self . edges : <NEWLINE> <INDENT> if ed . color == 0 : <NEWLINE> <INDENT> ed . set_color ( co ) <NEWLINE> for i in ed . ends : <NEWLINE> <INDENT> no = self . parent . nords [ i - 1 ] <NEWLINE> if self is not no : <NEWLINE> <INDENT> no . set_color ( co ) <NEWLINE> <DEDENT> <DEDENT> co = next_color ( co ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nords = [ ] <NEWLINE> <NL> <DEDENT> def add_nord ( self , no ) : <NEWLINE> <INDENT> self . nords . append ( no ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , ed ) : <NEWLINE> <INDENT> for i in ed . ends : <NEWLINE> <INDENT> self . nords [ i - 1 ] . add ( ed ) <NEWLINE> <NL> <DEDENT> <DEDENT> def set_color ( self ) : <NEWLINE> <INDENT> self . nords [ 0 ] . set_color ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> tr = tree ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> no = nord ( tr ) <NEWLINE> tr . add_nord ( no ) <NEWLINE> <NL> <DEDENT> e_tree = [ ] <NEWLINE> for en in t : <NEWLINE> <INDENT> ed = edge ( en ) <NEWLINE> e_tree . append ( ed ) <NEWLINE> tr . add_edge ( ed ) <NEWLINE> <NL> <DEDENT> tr . set_color ( ) <NEWLINE> <NL> print ( number_of_colors ) <NEWLINE> for e in e_tree : <NEWLINE> <INDENT> print ( e . color ) <NEWLINE> <DEDENT>
class Factorial ( ) : <NEWLINE> <INDENT> def __init__ ( self , n , mod ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . fct = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> self . inv = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> self . fct [ 0 ] = 1 <NEWLINE> self . inv [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> self . fct [ i + 1 ] = self . fct [ i ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> self . inv [ n ] = pow ( self . fct [ n ] , mod - 2 , mod ) <NEWLINE> for i in range ( n ) [ : : - 1 ] : <NEWLINE> <INDENT> self . inv [ i ] = self . inv [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def comb ( self , m , k ) : <NEWLINE> <INDENT> if m < k : return 0 <NEWLINE> return self . fct [ m ] * self . inv [ k ] * self . inv [ m - k ] % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 998244353 <NEWLINE> N , A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f = Factorial ( N , MOD ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( K - A * i ) % B == 0 : <NEWLINE> <INDENT> j = ( K - A * i ) // B <NEWLINE> if 0 <= j <= N : <NEWLINE> <INDENT> res += f . comb ( N , i ) * f . comb ( N , j ) <NEWLINE> res %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = ( int ( input ( ) ) for i in range ( q ) ) <NEWLINE> d = defaultdict ( lambda : k - q ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> d [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for value in d . values ( ) : <NEWLINE> <INDENT> print ( <STRING> if value > 0 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X , Y , Z , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> e = [ ] <NEWLINE> s = [ ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> for j in B : <NEWLINE> <INDENT> e . append ( i + j ) <NEWLINE> <DEDENT> <DEDENT> e = sorted ( e , reverse = True ) <NEWLINE> <NL> if K < len ( e ) : <NEWLINE> <INDENT> e = e [ 0 : K ] <NEWLINE> <NL> <DEDENT> for i in e : <NEWLINE> <INDENT> for j in C : <NEWLINE> <INDENT> s . append ( i + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = sorted ( s , reverse = True ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <COMMENT> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> boolean = True <NEWLINE> while boolean : <NEWLINE> <INDENT> if is_prime ( x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> al = sum ( l ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> al -= l [ i ] <NEWLINE> <DEDENT> print ( al ) <NEWLINE>
<COMMENT> <NL> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MII ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LII ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <INDENT> N = II ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = S . find ( str ( k ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ 0 ] * N <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> P , S = map ( str , input ( ) . split ( ) ) <NEWLINE> P = int ( P ) - 1 <NEWLINE> if ac [ P ] != 1 and S == <STRING> : <NEWLINE> <INDENT> wa += abs ( ac [ P ] ) <NEWLINE> ac [ P ] = 1 <NEWLINE> <DEDENT> elif ac [ P ] != 1 and S == <STRING> : <NEWLINE> <INDENT> ac [ P ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac . count ( 1 ) , wa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> MMM = map ( int , input ( ) . split ( ) ) <NEWLINE> MM = list ( MMM ) <NEWLINE> mini = 2020202020 <NEWLINE> list1 = [ ] <NEWLINE> total = 0 <NEWLINE> for i in MM : <NEWLINE> <INDENT> total += i <NEWLINE> list1 . append ( total ) <NEWLINE> <DEDENT> for i in list1 : <NEWLINE> <INDENT> x = abs ( total - 2 * i ) <NEWLINE> if mini > x : <NEWLINE> <INDENT> mini = x <NEWLINE> <DEDENT> <DEDENT> print ( mini ) <NEWLINE>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> <NL> first_harf = Y [ : int ( N / 2 ) ] <NEWLINE> second_harf = Y [ int ( N / 2 ) : ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] <= first_harf [ - 1 ] : <NEWLINE> <INDENT> print ( second_harf [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( first_harf [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> max = l [ N - 1 ] <NEWLINE> tc = N <NEWLINE> st = [ j + 1 for j in range ( N - 1 ) ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if l [ i ] + l [ i + 1 ] > max : <NEWLINE> <INDENT> k = N - i - 1 <NEWLINE> ans += ( ( k - 1 ) * k * ( k + 1 ) ) // 6 <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if j == tc : <NEWLINE> <INDENT> ans += tp <NEWLINE> break <NEWLINE> <DEDENT> s = l [ i ] + l [ j ] <NEWLINE> if s <= l [ j + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s > max : <NEWLINE> <INDENT> tc = j <NEWLINE> tp = ( N - j - 1 ) * ( N - j ) // 2 <COMMENT> <NEWLINE> ans += tp <NEWLINE> break <NEWLINE> <DEDENT> start = st [ j ] <NEWLINE> if s <= l [ start ] : <NEWLINE> <INDENT> ans += start - j - 1 <NEWLINE> continue <NEWLINE> <DEDENT> end = N <NEWLINE> while start != end : <NEWLINE> <INDENT> center = ( start + end ) // 2 <NEWLINE> if s <= l [ center ] : <NEWLINE> <INDENT> end = center <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = center + 1 <NEWLINE> <DEDENT> <DEDENT> st [ j ] = end <NEWLINE> ans += end - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , x = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> la = [ int ( w ) for w in input ( ) . split ( ) ] + [ x ] <NEWLINE> la . sort ( ) <NEWLINE> if la [ 0 ] < 0 : <NEWLINE> <INDENT> m = la [ 0 ] <NEWLINE> la = [ w + m for w in la ] <NEWLINE> <NL> <DEDENT> diff = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> diff [ i ] = la [ i + 1 ] - la [ i ] <NEWLINE> <DEDENT> g = diff [ 0 ] <NEWLINE> for i in diff [ 1 : ] : <NEWLINE> <INDENT> g = math . gcd ( g , i ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> import bisect <NEWLINE> b = [ ] <NEWLINE> for i in B : <NEWLINE> <INDENT> x = bisect . bisect_right ( C , i ) <NEWLINE> b . append ( N - x ) <NEWLINE> <DEDENT> y = sum ( b ) <NEWLINE> c = [ y ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> y -= b [ i - 1 ] <NEWLINE> c . append ( y ) <NEWLINE> <DEDENT> c . append ( 0 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> a = bisect . bisect_right ( B , i ) <NEWLINE> ans += c [ a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> ZtoA = <STRING> <NEWLINE> diff = sorted ( list ( set ( ZtoA ) ^ set ( S ) ) ) <NEWLINE> if len ( S ) < 26 : <NEWLINE> <INDENT> print ( S + diff [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S == ZtoA : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 25 ) : <NEWLINE> <INDENT> if S [ i ] < S [ i + 1 ] : <NEWLINE> <INDENT> k = i <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( k + 1 , 26 ) : <NEWLINE> <INDENT> if S [ k ] < S [ i ] : <NEWLINE> <INDENT> a = min ( a , S [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( S [ : k ] + a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ [ <STRING> ] * ( w + 2 ) ] + [ list ( <STRING> + input ( ) + <STRING> ) for i in range ( h ) ] + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> <NL> flg = False <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if f [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if f [ y + 1 ] [ x ] == f [ y - 1 ] [ x ] == f [ y ] [ x + 1 ] == f [ y ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> flg = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) if flg else print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ A [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += ( l [ i ] + <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> R = [ 0 ] * N <NEWLINE> ans = 10 ** 9 <NEWLINE> def myadd ( i ) : <NEWLINE> <INDENT> if R [ i ] == 3 : <NEWLINE> <INDENT> R [ i ] = 0 <NEWLINE> myadd ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 ** N - 1 ) : <NEWLINE> <INDENT> myadd ( 0 ) <NEWLINE> if 1 in R and 2 in R and 3 in R : <NEWLINE> <INDENT> tmp = - 30 <NEWLINE> t1 , t2 , t3 = 0 , 0 , 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if R [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if R [ j ] == 1 : <NEWLINE> <INDENT> t1 += L [ j ] <NEWLINE> <DEDENT> elif R [ j ] == 2 : <NEWLINE> <INDENT> t2 += L [ j ] <NEWLINE> <DEDENT> elif R [ j ] == 3 : <NEWLINE> <INDENT> t3 += L [ j ] <NEWLINE> <DEDENT> tmp += 10 <NEWLINE> <DEDENT> tmp += abs ( A - t1 ) + abs ( B - t2 ) + abs ( C - t3 ) <NEWLINE> ans = min ( tmp , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> c = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in c : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= c . count ( a [ i ] ) <NEWLINE> ans %= 1000000007 <NEWLINE> c [ c . index ( a [ i ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> <NL> def neighbors ( ih , iw ) : <NEWLINE> <INDENT> for ih1 , iw1 in ( <NEWLINE> <INDENT> ( ih - 1 , iw ) , <NEWLINE> ( ih + 1 , iw ) , <NEWLINE> ( ih , iw - 1 ) , <NEWLINE> ( ih , iw + 1 ) , <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> if 0 <= ih1 < h and 0 <= iw1 < w and maze [ ih1 ] [ iw1 ] == <STRING> : <NEWLINE> <INDENT> yield ( ih1 , iw1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def len_maze ( ih , iw ) : <NEWLINE> <COMMENT> <NL> <INDENT> if maze [ ih ] [ iw ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> stepped = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> q0 = [ ( ih , iw ) ] <NEWLINE> l = - 1 <NEWLINE> while q0 : <NEWLINE> <INDENT> q1 = set ( ) <NEWLINE> for ih0 , iw0 in q0 : <NEWLINE> <INDENT> stepped [ ih0 ] [ iw0 ] = True <NEWLINE> for ih1 , iw1 in neighbors ( ih0 , iw0 ) : <NEWLINE> <INDENT> if not stepped [ ih1 ] [ iw1 ] : <NEWLINE> <INDENT> q1 . add ( ( ih1 , iw1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q0 = list ( q1 ) <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> return l <NEWLINE> <NL> <NL> <DEDENT> answer = max ( len_maze ( ih , iw ) for ih , iw in product ( range ( h ) , range ( w ) ) ) <NEWLINE> print ( answer ) <NEWLINE>
import bisect <NEWLINE> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = I ( ) <NEWLINE> a_li = sorted ( LI ( ) ) <NEWLINE> b_li = sorted ( LI ( ) ) <NEWLINE> c_li = sorted ( LI ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = b_li [ i ] <NEWLINE> k = n - bisect . bisect_right ( c_li , B ) <NEWLINE> l = bisect . bisect_left ( a_li , B ) <NEWLINE> ans += k * l <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> N = 10 ** 5 + 5 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = tuple ( A [ i + 1 ] - A [ i ] for i in range ( len ( A ) - 1 ) ) <NEWLINE> lim = math . ceil ( len ( B ) / 2 ) <NEWLINE> <NL> L = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> multi = cmb ( N , K , mod ) <NEWLINE> for j in range ( lim ) : <NEWLINE> <INDENT> front = j + 1 <NEWLINE> back = N - front <NEWLINE> tmp_b = 0 <NEWLINE> tmp_f = 0 <NEWLINE> if front >= K : <NEWLINE> <INDENT> tmp_f = cmb ( front , K , mod ) <NEWLINE> <DEDENT> if back >= K : <NEWLINE> <INDENT> tmp_b = cmb ( back , K , mod ) <NEWLINE> <DEDENT> if j == ( len ( B ) - 1 ) / 2 : <NEWLINE> <INDENT> ans += ( multi - tmp_b - tmp_f ) * ( B [ j ] ) % L <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( multi - tmp_b - tmp_f ) * ( B [ j ] + B [ len ( B ) - 1 - j ] ) % L <NEWLINE> <DEDENT> <DEDENT> print ( ans % L ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 800 * n - 200 * ( n // 15 ) ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> if l != [ ] : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if l == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <DEDENT>
S = set ( input ( ) ) <NEWLINE> a = set ( [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] ) <NEWLINE> result = sorted ( list ( a - S ) ) <NEWLINE> if len ( result ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result [ 0 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> h , w = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( str , input ( ) ) ) for i in range ( h ) ] <NEWLINE> l = [ [ 0 ] * ( w + 2 ) for i in range ( h + 2 ) ] <NEWLINE> <NL> <NL> def addFlag ( i , j ) : <NEWLINE> <INDENT> for x in range ( 3 ) : <NEWLINE> <INDENT> for y in range ( 3 ) : <NEWLINE> <INDENT> if l [ i + x ] [ j + y ] != <STRING> : <NEWLINE> <INDENT> l [ i + x ] [ j + y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> l [ i + 1 ] [ j + 1 ] = <STRING> <NEWLINE> addFlag ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = np . delete ( l , [ 0 , h + 1 ] , 0 ) <NEWLINE> l = np . delete ( l , [ 0 , w + 1 ] , 1 ) <NEWLINE> <NL> <NL> for i in l : <NEWLINE> <INDENT> ans = <STRING> . join ( map ( str , i ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> USED = [ False ] * 26 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> USED [ ord ( s ) - 97 ] = True <NEWLINE> <NL> <DEDENT> ok = False <NEWLINE> ans = None <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if not USED [ i ] : <NEWLINE> <INDENT> ans = chr ( 97 + i ) <NEWLINE> ok = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = [ input ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ [ float ( <STRING> ) ] * W for _ in range ( H ) ] <NEWLINE> dist [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> <NL> is_visited = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> is_visited [ start [ 0 ] ] [ start [ 1 ] ] = 1 <NEWLINE> <NL> q = deque ( [ start ] ) <NEWLINE> max_ = 0 <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> now_h , now_w = q . popleft ( ) <NEWLINE> if M [ now_h ] [ now_w ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for next_h , next_w in ( ( now_h + 1 , now_w ) , <NEWLINE> <INDENT> ( now_h - 1 , now_w ) , <NEWLINE> ( now_h , now_w - 1 ) , <NEWLINE> ( now_h , now_w + 1 ) ) : <NEWLINE> <NL> if not ( 0 <= next_h < H ) or not ( 0 <= next_w < W ) or ( is_visited [ next_h ] [ next_w ] == 1 ) or M [ next_h ] [ next_w ] == <STRING> : <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <NL> dist [ next_h ] [ next_w ] = dist [ now_h ] [ now_w ] + 1 <NEWLINE> is_visited [ next_h ] [ next_w ] = 1 <NEWLINE> <NL> max_ = max ( max_ , dist [ next_h ] [ next_w ] ) <NEWLINE> q . append ( ( next_h , next_w ) ) <NEWLINE> <DEDENT> <DEDENT> return max_ <NEWLINE> <NL> <DEDENT> max_ = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if M [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> max_ = max ( bfs ( ( h , w ) ) , max_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_ ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * L , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> from bisect import * <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j < N : <NEWLINE> <INDENT> ans += bisect_left ( L , L [ i ] + L [ j ] ) - j - 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
l = input ( ) <NEWLINE> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> if l [ i ] == l [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sorted ( h , reverse = True ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> q = sum ( m [ k : n ] ) <NEWLINE> print ( q ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . reverse ( ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i - 1 ] == h [ i ] - 1 : <NEWLINE> <INDENT> h [ i ] = h [ i ] - 1 <NEWLINE> <DEDENT> if h [ i - 1 ] < h [ i ] - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> import sys <NEWLINE> for j in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> if s [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ j ] [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ j - 1 ] [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ j ] [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ j + 1 ] [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if s - x - y <= k and s - x - y >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> for d in range ( 61 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( a >> d ) & 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> ans += x * ( n - x ) * 2 ** d <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> r [ i ] += r [ i - 1 ] + ( p [ i - 1 ] + 1 ) / 2 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , r [ j + k ] - r [ j ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
H , W , N = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import defaultdict as dd <NEWLINE> Grid = dd ( lambda : 0 ) <COMMENT> <NEWLINE> Draw = lambda x , y : [ ( x - i , y - j ) for i in range ( 3 ) for j in range ( 3 ) if 0 <= x - i < H - 2 and 0 <= y - j < W - 2 ] <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for x , y in Draw ( a - 1 , b - 1 ) : <COMMENT> <NEWLINE> <INDENT> Grid [ x , y ] += 1 <NEWLINE> <DEDENT> <DEDENT> Ans = [ ( H - 2 ) * ( W - 2 ) - len ( Grid ) if i == 0 else sum ( v == i for v in Grid . values ( ) ) for i in range ( 10 ) ] <NEWLINE> for ans in Ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> lcm = C * D // math . gcd ( C , D ) <NEWLINE> a = B - A + 1 <NEWLINE> b = B // C - ( A - 1 ) // C <NEWLINE> c = B // D - ( A - 1 ) // D <NEWLINE> d = B // lcm - ( A - 1 ) // lcm <NEWLINE> <NL> print ( a - b - c + d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> strings = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( list ( input ( ) ) ) ) <NEWLINE> if s in strings : <NEWLINE> <INDENT> strings [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> strings [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( list ( map ( lambda x : x * ( x - 1 ) // 2 , strings . values ( ) ) ) ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> heapq . heappush ( a , - 1 * ( - heapq . heappop ( a ) // 2 ) ) <NEWLINE> <DEDENT> print ( sum ( a ) * - 1 ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ - k ] ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> <NL> def conn ( n , m , e ) : <NEWLINE> <INDENT> d = dict ( zip ( range ( 1 , n + 1 ) , range ( - 1 , ( - 1 ) * n - 1 , - 1 ) ) ) <NEWLINE> td = defaultdict ( lambda : deque ( [ ] ) ) <COMMENT> <NEWLINE> c = 1 <NEWLINE> for edge in e : <NEWLINE> <INDENT> a = edge [ 0 ] <NEWLINE> b = edge [ 1 ] <NEWLINE> da = d [ a ] <COMMENT> <NEWLINE> db = d [ b ] <NEWLINE> if da < 0 and db < 0 : <NEWLINE> <INDENT> d [ a ] = c <NEWLINE> d [ b ] = c <NEWLINE> td [ c ] . append ( a ) <NEWLINE> td [ c ] . append ( b ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif da > 0 and db < 0 : <NEWLINE> <INDENT> d [ b ] = da <NEWLINE> td [ d [ a ] ] . append ( b ) <NEWLINE> <DEDENT> elif da < 0 and db > 0 : <NEWLINE> <INDENT> d [ a ] = db <NEWLINE> td [ d [ b ] ] . append ( a ) <NEWLINE> <DEDENT> elif da > 0 and db > 0 and da != db : <NEWLINE> <INDENT> for x in td [ db ] : <NEWLINE> <INDENT> d [ x ] = da <NEWLINE> td [ da ] . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return list ( d . values ( ) ) <NEWLINE> <NL> <DEDENT> def main ( n , k , l , e1 , e2 ) : <NEWLINE> <INDENT> d1 = conn ( n , k , e1 ) <NEWLINE> d2 = conn ( n , l , e2 ) <NEWLINE> p = tuple ( zip ( iter ( d1 ) , iter ( d2 ) ) ) <NEWLINE> d = Counter ( p ) <NEWLINE> <COMMENT> <NL> d [ ( k , l ) ] = 1 <NEWLINE> print ( <STRING> . join ( [ str ( d [ x ] ) for x in p ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ssr = sys . stdin . readline <NEWLINE> n , k , l = map ( int , ssr ( ) . strip ( ) . split ( ) ) <NEWLINE> e1 = [ ] <NEWLINE> e2 = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> e1 . append ( tuple ( map ( int , ssr ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( l ) : <NEWLINE> <INDENT> e2 . append ( tuple ( map ( int , ssr ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> main ( n , k , l , e1 , e2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> x = l [ i ] + l [ i + 1 ] + l [ i - 1 ] <NEWLINE> ans = max ( ans , x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m != 0 : <NEWLINE> <INDENT> l = [ list ( input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> p , s = [ list ( i ) for i in zip ( * l ) ] <NEWLINE> <DEDENT> t = [ 0 ] * n <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and t [ int ( p [ i ] ) - 1 ] != <STRING> : <NEWLINE> <INDENT> t [ int ( p [ i ] ) - 1 ] += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and t [ int ( p [ i ] ) - 1 ] != <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += t [ int ( p [ i ] ) - 1 ] <NEWLINE> t [ int ( p [ i ] ) - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> b = sorted ( a ) <NEWLINE> a1 = b [ - 1 ] <NEWLINE> a2 = b [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a1 : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * a * b == x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> mid = a ** 2 * b / 2 <NEWLINE> c = x / ( a ** 2 ) <NEWLINE> if mid == x : <NEWLINE> <INDENT> ans = 90 - math . degrees ( math . atan ( a / b ) ) <NEWLINE> <DEDENT> elif mid < x : <NEWLINE> <INDENT> d = 2 * x / ( a ** 2 ) - b <NEWLINE> ans = 90 - math . degrees ( math . atan ( a / ( b - d ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 2 * a * c / b <NEWLINE> ans = 90 - math . degrees ( math . atan ( d / b ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = list ( s ) <NEWLINE> ls [ k - 1 ] = ls [ k - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( ls ) ) <NEWLINE>
import math <NEWLINE> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> X_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( X_lst ) == 1 : <NEWLINE> <INDENT> print ( abs ( X_lst [ 0 ] - X ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> u = 0 <NEWLINE> if X_lst [ 0 ] == X : <NEWLINE> <INDENT> u = float ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( X_lst [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> if x == X : <NEWLINE> <INDENT> u = float ( <STRING> ) <NEWLINE> <NL> <DEDENT> if X_lst [ i - 1 ] < X < x : <NEWLINE> <INDENT> u = [ X - X_lst [ - 1 ] , x - X ] <NEWLINE> <NL> <DEDENT> if i == 1 : <NEWLINE> <INDENT> g = X_lst [ 1 ] - X_lst [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( g , x - X_lst [ i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if u == 0 : <NEWLINE> <INDENT> u = [ X - X_lst [ - 1 ] ] <NEWLINE> <DEDENT> elif u != float ( <STRING> ) : <NEWLINE> <INDENT> g = max ( math . gcd ( g , u [ 0 ] ) , math . gcd ( g , u [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
import random <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def atoi ( s ) : <NEWLINE> <INDENT> return ord ( s ) - ord ( <STRING> ) + 1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> mod = ( 1 << 61 ) - 1 <NEWLINE> b = random . randint ( 10000 , mod - 1 ) <NEWLINE> <NL> <NL> l = 0 <NEWLINE> r = ( N + 1 ) // 2 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> d = ( r + l ) // 2 <NEWLINE> memo = defaultdict ( int ) <NEWLINE> isok = False <NEWLINE> h = 0 <NEWLINE> t = pow ( b , d , mod ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> h = ( h * b + atoi ( S [ i ] ) ) % mod <NEWLINE> <DEDENT> memo [ h ] = 1 <NEWLINE> for i in range ( 1 , N - d + 1 ) : <NEWLINE> <INDENT> h = ( h * b + atoi ( S [ i + d - 1 ] ) - t * atoi ( S [ i - 1 ] ) ) % mod <NEWLINE> if not memo [ h ] : <NEWLINE> <INDENT> memo [ h ] = i + 1 <NEWLINE> <DEDENT> elif memo [ h ] and i - memo [ h ] + 1 >= d : <NEWLINE> <INDENT> isok = True <NEWLINE> <DEDENT> <DEDENT> if isok : <NEWLINE> <INDENT> l = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = d <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> tmp = <STRING> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> chtmp = ord ( S [ i ] ) + N <NEWLINE> if ( chtmp > ord ( <STRING> ) ) : <NEWLINE> <INDENT> chtmp -= ( ord ( <STRING> ) - ord ( <STRING> ) + 1 ) <NEWLINE> <DEDENT> tmp += chr ( chtmp ) <NEWLINE> <DEDENT> print ( tmp ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( a - b ) == 1 : <NEWLINE> <INDENT> c = math . factorial ( a ) % ( 10 ** 9 + 7 ) <NEWLINE> d = math . factorial ( b ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( c * d % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> if abs ( a - b ) == 0 : <NEWLINE> <INDENT> c = math . factorial ( a ) % ( 10 ** 9 + 7 ) <NEWLINE> d = math . factorial ( b ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( c * d * 2 % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> if abs ( a - b ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if D [ 0 ] != 0 or 0 in D [ 1 : ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A = collections . Counter ( D ) <NEWLINE> A = list ( A . items ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> if len ( A ) != max ( D ) + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( max ( D ) ) : <NEWLINE> <INDENT> ans *= A [ i ] [ 1 ] ** A [ i + 1 ] [ 1 ] <NEWLINE> if ans >= 998244353 : <NEWLINE> <INDENT> ans %= 998244353 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += [ int ( input ( ) ) ] <NEWLINE> <DEDENT> s = sorted ( s ) <NEWLINE> a = sum ( s ) <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> a -= s [ i ] <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> f = 0 <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> c . append ( b [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if b [ i ] == N : <NEWLINE> <INDENT> d . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> e = set ( c ) & set ( d ) <NEWLINE> <NL> if len ( e ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
s = input ( ) + <STRING> <NEWLINE> <NL> <NL> p = [ 0 ] * ( len ( s ) - 1 ) <NEWLINE> key = s [ 0 ] <NEWLINE> strt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <NL> <INDENT> if key != s [ i ] : <NEWLINE> <INDENT> if key == <STRING> : <NEWLINE> <INDENT> p [ i ] += ( i - strt ) // 2 <NEWLINE> p [ i - 1 ] += ( i - strt ) // 2 + ( i - strt ) % 2 <NEWLINE> key = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ strt ] += ( i - strt ) // 2 + ( i - strt ) % 2 <NEWLINE> p [ strt - 1 ] += ( i - strt ) // 2 <NEWLINE> key = <STRING> <NEWLINE> <DEDENT> strt = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> results = { } <NEWLINE> p_list = [ ] <NEWLINE> y_list = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list . append ( p ) <NEWLINE> y_list . append ( y ) <NEWLINE> if results . get ( p ) is None : <NEWLINE> <INDENT> results [ p ] = [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> results [ p ] . append ( y ) <NEWLINE> <DEDENT> <DEDENT> for i , p in results . items ( ) : <NEWLINE> <INDENT> p_sorted = sorted ( p ) <NEWLINE> results [ i ] = p_sorted <NEWLINE> <NL> <DEDENT> for i , p in enumerate ( p_list ) : <NEWLINE> <INDENT> import bisect <NEWLINE> print ( <STRING> . format ( p ) + <STRING> . format ( bisect . bisect_left ( results [ p ] , y_list [ i ] ) + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ABC = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC . append ( [ a , b , a + b ] ) <NEWLINE> <NL> <DEDENT> taka = 0 <NEWLINE> aoki = 0 <NEWLINE> ABC . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> while ABC : <NEWLINE> <NL> <INDENT> taka += ABC . pop ( ) [ 0 ] <NEWLINE> if len ( ABC ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> aoki += ABC . pop ( ) [ 1 ] <NEWLINE> <DEDENT> print ( taka - aoki ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N - 1 ) >= ( K - 1 ) * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , k , v <NEWLINE> <NL> <DEDENT> def main ( n , k , v ) : <NEWLINE> <INDENT> ruisekiL = [ 0 ] * ( n + 1 ) <NEWLINE> ruisekiR = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ruisekiL [ i ] = ruisekiL [ i - 1 ] + v [ i - 1 ] <NEWLINE> ruisekiR [ i ] = ruisekiR [ i - 1 ] + v [ n - i ] <NEWLINE> <DEDENT> vv = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vv . append ( ( i + 1 , v [ i ] ) ) <NEWLINE> <DEDENT> vv . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> maxown = - 10 ** 7 <NEWLINE> for kk in range ( k + 1 ) : <NEWLINE> <INDENT> if n < kk : <NEWLINE> <INDENT> own = ruisekiL [ n ] <NEWLINE> m = 0 <NEWLINE> while m < n and vv [ m ] [ 1 ] < 0 : <NEWLINE> <INDENT> own -= vv [ i ] [ 1 ] <NEWLINE> m += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxown = max ( maxown , own ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( kk // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( kk - l + 1 ) : <NEWLINE> <INDENT> j = kk - i - l <NEWLINE> jj = n - j + 1 <NEWLINE> own = ruisekiL [ i ] + ruisekiR [ j ] <NEWLINE> <COMMENT> <NL> m = 0 <NEWLINE> mcnt = 0 <NEWLINE> while ( mcnt < l ) : <NEWLINE> <INDENT> if i < vv [ m ] [ 0 ] and vv [ m ] [ 0 ] < jj : <NEWLINE> <INDENT> m += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> own -= vv [ m ] [ 1 ] <NEWLINE> mcnt += 1 <NEWLINE> m += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxown = max ( own , maxown ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return maxown <NEWLINE> <NL> <DEDENT> def main2 ( n , k , v ) : <NEWLINE> <INDENT> ruisekiL = [ 0 ] * ( n + 1 ) <NEWLINE> ruisekiR = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ruisekiL [ i ] = ruisekiL [ i - 1 ] + v [ i - 1 ] <NEWLINE> ruisekiR [ i ] = ruisekiR [ i - 1 ] + v [ n - i ] <NEWLINE> <DEDENT> vv = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vv . append ( ( i + 1 , v [ i ] ) ) <NEWLINE> <DEDENT> vv . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> maxown = - 10 ** 7 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if i + j > k or i + j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> jj = n - j + 1 <NEWLINE> own = ruisekiL [ i ] + ruisekiR [ j ] <NEWLINE> <COMMENT> <NL> l = min ( i + j , k - i - j ) <NEWLINE> m = 0 <NEWLINE> mcnt = 0 <NEWLINE> while ( mcnt < l ) : <NEWLINE> <INDENT> if i < vv [ m ] [ 0 ] and vv [ m ] [ 0 ] < jj : <NEWLINE> <INDENT> m += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if vv [ m ] [ 1 ] >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> own -= vv [ m ] [ 1 ] <NEWLINE> mcnt += 1 <NEWLINE> m += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxown = max ( own , maxown ) <NEWLINE> <DEDENT> <DEDENT> return maxown <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k , v = readinput ( ) <NEWLINE> ans = main2 ( n , k , v ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> pos = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> if S [ i ] == T [ 0 ] or S [ i ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if not T [ j ] == S [ i + j ] and not S [ i + j ] == <STRING> : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> pos . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not pos : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> words = [ ] <NEWLINE> for p in pos : <NEWLINE> <INDENT> word = S [ 0 : p ] + T + S [ p + len ( T ) : ] <NEWLINE> for i in range ( len ( word ) ) : <NEWLINE> <INDENT> if word [ i ] == <STRING> : <NEWLINE> <INDENT> word [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> words . append ( word ) <NEWLINE> <DEDENT> words . sort ( ) <NEWLINE> print ( <STRING> . join ( words [ 0 ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = { int ( input ( ) ) for _ in range ( m ) } <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> x += dp [ i - 2 ] <NEWLINE> <DEDENT> dp [ i ] = x <NEWLINE> <DEDENT> ans = dp [ n ] % mod <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> x = sorted ( [ i for i in A . items ( ) if i [ 1 ] >= 2 ] ) <NEWLINE> <NL> if len ( x ) < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x [ - 1 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( x [ - 1 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ - 1 ] [ 0 ] * x [ - 2 ] [ 0 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> def lcm ( l ) : <NEWLINE> <INDENT> r = l . pop ( 0 ) <NEWLINE> for i in l : <NEWLINE> <INDENT> r = r * i // math . gcd ( r , i ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( lcm ( T ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> maxL , minR = 0 , N + 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> maxL = max ( L , maxL ) <NEWLINE> minR = min ( R , minR ) <NEWLINE> <DEDENT> ans = minR - maxL + 1 <NEWLINE> print ( ans if ans > 0 else 0 ) <NEWLINE>
<NL> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> s = sorted ( s ) <NEWLINE> t = sorted ( t ) <NEWLINE> x = s [ 0 ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> x = x + s [ i + 1 ] <NEWLINE> <DEDENT> y = t [ - 1 ] <NEWLINE> for i in range ( len ( t ) - 1 ) : <NEWLINE> <INDENT> y = y + t [ - i - 2 ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> l = [ ] <NEWLINE> l . append ( x ) <NEWLINE> l . append ( y ) <NEWLINE> l = sorted ( l ) <NEWLINE> <NL> if l . index ( x ) < l . index ( y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> k = int ( n ) % 111 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n [ 0 ] > n [ 1 ] or ( n [ 0 ] == n [ 1 ] and n [ 1 ] > n [ 2 ] ) : <NEWLINE> <INDENT> print ( n [ 0 ] * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( str ( int ( n [ 0 ] ) + 1 ) ) * 3 ) <NEWLINE> <DEDENT> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> ls . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ls ) if ls else <STRING> ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = - A [ i ] <NEWLINE> <DEDENT> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = - heapq . heappop ( A ) <NEWLINE> a = ( a // 2 ) * - 1 <NEWLINE> heapq . heappush ( A , a ) <NEWLINE> <DEDENT> print ( sum ( A ) * - 1 ) <NEWLINE>
from bisect import * <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a += bisect_left ( L , L [ i ] + L [ j ] ) - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A + B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import bisect <NEWLINE> a . sort ( ) <NEWLINE> <NL> idx = bisect . bisect_left ( a , 0 ) <NEWLINE> sm = [ abs ( x ) for x in a ] <NEWLINE> if idx % 2 == 0 : <NEWLINE> <INDENT> print ( sum ( sm ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( sm ) - 2 * min ( sm ) ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> W , H , x , y = il ( ) <NEWLINE> print ( ( W * H ) / 2 , 1 if W / 2 == x and H / 2 == y else 0 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> S = _S ( ) <NEWLINE> S += <STRING> <NEWLINE> <COMMENT> <NL> <NL> ans = np . zeros ( len ( S ) + 1 , dtype = <STRING> ) <NEWLINE> bc = S [ 0 ] <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> cc = S [ i ] <NEWLINE> if cc == bc : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if cc == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ i - 1 ] += math . ceil ( count / 2 ) <NEWLINE> <COMMENT> <NL> ans [ i ] += math . floor ( count / 2 ) <NEWLINE> count = 1 <NEWLINE> bc = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - count ] += math . ceil ( count / 2 ) <NEWLINE> ans [ i - count - 1 ] += math . floor ( count / 2 ) <NEWLINE> count = 1 <NEWLINE> bc = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ : - 2 ] ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> broken = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> broken . add ( int ( input ( ) ) ) <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if 1 in broken : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> if 2 in broken : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1 in broken : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp = [ 0 for i in range ( N + 1 ) ] <NEWLINE> if 1 not in broken : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> if 2 not in broken : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> if i in broken : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE> <DEDENT>
li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nx = [ 0 , 0 , 0 ] <NEWLINE> ans = 0 <NEWLINE> if all ( x & 1 == 0 for x in li ) and li [ 0 ] == li [ 1 ] == li [ 2 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if ( li [ 0 ] % 2 != 0 or li [ 1 ] % 2 != 0 or li [ 2 ] % 2 != 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nx [ 0 ] = ( li [ 1 ] + li [ 2 ] ) / 2 <NEWLINE> nx [ 1 ] = ( li [ 0 ] + li [ 2 ] ) / 2 <NEWLINE> nx [ 2 ] = ( li [ 0 ] + li [ 1 ] ) / 2 <NEWLINE> li = nx . copy ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> letters = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , } <NEWLINE> to_check = combinations ( [ i for i in <STRING> ] , 3 ) <NEWLINE> <NL> for word in s : <NEWLINE> <INDENT> if word [ 0 ] in letters : <NEWLINE> <INDENT> letters [ word [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in to_check : <NEWLINE> <INDENT> count += letters [ i [ 0 ] ] * letters [ i [ 1 ] ] * letters [ i [ 2 ] ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> p = math . gcd ( p , i - x ) <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> cnt = np . zeros ( ( 10 , 10 ) ) <NEWLINE> <NL> for x in map ( str , range ( 0 , N + 1 ) ) : <NEWLINE> <INDENT> cnt [ int ( x [ 0 ] ) , int ( x [ - 1 ] ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> ans += cnt [ i , j ] * cnt [ j , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> d = [ 0 ] * 20002 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> d [ i ] = min ( d [ i - a ] + b for a , b in c ) <NEWLINE> <DEDENT> print ( d [ h - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> al . append ( a ) <NEWLINE> <NL> <DEDENT> al . insert ( 0 , 0 ) <NEWLINE> ans = - 1 <NEWLINE> push = 1 <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> light = al [ push ] <NEWLINE> push = light <NEWLINE> if light == 2 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if N % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> low = D [ 0 : N // 2 ] <NEWLINE> high = D [ N // 2 : : ] <NEWLINE> <NL> flg = all ( low [ - 1 ] + 1 > x for x in low ) <NEWLINE> flg |= all ( high [ 0 ] - 1 >= x for x in high ) <NEWLINE> <NL> if flg == True : <NEWLINE> <INDENT> print ( high [ 0 ] - low [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> print ( len ( str ( n // i ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = list ( s ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> f = ( - ord ( s [ i ] ) + ord ( <STRING> ) + 1 ) % 26 <NEWLINE> if f <= k : <NEWLINE> <INDENT> l [ i ] = <STRING> <NEWLINE> k -= f <NEWLINE> <NL> <DEDENT> <DEDENT> k = k % 26 <NEWLINE> a = ord ( l [ - 1 ] ) + k <NEWLINE> if a > ord ( <STRING> ) : a -= 26 <NEWLINE> l [ - 1 ] = chr ( a ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> sn = len ( s ) <NEWLINE> tn = len ( t ) <NEWLINE> <NL> if sn < tn : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( sn - tn , - 1 , - 1 ) : <NEWLINE> <INDENT> matched = True <NEWLINE> for j in range ( tn ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] and s [ i + j ] != <STRING> : <NEWLINE> <INDENT> matched = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if matched : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not matched : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> ans = [ <STRING> ] * sn <NEWLINE> for j in range ( 0 , i ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> ans [ j ] = s [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( tn ) : <NEWLINE> <INDENT> ans [ i + j ] = t [ j ] <NEWLINE> <DEDENT> for j in range ( i + tn , sn ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> ans [ j ] = s [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( n * ( n - 1 ) ) // 2 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> H , W = 10 , 37 <NEWLINE> ARR = [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> ARR . append ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def calculate ( h , w , arr ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> <NL> q . append ( ( 0 , 0 ) ) <NEWLINE> <NL> dx = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dy = [ - 1 , 0 , 1 , 0 ] <NEWLINE> <NL> distance = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> distance [ 0 ] [ 0 ] = 1 <NEWLINE> while q . __len__ ( ) > 0 : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> my = y + dy [ i ] <NEWLINE> mx = x + dx [ i ] <NEWLINE> if ( my >= 0 ) and ( mx >= 0 ) and ( my <= ( h - 1 ) ) and ( mx <= ( w - 1 ) ) and ( distance [ my ] [ mx ] == 0 ) and ( <NEWLINE> <INDENT> arr [ my ] [ mx ] == <STRING> ) : <NEWLINE> distance [ my ] [ mx ] = distance [ y ] [ x ] + 1 <NEWLINE> q . append ( ( my , mx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> mmk = 0 <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> mmk += arr [ j ] . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> if distance [ h - 1 ] [ w - 1 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h * w - distance [ h - 1 ] [ w - 1 ] - mmk ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> calculate ( H , W , ARR ) <NEWLINE>
k , s = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = a [ 0 ] <NEWLINE> y = sum ( a [ 1 : ] ) <NEWLINE> ans = abs ( x - y ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> x += a [ i ] <NEWLINE> y -= a [ i ] <NEWLINE> ans = min ( abs ( x - y ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minus = [ ] <NEWLINE> plus = [ ] <NEWLINE> for x in xlst : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> minus . append ( - 1 * x ) <NEWLINE> <DEDENT> elif x > 0 : <NEWLINE> <INDENT> plus . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> minus . append ( 0 ) <NEWLINE> minus = minus [ : : - 1 ] <NEWLINE> plus = [ 0 ] + plus <NEWLINE> ans = 10 ** 20 <NEWLINE> ml = len ( minus ) <NEWLINE> pl = len ( plus ) <NEWLINE> <NL> pos = min ( k , ml - 1 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> mm = minus [ pos ] <NEWLINE> pp = plus [ k - pos ] <NEWLINE> ans_tmp = max ( mm , pp ) + min ( mm , pp ) * 2 <NEWLINE> ans = min ( ans , ans_tmp ) <NEWLINE> pos -= 1 <NEWLINE> if pos == - 1 or k - pos == pl : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> def calc ( x ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> if x <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n // x == n % x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += calc ( n // i ) + calc ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al = sorted ( a ) <NEWLINE> bl = sorted ( b ) <NEWLINE> cl = sorted ( c ) <NEWLINE> <NL> abl = [ 0 ] * n <NEWLINE> bcl = [ 0 ] * n <NEWLINE> i = n - 1 <NEWLINE> for j in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> abl [ j ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> while al [ i ] >= bl [ j ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> if i == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i == - 1 : <NEWLINE> <INDENT> abl [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abl [ j ] = i + 1 <NEWLINE> <DEDENT> <DEDENT> j = 0 <NEWLINE> bcl = [ 0 ] * n <NEWLINE> k = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if k == n : <NEWLINE> <INDENT> bcl [ j ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> while cl [ k ] <= bl [ j ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> if k == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if k == n : <NEWLINE> <INDENT> bcl [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bcl [ j ] = ( n - k ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> ans += abl [ s ] * bcl [ s ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> s = sum ( S ) <NEWLINE> if s % 10 != 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . sort ( ) <NEWLINE> for i in S : <NEWLINE> <INDENT> if i % 10 != 0 : <NEWLINE> <INDENT> s -= i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if s % 10 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> num = [ 0 ] <NEWLINE> be = <STRING> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if be == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> num . append ( num [ - 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> num . append ( num [ - 1 ] ) <NEWLINE> <NL> <DEDENT> be = s [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( abs ( num [ l ] - num [ r ] ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = ( 1 + P [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> if N == K : <NEWLINE> <INDENT> print ( sum ( P ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> P [ i ] += P [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> T [ i ] = P [ i ] - P [ i - K ] <NEWLINE> <NL> <DEDENT> T = T [ K : ] <NEWLINE> <NL> print ( max ( T ) ) <NEWLINE> <DEDENT>
def sigma ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> s = list ( map ( lambda x : 1 if x == <STRING> else - 1 , input ( ) ) ) <NEWLINE> l = [ s [ 0 ] ] <NEWLINE> for c in s [ 1 : ] : <NEWLINE> <INDENT> if c * l [ - 1 ] > 0 : <NEWLINE> <INDENT> l [ - 1 ] += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( c ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> now = 0 <NEWLINE> for c in l : <NEWLINE> <INDENT> if c < 0 : <NEWLINE> <INDENT> ans -= min ( now , abs ( c ) ) <NEWLINE> <DEDENT> ans += sigma ( abs ( c ) ) <NEWLINE> now = abs ( c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t += 1 / a [ i ] <NEWLINE> <NL> <DEDENT> print ( 1 / t ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> n = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> l = [ INF ] * n <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in a [ : : - 1 ] : <NEWLINE> <INDENT> l [ bisect_right ( l , i ) ] = i <NEWLINE> <DEDENT> print ( bisect_left ( l , INF ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> M = [ ] <NEWLINE> sqr_N = math . floor ( math . sqrt ( N ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( 1 , ( sqr_N + 1 ) ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> <NL> <DEDENT> <DEDENT> a_pair = N // a <NEWLINE> print ( a + a_pair - 2 ) <NEWLINE>
from collections import Counter <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = A . values ( ) <NEWLINE> k = len ( B ) - K <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( sorted ( B ) [ 0 : k ] ) ) <NEWLINE> <DEDENT>
def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> L , R = LI ( ) <NEWLINE> ans = 2020 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> y = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , y ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = 1 , n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , L ) <NEWLINE> r = min ( r , R ) <NEWLINE> <DEDENT> if l > r : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - l + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] /= 2 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> first = { } <NEWLINE> second = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if v [ i ] in first : <NEWLINE> <INDENT> first [ v [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first [ v [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v [ i ] in second : <NEWLINE> <INDENT> second [ v [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second [ v [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> first = sorted ( first . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> second = sorted ( second . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> f = first . pop ( ) <NEWLINE> s = second . pop ( ) <NEWLINE> <NL> if f [ 0 ] == s [ 0 ] : <NEWLINE> <INDENT> if len ( first ) >= 1 : <NEWLINE> <INDENT> if len ( second ) >= 1 : <NEWLINE> <INDENT> f2 = first . pop ( ) <NEWLINE> s2 = second . pop ( ) <NEWLINE> <NL> if f2 [ 1 ] + s [ 1 ] > f [ 1 ] + s2 [ 1 ] : <NEWLINE> <INDENT> f = f2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = second . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif len ( second ) >= 1 : <NEWLINE> <INDENT> f = first . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( 0 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - f [ 1 ] - s [ 1 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = NMI ( ) <NEWLINE> ab = [ NLI ( ) for _ in range ( M ) ] <NEWLINE> <NL> ENDsorted_sections = sorted ( ab , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> dropped_bridge = ENDsorted_sections [ 0 ] [ 1 ] <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> if ENDsorted_sections [ m ] [ 0 ] >= dropped_bridge : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> dropped_bridge = ENDsorted_sections [ m ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( reverse = True ) <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( sum ( h ) ) <NEWLINE> <DEDENT> elif k <= n : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> h [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( h ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
X , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> if ( 2 * Y - X ) % 3 != 0 or ( 2 * X - Y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( 2 * Y - X ) < 0 or ( 2 * X - Y ) < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x = ( 2 * Y - X ) // 3 <NEWLINE> y = ( 2 * X - Y ) // 3 <NEWLINE> <COMMENT> <NL> fac = [ 0 for i in range ( x + y + 1 ) ] <NEWLINE> inv = [ 0 for i in range ( x + y + 1 ) ] <NEWLINE> finv = [ 0 for i in range ( x + y + 1 ) ] <NEWLINE> <COMMENT> <NL> p = 1000000007 <NEWLINE> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> for i in range ( 2 , x + y + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % p <NEWLINE> <COMMENT> <NL> inv [ i ] = ( - ( p // i ) * inv [ p % i ] ) % p <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % p <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ( fac [ x + y ] * finv [ x ] % p ) * finv [ y ] % p ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> MOD = 1000000007 <NEWLINE> memo = [ 0 ] * ( N + 1 ) <NEWLINE> memo [ 0 ] = 1 <NEWLINE> if 1 not in A : <NEWLINE> <INDENT> memo [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i not in A : <NEWLINE> <INDENT> memo [ i ] = ( memo [ i - 2 ] + memo [ i - 1 ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( memo [ N ] ) <NEWLINE>
N = input ( ) <NEWLINE> l = list ( map ( int , N ) ) <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> <NL> if int ( N ) < 9 : <NEWLINE> <INDENT> ans = int ( N ) <NEWLINE> <NL> <DEDENT> elif l . count ( 9 ) >= len ( l ) - 1 : <NEWLINE> <INDENT> if l [ len ( l ) - 1 ] != 9 : <NEWLINE> <INDENT> spot = 8 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> spot = min ( l ) <NEWLINE> <DEDENT> ans = spot + ( len ( l ) - 1 ) * 9 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if l [ i ] < 9 and i < len ( l ) - 1 : <NEWLINE> <INDENT> spot = l [ i ] - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = spot + ( len ( l ) - 1 ) * 9 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( a , min ( a + k , b ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> l . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( max ( a , b - k + 1 ) , b + 1 ) : <NEWLINE> <INDENT> if not i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n * 2 <= m : <NEWLINE> <INDENT> ans += n <NEWLINE> m -= n * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += m // 2 <NEWLINE> m %= 2 <NEWLINE> <NL> <DEDENT> if m >= 4 : <NEWLINE> <INDENT> ans += m // 4 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> MOD = 2 ** 61 - 1 <NEWLINE> root = 10000 <NEWLINE> <NL> rhs = [ 0 ] <NEWLINE> for h in map ( ord , S ) : <NEWLINE> <INDENT> rhs . append ( ( root * rhs [ - 1 ] + h ) % MOD ) <NEWLINE> <NL> <DEDENT> pws = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pws . append ( pws [ - 1 ] * root % MOD ) <NEWLINE> <NL> <DEDENT> ok = 0 <NEWLINE> ng = N <NEWLINE> while ng - ok > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> hashes = dict ( ) <NEWLINE> flg = False <NEWLINE> for i in range ( N - mid + 1 ) : <NEWLINE> <INDENT> hashofsub = ( rhs [ i + mid ] - rhs [ i ] * pws [ mid ] ) % MOD <NEWLINE> if hashofsub in hashes : <NEWLINE> <INDENT> if i >= hashes [ hashofsub ] + mid : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> hashes [ hashofsub ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def solver ( s , k ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> cnt = [ 1 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> cnt [ - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> for x in cnt : <NEWLINE> <INDENT> res += ( x // 2 ) * k <NEWLINE> <NL> <DEDENT> if len ( cnt ) == 1 : <COMMENT> <NEWLINE> <INDENT> return ( len ( s ) * k ) // 2 <NEWLINE> <NL> <DEDENT> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> res -= ( cnt [ 0 ] // 2 ) * ( k - 1 ) + ( cnt [ - 1 ] // 2 ) * ( k - 1 ) <NEWLINE> res += ( ( cnt [ 0 ] + cnt [ - 1 ] ) // 2 ) * ( k - 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solver2 ( s , k ) : <NEWLINE> <INDENT> t = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> t += s <NEWLINE> <DEDENT> res = 0 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == t [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += cnt // 2 <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> res += cnt // 2 <NEWLINE> return res <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( solver ( s , k ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> import random <NEWLINE> import string <NEWLINE> <NL> <COMMENT> <NL> def randomCharacter ( n ) : <NEWLINE> <INDENT> alphabet_m = string . ascii_lowercase <NEWLINE> return <STRING> . join ( [ random . choice ( alphabet_m ) for _ in range ( n ) ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . sort ( reverse = True ) <NEWLINE> print ( sum ( lis [ b : ] ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> d = Counter ( A ) <NEWLINE> <NL> if len ( d ) > 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> k = list ( d . keys ( ) ) <NEWLINE> v = list ( d . values ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if len ( d ) == 3 and k [ 0 ] ^ k [ 1 ] ^ k [ 2 ] == 0 and v [ 0 ] == v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif len ( d ) == 2 and ( ( k [ 0 ] == 0 and v [ 1 ] == 2 * v [ 0 ] ) or ( k [ 1 ] == 0 and v [ 0 ] == 2 * v [ 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif len ( d ) == 1 and k [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> lis = [ i for i in l if i % 10 != 0 ] <NEWLINE> <NL> sum_l = sum ( l ) <NEWLINE> <NL> if sum_l % 10 != 0 : <NEWLINE> <INDENT> print ( sum_l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( lis ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum_l - min ( lis ) ) <NEWLINE> <DEDENT> <DEDENT>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ 100 ** D * i for i in range ( 102 ) if i % 100 != 0 ] [ N - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> S = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> a_cnt = S . count ( <STRING> ) <NEWLINE> b_cnt = S . count ( <STRING> ) <NEWLINE> c_cnt = S . count ( <STRING> ) <NEWLINE> if abs ( a_cnt - b_cnt ) <= 1 and abs ( a_cnt - c_cnt ) <= 1 and abs ( b_cnt - c_cnt ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
def candy ( ) : <NEWLINE> <INDENT> boxNum , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ain = input ( ) <NEWLINE> alist = ain . split ( <STRING> ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( 0 , boxNum - 1 ) : <NEWLINE> <INDENT> if int ( alist [ i + 1 ] ) + int ( alist [ i ] ) > x : <NEWLINE> <INDENT> s = s + ( int ( alist [ i + 1 ] ) + int ( alist [ i ] ) - x ) <NEWLINE> alist [ i + 1 ] = x - int ( alist [ i ] ) <NEWLINE> if int ( alist [ i + 1 ] ) < 0 : <NEWLINE> <INDENT> alist [ i ] = int ( alist [ i ] ) + int ( alist [ i + 1 ] ) <NEWLINE> alist [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> candy ( ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( X ) <NEWLINE> <NL> li = [ ] <NEWLINE> x . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <NL> <DEDENT> li . sort ( ) <NEWLINE> while len ( li ) > 1 : <NEWLINE> <INDENT> l = [ ] <NEWLINE> div = li [ 0 ] <NEWLINE> for n in li : <NEWLINE> <INDENT> mod = n % div <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> l . append ( mod ) <NEWLINE> <DEDENT> <DEDENT> l . append ( div ) <NEWLINE> l . sort ( ) <NEWLINE> li = l <NEWLINE> <DEDENT> print ( * li ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> card = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == card : <NEWLINE> <INDENT> card += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> C = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> vec = [ i for i , a in enumerate ( A , 1 ) for _ in range ( a ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> color = vec [ i * W + j ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> C [ i ] [ j ] = color <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ i ] [ W - j - 1 ] = color <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for row in C : <NEWLINE> <INDENT> print ( * row ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> S = np . array ( [ [ int ( c == <STRING> ) for c in input ( ) ] for _ in range ( H ) ] ) <NEWLINE> <NL> up = S . copy ( ) <NEWLINE> down = S . copy ( ) <NEWLINE> left = S . copy ( ) <NEWLINE> right = S . copy ( ) <NEWLINE> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> up [ i ] = ( up [ i - 1 ] + 1 ) * up [ i ] <NEWLINE> down [ - i - 1 ] = ( down [ - i ] + 1 ) * down [ - i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , W ) : <NEWLINE> <INDENT> left [ : , i ] = ( left [ : , i - 1 ] + 1 ) * left [ : , i ] <NEWLINE> right [ : , - i - 1 ] = ( right [ : , - i ] + 1 ) * right [ : , - i - 1 ] <NEWLINE> <NL> <DEDENT> print ( np . max ( up + down + left + right ) - 3 ) <NEWLINE>
from collections import * <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> b = deque ( ) <NEWLINE> <NL> b . append ( a [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> kouho = [ [ ] for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : <NEWLINE> <INDENT> kouho [ a - 1 ] . append ( - b ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> p = [ ] <NEWLINE> heapq . heapify ( p ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <NL> <INDENT> for j in kouho [ i ] : <NEWLINE> <INDENT> heapq . heappush ( p , j ) <NEWLINE> <DEDENT> if p : <NEWLINE> <INDENT> ans -= heapq . heappop ( p ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> S = input ( ) <NEWLINE> <NL> cs = [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] + S [ i ] == <STRING> : <NEWLINE> <INDENT> cs . append ( cs [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cs . append ( cs [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l , r in ( [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( Q ) ) : <NEWLINE> <INDENT> print ( cs [ r - 1 ] - cs [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import itertools <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( itertools . accumulate ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> s = [ None ] * ( n * ( n + 1 ) // 2 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> s [ cnt ] = format ( a [ j ] - a [ i ] , <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> sel = set ( range ( n * ( n + 1 ) // 2 ) ) <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> nxt = set ( [ ] ) <NEWLINE> for j in sel : <NEWLINE> <INDENT> if s [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> nxt . add ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( nxt ) >= k : <NEWLINE> <INDENT> sel = nxt <NEWLINE> ret += 2 ** ( 49 - i ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ma = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 - 1 ) : <NEWLINE> <INDENT> ma = max ( b [ i - 1 ] + b [ i ] + b [ i + 1 ] , ma ) <NEWLINE> <DEDENT> print ( ma ) <NEWLINE>
s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> D = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ s [ i ] ] += 1 <NEWLINE> <DEDENT> my_p = N // 2 <NEWLINE> score = my_p - D [ <STRING> ] <NEWLINE> print ( score ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> dp = [ 0 ] * 20001 <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in l ) <NEWLINE> <NL> <DEDENT> print ( dp [ h ] ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> <NL> digits = len ( str ( num ) ) <NEWLINE> <NL> ans = digits <NEWLINE> <NL> for i in range ( 1 , 10 ** ( digits // 2 + 1 ) ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> target = max ( len ( str ( i ) ) , len ( str ( num // i ) ) ) <NEWLINE> if ans >= target : <NEWLINE> <INDENT> ans = target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> tmp_min = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , ( - 1 ) * ( - tmp_min // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> ans = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> ans = s [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> array = [ 0 ] * len ( s ) <NEWLINE> <NL> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i - 1 : i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> array [ i ] = array [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ i ] = array [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> ans = array [ r ] - array [ l ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( 2 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> t = [ 3 ] <NEWLINE> cnt = 3 <NEWLINE> while t [ - 1 ] + cnt <= n : <NEWLINE> <INDENT> t . append ( t [ - 1 ] + cnt ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if t [ - 1 ] != n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> n_cols = t [ - 1 ] - t [ - 2 ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( n_cols + 1 ) <NEWLINE> t_len = len ( t ) <NEWLINE> t2 = [ i + 1 for i in t ] <NEWLINE> t3 = [ 0 for i in t ] <NEWLINE> for col in range ( n_cols + 1 ) : <NEWLINE> <INDENT> out = str ( n_cols ) <NEWLINE> if col <= 2 : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> elif col == 1 : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> elif col == 2 : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = t [ col - 3 ] + 1 <NEWLINE> while idx <= t [ col - 2 ] : <NEWLINE> <INDENT> out += <STRING> + str ( idx ) <NEWLINE> idx += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( t_len - 1 ) : <NEWLINE> <INDENT> if t2 [ i ] != t [ i + 1 ] + 1 : <NEWLINE> <INDENT> out += <STRING> + str ( t2 [ i ] ) <NEWLINE> t2 [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> turn = len ( s ) <NEWLINE> if s [ 0 ] == s [ turn - 1 ] : <NEWLINE> <INDENT> turn += 1 <NEWLINE> <DEDENT> if turn & 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( P ** ( 1 / N ) + 1.0E-7 ) <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if P % ( i ** N ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> point = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( b - 1 ) <NEWLINE> tree [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> stack = [ [ 0 , 0 , - 1 ] ] <NEWLINE> while stack : <NEWLINE> <INDENT> v , p , parent = stack . pop ( ) <NEWLINE> point [ v ] += p <NEWLINE> for child in tree [ v ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack . append ( [ child , point [ v ] , v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * point ) <NEWLINE>
s = input ( ) <NEWLINE> num = len ( s ) <NEWLINE> a = [ 0 ] * ( num + 1 ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = max ( a [ i + 1 ] , a [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if s [ - i ] == <STRING> : <NEWLINE> <INDENT> a [ - ( i + 1 ) ] = max ( a [ - ( i + 1 ) ] , a [ - i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> if A [ i ] + A [ i + 1 ] <= X : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = A [ i ] + A [ i + 1 ] - X <NEWLINE> if A [ i + 1 ] < temp : <NEWLINE> <INDENT> A [ i + 1 ] = 0 <NEWLINE> cnt += A [ i + 1 ] <NEWLINE> temp -= A [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i + 1 ] -= temp <NEWLINE> cnt += temp <NEWLINE> temp -= A [ i + 1 ] <NEWLINE> <NL> <DEDENT> if A [ i ] + A [ i + 1 ] > X : <NEWLINE> <INDENT> A [ i ] -= temp <NEWLINE> cnt += temp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a . append ( 0 ) <NEWLINE> <NL> l = [ 0 ] * ( n + 2 ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l [ i ] = max ( l [ i - 1 ] , a [ i ] ) <NEWLINE> <NL> <DEDENT> r = [ 0 ] * ( n + 2 ) <NEWLINE> r [ n ] = 0 <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> r [ i ] = max ( r [ i + 1 ] , a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( max ( l [ i - 1 ] , r [ i + 1 ] ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def ruiseki ( n , array ) : <NEWLINE> <INDENT> res = [ 0 ] * ( n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res [ i ] = res [ i - 1 ] + array [ i ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = ruiseki ( n , A ) <NEWLINE> <NL> ans = 10 ** 15 <NEWLINE> left_c = 0 <NEWLINE> right_c = 2 <NEWLINE> for center in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> while left_c + 1 < center : <NEWLINE> <INDENT> if abs ( sa [ center ] - 2 * sa [ left_c ] ) > abs ( sa [ center ] - 2 * sa [ left_c + 1 ] ) : <NEWLINE> <INDENT> left_c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> right_c = max ( right_c , center + 1 ) <NEWLINE> while right_c + 1 < n - 1 : <NEWLINE> <INDENT> if abs ( sa [ - 1 ] + sa [ center ] - 2 * sa [ right_c ] ) > abs ( sa [ - 1 ] + sa [ center ] - 2 * sa [ right_c + 1 ] ) : <NEWLINE> <INDENT> right_c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> x = max ( sa [ left_c ] , sa [ center ] - sa [ left_c ] , sa [ right_c ] - sa [ center ] , sa [ - 1 ] - sa [ right_c ] ) <NEWLINE> y = min ( sa [ left_c ] , sa [ center ] - sa [ left_c ] , sa [ right_c ] - sa [ center ] , sa [ - 1 ] - sa [ right_c ] ) <NEWLINE> ans = min ( ans , x - y ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> l . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h = l [ 0 ] [ 2 ] + abs ( i - l [ 0 ] [ 0 ] ) + abs ( j - l [ 0 ] [ 1 ] ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> tmp = max ( h - abs ( i - l [ k ] [ 0 ] ) - abs ( j - l [ k ] [ 1 ] ) , 0 ) <NEWLINE> if tmp != l [ k ] [ 2 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif k == N - 1 : <NEWLINE> <INDENT> X = i <NEWLINE> Y = j <NEWLINE> H = h <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( X , Y , H ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = ( a - 1 ) // x <NEWLINE> bb = b // x <NEWLINE> print ( bb - aa ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( range ( a , min ( b + 1 , a + k ) ) ) <NEWLINE> bl = list ( range ( max ( a , b - k + 1 ) , b + 1 ) ) <NEWLINE> l = sorted ( set ( al + bl ) ) <NEWLINE> for v in l : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> N = int ( input ( ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> tmp = y [ i ] + y [ j ] <NEWLINE> ans += bisect_left ( y , tmp ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def expectation ( N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return N / 2 + 0.5 <NEWLINE> <NL> <DEDENT> Ps = [ ] <NEWLINE> s = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> s += p <NEWLINE> Ps . append ( s ) <NEWLINE> <NL> <DEDENT> cmax = Ps [ K - 1 ] <NEWLINE> max_sp = 0 <NEWLINE> <NL> for ix in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> csum = Ps [ ix + K - 1 ] - Ps [ ix - 1 ] <NEWLINE> if cmax < csum : <NEWLINE> <INDENT> max_sp = ix <NEWLINE> cmax = csum <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ix in range ( max_sp , max_sp + K ) : <NEWLINE> <INDENT> ans += expectation ( P [ ix ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def prime_factorization ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> primes = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> primes . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <NL> <DEDENT> A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a_primes = set ( prime_factorization ( A ) ) <NEWLINE> b_primes = set ( prime_factorization ( B ) ) <NEWLINE> <NL> print ( len ( a_primes & b_primes ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ball = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if n // 2 < i : <NEWLINE> <INDENT> ball [ i ] = a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( sum ( ball [ i : : ( i + 1 ) ] ) - a [ i ] ) % 2 == 0 : <NEWLINE> <INDENT> ball [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ball [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> num = [ str ( i + 1 ) for i , x in enumerate ( ball ) if x == 1 ] <NEWLINE> <NL> if len ( num ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( num ) ) <NEWLINE> num = <STRING> . join ( num ) <NEWLINE> print ( num ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> n_hoge = int ( N ** 0.5 ) <NEWLINE> print <NEWLINE> <NL> true_ans = 10 ** 12 <NEWLINE> for i in range ( 1 , n_hoge + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = N // i <NEWLINE> true_ans = min ( ans + i - 2 , true_ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( true_ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> <NL> if c . most_common ( ) [ 0 ] [ 1 ] != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> N , K = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> queries = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> queries . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> temp_que = [ ] <NEWLINE> for num , val in queries : <NEWLINE> <INDENT> temp_que = num <NEWLINE> K -= val <NEWLINE> if K <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( temp_que ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> T = <STRING> . join ( sorted ( <STRING> . join ( sorted ( input ( ) ) ) , reverse = True ) ) <NEWLINE> print ( <STRING> if S < T else <STRING> ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> H , W = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> grid = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> grid . append ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> q = deque ( ) <NEWLINE> q . append ( ( 0 , 0 , 0 ) ) <NEWLINE> visited = set ( ) <NEWLINE> while q : <NEWLINE> <INDENT> x , y , c = q . popleft ( ) <NEWLINE> if x == W - 1 and y == H - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( x , y ) in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( ( x , y ) ) <NEWLINE> <NL> for dx , dy in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> if 0 <= nx < W and 0 <= ny < H and grid [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> q . append ( ( nx , ny , c + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if x == W - 1 and y == H - 1 : <NEWLINE> <INDENT> print ( H * W - black - c - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = ( d * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ l [ i ] ] = i + 1 <NEWLINE> <DEDENT> c = sorted ( c . items ( ) ) <NEWLINE> [ print ( s [ 1 ] , end = <STRING> ) for s in c ] <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) ; a . sort ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) ; b . sort ( ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) ; c . sort ( ) <NEWLINE> ab = [ 0 for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ab [ i ] = ab [ i - 1 ] + bisect . bisect_left ( a , b [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = bisect . bisect_left ( b , c [ i ] ) <NEWLINE> if tmp != 0 : <NEWLINE> <INDENT> ans += ab [ tmp - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if len ( set ( S ) ) == 1 : <NEWLINE> <INDENT> print ( ( N * K ) // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> tmpS = S * 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if tmpS [ i ] == tmpS [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmpS [ i + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if S [ N - 1 ] == S [ 0 ] : <NEWLINE> <INDENT> a = 1 <NEWLINE> while a <= N - 1 and S [ a - 1 ] == S [ a ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> b = 1 <NEWLINE> while b <= N - 1 and S [ N - b ] == S [ N - b - 1 ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> print ( cnt * K - ( a // 2 + b // 2 - ( a + b ) // 2 ) * ( K - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt * K ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a - 1 ] . append ( b ) <NEWLINE> E [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> dic = { } <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if not p - 1 in dic : <NEWLINE> <INDENT> dic [ p - 1 ] = x <NEWLINE> continue <NEWLINE> <DEDENT> dic [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> res = [ 0 for _ in range ( N ) ] <NEWLINE> def dfs ( p , s , ans ) : <NEWLINE> <INDENT> global res <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if s - 1 in dic : <NEWLINE> <INDENT> ans += dic [ s - 1 ] <NEWLINE> <NL> <DEDENT> res [ s - 1 ] = str ( ans ) <NEWLINE> if E [ s - 1 ] == [ p ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for e in E [ s - 1 ] : <NEWLINE> <INDENT> if e == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( s , e , ans ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 1 , 1 , 0 ) <NEWLINE> print ( <STRING> . join ( res ) ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> from typing import List , Optional <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> g [ l ] . append ( ( r , d ) ) <NEWLINE> g [ r ] . append ( ( l , - d ) ) <NEWLINE> <NL> <NL> <DEDENT> def ok ( cur : int , ds : int , dists : List [ Optional [ int ] ] ) -> bool : <NEWLINE> <INDENT> dists [ cur ] = ds <NEWLINE> <NL> flag = True <NEWLINE> for nx , d in g [ cur ] : <NEWLINE> <INDENT> if dists [ nx ] != None : <NEWLINE> <INDENT> flag &= dists [ nx ] - dists [ cur ] == d <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> flag &= ok ( nx , ds + d , dists ) <NEWLINE> <NL> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <NL> <DEDENT> dists = [ None ] * N <NEWLINE> ans = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ans and dists [ i ] == None : <NEWLINE> <INDENT> ans &= ok ( i , 0 , dists ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 7 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( a ) <NEWLINE> t = 4 <NEWLINE> s = [ ] <NEWLINE> for i in sorted ( count . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) : <NEWLINE> <INDENT> if i [ 1 ] >= 4 and t == 4 : <NEWLINE> <INDENT> print ( i [ 0 ] ** 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i [ 1 ] >= 2 and t != 0 : <NEWLINE> <INDENT> t -= 2 <NEWLINE> s . append ( i [ 0 ] ) <NEWLINE> <DEDENT> elif t == 0 : break <NEWLINE> <NL> <DEDENT> if len ( s ) != 0 : print ( s [ 0 ] * s [ 1 ] ) <NEWLINE> else : print ( 0 ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> abc = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( input ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> a = str ( a ) <NEWLINE> abc . append ( a ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( abc ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> num = c [ i ] <NEWLINE> if num != 1 : <NEWLINE> <INDENT> cnt += num * ( num - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
L = list ( input ( ) ) <NEWLINE> L = list ( set ( L ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> R = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( min ( 26 , len ( L ) ) ) : <NEWLINE> <INDENT> if L [ i ] != R [ i ] : <NEWLINE> <INDENT> print ( R [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if len ( L ) < 26 : <NEWLINE> <INDENT> print ( R [ len ( L ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> di = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ls [ a ] . append ( [ b , i + 1 ] ) <NEWLINE> <DEDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if ls [ j ] != [ ] : <NEWLINE> <INDENT> ls [ j ] . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for k in range ( len ( ls [ j ] ) ) : <NEWLINE> <INDENT> di . append ( [ ls [ j ] [ k ] [ 1 ] , str ( 10 ** 12 + j * 10 ** 6 + k + 1 ) [ 1 : ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> di . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> print ( di [ l ] [ 1 ] ) <NEWLINE> <DEDENT>
K , S = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> remain = S - x - y <NEWLINE> if 0 <= remain and remain <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x_sort = sorted ( x [ : ] ) <NEWLINE> a , b = x_sort [ n // 2 - 1 ] , x_sort [ n // 2 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> start_set = set ( ) <NEWLINE> goal_set = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , g = map ( int , input ( ) . split ( ) ) <NEWLINE> if s == 1 : <NEWLINE> <INDENT> start_set . add ( g ) <NEWLINE> <DEDENT> if g == n : <NEWLINE> <INDENT> goal_set . add ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> if ( start_set & goal_set ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( b - a + 1 ) <= 2 * k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minP = P [ 0 ] <NEWLINE> ans = 1 <NEWLINE> for i in P [ 1 : ] : <NEWLINE> <INDENT> if ( i <= minP ) : <NEWLINE> <INDENT> minP = i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = k <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> p *= k - 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> L . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <COMMENT> <NEWLINE> <INDENT> ab = L [ i ] + L [ j ] <NEWLINE> idx = bisect . bisect_left ( L , ab , lo = j ) <NEWLINE> ans += max ( idx - ( j + 1 ) , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) - 1 for _ in range ( N ) ] <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = a [ x ] <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> if ans > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> blue = math . factorial ( K - 1 ) // ( math . factorial ( i - 1 ) * math . factorial ( K - i ) ) <NEWLINE> if N - K + 1 - i < 0 : <NEWLINE> <INDENT> red = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> red = math . factorial ( N - K + 1 ) // ( math . factorial ( i ) * math . factorial ( N - K + 1 - i ) ) <NEWLINE> <DEDENT> ans = blue * red <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abs_A = list ( map ( lambda x : abs ( x ) , A ) ) <NEWLINE> <NL> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for e in A : <NEWLINE> <INDENT> if e > 0 : <NEWLINE> <INDENT> pos . append ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( e ) <NEWLINE> <DEDENT> <DEDENT> if len ( neg ) % 2 == 0 : <NEWLINE> <INDENT> ans = sum ( abs_A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = sum ( abs_A ) <NEWLINE> ans -= 2 * min ( abs_A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> S = min ( A ) <NEWLINE> L = max ( A ) <NEWLINE> <NL> c = 0 <NEWLINE> B = [ ] <NEWLINE> <NL> if S == L : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> elif S >= 0 and L > 0 : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] >= A [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i + 1 ] += A [ i ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( i + 1 , i + 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif L <= 0 and S < 0 : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ - i - 2 ] <= A [ - i - 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ - i - 2 ] += A [ - i - 1 ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( N - i , N - i - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if L >= - S : <NEWLINE> <INDENT> l = A . index ( L ) <NEWLINE> if A [ 0 ] < 0 : <NEWLINE> <INDENT> A [ 0 ] += L <NEWLINE> c += 1 <NEWLINE> B . append ( ( l + 1 , 1 ) ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] >= A [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ i + 1 ] < 0 : <NEWLINE> <INDENT> A [ i + 1 ] += L <NEWLINE> c += 1 <NEWLINE> B . append ( ( l + 1 , i + 2 ) ) <NEWLINE> <DEDENT> A [ i + 1 ] += A [ i ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( i + 1 , i + 2 ) ) <NEWLINE> if i + 1 == l : <NEWLINE> <INDENT> L = A [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = A . index ( S ) <NEWLINE> if A [ - 1 ] > 0 : <NEWLINE> <INDENT> A [ - 1 ] += S <NEWLINE> c += 1 <NEWLINE> B . append ( ( s + 1 , N ) ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ - i - 2 ] <= A [ - i - 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ - i - 2 ] > 0 : <NEWLINE> <INDENT> A [ - i - 2 ] += S <NEWLINE> c += 1 <NEWLINE> B . append ( ( s + 1 , N - i - 1 ) ) <NEWLINE> <DEDENT> A [ - i - 2 ] += A [ - i - 1 ] <NEWLINE> c += 1 <NEWLINE> B . append ( ( N - i , N - i - 1 ) ) <NEWLINE> if - i - 2 == s : <NEWLINE> <INDENT> S = A [ s ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> print ( B [ i ] [ 0 ] , B [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> y = sorted ( x ) <NEWLINE> a , b = y [ n // 2 - 1 ] , y [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> if i > a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> ans += k - 1 - j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c_al = Counter ( al ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for k , v in c_al . items ( ) : <NEWLINE> <INDENT> if v != 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow ( 2 , n // 2 , 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> elif n % 2 != 0 : <NEWLINE> <INDENT> for k , v in c_al . items ( ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> if v != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif v != 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow ( 2 , n // 2 , 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> import math <NEWLINE> gcd = math . gcd ( a , b ) <NEWLINE> <NL> p = [ ] <NEWLINE> for i in range ( 2 , int ( math . sqrt ( gcd ) ) + 1 ) : <NEWLINE> <INDENT> while gcd % i == 0 : <NEWLINE> <INDENT> gcd /= i <NEWLINE> p . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> p . append ( int ( gcd ) ) <NEWLINE> p . append ( 1 ) <NEWLINE> print ( len ( list ( set ( p ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> N = I ( ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = make_divisors ( N ) <NEWLINE> lenc = len ( c ) <NEWLINE> if ( lenc % 2 ) == 0 : <NEWLINE> <INDENT> a = c [ lenc // 2 - 1 ] <NEWLINE> b = c [ lenc // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = c [ lenc // 2 ] <NEWLINE> b = a <NEWLINE> <NL> <DEDENT> print ( a + b - 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> <NL> S = sum ( A2 ) + A1 [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> C . append ( S ) <NEWLINE> S += A1 [ i ] - A2 [ i - 1 ] <NEWLINE> <NL> <DEDENT> if N != 1 : <NEWLINE> <INDENT> print ( max ( C ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A1 [ 0 ] + A2 [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> card = [ list ( map ( int , i . rstrip ( ) . split ( ) ) ) for i in sys . stdin . readlines ( ) ] <NEWLINE> card = sorted ( card , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> A = sorted ( A ) <NEWLINE> i = 0 <NEWLINE> for b , c in card : <NEWLINE> <INDENT> for _ in range ( b ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif A [ i ] >= c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = c <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if S - i > 2 * K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif S - i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif 0 <= S - i <= K : <NEWLINE> <INDENT> ans += S - i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 * K + i - S + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = i [ 0 ] <NEWLINE> M = i [ 1 ] <NEWLINE> <NL> l = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] ) <NEWLINE> <NL> limit1 = max ( l [ : , 0 ] ) <NEWLINE> limit2 = min ( l [ : , 1 ] ) <NEWLINE> <NL> print ( max ( limit2 - limit1 + 1 , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for l in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ count ] == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = a [ count ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> u -= 1 <NEWLINE> v -= 1 <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> INF = 1 << 30 <NEWLINE> t = [ INF ] * n <NEWLINE> a = [ INF ] * n <NEWLINE> <NL> t [ u ] = 0 <NEWLINE> a [ v ] = 0 <NEWLINE> <NL> <NL> def dfs ( v , p , d ) : <NEWLINE> <INDENT> for nv in g [ v ] : <NEWLINE> <INDENT> if nv == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ nv ] == INF : <NEWLINE> <INDENT> d [ nv ] = d [ v ] + 1 <NEWLINE> dfs ( nv , v , d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( u , - 1 , t ) <NEWLINE> dfs ( v , - 1 , a ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] < a [ i ] : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> WW = [ 0 ] * ( W + 1 ) <NEWLINE> WW [ 0 ] = 1 <NEWLINE> WW [ 1 ] = 1 <NEWLINE> for i in range ( 2 , W + 1 ) : <NEWLINE> <INDENT> WW [ i ] = WW [ i - 1 ] + WW [ i - 2 ] <NEWLINE> <DEDENT> DP = [ [ 0 ] * W for i in range ( H + 1 ) ] <NEWLINE> DP [ 0 ] [ 0 ] = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> DP [ i ] [ j ] = DP [ i - 1 ] [ j ] * WW [ W - 1 ] <NEWLINE> if W > 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] += DP [ i - 1 ] [ j + 1 ] * WW [ W - 2 ] <NEWLINE> <DEDENT> <DEDENT> elif j == W - 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] = DP [ i - 1 ] [ j ] * WW [ W - 1 ] <NEWLINE> if W > 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] += DP [ i - 1 ] [ j - 1 ] * WW [ W - 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> DP [ i ] [ j ] = DP [ i - 1 ] [ j ] * WW [ j ] * WW [ W - 1 - j ] + DP [ i - 1 ] [ j - 1 ] * WW [ j - 1 ] * WW [ W - 1 - j ] + DP [ i - 1 ] [ j + 1 ] * WW [ j ] * WW [ W - 2 - j ] <NEWLINE> <NL> <DEDENT> DP [ i ] [ j ] %= mod <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( DP [ - 1 ] [ K - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = set ( a ) <NEWLINE> a . sort ( ) <NEWLINE> if len ( a ) != len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_ls . sort ( ) <NEWLINE> if x_ls [ 0 ] >= 0 : <NEWLINE> <INDENT> print ( x_ls [ k - 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif x_ls [ - 1 ] <= 0 : <NEWLINE> <INDENT> x_ls . sort ( reverse = True ) <NEWLINE> print ( abs ( x_ls [ k - 1 ] ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = k - 1 <NEWLINE> ans = float ( <STRING> ) <NEWLINE> while r < n : <NEWLINE> <INDENT> cost_1 = 2 * abs ( x_ls [ l ] ) + abs ( x_ls [ r ] ) <NEWLINE> cost_2 = abs ( x_ls [ l ] ) + 2 * abs ( x_ls [ r ] ) <NEWLINE> cost = min ( cost_1 , cost_2 ) <NEWLINE> ans = min ( cost , ans ) <NEWLINE> r += 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a = bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> ans += a - 1 - j <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; f , b , c = 0 , sum ( a ) , float ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> f , b = f + a [ i ] , b - a [ i ] <NEWLINE> c = min ( c , abs ( f - b ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
words = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> S = readline ( ) . rstrip ( ) <NEWLINE> <NL> stack = [ 0 ] <NEWLINE> while stack : <NEWLINE> <INDENT> ind = stack . pop ( ) <NEWLINE> if ind == len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> for w in words : <NEWLINE> <INDENT> if S [ ind : ind + len ( w ) ] == w : <NEWLINE> <INDENT> stack . append ( ind + len ( w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( bisect . bisect_left ( A , b ) * ( N - bisect . bisect_right ( C , b ) ) for b in B ) ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> <NL> _sum = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <NL> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> _sum += 1 <NEWLINE> <NL> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> ans += _sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> dum = ( s - ( i + j ) ) <NEWLINE> if dum < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dum <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r , g , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( n // g + 1 ) : <NEWLINE> <INDENT> nb = ( n - ( i * r + j * g ) ) <NEWLINE> <NL> if ( nb >= 0 ) : <NEWLINE> <INDENT> if ( nb % b == 0 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> layers = [ 1 ] <NEWLINE> patties = [ 1 ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> layer_i = 2 * layers [ i - 1 ] + 3 <NEWLINE> patty_i = 2 * patties [ i - 1 ] + 1 <NEWLINE> layers . append ( layer_i ) <NEWLINE> patties . append ( patty_i ) <NEWLINE> <NL> <DEDENT> def f ( n , x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return 1 if n == 0 else 0 <NEWLINE> <NL> <DEDENT> elif 1 < x <= 1 + layers [ n - 1 ] : <NEWLINE> <INDENT> return f ( n - 1 , x - 1 ) <NEWLINE> <NL> <DEDENT> elif x == 2 + layers [ n - 1 ] : <NEWLINE> <INDENT> return patties [ n - 1 ] + 1 <NEWLINE> <NL> <DEDENT> elif 2 + layers [ n - 1 ] < x <= 2 + 2 * layers [ n - 1 ] : <NEWLINE> <INDENT> return patties [ n - 1 ] + 1 + f ( n - 1 , x - 2 - layers [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return 2 * patties [ n - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ( N , X ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> idx = bisect_left ( A , 0 ) <NEWLINE> if idx != 0 and idx != N : <NEWLINE> <INDENT> if idx % 2 == 1 : <NEWLINE> <INDENT> if abs ( A [ idx - 1 ] ) > abs ( A [ idx ] ) : <NEWLINE> <INDENT> A [ idx - 1 ] *= - 1 <NEWLINE> A [ idx ] *= - 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , idx - 1 , 2 ) : <NEWLINE> <INDENT> A [ i ] *= - 1 <NEWLINE> A [ i + 1 ] *= - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if idx == N : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> print ( - sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - sum ( A [ : - 1 ] ) + A [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> M = P [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if M >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> M = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x >= p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> list = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> list [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if list [ i ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A = abs ( abs ( x ) - abs ( y ) ) <NEWLINE> <NL> if x * y > 0 : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 2 <NEWLINE> <DEDENT> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 1 <NEWLINE> <DEDENT> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> B = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = 1 <NEWLINE> <NL> <DEDENT> print ( A + B ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> <NL> state = [ - 1 for i in range ( 100010 ) ] <NEWLINE> <NL> def step_state ( n , broken ) : <NEWLINE> <INDENT> if state [ n ] != - 1 : <NEWLINE> <INDENT> return state [ n ] <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> state [ 0 ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> if broken [ 1 ] : <NEWLINE> <INDENT> state [ 1 ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state [ 1 ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if broken [ n - 1 ] and broken [ n - 2 ] : <NEWLINE> <INDENT> state [ n ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> elif broken [ n - 1 ] : <NEWLINE> <INDENT> state [ n ] = step_state ( n - 2 , broken ) % MOD <NEWLINE> return state [ n ] <NEWLINE> <DEDENT> elif broken [ n - 2 ] : <NEWLINE> <INDENT> state [ n ] = step_state ( n - 1 , broken ) % MOD <NEWLINE> return state [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state [ n ] = ( step_state ( n - 1 , broken ) + step_state ( n - 2 , broken ) ) % MOD <NEWLINE> return state [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for i in range ( m ) ] ) <NEWLINE> broken = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> broken [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> answer = step_state ( n , broken ) <NEWLINE> <NL> print ( answer ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> j = int ( i ** 0.5 ) <NEWLINE> if int ( j ) ** 2 == i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arrR = [ 0 ] * N <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arrR [ a - 1 ] += 1 <NEWLINE> arrR [ b - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( arrR [ i ] ) for i in range ( N ) ] <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def extgcd ( a , b ) : <NEWLINE> <INDENT> r = [ 1 , 0 , a ] <NEWLINE> w = [ 0 , 1 , b ] <NEWLINE> while w [ 2 ] != 1 : <NEWLINE> <INDENT> q = r [ 2 ] // w [ 2 ] <NEWLINE> r2 = w <NEWLINE> w2 = [ r [ 0 ] - q * w [ 0 ] , r [ 1 ] - q * w [ 1 ] , r [ 2 ] - q * w [ 2 ] ] <NEWLINE> r = r2 <NEWLINE> w = w2 <NEWLINE> <COMMENT> <NL> <DEDENT> return [ w [ 0 ] , w [ 1 ] ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def mod_inv ( a , mod ) : <NEWLINE> <INDENT> x = extgcd ( a , mod ) [ 0 ] <NEWLINE> return ( mod + x % mod ) % mod <NEWLINE> <DEDENT> N = n - k + 1 <NEWLINE> combi = [ 0 for i in range ( n + 1 ) ] <NEWLINE> combi [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> combi [ i ] = ( combi [ i - 1 ] * ( N - i + 1 ) * mod_inv ( i , mod ) ) % mod <NEWLINE> <DEDENT> fact = [ 0 for i in range ( n + 1 ) ] <NEWLINE> fact [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = ( i * fact [ i - 1 ] ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( ( combi [ i ] * fact [ k - 1 ] * pow ( fact [ k - i ] , - 1 , mod ) * pow ( fact [ i - 1 ] , - 1 , mod ) ) % mod ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> cur = 1 <NEWLINE> ans = 0 <NEWLINE> pushed = [ False ] * ( N + 1 ) <NEWLINE> pushed [ 1 ] = True <NEWLINE> ok = True <NEWLINE> while True : <NEWLINE> <INDENT> pushed [ cur ] = True <NEWLINE> ans += 1 <NEWLINE> cur = A [ cur ] <NEWLINE> if cur == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if pushed [ cur ] : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> def rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ri ( ) : return int ( rs ( ) ) <NEWLINE> def rs_ ( ) : return [ _ for _ in rs ( ) . split ( ) ] <NEWLINE> def ri_ ( ) : return [ int ( _ ) for _ in rs ( ) . split ( ) ] <NEWLINE> <NL> o = rs ( ) <NEWLINE> e = rs ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( o ) ) : <NEWLINE> <INDENT> ans += o [ i ] <NEWLINE> if i < len ( e ) : <NEWLINE> <INDENT> ans += e [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower , upper = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower + upper [ : : - 1 ] <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , int ( input ( ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
l = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = input ( ) <NEWLINE> print ( l [ l . index ( s ) + 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ [ ] for x in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = [ A [ i ] , i + 1 ] <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> <NL> ANS = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ANS [ i ] = L [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( * ANS ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power = power % ( 10 ** 9 + 7 ) * n <NEWLINE> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
def run_length_compress ( S ) : <NEWLINE> <INDENT> res = [ [ S [ 0 ] , 1 ] ] <NEWLINE> for c in S [ 1 : ] : <NEWLINE> <INDENT> if c == res [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> res [ - 1 ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( [ c , 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> T = run_length_compress ( S ) <NEWLINE> if T [ 0 ] [ 1 ] == N : <NEWLINE> <INDENT> print ( N * K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = sum ( l // 2 for _ , l in T ) * K <NEWLINE> if T [ 0 ] [ 0 ] == T [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> head , tail = T [ 0 ] [ 1 ] , T [ - 1 ] [ 1 ] <NEWLINE> ans += ( ( head + tail ) // 2 - head // 2 - tail // 2 ) * ( K - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( N - 1 - i ) == i : <NEWLINE> <INDENT> if 0 not in c or c [ 0 ] != 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = abs ( ( N - 1 - i ) - i ) <NEWLINE> if p not in c or c [ p ] != 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = pow ( 2 , N // 2 , mod ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
D , G = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> score_table = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> p , c = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> score_table . append ( [ i * 100 , p , c ] ) <NEWLINE> <NL> <DEDENT> min_count = sum ( [ l [ 1 ] for l in score_table ] ) <NEWLINE> <COMMENT> <NL> <NL> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> score += score_table [ i ] [ 0 ] * score_table [ i ] [ 1 ] + score_table [ i ] [ 2 ] <NEWLINE> count += score_table [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> additional = [ ] <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if not bit & ( 1 << j ) : <NEWLINE> <INDENT> additional . append ( score_table [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> additional_ = sorted ( additional , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> for k in range ( additional_ [ 0 ] [ 1 ] - 1 ) : <NEWLINE> <INDENT> score += additional_ [ 0 ] [ 0 ] <NEWLINE> count += 1 <NEWLINE> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min_count ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> B = deque ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = str ( A [ i ] ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> B . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = str ( A [ i ] ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> B . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( B ) ) <NEWLINE>
def add_memo ( tate , yoko ) : <NEWLINE> <INDENT> global memo <NEWLINE> if 2 <= tate <= h - 1 : <NEWLINE> <INDENT> if 2 <= yoko <= w - 1 : <NEWLINE> <INDENT> memo . append ( [ tate , yoko ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> memo = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> add_memo ( x - 1 , y - 1 ) <NEWLINE> add_memo ( x - 1 , y ) <NEWLINE> add_memo ( x - 1 , y + 1 ) <NEWLINE> add_memo ( x , y - 1 ) <NEWLINE> add_memo ( x , y ) <NEWLINE> add_memo ( x , y + 1 ) <NEWLINE> add_memo ( x + 1 , y - 1 ) <NEWLINE> add_memo ( x + 1 , y ) <NEWLINE> add_memo ( x + 1 , y + 1 ) <NEWLINE> <NL> <DEDENT> memo . sort ( ) <NEWLINE> ans = [ 0 ] * 10 <NEWLINE> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) <NEWLINE> tmp_x = 0 <NEWLINE> tmp_y = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , len ( memo ) ) : <NEWLINE> <INDENT> if tmp_x == memo [ i ] [ 0 ] and tmp_y == memo [ i ] [ 1 ] : <NEWLINE> <INDENT> ans [ count ] -= 1 <NEWLINE> count += 1 <NEWLINE> ans [ count ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] -= 1 <NEWLINE> count = 1 <NEWLINE> ans [ count ] += 1 <NEWLINE> <DEDENT> tmp_x = memo [ i ] [ 0 ] <NEWLINE> tmp_y = memo [ i ] [ 1 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> @ jit <NEWLINE> def nya ( N , K , h ) : <NEWLINE> <INDENT> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> value = math . inf <NEWLINE> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i - j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> value = min ( value , dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) ) <NEWLINE> <DEDENT> dp [ i ] = value <NEWLINE> <DEDENT> return ( dp [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( nya ( N , K , h ) ) <NEWLINE>
L , R = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> diff = R - L <NEWLINE> if diff >= 2019 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( [ i * j % 2019 for j in range ( L + 1 , R + 1 ) for i in range ( L , R ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> one = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> one += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K <= one : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> import itertools <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import time <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def ev ( n ) : <NEWLINE> <INDENT> return 0.5 * ( n + 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_ev = list ( map ( ev , p ) ) <NEWLINE> <NL> s = np . cumsum ( p_ev ) <NEWLINE> s = np . insert ( s , 0 , 0 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans . append ( s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> head_prob_table = [ [ 0.0 ] * ( N + 1 ) for i in range ( N ) ] <NEWLINE> head_prob = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> head_prob_table [ 0 ] [ 1 ] = head_prob [ 0 ] <NEWLINE> head_prob_table [ 0 ] [ 0 ] = 1 - head_prob [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 2 ) : <NEWLINE> <INDENT> head_prob_table [ i ] [ j ] += head_prob_table [ i - 1 ] [ j ] * ( 1 - head_prob [ i ] ) <NEWLINE> if j > 0 : <NEWLINE> <INDENT> head_prob_table [ i ] [ j ] += head_prob_table [ i - 1 ] [ j - 1 ] * head_prob [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( head_prob_table [ N - 1 ] [ ( N + 1 ) // 2 : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if a > 0 and b > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> count = 0 <NEWLINE> ironbar = list ( accumulate ( A ) ) <NEWLINE> <NL> min_value = ironbar [ - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> bet = abs ( ironbar [ i ] - ( ironbar [ - 1 ] - ironbar [ i ] ) ) <NEWLINE> <NL> if min_value > bet : <NEWLINE> <INDENT> min_value = bet <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_value ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 1 ; w = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if w == 0 : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> w = 1 <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> w = - 1 <NEWLINE> <DEDENT> <DEDENT> elif ( w > 0 and A [ i ] > A [ i + 1 ] ) or ( w < 0 and A [ i ] < A [ i + 1 ] ) : <NEWLINE> <INDENT> w = 0 <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> time = 0 <NEWLINE> pos = 0 <NEWLINE> while pos < X : <NEWLINE> <INDENT> time += 1 <NEWLINE> pos += time <NEWLINE> <NL> <DEDENT> print ( time ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W = MAP ( ) <NEWLINE> a = [ LIST ( ) for _ in range ( H ) ] <NEWLINE> <NL> op = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 : <NEWLINE> <INDENT> a [ i ] [ j ] -= 1 <NEWLINE> a [ i ] [ j + 1 ] += 1 <NEWLINE> op . append ( ( i + 1 , j + 1 , i + 1 , j + 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ - 1 ] % 2 : <NEWLINE> <INDENT> a [ i ] [ - 1 ] -= 1 <NEWLINE> a [ i + 1 ] [ - 1 ] += 1 <NEWLINE> op . append ( ( i + 1 , W , i + 2 , W ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( op ) ) <NEWLINE> print ( * [ <STRING> . join ( map ( str , x ) ) for x in op ] , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> E = max ( C , D ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( A - 1 , E ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> if cnt >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if C < D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( B - 2 , D + 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> if cnt >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque <NEWLINE> import sys , heapq , bisect , math , itertools , string , queue , datetime <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpl_s ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S [ K - 1 ] ) <NEWLINE>
from math import gcd , ceil <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] // 2 <NEWLINE> <NL> <DEDENT> lcm_v = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> lcm_v = lcm ( lcm_v , a [ i ] ) <NEWLINE> <NL> <DEDENT> ok = True <NEWLINE> for aa in a : <NEWLINE> <INDENT> if ( lcm_v // aa ) % 2 != 1 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if ok : <NEWLINE> <INDENT> ans = ( ( m // lcm_v ) + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> X = sorted ( X ) <NEWLINE> dis = [ 0 for x in range ( M - 1 ) ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> dis [ i ] = X [ i + 1 ] - X [ i ] <NEWLINE> <DEDENT> dis . sort ( ) <NEWLINE> dis . reverse ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> dis [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( dis ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( ( N - 1 ) * N // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
from collections import * <NEWLINE> n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; C = Counter ( A ) . items ( ) ; f = 1 ; l = len ( C ) <NEWLINE> if l == 3 : <NEWLINE> <INDENT> x = 0 <NEWLINE> for c in C : x ^= c [ 0 ] <NEWLINE> f = ( len ( set ( c [ 1 ] for c in C ) ) > 1 ) + n % 3 + x > 0 <NEWLINE> <DEDENT> elif l == 2 : f = ( abs ( sum ( c [ 1 ] * ( - 1 ) ** i for i , c in enumerate ( C ) ) ) != n // 3 ) + n % 3 > 0 <NEWLINE> else : f = ( l != 1 ) + A [ 0 ] > 0 <NEWLINE> print ( <STRING> [ f : : 2 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> print ( ( N // K ) ** 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( N // K ) ** 3 <NEWLINE> k = K // 2 <NEWLINE> j = ( N + k ) // K <NEWLINE> print ( j ** 3 + ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nxt_btn = { i : int ( input ( ) ) for i in range ( 1 , n + 1 ) } <NEWLINE> <NL> num = - 1 <NEWLINE> crr_btn = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if nxt_btn [ crr_btn ] == 2 : <NEWLINE> <INDENT> num = i <NEWLINE> break <NEWLINE> <DEDENT> crr_btn = nxt_btn [ crr_btn ] <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC . append ( tmp ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while A [ j ] < BC [ i ] [ 1 ] : <NEWLINE> <INDENT> A [ j ] = BC [ i ] [ 1 ] <COMMENT> <NEWLINE> j += 1 <NEWLINE> count += 1 <NEWLINE> if count == BC [ i ] [ 0 ] or j == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if j == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p2 . append ( ( ( 1 + p1 [ i ] ) / 2 ) ) <NEWLINE> <DEDENT> ans = sum ( p2 [ 0 : k ] ) <NEWLINE> sum1 = sum ( p2 [ 0 : k ] ) <NEWLINE> for j in range ( n - k ) : <NEWLINE> <INDENT> sum1 = sum1 + p2 [ j + k ] - p2 [ j ] <NEWLINE> if ans < sum1 : <NEWLINE> <INDENT> ans = sum1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> a = collections . Counter ( A ) <NEWLINE> b = [ ] <NEWLINE> for i , j in a . items ( ) : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> b . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> b . sort ( reverse = True ) <NEWLINE> if len ( b ) >= 1 and b [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( b [ 0 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> elif len ( b ) >= 2 : <NEWLINE> <INDENT> print ( b [ 0 ] [ 0 ] * b [ 1 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> edges_r = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n + m - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges_r [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> s = 0 <NEWLINE> ks = [ ] <NEWLINE> for i , e in enumerate ( edges_r ) : <NEWLINE> <INDENT> if len ( e ) == 0 : <NEWLINE> <INDENT> s = i <NEWLINE> <DEDENT> ks . append ( len ( e ) ) <NEWLINE> <NL> <DEDENT> parents = [ - 1 ] * n <NEWLINE> INF = 1 << 60 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in edges [ u ] : <NEWLINE> <COMMENT> <NL> <INDENT> ks [ v ] -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ks [ v ] == 0 : <NEWLINE> <INDENT> parents [ v ] = u <NEWLINE> q . appendleft ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for p in parents : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> divs = [ ] <NEWLINE> while i ** 2 <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> divs . append ( ( i , N // i ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p in divs : <NEWLINE> <INDENT> r = p [ 0 ] <NEWLINE> m = p [ 1 ] - 1 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if N % m == r : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = collections . deque ( ) <NEWLINE> <NL> flag = True <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> b . append ( x ) <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( x ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * list ( b ) [ : : - 1 ] ) <NEWLINE> <DEDENT>
a = sorted ( [ int ( input ( ) ) for i in range ( 2 ) ] ) <NEWLINE> print ( <STRING> if a == [ 2 , 3 ] else <STRING> if a == [ 1 , 3 ] else <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] * - 1 <NEWLINE> <DEDENT> import heapq <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t = ( heapq . heappop ( a ) ) * - 1 <NEWLINE> heapq . heappush ( a , ( t // 2 ) * - 1 ) <NEWLINE> <DEDENT> print ( sum ( a ) * - 1 ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> if A + B - 1 <= N <= A * B : <NEWLINE> <INDENT> S = N - A <NEWLINE> cur = N <NEWLINE> ans = [ ] <NEWLINE> for i in range ( A + 1 ) : <NEWLINE> <INDENT> num = min ( B - 1 , S ) + 1 <NEWLINE> S -= num - 1 <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> ans . append ( cur - num + 1 + j ) <NEWLINE> <DEDENT> cur -= num <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] [ 1 : ] <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> from bisect import bisect <NEWLINE> <NL> <NL> def LIS ( L ) : <NEWLINE> <INDENT> INF , N = 10 ** 12 , len ( L ) <NEWLINE> seq = [ INF ] * N <NEWLINE> for i in L : <NEWLINE> <INDENT> seq [ bisect ( seq , i ) ] = i <NEWLINE> <DEDENT> return N - seq . count ( INF ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 2019 <NEWLINE> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> import itertools <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i , j in itertools . combinations ( list ( range ( L , R + 1 ) ) , 2 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % MOD ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LRD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> adj_list = [ [ ] for _ in range ( N ) ] <NEWLINE> for lrd in LRD : <NEWLINE> <INDENT> l , r , d = lrd <NEWLINE> adj_list [ l - 1 ] . append ( ( l - 1 , r - 1 , d ) ) <NEWLINE> adj_list [ r - 1 ] . append ( ( r - 1 , l - 1 , - d ) ) <NEWLINE> <NL> <DEDENT> X = [ None ] * N <NEWLINE> import collections <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = collections . deque ( adj_list [ i ] ) <NEWLINE> X [ i ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> src , nxt , d = q . pop ( ) <NEWLINE> if X [ nxt ] is not None : <NEWLINE> <INDENT> if X [ nxt ] != X [ src ] + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> X [ nxt ] = X [ src ] + d <NEWLINE> q . extend ( adj_list [ nxt ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> saidai = 1 <NEWLINE> <NL> def yakusuu ( x , y ) : <NEWLINE> <INDENT> return ( y , x % y ) <NEWLINE> <NL> <DEDENT> def cont ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> saidai = math . gcd ( a , b ) <NEWLINE> <NL> <NL> d = cont ( saidai ) <NEWLINE> if d [ 0 ] == [ 1 , 1 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( len ( d ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> memo = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> min_k = float ( <STRING> ) <NEWLINE> min_k = min ( [ memo [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ] ) <NEWLINE> memo [ i ] = min_k <NEWLINE> <NL> <DEDENT> print ( memo [ - 1 ] ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = len ( str ( int ( n / i ) ) ) <NEWLINE> b = len ( str ( int ( i ) ) ) <NEWLINE> l . append ( max ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> abc = <STRING> <NEWLINE> <NL> def dfs ( keta , ns ) : <NEWLINE> <INDENT> global cnt <NEWLINE> if ns in s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt == k : <NEWLINE> <INDENT> print ( ns ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if keta == k : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for i in abc : <NEWLINE> <INDENT> dfs ( keta + 1 , ns + i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in abc : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( 1 , i ) <NEWLINE> <DEDENT>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for j in range ( A ) : <NEWLINE> <INDENT> if B != [ ] : B . pop ( ) <NEWLINE> <DEDENT> print ( sum ( B ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= 0 : <NEWLINE> <INDENT> if N <= A : <NEWLINE> <INDENT> print ( A - N , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = N - A <NEWLINE> if N <= B : <NEWLINE> <INDENT> print ( 0 , B - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif A < K <= ( A + B ) : <NEWLINE> <INDENT> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> pow = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pow *= i + 1 <NEWLINE> pow = pow % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( pow ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 10 ** 9 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ i ] + abs ( h [ i + 1 ] - h [ i ] ) ) <NEWLINE> if i + 2 < n : <NEWLINE> <INDENT> dp [ i + 2 ] = min ( dp [ i + 2 ] , dp [ i ] + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( A ) >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> d = a . min ( ) <NEWLINE> while True : <NEWLINE> <INDENT> a1 = a % d <NEWLINE> if all ( a1 == 0 ) : <NEWLINE> <INDENT> ans = d <NEWLINE> break <NEWLINE> <DEDENT> d = min ( a1 [ a1 != 0 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> class UnionFind ( ) : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bridges = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> answer_list = [ ] <NEWLINE> total = N * ( N - 1 ) // 2 <NEWLINE> answer_list . append ( total ) <NEWLINE> <COMMENT> <NL> union_find = UnionFind ( N ) <NEWLINE> for i in range ( M - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> A , B = bridges [ i ] <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if not union_find . same ( A , B ) : <NEWLINE> <INDENT> total -= union_find . size ( A ) * union_find . size ( B ) <NEWLINE> union_find . union ( A , B ) <NEWLINE> <NL> <DEDENT> answer_list . append ( total ) <NEWLINE> <NL> <DEDENT> len_answer = len ( answer_list ) <NEWLINE> for i in range ( len_answer - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( answer_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> amax = max ( A ) <NEWLINE> AA = sorted ( A , key = lambda x : abs ( amax / 2 - x ) ) <NEWLINE> if AA [ 0 ] == amax : <NEWLINE> <INDENT> print ( amax , AA [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( amax , AA [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> n = N - i <NEWLINE> for j in range ( n * 2 - 1 , N , n ) : <NEWLINE> <INDENT> if b [ j ] == 1 : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> if a [ n - 1 ] != tmp % 2 : <NEWLINE> <INDENT> b [ n - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if b [ i ] == 1 : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> if ans != [ ] : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from sys import stdin , setrecursionlimit <NEWLINE> input = stdin . readline <NEWLINE> setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parent = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if self . parent [ x ] < self . parent [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> total_unite_island = self . parent [ x ] * self . parent [ y ] <NEWLINE> self . parent [ x ] += self . parent [ y ] <NEWLINE> self . parent [ y ] = x <NEWLINE> return total_unite_island <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M ; B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> uf = Unionfind ( N ) <NEWLINE> inconvenience = N * ( N - 1 ) // 2 <NEWLINE> inconvenience_list = [ 0 ] * M <NEWLINE> inconvenience_list [ M - 1 ] = inconvenience <NEWLINE> for i in range ( M - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> inconvenience -= uf . union ( A [ i ] , B [ i ] ) <NEWLINE> inconvenience_list [ i - 1 ] = inconvenience <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( inconvenience_list [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> cnt = [ 0 ] * 100001 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( cnt ) - 2 ) : <NEWLINE> <INDENT> ans = max ( ans , cnt [ i ] + cnt [ i + 1 ] + cnt [ i + 2 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * V , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import * <NEWLINE> C1 = Counter ( V [ : : 2 ] ) <NEWLINE> C1 = sorted ( C1 . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> C2 = Counter ( V [ 1 : : 2 ] ) <NEWLINE> C2 = sorted ( C2 . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> K1 = C1 [ - 1 ] [ 0 ] <NEWLINE> V1 = C1 [ - 1 ] [ 1 ] <NEWLINE> K2 = C2 [ - 1 ] [ 0 ] <NEWLINE> V2 = C2 [ - 1 ] [ 1 ] <NEWLINE> if V1 > V2 : <NEWLINE> <INDENT> if K1 == K2 : <NEWLINE> <INDENT> V2 = C2 [ - 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> elif V2 > V1 : <NEWLINE> <INDENT> if K1 == K2 : <NEWLINE> <INDENT> V1 = C1 [ - 2 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K1 == K2 : <NEWLINE> <INDENT> if len ( set ( V ) ) == 1 : <NEWLINE> <INDENT> V2 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> V2 = max ( C1 [ - 2 ] [ 1 ] , C2 [ - 2 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - V1 - V2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> print ( ( ( n - 1 ) * n ) // 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ - 1 for _ in range ( n ) ] <NEWLINE> V = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> V [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if dp [ x ] != - 1 : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for v in V [ x ] : <NEWLINE> <INDENT> t = max ( t , f ( v ) + 1 ) <NEWLINE> <NL> <DEDENT> dp [ x ] = t <NEWLINE> return dp [ x ] <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = max ( t , f ( i ) ) <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ab = sorted ( ab , key = lambda x : x [ 0 ] ) <NEWLINE> res = ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if res + ab [ i ] [ 1 ] >= m : <NEWLINE> <INDENT> ans += ( ab [ i ] [ 0 ] ) * ( m - res ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( ab [ i ] [ 0 ] ) * ab [ i ] [ 1 ] <NEWLINE> res += ab [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( n // k ) ** 3 + ( ~ k & 1 ) * ( n // - ( - k // 2 ) - n // k ) ** 3 ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> judge = 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> judge = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if judge != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> <NL> cnt = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for c in cnt : <NEWLINE> <INDENT> if k - ( q - c ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if x != 0 and y != 0 : <NEWLINE> <INDENT> if W / x == 2 and H / y == 2 : <NEWLINE> <INDENT> print ( W * H / 2 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , <STRING> ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = min ( a , b ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in reversed ( range ( 1 , n + 1 ) ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import copy <NEWLINE> <NL> <COMMENT> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ deque ( [ ] ) for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> q_sum_list = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> q_sum_list [ p - 1 ] += x <NEWLINE> <COMMENT> <NL> <DEDENT> arrive_rireki = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> score = [ 0 ] * n <NEWLINE> score_temp = 0 <NEWLINE> <NL> <COMMENT> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global score_temp <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> stack = [ v ] <NEWLINE> arrive_rireki [ v ] = 1 <NEWLINE> score_temp += q_sum_list [ v - 1 ] <NEWLINE> while stack : <NEWLINE> <COMMENT> <NL> <INDENT> v = stack [ - 1 ] <NEWLINE> if graph [ v ] : <NEWLINE> <INDENT> w = graph [ v ] . popleft ( ) <NEWLINE> if arrive_rireki [ w ] < 0 : <NEWLINE> <INDENT> arrive_rireki [ w ] = 1 <NEWLINE> stack . append ( w ) <NEWLINE> score_temp += q_sum_list [ w - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <COMMENT> <NL> score [ v - 1 ] = score_temp <NEWLINE> score_temp -= q_sum_list [ v - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> <COMMENT> <NL> print ( * score ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> <NL> kouho = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> ans = s [ : i ] <NEWLINE> tmp = s [ i : ( i + len ( t ) ) ] <NEWLINE> <NL> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if tmp [ j ] == t [ j ] : <NEWLINE> <INDENT> ans += t [ j ] <NEWLINE> <DEDENT> elif tmp [ j ] == <STRING> : <NEWLINE> <INDENT> ans += t [ j ] <NEWLINE> <DEDENT> elif tmp [ j ] != <STRING> and tmp [ j ] != t [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = ans + s [ ( i + len ( t ) ) : ] <NEWLINE> <NL> if len ( ans ) == len ( s ) : <NEWLINE> <INDENT> kouho . append ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( kouho ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> answers = [ ] <NEWLINE> for j in kouho : <NEWLINE> <NL> <INDENT> tmp_ans = <STRING> <NEWLINE> for k in range ( len ( j ) ) : <NEWLINE> <INDENT> if j [ k ] == <STRING> : <NEWLINE> <INDENT> tmp_ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_ans += j [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> answers . append ( tmp_ans ) <NEWLINE> <NL> <DEDENT> answers = sorted ( answers ) <NEWLINE> print ( answers [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n * m ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> if r * R + g * G > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( N - r * R - g * G ) % B != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mm = 0 <NEWLINE> mx = 10 ** 5 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> mm = max ( mm , l ) <NEWLINE> mx = min ( mx , r ) <NEWLINE> <DEDENT> print ( max ( mx - mm + 1 , 0 ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> BC . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> temp = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> temp += [ BC [ i ] [ 1 ] ] * BC [ i ] [ 0 ] <NEWLINE> if len ( temp ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += temp <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( A [ : N ] ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> r = range ( a , b + 1 ) <NEWLINE> print ( * sorted ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) , sep = <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <NL> <NL> def search ( H , W , S , start ) : <NEWLINE> <INDENT> wall_i = ord ( <STRING> ) <NEWLINE> used = [ [ - 1 for h in range ( W ) ] for w in range ( H ) ] <NEWLINE> <NL> qu = collections . deque ( ) <NEWLINE> qu . append ( start ) <NEWLINE> used [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> <NL> while qu : <NEWLINE> <INDENT> h , w = qu . popleft ( ) <NEWLINE> cost = used [ h ] [ w ] <NEWLINE> for h0 , w0 in ( ( h - 1 , w ) , ( h + 1 , w ) , ( h , w - 1 ) , ( h , w + 1 ) ) : <NEWLINE> <INDENT> if not ( 0 <= h0 < H and 0 <= w0 < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if used [ h0 ] [ w0 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ h0 ] [ w0 ] == wall_i : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> used [ h0 ] [ w0 ] = cost + 1 <NEWLINE> qu . append ( ( h0 , w0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return max ( cost for costs in used for cost in costs ) <NEWLINE> <NL> <NL> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> H , W = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> S = tuple ( s . strip ( ) for s in itertools . islice ( in_ , H ) ) <NEWLINE> <NL> road_i = ord ( <STRING> ) <NEWLINE> <NL> roads = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == road_i : <NEWLINE> <INDENT> roads . append ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = max ( search ( H , W , S , start ) for start in roads ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if d . get ( A [ n ] ) == None : <NEWLINE> <INDENT> d [ A [ n ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ n ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d = sorted ( d . items ( ) , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> if d [ i ] [ 1 ] >= 4 : <NEWLINE> <INDENT> ans = d [ i ] [ 0 ] ** 2 <NEWLINE> break <NEWLINE> <DEDENT> elif d [ i ] [ 1 ] >= 2 : <NEWLINE> <INDENT> temp = d [ i ] [ 0 ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ i ] [ 1 ] >= 2 : <NEWLINE> <INDENT> ans = temp * d [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if p [ i ] - 1 == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> <DEDENT> <DEDENT> if p [ n - 1 ] - 1 == n - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> def div ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> count += 1 if n % i == 0 else 0 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , int ( input ( ) ) + 1 ) : <NEWLINE> <INDENT> ans += 1 if i % 2 == 1 and div ( i ) == 8 else 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> int1 = lambda x : int ( x ) - 1 <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int1 , input ( ) . split ( ) ) <NEWLINE> T [ a ] . append ( b ) <NEWLINE> T [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> lst = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> d = deque ( [ 0 ] ) <NEWLINE> visited = set ( ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . pop ( ) <NEWLINE> visited . add ( v ) <NEWLINE> for x in T [ v ] : <NEWLINE> <INDENT> if x not in visited : <NEWLINE> <INDENT> lst [ x ] += lst [ v ] <NEWLINE> d . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * lst ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . rfind ( <STRING> ) - S . find ( <STRING> ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ [ - 1 for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> li [ i ] [ x - 1 ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> t = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> t [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> is_contradict = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if t [ j ] : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if li [ j ] [ k ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if li [ j ] [ k ] != t [ k ] : <NEWLINE> <INDENT> is_contradict = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if not is_contradict : <NEWLINE> <INDENT> ans = max ( ans , sum ( t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> pair = [ ] <NEWLINE> unpair = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in unpair : <NEWLINE> <INDENT> pair . append ( a ) <NEWLINE> unpair . remove ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unpair . add ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> pair . sort ( ) <NEWLINE> pair . reverse ( ) <NEWLINE> if len ( pair ) <= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = pair [ 0 ] * pair [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r , l = [ 0 ] * ( n ) , [ 0 ] * ( n ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> r [ n - 1 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l [ i ] = math . gcd ( l [ i - 1 ] , a [ i - 1 ] ) <NEWLINE> r [ n - i - 1 ] = math . gcd ( r [ n - i ] , a [ n - i ] ) <NEWLINE> <DEDENT> m = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] = math . gcd ( l [ i ] , r [ i ] ) <NEWLINE> <DEDENT> print ( max ( m ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b - a + 1 ) <= 2 * k : <NEWLINE> <INDENT> count = a <NEWLINE> while count <= b : <NEWLINE> <INDENT> print ( count ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( b - ( ( k - 1 ) - i ) ) <NEWLINE> <DEDENT> <DEDENT>
from heapq import * <NEWLINE> ( N , M ) , * t = [ map ( int , s . split ( ) ) for s in open ( 0 ) ] <NEWLINE> v = [ [ ] for _ in [ None ] * 10 ** 5 ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> v [ a - 1 ] += b , <NEWLINE> <DEDENT> z = 0 <NEWLINE> q = [ ] <NEWLINE> for i in v [ : M ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heappush ( q , - j ) <NEWLINE> <DEDENT> if q : <NEWLINE> <INDENT> z += - heappop ( q ) <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> text = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> text = [ t [ : : - 1 ] for t in text ] <NEWLINE> <NL> while len ( S ) > 0 : <NEWLINE> <INDENT> for t in text : <NEWLINE> <INDENT> if S . find ( t ) == 0 : <NEWLINE> <INDENT> S = S [ len ( t ) : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , K = il ( ) <NEWLINE> X = il ( ) <NEWLINE> <NL> ret = MAX <NEWLINE> for n in range ( N - K + 1 ) : <NEWLINE> <INDENT> ret = min ( ret , abs ( X [ n ] ) + abs ( X [ n ] - X [ n + K - 1 ] ) , abs ( X [ n + K - 1 ] ) + abs ( X [ n ] - X [ n + K - 1 ] ) ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in itertools . product ( range ( K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> Z = S - sum ( i ) <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <NL> print ( math . factorial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> aL = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> heapq . heapify ( aL ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a = heapq . heappop ( aL ) <NEWLINE> a = int ( a / 2 ) <NEWLINE> heapq . heappush ( aL , a ) <NEWLINE> <NL> <DEDENT> print ( int ( sum ( aL ) * - 1 ) ) <NEWLINE>
import math <NEWLINE> <NL> N = 5 <NEWLINE> ARR = [ 2 , 4 , 4 , 0 , 2 ] <NEWLINE> <NL> N = 7 <NEWLINE> ARR = [ 6 , 4 , 0 , 2 , 4 , 0 , 2 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> n = n // 2 <NEWLINE> start = 1 <NEWLINE> finalResult = pow ( 2 , n , 1000000000 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n // 2 + 1 <NEWLINE> start = 0 <NEWLINE> finalResult = pow ( 2 , ( n - 1 ) , 1000000000 + 7 ) <NEWLINE> <NL> <DEDENT> result = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> index = start + 2 * i <NEWLINE> if index == 0 : <NEWLINE> <INDENT> result . __setitem__ ( 0 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . __setitem__ ( index , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> isOk = True <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if result . get ( arr [ i ] ) == None : <NEWLINE> <INDENT> isOk = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if result . get ( arr [ i ] ) == 0 : <NEWLINE> <INDENT> isOk = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> result . __setitem__ ( arr [ i ] , result . get ( arr [ i ] ) - 1 ) <NEWLINE> <NL> <DEDENT> if isOk == False : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if sum ( result . values ( ) ) == 0 : <NEWLINE> <INDENT> print ( finalResult ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> calculate ( N , ARR ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> H . sort ( reverse = True ) <NEWLINE> <NL> if K >= N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( H [ K : ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for key in range ( 1000 ) : <NEWLINE> <INDENT> key = <STRING> . format ( str ( key ) ) <COMMENT> <NEWLINE> i0 = s . find ( key [ 0 ] ) <NEWLINE> if 0 <= i0 < N - 2 : <NEWLINE> <INDENT> i1 = s . find ( key [ 1 ] , i0 + 1 ) <NEWLINE> if 0 < i1 < N - 1 : <NEWLINE> <INDENT> i2 = s . find ( key [ 2 ] , i1 + 1 ) <NEWLINE> if i2 != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> paths = { i : [ ] for i in range ( N + 1 ) } <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ x ] . append ( y ) <NEWLINE> paths [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> dpt = [ [ - 1 ] * 2 for i in range ( N + 1 ) ] <NEWLINE> <NL> def count_cc ( prev , node , color ) : <NEWLINE> <INDENT> if dpt [ node ] [ color ] != - 1 : <NEWLINE> <INDENT> return dpt [ node ] [ color ] <NEWLINE> <DEDENT> if paths [ node ] == [ prev ] : <NEWLINE> <INDENT> dpt [ node ] [ color ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> result = 1 <NEWLINE> if color == 0 : <NEWLINE> <INDENT> for nxt in paths [ node ] : <NEWLINE> <INDENT> if nxt == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> result *= ( count_cc ( node , nxt , 0 ) + count_cc ( node , nxt , 1 ) ) <NEWLINE> result %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for nxt in paths [ node ] : <NEWLINE> <INDENT> if nxt == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> result *= count_cc ( node , nxt , 0 ) <NEWLINE> result %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> dpt [ node ] [ color ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> print ( ( count_cc ( 0 , 1 , 0 ) + count_cc ( 0 , 1 , 1 ) ) % MOD ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * a <NEWLINE> <STRING> <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c [ b [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> result = <STRING> . join ( map ( str , c ) ) <NEWLINE> print ( result ) <NEWLINE>
