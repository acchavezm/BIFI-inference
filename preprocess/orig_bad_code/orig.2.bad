N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> DP = [ False ] * ( 2 * K + 1 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for item in List : <NEWLINE> <INDENT> if DP [ i ] == False : <NEWLINE> <INDENT> DP [ i + item ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if DP [ k ] == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> import numpy as np <NEWLINE> from functools import partial <NEWLINE> array = partial ( np . array , dtype = np . int64 ) <NEWLINE> zeros = partial ( np . zeros , dtype = np . int64 ) <NEWLINE> full = partial ( np . full , dtype = np . int64 ) <NEWLINE> <NL> <NL> def a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> <NL> def ints ( ) : return np . fromstring ( readline ( ) , sep = <STRING> , dtype = np . int64 ) <NEWLINE> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 2 ** 31 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> N = a_int ( ) <NEWLINE> A = ints ( ) <NEWLINE> <NL> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , A , dp ) : <NEWLINE> <INDENT> dp = np . zeros ( ( N + 1 , N + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i , j ] = max ( A [ i ] - dp [ i + 1 , j ] , A [ j - 1 ] - dp [ i , j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 , N ] ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> solve ( N , A ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> scores = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = <STRING> ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def get_max_score ( scores , i , j ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> return scores [ i ] <NEWLINE> <DEDENT> return max ( scores [ i ] - get_max_score ( scores , i + 1 , j ) , scores [ j ] - get_max_score ( scores , i , j - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( get_max_score ( scores , 0 , len ( scores ) - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] , dtype = np . int64 ) <NEWLINE> <NL> dp = np . full ( ( N + 1 , K + 1 ) , 0 , dtype = np . int64 ) <NEWLINE> c = np . full ( K + 2 , 0 , dtype = np . int64 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( N , K , MOD , dp , c ) : <NEWLINE> <NL> <INDENT> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c [ 0 ] = 0 <NEWLINE> for j in range ( 1 , K + 2 ) : <NEWLINE> <INDENT> c [ j ] = ( c [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) % MOD <NEWLINE> <DEDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = ( c [ j + 1 ] - c [ max ( 0 , j - a [ i - 1 ] ) ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ N ] [ K ] <NEWLINE> <NL> <DEDENT> print ( main ( N , K , dp , c ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max_candies = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> dpt = np . full ( ( N + 1 , K + 1 ) , 0 , dtype = <STRING> ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> dpt [ 0 ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def dp ( N , K , max_candies , dpt ) : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> dpt [ i ] [ j ] += dpt [ i - 1 ] [ j ] <NEWLINE> t = j - max_candies [ i - 1 ] - 1 <NEWLINE> if t >= 0 : <NEWLINE> <INDENT> dpt [ i ] [ j ] -= dpt [ i - 1 ] [ t ] <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> dpt [ i ] [ j ] += dpt [ i ] [ j - 1 ] <NEWLINE> <DEDENT> dpt [ i ] [ j ] = dpt [ i ] [ j ] % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> return ( dpt [ N ] [ K ] - dpt [ N ] [ K - 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> if K > 0 : <NEWLINE> <INDENT> print ( dp ( N , K , max_candies , dpt ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] , dtype = np . int64 ) <NEWLINE> <NL> s = [ 0 ] <NEWLINE> <NL> dp = np . array ( [ [ - 1 for i in range ( N ) ] for _ in range ( N ) ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> s . append ( s [ i - 1 ] + a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> s = np . array ( s , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def calc ( i , j , dp , s ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ j ] <NEWLINE> <DEDENT> m = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m = min ( m , calc ( i , k , dp , s ) + calc ( k + 1 , j , dp , s ) + s [ j + 1 ] - s [ i ] ) <NEWLINE> <DEDENT> dp [ i ] [ j ] = m <NEWLINE> return dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> print ( calc ( 0 , N - 1 , dp , s ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> slimes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> csum_slimes = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> csum_slimes . append ( csum_slimes [ - 1 ] + slimes [ i ] ) <NEWLINE> <NL> <DEDENT> dpt = np . full ( ( N , N ) , - 1 , dtype = <STRING> ) <NEWLINE> <NL> def get_min_cost ( l , r ) : <NEWLINE> <INDENT> if dpt [ l ] [ r ] != - 1 : <NEWLINE> <INDENT> return dpt [ l ] [ r ] <NEWLINE> <DEDENT> if l == r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> min_cost = 10 ** 18 <NEWLINE> for m in range ( l , r ) : <NEWLINE> <INDENT> min_cost = min ( min_cost , get_min_cost ( l , m ) + get_min_cost ( m + 1 , r ) + csum_slimes [ r + 1 ] - csum_slimes [ l ] ) <NEWLINE> <DEDENT> dpt [ l ] [ r ] = min_cost <NEWLINE> return min_cost <NEWLINE> <NL> <NL> <DEDENT> print ( get_min_cost ( 0 , N - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , aff , dpt , MOD ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> row = aff [ i ] <NEWLINE> for idx in range ( N ) : <NEWLINE> <INDENT> if row [ idx ] == 1 : <NEWLINE> <INDENT> dpt [ i + 1 ] [ ( 1 << idx ) : ] += dpt [ i ] [ : - ( 1 << idx ) ] <NEWLINE> <DEDENT> <DEDENT> dpt [ i + 1 ] %= MOD <NEWLINE> <DEDENT> return dpt [ N ] [ ( 1 << N ) - 1 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> aff = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] , dtype = <STRING> ) <NEWLINE> dpt = np . zeros ( ( N + 1 , 1 << N ) , dtype = <STRING> ) <NEWLINE> dpt [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> print ( solve ( N , aff , dpt , MOD ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> import numpy as np <NEWLINE> from functools import partial <NEWLINE> array = partial ( np . array , dtype = np . int64 ) <NEWLINE> zeros = partial ( np . zeros , dtype = np . int64 ) <NEWLINE> full = partial ( np . full , dtype = np . int64 ) <NEWLINE> <NL> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def exit ( * argv , ** kwarg ) : <NEWLINE> <INDENT> print ( * argv , ** kwarg ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def mina ( * argv , sub = 1 ) : return list ( map ( lambda x : x - sub , argv ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> <NL> def read_matrix ( H , W ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lines = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> lines . append ( read ( ) ) <NEWLINE> <DEDENT> lines = <STRING> . join ( lines ) <COMMENT> <NEWLINE> return np . fromstring ( lines , sep = <STRING> , dtype = np . int64 ) . reshape ( H , W ) <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> INF = 2 ** 31 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> from collections import defaultdict , Counter , deque <NEWLINE> from operator import itemgetter , xor , add <NEWLINE> from itertools import product , permutations , combinations <NEWLINE> from bisect import bisect_left , bisect_right <COMMENT> <NEWLINE> from functools import reduce <NEWLINE> <NL> N = a_int ( ) <NEWLINE> A = read_matrix ( N , N ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve_TLE ( N , A ) : <NEWLINE> <INDENT> dp = np . zeros ( ( N + 1 , 1 << N ) , dtype = np . int64 ) <NEWLINE> dp [ 0 , 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for s in range ( 1 << N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if ( s >> j ) & 1 == 0 and A [ i , j ] == 1 : <NEWLINE> <INDENT> dp [ i + 1 , s + ( 1 << j ) ] += dp [ i , s ] % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N , ( 1 << N ) - 1 ] % MOD ) <NEWLINE> <NL> <NL> <DEDENT> solve_TLE ( N , A ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> aff = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] , dtype = <STRING> ) <NEWLINE> dpt = np . zeros ( ( N + 1 , 1 << N ) , dtype = <STRING> ) <NEWLINE> dpt [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> print ( solve ( N , aff , dpt ) ) <NEWLINE> <NL> <DEDENT> @ njit ( cache = True ) <NEWLINE> def solve ( N , aff , dpt ) : <NEWLINE> <INDENT> for i , row in enumerate ( aff ) : <NEWLINE> <INDENT> for idx , v in enumerate ( row ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> dpt [ i + 1 ] [ ( 1 << idx ) : ] += dpt [ i ] [ : - ( 1 << idx ) ] <NEWLINE> <DEDENT> <DEDENT> dpt [ i + 1 ] %= MOD <NEWLINE> <DEDENT> return dpt [ N ] [ ( 1 << N ) - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class BITmax : <NEWLINE> <INDENT> def __init__ ( self , N , init = 0 ) : <NEWLINE> <INDENT> self . init = init <NEWLINE> self . tree = [ self . init ] * ( N + 1 ) <NEWLINE> <NL> <DEDENT> def set ( self , x , value ) : <NEWLINE> <INDENT> while x < N + 1 : <NEWLINE> <INDENT> old = self . tree [ x ] <NEWLINE> if value <= old : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . tree [ x ] = value <NEWLINE> x += x & - x <NEWLINE> <NL> <DEDENT> <DEDENT> def find_max_to ( self , x ) : <NEWLINE> <INDENT> result = self . init <NEWLINE> while x > 0 : <NEWLINE> <INDENT> result = max ( result , self . tree [ x ] ) <NEWLINE> x -= x & - x <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> dpt = BITmax ( N ) <NEWLINE> <NL> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for h , b in zip ( h_list , b_list ) : <NEWLINE> <INDENT> dpt . set ( h , dpt . find_max_to ( h - 1 ) + b ) <NEWLINE> <NL> <DEDENT> print ( max ( dpt . tree ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] , dtype = int ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> res = matrix_power ( A , N , mod ) <NEWLINE> print ( res . sum ( ) % mod ) <NEWLINE> <NL> power_list = [ A ] <NEWLINE> for i in range ( 1 , K . bit_length ( ) + 1 ) : <NEWLINE> <INDENT> power_list . append ( ( power_list [ - 1 ] @ power_list [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> B = np . identity ( N ) . astype ( int ) <NEWLINE> for i in range ( K . bit_length ( ) + 1 ) : <NEWLINE> <INDENT> if K >> i & 1 : <NEWLINE> <INDENT> B = ( B @ power_list [ i ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( B . sum ( ) % mod ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> a = np . array ( a , dtype = np . int64 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def matmul ( A , B , MOD ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> C = np . zeros ( ( N , N ) , dtype = np . int64 ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> C [ n ] = ( A [ n , : ] [ : , None ] * B % mod ) . sum ( axis = 0 ) % mod <NEWLINE> <DEDENT> return C <NEWLINE> <NL> <DEDENT> def mat_power ( A , k , MOD ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> D = np . identity ( N , dtype = np . int64 ) <NEWLINE> while k : <NEWLINE> <INDENT> if k & 1 : <NEWLINE> <INDENT> D = matmul ( D , A , MOD ) <NEWLINE> <DEDENT> A = matmul ( A , A , MOD ) <NEWLINE> k >>= 1 <NEWLINE> <NL> <DEDENT> return D <NEWLINE> <NL> <DEDENT> A = mat_power ( a , K , MOD ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] [ j ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> cnt = N . count ( <STRING> ) <NEWLINE> print ( cnt ) <NEWLINE>
print ( input ( ) . count ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N . count ( <STRING> ) ) <NEWLINE>
print ( input ( ) . count ( ) ) <NEWLINE>
N , H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= H and b = W : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = factorization ( N ) <NEWLINE> ans = 1 <NEWLINE> for i in L : <NEWLINE> <INDENT> ans *= L [ 0 ] ** ( L [ 1 ] // N ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p == 1 or n >= 60 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( int ( p ** ( 1 / n ) ) + 1 ) [ 0 : : - 1 ] : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n >= len ( L ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> div = 2 <NEWLINE> L = [ ] <NEWLINE> i = 1 <NEWLINE> while div <= int ( m ** 0.5 ) + 1 : <NEWLINE> <INDENT> while m % div == 0 : <NEWLINE> <INDENT> m //= div <NEWLINE> L . append ( div ) <NEWLINE> <DEDENT> div += 1 <NEWLINE> <DEDENT> L . append ( m ) <NEWLINE> <COMMENT> <NL> <NL> from collections import Counter <NEWLINE> L = Counter ( L ) <NEWLINE> <NL> cnt = 1 <NEWLINE> for k , v in L . items ( ) : <NEWLINE> <INDENT> if v >= n : <NEWLINE> <INDENT> cnt *= k <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import sqrt <NEWLINE> def divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> q , r = divmod ( n , i ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != q : <NEWLINE> <INDENT> divisors . append ( q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 1 <NEWLINE> for k , v in factorint ( p ) . items ( ) : <NEWLINE> <INDENT> x *= k ** ( v // n ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> num = int ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( num + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> p0 = p <NEWLINE> count = 0 <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if p0 % i == 0 : <NEWLINE> <INDENT> p0 //= i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 1 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> <NL> def facto ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ cnt , i ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ 1 , temp ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ 1 , n ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n , p = I ( ) <NEWLINE> <NL> for i in facto ( p ) : <NEWLINE> <INDENT> if i [ 0 ] >= n : <NEWLINE> <INDENT> ans *= i [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def prime_factorize ( P ) : <NEWLINE> <INDENT> prime = list ( ) <NEWLINE> for i in range ( 2 , P + 1 ) : <NEWLINE> <INDENT> if i ** 2 <= P : <NEWLINE> <INDENT> if P % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while P % i == 0 : <NEWLINE> <INDENT> P //= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> prime . append ( [ i , c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if P != 1 : <NEWLINE> <INDENT> prime . append ( [ P , 1 ] ) <NEWLINE> <NL> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> prime = prime_factorize ( P ) <NEWLINE> <NL> print ( prime ) <NEWLINE> ans = 1 <NEWLINE> for p in prime : <NEWLINE> <INDENT> n , c = p <NEWLINE> ans *= ( n ** ( c // N ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT> def prime_factorize ( P ) : <NEWLINE> <INDENT> prime = list ( ) <NEWLINE> for i in range ( 2 , P + 1 ) : <NEWLINE> <INDENT> if i ** 2 <= P : <NEWLINE> <INDENT> if P % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while P % i == 0 : <NEWLINE> <INDENT> P //= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> prime . append ( [ i , c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if P != 1 : <NEWLINE> <INDENT> prime . append ( [ P , 1 ] ) <NEWLINE> <NL> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> prime = prime_factorize ( P ) <NEWLINE> ans = 1 <NEWLINE> for p in prime : <NEWLINE> <INDENT> n , c = p <NEWLINE> ans *= ( n ** ( c // N ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> import sys <NEWLINE> from collections import * <NEWLINE> from functools import lru_cache <NEWLINE> from itertools import accumulate , combinations , permutations , product <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> def ruiseki ( lst ) : <NEWLINE> <INDENT> return [ 0 ] + list ( accumulate ( lst ) ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 500000 ) <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> al = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> direction = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> f = <STRING> <NEWLINE> s = <STRING> <NEWLINE> <COMMENT> <NL> if sum ( a ) == n sum ( a ) == n + 1 : <NEWLINE> <INDENT> print ( f ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> if sum ( a ) % 2 : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( [ ( int ( input ( ) ) ) % 2 for i in range ( n ) ] ) <NEWLINE> su = sum ( a ) <NEWLINE> xors = 0 <NEWLINE> for i in ( a ) : <NEWLINE> <INDENT> xors ^= i <NEWLINE> <DEDENT> if ( xors != 0 | | sum == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) % 2 ) ) <NEWLINE> <DEDENT> k = sum ( a ) <NEWLINE> <NL> if ( k % 2 ) or n == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if all ( a [ i ] % 2 == 0 for i in range ( N ) ) else <STRING> ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( sys . stdin . readline ( ) ) for _ in range ( n ) ] <NEWLINE> print ( <STRING> if all ( a [ i ] % 2 == 0 for i in range ( n ) ) else <STRING> ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( intput ( ) ) <NEWLINE> flag &= ( a % 2 == 1 ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> a = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += c <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
othello = input ( ) <NEWLINE> bef = 0 <NEWLINE> sumall = 0 <NEWLINE> sumelse = 0 <NEWLINE> <NL> for i in range ( len ( othello ) ) : <NEWLINE> <INDENT> sumall += i <NEWLINE> if ( othello [ i ] == <STRING> ) : <NEWLINE> <INDENT> bef += i <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( othello ) - count ) : <NEWLINE> <INDENT> sumelse += i <NEWLINE> <NL> <DEDENT> aft = sumall - sumelse <NEWLINE> <NL> print ( aft - bef ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> sum = [ 0 ] * ( n + 1 ) <NEWLINE> sum [ 0 ] = ( s [ 0 ] == <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum [ i ] = sum [ i - 1 ] + ( s [ i ] == <STRING> ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += sum [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> ans2 = 0 <NEWLINE> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> t = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> same = True <NEWLINE> while same : <NEWLINE> <INDENT> if s [ i ] != s [ t ] : <NEWLINE> <INDENT> i = t <NEWLINE> print ( <STRING> ) <NEWLINE> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans , ans2 ) ) <NEWLINE>
from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> val = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> val . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 10 ** 10 <NEWLINE> for i in permutations ( val ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> ans = min ( max ( sum ( i [ : j ] ) , sum ( i [ j : ] ) ) , ans ) <NEWLINE> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( val [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for j in range ( len ( s ) ** 0.5 ) : <NEWLINE> <INDENT> for i in range ( j , len ( s ) - 1 , 2 ) : <NEWLINE> <INDENT> if l [ i ] == 1 and l [ i + 1 ] == 0 : <NEWLINE> <INDENT> l [ i ] = 0 <NEWLINE> l [ i + 1 ] = 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> W = [ ] <NEWLINE> <NL> for i , s enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> W . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> idx = 0 <NEWLINE> ans = 0 <NEWLINE> for w in W : <NEWLINE> <INDENT> ans += w - idx <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> cunt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cunt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> cw = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - cw <NEWLINE> cw += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
max = 0 <NEWLINE> k = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> if p > max : max = p <NEWLINE> k = k + p <NEWLINE> print ( ( k - max ) + ( max // 2 ) ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> if d = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = input ( ) <NEWLINE> D = int ( d ) <NEWLINE> <NL> if D == 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if D == 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if D == 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if D == 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a == 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> if D = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) . split ( ) ) <NEWLINE> if D == 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D == 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D == 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
print ( <STRING> + <STRING> + ( 25 - int ( input ( ) ) ) ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> if D = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
christmas_day = 25 <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( <STRING> , <STRING> * christmas_day - d ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> if d = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> total_price = max ( N ) / 2 + sum ( N ) - max ( N ) <NEWLINE> <NL> print ( math . floor ( total_price ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> values = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> values . append ( int ( lines [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> result = sum ( values ) - int ( max ( values ) / 2 ) <NEWLINE> <NL> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> N , M = list ( map ( int , line . split ( ) ) ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 15950 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 15120 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( int ( sum ( p ) - ( max ( p ) / 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> print ( p [ - 1 ] // 2 + sum ( p [ : - 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( int ( ( sum ( k ) - max ( k ) // 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> b = int ( b ) <NEWLINE> b . sort ( ) <NEWLINE> c = sum ( b ) <NEWLINE> print ( int ( c - b [ a ] / 2 ) ) <NEWLINE>
total_item = int ( input ( ) ) <NEWLINE> item_cost = [ ] <NEWLINE> for i in range ( total_item ) : <NEWLINE> <INDENT> item_cost . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( sum ( item_cost ) - max ( item_cost ) // 2 ) v <NEWLINE>
max = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> if p > max : <NEWLINE> <INDENT> max = p // 2 <NEWLINE> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
P = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> print ( sum ( p ) - max ( p ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = sorted ( [ int ( input ( ) ) for X in range ( 0 , N ) ] ) <NEWLINE> P [ - 1 ] = P [ - 1 ] // 2 <NEWLINE> print ( sum ( SP ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> z = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> if a [ i ] > z : <NEWLINE> <INDENT> z = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) - a [ z ] / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> a . append ( p ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> s = p [ n - 1 ] // 2 <NEWLINE> print ( sum ( a ) - s ) <NEWLINE>
, k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 1000000009 <NEWLINE> a = sorted ( a ) <NEWLINE> for y in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( a [ y + k - 1 ] - a [ y ] , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> print ( min ( ans [ j + k - 1 ] - ans [ j ] for j in range ( n - k + 1 ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = Input ( ) <NEWLINE> data = sorted ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> print ( min ( [ data [ i + k - 1 ] - data [ i ] for i in range ( n - k + 1 ) ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = h [ 0 ] <NEWLINE> <NL> print ( min ( h [ i + k - 1 ] - h [ i ] for i in range ( n - k + 1 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( ) <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a = h [ i + k - 1 ] - h [ i ] <NEWLINE> ans = a if i == 0 else min ( ans , a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> b = [ ] <NEWLINE> for p in range ( n - k ) : <NEWLINE> <INDENT> c = a [ p + k ] - a [ p ] <NEWLINE> b . append ( c ) <NEWLINE> <NL> <DEDENT> print ( min ( b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> trees = [ ] <NEWLINE> for _i in range ( n ) : <NEWLINE> <INDENT> trees . append ( int ( input ( ) ) <NEWLINE> <NL> <DEDENT> trees . sort ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> diff = trees [ i + k - 1 ] - trees [ i ] <NEWLINE> if ans > diff : <NEWLINE> <INDENT> ans = diff <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> print ( min ( ans [ i + k - 1 ] - ans [ i ] for j in range ( n - k + 1 ) ) ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> a = False <NEWLINE> if x = 7 or x = 5 or x = 3 : <NEWLINE> <INDENT> a = True <NEWLINE> <NL> <DEDENT> print ( <STRING> if a else <STRING> ) <NEWLINE>
a = imput ( ) <NEWLINE> a = int ( a ) <NEWLINE> <NL> if a == 7 or a == 5 or a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> li = [ 3 , 5 , 7 ] <NEWLINE> if x in li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
print ( <STRING> if input ( ) == <STRING> or input ( ) == <STRING> or input ( ) == <STRING> else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 3 | | N == 5 | | N == 7 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( str ( input ( ) ) ) <NEWLINE>
print ( <STRING> [ ~ input ( ) in <STRING> % 2 : : 2 ] <NEWLINE>
y = int ( input ( ) ) <NEWLINE> if y == 7 or y == 5 0 r y == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> if a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X == 3 , 5 , 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 7 or n == 5 or n = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> ans = 753 <NEWLINE> <NL> for i in range ( len ( S ) - 2 ) : <NEWLINE> <INDENT> sa = abs ( 753 - ( int ( S [ i ] ) * 100 + int ( S [ i + 1 ] ) * 10 + int ( S [ i + 2 ] ) ) ) <NEWLINE> ans = min ( sa , ans ) <NEWLINE> <NL> <DEDENT> print ( ans <NEWLINE>
S = input ( ) <NEWLINE> print ( min ( abs ( 753 - int ( S [ i , i + 3 ] ) ) for i in range ( len ( S ) - 2 ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> tmp = abs ( 753 - int ( S [ i : i + 2 ] ) <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = abs ( 753 - int ( a [ 0 ] + a [ 1 ] + a [ 2 ] ) ) <NEWLINE> for i in range ( int ( len ( a ) - 2 ) ) : <NEWLINE> <INDENT> if abs ( 753 - int ( a [ i ] + a [ i + 1 ] + a [ i + 2 ] ) ) > abs ( 753 - int ( a [ i + 1 ] + a [ i + 2 ] + a [ i + 3 ] ) ) : <NEWLINE> <INDENT> b = abs ( 753 - int ( a [ i + 1 ] + a [ i + 2 ] + a [ i + 3 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( len ( str ( s ) ) - 2 ) : <NEWLINE> <INDENT> a . extend ( abs ( int ( s [ i ] ) * 100 + int ( s [ i + 1 ] ) * 10 + int ( s [ i + 2 ] ) - 753 ) ) <NEWLINE> <DEDENT> print ( min ( a ) ) <NEWLINE>
1 S = input ( ) <NEWLINE> 2 print ( min ( abs ( int ( S [ i : i + 3 ] ) - 753 ) for i in range ( len ( S ) - 3 ) ) ) <NEWLINE>
l , ans = len ( s ) , [ ] <NEWLINE> for i in range ( 0 , l - 2 ) : <NEWLINE> <INDENT> n = s [ i : i + 3 ] <NEWLINE> ans . append ( abs ( 753 - int ( n ) ) ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) - 2 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( 753 - int ( s [ i : i + 3 ] ) ) ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> from decorator import stop_watch <NEWLINE> <NL> <NL> @ stop_watch <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> dq = deque ( [ ( 3 , [ 1 , 0 , 0 ] ) , ( 5 , [ 0 , 1 , 0 ] ) , ( 7 , [ 0 , 0 , 1 ] ) ] ) <NEWLINE> ans = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> num , check = dq . popleft ( ) <NEWLINE> if num > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if sum ( check ) == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in ( 3 , 5 , 7 ) : <NEWLINE> <INDENT> new_num = num * 10 + i <NEWLINE> if new_num > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> new_check = check . copy ( ) <NEWLINE> if i == 3 : <NEWLINE> <INDENT> new_check [ 0 ] = 1 <NEWLINE> <DEDENT> elif i == 5 : <NEWLINE> <INDENT> new_check [ 1 ] = 1 <NEWLINE> <DEDENT> elif i == 7 : <NEWLINE> <INDENT> new_check [ 2 ] = 1 <NEWLINE> <DEDENT> dq . append ( ( new_num , new_check ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> solve ( N ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tmp = 2 <NEWLINE> ans = 0 <NEWLINE> Flag = True <NEWLINE> while Flag : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> iterator = product ( range ( 3 ) , repeat = tmp ) <NEWLINE> for idxs in iterator : <NEWLINE> <INDENT> num = <STRING> . join ( map ( str , idxs ) ) <NEWLINE> num753 = str ( num ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> if <STRING> in num753 and <STRING> in num753 and <STRING> in num753 : <NEWLINE> <INDENT> if int ( num753 ) <= n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> from itertools import product <NEWLINE> from collectins import Counter <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( n ) - 2 ) : <NEWLINE> <INDENT> for j in list ( product ( <STRING> , repeat = i + 3 ) ) : <NEWLINE> <INDENT> if int ( <STRING> . join ( j ) ) <= int ( n ) and len ( Counter ( j ) ) == 3 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 , len ( str ( N ) ) + 1 ) : <NEWLINE> <INDENT> for j in itertools . product ( <STRING> , repeat = i ) : <NEWLINE> <INDENT> if int ( <STRING> . join ( j ) ) = < N and <STRING> in str ( j ) and <STRING> in str ( j ) and <STRING> in str ( j ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> N = input ( ) <NEWLINE> N_len = len ( N ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def dfs ( a , depth ) : <NEWLINE> <INDENT> if depth == N_len : <NEWLINE> <INDENT> if int ( a ) <= int ( N ) and a . count ( <STRING> ) > 0 and a . count ( <STRING> ) > 0 and a . count ( <STRING> ) > 0 and str ( int ( a ) ) . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> t . append ( a ) <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ret1 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> ret2 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> ret3 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> ret4 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> return ret1 + ret2 + ret3 + ret4 <NEWLINE> <NL> <NL> <DEDENT> ans = dfs ( <STRING> , 0 ) <NEWLINE> print ( ans ) <NEWLINE> <COMMENT> <NL>
from itertools import permutations <NEWLINE> target = [ 3 , 5 , 7 ] <NEWLINE> <NL> clear_list = combinations ( target , 4 ) <NEWLINE> print ( clear_list ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> if int ( n ) < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> for i in range ( 3 , len ( n ) + 1 ) : <NEWLINE> <INDENT> s = list ( product ( <STRING> , repeat = i ) ) <NEWLINE> for combi in s : <NEWLINE> <INDENT> n_s = <STRING> . join ( combi ) <NEWLINE> if int ( n_s ) > int ( n ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( <STRING> in combi ) and ( <STRING> in combi ) and ( <STRING> in combi ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> from copy import deepcopy <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 ] <NEWLINE> dp = [ [ 0 ] * 26 for _ in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = deepcopy ( dp [ i - 1 ] ) <NEWLINE> temp = Counter ( prime_factorize ( i + 1 ) ) <NEWLINE> for x in temp . items ( ) : <NEWLINE> <INDENT> if len ( prime_factorize ( x [ 0 ] ) ) == 1 : <NEWLINE> <INDENT> dp [ i ] [ prime . index ( x [ 0 ] ) ] += x [ 1 ] <NEWLINE> <DEDENT> <DEDENT> four = 0 <NEWLINE> two = 0 <NEWLINE> fourteen = 0 <NEWLINE> twenty_four = 0 <NEWLINE> seventy_four = 0 <NEWLINE> for j in range ( 25 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] >= 74 : <NEWLINE> <INDENT> seventy_four += 1 <NEWLINE> twenty_four += 1 <NEWLINE> fourteen += 1 <NEWLINE> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 24 : <NEWLINE> <INDENT> twenty_four += 1 <NEWLINE> fourteen += 1 <NEWLINE> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 14 : <NEWLINE> <INDENT> fourteen += 1 <NEWLINE> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 4 : <NEWLINE> <INDENT> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 2 : <NEWLINE> <INDENT> two += 1 <NEWLINE> <DEDENT> <DEDENT> dp [ i ] [ 25 ] = ( ( four * ( four - 1 ) ) // 2 ) * ( two - 2 ) + twenty_four * ( two - 1 ) + fourteen * ( four - 1 ) + seventy_four <NEWLINE> <DEDENT> print ( dp [ N - 1 ] [ 25 ] ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = statistics . mean ( a ) <NEWLINE> print ( s ) <NEWLINE> c = float ( <STRING> ) <NEWLINE> d = i <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c != min ( abs ( s - a [ i ] ) , c ) : <NEWLINE> <INDENT> c = s - a [ i ] <NEWLINE> d = i <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> int : n , k , i , j , ans , num , cnt , b <NEWLINE> list : a , btfl <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> btfl = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> btfl . append ( a [ j ] - a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 50 ) [ : : - 1 ] : <NEWLINE> <INDENT> num , cnt = ans + pow ( 2 , i ) , 0 <NEWLINE> for b in btfl : <NEWLINE> <INDENT> if num == num & b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> ans = num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( N , S , k ) : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <NL> <COMMENT> <NL> D_counts = [ 0 ] <NEWLINE> M_counts = [ 0 ] <NEWLINE> DM_counts = [ 0 ] <NEWLINE> <NL> D = 0 <NEWLINE> M = 0 <NEWLINE> DM = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> D += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> DM += D <NEWLINE> M += 1 <NEWLINE> <DEDENT> D_counts . append ( D ) <NEWLINE> M_counts . append ( M ) <NEWLINE> DM_counts . append ( DM ) <NEWLINE> <DEDENT> for i in range ( k , N ) : <NEWLINE> <INDENT> if S [ i - k ] == <STRING> : <NEWLINE> <INDENT> D -= 1 <NEWLINE> DM -= M <NEWLINE> <DEDENT> elif S [ i - k ] == <STRING> : <NEWLINE> <INDENT> M -= 1 <NEWLINE> <NL> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> D += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> DM += D <NEWLINE> M += 1 <NEWLINE> <NL> <DEDENT> D_counts . append ( D ) <NEWLINE> M_counts . append ( M ) <NEWLINE> DM_counts . append ( DM ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> ans += DM_counts [ i ] <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ks = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in ks : <NEWLINE> <INDENT> print ( solve ( N , S , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) ) <NEWLINE> print ( x + y // 2 ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> print ( a + b // 2 ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a + b / 2 ) <NEWLINE>
x , y = map ( int , input . split ( ) ) <NEWLINE> print ( x + y / 2 ) <NEWLINE>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( L [ 0 ] + l [ 1 ] // 2 ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> printint ( ( x + y / 2 ) ) <NEWLINE>
x , y = map ( int , input ( ) ) <NEWLINE> print ( x + y / 2 ) <NEWLINE>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> print ( x + ( y // 2 ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> printint ( ( x + y / 2 ) ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( X + y / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> beta = 0.006 <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> H = np . array ( H ) <NEWLINE> use = t - beta * H - a <NEWLINE> use = use ** 2 <NEWLINE> pre_answer = min ( use ) <NEWLINE> ans = 1 + use . index ( pre_answer ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T , A = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ ] <NEWLINE> for i in H : <NEWLINE> <INDENT> diff . append ( abs ( A - T + i * 0.006 ) ) <NEWLINE> <NL> <DEDENT> diffmin = diff [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if diffmin > diff [ i ] : <NEWLINE> <INDENT> diffmin = diff [ i ] <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( abs ( a - ( t - x * 6 / 1000 ) ) ) <NEWLINE> <DEDENT> print ( l . index ( min ( l ) ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = int ( input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = [ ] <NEWLINE> <NL> for i in h : <NEWLINE> <INDENT> b = t - 0.006 * j - a <NEWLINE> x . append ( b ) <NEWLINE> <NL> <DEDENT> print ( x . index ( min ( x ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , inpt ( ) . split ( ) ) ) <NEWLINE> minn = 10 ** 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minn > abs ( ( t * ( 1000 ) - 6 * H [ i ] ) - a ) : <NEWLINE> <INDENT> ans = H [ i ] <NEWLINE> minn = t * ( 1000 ) - 6 * H [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . solit ( ) ) ) <NEWLINE> num = 0 <NEWLINE> dist = abs ( t - h [ 0 ] * 0.006 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if dist > abs ( ( t - h [ i ] * 0.006 ) ) : <NEWLINE> <INDENT> num = i <NEWLINE> <DEDENT> <DEDENT> print ( num + 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = 0 <NEWLINE> m = 100000000000000 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b = a - t + h [ i ] * 0.006 <NEWLINE> if m > abs ( b ) : <NEWLINE> <INDENT> m = abs ( b ) <NEWLINE> k = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ abs ( a - ( t - i * 0.006 ) ) for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> print ( b . index ( min ( b ) + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> listh = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = [ abs ( ( t - x * 0.006 ) - a ) for x in listh ] <NEWLINE> print ( diff . index ( min ( diff ) + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> T , A = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in h : <NEWLINE> <INDENT> a . append ( abs ( A - ( T - i * 0.006 ) ) ) <NEWLINE> <DEDENT> print ( index ( min ( a ) ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter = 0 <NEWLINE> diff = abs ( a - ( t - h [ 0 ] * 0.006 ) ) <NEWLINE> <NL> for x in h : <NEWLINE> <INDENT> average_temple = t - x * 0.006 <NEWLINE> counter += 1 <NEWLINE> if diff > abs ( a - average_temple ) : <NEWLINE> <INDENT> poss = counter <NEWLINE> <NL> <DEDENT> <DEDENT> print ( poss ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 10 ** 3 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> s = t - x [ i ] * 0.006 <NEWLINE> if abs ( s - a ) < cnt : <NEWLINE> <INDENT> cnt = abs ( s - a ) <NEWLINE> ans = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> T , A = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> TH = [ ] <NEWLINE> for i in n : <NEWLINE> <INDENT> TH . append ( abs ( T - int ( T - 0.006 * H [ i ] ) ) ) <NEWLINE> <DEDENT> print ( TH . index ( min ( TH ) ) + 1 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b , c = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> l [ 0 ] == abs ( c - ( b - l [ 0 ] * 0.006 ) ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if l [ i ] == min . l <NEWLINE> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> T , A = np . array ( input ( ) . split ( ) , dtype = <STRING> ) [ : 2 ] <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> min_dif = 10000 <NEWLINE> place = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp = T - H [ i ] * 0.006 <NEWLINE> dif = abs ( A - temp ) <NEWLINE> <NL> <COMMENT> <NL> if min_dif >= dif : <NEWLINE> <INDENT> min_dif = dif <NEWLINE> place = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( place ) <NEWLINE>
import collections <NEWLINE> import bisect <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ map ( int , input ( ) . splilt ( ) ) for i in range ( m ) ] <NEWLINE> a = collections . defaultdict ( list ) <NEWLINE> for x , y in sorted ( p ) : <NEWLINE> <INDENT> a [ x ] += [ y ] <NEWLINE> <DEDENT> for x , y in p : <NEWLINE> <INDENT> z = bisect . bisect ( a [ x ] , y ) <NEWLINE> print ( <STRING> % ( x , z ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop , heapify <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> <COMMENT> <NL> lst = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ p - 1 ] . append ( y ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( lst [ i ] ) > 1 : <NEWLINE> <INDENT> lst [ i ] . sort ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for pair in py : <NEWLINE> <INDENT> print ( str ( pair [ 0 ] * 1000000 + lst [ pair [ 0 ] - 1 ] . index ( pair [ 1 ] ) + 1 ) . zfill ( 12 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from bisect import bisect <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) for _ in range ( m ) ) ] <NEWLINE> a = defaultdict ( list ) <NEWLINE> for x , y in sorted ( l ) : <NEWLINE> <INDENT> a [ x ] += [ y ] <NEWLINE> <NL> <DEDENT> for x , y in l : <NEWLINE> <INDENT> z = bisect ( a [ x ] , y ) <NEWLINE> print ( <STRING> % ( x , z ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if len ( s ) == 3 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> if len ( S ) == 2 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S . reverse ( ) ) <NEWLINE> <DEDENT>
if len ( S ) == 2 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> if len ( S ) == 3 : <NEWLINE> <INDENT> print ( S [ 2 ] + S [ 1 ] + S [ 0 ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> buffer = 0 <NEWLINE> if len ( S ) != 2 : <NEWLINE> <INDENT> buffer = S [ 0 ] <NEWLINE> S [ 0 ] = S [ 2 ] <NEWLINE> S [ 2 ] = buffer <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if len ( s ) == 2 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> if len ( s ) == 3 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print ( n . reverse ( ) if len ( n ) == 3 else n ) <NEWLINE>
s = input ( ) <NEWLINE> if len ( S ) == 2 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 2 ] + s [ 1 ] + s [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if len ( n ) == 2 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n [ : : - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> res = 2 * ( sum ( a [ N // 2 : ] ) - sum ( a [ : N // 2 ] ) ) <NEWLINE> res += a [ N // 2 - 1 ] - a [ N // 2 ] <NEWLINE> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 2 * ( sum ( a [ N // 2 + 1 : ] ) - sum ( a [ N // 2 ] ) ) <NEWLINE> print ( res - min ( a [ N // 2 + 1 ] - a [ N // 2 ] - a [ N // 2 - 1 ] ) ) <NEWLINE> <DEDENT>
A . sort ( ) <NEWLINE> n = N // 2 <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> ans1 , ans2 , ans = 0 , 0 , 0 <NEWLINE> ar1 , ar2 = A [ : n ] , A [ n + 1 : ] <NEWLINE> ar = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ar . append ( ar2 [ i ] ) <NEWLINE> ar . append ( ar1 [ i ] ) <NEWLINE> <DEDENT> ar . append ( A [ n ] ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans1 += abs ( ar [ i ] - ar [ i + 1 ] ) <NEWLINE> <DEDENT> ar = [ A [ n ] ] + ar [ : - 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans2 += abs ( ar [ i ] - ar [ i + 1 ] ) <NEWLINE> <DEDENT> ans = max ( ans1 , ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> ar1 , ar2 = A [ : n ] , A [ n : ] <NEWLINE> ar = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ar . append ( ar2 [ i ] ) <NEWLINE> ar . append ( ar1 [ i ] ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += abs ( ar [ i ] - ar [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 50000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> d_1 , d_2 = deque ( [ ] ) , deque ( [ ] ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> l . sort ( ) <NEWLINE> l_1 , l_2 = copy . copy ( l ) , copy . copy ( l ) <NEWLINE> d_1 . append ( max ( l ) ) <NEWLINE> d_2 . append ( min ( l ) ) <NEWLINE> l_1 . pop ( ) <NEWLINE> l_2 . pop ( 0 ) <NEWLINE> <NL> def main1 ( d , l ) : <NEWLINE> <INDENT> d . appendleft ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . appendleft ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main1 ( d , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main2 ( d , l ) : <NEWLINE> <INDENT> d . appendleft ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . appendleft ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main2 ( d , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> x , y = 0 , 0 <NEWLINE> a = main1 ( d_1 , l_1 ) <NEWLINE> b = main2 ( d_2 , l_2 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x += abs ( a [ i + 1 ] - a [ i ] ) <NEWLINE> y += abs ( b [ i + 1 ] - b [ i ] ) <NEWLINE> <DEDENT> print ( max ( x , y ) ) <NEWLINE>
from copy import deepcopy <NEWLINE> <NL> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> acopy = deepcopy ( a ) <NEWLINE> a . sort ( ) <NEWLINE> acopy . sort ( reverse = True ) <NEWLINE> <NL> L = deque ( [ ] ) <NEWLINE> a = deque ( a ) <NEWLINE> acopy = deque ( acopy ) <NEWLINE> Lcopy = deepcopy ( L ) <NEWLINE> <NL> max_ = a . pop ( ) <NEWLINE> L . append ( max_ ) <NEWLINE> min_ = acopy . pop ( ) <NEWLINE> Lcopy . append ( min_ ) <NEWLINE> <NL> while a : <NEWLINE> <INDENT> if a : <NEWLINE> <INDENT> b = a . popleft ( ) <NEWLINE> L . append ( b ) <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> c = a . popleft ( ) <NEWLINE> L . appendleft ( c ) <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> d = a . pop ( ) <NEWLINE> L . append ( d ) <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> e = a . pop ( ) <NEWLINE> L . appendleft ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> while acopy : <NEWLINE> <INDENT> if acopy : <NEWLINE> <INDENT> b = acopy . popleft ( ) <NEWLINE> Lcopy . append ( b ) <NEWLINE> <DEDENT> if acopy : <NEWLINE> <INDENT> c = acopy . popleft ( ) <NEWLINE> Lcopy . appendleft ( c ) <NEWLINE> <DEDENT> if acopy : <NEWLINE> <INDENT> d = acopy . pop ( ) <NEWLINE> Lcopy . append ( d ) <NEWLINE> <DEDENT> if acopy : <NEWLINE> <INDENT> e = acopy . pop ( ) <NEWLINE> Lcopy . appendleft ( e ) <NEWLINE> <DEDENT> <DEDENT> ans1 , ans2 = 0 , 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( L ) - 1 ) : <NEWLINE> <INDENT> ans1 += abs ( L [ i + 1 ] - L [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( Lcopy ) - 1 ) : <NEWLINE> <INDENT> ans2 += abs ( Lcopy [ i + 1 ] - Lcopy [ i ] ) <NEWLINE> <DEDENT> print ( max ( ans1 , ans2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> from collections import deque <NEWLINE> d . sort ( ) <NEWLINE> a = deque ( d ) <NEWLINE> <NL> tmpl = a . popleft ( ) <NEWLINE> tmpr = tmpl <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while len ( a ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 1 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 2 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 3 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> res = ans <NEWLINE> <NL> d . sort ( reverse = True ) <NEWLINE> a = deque ( copy . deepcopy ( d ) ) <NEWLINE> <NL> tmpl = a . popleft ( ) <NEWLINE> tmpr = tmpl <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while len ( a ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 1 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 2 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 3 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( max ( ans , res ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , m = I ( ) <NEWLINE> s = v ( ) <NEWLINE> t = v ( ) <NEWLINE> l = lcm ( n , m ) <NEWLINE> g = gcd ( n , m ) <NEWLINE> <NL> for i in range ( g ) : <NEWLINE> <INDENT> if s [ n // g * i ] != t [ m // g * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
import math <NEWLINE> def main5 ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> G = math . gcd ( N , M ) <NEWLINE> L = ( N * M ) // G <NEWLINE> <NL> for i in range ( G ) : <NEWLINE> <INDENT> if S [ i * N // G ] != T [ i * M // G ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> g = gcd ( n , m ) <NEWLINE> ans = n * m // g <NEWLINE> a , b = n // g , m // g <NEWLINE> x , y = 0 , 0 <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if s [ x ] != x [ y ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> x += a <NEWLINE> y += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
from math import gcd <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = input ( ) <NEWLINE> d = input ( ) <NEWLINE> <NL> e = gcd ( n , m ) <NEWLINE> <NL> ae = a // e <NEWLINE> be = b // e <NEWLINE> <NL> for i in range ( 0 , e ) : <NEWLINE> <INDENT> if c [ ae * i ] != d [ be * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ae * be * e ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if ( n == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n == 2 ) : <NEWLINE> <INDENT> print ( int ( a + b ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 2 : <NEWLINE> <INDENT> print ( int ( b + c ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> orint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
a = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> <NL> if a [ 0 ] == 2 : <NEWLINE> <INDENT> print ( a [ 1 ] + a [ 2 ] ) <NEWLINE> <NL> <DEDENT> elif a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> n = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if n == 1 : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = int ( lines [ 1 ] ) <NEWLINE> B = int ( lines [ 2 ] ) <NEWLINE> return [ A + B ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> N = int ( line ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 8 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if n == 1 : print ( <STRING> ) <NEWLINE> else : print ( a + b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : print ( <STRING> ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 2 : print ( a + b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
if input ( ) == <STRING> : <NEWLINE> <INDENT> print ( Hello World ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( eval ( input ( ) + <STRING> + input ( ) ) ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> l = [ ] <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] [ 2 ] <= t : <NEWLINE> <INDENT> l . append ( a [ i ] [ 0 ] ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( min ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
T , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_c = 1001 <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> c , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( N >= t ) and ( c <= ans_c ) : <NEWLINE> <INDENT> ans_c = c <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_t == 1001 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_c ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> k = 1000 <NEWLINE> l = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , t = int ( input ( ) ) <NEWLINE> if t [ i ] <= T : <NEWLINE> <INDENT> l = 0 <NEWLINE> if c [ i ] < k : <NEWLINE> <INDENT> k = c [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if l == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1001 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) if c < 1001 else print ( <STRING> ) <NEWLINE>
a , b = map ( int , inpu ( ) . split ( ) ) <NEWLINE> meta = int ( a ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > y and a > x : <NEWLINE> <INDENT> a = x <NEWLINE> <DEDENT> <DEDENT> if meta > a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = 1001 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <NL> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if t <= T : <NEWLINE> <INDENT> m = min ( m , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if m == 1001 else m ) <NEWLINE> <NL>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> Y = [ X [ i ] if X [ i ] [ 1 ] <= T for i in range ( N ) ] <NEWLINE> print ( Y ) <NEWLINE>
n , t = map ( int , input . split ( ) ) <NEWLINE> <NL> max_cost = 10 ** 9 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> c , tt = map ( int , input ( ) . split ( ) ) <NEWLINE> if tt <= t : <NEWLINE> <INDENT> max_cost = max ( max_cost , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_cost ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 999 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> if t <= tmp [ 1 ] : <NEWLINE> <INDENT> if tmp [ 0 ] < c : <NEWLINE> <INDENT> c = tmp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 100000 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if ans = 100000 else ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> d = 1001 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if int ( c [ i ] [ i ] ) <= b : <NEWLINE> <INDENT> if d > int ( c [ i ] [ i ] ) : <NEWLINE> <INDENT> d = int ( c [ i ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , T = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> min_c = None <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c , t = list ( map ( int , lines [ i ] . split ( ) ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> if min_c is None : <NEWLINE> <INDENT> min_c = c <NEWLINE> <DEDENT> elif min_c > c : <NEWLINE> <INDENT> min_c = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min_c is None : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ min_c ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 4 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 5 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xyh = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> ansh = - 1 <NEWLINE> ans = [ ] <NEWLINE> flag = True <NEWLINE> for cx in range ( 0 , 101 ) : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for cy in range ( 0 , 101 ) : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ansh = - 1 <NEWLINE> for pira in xyh : <NEWLINE> <NL> <INDENT> if flag and pira [ 2 ] == 0 and ansh == - 1 and pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) <= 0 : <NEWLINE> <INDENT> ansh = pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) <NEWLINE> ans . append ( [ cx , cy , ansh ] ) <NEWLINE> <NL> <DEDENT> elif flag and pira [ 2 ] > 0 and ansh == - 1 : <NEWLINE> <INDENT> ansh = pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) <NEWLINE> ans . append ( [ cx , cy , ansh ] ) <NEWLINE> flag = False <NEWLINE> <NL> <DEDENT> elif len ( ans ) > 0 and pira [ 2 ] > 0 and ansh != pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif len ( ans ) > 0 and pira [ 2 ] == 0 and ansh - abs ( cx - pira [ 0 ] ) - abs ( cy - pira [ 1 ] ) > 0 : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> Cx = 0 <NEWLINE> Cy = 0 <NEWLINE> H = 0 <NEWLINE> dp = [ [ 0 ] * 101 for i in range ( 101 ) ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> for k in range ( 101 ) : <NEWLINE> <INDENT> count = abs ( x [ i ] [ 0 ] - j ) + abs ( x [ i ] [ 1 ] - k ) + x [ i ] [ 2 ] <NEWLINE> if dp [ j ] [ k ] != i * count : <NEWLINE> <INDENT> dp [ j ] [ k ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j ] [ k ] += count <NEWLINE> <DEDENT> ans = min ( ans , x [ i ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = 10 ** 19 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] % N == 0 dp [ i ] [ j ] != 0 : <NEWLINE> <INDENT> if p != min ( p , dp [ i ] [ j ] // N ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> p = min ( p , dp [ i ] [ j ] // N ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a , b , p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> XYH = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> x1 , y1 , h1 = XYH [ 0 ] <NEWLINE> <COMMENT> <NL> <NL> for Cx in range ( 101 ) : <NEWLINE> <INDENT> for Cy in range ( 101 ) : <NEWLINE> <INDENT> H = h1 + abs ( x1 - Cx ) + abs ( y1 - Cy ) <NEWLINE> <COMMENT> <NL> if all ( h == max ( H - abs ( x - Cx ) - abs ( y - Cy ) , 0 ) for x , y , h in XYH : <NEWLINE> <INDENT> print ( Cx , Cy , H ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> conditions = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> conditions . append ( [ x , y , h ] ) <NEWLINE> <NL> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> H = - 1 <NEWLINE> for _ , cond in enumerate ( conditions ) : <NEWLINE> <INDENT> if cond [ 2 ] > 0 : <NEWLINE> <INDENT> H_tmp = cond [ 2 ] + abs ( cond [ 0 ] - cx ) + abs ( cond [ 1 ] - cy ) <NEWLINE> if H == - 1 : <NEWLINE> <INDENT> H = H_tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H_tmp != H : <NEWLINE> <INDENT> H = - 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if H == - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for _ , cond in enumerate ( conditions ) : <NEWLINE> <INDENT> if cond [ 2 ] == 0 : <NEWLINE> <INDENT> if H > abs ( cond [ 0 ] - cx ) + abs ( cond [ 1 ] - cy ) : <NEWLINE> <INDENT> H = - 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if H == - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( cx , cy , H ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N = int ( input ( ) ) <NEWLINE> xyh = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xyh [ i ] = tuple ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict <NEWLINE> H = defaultdict ( set ) <NEWLINE> for x , y , h in xyh : <NEWLINE> <INDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> xx = x - cx <NEWLINE> yy = y - cy <NEWLINE> if cx <= x and cy <= y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h + xx + yy ) ) <NEWLINE> <DEDENT> elif cx > x and cy <= y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h - xx + yy ) ) <NEWLINE> <DEDENT> elif cx <= x and cy > y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h + xx - yy ) ) <NEWLINE> <DEDENT> elif cx > x and cy > y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h - xx - yy ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k , v in H . items ( ) : <NEWLINE> <INDENT> if len ( v ) == 1 : <NEWLINE> <INDENT> if 0 <= v [ 0 ] <= 10 ** 9 : <NEWLINE> <INDENT> print ( * k , * v ) <NEWLINE> <DEDENT> elif v [ 0 ] < 0 : <NEWLINE> <INDENT> print ( * k , 0 ) <NEWLINE> <DEDENT> elif 10 ** 9 < v [ 0 ] : <NEWLINE> <INDENT> print ( * k , 10 ** 9 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> points = list ( ) <NEWLINE> highest = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> point = list ( map ( int , lines [ i ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> points . append ( point ) <NEWLINE> if highest < point [ 2 ] : <NEWLINE> <INDENT> highest = point [ 2 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> for h in range ( highest , highest + 200 ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag = True <NEWLINE> for point in points : <NEWLINE> <COMMENT> <NL> <INDENT> calc_h = max ( h - abs ( point [ 0 ] - x ) - abs ( point [ 1 ] - y ) , 0 ) <NEWLINE> if point [ 2 ] != calc_h : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> result = str ( x ) + <STRING> + str ( y ) + <STRING> + str ( h ) <NEWLINE> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> import numba as nb <NEWLINE> from numba import njit , i8 , u1 , b1 <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_ints2 ( x ) : return map ( lambda num : int ( num ) - x , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def GCD ( a : int , b : int ) -> int : return b if a % b == 0 else GCD ( b , a % b ) <NEWLINE> def LCM ( a : int , b : int ) -> int : return ( a * b ) // GCD ( a , b ) <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( info ) : <NEWLINE> <INDENT> for Cx in range ( 101 ) : <NEWLINE> <INDENT> for Cy in range ( 101 ) : <NEWLINE> <INDENT> height = abs ( Cx - info [ 0 ] [ 0 ] ) + abs ( Cy - info [ 0 ] [ 1 ] ) + info [ 0 ] [ 2 ] <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , len ( info ) - 1 ) : <NEWLINE> <INDENT> x , y , h = info [ i ] [ 0 ] , info [ i ] [ 1 ] , info [ i ] [ 2 ] <NEWLINE> val = max ( height - abs ( Cx - x ) - abs ( Cy - y ) , 0 ) <NEWLINE> if h == val : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> return Cx , Cy , height <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> n = read_int ( ) <NEWLINE> info = np . empty ( ( n , 3 ) , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> info [ i ] [ 0 ] , info [ i ] [ 1 ] , info [ i ] [ 2 ] = read_ints ( ) <NEWLINE> <DEDENT> print ( * solve ( info ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xyh = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> xyh . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> x , y , h = xyh [ 0 ] <NEWLINE> tmp_h = abs ( cy - y ) + abs ( cx - x ) + h <NEWLINE> H = np . zeros ( n , dtype = np . bool ) <NEWLINE> for i , a in enumerate ( xyh ) : <NEWLINE> <INDENT> H [ i ] = a [ 2 ] == max ( tmp_h - abs ( cx - a [ 0 ] ) - abs ( cy - a [ 1 ] ) , 0 ) <NEWLINE> <DEDENT> if np . all ( H ) : <NEWLINE> <INDENT> print ( cx , cy , tmp_h ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <NL> <COMMENT> <NL> N , M = MAP ( ) <NEWLINE> <NL> def make_divisors ( n ) : <COMMENT> <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> divisors = make_divisors ( M ) <NEWLINE> print ( divisors ) n = divisors [ bisect_left ( divisors , N ) ] <NEWLINE> print ( M // n ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i = 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> array = make_divisors ( m ) <NEWLINE> array . reverse ( ) <NEWLINE> for ele in array : <NEWLINE> <INDENT> if m // ele >= n : <NEWLINE> <INDENT> print ( ele ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> res = [ ] <NEWLINE> for i in range ( 1 , n ** .5 + 1 ) <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> if n // i not in res : <NEWLINE> <INDENT> res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res . sort ( reverse = True ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> md = divisor ( m ) <NEWLINE> for i in md : <NEWLINE> <INDENT> if i * n <= m : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ret = <STRING> <NEWLINE> for a in input ( ) : <NEWLINE> <INDENT> if a = <STRING> : <NEWLINE> <INDENT> ret += <STRING> <NEWLINE> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> ret += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += a <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a . replace ( 1 , 8 ) . replace ( 9 , 1 ) . replace ( 8 , 9 ) ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
def f ( c ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( map ( f , input ( ) ) ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> n [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( int ( n ) ) <NEWLINE>
a = input ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> a [ 0 ] = <STRING> <NEWLINE> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> a [ 0 ] == <STRING> <NEWLINE> <DEDENT> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> a [ 1 ] == <STRING> <NEWLINE> <DEDENT> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> a [ 1 ] == <STRING> <NEWLINE> <DEDENT> if a [ 2 ] == <STRING> : <NEWLINE> <INDENT> a [ 2 ] == <STRING> <NEWLINE> <DEDENT> if a [ 2 ] == <STRING> : <NEWLINE> <INDENT> a [ 2 ] == <STRING> <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for k in l : <NEWLINE> <INDENT> print ( k , end = <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> pirnt ( a . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> if n = 111 : <NEWLINE> <INDENT> print ( 999 ) <NEWLINE> <DEDENT> elif n = 119 : <NEWLINE> <INDENT> print ( 991 ) <NEWLINE> <DEDENT> elif n = 191 : <NEWLINE> <INDENT> print ( 919 ) <NEWLINE> <DEDENT> elif n = 199 : <NEWLINE> <INDENT> print ( 911 ) <NEWLINE> <DEDENT> elif n = 911 : <NEWLINE> <INDENT> print ( 199 ) <NEWLINE> <DEDENT> elif n = 919 : <NEWLINE> <INDENT> print ( 191 ) <NEWLINE> <DEDENT> elif n = 991 : <NEWLINE> <INDENT> print ( 199 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 111 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> print ( input ( ) . replace ( 1 , x ) . replace ( 9.1 ) . replace ( x , 9 ) ) <NEWLINE>
print ( int ( input ( ) ) - N ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a , replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 100 * ( 10 - n [ 0 ] ) + 10 * ( 10 - n [ 1 ] ) + 10 - n [ 2 ] ) <NEWLINE>
n = input ( ) <NEWLINE> result = <STRING> <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> result += 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == 1 : <NEWLINE> <INDENT> ans += 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> <NL> ans = <STRING> <NEWLINE> <NL> if n [ 0 ] == <STRING> : <NEWLINE> ans = ans + <STRING> <NEWLINE> else : <NEWLINE> ans = ans + <STRING> <NEWLINE> <NL> if n [ 1 ] == <STRING> : <NEWLINE> ans = ans + <STRING> <NEWLINE> else : <NEWLINE> ans = ans + <STRING> <NEWLINE> <NL> <NL> if n [ 2 ] == <STRING> : <NEWLINE> ans = ans + <STRING> <NEWLINE> else : <NEWLINE> ans = ans + <STRING> <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE>
S = input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , 9 ) <NEWLINE> print ( S ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = lines [ 0 ] <NEWLINE> <NL> return [ n . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a % 100 <NEWLINE> c = a // 100 <NEWLINE> if b <= c * 11 : <NEWLINE> <INDENT> print ( c * 111 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) c + 1 ) * 111 ) <NEWLINE> <DEDENT>
number = int ( input ( ) ) <NEWLINE> i = int ( number / 111 ) <NEWLINE> if number % 111 != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( i * 111 ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = - ( - n // 111 ) <NEWLINE> if a = 10 : <NEWLINE> <INDENT> print ( 1111 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * 111 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> e1 , e2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> z = a // 9 <NEWLINE> af = a % 9 <NEWLINE> if af == 0 : <NEWLINE> <INDENT> print ( str ( 9 ) * ( z ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( af ) * ( z + 1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = set ( str ( N ) ) <NEWLINE> Y = len ( X ) <NEWLINE> if Y == 1 <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> if Y != 1 : <NEWLINE> <INDENT> Z = 0 <NEWLINE> for i in range ( 111 , 1000 , 111 ) : <NEWLINE> <INDENT> if N - i < 0 : <NEWLINE> <INDENT> Z += i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( Z ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( int ( n ) , 1000 ) : <NEWLINE> <INDENT> if i . count ( n [ 0 ] ) == 3 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if 100 * i + 10 * i + i = > n : <NEWLINE> <INDENT> print ( 100 * i + 10 * i + i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if N % 111 == 0 : <NEWLINE> <INDENT> result = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = - ( - N // 111 ) * 111 <NEWLINE> <NL> <DEDENT> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 111 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 222 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 777 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( set ( v ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> c1 = Counter ( v [ : : 2 ] ) <NEWLINE> c2 = Counter ( v [ 1 : : 2 ] ) <NEWLINE> o = c1 . most_common ( 2 ) <NEWLINE> e = c2 . most_common ( 2 ) <NEWLINE> o . append ( ( 0 , 0 ) ) <NEWLINE> e . append ( ( 0 , 0 ) ) <NEWLINE> if o [ 0 ] [ 0 ] == e [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( min ( n - o [ 1 ] [ 1 ] - e [ 0 ] [ 1 ] , n - o [ 0 ] [ 1 ] - e [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - o ( 2 ) [ 0 ] [ 1 ] - e ( 2 ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> A , B = [ [ - 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> L . append ( list_A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( list_A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = itertools . groupby ( L ) <NEWLINE> for key , group in L : <NEWLINE> <INDENT> A . append ( [ key , len ( list ( group ) ) ] ) <NEWLINE> <NL> <DEDENT> A . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> R = itertools . groupby ( R ) <NEWLINE> for key , group in R : <NEWLINE> <INDENT> B . append ( [ key , len ( list ( group ) ) ] ) <NEWLINE> <NL> <DEDENT> B . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> if A [ 0 ] [ 0 ] != B [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - A [ 0 ] [ 1 ] - B [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - A [ 1 ] [ 1 ] - B [ 0 ] [ 1 ] , n - A [ 0 ] [ 1 ] - B [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d1 = { } <NEWLINE> d2 = { } <NEWLINE> l1 = [ ] <NEWLINE> l2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = v [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d1 [ num ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d1 [ num ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d2 [ num ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d2 [ num ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in d1 : <NEWLINE> <INDENT> l1 . append ( [ d1 [ i ] , i ] ) <NEWLINE> <DEDENT> for i in d2 : <NEWLINE> <INDENT> l2 . append ( [ d2 [ i ] , i ] ) <NEWLINE> <DEDENT> l1 . sort ( reverse = True ) <NEWLINE> l2 . sort ( reverse = True ) <NEWLINE> ans = n <NEWLINE> if l1 [ 0 ] [ 1 ] != l2 [ 0 ] [ 1 ] : <NEWLINE> <INDENT> ans -= ( l1 [ 0 ] [ 0 ] + l2 [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> elif len ( l1 ) == 1 and len ( l2 ) == 1 : <NEWLINE> <INDENT> ans //= 2 <NEWLINE> <DEDENT> elif len ( l1 ) == 1 : <NEWLINE> <INDENT> ans -= l2 [ 1 ] [ 0 ] <NEWLINE> <DEDENT> elif len ( l2 ) == 1 <NEWLINE> <INDENT> ans -= l1 [ 1 ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ans - l1 [ 0 ] [ 0 ] - l2 [ 1 ] [ 0 ] <NEWLINE> b = ans - l1 [ 1 ] [ 0 ] - l2 [ 0 ] [ 0 ] <NEWLINE> ans = min ( a , b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d1 = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> d2 = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> d1 [ v [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d2 [ v [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> assert n - max ( d1 ) - max ( d2 ) < 0 <NEWLINE> print ( n - max ( d1 ) - max ( d2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * V , = map ( int , input ( ) . split ( ) ) <NEWLINE> import Counter from collections <NEWLINE> <NL> c1 = Counter ( V [ 0 : : 2 ] ) . most_common ( ) + [ ( 0 , 0 ) ] <NEWLINE> c2 = Counter ( V [ 1 : : 2 ] ) . most_common ( ) + [ ( 0 , 0 ) ] <NEWLINE> if c1 [ 0 ] [ 0 ] != c2 [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( N - c1 [ 0 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( N - c1 [ 0 ] [ 1 ] - c2 [ 1 ] [ 1 ] , N - c1 [ 1 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
a , b , c = input ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b < c : <NEWLINE> <INDENT> b , c = c , b <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> print ( 10 * a + b + c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> d = str ( a [ 2 ] ) + str ( a [ 1 ] ) <NEWLINE> print ( int ( d ) + a [ 0 ] ) <NEWLINE>
A , B , C = I ( ) <NEWLINE> if max ( A , B , C ) == A : <NEWLINE> <INDENT> print ( A * 10 + B + C ) <NEWLINE> <DEDENT> if max ( A , B , C ) == B : <NEWLINE> <INDENT> print ( B * 10 + A + C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C * 10 + A + B ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> a = list [ 2 ] * 10 + list [ 1 ] + list [ 2 ] <NEWLINE> print ( a ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> print ( A [ 0 ] * 10 + A [ 1 ] + A [ 2 ] <NEWLINE>
A , B , C = input ( ) . split ( ) <NEWLINE> ichi = eval ( AB + C ) <NEWLINE> two = eval ( A + BC ) <NEWLINE> print ( max ( ichi , two ) ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> m = max ( A , B , C ) <NEWLINE> print ( m * 9 + sum ( A , B , C ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> a , b , c = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> result = max ( a , b , c ) * 9 + a + b + c <NEWLINE> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 53 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 108 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 82 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( A * 10 + B + C , A + N * 10 + C ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , M , X , Y = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> xs = list ( map ( int , lines [ 1 ] . split ( ) ) ) <NEWLINE> ys = list ( map ( int , lines [ 2 ] . split ( ) ) ) <NEWLINE> xs . append ( X ) <NEWLINE> ys . append ( Y ) <NEWLINE> max_x = max ( xs ) <NEWLINE> min_y = min ( ys ) <NEWLINE> if max_x < min_y : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , X , Y = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = max ( [ X ] , max ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> y = min ( [ Y ] , min ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if x < y else <STRING> ) <NEWLINE>
n , m , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yy = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xxx = max ( xx + list ( x ) ) <NEWLINE> yyy = min ( yy + list ( y ) ) <NEWLINE> if xxx < yyy : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x . sort ( reverse = True ) <NEWLINE> y . sort ( ) <NEWLINE> <NL> <NL> flag = 0 <NEWLINE> for i in range ( X + 1 , Y + 1 ) : <NEWLINE> <INDENT> if x [ 0 ] <= i and y [ 0 ] > i : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ListX = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ListY = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ListX . sort ( ) <NEWLINE> ListX . sort ( ) <NEWLINE> threX = max ( X , List [ N - 1 ] ) <NEWLINE> threY = min ( Y , List [ 0 ] ) <NEWLINE> Z = threX + 1 <NEWLINE> if threY >= Z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , x , y = map ( list ( input ( ) . split ( ) ) ) <NEWLINE> a = map ( list ( input ( ) . split ( ) ) ) <NEWLINE> b = map ( list ( input ( ) . split ( ) ) ) <NEWLINE> max_x = max ( a ) <NEWLINE> max_y = max ( b ) <NEWLINE> max_x = max ( max_x , x ) <NEWLINE> max_y = max ( max_y , y ) <NEWLINE> <NL> if max_x < max_y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = min ( y ) - max ( x ) <NEWLINE> if D >= 0 and max ( x ) + D <= min ( y ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x_max = max ( X ) <NEWLINE> y_min = min ( Y ) <NEWLINE> <NL> flg = False <NEWLINE> for Z in range ( x + 1 , y + 1 ) : <NEWLINE> <INDENT> if x_max < Z and Z <= y_min : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> x = defaultdict ( list ) <NEWLINE> <NL> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> x [ t ] . append ( S [ i ] ) <NEWLINE> <NL> <DEDENT> ok = True <NEWLINE> for k , v in x . items ( ) : <NEWLINE> <INDENT> a = v [ 0 ] <NEWLINE> for c in v : <NEWLINE> <INDENT> if c != a : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> A = collections . Counter ( a ) <NEWLINE> B = collections . Counter ( b ) <NEWLINE> Asort = sorted ( A . values ( ) ) <NEWLINE> Bsort = sorted ( B . values ( ) ) <NEWLINE> if list ( Asort . values ( ) ) == list ( Bsort . values ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10000 <NEWLINE> <NL> dp = [ [ 0 ] * ( m + 1 ) for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if j - 1 - a [ i ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = ( dp [ i + 1 ] [ j - 1 ] + dp [ i ] [ j ] - dp [ i ] [ j - 1 - a [ i ] ] ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = ( dp [ i + 1 ] [ j - 1 ] + dp [ i ] [ j ] ) % M <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <INDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] and n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N + 100 + 1 ) : <NEWLINE> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> <NL> for p , cnt in primes : <NEWLINE> tmp = cmb ( N + cnt - 1 , N - 1 , mod ) <NEWLINE> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( 2 , floor ( sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> while M % i == 0 : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> M //= i <NEWLINE> <DEDENT> <DEDENT> if M != 1 : <NEWLINE> <INDENT> d [ M ] += 1 <NEWLINE> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return comb ( n - 1 , k - 1 ) * n // k <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for e in d . values ( ) : <NEWLINE> <INDENT> ans *= comb ( N + e - 1 , e ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> s = 0 <NEWLINE> i = 0 <NEWLINE> <NL> if sum ( a ) <= x : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif min ( a ) > x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while s < x : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i - 1 ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > x : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= A [ i ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x -= a [ i ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt if x <= 0 else cnt - 1 ) <NEWLINE>
children = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> children . sort ( ) <NEWLINE> count = 0 <NEWLINE> c = 0 <NEWLINE> if x < children [ 0 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> count += children [ i ] <NEWLINE> c += 1 <NEWLINE> if count == x : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif count > x : <NEWLINE> <INDENT> print ( c - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - 1 ) <NEWLINE>
for i in range ( N ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> if x >= sort_a [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> x -= sort_a [ i ] <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sort ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if x >= a [ i ] : <NEWLINE> <INDENT> x -= a [ i ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N , x = input ( ) . split ( ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> a . append ( int ( A [ i ] ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> a . append ( 1 ) <NEWLINE> X = int ( x ) <NEWLINE> <NL> idx = 0 <NEWLINE> while X >= 0 : <NEWLINE> <INDENT> X = X - a [ idx ] <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> print ( idx - 1 ) <NEWLINE>
N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> a_sum = [ sum ( a [ : i + 1 ] ) for i in range ( len ( a ) ) ] <NEWLINE> <NL> for i , item in enumerate ( a_sum ) : <NEWLINE> <INDENT> if x < item : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> elif x == item : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <DEDENT> elif x > item and i == len ( a_sum ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if x >= a [ min ] : <NEWLINE> <INDENT> x -= i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ar = a . sort ( reverse = True , key = int ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x -= ar [ i ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x += ar [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> @ jit <NEWLINE> def main ( n , x , a ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> x -= i <NEWLINE> if x <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i == a [ - 1 ] and x > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n , x = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . sort ( np . array ( readline ( ) . split ( ) , np . int64 ) ) <NEWLINE> print ( main ( n , x , a ) ) <NEWLINE>
<COMMENT> <NL> N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cou = 0 <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cou += 1 <NEWLINE> x -= i <NEWLINE> <NL> <DEDENT> while x > 0 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> cou -= 1 <NEWLINE> break <NEWLINE> <DEDENT> while x > i : <NEWLINE> <INDENT> x -= i <NEWLINE> <DEDENT> cou -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> S = [ ] <NEWLINE> for i in s : <COMMENT> <NEWLINE> <INDENT> if i == <STRING> : S . append ( 0 ) <NEWLINE> else : S . append ( 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> R = [ list ( ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> C = [ [ 0 , 0 ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a - 1 ] . append ( b - 1 ) <NEWLINE> R [ b - 1 ] . append ( a - 1 ) <NEWLINE> C [ a - 1 ] [ S [ b - 1 ] ] += 1 <NEWLINE> C [ b - 1 ] [ S [ a - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> O = [ 0 ] * N <COMMENT> <NEWLINE> q = deque ( ) <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] [ 0 ] * C [ i ] [ 1 ] == 0 : <COMMENT> <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> O [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for v in R [ x ] : <NEWLINE> <INDENT> C [ v ] [ S [ x ] ] -= 1 <NEWLINE> if C [ v ] [ S [ x ] ] == 0 and O [ v ] != 0 : <NEWLINE> <INDENT> O [ v ] = 1 <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sum ( O ) == N : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( a * b * i ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . input ( ) ) <NEWLINE> <NL> print ( <STRING> if A % 2 != 0 and B % 2 != 0 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> if ( a * b ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> if A * B % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> print ( <STRING> if ri ( ) == 2 or ri ( ) == 2 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % 2 == and b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> check = False <NEWLINE> for C in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( A * B * C ) % 2 == 1 : <NEWLINE> <INDENT> check = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if check else <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = True <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( A * B * i ) % 2 == 1 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> for c in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( a * b * c ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ A % 2 == 1 and B % 2 == 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = [ input ( ) for _ in range ( N ) ] <NEWLINE> Ws = [ ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Ws . append ( W [ i ] ) <NEWLINE> for j in range ( 1 , N + 1 ) <NEWLINE> <INDENT> if W [ i ] [ - 1 ] == W [ j ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( set ( W ) ) != len ( Ws ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Word_List = [ ] <NEWLINE> SP = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CW = str ( input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> Word_List . append ( CW ) <NEWLINE> SP = CW [ - 1 ] <NEWLINE> <DEDENT> elif SP != CW [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Word_List . append ( CW ) <NEWLINE> SP = CW [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Word_List = collections . Counter ( Word_List ) ) <NEWLINE> if len ( Word_List ) != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> x = str ( input ( ) ) <NEWLINE> a [ 0 ] = x <NEWLINE> d = bool ( True ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> y = str ( input ) <NEWLINE> if x [ len ( x ) ] != y [ 0 ] : <NEWLINE> <INDENT> d = False <NEWLINE> <DEDENT> for i in range ( a . size ( ) ) : <NEWLINE> <INDENT> if y == a [ i ] : <NEWLINE> <INDENT> d = False <NEWLINE> <DEDENT> <DEDENT> a . append ( y ) <NEWLINE> <NL> <DEDENT> if d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = [ input ( ) for _ in range ( int ( input ( ) ) ) ] ; if len ( set ( n ) ) != len ( n ) : print ( <STRING> ) ; exit ( ) <NEWLINE> print ( <STRING> [ all ( [ 1 if n [ i - 1 ] [ - 1 ] == n [ i ] [ 0 ] else 0 for i in range ( 1 , len ( n ) ) ] ) : : 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) for i in range ( N ) ) <NEWLINE> if len ( A ) == len ( set ( A ) ) : <NEWLINE> <INDENT> if all ( A [ i ] [ - 1 ] == A [ i + 1 ] [ 0 ] ) for i in range ( N - 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> if len ( set ( alist ) ) == n : <NEWLINE> <INDENT> if all ( alist [ i ] [ - 1 ] == alist [ i + 1 ] [ 0 ] ) for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> W = [ ] <NEWLINE> w = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != 0 and w [ - 1 ] != str ( input ( ) ) [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = str ( input ( ) ) <NEWLINE> W . append ( w ) <NEWLINE> <DEDENT> <DEDENT> if len ( W ) != len ( list ( set ( W ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> m = dict ( ) <NEWLINE> <NL> prev = input ( ) <NEWLINE> m [ prev ] = True <NEWLINE> flg = True <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> flg = all ( flg , s not in m , prev [ len ( prev ) - 1 ] == s [ 0 ] ) <NEWLINE> m [ s ] = True <NEWLINE> prev = s <NEWLINE> <NL> <DEDENT> print ( <STRING> if flg else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> if l . most_common ( ) [ 0 ] [ 1 ] != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_head = [ i [ 0 ] for i in l ] <NEWLINE> l_tail = [ i [ - 1 ] for i in l ] <NEWLINE> if l_head == l_tail : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> w = input ( ) <NEWLINE> W_list = [ w ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> W = input ( ) <NEWLINE> if w [ - 1 ] == W [ 0 ] and W not in W . list : <NEWLINE> <INDENT> W_list . append ( w ) <NEWLINE> w = W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import collections as cl <NEWLINE> import itertools as it <NEWLINE> <COMMENT> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> w = list ( readlines ( ) . split ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> <NL> for i in w : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> dic . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> if i in dic or dic [ i - 1 ] [ - 1 ] != dic [ i ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> dic . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> last_letter = lines [ 1 ] [ 0 ] <NEWLINE> values = list ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> line = lines [ i ] <NEWLINE> if line [ 0 ] != last_letter : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> last_letter = line [ - 1 : ] <NEWLINE> if line in values : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> values . append ( line ) <NEWLINE> <DEDENT> return [ <STRING> ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 4 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> keep = s [ - 1 ] <NEWLINE> s = input ( ) <NEWLINE> if keep != s [ 0 ] : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans ] ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> words = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> words . append ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> if all ( w [ i ] . startswith ( w [ i - 1 ] [ - 1 ] ) for i in range ( 1 , N ) ) and len ( set ( words ) ) == N else <STRING> ) <NEWLINE>
Row = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s_l = set ( List ) <NEWLINE> if len ( List ) != len ( s_l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( Row - 1 ) : <NEWLINE> <INDENT> n = len ( List [ i ] ) - 1 <NEWLINE> if List [ i ] [ n ] != List [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A [ 0 ] - X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A . append ( X ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> anslis = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> anslis [ i ] = A [ i + 1 ] - A [ i ] <NEWLINE> <NL> <DEDENT> g = anslis . pop ( 0 ) <NEWLINE> for c in cost_li : <NEWLINE> <INDENT> g = math . gcd ( g , c ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
from functols import reduce <NEWLINE> from fractions import gcd <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ abs ( X - int ( i ) ) for i in input ( ) . split ( ) ] <NEWLINE> print ( reduce ( gcd , x ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> N , X = map ( int , input ( ) . slpit ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] = abs ( x [ i ] - X ) <NEWLINE> <NL> <DEDENT> x = sorted ( x ) [ : : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt = math . gcd ( cnt , x [ i ] ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import sys <NEWLINE> <COMMENT> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> x_div = [ abs ( X - x [ 0 ] ) ] <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_div . append ( abs ( x [ i ] - x [ i + 1 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> ans = abs ( x [ 0 ] - X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = gcd_list ( x_div ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> def gcdlist ( a ) : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> ans = fractions . gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> if y == 1 : <NEWLINE> <INDENT> print ( abs ( x [ 0 ] - 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l . append ( abs ( x [ i + 1 ] - x [ i ] ) ) <NEWLINE> <DEDENT> print ( gcdlist ( l ) ) <NEWLINE>
def mapt ( fn , * args ) : <NEWLINE> <INDENT> return list ( map ( fn , * args ) ) <NEWLINE> <NL> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , X = Input ( ) <NEWLINE> x = Input ( ) <NEWLINE> <NL> data = [ abs ( X - x [ i ] ) for i in range ( N ) ] <NEWLINE> ans = data [ 0 ] <NEWLINE> for i in range ( 1 , len ( data ) ) : <NEWLINE> <INDENT> ans = gcd ( data [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> N , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( X ) <NEWLINE> x . sort ( ) <NEWLINE> <NL> res = [ abs ( x [ i + 1 ] - x [ i ] ) for i in range ( len ( x ) ) ] <NEWLINE> print ( gcd ( * res ) ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> H , W = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> posOdd = deque ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> while ( i , j ) != H - 1 , W - 1 : <NEWLINE> <INDENT> if i <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> row = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . append ( row ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def move ( src , dst ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> while src [ 0 ] != dst [ 0 ] : <NEWLINE> <INDENT> if src [ 0 ] > dst [ 0 ] : <NEWLINE> <INDENT> di = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> di = 1 <NEWLINE> <DEDENT> ret . append ( ( src [ 0 ] , src [ 1 ] , src [ 0 ] + di , src [ 1 ] ) ) <NEWLINE> src [ 0 ] += di <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> while src [ 1 ] != dst [ 1 ] : <NEWLINE> <INDENT> if src [ 1 ] > dst [ 1 ] : <NEWLINE> <INDENT> dj = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dj = 1 <NEWLINE> <DEDENT> ret . append ( ( src [ 0 ] , src [ 1 ] , src [ 0 ] , src [ 1 ] + dj ) ) <NEWLINE> src [ 1 ] += dj <NEWLINE> <NL> <DEDENT> <DEDENT> moves = [ ] <NEWLINE> while len ( posOdd ) > 1 : <NEWLINE> <INDENT> dst = posOdd . popleft ( ) <NEWLINE> src = posOdd . popleft ( ) <NEWLINE> moves += move ( src , dst ) <NEWLINE> <NL> <DEDENT> print ( len ( moves ) ) <NEWLINE> for m in moves : <NEWLINE> <INDENT> print ( <STRING> . join ( ( str ( i + 1 ) for i in m ) ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a , b in ( list ( combinations ( range ( 1 , n + 1 ) , 2 ) ) ) : <NEWLINE> <INDENT> if ( a % 2 == 0 and b % 2 != 0 ) or ( b % 2 == 0 and a % 2 != 0 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( int ( k * k / 2 / 2 ) ) <NEWLINE> <DEDENT> elif k % 2 == 1 : <NEWLINE> <INDENT> print ( int ( ( k / 2 ) * ( k // 2 ) / 2 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> print ( K // 2 * ( K // 2 + k % 2 ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> ev = K // 2 <NEWLINE> odd = k // 2 + K % 2 <NEWLINE> print ( ev * odd ) <NEWLINE>
a = int ( input ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( a * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a - 1 ) * a ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( a / 2 ) ** 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a / 2 ) * 2 ( int ( int ( a / 2 ) + 1 ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> ans = ( N / 2 ) ** 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( N + 1 ) / 2 * ( N - 1 ) / 2 ) <NEWLINE> <DEDENT> return [ int ( ans ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 9 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 30 ] <NEWLINE> <DEDENT> if pattern == 4 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 625 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( ( n // 2 ) * ( n // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n // 2 ) ** 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( k // 2 ) * ( ( k + 1 ) // 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> ans = ( a / 2 ) ** 2 <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( a - 1 ) / 2 ) * ( ( a + 1 ) / 2 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
Dist = abs ( y1 - y2 ) ** 2 + abs ( x1 - x2 ) ** 2 <NEWLINE> dist = Dist ** 0.5 <NEWLINE> if x2 >= x1 and y2 >= y1 : <NEWLINE> <INDENT> x3 = x2 - abs ( y2 - y1 ) <NEWLINE> x4 = x1 - abs ( y2 - y1 ) <NEWLINE> y3 = y2 + abs ( x2 - x1 ) <NEWLINE> y4 = y1 + abs ( x2 - x1 ) <NEWLINE> <DEDENT> elif x2 < x1 and y2 >= y1 : <NEWLINE> <INDENT> x3 = x2 - abs ( y2 - y1 ) <NEWLINE> x4 = x1 - abs ( y2 - y1 ) <NEWLINE> y3 = y2 - abs ( x2 - x1 ) <NEWLINE> y4 = y1 - abs ( x2 - x1 ) <NEWLINE> <DEDENT> elif x2 < x1 and y1 >= y2 : <NEWLINE> <INDENT> x3 = x2 + abs ( y2 - y1 ) <NEWLINE> x4 = x1 + abs ( y2 - y1 ) <NEWLINE> y3 = y2 - abs ( x2 - x1 ) <NEWLINE> y4 = y1 - abs ( x2 - x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x3 = x2 + abs ( y2 - y1 ) <NEWLINE> x4 = x1 + abs ( y2 - y1 ) <NEWLINE> y3 = y2 + abs ( x2 - x1 ) <NEWLINE> y4 = y1 + abs ( x2 - x1 ) <NEWLINE> <DEDENT> print ( x3 , y3 , x4 , y4 ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> nx = x2 <NEWLINE> ny = y2 <NEWLINE> l = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> dx , dy = - dy , dx <NEWLINE> nx += dx <NEWLINE> ny += dy <NEWLINE> l . append ( nx ) <NEWLINE> l . append ( ny ) <NEWLINE> <DEDENT> print ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> dx = x2 - x1 <NEWLINE> dy = y2 - y1 <NEWLINE> <NL> x3 = x2 - dy <NEWLINE> y3 = y2 + dx <NEWLINE> x4 = x3 - dx <NEWLINE> y4 = y3 - dy <NEWLINE> <NL> print ( x3 , y3 , x4 , y4 <NEWLINE>
n , k = map ( int , input ( ) ) <NEWLINE> candidOdd = 0 <NEWLINE> candidEven = 0 <NEWLINE> candidEven2 = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> candidOdd += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> candidEven += 1 <NEWLINE> <DEDENT> elif i % k == ( k / 2 ) : <NEWLINE> <INDENT> candidEven2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( candidOdd ** 3 + candidEven ** 3 + candidEven2 ** 3 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> return a - b + 1 <NEWLINE>
print ( int ( input ) + 1 - int ( input ( ) ) ) <NEWLINE>
n , i = map ( int , input . split ( ) ) <NEWLINE> print ( n - i + 1 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( int ( a - b + 1 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( a - b + 1 ) ) <NEWLINE>
n , i = map ( int , input ( ) ) <NEWLINE> print ( n - i + 1 ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> grid = [ list ( str ( input ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> def elim ( grid ) : <NEWLINE> <INDENT> grid_after = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> gset = list ( set ( grid [ i ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if gset [ 0 ] != <STRING> : <NEWLINE> <INDENT> grid_after . append ( grid [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return grid_after <NEWLINE> <NL> <DEDENT> def transpose ( grid_after ) : <NEWLINE> <NL> <INDENT> H1 = len ( grid_after ) <NEWLINE> W1 = len ( grid_after [ 0 ] [ : ] ) <NEWLINE> gridT = [ [ <STRING> ] * H1 for _ in range ( W1 ) ] <NEWLINE> for i in range ( W1 ) : <NEWLINE> <INDENT> for j in range ( H1 ) : <NEWLINE> <INDENT> gridT [ i ] [ j ] = grid_after [ j ] [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return gridT <NEWLINE> <NL> <DEDENT> grid_after = elim ( grid ) <NEWLINE> <NL> gridT1 = transpose ( grid_after ) <NEWLINE> <COMMENT> <NL> grid_after2 = elim ( gridT1 ) <NEWLINE> <COMMENT> <NL> gridT2 = transpose ( grid_after2 ) <NEWLINE> <COMMENT> <NL> for i in gridT2 : <NEWLINE> <INDENT> print ( * i , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N , W = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> masus = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = lines [ i + 1 ] <NEWLINE> if line != <STRING> * W : <NEWLINE> <INDENT> masus . append ( line ) <NEWLINE> <DEDENT> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for masu in masus : <NEWLINE> <INDENT> if masu [ w ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for i in range ( len ( masus ) ) : <NEWLINE> <INDENT> masus [ i ] = masus [ i ] [ : w ] + <STRING> + masus [ i ] [ w + 1 : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( masus ) ) : <NEWLINE> <INDENT> masus [ i ] = masus [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> return masus <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 4 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> ll = [ [ True for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> cells = list ( s ) <NEWLINE> <COMMENT> <NL> l . append ( cells ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for h_i in range ( h ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for w_i in range ( w ) : <NEWLINE> <COMMENT> <NL> <INDENT> if l [ h_i ] [ w_i ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for w_i in range ( w ) : <NEWLINE> <INDENT> ll [ h_i ] [ w_i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for w_i in range ( w ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for h_i in range ( h ) : <NEWLINE> <COMMENT> <NL> <INDENT> if l [ h_i ] [ w_i ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for h_i in range ( h ) : <NEWLINE> <INDENT> ll [ h_i ] [ w_i ] = False <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> lll = [ ] a <NEWLINE> for j in range ( w ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ll [ i ] [ j ] : <NEWLINE> <INDENT> lll . append ( l [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( lll ) > 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( lll ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <COMMENT> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> a . append ( x ) <NEWLINE> <NL> <DEDENT> h1 = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if a [ i ] == [ <STRING> ] * w : <NEWLINE> <INDENT> h1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> w1 = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> if a [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> w1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if i not in h1 : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> r . append ( a [ i ] [ j ] ) <NEWLINE> <DEDENT> ans . append ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( lens ( ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans [ i ] ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> mass = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> if <STRING> not in mass [ i ] : <NEWLINE> <INDENT> mass . pop ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = len ( mass ) <NEWLINE> <NL> new_mass = [ [ ] for _ in range ( W ) ] <NEWLINE> <NL> for j in mass : <NEWLINE> <INDENT> for i , k in enumerate ( j ) : <NEWLINE> <INDENT> new_mass [ i ] . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in range ( W ) : <NEWLINE> <INDENT> if <STRING> not in new_mass [ l ] : <NEWLINE> <INDENT> new_mass . pop ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> mass = [ [ ] for _ in range ( H ) ] <NEWLINE> <NL> for n in new_mass : <NEWLINE> <INDENT> for i , m in enumerate ( n ) : <NEWLINE> <INDENT> mass [ i ] . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mass ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> h , w = rm ( ) <NEWLINE> li = np . array ( [ np . array ( rl ( ) ) for _ in range ( h ) ] ) <NEWLINE> li2 = np . array ( [ ] ) <NEWLINE> li3 = np . array ( [ ] ) <NEWLINE> for i in li : <NEWLINE> <INDENT> if <STRING> not in i : <NEWLINE> <INDENT> li2 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> li2 = li2 . T <NEWLINE> for i in li2 : <NEWLINE> <INDENT> if <STRING> not in i : <NEWLINE> <INDENT> li3 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in li3 . T : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from resolve import resolve <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a = l [ i ] <NEWLINE> b = l [ i + k - 1 ] <NEWLINE> <INDENT> ls . append ( min ( abs ( a ) + abs ( a - b ) , abs ( b ) + abs ( a - b ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ls ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> inf = 10 * 8 <NEWLINE> <NL> l = inf <NEWLINE> dp = x [ N - K : N - 1 ] <NEWLINE> i = 0 <NEWLINE> while N - K - i >= 0 : <NEWLINE> <INDENT> if dp [ 0 ] >= 0 : <NEWLINE> <INDENT> tmp = dp [ K - 1 ] <NEWLINE> <DEDENT> elif dp [ K - 1 ] <= 0 : <NEWLINE> <INDENT> tmp = - dp [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dp [ K - 1 ] >= dp [ 0 ] : <NEWLINE> <INDENT> tmp = dp [ 0 ] * 2 + dp [ K - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = dp [ K - 1 ] * 2 + dp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> l = min ( l , tmp ) <NEWLINE> i += 1 <NEWLINE> if N - K - i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . appendleft ( x [ N - K - i ] ) <NEWLINE> dp . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> st = 0 <NEWLINE> m = 3 * 10 ** 8 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if x [ i ] < 0 and x [ i + 1 ] >= 0 : <NEWLINE> <INDENT> st = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - k + 2 ) : <NEWLINE> <INDENT> mi = x [ k + i - 1 ] - x [ i ] + min ( abs ( x [ k + i - 1 ] ) , abs ( x [ i ] ) ) <NEWLINE> print ( x [ k + i - 1 ] , x [ i ] , mi ) <NEWLINE> if k + i < st or i > st : continue <NEWLINE> if mi < m : m = mi <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> x = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> t_min = float ( <STRING> ) <NEWLINE> while i + K <= N : <NEWLINE> <INDENT> left = abs ( x [ i ] ) + abs ( x [ i + K - 1 ] - x [ i ] ) <NEWLINE> right = abs ( x [ i + K - 1 ] ) + abs ( x [ i + K - 1 ] - x [ i ] ) <NEWLINE> if min ( left , right ) < t_min : <NEWLINE> <INDENT> t_min = min ( left , right ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( t_min ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , inptut ( ) . split ( ) ) <NEWLINE> print ( ( a - 1 ) * ( b - 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> <NL> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ans = ( A * B ) - ( A + B - 1 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b = [ int ( i ) for i in input . split ( ) ] <NEWLINE> print ( ( a - 1 ) * ( b - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> AB = np . prod ( np . array ( list ( map ( int , input ( ) ) ) ) ) <NEWLINE> print ( AB ) <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( a * b - ( a + b - 1 ) ) <NEWLINE>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> ans = ( A - 1 ) * ( B - 1 ) <NEWLINE> print ( ans ) <NEWLINE>
print ( ( int ( input ( ) ) - 1 ) * ( int ( input ( ) ) - 1 ) ) <NEWLINE>
<COMMENT> <NL> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ans = ( a - 1 ) * ( b - 1 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( a - 1 ) ( b - 1 ) ) <NEWLINE>
n , m = input ( ) . split ( <STRING> ) <NEWLINE> m = int ( m ) <NEWLINE> n = int ( n ) <NEWLINE> multi = ( m * n ) - ( m + n ) + 1 <NEWLINE> print ( multi ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( str ( a * b - a - b + 1 ) ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> div_list = [ ] <NEWLINE> for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i % j != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i // j == j : <NEWLINE> <INDENT> div_list . append ( j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> div_list . append ( i // j ) <NEWLINE> div_list . append ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( div_list ) == 8 : <NEWLINE> <INDENT> ans = += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 9 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def yakusu ( x ) : <NEWLINE> <INDENT> A = [ ] <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> A . append ( ) <NEWLINE> <DEDENT> <DEDENT> return ( len ( A ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> print ( yakusu ( n ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a < 105 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 105 <= a < 135 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif 135 <= a < 165 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 165 <= a < 189 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif : 189 <= a : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> odd = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> odd . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N < 104 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif N = 105 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 106 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in odd : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> tmp = + 1 <NEWLINE> <DEDENT> <DEDENT> if tmp == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % j = 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans = 8 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
in_num = int ( input ( ) ) <NEWLINE> check_num = 0 <NEWLINE> ans_counter = 0 <NEWLINE> <NL> while check_num <= in_num : <NEWLINE> <INDENT> i = 1 <NEWLINE> div_counter = 0 <NEWLINE> while i < check_num / 2 : <NEWLINE> <INDENT> if check_num % i == 0 : <NEWLINE> <INDENT> div_counter += 1 <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> if div_counter == 8 : <NEWLINE> <INDENT> ans_counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans_counter ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i != n // i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) and ( make_divisors ( i ) == 8 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> tmp = make_divisors ( i ) <NEWLINE> if len ( tmp ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
https : // atcoder . jp / contests / abc106 / scoreN = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from sys import stdinans = 0 <NEWLINE> c = 0 <NEWLINE> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> i += 1 <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> if i % j == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> li = [ 3 , 5 , 7 , 11 , 13 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if i % li [ j ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if n >= 135 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if n >= 189 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( 1 , 1 + N , 2 ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for j in range ( 1 , 1 + i , 2 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> if n == 8 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for num in range ( 1 , n ) : <NEWLINE> <INDENT> if num % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ls = [ ] <NEWLINE> for i in range ( num + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> ls . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( ls ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> k += 1 <NEWLINE> <DEDENT> if k == 8 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> if n < 105 : print ( 0 ) <NEWLINE> elif n < 135 : print ( 1 ) <NEWLINE> elif n < 165 : print ( 2 ) <NEWLINE> elif n < 195 : print ( 3 ) <NEWLINE> else print ( 4 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def solve ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if solve ( i ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 105 , 135 , 165 , 189 , 195 ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if N < l [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( 5 ) <NEWLINE>
number = int ( input ( ) ) <NEWLINE> <NL> num_eight_divisors = 0 <NEWLINE> <NL> numbers = list ( range ( 9 , number + 1 , 2 ) ) <NEWLINE> <NL> for i in range ( 9 , number + 1 , 2 ) : <NEWLINE> <INDENT> divisors = [ 1 , i ] <NEWLINE> <NL> for j in range ( 2 , i ) : <NEWLINE> <INDENT> q , mod = divmod ( i , j ) <NEWLINE> <NL> if mod == 0 : <NEWLINE> <INDENT> divisors . append ( j , q ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( set ( divisors ) ) : <NEWLINE> <INDENT> num_eight_divisors = num_eight_divisors + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num_eight_divisors ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if res == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) ; <NEWLINE> K = input ( ) ; <NEWLINE> i = 0 ; <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if int ( S [ i ] ) > 1 : <NEWLINE> <INDENT> print ( S [ i ] ) ; <NEWLINE> break ; <NEWLINE> <DEDENT> elif i + 1 >= K : <NEWLINE> <INDENT> print ( 1 ) ; <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> k = input ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if k [ i ] != <STRING> : <NEWLINE> <INDENT> ans = k [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ind = - 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == 1 <NEWLINE> <INDENT> ind = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ind == - 1 : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT> elif ind + 1 >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ ind + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if <NEWLINE> for i in s : <NEWLINE> <INDENT> if i != <STRING> : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE>
s = list ( map ( int , tuple ( input ( ) ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> if 1 in s : <NEWLINE> <INDENT> i = s . index ( ) <NEWLINE> if i + 1 >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += int ( i ) ** ( ( 5 * 10 ** 16 ) - 1 ) <NEWLINE> <DEDENT> if k <= c : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( int ( s [ i ] ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
A = str ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B <= count : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i >= len ( N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N [ i ] != <STRING> : <NEWLINE> <INDENT> ans = N [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> while S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ count ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> pq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> cnt = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> cnt [ l ] [ r ] += 1 <NEWLINE> <NL> <DEDENT> acc = cnt . deepcopy ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> tmp = acc [ i ] [ j + 1 ] + acc [ i + 1 ] [ j ] - acc [ i ] [ j ] <NEWLINE> acc [ i + 1 ] [ j + 1 ] += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> p -= 1 <NEWLINE> ans = acc [ q ] [ q ] - acc [ p ] [ q ] - acc [ q ] [ p ] + acc [ p ] [ p ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
if snacks_num % persons == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
def mapt ( fn , * args ) : <NEWLINE> <INDENT> return list ( map ( fn , * args ) ) <NEWLINE> <NL> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = Input ( ) <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_n = math . ceil ( k / n ) <NEWLINE> min_n = math . floor ( k / n ) <NEWLINE> print ( max_n - min_n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % K == : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) ) <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( abs ( ( x // y + x % y ) - ( x // y ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> i <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % k = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
if int ( input ( ) ) % 3 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
buy = [ false ] * 1000 <NEWLINE> buy [ 0 ] = true <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if buy [ i ] : <NEWLINE> <INDENT> buy [ i + 4 ] = true <NEWLINE> buy [ i + 7 ] = true <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> if buy [ n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> if any ( ( n - i * 7 ) % 4 == 0 for i in range ( n // 7 + 1 ) else <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for i range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> if 4 * i + 7 * j == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> for j in range ( 15 ) : <NEWLINE> <INDENT> if 4 * i + 7 * j = n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * ( N + K ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i + k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + k ] = min ( dp [ i + k ] , dp [ i ] + abs ( h [ i ] - h [ i + k ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 15 ) : <NEWLINE> <INDENT> N = N - 7 <NEWLINE> print ( N ) <NEWLINE> if N <= 0 : <NEWLINE> <INDENT> if N % 3 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 4 == 0 or n % 7 == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ( n % 7 ) % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> ans = <STRING> <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> r = N % 2 <NEWLINE> N = ( N - r ) / - 2 <NEWLINE> ans = str ( int ( r ) ) + ans <NEWLINE> if N == 0 or N == 1 : <NEWLINE> <INDENT> ans = str ( int ( N ) ) + ans <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * 40 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif n > 0 : <NEWLINE> <INDENT> x = bin ( n ) <NEWLINE> bx = x [ 2 : ] <NEWLINE> lx = len ( bx ) <NEWLINE> for i in range ( lx - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = int ( bx [ lx - 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if i % 2 == 1 and dp [ i ] == 1 : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> while max ( dp ) > 1 : <NEWLINE> <INDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if dp [ i ] >= 2 : <NEWLINE> <INDENT> dp [ i ] -= 2 <NEWLINE> if dp [ i + 1 ] > 0 : <NEWLINE> <INDENT> dp [ i + 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> dp [ i + 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dpr = list ( reversed ( dp ) ) <NEWLINE> dprs = list ( map ( lambda x : str ( x ) , dpr ) ) <NEWLINE> dprj = <STRING> . join ( dprs ) <NEWLINE> print ( int ( dprj ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = bin ( n ) <NEWLINE> bx = x [ 2 : ] <NEWLINE> lx = len ( bx ) <NEWLINE> for i in range ( lx - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = int ( bx [ lx - 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if i % 2 == 1 and dp [ i ] == 1 : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> while max ( dp ) > 1 : <NEWLINE> <INDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if dp [ i ] >= 2 : <NEWLINE> <INDENT> dp [ i ] -= 2 <NEWLINE> if dp [ i + 1 ] > 0 : <NEWLINE> <INDENT> dp [ i + 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> dp [ i + 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dpr = list ( reversed ( dp ) ) <NEWLINE> dprs = list ( map ( lambda x : str ( x ) , dpr ) ) <NEWLINE> dprj = <STRING> . join ( dprs ) <NEWLINE> print ( int ( dprj ) ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , log2 <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> lim = 30 <NEWLINE> top = [ 0 ] * ( lim + 1 ) <NEWLINE> bottom = [ 0 ] * ( lim + 1 ) <NEWLINE> <NL> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> t = ( i + 1 ) // 2 <NEWLINE> top [ i ] = ( 4 ** t - 1 ) // 3 <NEWLINE> bottom [ i ] = bottom [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = i // 2 <NEWLINE> bottom [ i ] = ( 4 ** b - 1 ) * 2 // 3 <NEWLINE> top [ i ] = top [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> digit = [ 0 ] * ( lim + 1 ) <NEWLINE> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> digit [ i ] = ( - 2 ) ** ( i - 1 ) <NEWLINE> <NL> <DEDENT> if 0 <= N : <NEWLINE> <INDENT> idx = bisect_left ( top , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect_left ( bottom , - N ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( idx , 0 , - 1 ) : <NEWLINE> <INDENT> if - bottom [ i - 1 ] <= N <= top [ i - 1 ] : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> N -= digit [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> a = <STRING> <NEWLINE> if N == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> while N != 0 : <NEWLINE> <INDENT> if N % 2 != 0 : <NEWLINE> <INDENT> a = <STRING> + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> + a <NEWLINE> <DEDENT> N = - ( N // 2 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = <STRING> <NEWLINE> while n != 0 : <NEWLINE> <INDENT> x = str ( n % 2 ) + x <NEWLINE> n = - ( n // 2 ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
r = input ( ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1200 < r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r = int ( intput ( ) ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> rint ( [ <STRING> , <STRING> , <STRING> ] [ ( a >= 1200 ) + ( a >= 2800 ) ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
r = input ( ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 2799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
R = input ( ) <NEWLINE> print ( R ) <NEWLINE> <NL> if R < 1200 : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT> elif 1200 <= R and R < 2800 : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( AGC ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> r = I ( ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rating = int ( input ( ) ) <NEWLINE> switch ( rating ) : <NEWLINE> <INDENT> case rating > 0 and rating < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> case rating > 1200 and rating < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> case rating > 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> default : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if 2800 <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if R < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif R < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rint ( <STRING> , ord ( <STRING> ) ) <NEWLINE> print ( <STRING> , ord ( <STRING> ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 1 <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> if not ( 97 <= ord ( s [ 1 ] ) <= 122 ) : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> if not ( 97 <= ord ( s [ - 1 ] ) <= 122 ) : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <NL> <DEDENT> check = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> check += 1 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans & ( check == 1 ) ] ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> if s [ 0 ] == <STRING> and a [ 2 : - 2 ] . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> tmp = s [ 1 : ] <NEWLINE> tmp . replace ( <STRING> , <STRING> ) <NEWLINE> ans = <STRING> if tmp . islower ( ) else <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if s [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> if s [ 1 : ] . isLower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> flg = <STRING> <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if <STRING> in s [ 2 : len ( s ) - 1 ] : <NEWLINE> <INDENT> s . remove ( <STRING> ) <NEWLINE> s . remove ( <STRING> ) <NEWLINE> s = * s <NEWLINE> if s . islower ( ) == True : <NEWLINE> <INDENT> flg = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( flg ) <NEWLINE>
S = input ( ) <NEWLINE> flag = True <NEWLINE> count = 0 <NEWLINE> if not S [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> for i in range ( 2 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not S [ len ( S ) ] . islower ( ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not S [ len ( S ) ] . islower ( ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if not count == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def isAC ( S ) : <NEWLINE> <INDENT> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if S [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> S = S . remove ( <STRING> ) <NEWLINE> if not all ( <STRING> <= x <= <STRING> for x in S ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> print ( <STRING> if isAC ( input ( ) ) else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> sl = [ ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> sl . append ( i ) <NEWLINE> <DEDENT> if sl [ 0 ] != <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if sl [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> if sl [ 1 : ] . replace ( <STRING> , <STRING> , 1 ) . islower ( ) == False : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> C_cnt , low , upp = 0 , 0 , 0 <NEWLINE> if S [ 0 ] != <STRING> or S [ - 1 ] . isupper ( ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> C_cnt += 1 <NEWLINE> <DEDENT> elif S [ i ] . islower ( ) : <NEWLINE> <INDENT> low += 1 <NEWLINE> <DEDENT> elif S [ i ] . isupper ( ) : <NEWLINE> <INDENT> upp += 1 <NEWLINE> <DEDENT> <DEDENT> if C_cnt = 1 and low = len ( S ) - 3 and upp = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> l = [ chr ( i ) for i in range ( 65 , 65 + 26 ) ] <NEWLINE> <NL> flag = True <NEWLINE> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif S [ 1 ] in l : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif S [ len ( S ) ] in l : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif not <STRING> in S [ 2 : len ( S ) - 2 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 2 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] in l : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count > 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if count < 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif s [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> s = sorted ( s ) <NEWLINE> if s [ 2 : ] . islower ( ) == False : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> s = s ( ) <NEWLINE> <NL> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> f1 = True <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 2 , len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt1 == 1 : <NEWLINE> <INDENT> f2 = True <NEWLINE> <DEDENT> cnt2 = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] . islower ( ) : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt2 >= len ( s ) - 2 : <NEWLINE> <INDENT> f3 = True <NEWLINE> <NL> <DEDENT> if f1 and f2 and f3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prinet ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> and <STRING> in s [ 2 : - 1 ] and len ( re . findall ( <STRING> , s ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> al = list ( <STRING> ) <NEWLINE> if s [ 0 ] == <STRING> and s [ - 1 ] in al and s [ 1 ] in al : <NEWLINE> <INDENT> del s [ 0 ] <NEWLINE> del s [ 0 ] <NEWLINE> del s [ - 1 ] <NEWLINE> f = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i in al : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> count = 0 <NEWLINE> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> S . lower ( 0 ) <NEWLINE> for i in range ( 3 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> S . lower ( i ) <NEWLINE> <DEDENT> <DEDENT> if count == 1 & & S . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> and s [ 2 : - 1 ] . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if s . isupper ( ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> a = - 1 <NEWLINE> c = - 1 <NEWLINE> lower = 0 <NEWLINE> for i in range ( len ( s ) ) <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c = i <NEWLINE> <DEDENT> if <STRING> <= s [ i ] <= <STRING> : <NEWLINE> <INDENT> lower += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a == 0 and 2 <= c <= len ( s ) - 2 and lower == len ( s ) - 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> res = 0 <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s . find ( <STRING> ) >= 2 and s . find ( <STRING> ) < n - 2 : <NEWLINE> <INDENT> s . lower ( 0 ) <NEWLINE> s . lower ( s . find ( <STRING> ) ) <NEWLINE> if s == s . lower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> d += p [ i ] [ 0 ] <NEWLINE> <DEDENT> dp = [ [ 0 ] * ( d + 1 ) for i in range ( D ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> for j in range ( p [ i ] [ 0 ] + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if j == p [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] += p [ i ] [ 1 ] <NEWLINE> <DEDENT> dp [ i ] [ j ] += 100 * j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if j == p [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ k + j ] = max ( dp [ i ] [ k + j ] , dp [ i - 1 ] [ k ] + 100 * j * ( i + 1 ) + p [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ k + j ] = max ( dp [ i ] [ k + j ] , dp [ i - 1 ] [ k ] + 100 * j * ( i + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> c += p [ i ] [ 0 ] <NEWLINE> <DEDENT> for i in range ( d + 1 ) : <NEWLINE> <INDENT> if dp [ D - 1 ] [ i ] >= G : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> D , G = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
rom math import ceil <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> sum = 0 <NEWLINE> remain = set ( range ( 1 , D + 1 ) ) <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> cnt += pc [ i ] [ 0 ] <NEWLINE> sum += pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] <NEWLINE> remain . discard ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sum < G : <NEWLINE> <INDENT> use = max ( remain ) <NEWLINE> n = min ( pc [ use - 1 ] [ 0 ] , ceil ( ( G - sum ) / ( use * 100 ) ) ) <NEWLINE> <STRING> <NEWLINE> cnt += n <NEWLINE> sum += n * use * 100 <NEWLINE> <NL> <DEDENT> if sum >= G : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
P = [ ] <NEWLINE> C = [ ] <NEWLINE> point = 1001 <COMMENT> <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> for i in range ( 2 ** D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> solve = 0 <NEWLINE> needproblem = 0 <NEWLINE> for j in range ( D ) : <COMMENT> <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> score += P [ j ] * 100 * ( j + 1 ) + C [ j ] <NEWLINE> solve += P [ j ] <NEWLINE> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> point = min ( point , solve ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif score < G : <NEWLINE> <INDENT> rest = G - score <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if ( ~ i >> D - j ) & 1 : <NEWLINE> <INDENT> needproblem = D - j + 1 <NEWLINE> <DEDENT> sum = needproblem * 100 * ( P [ needproblem - 1 ] - 1 ) <NEWLINE> if rest > sum : <COMMENT> <NEWLINE> <INDENT> rest -= sum <NEWLINE> solve += P [ needproblem - 1 ] - 1 <NEWLINE> <DEDENT> elif rest <= sum : <NEWLINE> <INDENT> resolve = solve + rest // ( needproblem * 100 ) <NEWLINE> point = min ( point , resolve ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
<NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> for i in range ( 2 ** D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> solve = 0 <NEWLINE> needproblem = 0 <NEWLINE> for j in range ( D ) : <COMMENT> <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> score += P [ j ] * 100 * ( j + 1 ) + C [ j ] <NEWLINE> solve += P [ j ] <NEWLINE> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> if D * 100 > solve : <NEWLINE> <INDENT> point = min ( point , solve ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> rest = G - score <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 0 : <NEWLINE> <INDENT> needproblem = j + 1 <NEWLINE> sum = needproblem * 100 * ( P [ needproblem - 1 ] - 1 ) <NEWLINE> if rest > sum : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif rest <= sum : <NEWLINE> <INDENT> resolve = solve + rest // ( needproblem * 100 ) <NEWLINE> point = min ( point , resolve ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 << d ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> sum = 0 <NEWLINE> nokori = set ( range ( 1 , d + 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> for j in range ( d ) : <NEWLINE> <INDENT> if j & 1 << i : <NEWLINE> <INDENT> sum += pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] <NEWLINE> count += pc [ i ] [ 0 ] <NEWLINE> nokori . discard ( i + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if sum < g : <NEWLINE> <INDENT> use = max ( nokori ) <NEWLINE> n = min ( pc [ use - 1 ] [ 0 ] , ( g - sum ) // ( use * 100 ) ) <NEWLINE> count += n <NEWLINE> sum += n * use * 100 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if sum >= g : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> PC = [ 0 ] + [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> def dfs ( d , g ) : <NEWLINE> <INDENT> if ( d == 0 ) : <NEWLINE> <INDENT> return 1e9 <NEWLINE> <NL> <DEDENT> c = min ( g // ( 100 * d ) , PC [ d ] [ 0 ] ) <NEWLINE> s = 100 * d * c <NEWLINE> if c == PC [ d ] [ 0 ] : <NEWLINE> <INDENT> s += PC [ d ] [ 1 ] <NEWLINE> <DEDENT> if s < g : <NEWLINE> <INDENT> c += f ( d - 1 , g - s ) <NEWLINE> <DEDENT> return min ( c , f ( d - 1 , g ) ) <NEWLINE> <NL> <DEDENT> print ( dfs ( D , G ) ) <NEWLINE>
def dfs ( i , sum , count , unsolve ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == D : <NEWLINE> <COMMENT> <NL> <INDENT> if sum < G : <NEWLINE> <INDENT> use = max ( unsolve ) <NEWLINE> <COMMENT> <NL> N = min ( pc [ use - 1 ] [ 0 ] , - ( - ( g - sum ) // ( 100 * use ) ) ) <NEWLINE> count += N <NEWLINE> sum += N * 100 * use <NEWLINE> <DEDENT> if sum > G : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> dfs ( i + 1 , sum , count , unsolve ) <NEWLINE> <INDENT> dfs ( i + 1 , sum + pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] , count + pc [ i ] [ 0 ] , unsolve - { i + 1 } ) <NEWLINE> <NL> <DEDENT> <DEDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> dfs ( 0 , 0 , 0 , set ( range ( 1 , d + 1 ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> D , G = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> P . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> minp = float ( <STRING> ) <NEWLINE> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> num_p = 0 <NEWLINE> bset = set ( ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> mask = 1 << i <NEWLINE> if bit & mask : <NEWLINE> <INDENT> total += P [ i ] [ 1 ] + 100 * ( i + 1 ) * P [ i ] [ 0 ] <NEWLINE> num_p += P [ i ] [ 0 ] <NEWLINE> bset . add ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> res = G - total <NEWLINE> if res <= 0 : <NEWLINE> <INDENT> if num_p < minp : <NEWLINE> <INDENT> minp = num_p <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> for i in reversed ( sorted ( set ( [ i for i in range ( D ) ] ) - bset ) ) : <NEWLINE> <INDENT> maxv = 100 * ( i + 1 ) * ( P [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> if res <= maxv : <NEWLINE> <INDENT> num_take = max ( min ( bisect . bisect ( list ( range ( 0 , maxv + 100 * ( i + 1 ) , 100 * ( i + 1 ) ) ) , res ) - 1 , P [ i ] [ 0 ] - 1 ) , 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> num_p += num_take <NEWLINE> res -= 100 * ( i + 1 ) * num_take <NEWLINE> if num_p < minp : <NEWLINE> <INDENT> minp = num_p <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> res -= maxv <NEWLINE> <COMMENT> <NL> num_p += ( P [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minp ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A ) - min ( A ) ) <NEWLINE>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( X ) - min ( X ) ) <NEWLINE>
li = a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = sorted ( li ) <NEWLINE> print ( lis [ 2 ] - lis [ 0 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( abs ( a - b ) + abs ( b - c ) , abs ( b - a ) + abs ( a - c ) , abs ( a - c ) + abs ( c - b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l = sorted ( [ a , b , c ] ) <NEWLINE> print ( l [ 2 ] - l [ 1 ] + l [ 1 ] - l [ 0 ] ) <NEWLINE>
N_List = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( N_List [ 1 : ] - N_List [ : - 1 ] ) ) <NEWLINE>
a , b , c = sorted ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a + c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sorted <NEWLINE> print ( b [ 1 ] - b [ 0 ] + b [ 2 ] - b [ 1 ] ) <NEWLINE>
list = input ( ) <NEWLINE> list_n = [ int ( s ) for s in list ] <NEWLINE> print ( int ( max ( list_n ) ) - int ( min ( list_n ) ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> deque_s = deque ( list ( input ( ) ) ) <NEWLINE> kyoto <NEWLINE> deque_t = deque ( list ( input ( ) ) ) <NEWLINE> tokyo <NEWLINE> <NL> for _i in range ( len ( deque_s ) ) : <NEWLINE> <INDENT> deque_s . rotate ( ) <NEWLINE> if deque_s == deque_t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if S == T [ i : ] + T [ : i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ans = <STRING> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ : i ] + S [ 0 : i ] == T : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if s in T * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> task_list = sorted ( l ) <NEWLINE> <NL> print ( task_list [ 2 ] - task_list [ 0 ] ) <NEWLINE>
import sys <NEWLINE> S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> tmp = S [ - 1 ] <NEWLINE> S [ - 1 ] = <STRING> <NEWLINE> S . insert ( 0 , tmp ) <NEWLINE> if S == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s , t = [ input ( ) for i in range ( 2 ) ] <NEWLINE> for _ in range ( len ( s ) ) : <NEWLINE> <INDENT> s = s [ 1 : ] + s [ 0 ] <NEWLINE> if s = t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> x = len ( s ) <NEWLINE> <NL> ch1 = 0 <NEWLINE> ch = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if s [ i ] = t [ x - 1 - i ] : <NEWLINE> <INDENT> ch += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( x ) : <NEWLINE> <INDENT> if s [ j ] = t [ j ] : <NEWLINE> <INDENT> ch1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if ch == x or ch1 == x else print ( <STRING> ) <NEWLINE>
i = input ; i ( ) ; print ( sum ( [ x - 1 for x in i ( ) . split ( ) ] ) ) <NEWLINE>
N = int ( input ) <NEWLINE> print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) - N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( l ) = n ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ab = [ 0 ] * M <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ i - 1 ] ) <NEWLINE> for j in ab [ i ] : <NEWLINE> <INDENT> dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n = k ( ) <NEWLINE> a = l ( ) <NEWLINE> <NL> i = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from numpy import random <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> a [ i + 1 ] = random . randint ( 10000 ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
5 <NEWLINE> 1 1 1 1 1 n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = 0 <NEWLINE> c = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ i ] == a : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( b ) <NEWLINE> b = 0 <NEWLINE> <DEDENT> a = l [ i ] <NEWLINE> <DEDENT> c . append ( b ) <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> c [ i ] = ( c [ i ] + 1 ) // 2 <NEWLINE> <DEDENT> print ( sum ( c ) ) <NEWLINE>
from numpy . random import randint <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if l [ i ] == l [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l [ i + 1 ] = randint ( 0 , 10000 ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S_l = S [ : N ] <NEWLINE> S_r = S [ N : ] [ : : - 1 ] <NEWLINE> dict_l = { } <NEWLINE> dict_r = { } <NEWLINE> ans = 0 <NEWLINE> for num in range ( 2 ** N ) : <NEWLINE> <INDENT> tmpl_1 = <STRING> <NEWLINE> tmpl_2 = <STRING> <NEWLINE> tmpr_1 = <STRING> <NEWLINE> tmpr_2 = <STRING> <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if ( num >> ( N - 1 - n ) & 1 ) : <NEWLINE> <INDENT> tmpl_1 += S_l [ n ] <NEWLINE> tmpr_1 += S_r [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmpl_2 += S_l [ n ] <NEWLINE> tmpr_2 += S_r [ n ] <NEWLINE> <DEDENT> <DEDENT> dict_l [ [ tmpl_1 , tmpl_2 ] ] = dict_l . get ( [ tmpl_1 , tmpl_2 ] , 0 ) + 1 <NEWLINE> dict_r [ [ tmpr_1 , tmpr_2 ] ] = dict_r . get ( [ tmpr_1 , tmpr_2 ] , 0 ) + 1 <NEWLINE> <DEDENT> for k , v in dict_l . items ( ) : <NEWLINE> <INDENT> ans += v * dict_r . get ( k , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b = 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b = 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> if a + b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , intput ( ) . split ( ) ) <NEWLINE> if a + b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( print ( <STRING> ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( i + 1 ) % w == 1 : <NEWLINE> <INDENT> print ( S [ i ] ) , <NEWLINE> <DEDENT> <DEDENT>
n , m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 1 / n if d == 0 else p = 2 * ( n - d ) / n / n <NEWLINE> ans = ( m - 1 ) * p <NEWLINE> print ( ans ) <NEWLINE>
n , m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( ( m - 1 ) / double ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * ( m - 1 ) * ( n - d ) / double ( n * n ) ) <NEWLINE> <DEDENT>
from networkx import * <NEWLINE> ( N , M , * S ) , * t = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> G = Graph ( ) <NEWLINE> for * u , a , b in t : G . add_edge ( * u , y = a , s = b ) <NEWLINE> b = m = 10 ** 15 <NEWLINE> y , s , * r = map ( eval ( dir ( ) [ 761 ] ) , ( G , G ) , S , ( m , m ) , <STRING> ) <NEWLINE> while N : b = min ( b , y [ N ] + s [ N ] ) ; r += m - b , ; N -= 1 <NEWLINE> print ( * r [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( N * 2 ) <NEWLINE> <DEDENT>
<NL> N = input ( ) <NEWLINE> <NL> i = N + 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i % 2 == 0 and i % N == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def n_lcm ( * numbers ) : <NEWLINE> <INDENT> print ( reduce ( lcm_base , numbers , 1 ) ) <NEWLINE> <NL> <DEDENT> n_lcm ( 2 , int ( input ( ) ) ) <NEWLINE>
n = int ( input ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n if n % 2 == 0 else 2 n ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( 2 * N // gcd ( 2 , N ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> i = n <NEWLINE> while True : <NEWLINE> <INDENT> if i % 2 == 0 and i % n == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = max ( n , 2 ) + 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if m % 2 and m % n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> m += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) . split ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % != 0 : <NEWLINE> <INDENT> print ( 2 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> min_A = 10 ** 9 + 7 <NEWLINE> max_A = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> max_A = max ( tmp , max_A ) <NEWLINE> min_A = min ( min_A , tmp ) <NEWLINE> <NL> <DEDENT> print ( abs ( max_A - min_A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = a [ - 1 ] - a [ 0 ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> print ( max ( A ) - min ( A ) ) <NEWLINE>
num_len = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( numbers ) - min ( numbers ) <NEWLINE>
_n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int ( ) , input ( ) . split ( ) ) ) <NEWLINE> lists . sort ( ) <NEWLINE> <NL> print ( lists [ - 1 ] - lists [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list . sort ( ) <NEWLINE> <NL> answer = list [ - 1 ] - list [ 0 ] <NEWLINE> <NL> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = max ( a ) - min ( b ) <NEWLINE> print ( b ) <NEWLINE>
N = int ( input ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ - 1 ] - A [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( max ( A ) - min ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> <NL> Amax = max ( A ) <NEWLINE> Amin = min ( A ) <NEWLINE> <NL> ans = Amax - Amin <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ N ] - A [ 0 ] ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( abs ( A [ 0 ] - A [ - 1 ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mid = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j range ( i + 1 , N ) : <NEWLINE> <INDENT> mid = abs ( List [ i ] - List [ j ] ) <NEWLINE> res = max ( res , mid ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lists . sorted ( ) <NEWLINE> print ( lists [ - 1 ] - lists [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( max ( N ) - min ( N ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( ls ) - min ( ls ) ) <NEWLINE>
n , aaa = map ( int , open ( 0 ) . split ( ) ) <NEWLINE> print ( max ( aaa ) - min ( aaa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a ) - min ( a ) ) <NEWLINE>
count = input ( ) <NEWLINE> list = int ( input ( ) ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> list_1 = [ int ( s ) for s in list ] <NEWLINE> list2 = sorted ( list_1 ) <NEWLINE> sa = ( int ( list2 [ 0 ] ) - int ( list2 [ int ( count ) - 1 ] ) ) <NEWLINE> if sa < 0 : <NEWLINE> <INDENT> print ( - 1 * int ( sa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( sa ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> B = np . arange ( 1 , N + 1 ) <NEWLINE> <NL> C = A - B <NEWLINE> mean = int ( np . mean ( C ) ) <NEWLINE> <NL> print ( min ( np . sum ( np . abs ( C - mean ) ) ) , np . sum ( np . abs ( C + mean ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> blist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> blist . append ( alist [ i ] - i - 1 ) <NEWLINE> <DEDENT> blist . sort ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += abs ( blist [ i ] - blist [ ( i + 1 ) // 2 ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> num = ( blist [ i // 2 ] + blist [ i // 2 + 1 ] ) // 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += abs ( blist [ i ] - num <NEWLINE> <DEDENT> print ( cnt , cnt2 ) <NEWLINE> <DEDENT>
from statistics import median <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> an [ i ] = an [ i ] - ( i + 1 ) <NEWLINE> <NL> <DEDENT> b = int ( median ( bn ) ) <NEWLINE> <NL> k = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> y = abs ( an [ i ] - b ) <NEWLINE> k . append ( y ) <NEWLINE> <DEDENT> ans = sum ( k ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
li = sorted ( [ a [ i ] - ( i + 1 ) for i in range ( n ) ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> ave = ( li [ n // 2 ] + li [ n // 2 - 1 ] ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ave = li [ ( n - 1 ) // 2 ] <NEWLINE> <NL> <DEDENT> import math <NEWLINE> ave1 = math . floor ( ave ) <NEWLINE> ave2 = math . ceil ( ave ) <NEWLINE> <NL> ll = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += abs ( a [ i ] - ( ave1 + i + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll += [ c ] <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += abs ( a [ i ] - ( ave2 + i + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll += [ c ] <NEWLINE> <NL> <DEDENT> print ( min ( ll ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( A [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> a = N / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( N + 1 ) / 2 <NEWLINE> <DEDENT> b = B [ a - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ N - 1 ] = abs ( B [ N - 1 ] - b ) <NEWLINE> <DEDENT> print ( B ) <NEWLINE> <NL> <NL>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> arr = np . arange ( n ) + 1 <NEWLINE> diff = a - arr <NEWLINE> <NL> diff . sort ( ) <NEWLINE> <NL> diff -= np . median ( diff ) <NEWLINE> <NL> print ( int ( np . abs ( diff ) . sum ( ) ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = rr ( ) <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += 1 if i == <STRING> else ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
a = input <NEWLINE> print ( a . count ( <STRING> ) - a . count ( <STRING> ) ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == - : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for in range s : <NEWLINE> <INDENT> if <STRING> Then : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> Steam = 0 <NEWLINE> minecraft = 0 <NEWLINE> for i in range ( ) len ( S ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> minecraft += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Steam += 1 <NEWLINE> <DEDENT> <DEDENT> L = minecraft * 1 <NEWLINE> P = Steam * - 1 <NEWLINE> print ( L + P ) <NEWLINE>
s = list ( map ( str , input ( ) ) ) <NEWLINE> a = s . count ( + ) <NEWLINE> b = s . count ( - ) <NEWLINE> print ( a - b ) <NEWLINE>
s = input ( ) <NEWLINE> con = [ 0 ] * 2 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c [ 0 ] - c [ 1 ] ) <NEWLINE>
S = map ( str , input ( ) . split ( ) ) <NEWLINE> s = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i in <STRING> : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . cout ( <STRING> ) - S . count ( <STRING> ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( str ( N ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> S += s [ i ] <NEWLINE> <NL> <DEDENT> if N % S == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( str ( n ) ) <NEWLINE> a = n % ( sum ( s ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def s ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> x += int ( n [ i ] ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> print ( <STRING> ) if n % s ( n ) == 0 else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> m = 0 <NEWLINE> for c in range ( s ) : <NEWLINE> <INDENT> m += int ( c ) <NEWLINE> <DEDENT> print ( <STRING> if n % m == 0 else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> b = int ( a ) <NEWLINE> c = list ( a ) <NEWLINE> if b % ( sum ( c ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> num = int ( N ) <NEWLINE> Nls = list ( N ) <NEWLINE> sum1 = sum ( [ int ( i ) for in Nls ] ) <NEWLINE> if num % sum1 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> s = sum ( [ int ( n [ i ] ) for i in range ( len ( n ) ) ] ) <NEWLINE> if n % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = n <NEWLINE> m = 0 <NEWLINE> while i > 0 <NEWLINE> <INDENT> m += i % 10 <NEWLINE> i = i // 10 <NEWLINE> <NL> <DEDENT> if n % m != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def check ( p ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while p > 0 : <NEWLINE> <INDENT> c += p % 10 <NEWLINE> p //= 10 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> if n % check ( p ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> m = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> m += i <NEWLINE> <DEDENT> if n % m == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nlist = list ( map ( int , input ( ) ) ) <NEWLINE> rev_n = reversed ( nlist ) <NEWLINE> sn = sum ( nlist ) <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( len ( nlist ) ) : <NEWLINE> <INDENT> n += rev_n [ i ] * ( 10 ** i ) <NEWLINE> <DEDENT> if n % sn == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N2 = N <NEWLINE> sum = 0 <NEWLINE> while True : <NEWLINE> <INDENT> sum += N % 10 <NEWLINE> N = N // 10 <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if N2 % sum == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> <NL> <DEDENT> if N % ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> s += n [ i ] <NEWLINE> <DEDENT> if int ( n ) % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( len ( str ( N ) ) ) : <NEWLINE> <INDENT> S += int ( str ( S ) [ i ] ) <NEWLINE> <NL> <DEDENT> if N % S == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> j += num // 10 ^ i <NEWLINE> <DEDENT> print ( num % j == 0 ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> cnt += n [ i ] <NEWLINE> <DEDENT> if int ( n ) % cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> [ sum ( map ( int , S ) ) % int ( s ) == 0 : : 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = list ( str ( N ) ) <NEWLINE> print ( <STRING> if N % ( sum ( n ) == 0 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = sum ( map ( int , list ( str ( n ) ) ) <NEWLINE> <NL> if n % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = sum ( list ( map ( int , list ( str ( a ) ) ) ) ) <NEWLINE> ans = a / b <NEWLINE> print ( <STRING> if ans == o else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = N <NEWLINE> flag = True <NEWLINE> S = 0 <NEWLINE> a = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> a = n % 10 <NEWLINE> S += a <NEWLINE> n = n - a // 10 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if N % S == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> k = list ( map ( int , list ( n ) ) ) <NEWLINE> s = sum ( n ) <NEWLINE> n = int ( n ) <NEWLINE> if n % k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> Sn = sum ( list ( str ( n ) ) ) <NEWLINE> print ( <STRING> if n % Sn == 0 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
// <COMMENT> <NEWLINE> // <COMMENT> <NEWLINE> <COMMENT> <NL> using namespace std ; <NEWLINE> typedef long long ll ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> cin . tie ( 0 ) ; <NEWLINE> ios : : sync_with_stdio ( false ) ; <NEWLINE> int n , k ; cin >> n >> k ; <NEWLINE> int a [ n ] ; for ( int i = 0 ; i < n ; i + + ) cin >> a [ i ] ; <NEWLINE> cout << ( ( ( n - k ) + ( k - 2 ) ) / ( k - 1 ) ) + 1 << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> if ( n - 1 ) % % ( k - 1 ) == 0 : <NEWLINE> <INDENT> print ( n - 1 / k - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n - 1 // k - 1 ) + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , k = map ( int , open ( 0 ) . split ( ) ) <NEWLINE> print ( 0 - - ~ - n // ~ - k ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import math <NEWLINE> ans = math . ceil ( ( ( n - 1 ) / ( k - 1 ) ) <NEWLINE> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> print ( ceil ( ( N - 1 ) / ( K - 1 ) ) ) <NEWLINE>
n , k = int ( input ( ) . split ( ) ) ; print ( 0 - - ~ - n // ~ - k ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d -= 1 <NEWLINE> print ( a // d ) <NEWLINE>
ar = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> i = ar . index ( 1 ) <NEWLINE> count = 0 <NEWLINE> am = 0 <NEWLINE> if i % ( m - 1 ) == 0 : <NEWLINE> <INDENT> count += i // ( m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += i // ( m - 1 ) + 1 <NEWLINE> am += i % ( m - 1 ) <NEWLINE> <DEDENT> if ( n - 1 - i ) % ( m - 1 ) == 0 : <NEWLINE> <INDENT> count += ( n - 1 - i ) // ( m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += ( n - 1 - i ) // ( m - 1 ) + 1 <NEWLINE> am += ( n - 1 - i ) % ( m - 1 ) <NEWLINE> <DEDENT> if am >= m - 1 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> num = k <NEWLINE> while num < n : <NEWLINE> <INDENT> num += ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
index = a . index ( 1 ) <NEWLINE> cnt = 0 <NEWLINE> <NL> if ( n == k ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if index <= ( k - 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i = k - 1 <NEWLINE> while i <= ( len ( a ) - 2 ) : <NEWLINE> <INDENT> i += ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> elif index >= ( n - k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i = n - k <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i -= ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = index <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i -= ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> i = index <NEWLINE> while i <= ( len ( a ) - 2 ) : <NEWLINE> <INDENT> i += ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mini = min ( A ) <NEWLINE> idx = N + 1 <NEWLINE> mid = N / 2 <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == mini and abs ( idx - mid ) > abs ( i - mid ) : <NEWLINE> <INDENT> idx = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = i // ( K - 1 ) <NEWLINE> rem = i % ( K - 1 ) <NEWLINE> if rem : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if ( N - i - 1 - ( K - rem ) ) // ( K - 1 ) > 0 : <NEWLINE> <INDENT> ans += ( N - i - 1 - ( K - rem ) ) // ( K - 1 ) <NEWLINE> if ( N - i - 1 - ( K - rem ) ) % ( K - 1 ) != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( N - i - 1 ) // ( K - 1 ) > 0 : <NEWLINE> <INDENT> ans += ( N - i - 1 ) // ( K - 1 ) <NEWLINE> if ( N - i - 1 ) % ( K - 1 ) != 0 : : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> now = 1 <NEWLINE> step = 1 <NEWLINE> <NL> <NL> def sunuke ( n ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> while n : <NEWLINE> <INDENT> r += n % 10 <NEWLINE> n //= 10 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> def ok ( a , b ) : <NEWLINE> <INDENT> return a * s ( b ) <= b * s ( a ) <NEWLINE> <NL> <NL> <DEDENT> while k : <NEWLINE> <INDENT> if ok ( now , now + step ) : <NEWLINE> <INDENT> print ( now ) <NEWLINE> k -= 1 <NEWLINE> now += step <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nstep = step * 10 <NEWLINE> while now % nstep != nstep - 1 : <NEWLINE> <INDENT> now += step <NEWLINE> <DEDENT> step = nstep <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = < 8 and b = < 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> if a >= 9 or b >= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a <= 8 : <NEWLINE> <INDENT> if b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b = < 16 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , inuput ( ) . split ( ) ) <NEWLINE> if a >= 8 and b = > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) > 8 or int ( input ( ) ) > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if a > 8 or b > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= 8 ans b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N <= 8 and M <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> if a < 8 and b < 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input . split ( ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a > 8 or b > 8 <STRING> ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> esle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a < 9 and b < 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < 9 | | b < 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a <= 8 and b <= 8 else : <STRING> ) <NEWLINE>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d = 0 : <NEWLINE> <INDENT> if n <= 99 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> <DEDENT> elif d = 1 : <NEWLINE> <INDENT> if n <= 99 : <NEWLINE> <INDENT> print ( 100 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10100 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n <= 99 : <NEWLINE> <INDENT> print ( 10000 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1010000 ) <NEWLINE> <DEDENT> <DEDENT>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 10000000 ) : <NEWLINE> <INDENT> if i % ( 100 ** D ) == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> if len ( ans ) == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ N ] ) <NEWLINE>
0 5 <NEWLINE>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , 10000 * 100 + 1 ) : <NEWLINE> <INDENT> if i % ( pow ( 100 , d ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = 100 ** d <NEWLINE> print ( x * n ) <NEWLINE>
d , n = map ( int , intput ( ) . split ( ) ) <NEWLINE> print ( n * 10 ** ( 2 * d ) ) <NEWLINE>
D , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( 100 ** D ) * N ) <NEWLINE>
D , N = input ( ) . split ( ) <NEWLINE> print ( 100 ** D * 5 ) <NEWLINE>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> if n == 100 : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n == 100 : <NEWLINE> print ( n ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == 100 : <NEWLINE> <INDENT> print ( 100 ** d * 101 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 ** d * n ) <NEWLINE> <DEDENT> <DEDENT>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * 100 ** d ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lst = [ ] <NEWLINE> X = <STRING> ** D <NEWLINE> <NL> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if i % 100 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( str ( i ) + X ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst [ N - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count += bin ( i ) . rfind ( <STRING> ) - 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> int main ( void ) { <NEWLINE> <INDENT> int n , i ; <NEWLINE> scanf ( <STRING> , & n ) ; <NEWLINE> long long a [ n ] , ans = 0 ; <NEWLINE> for ( i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> scanf ( <STRING> , & a [ i ] ) ; <NEWLINE> <DEDENT> } <NEWLINE> for ( i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> while ( a [ i ] % 2 == 0 ) { <NEWLINE> <INDENT> a [ i ] += a [ i ] / 2 ; <NEWLINE> ans + + ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> printf ( <STRING> , ans ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int , input ( ) . split ( ) ) <NEWLINE> counter = [ ] <NEWLINE> for num in range ( len ( A ) ) : <NEWLINE> <INDENT> counter . append ( 0 ) <NEWLINE> <DEDENT> for num in range ( len ( A ) ) : <NEWLINE> <INDENT> while A [ num ] % 2 == 0 : <NEWLINE> <INDENT> A [ num ] = A [ num ] / 2 <NEWLINE> counter [ num ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( counter ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans += prime_factorize ( i ) . count ( 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> while A [ i ] % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> A = readInts ( ) <NEWLINE> abc = 1 <NEWLINE> for v in A : <NEWLINE> <INDENT> abc *= v <NEWLINE> <DEDENT> ans = 0 <NEWLINE> while abc % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> abc //= 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while a [ i ] % 2 = 0 : <NEWLINE> <INDENT> a [ i ] = a [ i ] / 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
if contest_num <= 999 : <NEWLINE> <INDENT> print ( <STRING> + str ( contest_num ) . zfill ( 3 ) ) <NEWLINE> <DEDENT> elif contest_num >= 1000 : <NEWLINE> <INDENT> over_thousand_num_fix = contest_num - 999 <NEWLINE> print ( <STRING> + str ( over_thousand_num_fix ) . zfill ( 3 ) ) <NEWLINE> <DEDENT>
<NL> n = input ( ) <NEWLINE> if n < 1000 : <NEWLINE> <INDENT> prnt ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if 1 <= N < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> elif 1000 <= N <= 1998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
name = input ( ) <NEWLINE> if name <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif name >= 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> if ( n / 1000 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> + n % 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + ( n % 1000 ) + 1 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a < 10 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif 10 <= a < 100 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif 100 <= a < 1000 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif : 1000 <= a < 1010 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif : 1010 <= a < 1100 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n < 1000 : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if N < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> if n < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 1000 <= n <= 1998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
moji = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( <STRING> , <STRING> ) [ moji >= 1000 ] ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if N >= 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if = 1 < N <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 999 < N <= 1998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> 1 <= N <= 1988 <NEWLINE> <NL> if N <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else N >= 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> X = b - a <NEWLINE> ans = 0 <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> while ( a > sum ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> <INDENT> sum += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum - a ) <NEWLINE> <NL>
def Gauss_sum ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> a , b = map ( int , input ( ) ) <NEWLINE> for i in range ( 999 ) : <NEWLINE> <INDENT> if Gauss_sum ( i + 1 ) - a == Gauss_sum ( i + 2 ) - b : <NEWLINE> <INDENT> print ( Gauss_sum ( i + 1 ) - a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = itertools . accumulate ( [ 1 ] * 999 ) <NEWLINE> print ( l [ m - n - 1 ] - m ) <NEWLINE>
L = [ 1 ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = 6 <NEWLINE> y = 9 <NEWLINE> while x <= n : <NEWLINE> <INDENT> L . append ( x ) <NEWLINE> x *= 6 <NEWLINE> <DEDENT> while y <= n : <NEWLINE> <INDENT> L . append ( y ) <NEWLINE> y *= 9 <NEWLINE> <DEDENT> L . sort ( ) <COMMENT> <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in L : <COMMENT> <NEWLINE> <INDENT> dp [ i + j ] = min ( dp [ i + j ] , dp [ i ] + 1 ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> six = [ 6 ** i for i in range ( 7 ) ] <NEWLINE> nine = [ 9 ** i for i in range ( 6 ) ] <NEWLINE> L = [ ] <NEWLINE> for s in six : <NEWLINE> <INDENT> L . append ( s ) <NEWLINE> <DEDENT> for s in nine [ 1 : ] : <NEWLINE> <INDENT> L . append ( s ) <NEWLINE> <DEDENT> L . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> while N > 0 : <NEWLINE> <INDENT> ans += N // l <NEWLINE> N %= l <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> n , C = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( C ) ] <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> a = [ [ 0 ] * C for _ in range ( 3 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a [ ( i + j ) % 3 ] [ c [ i ] [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 10 ** 9 <NEWLINE> for v in combinations ( range ( C ) , 3 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 30 ) : <NEWLINE> <INDENT> tmp += a [ i ] [ j ] * d [ j ] [ v [ i ] ] <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> M = 10 ** 9 <NEWLINE> for i in range ( 1 , N // 2 + 10 ) : <NEWLINE> <INDENT> a = list ( str ( i ) ) <NEWLINE> b = list ( str ( N - i ) ) <NEWLINE> <COMMENT> <NL> k = 0 <NEWLINE> for q in range ( len ( a ) ) : <NEWLINE> <INDENT> k += int ( a [ q ] ) <NEWLINE> <DEDENT> for p in range ( len ( b ) ) : <NEWLINE> <INDENT> k += int ( b [ p ] ) <NEWLINE> <DEDENT> M = min ( M , k ) <NEWLINE> <DEDENT> print ( M ) <NEWLINE>
I , i , R = input , int , range <NEWLINE> n , L , R , A , C = i ( I ( ) ) , [ ] , [ ] , 0 , 0 <NEWLINE> for _ in R ( n ) : l , r = map ( i , I ( ) . split ( ) ) ; L += [ l ] ; R += [ r ] <NEWLINE> L = sorted ( l ) [ : : - 1 ] ; R . sort ( ) <NEWLINE> for j in R ( n ) : C += ( L [ j ] - R [ j ] ) * 2 ; A = max ( A , C ) <NEWLINE> print ( A ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from card3 . void . stop_watch import stop_watch <NEWLINE> <NL> @ stop_watch <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <DEDENT> ll = np . array ( L ) ; ll . sort ( ) ; ll = ll [ : : - 1 ] <NEWLINE> rr = np . array ( R ) ; rr . sort ( ) <NEWLINE> <NL> lll = ll . cumsum ( ) <NEWLINE> rrr = rr . cumsum ( ) <NEWLINE> <NL> x = ( lll - rrr ) . max ( ) <NEWLINE> y = ( lll [ 1 : ] - rrr [ : - 1 ] ) . max ( ) <NEWLINE> z = ( lll [ : - 1 ] - rrr [ 1 : ] ) . max ( ) <NEWLINE> <NL> print ( 2 * max ( x , y , z ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A + B , A - B , A * B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , max ( a - b , a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a = b , a * b ) ) <NEWLINE>
A , B = max ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A + B , A - B , A * B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a - b , a * b ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = max ( a + b , a - b ) <NEWLINE> <NL> print ( k ) <NEWLINE>
a , b = map ( imt , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a * b , a - b ) ) <NEWLINE>
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> my_result = max ( a + b , a - b , a * b ) <NEWLINE> print ( my_result ) <NEWLINE>
a , b = map ( inr , input ( ) . split ( ) ) <NEWLINE> print ( max ( [ a + b , a - b , a * b ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> def f ( s , t ) : <NEWLINE> <INDENT> set_s = set ( ) <NEWLINE> set_t = set ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> set_s . add ( i ) <NEWLINE> <DEDENT> for i in t : <NEWLINE> <INDENT> set_t . add ( i ) <NEWLINE> <DEDENT> return len ( set_s & set_t ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> s = S [ i : ] <NEWLINE> t = S [ : i ] <NEWLINE> ans = max ( ans , f ( s , t ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> maxa = - 10 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = set ( L [ : i + 1 ] ) <NEWLINE> b = set ( [ i + 1 : ] ) <NEWLINE> maxa = max ( maxa , len ( a & b ) ) <NEWLINE> <DEDENT> print ( maxa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> a = [ 0 ] * 26 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ ord ( S [ i ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> b = [ 0 ] * 26 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> a [ ord ( S [ i ] ) - ord ( <STRING> ) ] -= 1 <NEWLINE> b [ ord ( S [ i ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> cnt = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if a [ j ] * b [ j ] > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> X = S [ : i ] <NEWLINE> Y = S [ i : ] <NEWLINE> setX = set ( X ) <NEWLINE> setY = set ( Y ) <NEWLINE> intersectionXY = setX & setY <NEWLINE> _temp = len ( intersectionXY ) <NEWLINE> if _temp > ans : <NEWLINE> <INDENT> ans = _temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> w = set ( s ) <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s . count ( w [ i ] ) >= 2 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> c = a <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> a = min ( a , c ) <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
e = S . count ( <STRING> ) <NEWLINE> cnt = e <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> e = min ( e , cnt ) <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> d = { k : 0 for k in <STRING> . split ( ) } <NEWLINE> for ln in sys . stdin : <NEWLINE> <INDENT> d [ ln . strip ( ) ] += 1 <NEWLINE> <DEDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> print ( k , <STRING> , v ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> CNT = [ ] <NEWLINE> c = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> CNT . append ( c ) <NEWLINE> <NL> <DEDENT> ans = N + 10 <NEWLINE> mn = N + 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> if i > 0 : <NEWLINE> <INDENT> c += i - 1 - CNT [ i - 1 ] <NEWLINE> <DEDENT> if i < N - 1 : <NEWLINE> <INDENT> c += N - i - 1 - ( CNT [ N ] - CNT [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> if c < mn : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
A , B , C , K = map ( int , split ( ) . input ( ) ) <NEWLINE> print ( A - B if K % 2 == 0 else B - A ) <NEWLINE>
if K % 2 == 0 : <NEWLINE> <INDENT> ans = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = a - b <NEWLINE> <NL> if ( k % 2 == 1 ) : <NEWLINE> <INDENT> ans = abs ( ans ) <NEWLINE> <NL> <DEDENT> if ( len ( ans ) >= 18 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k % 2 == 0 and abs ( a - b ) <= 10 ** 8 : print ( a - b ) <NEWLINE> elif k % 2 != 0 abs ( b - a ) <= 10 ** 8 : print ( b - a ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
A , B , C , K = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> C = int ( C ) <NEWLINE> K = int ( K ) <NEWLINE> while True : <NEWLINE> <INDENT> if A == B == C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> a = B + C <NEWLINE> b = A + C <NEWLINE> c = A + B <NEWLINE> A = a <NEWLINE> B = b <NEWLINE> C = c <NEWLINE> <DEDENT> if A - B > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A - B ) if k % 2 == 0 else print ( B - A ) <NEWLINE>
print ( ( - 1 ) ** k * ( a - b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> q = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q [ p [ i ] ] = q [ p [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> print ( q - max ( q ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> if l [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ i + 1 ] - l [ i ] > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( l [ i ] + 1 == l [ i + 1 ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> ans += l [ i + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> k1 = abs ( a - b ) <NEWLINE> k2 = abs ( a - c ) <NEWLINE> k3 = abs ( b - c ) <NEWLINE> if k2 <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k1 <= d or k3 <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> if abs ( a - c ) > d : <NEWLINE> <INDENT> if abs ( a - b ) > d or abs ( b - c ) > d : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
if abs ( c - a ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( b - a ) <= d and abs ( c - b ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> x = abs ( a - b ) <NEWLINE> y = abs ( b - c ) <NEWLINE> z = abs ( a - c ) <NEWLINE> <NL> if x <= d and y <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x > d and z <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if abs ( c - a ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( b - a ) <= d and abs ( c - b ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> if abs ( c - a ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( b - a ) <= d and abs ( c - b ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( abs ( a - b ) <= d ) and ( abs ( b - c ) <= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if e ( a - b ) <= d and e ( b - c ) <= d or e ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a < b and b < c ) or ( a > b and b > c ) : <NEWLINE> <INDENT> if abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for b in range ( 2 , int ( x ** ( 1 / 2 ) + 1 ) ) : <NEWLINE> <INDENT> for p in range ( 2 , 1000 ) : <NEWLINE> <INDENT> tmp = pow ( b , p ) <NEWLINE> if tmp <= x : <NEWLINE> <INDENT> ans = max ( ans , pow ( b , p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if d >= z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d >= x and d >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if d >= abs ( a - c ) or ( d >= abs ( a - b ) and d >= abs ( b - c ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - c ) <= d or abs ( a - b ) + abs ( b - c ) <= d : <NEWLINE> <DEDENT> main ( ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = abs ( a - b ) <NEWLINE> BC = abs ( b - c ) <NEWLINE> AC = abs ( a - c ) <NEWLINE> <NL> if AC <= d or ( AB <= d and BC <= d : ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ abs ( a - c ) <= d or ( abs ( a - b ) <= d and abs ( b - c ) <= d ] ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a - d <= c <= a + d : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif a - d <= b <= a + d and c - d <= b <= c + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = input ( ) <NEWLINE> <NL> dataa , datab , datac , datad = data . split ( <STRING> ) <NEWLINE> <NL> dataa = int ( dataa ) <NEWLINE> datab = int ( datab ) <NEWLINE> datac = int ( datac ) <NEWLINE> datad = int ( datad ) <NEWLINE> <NL> length1 = dataa - datab <NEWLINE> length2 = datab - datac <NEWLINE> length11 = abs ( length1 ) + abs ( length2 ) <NEWLINE> length3 = dataa - datac <NEWLINE> <NL> if abs ( length1 ) < >= datad : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( length2 ) <= datad : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( length11 ) <= datad : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = int ( input ( ) ) <NEWLINE> <NL> if D >= A + C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D >= A + B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if c - a <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a <= d and c - b <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( b - c ) <= d and abs ( a - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if c - a <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a <= d and c - b <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> d = input ( ) <NEWLINE> <NL> ab = a - b <NEWLINE> bc = b - c <NEWLINE> ac = a - c <NEWLINE> <NL> if a <= b <= c <= or c < b < a : <NEWLINE> <INDENT> if ab <= d and bc <= d or ac <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ac <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if abs ( b - a ) < d and abs ( c - b ) < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> n = [ ] <NEWLINE> for i in range ( 2 , 10 ) : <NEWLINE> <INDENT> for j in range ( 32 ) : <NEWLINE> if j ** i <= a : <NEWLINE> <INDENT> n . append ( j ** i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( n ) ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = ( int ( math . sqrt ( X ) ) ) ** 2 <NEWLINE> for i in range ( 2 , int ( math . sqrt ( x ) ) + 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i ** j <= x and i ** j > ans : <NEWLINE> <INDENT> ans = i ** j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
X = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for b in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for p in range ( 2 , 1000 ) : <NEWLINE> <INDENT> if b ** p <= X : <NEWLINE> <INDENT> res . append ( b ** p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res [ - 1 ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if X == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for b in range ( 2 , int ( x ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> temp = b <NEWLINE> while temp <= X : <NEWLINE> <INDENT> ans = max ( ans , temp ) <NEWLINE> temp *= b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> X = int ( sys . stdin . readline ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> for j in range ( 11 ) : <NEWLINE> <INDENT> tmp = pow ( i , j ) <NEWLINE> if tmp <= X : <NEWLINE> <INDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> if x == 0 or x == 1 : <NEWLINE> <INDENT> sum = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> j = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if pow ( i , j ) <= x : <NEWLINE> <INDENT> if pow ( i , j ) > sum : <NEWLINE> <INDENT> sum = pow ( i , j ) <NEWLINE> else : <NEWLINE> <DEDENT> break <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for p in range ( 2 , x ) : <NEWLINE> <INDENT> if b ** p <= x : c = max ( c , b ** p ) <NEWLINE> else : break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x <= 3 : <NEWLINE> <INDENT> print ( 1 ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> j = 2 <NEWLINE> while i ** j < x : <NEWLINE> <INDENT> a . append ( i ** j ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> res = 1 <NEWLINE> for b in range ( 2 , math . ceil ( math . sqrt ( x ) ) ) : <NEWLINE> <INDENT> p = 2 <NEWLINE> while b ** ( p + 1 ) <= x : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> res = max ( res , b ** p ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = [ 1 ] * 8 <NEWLINE> for i in range ( 2 , 10 ) : <NEWLINE> <INDENT> for j in range ( A + 1 ) : <NEWLINE> <INDENT> if j ** i <= A : <NEWLINE> <INDENT> B [ i - 2 ] = j ** i <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> <DEDENT> B = B . sort ( ) <NEWLINE> print ( B [ - 1 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( 33 ) : <NEWLINE> <INDENT> b = i <NEWLINE> while b < a : <NEWLINE> <INDENT> b = b * i <NEWLINE> <DEDENT> c = b / i <NEWLINE> if d > c : <NEWLINE> <INDENT> d = c <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def func ( p ) : <NEWLINE> <INDENT> q = p <NEWLINE> while q < x : <NEWLINE> <INDENT> q *= p <NEWLINE> if q == x : <NEWLINE> <INDENT> return q <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q / p == p : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return q / p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> z = [ ] <NEWLINE> a = 1 <NEWLINE> <NL> while a <= x : <NEWLINE> <INDENT> z . append ( func ( a ) ) <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> print ( max ( z ) ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> ans = [ 1 ] <NEWLINE> s = int ( math . sqrt ( x ) ) <NEWLINE> if s >= 2 : <NEWLINE> <INDENT> for i in range ( 2 , s + 1 ) : <NEWLINE> <INDENT> temp = i <NEWLINE> while True : <NEWLINE> <INDENT> temp *= i <NEWLINE> if temp <= n : <NEWLINE> <INDENT> ans . append ( temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> p = set ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( 1 , 6 ) : <NEWLINE> <INDENT> if i + j <= len ( s ) - 1 : <NEWLINE> <INDENT> p . add ( s [ i : j + i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = sorted ( p ) <NEWLINE> print ( p [ K - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = set ( ) <NEWLINE> for l in range ( n - 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , min ( t , n - l ) ) : <NEWLINE> <INDENT> ans . add ( s [ l : r ] ) <NEWLINE> <DEDENT> <DEDENT> aa = list ( ans ) <NEWLINE> aa . sort ( ) <NEWLINE> print ( aa [ t - 1 ] ) <NEWLINE>
def main2 ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> P = sorted ( S ) <NEWLINE> l = [ ] <NEWLINE> k = 0 <NEWLINE> while len ( l ) <= 5 : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> if S [ n ] == P [ k ] : <NEWLINE> <INDENT> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if n + i < N - 1 : <NEWLINE> <INDENT> tmp = <STRING> . join ( S [ n : n + i ] ) <NEWLINE> if tmp not in l : <NEWLINE> <INDENT> l . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> k += 1 <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> print ( l [ K - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) ) : <NEWLINE> <INDENT> if j - i >= 5 : break <NEWLINE> a . append ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = sorted ( set ( a ) ) <NEWLINE> print ( res [ k - 1 ] ) <NEWLINE>
class uft ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ - 1 for i in range ( n ) ] <NEWLINE> self . r = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if ( self . p [ x ] == - 1 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = self . find ( self . p [ x ] ) <NEWLINE> return self . find ( self . p [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if ( self . r [ x ] > self . r [ y ] ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <NL> <DEDENT> if ( self . r [ x ] == self . r [ y ] ) : <NEWLINE> <INDENT> self . r [ y ] += 1 <NEWLINE> <NL> <DEDENT> if ( x != y ) : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uf = uft ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> uf . unite ( x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( uf . find ( i ) == uf . find ( p [ i ] ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import jit <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> @ jit <NEWLINE> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> uf . union ( x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> ro = uf . roots ( ) <NEWLINE> <NL> for i in ro : <NEWLINE> <INDENT> mem = uf . members ( i ) <NEWLINE> for j in mem : <NEWLINE> <INDENT> if p [ j ] - 1 in mem : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> par = [ i for i in range ( n ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return par [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> fx = find ( x ) <NEWLINE> fy = find ( y ) <NEWLINE> if fx != fy : <NEWLINE> <INDENT> par [ fx ] = fy <NEWLINE> <NL> <DEDENT> <DEDENT> f = lambda x : int ( x ) - 1 <NEWLINE> for mm in range ( m ) : <NEWLINE> <INDENT> x , y = map ( f , input ( ) . split ( ) ) <NEWLINE> union ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if find ( p [ i ] ) == i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ ] <NEWLINE> for i in range ( len ( s ) - K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> ans_list . append ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_set = set ( ans_list ) <NEWLINE> ans_list_min = sorted ( list ( ans_set ) ) <NEWLINE> print ( ans_list_min [ K - 1 ] ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , A , B , C , D = LI ( ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> C -= 1 <NEWLINE> D -= 1 <NEWLINE> S = SS ( ) <NEWLINE> <NL> <COMMENT> <NL> if <STRING> in S [ A : C + 1 ] or <STRING> in S [ B : D + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if C < D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if <STRING> in S [ B : D + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
, <COMMENT> <NEWLINE> s = input ( ) + <STRING> <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( len ( s ) , i + 5 + 1 ) ) : <NEWLINE> <INDENT> t = <STRING> . join ( s [ i : j ] ) <NEWLINE> if t not in ans : <NEWLINE> <INDENT> ans . append ( t ) <NEWLINE> ans = sorted ( ans ) [ : 6 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ k - 1 ] ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> class UnionFind ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . _par = list ( range ( n ) ) <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , v ) : <NEWLINE> <INDENT> if self . _par [ v ] == v : <NEWLINE> <INDENT> return v <NEWLINE> <DEDENT> self . _par [ v ] = self . root ( self . _par [ v ] ) <NEWLINE> return self . _par [ v ] <NEWLINE> <NL> <DEDENT> def unite ( self , u , v ) : <NEWLINE> <INDENT> u , v = self . root ( u ) , self . root ( v ) <NEWLINE> if u == v : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . size [ u ] > self . size [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> self . size [ v ] += self . size [ u ] <NEWLINE> self . _par [ u ] = v <NEWLINE> <NL> <DEDENT> def is_connected ( self , u , v ) : <NEWLINE> <INDENT> return self . root ( u ) == self . root ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> P = list ( map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> uf , unite ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if uf . is_connected ( i , p [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - c ) <= d or ( abs ( a - b ) <= d and abs ( b - c ) <= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( a - 1 + ( a <= b ) ) ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if b >= a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - 1 ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if y < x : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> ans = ( a - 1 ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> if a == i and b == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( a , b ) - 1 ) <NEWLINE> <DEDENT>
abc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> mx = abc . pop ( max ( abc ) ) <NEWLINE> print ( mx * k + sum ( abc ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> a [ - 1 ] *= 2 ** k <NEWLINE> <NL> print ( sum ( a ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] + a [ 1 ] + ( a [ 2 ] * ( 2 ** b ) ) <NEWLINE>
a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> print ( sum ( a ) + max ( a ) * ( 2 ** ( K - 1 ) ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = max ( a , b , c ) <NEWLINE> <NL> print ( ( a + b + c ) - x + x * ( 2 ** k ) ) <NEWLINE>
ls = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ls . sort ( ) <NEWLINE> ans = ls [ 0 ] + ls [ 1 ] + ls [ 2 ] * 2 ** K <NEWLINE> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> * ( W + 2 ) ] + [ <STRING> + input ( ) + <STRING> for _ in range ( H ) ] + [ <STRING> * ( W + 2 ) ] <NEWLINE> for y in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ y ] [ x ] = <STRING> and ( S [ y - 1 ] [ x ] + S [ y + 1 ] [ x ] + S [ y ] [ x - 1 ] + S [ y ] [ x + 1 ] ) . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> f = False <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> pre = <STRING> <NEWLINE> now = S [ h ] [ 0 ] <NEWLINE> nxt = S [ h ] [ 1 ] <NEWLINE> abv = <STRING> if h == 0 else S [ h - 1 ] [ 0 ] <NEWLINE> blw = <STRING> if h == H - 1 else S [ h + 1 ] [ 0 ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if now == <STRING> : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> elif now in [ pre , nxt , abv , blw ] : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = True <NEWLINE> <NL> <DEDENT> pre = now <NEWLINE> now = nxt <NEWLINE> nxt = <STRING> if w == W - 1 else S [ h ] [ w + 1 ] <NEWLINE> abv = <STRING> if h == 0 else S [ h - 1 ] [ w ] <NEWLINE> blw = <STRING> if h == H - 1 else S [ h + 1 ] [ w ] <NEWLINE> <NL> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> figure = [ input ( ) for _ in range ( H ) ] <NEWLINE> D = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if figure [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> for dh , dw in D : <NEWLINE> <INDENT> nh , nw = h + dh , w + dw <NEWLINE> if not ( 0 <= nh <= H and 0 <= nw <= W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if figure [ nh ] [ nw ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> src = [ input ( ) for i in range ( h ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for row in src : <NEWLINE> <INDENT> ans . append ( list ( row ) ) <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> dxy = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> for x in range ( h ) : <NEWLINE> <INDENT> for y in range ( w ) : <NEWLINE> <INDENT> if src [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for dx , dy in dxy : <NEWLINE> <INDENT> if x + dx < 0 or x + dx > h - 1 or y + dy < 0 or y + dy > w - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if src [ x + dx ] [ y + dx ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
ans = True <NEWLINE> d = [ ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if s [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> for dy , dx in d : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if ny < 0 or H <= ny or nx < 0 or W <= nx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> d = <STRING> <NEWLINE> dn = <STRING> <NEWLINE> <NL> def isPaintable ( h , w , x , y , canvas ) : <NEWLINE> <INDENT> ret = False <NEWLINE> if x > 0 : <NEWLINE> <INDENT> if canvas [ x - 1 , y ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> elif x < w : <NEWLINE> <INDENT> if canvas [ x + 1 , y ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> elif y > 0 : <NEWLINE> <INDENT> if canvas [ x , y - 1 ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> elif y < h : <NEWLINE> <INDENT> if canvas [ x , y + 1 ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> canavs = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s = list ( input ( ) . split ( ) . rstrip ( <STRING> ) ) <NEWLINE> canvas . append ( s ) <NEWLINE> <DEDENT> for i in h : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in w : <NEWLINE> <INDENT> if not isPaintable ( h , w , j , i , canvas ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( * [ x for x in sieve ( 55555 ) if x % 10 == 7 ] [ : int ( input ( ) ) ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> T = [ <STRING> . join ( s ) for s in zip ( * S ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ans += ( S == T ) <NEWLINE> S = [ s [ - 1 ] + s [ : - 1 ] for s in S ] <NEWLINE> T = T [ - 1 : ] + T [ : - 1 ] <NEWLINE> <NL> <DEDENT> print ( N * ans ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = 2 * C * min ( X , Y ) + 2 * C * ( max ( X , Y ) - min ( X , Y ) ) <NEWLINE> <NL> <COMMENT> <NL> if X > Y : <NEWLINE> <INDENT> b = 2 * C * Y + ( X - Y ) * A <NEWLINE> <DEDENT> elif Y > X : <NEWLINE> <INDENT> b = 2 * C * X + ( Y - X ) * B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <NL> <COMMENT> <NL> c = A * X + B * Y <NEWLINE> print ( c ) <NEWLINE> <NL> print ( min ( a , b , c ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . count ( o ) * 100 + 700 ) <NEWLINE>
n = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c > 0 : <NEWLINE> <INDENT> print ( 700 * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 700 ) <NEWLINE> <DEDENT>
opt = input ( ) <NEWLINE> sum = 700 <NEWLINE> if opt [ 0 ] == o : <NEWLINE> <INDENT> sum += 100 <NEWLINE> <DEDENT> if opt [ 1 ] == o : <NEWLINE> <INDENT> sum += 100 <NEWLINE> <DEDENT> if opt [ 2 ] == o : <NEWLINE> <INDENT> sum += 100 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
to = list ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> <NL> if to [ 0 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> if to [ 1 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 : <NEWLINE> <DEDENT> if to [ 2 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 : <NEWLINE> <NL> <DEDENT> price = 700 + 100 * int ( counter ) <NEWLINE> <NL> print ( price ) <NEWLINE>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> if ( s [ 0 ] == <STRING> ) c += 700 <NEWLINE> if ( s [ 1 ] == <STRING> ) c += 100 <NEWLINE> if ( s [ 2 ] == <STRING> ) c += 100 <NEWLINE> print ( c ) <NEWLINE>
n = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( 700 + count * 100 ) <NEWLINE>
print ( 700 + input . count ( <STRING> ) * 100 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( 700 + int ( input ( ) ) . count ( <STRING> ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( 700 + int ( S . count ( ) * 100 ) ) <NEWLINE>
S = input ( ) <NEWLINE> price = 700 + 100 * s . count ( <STRING> ) <NEWLINE> print ( price ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> count = 700 <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> count += 100 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( 700 + 100 * cnt ) <NEWLINE>
import java . util . Scanner ; <NEWLINE> public class Main { <NEWLINE> <INDENT> public static void main ( String [ ] args ) { <NEWLINE> <INDENT> Scanner scan = new Scanner ( System . in ) ; <NEWLINE> String S = scan . nextLine ( ) ; <NEWLINE> <NL> <INDENT> int v = 700 ; <NEWLINE> for ( int i = 0 ; i < S . length ( ) ; i + + ) { <NEWLINE> if ( S . charAt ( i ) == <STRING> ) { <NEWLINE> <INDENT> v += 100 ; <NEWLINE> <DEDENT> } <NEWLINE> } <NEWLINE> <NL> System . out . println ( v ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> min_ = min ( X , Y ) <NEWLINE> max_ = max ( X , Y ) <NEWLINE> <NL> res = A * X + B * Y <NEWLINE> <NL> m = 2 * C * max ( X , Y ) ; <NEWLINE> <NL> sum = C * 2 * min_ <NEWLINE> <NL> if ( C <= 0.5 * A and C <= 0.5 * B ) : <NEWLINE> <INDENT> sum += 2 * C * ( max_ - min_ ) <NEWLINE> <NL> <DEDENT> elif ( max_ == X ) : <NEWLINE> <INDENT> sum += ( max_ - min_ ) * A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += ( max_ - min_ ) * B <NEWLINE> <NL> <DEDENT> print ( min ( m , min ( res , sum ) ) ) <NEWLINE>
n , x , * m = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = - 1 <NEWLINE> for i in sorted ( m ) : <NEWLINE> <INDENT> if x >= i : <NEWLINE> <INDENT> x -= i ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans + x // min ( m ) ) <NEWLINE>
n , x = map ( int , input ( ) ) <NEWLINE> m = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> <NL> print ( ( x - sum ( m ) ) // min ( m ) + n ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = n <NEWLINE> mi = 10 ** 4 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> x -= m <NEWLINE> mi = min ( m , mi ) <NEWLINE> <DEDENT> asn += ( x // mi ) * mi <NEWLINE> print ( ans ) <NEWLINE> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ range ( n ) ] <NEWLINE> print ( n + ( ( x - sum ( a ) ) // min ( a ) ) ) <NEWLINE>
n , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> m . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> sort ( m ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( m [ 0 : i + 1 ] ) > x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ) <NEWLINE> a = A * X + B * Y <NEWLINE> b = max ( X , Y ) * C * 2 <NEWLINE> p = B if X < Y else A <NEWLINE> c = min ( X , Y ) * 2 * C + abs ( X - Y ) * p <NEWLINE> print ( min ( a , b , c ) ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a * x + b * y , 2 * c * x + b * max ( 0 , y - x ) , 2 * c * y + a * max ( 0 , x - y ) ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = X * A + Y * B <NEWLINE> for i in range ( max ( X + Y ) + 1 ) : <NEWLINE> <INDENT> C = 2 * C * i + max ( 0 , X - i ) * A + max ( 0 , Y - i ) * B <NEWLINE> ans = min ( ans , C ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 10 ** 12 <NEWLINE> for i in range ( 0 , max ( x , y ) * 2 + 1 , 2 ) : <NEWLINE> <INDENT> xr = max ( x - i // 2 , 0 ) <NEWLINE> yr = max ( 0 , y - i // 2 ) <NEWLINE> <NL> if ans > ( i * c ) + ( xr * a ) + ( yr * b ) : <NEWLINE> <INDENT> ans = ( i * c ) + ( xr * a ) + ( yr * B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mast = max ( x , y ) <NEWLINE> ans = max ( a * x + b * y , c * 2 * i ) <NEWLINE> <NL> for i in range ( mast + 1 ) : <NEWLINE> <INDENT> price = a * max ( x - i , 0 ) + b * max ( y - i , 0 ) + c * 2 * i <NEWLINE> ans = min ( ans , price ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = max ( x , y ) <NEWLINE> ans = 10 ** 9 + 7 <NEWLINE> for e in range ( m + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , 2 * e * c + a * max ( 0 , x - e ) + b * ( 0 , y - e ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> kei = 0 <NEWLINE> if c > a / 2 + b / 2 : <NEWLINE> <INDENT> kei = a * x + b * y <NEWLINE> <NL> <DEDENT> elif c * 2 = < a + b and a >= c * 2 and b >= c * 2 : <NEWLINE> <INDENT> kei += c * ( min ( x , y ) * 2 ) <NEWLINE> if x > y : <NEWLINE> <INDENT> kei += c * ( ( x - y ) * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kei += c * ( ( y - x ) * 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif c = < a / 2 + b / 2 : <NEWLINE> <INDENT> kei += c * ( min ( x , y ) * 2 ) <NEWLINE> if x > y : <NEWLINE> <INDENT> kei += a * ( x - y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kei += b * ( y - x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( kei ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A <= 2 * C amd B <= 2 * C : <NEWLINE> <INDENT> print ( A * X + B * Y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if X >= Y : <NEWLINE> <INDENT> print ( min ( A * ( X - Y ) + 2 * C * Y , 2 * C * X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( B * ( Y - X ) + 2 * C * X , 2 * C * Y ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> a , b , c , x , y = I ( ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> cash = 2 * c * i + a * max ( 0 , x - i ) + b * max ( 0 , y - i ) <NEWLINE> c . append ( cash ) <NEWLINE> <NL> <DEDENT> print ( min ( p ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> n , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xv = [ [ 0 , 0 ] ] + [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] + [ [ c , 0 ] ] <NEWLINE> xv_rev = reversed ( xv ) <NEWLINE> <NL> print ( xv ) <NEWLINE> ans = 0 <NEWLINE> cal = 0 <NEWLINE> dis = 0 <NEWLINE> <NL> for i in range ( 1 , len ( xv ) ) : <NEWLINE> <INDENT> cal += xv [ i ] [ 1 ] <NEWLINE> cal -= ( xv [ i ] [ 0 ] - xv [ i - 1 ] [ 0 ] ) <NEWLINE> ans = max ( cal , ans ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , xv_rev ) : <NEWLINE> <INDENT> cal += xv [ i ] [ 1 ] <NEWLINE> cal -= ( xv [ i ] [ 0 ] - xv [ i - 1 ] [ 0 ] ) <NEWLINE> ans = max ( cal , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> if A + B > c * 2 : <NEWLINE> <INDENT> Z = min ( X , Y ) <NEWLINE> ans += 2 * C * Z <NEWLINE> X -= Z <NEWLINE> Y -= Z <NEWLINE> <DEDENT> a = min ( A , 2 * C ) <NEWLINE> b = min ( B , 2 * C ) <NEWLINE> <NL> ans += a * X <NEWLINE> ans += b * Y <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) ) <NEWLINE> if x >= a + b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a <= x and a + b >= x or <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( A <= C & & B >= C ) else <STRING> ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> if A <= X and A + B >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] ] [ a <= x < a + b ] ) <NEWLINE>
<INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( a + b ) >= x else <STRING> ) <NEWLINE> <DEDENT>
if 0 <= X - A <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def actual ( N , M , X , A ) : <NEWLINE> <COMMENT> <NL> <INDENT> toll_gates_left = [ a_i for a_i in A if a_i < X ] <NEWLINE> toll_gates_right = [ a_i for a_i in A if X < a_i ] <NEWLINE> <NL> return min ( len ( toll_gates_left ) , len ( toll_gates_right ) ) <NEWLINE> <NL> <DEDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> print ( actual ( N , M , X , A ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i < c : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( l , r ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( sum ( [ 1 for i in a if i > x ] ) , sum ( [ 1 for i in a if i < x ] ) ) <NEWLINE>
n , m , x , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; print ( min ( c : = sorted ( a ) . index ( x ) , m - c ) ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = 0 <NEWLINE> f = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if d [ i ] > c : <NEWLINE> <INDENT> e = e + 1 <NEWLINE> <DEDENT> if d [ i ] < c : <NEWLINE> <INDENT> f = f + 1 <NEWLINE> <DEDENT> <DEDENT> if e > f : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for in range ( M ) ] <NEWLINE> count_low = 0 <NEWLINE> count_high = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if a [ i - 1 ] < X : <NEWLINE> <INDENT> count_low += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if a [ i - 1 ] > X : <NEWLINE> <INDENT> count_high += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( count_low , count_high ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sum ( i if int ( i ) < x for i in input ( ) . split ( ) ) <NEWLINE> print ( min ( s , m - s ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( c ) <NEWLINE> d . sort ( ) <NEWLINE> print ( min ( d . index ( c ) , len ( d ) - d . index ( c ) - 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sort ( ) <NEWLINE> x = b [ n // 2 - 1 ] <NEWLINE> y = b [ n // 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if a <= x : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
fuckoff <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> def getNearestValue ( list , num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> idx = np . abs ( np . asarray ( list ) - num ) . argmin ( ) <NEWLINE> return list [ idx ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> check = 0 <NEWLINE> a . sort ( ) <NEWLINE> b = a [ - i ] <NEWLINE> c = getNearestValue ( a , b / 2 ) <NEWLINE> ans = str ( b ) + <STRING> + str ( c ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> from bisect import bisect_left , bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> ai = max ( a ) <NEWLINE> <NL> <NL> if ai % 2 == 0 : <NEWLINE> <INDENT> ai2 = ai // 2 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ai2 = ai // 2 <NEWLINE> <NL> <DEDENT> jj = bisect ( a , ai2 ) <NEWLINE> <NL> if jj + 1 < n : <NEWLINE> <INDENT> if abs ( a [ jj ] - ai2 ) > abs ( a [ jj + 1 ] - ai2 ) : <NEWLINE> <INDENT> jj2 = jj + 1 <NEWLINE> <DEDENT> <DEDENT> if jj - 1 >= 0 : <NEWLINE> <INDENT> if abs ( a [ jj ] - ai2 ) > abs ( a [ jj - 1 ] - ai2 ) : <NEWLINE> <INDENT> jj2 = jj - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if jj2 == n - 1 : <NEWLINE> <INDENT> jj2 = jj2 - 1 <NEWLINE> <NL> <DEDENT> aj = a [ jj2 ] <NEWLINE> <NL> print ( ai , aj ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> s . sort ( ) <NEWLINE> if <STRING> . join ( s ) = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if s [ 0 ] != s [ 1 ] & & s [ 1 ] != s [ 2 ] & & s [ 0 ] != s [ 2 ] else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> a = a . sort ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> S = sorted ( S ) <NEWLINE> if S = [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = sort ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> and s [ 1 ] == <STRING> and s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = [ input ( ) . split ( ) ] <NEWLINE> print ( <STRING> if len ( set ( s ) ) == 3 else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if set ( S ) == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ 0 ] == s [ 1 ] or s [ 1 ] == s [ 2 ] or s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B - A + 1 <= 2 * K : <NEWLINE> <INDENT> print ( * range ( A , B + 1 ) , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( range ( A , A + K ) ) <NEWLINE> b = list ( range ( B - K + 1 , B + 1 ) ) <NEWLINE> C = set ( a , b ) <NEWLINE> print ( * C , sep = <STRING> ) <NEWLINE> <DEDENT>
def actual ( A , B , K ) : <NEWLINE> <INDENT> min_left = A <NEWLINE> max_left = min ( A + ( K - 1 ) , B ) <NEWLINE> <NL> min_right = max ( B - ( K - 1 ) , max_left + 1 ) <NEWLINE> max_right = B <NEWLINE> <NL> left = set ( range ( min_left , max_left + 1 ) ) <NEWLINE> right = set ( range ( min_right , max_right + 1 ) ) <NEWLINE> <NL> unique_nums = left | right <NEWLINE> <NL> return <STRING> . join ( map ( str , sorted ( unique_nums ) ) ) <NEWLINE> <NL> <DEDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( actual_TLE ( A , B , K ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in rangea ( a , k + a ) : <NEWLINE> <INDENT> if a <= i <= b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in rangea ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if a <= i <= b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = list ( set ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = b - a + 1 <NEWLINE> if n <= k * 2 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , k + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> fot j in range ( b - k + 1 , b + 1 ) <NEWLINE> print ( j ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a + 1 > k * 2 : <NEWLINE> <INDENT> print ( [ a : a + k ] + [ b - k : b ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( [ a : b ] , end = <STRING> ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> enda = min ( a + n , b ) <NEWLINE> stab = max ( a , b - n ) <NEWLINE> C = sorted ( set ( list ( range ( a , enda ) ) ) | set ( list ( range ( stab + 1 : b + 1 ) ) ) ) <NEWLINE> for i in C : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) ; r = range ( a , b + 1 ) ; print ( * sorted ( { * ( r [ : k ] + r [ - k : ] ) } ) ) <NEWLINE>
2 9 100 <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a + 1 > 2 k : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> even += A % 2 + B % 2 + C % 2 <NEWLINE> answer = 0 <NEWLINE> if even == 1 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> if A % 2 : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> if B % 2 : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> if C % 2 : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> <DEDENT> elif even == 2 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> if not A % 2 : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> if not B % 2 : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> if not C % 2 : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> <DEDENT> D = sorted ( [ A , B , C ] ) <NEWLINE> answer += ( D [ 2 ] - D [ 0 ] ) // 2 + ( D [ 2 ] - D [ 1 ] ) // 2 <NEWLINE>
List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List . sort ( ) <NEWLINE> res = List [ 2 ] - List [ 1 ] <NEWLINE> Litt [ 1 ] = List [ 2 ] <NEWLINE> List [ 0 ] += res <NEWLINE> mid = List [ 2 ] - List [ 0 ] <NEWLINE> if mid % 2 == 1 : <NEWLINE> <INDENT> res += mid // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += mid // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> m1 , m2 = y [ n // 2 - 1 ] , y [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> if i <= m1 : print ( m2 ) <NEWLINE> else : print ( m1 ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> if a > b : a , b = b , a <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( 2 * a - 2 ) <NEWLINE> <DEDENT> elif a + 1 == b : <NEWLINE> <INDENT> print ( 2 * a - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = int ( ( a * b ) ** 0.5 ) <NEWLINE> if c * ( c + 1 ) >= a * b : <NEWLINE> <INDENT> print ( 2 * c - 2 ) <NEWLINE> <DEDENT> elif c ** 2 < a * b : <NEWLINE> <INDENT> print ( 2 * c - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> from math import floor <NEWLINE> for a , b in ab : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if a == b : <NEWLINE> <INDENT> print ( 2 * a - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> t = floor ( ( a * b ) ** 0.5 ) <NEWLINE> <COMMENT> <NL> if t * t >= a * b : <NEWLINE> <COMMENT> <NL> <INDENT> print ( 2 * t - 3 ) <NEWLINE> <DEDENT> elif t * ( t + 1 ) >= a * b : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( 2 * t - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( 2 * t - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
lst = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> <NL> mval = lst [ - 1 ] <NEWLINE> sval = sum ( lst ) <NEWLINE> cn = mval + ( sval - mval ) % 2 <NEWLINE> n = ( cn * 3 - sval ) // 2 <NEWLINE> print ( n ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> m = list ( <STRING> ) <NEWLINE> if len ( s ) < 26 : <NEWLINE> <INDENT> for i in m [ : : - 1 ] : <NEWLINE> <INDENT> if not j in s : <NEWLINE> <INDENT> s . append ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ - 1 ] <NEWLINE> for i in range ( 25 ) [ : : - 1 ] : <NEWLINE> <INDENT> if x > s [ i ] : <NEWLINE> <INDENT> s = s [ : i ] <NEWLINE> s . append ( x ) <NEWLINE> break <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> z = m . index ( s [ 0 ] ) <NEWLINE> s = m [ z - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if len ( s ) != 26 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if t [ i ] not in s : <NEWLINE> <INDENT> s . append ( t [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> . join ( s ) == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> a . append ( s [ 25 - i ] ) <NEWLINE> for j in a : <NEWLINE> <INDENT> if s < s [ : 25 - i ] + j : <NEWLINE> <INDENT> print ( s [ : 25 - i ] + j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> abc = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> if s == <STRING> . join ( abc ) [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( s ) != 26 : <NEWLINE> <INDENT> for a in abc : <NEWLINE> <INDENT> if a not in abc : <NEWLINE> <INDENT> print ( s + a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = 25 <NEWLINE> while s [ i - 1 ] > s [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> tt = s [ i - 1 ] <NEWLINE> ss = list ( s [ i - 1 : ] ) <NEWLINE> ss . sort ( ) <NEWLINE> print ( s [ : i - 1 ] + ss [ ss . index ( tt ) + 1 ] ) <NEWLINE>
A , B , C , D = int ( input ( ) ) <NEWLINE> <NL> train = [ A , B ] <NEWLINE> bus = [ C , D ] <NEWLINE> <NL> print ( min ( train ) + min ( bus ) ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A <= B : <NEWLINE> <INDENT> train = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> train = B <NEWLINE> <DEDENT> if C <= D : <NEWLINE> <INDENT> bus = C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bus = D <NEWLINE> <NL> <DEDENT> answer = train + bus <NEWLINE> print ( answer ) <NEWLINE>
a = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> if a <= b : <NEWLINE> <INDENT> if c <= d : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c <= d : <NEWLINE> <INDENT> print ( b + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b + d ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> A , B , C , D = MAP ( ) <NEWLINE> print ( min ( [ A , B ] ) + min ( [ C , D ] ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( mix ( a , b ) + min ( c , d ) ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> if a >= b : <NEWLINE> <INDENT> if c >= d : <NEWLINE> <INDENT> print ( b + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b + c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c >= d : <NEWLINE> <INDENT> print ( a + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( A , B ) + min ( C , D ) ) <NEWLINE>
a , b , c , d = [ int ( input ( ) ) for_ in range ( 4 ) ] <NEWLINE> print ( min ( a , b ) + min ( c , d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> res = x <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> res += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += ( d - 1 ) // a + 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> a , b , c , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> gokei1 = a + b <NEWLINE> gokei2 = a + c <NEWLINE> gokei3 = a + d <NEWLINE> gokei4 = b + c <NEWLINE> gokei5 = b + d <NEWLINE> gokei6 = c + d <NEWLINE> <NL> resalt = [ gokei1 , gokei2 , gokei3 , gokei4 , gokei5 , gokei6 ] <NEWLINE> print ( min ( resalt ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( sum ( min ( a , b ) , min ( c , d ) ) ) <NEWLINE>
B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> <NL> if A <= B : <NEWLINE> <INDENT> densya = A <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> densya = B <NEWLINE> <NL> <DEDENT> if C <= D : <NEWLINE> <INDENT> bus = C <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> bus = D <NEWLINE> <NL> <DEDENT> untin = densya + bus <NEWLINE> <NL> print ( untin ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( A , B ) + min ( C , D ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( a , b ) + min ( c , d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = [ ] <NEWLINE> cnt = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = 1 <NEWLINE> while b [ i ] <= d : <NEWLINE> <INDENT> b [ i ] += a [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt + x ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b , c = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = [ int ( input ( ) ) i in range ( a ) <NEWLINE> <INDENT> e = e + int ( ( b - 1 ) / d [ i ] ) + 1 <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D , X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = X <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> l = 1 <NEWLINE> while a <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = l * A [ i ] + 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) N = int ( input ( ) ) <NEWLINE> D , X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = X <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> l = 1 <NEWLINE> while a <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = l * A [ i ] + 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> D , X = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> As = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> day = 0 <NEWLINE> j = 0 <NEWLINE> while day <= D : <NEWLINE> <INDENT> day = j * As [ i ] + 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
5 <NEWLINE> 30 44 <NEWLINE> 26 <NEWLINE> 18 <NEWLINE> 81 <NEWLINE> 18 <NEWLINE> 6 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D , X = map ( int , input ( ) . spilt ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans += ( D - 1 ) // A [ i ] + 1 <NEWLINE> <DEDENT> print ( ans + X ) <NEWLINE>
jfrom math import gcd <NEWLINE> <NL> from math import factorial as f <NEWLINE> <NL> from math import ceil , floor , sqrt <NEWLINE> import math <NEWLINE> <NL> import bisect <NEWLINE> import re <NEWLINE> import heapq <NEWLINE> <NL> from copy import deepcopy <NEWLINE> import itertools <NEWLINE> from itertools import permutations <NEWLINE> <NL> from sys import exit <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> yes = <STRING> <NEWLINE> no = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> d , x = mi ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = ii ( ) <NEWLINE> a . append ( tmp ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while tmp <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> tmp += i <NEWLINE> <DEDENT> <DEDENT> ans += x <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def actual ( N , D , X , A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for a_i in A : <NEWLINE> <INDENT> for i in range ( 100 + 1 ) : <NEWLINE> <INDENT> eating_day = 1 + ( a_i * i ) <NEWLINE> <NL> if eating_day <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return X + count <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> D , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ) for _ in range ( N ) ] <NEWLINE> <NL> print ( actual ( N , D , X , A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + a + [ 0 ] <NEWLINE> <NL> d_1 = [ ] <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> d_1 . append ( abs ( a [ i ] - a [ i - 1 ] ) ) <NEWLINE> <DEDENT> d_2 = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d_2 . append ( abs ( a [ i + 1 ] - a [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> s_d = sum ( d_1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( s_d - d_1 [ i ] - d_1 [ i + 1 ] + d_2 [ i ] ) <NEWLINE> <DEDENT>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = abs ( A [ 0 ] ) + abs ( A [ N - 1 ] ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> j += abs ( A [ i ] - A [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = j - abs ( A [ 0 ] ) - abs ( A [ 0 ] - A [ 1 ] ) + abs ( A [ 1 ] ) <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> ans = j - abs ( A [ N - 2 ] - A [ N - 1 ] ) - abs ( A [ N - 1 ] ) + abs ( A [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = j - abs ( A [ i ] - A [ i - 1 ] ) - abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i - 1 ] - A [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = tuple ( [ 0 , ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 , ] ) <NEWLINE> D = [ ] <NEWLINE> sum = 0 <NEWLINE> for i , a in enumarate ( A [ 1 : - 1 ] ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> pre = A [ i - 1 ] <NEWLINE> tem = A [ i ] <NEWLINE> nex = A [ i + 1 ] <NEWLINE> x = abs ( pre - tem ) + abs ( tem - nex ) <NEWLINE> sum += x <NEWLINE> D . append ( abs ( pre - nex ) - x ) <NEWLINE> <DEDENT> for d in D : <NEWLINE> <INDENT> print ( sum + d ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ac = a <NEWLINE> del ac [ i ] <NEWLINE> for j in range ( 0 , n ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> ans [ i ] += abs ( ac [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += abs ( ac [ j ] - ac [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in ans : <NEWLINE> <INDENT> print ( str ( k ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> l = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> ans = 0 <NEWLINE> pre = 0 <NEWLINE> for i in l : ans += abs ( pre - i ) ; pre = i <NEWLINE> for i in range ( 1 , int ( n ) + 1 ) : <NEWLINE> <INDENT> dif = - abs ( l [ i ] - l [ i - 1 ] ) - abs ( l [ i ] - l [ i + 1 ] ) + abs ( l [ i - 1 ] - l [ i + 1 ] ) <NEWLINE> if l [ i ] in ( l [ i - 1 ] , l [ i + 1 ] ) : print ( ans ) <NEWLINE> elif l [ i ] < l [ i - 1 ] : <NEWLINE> <INDENT> print ( ans if l [ i + 1 ] < l [ i ] else ans + dif ) <NEWLINE> <DEDENT> else : print ( ansans if l [ i + 1 ] > l [ i ] else ans + dif ) <NEWLINE> <DEDENT>
line = <STRING> . join ( [ <STRING> ] * 50 ) <NEWLINE> dot = [ <STRING> , <STRING> ] <NEWLINE> cl = [ <STRING> . join ( [ <STRING> ] * 100 ) , <STRING> . join ( [ <STRING> ] * 100 ) ] <NEWLINE> ba = [ b - 1 , a - 1 ] <NEWLINE> ans = [ ] <NEWLINE> for c in [ 0 , 1 ] : <NEWLINE> <INDENT> ans . append ( cl [ c ] ) <NEWLINE> for i in range ( ba [ c ] // 50 ) : <NEWLINE> <INDENT> ans . append ( line ) <NEWLINE> ans . append ( cl [ c ] ) <NEWLINE> <DEDENT> ans . append ( <STRING> . join ( [ <STRING> ] * ( ba [ c ] % 50 ) ) + cl [ c ] [ ( ba [ c ] % 50 ) * 2 : ] ) <NEWLINE> ans . append ( cl [ c ] ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE> for l in ans : print ( <STRING> . join ( l ) ) <NEWLINE>
a , b , c = int ( input ( ) ) <NEWLINE> if a + b >= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if sum ( A , B ) >= C else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) if c = < a + b else print ( <STRING> ) <NEWLINE>
a , s , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a + b >= c else <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if A + B * 2 >= C else <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> <NL> if A + B >= C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input . split ( ) ) <NEWLINE> if a + b = > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> d [ input ( ) ] += 1 <NEWLINE> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> d [ input ( ) ] -= 1 <NEWLINE> <DEDENT> print ( max ( 0 , d . values ( ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( x ) ] <NEWLINE> y = int ( input ( ) ) <NEWLINE> b = [ input ( ) for h in range ( y ) ] <NEWLINE> <NL> count_max = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if ( a . count ( j ) - b . count ( j ) ) > count_max : <NEWLINE> <INDENT> a . count ( j ) - b . count ( j ) = count_max <NEWLINE> <DEDENT> <DEDENT> print ( count_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> T1 = [ x + <STRING> for x in T ] <NEWLINE> arr = S + T1 <NEWLINE> list1 = [ ] <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] not <NEWLINE> <NL> <DEDENT> list2 = [ ] in list2 : <NEWLINE> <INDENT> s = arr . count ( arr [ i ] ) <NEWLINE> t = arr . count ( arr [ i ] + <STRING> ) <NEWLINE> a = s - t <NEWLINE> list1 . append ( ( arr [ i ] , a ) ) <NEWLINE> list2 . append ( arr [ i ] ) <NEWLINE> <NL> <DEDENT> for i in list1 : <NEWLINE> <NL> <INDENT> if i [ 0 ] . endswith ( <STRING> ) : <NEWLINE> <INDENT> list1 . remove ( i ) <NEWLINE> <DEDENT> print ( list1 ) <NEWLINE> <NL> <DEDENT> ans1 = max ( list1 , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> if int ( ans1 [ 1 ] ) <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> print ( max ( 0 , max ( s . count ( i ) - t . count ( i ) for i in set ( s ) ) ) ) <NEWLINE> <NL> <NL> <NL>
def resolve ( ) : <NEWLINE> <INDENT> A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( ) <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> t = list ( ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> for a in range ( m ) : <NEWLINE> <INDENT> t . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> kind = list ( set ( s ) ) <NEWLINE> kind_length = len ( kind ) <NEWLINE> <NL> counter = dict ( ) <NEWLINE> for a in range ( kind_length ) : <NEWLINE> <INDENT> counter [ kind [ a ] ] = 0 <NEWLINE> <NL> <DEDENT> for a in range ( n ) : <NEWLINE> <INDENT> counter [ s [ a ] ] += 1 <NEWLINE> <NL> <DEDENT> for a in range ( m ) : <NEWLINE> <INDENT> if t [ a ] not in counter : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ t [ a ] ] -= 1 <NEWLINE> <NL> <DEDENT> print ( max ( counter . values ( ) , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ input ( ) for i in range ( m ) ] <NEWLINE> <NL> s = set ( s ) <NEWLINE> tot = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> tot = max ( s . count ( i ) - t . count ( i ) , tot ) <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ input ( ) for _ in range ( m ) ] <NEWLINE> <NL> res = 0 <NEWLINE> for i in set ( s ) : <NEWLINE> <INDENT> res = max ( s . count ( i ) - t . count ( i ) , ans ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> blue = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> red = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> l = list ( set ( blue ) ) <NEWLINE> print ( max ( 0 , max ( blue . count ( l [ i ] ) - red . count ( l [ i ] ) for i in range ( len ( l ) ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for _ in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ str ( input ( ) ) for _ in range ( m ) ] <NEWLINE> s = collections . Counter ( s ) <NEWLINE> t = collections . Counter ( t ) <NEWLINE> <NL> for k , j in t . items ( ) : <NEWLINE> <INDENT> if k in s : <NEWLINE> <INDENT> s [ k ] -= j <NEWLINE> <NL> <DEDENT> <DEDENT> values , counts = zip ( * s . most_common ( ) ) <NEWLINE> print ( max ( 0 , counts [ 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Red = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> Blue = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> switch = lambda X : ( X [ 1 ] , X [ 0 ] ) <NEWLINE> for b in Blue : <NEWLINE> <INDENT> C = [ switch ( r ) for r in Red if r < b ] <COMMENT> <NEWLINE> if len ( C ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> C . sorted ( reverse = True ) <NEWLINE> Red . remove ( switch ( C [ 0 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) . strip ( ) ) <NEWLINE> red = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> blue = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> red . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) , reverse = True ) <NEWLINE> blue . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> flg_r = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if flg_r [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if red [ j ] [ 0 ] < blue [ i ] [ 0 ] and red [ j ] [ 1 ] < blue [ i ] [ 1 ] : <NEWLINE> <INDENT> flg_a [ j ] = 1 <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ab = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> cd = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> ab . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> cd . sort ( ) <NEWLINE> <NL> a = 0 <NEWLINE> for c , d in cd : <NEWLINE> <INDENT> for a , b in ab : <NEWLINE> <INDENT> if a < c and b < d : <NEWLINE> <INDENT> a += 1 <NEWLINE> ab . remove ( [ a , b ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> R = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( N ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( N ) ] <NEWLINE> <NL> sorted ( R , key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> B . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for c , d in B : <NEWLINE> <INDENT> for a , b in R : <NEWLINE> <INDENT> if a < c and b < d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> R . remove ( [ a , b ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> reds = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> blues = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> <NL> reds = reds [ : : - 1 ] <NEWLINE> res = 0 <NEWLINE> <NL> for c , d in blues : <NEWLINE> <INDENT> for a , b in reds : <NEWLINE> <INDENT> if a < c and b < d : <NEWLINE> <INDENT> reds . remove ( [ a , b ] ) <NEWLINE> res += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> red = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> blue = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> red . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> blue . sort ( ) <NEWLINE> count = 0 <NEWLINE> for xb , yb in blue : <NEWLINE> <INDENT> for xr , yr in red : <NEWLINE> <INDENT> if xb > xr and yb > yr : <NEWLINE> <INDENT> red [ max_i ] = ( 201 , 201 ) <NEWLINE> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = list ( s ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if 26 - ( ord ( s [ i ] ) - ord ( <STRING> ) ) <= k : k -= 26 - ( ord ( s [ i ] ) - ord ( <STRING> ) ) ; l [ i ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( l [ : - 1 ] + list ( chr ( ( ord ( l [ - 1 ] ) - 97 + k ) % 26 + 97 ) ) ) ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a [ i ] = input ( ) <NEWLINE> <DEDENT> print ( a [ 0 ] [ 0 ] + a [ 1 ] [ 1 ] + a [ 2 ] [ 2 ] ) <NEWLINE>
a = list ( input ( ) . split ( ) ) <NEWLINE> b = list ( input ( ) . split ( ) ) <NEWLINE> c = list ( input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] + b [ 1 ] + c [ 2 ] ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> d , e , f = input ( ) . split ( ) <NEWLINE> g , h , i = input ( ) . split ( ) <NEWLINE> print ( a + e + i ) <NEWLINE>
U = input ( ) <NEWLINE> M = input ( ) <NEWLINE> B = input ( ) <NEWLINE> <NL> print ( U [ 0 ] . M [ 1 ] . B [ 2 ] ) <NEWLINE>
for i in range ( 3 ) <NEWLINE> <INDENT> A [ i ] = input ( ) <NEWLINE> <DEDENT> print ( A [ 0 ] [ 0 ] + A [ 1 ] [ 1 ] + A [ 2 ] [ 2 ] ) <NEWLINE>
x = list ( map ( input ( ) . split ( ) ) for i in range ( 3 ) ) <NEWLINE> print ( x [ 0 ] [ 0 ] + x [ 1 ] [ 1 ] + x [ 2 ] [ 2 ] ) <NEWLINE>
x = [ input ( ) for _ in range ( 3 ) ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( x [ i ] [ i ] , seq = <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> print ( a [ 0 ] + b [ 1 ] + c [ 2 ] ) <NEWLINE>
c1 = input ( ) . split ( ) <NEWLINE> c2 = input ( ) . split ( ) <NEWLINE> c3 = input ( ) . split ( ) <NEWLINE> print ( c1 [ 0 ] + c2 [ 1 ] + c3 [ 2 ] ) <NEWLINE>
31415 92653 <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i [ 0 ] == i [ 4 ] and i [ 1 ] == i [ 3 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> l = len ( x ) <NEWLINE> i = 0 <NEWLINE> while x [ i ] == x [ l - i - 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i > ( l // 2 ) : <NEWLINE> <INDENT> return True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> A , B = map ( input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if f ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i [ 0 ] == i [ 4 ] and i [ 1 ] == i [ 3 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> s = str ( i ) <NEWLINE> for j in range ( ( 3 ) : <NEWLINE> <INDENT> if s [ j ] != s [ - 1 - j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> s = list ( map ( str , i ) ) <NEWLINE> if s = reversed ( s ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , m = map ( int , inout ( ) . split ( ) ) <NEWLINE> if n * m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 1 or m == 1 : <NEWLINE> <INDENT> print ( n + m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n - 2 ) * ( m - 2 ) ) <NEWLINE> <DEDENT>
def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> a [ i ] [ j ] = f ( a [ i ] [ j ] ) <NEWLINE> a [ i ] [ j + 1 ] = f ( a [ i ] [ j + 1 ] ) <NEWLINE> a [ i ] [ j + 2 ] = f ( a [ i ] [ j + 2 ] ) <NEWLINE> a [ i + 1 ] [ j ] = f ( a [ i + 1 ] [ j ] ) <NEWLINE> a [ i + 1 ] [ j + 1 ] = f ( a [ i + 1 ] [ j + 1 ] ) <NEWLINE> a [ i + 1 ] [ j + 2 ] = f ( a [ i + 1 ] [ j + 2 ] ) <NEWLINE> a [ i + 2 ] [ j ] = f ( a [ i + 2 ] [ j ] ) <NEWLINE> a [ i + 2 ] [ j + 1 ] = f ( a [ i + 2 ] [ j + 1 ] ) <NEWLINE> a [ i + 2 ] [ j + 2 ] = f ( a [ i + 2 ] [ j + 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a [ 1 : N + 1 , 1 : M + 1 ] ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if N == M == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if N == 1 and M >= 2 : <NEWLINE> <INDENT> print ( M - 2 ) <NEWLINE> <DEDENT> if N == 2 and M >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if N >= 3 and M >= 3 : <NEWLINE> <INDENT> print ( ( N - 2 ) * ( M - 2 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> elif ( n == 1 ) or ( m == 1 ) : <NEWLINE> <INDENT> if ( n == 1 ) and ( m == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( 0 , max ( n , m ) - 2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n - 2 ) * ( m - 2 ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m - 2 ) <NEWLINE> <DEDENT> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> print ( n - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - 2 ) * ( M - 2 ) ) <NEWLINE> <DEDENT>
if N > 1 and M > 1 : <NEWLINE> <INDENT> four = 4 <NEWLINE> six = ( N - 2 ) * 2 + ( M - 2 ) * 2 <NEWLINE> nine = N * M - four - six <NEWLINE> print ( nine ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two = 2 <NEWLINE> three = N * M - two <NEWLINE> print ( three ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> S = s ( ) <NEWLINE> if len ( S ) == 26 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in alpha : <NEWLINE> <INDENT> if i not in S : <NEWLINE> <INDENT> print ( S + ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N = <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> groupnum = math . floor ( N / 3 ) <NEWLINE> <NL> <COMMENT> <NL> print ( groupnum ) <NEWLINE>
n = input ( ) <NEWLINE> print ( str ( n // 3 ) ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n // 3 ) <NEWLINE>
N = int ( intput ( ) ) <NEWLINE> <NL> print ( N // 3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> x == N // 3 <NEWLINE> <NL> print ( x ) <NEWLINE>
n = map ( int , input ( ) ) <NEWLINE> print ( n // 3 ) <NEWLINE>
print ( int ( input ) // 3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> if <STRING> , <STRING> , <STRING> , <STRING> in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 9 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = [ 0 ] * 4 <NEWLINE> N = i ( ) <NEWLINE> S = l ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 0 ] = 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 1 ] = 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 2 ] = 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 3 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( s ) ) <NEWLINE>
_ = input ( ) <NEWLINE> * S , = map ( int , input ( ) . split ( ) ) <NEWLINE> l = len ( set ( S ) ) <NEWLINE> if l == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( <STRING> if len ( set ( D ) ) == 4 else <STRING> ) <NEWLINE>
n , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( <STRING> [ len ( set ( s ) ) == 4 : : 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> <NL> if Y in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = set ( ) <NEWLINE> for s in S : <NEWLINE> <INDENT> X . add ( s ) <NEWLINE> <NL> <DEDENT> if len ( X ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = len ( set ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> if k = 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if l . count ( <STRING> ) > 0 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans ] ) <NEWLINE>
a = input ( ) <NEWLINE> b = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> if <STRING> in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = set ( L ) <NEWLINE> if len ( L ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( string , input ( ) . slipt ( ) ) ) <NEWLINE> <NL> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) ; print ( <STRING> if len ( set ( map ( input ( ) . split ( ) ) ) ) == 3 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sets = set ( lists ) <NEWLINE> ans = len ( sets ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s_l = set ( List ) <NEWLINE> if len ( s_l ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j , k in combinations ( <STRING> , 3 ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] * d [ k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
using System ; <NEWLINE> using static System . Console ; <NEWLINE> using System . Linq ; <NEWLINE> using System . Collections . Generic ; <NEWLINE> class Program <NEWLINE> { <NEWLINE> <INDENT> static void Main ( string [ ] args ) <NEWLINE> { <NEWLINE> <INDENT> int n = int . Parse ( ReadLine ( ) ) ; <NEWLINE> List < string > s = new List < string > ( ) ; <NEWLINE> <NL> for ( int i = 0 ; i < n ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> s . Add ( ReadLine ( ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> var hashSet = new HashSet < string > ( s ) ; <NEWLINE> s = hashSet . ToList ( ) ; <NEWLINE> List < int > ans = new List < int > ( ) ; <NEWLINE> <NL> for ( int i = 0 ; i < 5 ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> ans . Add ( 0 ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> for ( int i = 0 ; i < s . Count ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 0 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 1 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 2 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 3 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 4 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> int answ = 0 ; <NEWLINE> for ( int i = 0 ; i < 5 ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> for ( int j = i + 1 ; j < 5 ; j + + ) <NEWLINE> { <NEWLINE> <INDENT> for ( int k = j + 1 ; k < 5 ; k + + ) <NEWLINE> { <NEWLINE> <INDENT> if ( i != j & & j != k & & i != k ) <NEWLINE> { <NEWLINE> <INDENT> answ += ans [ i ] * ans [ j ] * ans [ k ] ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> WriteLine ( answ ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> common = common_function ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> m = [ 0 ] * 5 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) [ : - 1 ] <NEWLINE> Shead = S [ 0 ] <NEWLINE> for i , s0 in enumerate ( l ) : <NEWLINE> <INDENT> if Shead == s0 : <NEWLINE> <INDENT> m [ i ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ll = [ ] <NEWLINE> for i , n in enumerate ( m ) : <NEWLINE> <INDENT> if n >= 1 : <NEWLINE> <INDENT> ll . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( ll ) <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , j , k in itertools . combinations ( ll , 3 ) : <NEWLINE> <INDENT> ans += m [ l . index ( i ) ] * m [ l . index ( j ) ] * m [ l . index ( k ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> names = [ input ( ) for i in range ( n ) ] <NEWLINE> names = [ i for i in names if i [ 0 ] in <STRING> ] <NEWLINE> <NL> <NL> print ( len ( list ( itertools . combinations ( seq , 3 ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> Mnum = 0 <NEWLINE> Anum = 0 <NEWLINE> Rnum = 0 <NEWLINE> Cnum = 0 <NEWLINE> Hnum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Mnum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Anum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Rnum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Cnum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Hnum += 1 <NEWLINE> <DEDENT> <DEDENT> alist = [ ] <NEWLINE> alist . append ( Mnum ) <NEWLINE> alist . append ( Anum ) <NEWLINE> alist . append ( Rnum ) <NEWLINE> alist . append ( Cnum ) <NEWLINE> alist . append ( Hnum ) <NEWLINE> from itertools import combinations <NEWLINE> blist = list ( combinations ( alist , 3 ) ) <NEWLINE> from functools import reduce <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( blist ) ) : <NEWLINE> <INDENT> sum += reduce ( mul , blist [ i ] ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
import numpy as np <NEWLINE> from itertools <NEWLINE> from functools import reduce <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if c [ 0 ] in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> d [ c [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l = len ( d ) <NEWLINE> if l < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for l in list ( itertools . combinations ( d . values ( ) , 3 ) ) : <NEWLINE> <INDENT> ans += reduce ( np . multiply , l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> name = [ 0 ] * 5 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : name [ 0 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 1 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 2 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 3 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 4 ] += 1 <NEWLINE> <DEDENT> if sum ( name ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in combinations ( name , 3 ) : <NEWLINE> <INDENT> ans += i [ 0 ] * i [ 1 ] * i [ 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M_Dict = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> moji = str ( input ( ) ) <NEWLINE> if moji [ 0 ] in M_Dict . keys ( ) : <NEWLINE> <INDENT> M_Dict [ moji [ 0 ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> M_Dict = { k : v for k , v in M_Dict . items ( ) if v != 0 } <NEWLINE> if len ( M_Dict ) < 3 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for k in itertools . combinations ( list ( M_Dict . keys ( ) ) , 3 ) : <NEWLINE> <INDENT> ans += M_Dict [ k [ 0 ] ] * M_Dict [ k [ 1 ] ] * M_Dict [ [ 2 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def dfs ( H , W , D , A , Q , LR , ans ) : <NEWLINE> <INDENT> position = [ ( - 1 , - 1 ) ] * ( H * W + 1 ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> position [ A [ h ] [ w ] ] = ( h , w ) <NEWLINE> <NL> <DEDENT> <DEDENT> mp = np . zeros ( shape = ( H * W + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 1 , H * W + 1 - D ) : <NEWLINE> <INDENT> h , w = position [ i ] <NEWLINE> y , x = position [ i + D ] <NEWLINE> mp [ i ] = abs ( x - w ) + abs ( y - h ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = LR [ i ] <NEWLINE> ans [ i ] = mp [ l : r : D ] . sum ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . zeros ( shape = ( H , W ) , dtype = np . int64 ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> A [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> LR = np . zeros ( shape = ( Q , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> LR [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> ans = np . zeros ( shape = Q , dtype = np . int64 ) <NEWLINE> dfs ( H , W , D , A , Q , LR , ans ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = np . zeros ( [ h , w ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> lr = np . zeros ( [ q , 2 ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> lr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> cnt = h * w <NEWLINE> result = [ [ 0 ] for _ in range ( d ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> l = i <NEWLINE> score = 0 <NEWLINE> while l + d <= cnt : <NEWLINE> <INDENT> if l == 0 : <NEWLINE> <INDENT> result [ i ] . append ( score ) <NEWLINE> l += d <NEWLINE> continue <NEWLINE> <DEDENT> u = np . where ( arr == l ) <NEWLINE> v = np . where ( arr == l + d ) <NEWLINE> score += abs ( v [ 0 ] [ 0 ] - u [ 0 ] [ 0 ] ) + abs ( v [ 1 ] [ 0 ] - u [ 1 ] [ 0 ] ) <NEWLINE> result [ i ] . append ( score ) <NEWLINE> l += d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> result = solve ( h , w , d , arr ) <NEWLINE> <NL> <NL> for l , r in lr : <NEWLINE> <INDENT> ans = result [ l % d ] <NEWLINE> print ( ans [ r // d ] - ans [ l // d ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees <COMMENT> <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> H , W , D = MAP ( ) <NEWLINE> A = [ LIST ( ) for _ in range ( H ) ] <NEWLINE> <NL> dic = defaultdict ( tuple ) <NEWLINE> <NL> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> dic [ A [ y ] [ x ] ] = ( y + 1 , x + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> power = [ [ ] for _ in range ( D ) ] <NEWLINE> for i in range ( 1 , H * W + 1 ) : <NEWLINE> <INDENT> if i <= D : <NEWLINE> <INDENT> power [ i % D ] . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = i % D <NEWLINE> tmp = abs ( dic [ i ] [ 0 ] - dic [ i - D ] [ 0 ] ) + abs ( dic [ i ] [ 1 ] - dic [ i - D ] [ 1 ] ) <NEWLINE> power [ i % D ] . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> power_acc = [ ] <NEWLINE> for x in power : <NEWLINE> <INDENT> power_acc . append ( list ( accumulate ( x ) ) ) <NEWLINE> <NL> <DEDENT> Q = INT ( ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = MAP ( ) <NEWLINE> print ( power_acc [ R % D ] [ R // D ] - power_acc [ L % D ] [ L // D ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n <= 9 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> x = n [ 0 ] <NEWLINE> x = int ( x ) - 1 <NEWLINE> if n [ 1 : ] . count ( <STRING> ) == len ( n - 1 ) : <NEWLINE> <INDENT> print ( x + 1 ( len ( n ) - 1 ) * 9 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + ( len ( n ) - 1 ) * 9 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = len ( str ( n ) ) <NEWLINE> a = 9 * ( k - 1 ) <NEWLINE> b = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> b += int ( str ( n ) [ i ] ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> if k > 2 : <NEWLINE> <INDENT> m = str ( int ( n ) ) [ : k - 2 ] + str ( int ( int ( str ( n ) [ - 2 ] ) - 1 ) ) + <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c += int ( m [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( a , b , c ) <NEWLINE> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> ans1 = int ( n [ 0 ] ) <NEWLINE> for i in n : <NEWLINE> <INDENT> ans1 += int ( i ) <NEWLINE> <DEDENT> ans2 = int ( n [ 0 ] ) - 1 + 9 * ( len ( n ) - 1 ) <NEWLINE> print ( max ( ans1 , ans2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> sum = int ( n [ 0 ] ) + ( len ( n ) - 1 ) * 9 <NEWLINE> print ( sum if set ( n [ 1 : ] ) == { <STRING> } else sum - 1 ) <NEWLINE>
Num = str ( input ( ) ) <NEWLINE> L = len ( Num ) <NEWLINE> if Num [ 1 : ] == <STRING> * ( l - 1 ) : <NEWLINE> <INDENT> val = int ( Num [ 0 ] ) + 9 * ( l - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = int ( Num [ 0 ] ) - 1 + 9 * ( l - 1 ) <NEWLINE> <DEDENT> print ( val ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> if n [ : 1 ] == <STRING> * l - 1 : <COMMENT> <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + 9 * ( l - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( n [ 0 ] ) - 1 ) + ( 9 * ( l - 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> def ketawa ( x ) : <NEWLINE> <INDENT> return sum ( map ( int , list ( str ( x ) ) ) ) <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> <NL> if len ( N ) == 1 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pint ( max ( ketawa ( N ) , int ( N [ 0 ] ) - 1 + 9 * ( len ( N ) - 1 ) ) ) <NEWLINE> <DEDENT>
def maxf ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , list ( n ) ) ) <NEWLINE> for i , item in enumerate ( a ) : <NEWLINE> <INDENT> if i == 0 and item != 9 : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> a [ i + 1 : ] = [ 9 ] * ( len ( a ) - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif item != 9 : <NEWLINE> <INDENT> a [ i - 1 ] -= 1 <NEWLINE> a [ i : ] = [ 9 ] * ( len ( a ) - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return sum ( a ) <NEWLINE> <NL> <DEDENT> print ( maxf ( input ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = len ( str ( N ) ) <NEWLINE> NS = str ( N ) <NEWLINE> ans0 = 0 <NEWLINE> for i in range ( NS ) : <NEWLINE> <INDENT> ans0 += int ( i ) <NEWLINE> <DEDENT> ans1 = int ( NS [ 0 ] ) - 1 + 9 * ( n - 1 ) <NEWLINE> ans2 = 9 * ( n - 1 ) <NEWLINE> <NL> print ( max ( ans0 , ans1 , ans2 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> ans = [ sum ( map ( int , s ) ) , 9 * ( len ( s ) - 1 ) + int ( s [ 0 ] - 1 ) ] <NEWLINE> print ( max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 17 ) : <NEWLINE> <INDENT> if 10 ** i <= N < 10 ** ( i + 1 ) : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if ( 10 ** ( m - 1 ) ) * j + 10 ** ( m - 1 ) - 1 <= N < ( j + 1 ) * ( 10 ** ( m - 1 ) ) + 10 ** ( m - 1 ) - 1 : <NEWLINE> <INDENT> a = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a + 9 * ( m - 1 ) ) <NEWLINE>
n , k , p = map ( int , input ( ) . split ( ) ) , 998244353 <NEWLINE> r = range <NEWLINE> f = [ 1 ] <NEWLINE> for i in r ( k ) : f += [ - ~ i * f [ i ] ] <NEWLINE> print ( sum ( f [ - 1 ] * pow ( f [ i ] * f [ - 1 - i ] , - 1 , p ) for i in r ( n - 1 , k ) ) % p ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % 500 <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> l = [ int ( s ) for s in L ] <NEWLINE> list . sort ( l , reverse = True ) <NEWLINE> a = 0 <NEWLINE> x = 0 <NEWLINE> m = math . ceil ( N / 2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x += int ( l [ a ] ) <NEWLINE> a += 2 <NEWLINE> <DEDENT> a = 1 <NEWLINE> y = 0 <NEWLINE> for i in range ( N - m ) : <NEWLINE> <INDENT> y += int ( l [ a ] ) <NEWLINE> b += 2 <NEWLINE> <DEDENT> print ( x - y ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N // 500 <= A : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a % 500 = < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> if n % 500 <= a : <NEWLINE> <INDENT> plint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( <STRING> ) ) <NEWLINE> A = int ( input ( <STRING> ) ) <NEWLINE> <NL> b = n % 500 <NEWLINE> <NL> if A > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ int ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> n = a [ 0 ] % 500 <NEWLINE> if a >= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> <NL> amari = N % 500 <NEWLINE> if amari <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> if n % 500 <= a : <NEWLINE> <INDENT> plint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ n % 500 > a ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . sort ( reverse = True ) <NEWLINE> <NL> A = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 or i % 2 == 0 : <NEWLINE> <INDENT> A += lst [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += lst [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( A ) - int ( B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> print ( sum ( a [ 0 : : 2 ] - sum ( a [ 1 : : 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> res += 2 * min ( x , K - x ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( l [ 0 : : 2 ] ) - sum ( l [ 1 : : 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ ] <NEWLINE> print ( sum ( A [ - 1 : : - 2 ] ) - sum ( A [ - 2 : : - 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( key = int ) <NEWLINE> Ali = 0 <NEWLINE> Bob = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> Ali += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bob += a [ i ] <NEWLINE> <DEDENT> <DEDENT> ans ( Ali - Bob ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def sort_reverse ( n ) : <NEWLINE> <INDENT> n . sort ( reverse = True ) <NEWLINE> return n <NEWLINE> <NL> <DEDENT> N_Even = list ( range ( 0 , N + 1 , 2 ) ) <NEWLINE> N_Odd = list ( range ( 1 , N + 1 , 2 ) ) <NEWLINE> a1 = sort_reverse ( a ) <NEWLINE> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> <NL> for i in N_Even : <NEWLINE> <INDENT> sum1 += a1 [ i ] <NEWLINE> <DEDENT> for j in N_Odd : <NEWLINE> <INDENT> sum2 += a1 [ j ] <NEWLINE> <NL> <DEDENT> print ( sum1 - sum2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> diff = sum ( [ : : 2 ] ) - sum ( [ 1 : : 2 ] ) <NEWLINE> print ( diff ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> alice_sum = 0 <NEWLINE> bob_sum = 0 <NEWLINE> if len ( a ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( , n , 2 ) : <NEWLINE> <INDENT> bob_sum += a [ i ] <NEWLINE> <DEDENT> for l in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> alice_sum += a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( , n , 2 ) : <NEWLINE> <INDENT> alice_sum += a [ i ] <NEWLINE> <DEDENT> for k in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> bob_sum += a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice_sum - bob_sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> for num in range ( N + 1 ) : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> sum1 += A [ num ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum2 += A [ num ] <NEWLINE> <DEDENT> <DEDENT> print ( sum1 - sum2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = sorted ( A ) <NEWLINE> Alice = [ ] <NEWLINE> Bob = [ ] <NEWLINE> while len ( B ) != 0 or len ( B ) != 1 : <NEWLINE> <INDENT> Alice . append ( B [ - 1 ] ) <NEWLINE> B . pop ( ) <NEWLINE> Bob . append ( B [ - 1 ] ) <NEWLINE> B . pop ( ) <NEWLINE> <DEDENT> if len ( B ) == 1 : <NEWLINE> <INDENT> Alice . append ( B [ 0 ] ) <NEWLINE> B . pop ( ) <NEWLINE> <DEDENT> print ( sum ( Alice ) - sum ( Bob ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> Alice = sum ( a [ : : 2 ] ) <NEWLINE> Bob = sum ( a [ 1 : : 2 ] ) <NEWLINE> print ( Alice - ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sorted ( ) <NEWLINE> alice = 0 <NEWLINE> bob = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> alice += a [ i ] <NEWLINE> <DEDENT> elif i % 2 == 1 : <NEWLINE> <INDENT> bob += a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( a [ : : 2 ] ) - sum ( a [ 1 : : 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> a = sorted ( a ) [ : : - 1 ] <NEWLINE> Alice = 0 <NEWLINE> Bob = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> Alice += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bob += a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( Alice - Bob ) <NEWLINE> <NL>
<NL> <NL> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> bob = 0 <NEWLINE> alice = 0 <NEWLINE> sort_a = sorted ( a , reverse = True ) <NEWLINE> count = 0 <NEWLINE> for m in sort_a : <NEWLINE> <INDENT> if m % 2 == 0 : <NEWLINE> <INDENT> alice = alice + int ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bob = bob + int ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( int , input ( ) . split ( ) ) <NEWLINE> al = [ a [ 2 * i ] for i in range ( n // 2 ) ] <NEWLINE> bo = [ a [ 2 * i + 1 ] for i in range ( n // 2 ) ] <NEWLINE> print ( sum ( al ) - sum ( bo ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 != 0 : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> d = 0 <NEWLINE> <NL> for i in range ( int ( n / 2 ) : <NEWLINE> <INDENT> d += a [ 2 * i + 1 ] - a [ 2 * i ] <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_a . sort ( reverse = True ) <NEWLINE> alice = 0 ; bob = 0 <NEWLINE> for i in range ( 0 , 100 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> alice += list_a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bob += list_a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE> <NL>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> l = [ int ( s ) for s in L ] <NEWLINE> list . sort ( l , reverse = True ) <NEWLINE> a = 0 <NEWLINE> x = 0 <NEWLINE> m = math . ceil ( N / 2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x += int ( l [ a ] ) <NEWLINE> a += 2 <NEWLINE> <DEDENT> a = 1 <NEWLINE> y = 0 <NEWLINE> for i in range ( N - m ) : <NEWLINE> <INDENT> y += int ( l [ a ] ) <NEWLINE> b += 2 <NEWLINE> <DEDENT> print ( x - y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cards = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> alice = [ ] <NEWLINE> bob = [ ] <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> alice . append ( max ( cards [ i ] ) ) <NEWLINE> try : <NEWLINE> <INDENT> bob . append ( max ( cards [ i + 1 ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( alice ) - sum ( bob ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> alice = 0 <NEWLINE> bob = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> card = max ( a ) <NEWLINE> alice += card <NEWLINE> a . remove ( card ) <NEWLINE> if len ( a ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> card = max ( a ) <NEWLINE> bob += card <NEWLINE> a . remove ( card ) <NEWLINE> <NL> <DEDENT> print ( alice - bob ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) . sort ( reverse = True ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> answer += a [ i ] <NEWLINE> <DEDENT> for i in range ( 1 , N , 2 ) : <NEWLINE> <INDENT> answer -= a [ i ] <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
l = [ list ( map ( int , input ( ) ) ) for i in range ( 3 ) ] <NEWLINE> <NL> sum_l = 0 <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> sum_l += sum ( i ) <NEWLINE> <NL> <DEDENT> if sum_l % 3 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL>  <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> y1_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y2_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y3_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a1 = list ( ) <NEWLINE> a2 = list ( ) <NEWLINE> a3 = list ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a1 . append ( y1_list [ i ] - y2_list [ i ] ) <NEWLINE> a2 . append ( y2_list [ i ] - y3_list [ i ] ) <NEWLINE> <NL> <DEDENT> if a1 [ 0 ] == a1 [ 1 ] and a1 [ 2 ] == a1 [ 0 ] : <NEWLINE> <INDENT> if a2 [ 0 ] == a1 [ 1 ] and a2 [ 2 ] == a1 [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> if a [ 1 ] - a [ 0 ] == b [ 1 ] - b [ 0 ] == c [ 1 ] - c [ 0 ] and a [ 2 ] - a [ 1 ] == b [ 2 ] - b [ 1 ] == c [ 2 ] - c [ 1 ] : <NEWLINE> <INDENT> b [ 0 ] - a [ 0 ] == b [ 1 ] - a [ 1 ] == b [ 2 ] - b [ 2 ] and c [ 0 ] - b [ 0 ] == c [ 1 ] - b [ 1 ] == c [ 2 ] - b [ 2 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> x = l [ 0 ] [ 0 ] , y = l [ 0 ] [ 1 ] , z = l [ 0 ] [ 2 ] <NEWLINE> a = 0 , b = l [ 1 ] [ 0 ] - x , c = l [ 2 ] [ 0 ] - x <NEWLINE> if b + y == l [ 1 ] [ 1 ] and b + z == l [ 1 ] [ 2 ] and c + y == l [ 2 ] [ 1 ] and c + z == l [ 2 ] [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( c1 ) <NEWLINE> c1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = np . array ( c1 ) <NEWLINE> c1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = np . array ( c1 ) <NEWLINE> <NL> D = A - B <NEWLINE> D1 = list ( D ) <NEWLINE> D1 = set ( D1 ) <NEWLINE> if len ( D1 ) == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> E = B - C <NEWLINE> E1 = list ( E ) <NEWLINE> E1 = set ( E1 ) <NEWLINE> if len ( E1 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( - 1 <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( ) : <NEWLINE> <INDENT> d = [ [ float ( <STRING> ) ] * w for i in range ( h ) ] <NEWLINE> <NL> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( ( sx , sy ) ) <NEWLINE> d [ sx ] [ sy ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> if p [ 0 ] == gx and p [ 1 ] == gy : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = p [ 0 ] + dx [ i ] <NEWLINE> ny = p [ 1 ] + dy [ i ] <NEWLINE> <NL> if 0 <= nx < h and 0 <= ny < w and maze [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == float ( <STRING> ) : <NEWLINE> <INDENT> que . append ( ( nx , ny ) ) <NEWLINE> d [ nx ] [ ny ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d [ gx ] [ gy ] <NEWLINE> <NL> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> sx , sy = 0 , 0 <NEWLINE> gx , gy = h - 1 , w - 1 <NEWLINE> <NL> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = bfs ( ) <NEWLINE> if 0 < res < float ( <STRING> ) : <NEWLINE> <INDENT> print ( white - res - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def LSH ( h ) : <NEWLINE> <INDENT> return [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> <NL> <DEDENT> H , W = LI ( ) <NEWLINE> A = LSH ( H ) <NEWLINE> MAP = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> white = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S = A [ i ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> MAP [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAP [ i ] [ j ] = <STRING> <NEWLINE> white += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> d = deque ( ) <NEWLINE> d . append ( [ 0 , 0 ] ) <NEWLINE> looked = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> looked [ 0 ] [ 0 ] = 1 <NEWLINE> move = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> count = - 1 <NEWLINE> <NL> while d : <NEWLINE> <INDENT> h , w = d . popleft ( ) <NEWLINE> for i in move : <NEWLINE> <INDENT> a = h + i [ 0 ] <NEWLINE> b = w + i [ 0 ] <NEWLINE> if not ( 0 <= a < H ) or not ( 0 <= b < W ) or looked [ a ] [ b ] == 0 or MAP [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a == H - 1 and b == W - 1 : <NEWLINE> <INDENT> count = looked [ h ] [ w ] + 1 <NEWLINE> break <NEWLINE> <DEDENT> d . append ( [ a , b ] ) <NEWLINE> looked [ a ] [ b ] = looked [ h ] [ w ] + 1 <NEWLINE> <DEDENT> if count != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if count == - 1 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( white - count ) <NEWLINE>
<NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ list ( str ( input ( ) ) ) for i in range ( H ) ] <NEWLINE> <COMMENT> <NL> d = [ [ 0 for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> inf = 10 ** 6 <NEWLINE> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> d [ i ] [ j ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] [ j ] = inf <NEWLINE> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> d [ 0 ] [ 0 ] = 0 <NEWLINE> queue = collections . deque ( [ [ 0 , 0 ] ] ) <NEWLINE> gy , gx = H - 1 , W - 1 <NEWLINE> <NL> moves = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> flag = False <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = now [ 0 ] + moves [ i ] [ 0 ] <NEWLINE> nx = now [ 1 ] + moves [ i ] [ 1 ] <NEWLINE> <NL> if 0 <= ny and ny < H and 0 <= nx and nx < W and c [ ny ] [ nx ] == <STRING> and d [ ny ] [ nx ] == inf : <NEWLINE> <INDENT> d [ ny ] [ nx ] = d [ now [ 0 ] ] [ now [ 1 ] ] + 1 <NEWLINE> queue . append ( [ ny , nx ] ) <NEWLINE> if ny == gy and nx == gx : <NEWLINE> <INDENT> print ( ans - d [ ny ] [ nx ] - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( sy , sx , gy , gx ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ [ float ( <STRING> ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( ( sy , sx ) ) <NEWLINE> d [ sy ] [ sx ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <NL> <INDENT> p = que . popleft ( ) <NEWLINE> <NL> if p [ 0 ] == gy and p [ 1 ] == gx : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = p [ 0 ] + dy [ i ] <NEWLINE> nx = p [ 1 ] + dx [ i ] <NEWLINE> <NL> if 0 <= ny < h and 0 <= nx < w and maze [ ny ] [ nx ] != <STRING> and d [ ny ] [ nx ] == float ( <STRING> ) : <NEWLINE> <INDENT> que . append ( ( ny , nx ) ) <NEWLINE> d [ ny ] [ nx ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if d [ gy ] [ gx ] == float ( <STRING> ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ gy ] [ gx ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> res = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if maze [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dis = bfs ( 0 , 0 , h - 1 , w - 1 ) <NEWLINE> <NL> if dis == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h * w - res - dis - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from collections import deque <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = na ( ) <NEWLINE> g = [ [ 1 ] * ( w + 2 ) ] <NEWLINE> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> r = ns ( ) <NEWLINE> white += r . count ( <STRING> ) <NEWLINE> g . append ( [ 1 ] + [ 1 if s == <STRING> else 0 for s in r ] + [ 1 ] ) <NEWLINE> <DEDENT> g . append ( [ 1 ] * ( w + 2 ) ) <NEWLINE> q = deque ( [ [ 1 , 1 ] ] ) <NEWLINE> move = ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) ) <NEWLINE> while q : <NEWLINE> <INDENT> x , y = q . popleft ( ) <NEWLINE> for dx , dy in move : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if g [ nx ] [ ny ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> g [ nx ] [ ny ] = g [ x ] [ y ] + 1 <NEWLINE> q . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> <DEDENT> if g [ h ] [ w ] = 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( white - g [ h ] [ w ] - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ 0 ] * H <NEWLINE> num_black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> num_black += 1 <NEWLINE> <DEDENT> <DEDENT> grid [ i ] = list ( s ) <NEWLINE> <DEDENT> time_grid = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> time_grid [ 0 ] [ 0 ] = 0 <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( [ 0 , 0 , 0 ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , t = queue . popleft ( ) <NEWLINE> for next_y , next_x in [ [ y + 1 , x ] , [ y , x + 1 ] , [ y - 1 , x ] , [ y , x - 1 ] ] : <NEWLINE> <INDENT> if 0 <= next_x < W and 0 <= next_y < H and grid [ next_y ] [ next_x ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ next_y , next_x , t + 1 ] ) <NEWLINE> time_grid [ next_y ] [ next_x ] = t + 1 <NEWLINE> grid [ next_y ] [ next_x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if time_grid [ H ] [ W ] != - 1 : <NEWLINE> <INDENT> print ( H * W - time_grid [ - 1 ] [ - 1 ] - 1 - num_black ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ [ float ( <STRING> ) ] * w for i in range ( h ) ] <NEWLINE> <COMMENT> <NL> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <COMMENT> <NL> que = deque ( [ ] ) <NEWLINE> <COMMENT> <NL> que . append ( sx , sy ) <NEWLINE> <COMMENT> <NL> d [ sx ] [ sy ] = 0 <NEWLINE> <COMMENT> <NL> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> <COMMENT> <NL> if p [ 0 ] == gy and p [ 1 ] == gx : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = p [ 0 ] + dx [ i ] <NEWLINE> ny = p [ 1 ] + dy [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if 0 <= nx < r and 0 <= ny < c and maze [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> que . append ( ( nx , ny ) ) <NEWLINE> <COMMENT> <NL> d [ nx ] [ ny ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d [ gy ] [ gx ] <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> sx , sy = 0 , 0 <NEWLINE> gx , gy = h - 1 , w - 1 <NEWLINE> <NL> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = bfs ( ) <NEWLINE> if 0 < res < float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( white - res - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> z = [ [ <STRING> ] * W for _ in range ( H ) ] <COMMENT> <NEWLINE> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> black += s [ i ] . count ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT> v = [ [ 1 , 0 ] [ 0 , 1 ] [ - 1 , 0 ] [ 0 , - 1 ] ] <COMMENT> <NEWLINE> que = collections . deque ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> z [ 0 ] [ 0 ] = <STRING> <NEWLINE> s [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> que . append ( [ 0 , 0 ] ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> while len ( que ) != 0 : <COMMENT> <NEWLINE> <INDENT> i = que . popleft ( ) <COMMENT> <NEWLINE> for dy , dx in v : <COMMENT> <NEWLINE> <INDENT> y = i [ 0 ] + dy <NEWLINE> x = i [ 1 ] + dx <NEWLINE> if ( 0 <= y < H and 0 <= x < W and s [ y ] [ x ] == <STRING> and z [ y ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> z [ y ] [ x ] == <STRING> <NEWLINE> s [ y ] [ x ] == s [ i [ 0 ] ] [ i [ 1 ] ] + 1 <NEWLINE> que . append ( [ y , x ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if s [ - 1 ] [ - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( H * W - black - s [ - 1 ] [ - 1 ] ) <NEWLINE> <DEDENT>
def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> H , W = MI ( ) <NEWLINE> <COMMENT> <NL> Map = [ ] <NEWLINE> white = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> Map . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> def bfs ( ) : <NEWLINE> <INDENT> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dist = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 0 <NEWLINE> que = deque ( ) <NEWLINE> que . append ( ( 0 , ( 0 , 0 ) ) ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> d , ( x , y ) = que . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = x + dx [ i ] <NEWLINE> ny = y + dy [ i ] <NEWLINE> if 0 <= nx < H and 0 <= ny < W : <NEWLINE> <INDENT> if Map [ nx ] [ ny ] != <STRING> : <NEWLINE> <INDENT> if dist [ nx ] [ ny ] == INF : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = d + 1 <NEWLINE> que . append ( ( d + 1 , ( nx , ny ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <DEDENT> res = bfs ( ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = white - res [ H - 1 ] [ W - 1 ] - 1 <NEWLINE> if 0 < ans < INF : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
X , Y = map ( int . input ( ) . split ( ) ) <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X * Y - 1 ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> num = X <NEWLINE> l = 10 ** 18 <NEWLINE> while num <= l : <NEWLINE> <INDENT> if num % Y != 0 : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> num += X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) ) <NEWLINE> if x == y : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> a = i * x <NEWLINE> if a % y != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def L ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> [ x , y ] = L ( ) <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> b = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> ba = 0 , bb = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> ba += a [ i ] - b [ i ] <NEWLINE> <DEDENT> if b [ i ] > a [ i ] : <NEWLINE> <INDENT> bb += ( b [ i ] - a [ i ] ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if bb >= ba : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cou = 0 <NEWLINE> for j , k in zip ( a , b ) : <NEWLINE> <INDENT> if j < k : <NEWLINE> <INDENT> cou += ( k - j ) // 2 <NEWLINE> <DEDENT> elif j > k : <NEWLINE> <INDENT> cou -= ( j - k ) <NEWLINE> <DEDENT> <DEDENT> if cou = > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> k = suma - sumb <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> cnt += b [ i ] - a [ i ] <NEWLINE> <DEDENT> elif a [ i ] < b [ i ] : <NEWLINE> <INDENT> cnt += ( - 1 ) * ( ( a [ i ] - b [ i ] ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> u = d = z = r = 0 <NEWLINE> for i , j in zip ( a [ : n ] , a [ n : ] ) : <NEWLINE> <INDENT> if j - i > 0 : u += ( j - i ) // 2 * 2 ; r += ( j - i ) % 2 <NEWLINE> elif j - i == 0 : z += 1 <NEWLINE> else : d += [ j - i ] <NEWLINE> <DEDENT> print ( <STRING> if u + 2 * d >= 0 else <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> sm = 0 <NEWLINE> for x , y in zip ( a , b ) : <NEWLINE> <INDENT> tmp = x - y <NEWLINE> sm += tmp <NEWLINE> if tmp == - 1 <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> if tmp > 0 : <NEWLINE> <INDENT> tmp *= 2 <NEWLINE> <DEDENT> s += tmp <NEWLINE> <DEDENT> if s > 0 or sm > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import * <NEWLINE> from heapq import * <NEWLINE> ( n , m ) , a , * q = [ [ * map ( int , o . split ( ) ) ] for o in open ( 0 ) ] <NEWLINE> t = [ - 1 ] * n <NEWLINE> def r ( x ) : <NEWLINE> <INDENT> while t [ x ] >= 0 : x = t [ x ] <NEWLINE> return x <NEWLINE> <DEDENT> def u ( x , y ) : <NEWLINE> <INDENT> x , y = r ( x ) , r ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if t [ x ] > t [ y ] : x , y = y , x <NEWLINE> t [ x ] += t [ y ] ; t [ y ] = x <NEWLINE> <DEDENT> <DEDENT> d = defaultdict ( list ) <NEWLINE> for x , y in q : u ( x , y ) <NEWLINE> i = c = 0 ; b = [ ] ; k = ( n + ~ m ) * 2 ; p = print <NEWLINE> for v in a : d [ r ( i ) ] += v , ; i += 1 <NEWLINE> if k < 1 : p ( 0 ) <NEWLINE> elif k > n : p ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> for r , p in d . items ( ) : p . sort ( ) ; c += p . pop ( 0 ) ; b += p ; k -= 1 <NEWLINE> p ( c + sum ( sorted ( b ) [ : k ] ) ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xa = x - a <NEWLINE> xab = xa // b <NEWLINE> answer = xa - ( b * xab ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> af = x - a <NEWLINE> <NL> while af > 0 : <NEWLINE> <INDENT> af - b <NEWLINE> <NL> <DEDENT> print ( af ) <NEWLINE>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( ( x - a ) - ( b * ( ( x - a ) // b ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> i <NEWLINE>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE>
<NL> x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = ( x - a ) % b <NEWLINE> <NL> print ( answer ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a - b - ( c * ( ( a - b ) // c ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> in_n = lambda : int ( input ( ) ) <NEWLINE> in_nn = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> in_s = lambda : input ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in input ( ) if s != ord ( <STRING> ) ] <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 8 * 10 ** 18 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> X , A , B = in_nn ( ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> n = s [ 0 ] <NEWLINE> a = n [ 1 ] <NEWLINE> b = n [ 2 ] <NEWLINE> c = n - a <NEWLINE> d = int ( c / b ) <NEWLINE> print ( c - b * d ) <NEWLINE>
X , A , B = int ( input ( ) ) for i in range ( 3 ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> print ( x = a - b // c ) <NEWLINE>
<NL> X = input ( ) <NEWLINE> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> X -= A <NEWLINE> Y = X % B <NEWLINE> print ( Y ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
import math <NEWLINE> x , a , b = [ int ( input ( ) ) for i int range ( 3 ) ] <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for a500 in range ( A + 1 ) : <NEWLINE> <INDENT> for b100 in range ( B + 1 ) : <NEWLINE> <INDENT> for c50 in range ( C + 1 ) : <NEWLINE> <INDENT> if a500 * 500 + b100 * 100 + c50 * 50 = X : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
abc = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * i + 100 * j + 50 * k == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . open ( 0 ) . split ( ) ) <NEWLINE> print ( sum ( 500 * x + 100 * y + 50 * z == d for x in range ( a + 1 ) for y in range ( b + 1 ) for z in range ( c + 1 ) ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( A + 1 ) : <NEWLINE> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <INDENT> for c in range ( C + 1 ) : <NEWLINE> if X == 500 * a + 100 * b + 50 * c : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> ctypedef long long LL <NEWLINE> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> cdef LL a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> cdef LL i , j , k , _ <NEWLINE> <NL> <NL> cdef LL A = a_int ( ) <NEWLINE> cdef LL B = a_int ( ) <NEWLINE> cdef LL C = a_int ( ) <NEWLINE> cdef LL X = a_int ( ) <NEWLINE> <NL> <COMMENT> <NL> cdef LL a , b , c , ans <NEWLINE> for a in range ( A + 1 ) : <NEWLINE> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <INDENT> for c in range ( C + 1 ) : <NEWLINE> <INDENT> ans += ( 500 * a + 100 * b + 50 * c == X ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( 500 * i + 100 * j + 50 * k == D for i in range ( A + 1 ) for j in range ( B + 1 ) for k in range ( C + 1 ) ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for a in range ( A + 1 ) : <NEWLINE> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <INDENT> for c in range ( C + 1 ) : <NEWLINE> <INDENT> if a * 500 + b * 100 + c * 50 == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <COMMENT> <NEWLINE> b = input ( ) <COMMENT> <NEWLINE> c = input ( ) <COMMENT> <NEWLINE> x = input ( ) <COMMENT> <NEWLINE> <NL> counter = 0 <NEWLINE> for use_a in range ( a + 1 ) : <NEWLINE> <INDENT> if 500 * use_a > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rest = x - 500 * use_a <NEWLINE> for use_b in range ( b + 1 ) : <NEWLINE> <INDENT> if 100 * use_b > rest : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rest = rest - 100 * use_b <NEWLINE> for use_c in range ( c + 1 ) : <NEWLINE> <INDENT> if 50 * use_c != rest : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
a = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for ( i = 0 ; i <= a [ 0 ] ; i + + ) : <NEWLINE> <INDENT> for ( j = 0 ; j <= a [ 1 ] ; j + + ) : <NEWLINE> <INDENT> for ( k = 0 ; k <= a [ 2 ] ; k + + ) : <NEWLINE> <INDENT> sum = 500 * i + 100 * j + 50 * k <NEWLINE> if sum == a [ 3 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> for x in range ( a ) : <NEWLINE> <INDENT> for y in range ( b ) : <NEWLINE> <INDENT> for z in range ( c ) : <NEWLINE> <INDENT> if 500 x + 100 y + 50 z == s : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b , c , x = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> counta = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> ans = ( ( i * 500 + ( j * 100 + ( k * 50 ) <NEWLINE> if ans == x : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counta ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> s = 50 * c <NEWLINE> print ( len [ 1 for i in range ( a + 1 ) for m in range ( b + 1 ) if 0 <= x - 500 * i + 100 * m <= s ] ) <NEWLINE>
a , b , c , x = map ( int , [ input ( ) fot z in range ( 4 ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if i * 500 + j * 100 + k * 50 == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> pat = 0 <NEWLINE> for a in range ( A ) : <NEWLINE> <INDENT> for b in range ( B ) : <NEWLINE> <INDENT> for c in range ( C ) : <NEWLINE> <INDENT> if a * 500 + B * 100 + c * 50 == X : <NEWLINE> <INDENT> pat += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( pat ) <NEWLINE>
a , b , c , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * i + 100 * j + 50 * k == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 0 , A + 1 ) : <NEWLINE> <INDENT> y = X - 500 * a <NEWLINE> if y < 500 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for b in range ( 0 , B + 1 ) : <NEWLINE> <INDENT> z = y - 100 * b <NEWLINE> if z < 100 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in range ( 0 , C + 1 ) : <NEWLINE> <INDENT> w = z - 50 * a <NEWLINE> if w < 50 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if w != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = ( X - y ) / 500 <NEWLINE> e = ( y - z ) / 100 <NEWLINE> f = ( z - w ) / 50 <NEWLINE> i = - 1 <NEWLINE> for n in range ( 0 , d + 1 ) : <NEWLINE> <INDENT> if B - e - 5 * n >= 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> for m in range ( 0 , e + 5 * i ) : <NEWLINE> <INDENT> if C - f - 2 * m >= 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
c500 = int ( input ) <NEWLINE> c100 = int ( input ) <NEWLINE> c50 = int ( input ) <NEWLINE> x = int ( input ) <NEWLINE> count = 0 <NEWLINE> <NL> for c500_n in range ( 1 , c500 ) : <NEWLINE> <INDENT> for c100_n in range ( 1 , c100 ) : <NEWLINE> <INDENT> for c50_n in range ( 1 , c50 ) : <NEWLINE> <INDENT> if c500_n * 500 + c100_n * 100 + c50_n * 50 == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> counts = 0 <NEWLINE> for A in range ( a + 1 ) : <NEWLINE> <INDENT> for B in range ( b + 1 ) : <NEWLINE> <INDENT> for C in range ( c + 1 ) : <NEWLINE> <INDENT> if ( 500 * a + 100 * b + 50 * c ) == X : <NEWLINE> <INDENT> counts += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counts ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> c = int ( input ( <STRING> ) ) <NEWLINE> x = int ( input ( <STRING> ) ) <NEWLINE> def countcourse ( r , t , y , u ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for h in range ( r ) : <NEWLINE> <INDENT> for l in range ( t ) : <NEWLINE> <INDENT> for o range ( y ) : <NEWLINE> <INDENT> if 500 * h + 100 * l + 50 * o == u : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> print ( countcourse ( a , b , c , x ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> num_500 = 500 * i <NEWLINE> num_100 = 100 * j <NEWLINE> num_50 = 50 * k <NEWLINE> if num_500 + num_100 + num_50 == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
cnt = 0 <NEWLINE> for a in range ( A + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for c in range ( C + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( a * 500 + b * 100 + c * 50 ) == X : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if i * 500 + j * 100 + k * 50 == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) / 50 <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if i * 10 + j * 2 + k = x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x = int ( input ( ) ) for _ in range ( 4 ) <NEWLINE> <NL> ans = [ ( i , j , k ) for i in range ( a + 1 ) for j in range ( b + 1 ) for k in range ( c + 1 ) if 500 * i + 100 * j + 50 * k == x ] <NEWLINE> print ( len ( ans ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * a + 100 * b + 50 * c = x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
[ a , b , c , d ] = [ int ( input ( ) ) for i in range ( 1 , 4 + 1 ) ] <NEWLINE> a1 = d // 500 <NEWLINE> b1 = d // 100 <NEWLINE> c1 = d // 50 <NEWLINE> coun = 0 <NEWLINE> for i in range ( 0 , min ( [ a + 1 , a1 + 1 ] ) ) : <NEWLINE> <INDENT> a = 500 * i <NEWLINE> if a == d : <NEWLINE> <INDENT> coun = coun + 1 <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( 0 , min ( [ b + 1 , b1 + 1 - 5 * i ] ) ) : <NEWLINE> <INDENT> s = a + 100 * j <NEWLINE> if s == d : <NEWLINE> <INDENT> coun = coun + 1 <NEWLINE> break <NEWLINE> <DEDENT> for k in range ( 0 , min ( [ c + 1 , c1 + 1 - 10 * i - 2 * j ] ) : <NEWLINE> <INDENT> v = s + 50 * k <NEWLINE> if v == d : <NEWLINE> <INDENT> coun = coun + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( coun ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxn = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> maxn = max ( maxn , sum ( a [ : i + 1 ] , b [ i : ] ) ) <NEWLINE> <DEDENT> print ( maxn ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , sum ( a [ : i + 1 ] ) + sum ( b [ i : n ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( l [ 0 ] [ 0 ] + l [ 1 ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m1 = [ ] <NEWLINE> m2 = [ ] <NEWLINE> m1 . append ( l [ 0 ] [ 0 ] ) <NEWLINE> m2 . append ( l [ 1 ] [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> m1 . append ( m1 [ i - 1 ] + l [ 0 ] [ i ] ) <NEWLINE> m2 . append ( m2 [ i - 1 ] + l [ 1 ] [ i ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ans [ j ] = m1 [ j ] + ( m2 [ n - 1 ] - m2 [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( sum ( a [ 0 : i + 1 ] + sum ( b [ i : n ] ) ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import chain <NEWLINE> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a1 = chain ( tuple ( [ 0 ] ) , tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a2 = chain ( tuple ( [ 0 ] ) , tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> a1a = tuple ( accumulate ( a1 ) ) <NEWLINE> a2a = tuple ( accumulate ( a2 ) ) <NEWLINE> scores = deque ( ) <NEWLINE> for i1 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> scores . append ( [ i1 ] + a2a [ n ] - a2a [ i1 - 1 ] ) <NEWLINE> <DEDENT> r = max ( scores ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> candies_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> candies_j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> total_li = sum ( candies_i [ : count ] ) <NEWLINE> total_lj = sum ( candies_j [ += 1 : ] ) <NEWLINE> total = total_li + total_lj <NEWLINE> l . append ( total ) <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> s = 0 ; t = 0 ; u = 0 ; v = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( 0 , i + 1 ) : <NEWLINE> <INDENT> s += a [ 0 ] [ j ] <NEWLINE> t += a [ 1 ] [ j ] <NEWLINE> u += a [ 0 ] [ N - j - 1 ] <NEWLINE> v += a [ 1 ] [ N - j - 1 ] <NEWLINE> if s >= t and v >= u : <NEWLINE> print ( s + v ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list1 = [ ] <NEWLINE> ame = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> list1 . append ( sum ( A [ : i + 1 ] ) + sum ( B [ i : ] ) ) <NEWLINE> <NL> <DEDENT> if list1 = [ ] : <NEWLINE> <INDENT> print ( A [ 0 ] + b [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( list1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A1 [ 0 ] + A2 [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ansA1 = 0 <NEWLINE> ansA2 = 0 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ansA1 += A1 [ j ] <NEWLINE> <DEDENT> for k in range ( j , N ) : <NEWLINE> <INDENT> ansA2 += A2 [ k ] <NEWLINE> <DEDENT> ans1 = ansA1 + ansA2 <NEWLINE> ans . append ( ans1 ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT>
